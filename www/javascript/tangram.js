(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":39}],2:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":40}],3:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/is-iterable"), __esModule: true };
},{"core-js/library/fn/is-iterable":41}],4:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/map"), __esModule: true };
},{"core-js/library/fn/map":42}],5:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/math/log2"), __esModule: true };
},{"core-js/library/fn/math/log2":43}],6:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":44}],7:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":45}],8:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/object/define-properties"), __esModule: true };
},{"core-js/library/fn/object/define-properties":46}],9:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":47}],10:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/object/freeze"), __esModule: true };
},{"core-js/library/fn/object/freeze":48}],11:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/object/get-own-property-descriptor"), __esModule: true };
},{"core-js/library/fn/object/get-own-property-descriptor":49}],12:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":50}],13:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":51}],14:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/promise"), __esModule: true };
},{"core-js/library/fn/promise":52}],15:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/set"), __esModule: true };
},{"core-js/library/fn/set":53}],16:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":54}],17:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":55}],18:[function(_dereq_,module,exports){
"use strict";

exports["default"] = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

exports.__esModule = true;
},{}],19:[function(_dereq_,module,exports){
"use strict";

var _Object$defineProperty = _dereq_("babel-runtime/core-js/object/define-property")["default"];

exports["default"] = (function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;

      _Object$defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
})();

exports.__esModule = true;
},{"babel-runtime/core-js/object/define-property":9}],20:[function(_dereq_,module,exports){
"use strict";

var _Object$defineProperty = _dereq_("babel-runtime/core-js/object/define-property")["default"];

exports["default"] = function (obj, key, value) {
  if (key in obj) {
    _Object$defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/define-property":9}],21:[function(_dereq_,module,exports){
"use strict";

var _Object$getOwnPropertyDescriptor = _dereq_("babel-runtime/core-js/object/get-own-property-descriptor")["default"];

exports["default"] = function get(_x, _x2, _x3) {
  var _again = true;

  _function: while (_again) {
    var object = _x,
        property = _x2,
        receiver = _x3;
    _again = false;
    if (object === null) object = Function.prototype;

    var desc = _Object$getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        _x = parent;
        _x2 = property;
        _x3 = receiver;
        _again = true;
        desc = parent = undefined;
        continue _function;
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  }
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/get-own-property-descriptor":11}],22:[function(_dereq_,module,exports){
"use strict";

var _Object$create = _dereq_("babel-runtime/core-js/object/create")["default"];

var _Object$setPrototypeOf = _dereq_("babel-runtime/core-js/object/set-prototype-of")["default"];

exports["default"] = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = _Object$create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/create":7,"babel-runtime/core-js/object/set-prototype-of":13}],23:[function(_dereq_,module,exports){
"use strict";

exports["default"] = function (obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
};

exports.__esModule = true;
},{}],24:[function(_dereq_,module,exports){
"use strict";

var _getIterator = _dereq_("babel-runtime/core-js/get-iterator")["default"];

var _isIterable = _dereq_("babel-runtime/core-js/is-iterable")["default"];

exports["default"] = (function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = _getIterator(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (_isIterable(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
})();

exports.__esModule = true;
},{"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/is-iterable":3}],25:[function(_dereq_,module,exports){
"use strict";

var _Array$from = _dereq_("babel-runtime/core-js/array/from")["default"];

exports["default"] = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return _Array$from(arr);
  }
};

exports.__esModule = true;
},{"babel-runtime/core-js/array/from":1}],26:[function(_dereq_,module,exports){
(function (global){
// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g =
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this;

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = _dereq_("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

module.exports = { "default": module.exports, __esModule: true };

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID1cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IG1vZHVsZS5leHBvcnRzLCBfX2VzTW9kdWxlOiB0cnVlIH07XG4iXX0=
},{"./runtime":27}],27:[function(_dereq_,module,exports){
(function (process,global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

"use strict";

var _Symbol = _dereq_("babel-runtime/core-js/symbol")["default"];

var _Symbol$iterator = _dereq_("babel-runtime/core-js/symbol/iterator")["default"];

var _Object$create = _dereq_("babel-runtime/core-js/object/create")["default"];

var _Promise = _dereq_("babel-runtime/core-js/promise")["default"];

!(function (global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var iteratorSymbol = typeof _Symbol === "function" && _Symbol$iterator || "@@iterator";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided, then outerFn.prototype instanceof Generator.
    var generator = _Object$create((outerFn || Generator).prototype);

    generator._invoke = makeInvokeMethod(innerFn, self || null, new Context(tryLocsList || []));

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction ||
    // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    genFun.__proto__ = GeneratorFunctionPrototype;
    genFun.prototype = _Object$create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `value instanceof AwaitArgument` to determine if the yielded value is
  // meant to be awaited. Some may consider the name of this method too
  // cutesy, but they are curmudgeons.
  runtime.awrap = function (arg) {
    return new AwaitArgument(arg);
  };

  function AwaitArgument(arg) {
    this.arg = arg;
  }

  function AsyncIterator(generator) {
    // This invoke function is written in a style that assumes some
    // calling function (or Promise) will handle exceptions.
    function invoke(method, arg) {
      var result = generator[method](arg);
      var value = result.value;
      return value instanceof AwaitArgument ? _Promise.resolve(value.arg).then(invokeNext, invokeThrow) : _Promise.resolve(value).then(function (unwrapped) {
        // When a yielded Promise is resolved, its final value becomes
        // the .value of the Promise<{value,done}> result for the
        // current iteration. If the Promise is rejected, however, the
        // result for this iteration will be rejected with the same
        // reason. Note that rejections of yielded Promises are not
        // thrown back into the generator function, as is the case
        // when an awaited Promise is rejected. This difference in
        // behavior between yield and await is important, because it
        // allows the consumer to decide what to do with the yielded
        // rejection (swallow it and continue, manually .throw it back
        // into the generator, abandon iteration, whatever). With
        // await, by contrast, there is no opportunity to examine the
        // rejection reason outside the generator function, so the
        // only option is to throw it from the await expression, and
        // let the generator function handle the exception.
        result.value = unwrapped;
        return result;
      });
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var invokeNext = invoke.bind(generator, "next");
    var invokeThrow = invoke.bind(generator, "throw");
    var invokeReturn = invoke.bind(generator, "return");
    var previousPromise;

    function enqueue(method, arg) {
      var enqueueResult =
      // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(function () {
        return invoke(method, arg);
      }) : new _Promise(function (resolve) {
        resolve(invoke(method, arg));
      });

      // Avoid propagating enqueueResult failures to Promises returned by
      // later invocations of the iterator.
      previousPromise = enqueueResult["catch"](function (ignored) {});

      return enqueueResult;
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            context.sent = undefined;
          }
        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }
        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }
        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function stop() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
// Among the various tricks for obtaining a reference to the global
// object, this seems to be the most reliable technique that does not
// use indirect eval (which violates Content Security Policy).
typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : undefined);
}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL3J1bnRpbWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX1N5bWJvbCA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9TeW1ib2wkaXRlcmF0b3IgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBfT2JqZWN0JGNyZWF0ZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBfUHJvbWlzZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiKVtcImRlZmF1bHRcIl07XG5cbiEoZnVuY3Rpb24gKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciBpdGVyYXRvclN5bWJvbCA9IHR5cGVvZiBfU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgX1N5bWJvbCRpdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBnZW5lcmF0b3IgPSBfT2JqZWN0JGNyZWF0ZSgob3V0ZXJGbiB8fCBHZW5lcmF0b3IpLnByb3RvdHlwZSk7XG5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiB8fCBudWxsLCBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSkpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3IgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICBnZW5GdW4ucHJvdG90eXBlID0gX09iamVjdCRjcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGB2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnRgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLiBTb21lIG1heSBjb25zaWRlciB0aGUgbmFtZSBvZiB0aGlzIG1ldGhvZCB0b29cbiAgLy8gY3V0ZXN5LCBidXQgdGhleSBhcmUgY3VybXVkZ2VvbnMuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIG5ldyBBd2FpdEFyZ3VtZW50KGFyZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQXdhaXRBcmd1bWVudChhcmcpIHtcbiAgICB0aGlzLmFyZyA9IGFyZztcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgLy8gVGhpcyBpbnZva2UgZnVuY3Rpb24gaXMgd3JpdHRlbiBpbiBhIHN0eWxlIHRoYXQgYXNzdW1lcyBzb21lXG4gICAgLy8gY2FsbGluZyBmdW5jdGlvbiAob3IgUHJvbWlzZSkgd2lsbCBoYW5kbGUgZXhjZXB0aW9ucy5cbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZW5lcmF0b3JbbWV0aG9kXShhcmcpO1xuICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudCA/IF9Qcm9taXNlLnJlc29sdmUodmFsdWUuYXJnKS50aGVuKGludm9rZU5leHQsIGludm9rZVRocm93KSA6IF9Qcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkge1xuICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBpbnZva2VOZXh0ID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcIm5leHRcIik7XG4gICAgdmFyIGludm9rZVRocm93ID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInRocm93XCIpO1xuICAgIHZhciBpbnZva2VSZXR1cm4gPSBpbnZva2UuYmluZChnZW5lcmF0b3IsIFwicmV0dXJuXCIpO1xuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICB2YXIgZW5xdWV1ZVJlc3VsdCA9XG4gICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pIDogbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHJlc29sdmUoaW52b2tlKG1ldGhvZCwgYXJnKSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZW5xdWV1ZVJlc3VsdCBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieVxuICAgICAgLy8gbGF0ZXIgaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgcHJldmlvdXNQcm9taXNlID0gZW5xdWV1ZVJlc3VsdFtcImNhdGNoXCJdKGZ1bmN0aW9uIChpZ25vcmVkKSB7fSk7XG5cbiAgICAgIHJldHVybiBlbnF1ZXVlUmVzdWx0O1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIgfHwgbWV0aG9kID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIExpa2UgcmV0dXJuaW5nIGdlbmVyYXRvci50aHJvdyh1bmNhdWdodCksIGJ1dCB3aXRob3V0IHRoZVxuICAgICAgICAgICAgLy8gb3ZlcmhlYWQgb2YgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCkge1xuICAgICAgICAgICAgY29udGV4dC5zZW50ID0gYXJnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IEdlblN0YXRlQ29tcGxldGVkIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlICYmIG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICB0aGlzLnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJiAodHlwZSA9PT0gXCJicmVha1wiIHx8IHR5cGUgPT09IFwiY29udGludWVcIikgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHwgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbi8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbi8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbnR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdW5kZWZpbmVkKTsiXX0=
},{"_process":188,"babel-runtime/core-js/object/create":7,"babel-runtime/core-js/promise":14,"babel-runtime/core-js/symbol":16,"babel-runtime/core-js/symbol/iterator":17}],28:[function(_dereq_,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],29:[function(_dereq_,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],30:[function(_dereq_,module,exports){
'use strict'

module.exports = boxIntersectWrapper

var pool = _dereq_('typedarray-pool')
var sweep = _dereq_('./lib/sweep')
var boxIntersectIter = _dereq_('./lib/intersect')

function boxEmpty(d, box) {
  for(var j=0; j<d; ++j) {
    if(!(box[j] <= box[j+d])) {
      return true
    }
  }
  return false
}

//Unpack boxes into a flat typed array, remove empty boxes
function convertBoxes(boxes, d, data, ids) {
  var ptr = 0
  var count = 0
  for(var i=0, n=boxes.length; i<n; ++i) {
    var b = boxes[i]
    if(boxEmpty(d, b)) {
      continue
    }
    for(var j=0; j<2*d; ++j) {
      data[ptr++] = b[j]
    }
    ids[count++] = i
  }
  return count
}

//Perform type conversions, check bounds
function boxIntersect(red, blue, visit, full) {
  var n = red.length
  var m = blue.length

  //If either array is empty, then we can skip this whole thing
  if(n <= 0 || m <= 0) {
    return
  }

  //Compute dimension, if it is 0 then we skip
  var d = (red[0].length)>>>1
  if(d <= 0) {
    return
  }

  var retval

  //Convert red boxes
  var redList  = pool.mallocDouble(2*d*n)
  var redIds   = pool.mallocInt32(n)
  n = convertBoxes(red, d, redList, redIds)

  if(n > 0) {
    if(d === 1 && full) {
      //Special case: 1d complete
      sweep.init(n)
      retval = sweep.sweepComplete(
        d, visit, 
        0, n, redList, redIds,
        0, n, redList, redIds)
    } else {

      //Convert blue boxes
      var blueList = pool.mallocDouble(2*d*m)
      var blueIds  = pool.mallocInt32(m)
      m = convertBoxes(blue, d, blueList, blueIds)

      if(m > 0) {
        sweep.init(n+m)

        if(d === 1) {
          //Special case: 1d bipartite
          retval = sweep.sweepBipartite(
            d, visit, 
            0, n, redList,  redIds,
            0, m, blueList, blueIds)
        } else {
          //General case:  d>1
          retval = boxIntersectIter(
            d, visit,    full,
            n, redList,  redIds,
            m, blueList, blueIds)
        }

        pool.free(blueList)
        pool.free(blueIds)
      }
    }

    pool.free(redList)
    pool.free(redIds)
  }

  return retval
}

//User-friendly wrapper, handle full input and no-visitor cases
function boxIntersectWrapper(arg0, arg1, arg2) {
  var result
  switch(arguments.length) {
    case 1:
      result = []
      boxIntersect(arg0, arg0, function(i,j) {
        result.push([i, j])
      }, true)
      return result
    case 2:
      if(typeof arg1 === 'function') {
        var visit = arg1
        return boxIntersect(arg0, arg0, visit, true)
      } else {
        result = []
        boxIntersect(arg0, arg1, function(i,j) {
          result.push([i, j])
        }, false)
        return result
      }
    case 3:
      return boxIntersect(arg0, arg1, arg2, false)
    default:
      throw new Error('box-intersect: Invalid arguments')
  }
}
},{"./lib/intersect":32,"./lib/sweep":36,"typedarray-pool":191}],31:[function(_dereq_,module,exports){
'use strict'

var DIMENSION   = 'd'
var AXIS        = 'ax'
var VISIT       = 'vv'
var FLIP        = 'fp'

var ELEM_SIZE   = 'es'

var RED_START   = 'rs'
var RED_END     = 're'
var RED_BOXES   = 'rb'
var RED_INDEX   = 'ri'
var RED_PTR     = 'rp'

var BLUE_START  = 'bs'
var BLUE_END    = 'be'
var BLUE_BOXES  = 'bb'
var BLUE_INDEX  = 'bi'
var BLUE_PTR    = 'bp'

var RETVAL      = 'rv'

var INNER_LABEL = 'Q'

var ARGS = [
  DIMENSION,
  AXIS,
  VISIT,
  RED_START,
  RED_END,
  RED_BOXES,
  RED_INDEX,
  BLUE_START,
  BLUE_END,
  BLUE_BOXES,
  BLUE_INDEX
]

function generateBruteForce(redMajor, flip, full) {
  var funcName = 'bruteForce' + 
    (redMajor ? 'Red' : 'Blue') + 
    (flip ? 'Flip' : '') +
    (full ? 'Full' : '')

  var code = ['function ', funcName, '(', ARGS.join(), '){',
    'var ', ELEM_SIZE, '=2*', DIMENSION, ';']

  var redLoop = 
    'for(var i=' + RED_START + ',' + RED_PTR + '=' + ELEM_SIZE + '*' + RED_START + ';' +
        'i<' + RED_END +';' +
        '++i,' + RED_PTR + '+=' + ELEM_SIZE + '){' +
        'var x0=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '],' +
            'x1=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '+' + DIMENSION + '],' +
            'xi=' + RED_INDEX + '[i];'

  var blueLoop = 
    'for(var j=' + BLUE_START + ',' + BLUE_PTR + '=' + ELEM_SIZE + '*' + BLUE_START + ';' +
        'j<' + BLUE_END + ';' +
        '++j,' + BLUE_PTR + '+=' + ELEM_SIZE + '){' +
        'var y0=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '],' +
            (full ? 'y1=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '+' + DIMENSION + '],' : '') +
            'yi=' + BLUE_INDEX + '[j];'

  if(redMajor) {
    code.push(redLoop, INNER_LABEL, ':', blueLoop)
  } else {
    code.push(blueLoop, INNER_LABEL, ':', redLoop)
  }

  if(full) {
    code.push('if(y1<x0||x1<y0)continue;')
  } else if(flip) {
    code.push('if(y0<=x0||x1<y0)continue;')
  } else {
    code.push('if(y0<x0||x1<y0)continue;')
  }

  code.push('for(var k='+AXIS+'+1;k<'+DIMENSION+';++k){'+
    'var r0='+RED_BOXES+'[k+'+RED_PTR+'],'+
        'r1='+RED_BOXES+'[k+'+DIMENSION+'+'+RED_PTR+'],'+
        'b0='+BLUE_BOXES+'[k+'+BLUE_PTR+'],'+
        'b1='+BLUE_BOXES+'[k+'+DIMENSION+'+'+BLUE_PTR+'];'+
      'if(r1<b0||b1<r0)continue ' + INNER_LABEL + ';}' +
      'var ' + RETVAL + '=' + VISIT + '(')

  if(flip) {
    code.push('yi,xi')
  } else {
    code.push('xi,yi')
  }

  code.push(');if(' + RETVAL + '!==void 0)return ' + RETVAL + ';}}}')

  return {
    name: funcName, 
    code: code.join('')
  }
}

function bruteForcePlanner(full) {
  var funcName = 'bruteForce' + (full ? 'Full' : 'Partial')
  var prefix = []
  var fargs = ARGS.slice()
  if(!full) {
    fargs.splice(3, 0, FLIP)
  }

  var code = ['function ' + funcName + '(' + fargs.join() + '){']

  function invoke(redMajor, flip) {
    var res = generateBruteForce(redMajor, flip, full)
    prefix.push(res.code)
    code.push('return ' + res.name + '(' + ARGS.join() + ');')
  }

  code.push('if(' + RED_END + '-' + RED_START + '>' +
                    BLUE_END + '-' + BLUE_START + '){')

  if(full) {
    invoke(true, false)
    code.push('}else{')
    invoke(false, false)
  } else {
    code.push('if(' + FLIP + '){')
    invoke(true, true)
    code.push('}else{')
    invoke(true, false)
    code.push('}}else{if(' + FLIP + '){')
    invoke(false, true)
    code.push('}else{')
    invoke(false, false)
    code.push('}')
  }
  code.push('}}return ' + funcName)

  var codeStr = prefix.join('') + code.join('')
  var proc = new Function(codeStr)
  return proc()
}


exports.partial = bruteForcePlanner(false)
exports.full    = bruteForcePlanner(true)
},{}],32:[function(_dereq_,module,exports){
'use strict'

module.exports = boxIntersectIter

var pool = _dereq_('typedarray-pool')
var bits = _dereq_('bit-twiddle')
var bruteForce = _dereq_('./brute')
var bruteForcePartial = bruteForce.partial
var bruteForceFull = bruteForce.full
var sweep = _dereq_('./sweep')
var findMedian = _dereq_('./median')
var genPartition = _dereq_('./partition')

//Twiddle parameters
var BRUTE_FORCE_CUTOFF    = 128       //Cut off for brute force search
var SCAN_CUTOFF           = (1<<22)   //Cut off for two way scan
var SCAN_COMPLETE_CUTOFF  = (1<<22)  

//Partition functions
var partitionInteriorContainsInterval = genPartition(
  '!(lo>=p0)&&!(p1>=hi)', 
  ['p0', 'p1'])

var partitionStartEqual = genPartition(
  'lo===p0',
  ['p0'])

var partitionStartLessThan = genPartition(
  'lo<p0',
  ['p0'])

var partitionEndLessThanEqual = genPartition(
  'hi<=p0',
  ['p0'])

var partitionContainsPoint = genPartition(
  'lo<=p0&&p0<=hi',
  ['p0'])

var partitionContainsPointProper = genPartition(
  'lo<p0&&p0<=hi',
  ['p0'])

//Frame size for iterative loop
var IFRAME_SIZE = 6
var DFRAME_SIZE = 2

//Data for box statck
var INIT_CAPACITY = 1024
var BOX_ISTACK  = pool.mallocInt32(INIT_CAPACITY)
var BOX_DSTACK  = pool.mallocDouble(INIT_CAPACITY)

//Initialize iterative loop queue
function iterInit(d, count) {
  var levels = (8 * bits.log2(count+1) * (d+1))|0
  var maxInts = bits.nextPow2(IFRAME_SIZE*levels)
  if(BOX_ISTACK.length < maxInts) {
    pool.free(BOX_ISTACK)
    BOX_ISTACK = pool.mallocInt32(maxInts)
  }
  var maxDoubles = bits.nextPow2(DFRAME_SIZE*levels)
  if(BOX_DSTACK < maxDoubles) {
    pool.free(BOX_DSTACK)
    BOX_DSTACK = pool.mallocDouble(maxDoubles)
  }
}

//Append item to queue
function iterPush(ptr,
  axis, 
  redStart, redEnd, 
  blueStart, blueEnd, 
  state, 
  lo, hi) {

  var iptr = IFRAME_SIZE * ptr
  BOX_ISTACK[iptr]   = axis
  BOX_ISTACK[iptr+1] = redStart
  BOX_ISTACK[iptr+2] = redEnd
  BOX_ISTACK[iptr+3] = blueStart
  BOX_ISTACK[iptr+4] = blueEnd
  BOX_ISTACK[iptr+5] = state

  var dptr = DFRAME_SIZE * ptr
  BOX_DSTACK[dptr]   = lo
  BOX_DSTACK[dptr+1] = hi
}

//Special case:  Intersect single point with list of intervals
function onePointPartial(
  d, axis, visit, flip,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    if(flip && blueX === r0) {
      continue
    }
    var redId = redIndex[i]
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval
    if(flip) {
      retval = visit(blueId, redId)
    } else {
      retval = visit(redId, blueId)
    }
    if(retval !== void 0) {
      return retval
    }
  }
}

//Special case:  Intersect one point with list of intervals
function onePointFull(
  d, axis, visit,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var redId = redIndex[i]
    if(redId === blueId) {
      continue
    }
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval = visit(redId, blueId)
    if(retval !== void 0) {
      return retval
    }
  }
}

//The main box intersection routine
function boxIntersectIter(
  d, visit, initFull,
  xSize, xBoxes, xIndex,
  ySize, yBoxes, yIndex) {

  //Reserve memory for stack
  iterInit(d, xSize + ySize)

  var top  = 0
  var elemSize = 2 * d
  var retval

  iterPush(top++,
      0,
      0, xSize,
      0, ySize,
      initFull ? 16 : 0, 
      -Infinity, Infinity)
  if(!initFull) {
    iterPush(top++,
      0,
      0, ySize,
      0, xSize,
      1, 
      -Infinity, Infinity)
  }

  while(top > 0) {
    top  -= 1

    var iptr = top * IFRAME_SIZE
    var axis      = BOX_ISTACK[iptr]
    var redStart  = BOX_ISTACK[iptr+1]
    var redEnd    = BOX_ISTACK[iptr+2]
    var blueStart = BOX_ISTACK[iptr+3]
    var blueEnd   = BOX_ISTACK[iptr+4]
    var state     = BOX_ISTACK[iptr+5]

    var dptr = top * DFRAME_SIZE
    var lo        = BOX_DSTACK[dptr]
    var hi        = BOX_DSTACK[dptr+1]

    //Unpack state info
    var flip      = (state & 1)
    var full      = !!(state & 16)

    //Unpack indices
    var red       = xBoxes
    var redIndex  = xIndex
    var blue      = yBoxes
    var blueIndex = yIndex
    if(flip) {
      red         = yBoxes
      redIndex    = yIndex
      blue        = xBoxes
      blueIndex   = xIndex
    }

    if(state & 2) {
      redEnd = partitionStartLessThan(
        d, axis,
        redStart, redEnd, red, redIndex,
        hi)
      if(redStart >= redEnd) {
        continue
      }
    }
    if(state & 4) {
      redStart = partitionEndLessThanEqual(
        d, axis,
        redStart, redEnd, red, redIndex,
        lo)
      if(redStart >= redEnd) {
        continue
      }
    }
    
    var redCount  = redEnd  - redStart
    var blueCount = blueEnd - blueStart

    if(full) {
      if(d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {
        retval = sweep.scanComplete(
          d, axis, visit, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    } else {
      if(d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {
        //If input small, then use brute force
        retval = bruteForcePartial(
            d, axis, visit, flip,
            redStart,  redEnd,  red,  redIndex,
            blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      } else if(d * redCount * blueCount < SCAN_CUTOFF) {
        //If input medium sized, then use sweep and prune
        retval = sweep.scanBipartite(
          d, axis, visit, flip, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    }
    
    //First, find all red intervals whose interior contains (lo,hi)
    var red0 = partitionInteriorContainsInterval(
      d, axis, 
      redStart, redEnd, red, redIndex,
      lo, hi)

    //Lower dimensional case
    if(redStart < red0) {

      if(d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {
        //Special case for small inputs: use brute force
        retval = bruteForceFull(
          d, axis+1, visit,
          redStart, red0, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
      } else if(axis === d-2) {
        if(flip) {
          retval = sweep.sweepBipartite(
            d, visit,
            blueStart, blueEnd, blue, blueIndex,
            redStart, red0, red, redIndex)
        } else {
          retval = sweep.sweepBipartite(
            d, visit,
            redStart, red0, red, redIndex,
            blueStart, blueEnd, blue, blueIndex)
        }
        if(retval !== void 0) {
          return retval
        }
      } else {
        iterPush(top++,
          axis+1,
          redStart, red0,
          blueStart, blueEnd,
          flip,
          -Infinity, Infinity)
        iterPush(top++,
          axis+1,
          blueStart, blueEnd,
          redStart, red0,
          flip^1,
          -Infinity, Infinity)
      }
    }

    //Divide and conquer phase
    if(red0 < redEnd) {

      //Cut blue into 3 parts:
      //
      //  Points < mid point
      //  Points = mid point
      //  Points > mid point
      //
      var blue0 = findMedian(
        d, axis, 
        blueStart, blueEnd, blue, blueIndex)
      var mid = blue[elemSize * blue0 + axis]
      var blue1 = partitionStartEqual(
        d, axis,
        blue0, blueEnd, blue, blueIndex,
        mid)

      //Right case
      if(blue1 < blueEnd) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blue1, blueEnd,
          (flip|4) + (full ? 16 : 0),
          mid, hi)
      }

      //Left case
      if(blueStart < blue0) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blueStart, blue0,
          (flip|2) + (full ? 16 : 0),
          lo, mid)
      }

      //Center case (the hard part)
      if(blue0 + 1 === blue1) {
        //Optimization: Range with exactly 1 point, use a brute force scan
        if(full) {
          retval = onePointFull(
            d, axis, visit,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        } else {
          retval = onePointPartial(
            d, axis, visit, flip,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        }
        if(retval !== void 0) {
          return retval
        }
      } else if(blue0 < blue1) {
        var red1
        if(full) {
          //If full intersection, need to handle special case
          red1 = partitionContainsPoint(
            d, axis,
            red0, redEnd, red, redIndex,
            mid)
          if(red0 < red1) {
            var redX = partitionStartEqual(
              d, axis,
              red0, red1, red, redIndex,
              mid)
            if(axis === d-2) {
              //Degenerate sweep intersection:
              //  [red0, redX] with [blue0, blue1]
              if(red0 < redX) {
                retval = sweep.sweepComplete(
                  d, visit,
                  red0, redX, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }

              //Normal sweep intersection:
              //  [redX, red1] with [blue0, blue1]
              if(redX < red1) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  redX, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }
            } else {
              if(red0 < redX) {
                iterPush(top++,
                  axis+1,
                  red0, redX,
                  blue0, blue1,
                  16,
                  -Infinity, Infinity)
              }
              if(redX < red1) {
                iterPush(top++,
                  axis+1,
                  redX, red1,
                  blue0, blue1,
                  0,
                  -Infinity, Infinity)
                iterPush(top++,
                  axis+1,
                  blue0, blue1,
                  redX, red1,
                  1,
                  -Infinity, Infinity)
              }
            }
          }
        } else {
          if(flip) {
            red1 = partitionContainsPointProper(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          } else {
            red1 = partitionContainsPoint(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          }
          if(red0 < red1) {
            if(axis === d-2) {
              if(flip) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  blue0, blue1, blue, blueIndex,
                  red0, red1, red, redIndex)
              } else {
                retval = sweep.sweepBipartite(
                  d, visit,
                  red0, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
              }
            } else {
              iterPush(top++,
                axis+1,
                red0, red1,
                blue0, blue1,
                flip,
                -Infinity, Infinity)
              iterPush(top++,
                axis+1,
                blue0, blue1,
                red0, red1,
                flip^1,
                -Infinity, Infinity)
            }
          }
        }
      }
    }
  }
}
},{"./brute":31,"./median":33,"./partition":34,"./sweep":36,"bit-twiddle":29,"typedarray-pool":191}],33:[function(_dereq_,module,exports){
'use strict'

module.exports = findMedian

var genPartition = _dereq_('./partition')

var partitionStartLessThan = genPartition('lo<p0', ['p0'])

var PARTITION_THRESHOLD = 8   //Cut off for using insertion sort in findMedian

//Base case for median finding:  Use insertion sort
function insertionSort(d, axis, start, end, boxes, ids) {
  var elemSize = 2 * d
  var boxPtr = elemSize * (start+1) + axis
  for(var i=start+1; i<end; ++i, boxPtr+=elemSize) {
    var x = boxes[boxPtr]
    for(var j=i, ptr=elemSize*(i-1); 
        j>start && boxes[ptr+axis] > x; 
        --j, ptr-=elemSize) {
      //Swap
      var aPtr = ptr
      var bPtr = ptr+elemSize
      for(var k=0; k<elemSize; ++k, ++aPtr, ++bPtr) {
        var y = boxes[aPtr]
        boxes[aPtr] = boxes[bPtr]
        boxes[bPtr] = y
      }
      var tmp = ids[j]
      ids[j] = ids[j-1]
      ids[j-1] = tmp
    }
  }
}

//Find median using quick select algorithm
//  takes O(n) time with high probability
function findMedian(d, axis, start, end, boxes, ids) {
  if(end <= start+1) {
    return start
  }

  var lo       = start
  var hi       = end
  var mid      = ((end + start) >>> 1)
  var elemSize = 2*d
  var pivot    = mid
  var value    = boxes[elemSize*mid+axis]
  
  while(lo < hi) {
    if(hi - lo < PARTITION_THRESHOLD) {
      insertionSort(d, axis, lo, hi, boxes, ids)
      value = boxes[elemSize*mid+axis]
      break
    }
    
    //Select pivot using median-of-3
    var count  = hi - lo
    var pivot0 = (Math.random()*count+lo)|0
    var value0 = boxes[elemSize*pivot0 + axis]
    var pivot1 = (Math.random()*count+lo)|0
    var value1 = boxes[elemSize*pivot1 + axis]
    var pivot2 = (Math.random()*count+lo)|0
    var value2 = boxes[elemSize*pivot2 + axis]
    if(value0 <= value1) {
      if(value2 >= value1) {
        pivot = pivot1
        value = value1
      } else if(value0 >= value2) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    } else {
      if(value1 >= value2) {
        pivot = pivot1
        value = value1
      } else if(value2 >= value0) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    }

    //Swap pivot to end of array
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Partition using pivot
    pivot = partitionStartLessThan(
      d, axis, 
      lo, hi-1, boxes, ids,
      value)

    //Swap pivot back
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Swap pivot to last pivot
    if(mid < pivot) {
      hi = pivot-1
      while(lo < hi && 
        boxes[elemSize*(hi-1)+axis] === value) {
        hi -= 1
      }
      hi += 1
    } else if(pivot < mid) {
      lo = pivot + 1
      while(lo < hi &&
        boxes[elemSize*lo+axis] === value) {
        lo += 1
      }
    } else {
      break
    }
  }

  //Make sure pivot is at start
  return partitionStartLessThan(
    d, axis, 
    start, mid, boxes, ids,
    boxes[elemSize*mid+axis])
}
},{"./partition":34}],34:[function(_dereq_,module,exports){
'use strict'

module.exports = genPartition

var code = 'for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m'

function genPartition(predicate, args) {
  var fargs ='abcdef'.split('').concat(args)
  var reads = []
  if(predicate.indexOf('lo') >= 0) {
    reads.push('lo=e[k+n]')
  }
  if(predicate.indexOf('hi') >= 0) {
    reads.push('hi=e[k+o]')
  }
  fargs.push(
    code.replace('_', reads.join())
        .replace('$', predicate))
  return Function.apply(void 0, fargs)
}
},{}],35:[function(_dereq_,module,exports){
'use strict';

//This code is extracted from ndarray-sort
//It is inlined here as a temporary workaround

module.exports = wrapper;

var INSERT_SORT_CUTOFF = 32

function wrapper(data, n0) {
  if (n0 <= 4*INSERT_SORT_CUTOFF) {
    insertionSort(0, n0 - 1, data);
  } else {
    quickSort(0, n0 - 1, data);
  }
}

function insertionSort(left, right, data) {
  var ptr = 2*(left+1)
  for(var i=left+1; i<=right; ++i) {
    var a = data[ptr++]
    var b = data[ptr++]
    var j = i
    var jptr = ptr-2
    while(j-- > left) {
      var x = data[jptr-2]
      var y = data[jptr-1]
      if(x < a) {
        break
      } else if(x === a && y < b) {
        break
      }
      data[jptr]   = x
      data[jptr+1] = y
      jptr -= 2
    }
    data[jptr]   = a
    data[jptr+1] = b
  }
}

function swap(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = x
  data[j+1] = y
}

function move(i, j, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[i+1] = data[j+1]
}

function rotate(i, j, k, data) {
  i *= 2
  j *= 2
  k *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = data[k]
  data[j+1] = data[k+1]
  data[k] = x
  data[k+1] = y
}

function shufflePivot(i, j, px, py, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[j] = px
  data[i+1] = data[j+1]
  data[j+1] = py
}

function compare(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i],
      y = data[j]
  if(x < y) {
    return false
  } else if(x === y) {
    return data[i+1] > data[j+1]
  }
  return true
}

function comparePivot(i, y, b, data) {
  i *= 2
  var x = data[i]
  if(x < y) {
    return true
  } else if(x === y) {
    return data[i+1] < b
  }
  return false
}

function quickSort(left, right, data) {
  var sixth = (right - left + 1) / 6 | 0, 
      index1 = left + sixth, 
      index5 = right - sixth, 
      index3 = left + right >> 1, 
      index2 = index3 - sixth, 
      index4 = index3 + sixth, 
      el1 = index1, 
      el2 = index2, 
      el3 = index3, 
      el4 = index4, 
      el5 = index5, 
      less = left + 1, 
      great = right - 1, 
      tmp = 0
  if(compare(el1, el2, data)) {
    tmp = el1
    el1 = el2
    el2 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }
  if(compare(el1, el3, data)) {
    tmp = el1
    el1 = el3
    el3 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el1, el4, data)) {
    tmp = el1
    el1 = el4
    el4 = tmp
  }
  if(compare(el3, el4, data)) {
    tmp = el3
    el3 = el4
    el4 = tmp
  }
  if(compare(el2, el5, data)) {
    tmp = el2
    el2 = el5
    el5 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }

  var pivot1X = data[2*el2]
  var pivot1Y = data[2*el2+1]
  var pivot2X = data[2*el4]
  var pivot2Y = data[2*el4+1]

  var ptr0 = 2 * el1;
  var ptr2 = 2 * el3;
  var ptr4 = 2 * el5;
  var ptr5 = 2 * index1;
  var ptr6 = 2 * index3;
  var ptr7 = 2 * index5;
  for (var i1 = 0; i1 < 2; ++i1) {
    var x = data[ptr0+i1];
    var y = data[ptr2+i1];
    var z = data[ptr4+i1];
    data[ptr5+i1] = x;
    data[ptr6+i1] = y;
    data[ptr7+i1] = z;
  }

  move(index2, left, data)
  move(index4, right, data)
  for (var k = less; k <= great; ++k) {
    if (comparePivot(k, pivot1X, pivot1Y, data)) {
      if (k !== less) {
        swap(k, less, data)
      }
      ++less;
    } else {
      if (!comparePivot(k, pivot2X, pivot2Y, data)) {
        while (true) {
          if (!comparePivot(great, pivot2X, pivot2Y, data)) {
            if (--great < k) {
              break;
            }
            continue;
          } else {
            if (comparePivot(great, pivot1X, pivot1Y, data)) {
              rotate(k, less, great, data)
              ++less;
              --great;
            } else {
              swap(k, great, data)
              --great;
            }
            break;
          }
        }
      }
    }
  }
  shufflePivot(left, less-1, pivot1X, pivot1Y, data)
  shufflePivot(right, great+1, pivot2X, pivot2Y, data)
  if (less - 2 - left <= INSERT_SORT_CUTOFF) {
    insertionSort(left, less - 2, data);
  } else {
    quickSort(left, less - 2, data);
  }
  if (right - (great + 2) <= INSERT_SORT_CUTOFF) {
    insertionSort(great + 2, right, data);
  } else {
    quickSort(great + 2, right, data);
  }
  if (great - less <= INSERT_SORT_CUTOFF) {
    insertionSort(less, great, data);
  } else {
    quickSort(less, great, data);
  }
}
},{}],36:[function(_dereq_,module,exports){
'use strict'

module.exports = {
  init:           sqInit,
  sweepBipartite: sweepBipartite,
  sweepComplete:  sweepComplete,
  scanBipartite:  scanBipartite,
  scanComplete:   scanComplete
}

var pool  = _dereq_('typedarray-pool')
var bits  = _dereq_('bit-twiddle')
var isort = _dereq_('./sort')

//Flag for blue
var BLUE_FLAG = (1<<28)

//1D sweep event queue stuff (use pool to save space)
var INIT_CAPACITY      = 1024
var RED_SWEEP_QUEUE    = pool.mallocInt32(INIT_CAPACITY)
var RED_SWEEP_INDEX    = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_QUEUE   = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_INDEX   = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY)
var SWEEP_EVENTS       = pool.mallocDouble(INIT_CAPACITY * 8)

//Reserves memory for the 1D sweep data structures
function sqInit(count) {
  var rcount = bits.nextPow2(count)
  if(RED_SWEEP_QUEUE.length < rcount) {
    pool.free(RED_SWEEP_QUEUE)
    RED_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(RED_SWEEP_INDEX.length < rcount) {
    pool.free(RED_SWEEP_INDEX)
    RED_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_QUEUE.length < rcount) {
    pool.free(BLUE_SWEEP_QUEUE)
    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_INDEX.length < rcount) {
    pool.free(BLUE_SWEEP_INDEX)
    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_QUEUE.length < rcount) {
    pool.free(COMMON_SWEEP_QUEUE)
    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_INDEX.length < rcount) {
    pool.free(COMMON_SWEEP_INDEX)
    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  var eventLength = 8 * rcount
  if(SWEEP_EVENTS.length < eventLength) {
    pool.free(SWEEP_EVENTS)
    SWEEP_EVENTS = pool.mallocDouble(eventLength)
  }
}

//Remove an item from the active queue in O(1)
function sqPop(queue, index, count, item) {
  var idx = index[item]
  var top = queue[count-1]
  queue[idx] = top
  index[top] = idx
}

//Insert an item into the active queue in O(1)
function sqPush(queue, index, count, item) {
  queue[count] = item
  index[item]  = count
}

//Recursion base case: use 1D sweep algorithm
function sweepBipartite(
    d, visit,
    redStart,  redEnd, red, redIndex,
    blueStart, blueEnd, blue, blueIndex) {

  //store events as pairs [coordinate, idx]
  //
  //  red create:  -(idx+1)
  //  red destroy: idx
  //  blue create: -(idx+BLUE_FLAG)
  //  blue destroy: idx+BLUE_FLAG
  //
  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = redIndex[i]
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -(idx+1)
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = blueIndex[i]+BLUE_FLAG
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive  = 0
  var blueActive = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e >= BLUE_FLAG) {
      //blue destroy event
      e = (e-BLUE_FLAG)|0
      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e)
    } else if(e >= 0) {
      //red destroy event
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e)
    } else if(e <= -BLUE_FLAG) {
      //blue create event
      e = (-e-BLUE_FLAG)|0
      for(var j=0; j<redActive; ++j) {
        var retval = visit(RED_SWEEP_QUEUE[j], e)
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e)
    } else {
      //red create event
      e = (-e-1)|0
      for(var j=0; j<blueActive; ++j) {
        var retval = visit(e, BLUE_SWEEP_QUEUE[j])
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e)
    }
  }
}

//Complete sweep
function sweepComplete(d, visit, 
  redStart, redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = (redIndex[i]+1)<<1
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = (blueIndex[i]+1)<<1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = (-idx)|1
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx|1
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  var blueActive   = 0
  var commonActive = 0
  for(var i=0; i<n; ++i) {
    var e     = SWEEP_EVENTS[2*i+1]|0
    var color = e&1
    if(i < n-1 && (e>>1) === (SWEEP_EVENTS[2*i+3]>>1)) {
      color = 2
      i += 1
    }
    
    if(e < 0) {
      //Create event
      var id = -(e>>1) - 1

      //Intersect with common
      for(var j=0; j<commonActive; ++j) {
        var retval = visit(COMMON_SWEEP_QUEUE[j], id)
        if(retval !== void 0) {
          return retval
        }
      }

      if(color !== 0) {
        //Intersect with red
        for(var j=0; j<redActive; ++j) {
          var retval = visit(RED_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color !== 1) {
        //Intersect with blue
        for(var j=0; j<blueActive; ++j) {
          var retval = visit(BLUE_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color === 0) {
        //Red
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id)
      } else if(color === 1) {
        //Blue
        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id)
      } else if(color === 2) {
        //Both
        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id)
      }
    } else {
      //Destroy event
      var id = (e>>1) - 1
      if(color === 0) {
        //Red
        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id)
      } else if(color === 1) {
        //Blue
        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id)
      } else if(color === 2) {
        //Both
        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id)
      }
    }
  }
}

//Sweep and prune/scanline algorithm:
//  Scan along axis, detect intersections
//  Brute force all boxes along axis
function scanBipartite(
  d, axis, visit, flip,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {
  
  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  var redShift  = 1
  var blueShift = 1
  if(flip) {
    blueShift = BLUE_FLAG
  } else {
    redShift  = BLUE_FLAG
  }

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + redShift
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + blueShift
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      var isRed = false
      if(idx >= BLUE_FLAG) {
        isRed = !flip
        idx -= BLUE_FLAG 
      } else {
        isRed = !!flip
        idx -= 1
      }
      if(isRed) {
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx)
      } else {
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx
        
        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redPtr = elemSize * oidx

          if(b1 < red[redPtr+axis+1] || 
             red[redPtr+axis+1+d] < b0) {
            continue
          }

          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d] < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var redId  = redIndex[oidx]
          var retval
          if(flip) {
            retval = visit(blueId, redId)
          } else {
            retval = visit(redId, blueId)
          }
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift)
    }
  }
}

function scanComplete(
  d, axis, visit,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + BLUE_FLAG
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + 1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      if(idx >= BLUE_FLAG) {
        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG
      } else {
        idx -= 1
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx

        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redId  = redIndex[oidx]

          if(redId === blueId) {
            break
          }

          var redPtr = elemSize * oidx
          if(b1 < red[redPtr+axis+1] || 
            red[redPtr+axis+1+d] < b0) {
            continue
          }
          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d]   < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var retval = visit(redId, blueId)
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      var idx = e - BLUE_FLAG
      for(var j=redActive-1; j>=0; --j) {
        if(RED_SWEEP_QUEUE[j] === idx) {
          for(var k=j+1; k<redActive; ++k) {
            RED_SWEEP_QUEUE[k-1] = RED_SWEEP_QUEUE[k]
          }
          break
        }
      }
      --redActive
    }
  }
}
},{"./sort":35,"bit-twiddle":29,"typedarray-pool":191}],37:[function(_dereq_,module,exports){

},{}],38:[function(_dereq_,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = _dereq_('base64-js')
var ieee754 = _dereq_('ieee754')
var isArray = _dereq_('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length, unitSize) {
  if (unitSize) length -= length % unitSize;
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":28,"ieee754":152,"is-array":153}],39:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.string.iterator');
_dereq_('../../modules/es6.array.from');
module.exports = _dereq_('../../modules/$.core').Array.from;
},{"../../modules/$.core":64,"../../modules/es6.array.from":116,"../../modules/es6.string.iterator":128}],40:[function(_dereq_,module,exports){
_dereq_('../modules/web.dom.iterable');
_dereq_('../modules/es6.string.iterator');
module.exports = _dereq_('../modules/core.get-iterator');
},{"../modules/core.get-iterator":114,"../modules/es6.string.iterator":128,"../modules/web.dom.iterable":132}],41:[function(_dereq_,module,exports){
_dereq_('../modules/web.dom.iterable');
_dereq_('../modules/es6.string.iterator');
module.exports = _dereq_('../modules/core.is-iterable');
},{"../modules/core.is-iterable":115,"../modules/es6.string.iterator":128,"../modules/web.dom.iterable":132}],42:[function(_dereq_,module,exports){
_dereq_('../modules/es6.object.to-string');
_dereq_('../modules/es6.string.iterator');
_dereq_('../modules/web.dom.iterable');
_dereq_('../modules/es6.map');
_dereq_('../modules/es7.map.to-json');
module.exports = _dereq_('../modules/$.core').Map;
},{"../modules/$.core":64,"../modules/es6.map":118,"../modules/es6.object.to-string":125,"../modules/es6.string.iterator":128,"../modules/es7.map.to-json":130,"../modules/web.dom.iterable":132}],43:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.math.log2');
module.exports = _dereq_('../../modules/$.core').Math.log2;
},{"../../modules/$.core":64,"../../modules/es6.math.log2":119}],44:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.object.assign');
module.exports = _dereq_('../../modules/$.core').Object.assign;
},{"../../modules/$.core":64,"../../modules/es6.object.assign":120}],45:[function(_dereq_,module,exports){
var $ = _dereq_('../../modules/$');
module.exports = function create(P, D){
  return $.create(P, D);
};
},{"../../modules/$":89}],46:[function(_dereq_,module,exports){
var $ = _dereq_('../../modules/$');
module.exports = function defineProperties(T, D){
  return $.setDescs(T, D);
};
},{"../../modules/$":89}],47:[function(_dereq_,module,exports){
var $ = _dereq_('../../modules/$');
module.exports = function defineProperty(it, key, desc){
  return $.setDesc(it, key, desc);
};
},{"../../modules/$":89}],48:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.object.freeze');
module.exports = _dereq_('../../modules/$.core').Object.freeze;
},{"../../modules/$.core":64,"../../modules/es6.object.freeze":121}],49:[function(_dereq_,module,exports){
var $ = _dereq_('../../modules/$');
_dereq_('../../modules/es6.object.get-own-property-descriptor');
module.exports = function getOwnPropertyDescriptor(it, key){
  return $.getDesc(it, key);
};
},{"../../modules/$":89,"../../modules/es6.object.get-own-property-descriptor":122}],50:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.object.keys');
module.exports = _dereq_('../../modules/$.core').Object.keys;
},{"../../modules/$.core":64,"../../modules/es6.object.keys":123}],51:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.object.set-prototype-of');
module.exports = _dereq_('../../modules/$.core').Object.setPrototypeOf;
},{"../../modules/$.core":64,"../../modules/es6.object.set-prototype-of":124}],52:[function(_dereq_,module,exports){
_dereq_('../modules/es6.object.to-string');
_dereq_('../modules/es6.string.iterator');
_dereq_('../modules/web.dom.iterable');
_dereq_('../modules/es6.promise');
module.exports = _dereq_('../modules/$.core').Promise;
},{"../modules/$.core":64,"../modules/es6.object.to-string":125,"../modules/es6.promise":126,"../modules/es6.string.iterator":128,"../modules/web.dom.iterable":132}],53:[function(_dereq_,module,exports){
_dereq_('../modules/es6.object.to-string');
_dereq_('../modules/es6.string.iterator');
_dereq_('../modules/web.dom.iterable');
_dereq_('../modules/es6.set');
_dereq_('../modules/es7.set.to-json');
module.exports = _dereq_('../modules/$.core').Set;
},{"../modules/$.core":64,"../modules/es6.object.to-string":125,"../modules/es6.set":127,"../modules/es6.string.iterator":128,"../modules/es7.set.to-json":131,"../modules/web.dom.iterable":132}],54:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.symbol');
_dereq_('../../modules/es6.object.to-string');
module.exports = _dereq_('../../modules/$.core').Symbol;
},{"../../modules/$.core":64,"../../modules/es6.object.to-string":125,"../../modules/es6.symbol":129}],55:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.string.iterator');
_dereq_('../../modules/web.dom.iterable');
module.exports = _dereq_('../../modules/$.wks')('iterator');
},{"../../modules/$.wks":112,"../../modules/es6.string.iterator":128,"../../modules/web.dom.iterable":132}],56:[function(_dereq_,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],57:[function(_dereq_,module,exports){
module.exports = function(){ /* empty */ };
},{}],58:[function(_dereq_,module,exports){
var isObject = _dereq_('./$.is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./$.is-object":82}],59:[function(_dereq_,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = _dereq_('./$.cof')
  , TAG = _dereq_('./$.wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./$.cof":60,"./$.wks":112}],60:[function(_dereq_,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],61:[function(_dereq_,module,exports){
'use strict';
var $            = _dereq_('./$')
  , hide         = _dereq_('./$.hide')
  , redefineAll  = _dereq_('./$.redefine-all')
  , ctx          = _dereq_('./$.ctx')
  , strictNew    = _dereq_('./$.strict-new')
  , defined      = _dereq_('./$.defined')
  , forOf        = _dereq_('./$.for-of')
  , $iterDefine  = _dereq_('./$.iter-define')
  , step         = _dereq_('./$.iter-step')
  , ID           = _dereq_('./$.uid')('id')
  , $has         = _dereq_('./$.has')
  , isObject     = _dereq_('./$.is-object')
  , setSpecies   = _dereq_('./$.set-species')
  , DESCRIPTORS  = _dereq_('./$.descriptors')
  , isExtensible = Object.isExtensible || isObject
  , SIZE         = DESCRIPTORS ? '_s' : 'size'
  , id           = 0;

var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!$has(it, ID)){
    // can't set id to frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add id
    if(!create)return 'E';
    // add missing object id
    hide(it, ID, ++id);
  // return object id with prefix
  } return 'O' + it[ID];
};

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      strictNew(that, C, NAME);
      that._i = $.create(null); // index
      that._f = undefined;      // first entry
      that._l = undefined;      // last entry
      that[SIZE] = 0;           // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)$.setDesc(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};
},{"./$":89,"./$.ctx":65,"./$.defined":66,"./$.descriptors":67,"./$.for-of":72,"./$.has":75,"./$.hide":76,"./$.is-object":82,"./$.iter-define":85,"./$.iter-step":87,"./$.redefine-all":96,"./$.set-species":100,"./$.strict-new":104,"./$.uid":111}],62:[function(_dereq_,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var forOf   = _dereq_('./$.for-of')
  , classof = _dereq_('./$.classof');
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    var arr = [];
    forOf(this, false, arr.push, arr);
    return arr;
  };
};
},{"./$.classof":59,"./$.for-of":72}],63:[function(_dereq_,module,exports){
'use strict';
var $              = _dereq_('./$')
  , global         = _dereq_('./$.global')
  , $export        = _dereq_('./$.export')
  , fails          = _dereq_('./$.fails')
  , hide           = _dereq_('./$.hide')
  , redefineAll    = _dereq_('./$.redefine-all')
  , forOf          = _dereq_('./$.for-of')
  , strictNew      = _dereq_('./$.strict-new')
  , isObject       = _dereq_('./$.is-object')
  , setToStringTag = _dereq_('./$.set-to-string-tag')
  , DESCRIPTORS    = _dereq_('./$.descriptors');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
  } else {
    C = wrapper(function(target, iterable){
      strictNew(target, C, NAME);
      target._c = new Base;
      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
    });
    $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','),function(KEY){
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    if('size' in proto)$.setDesc(C.prototype, 'size', {
      get: function(){
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./$":89,"./$.descriptors":67,"./$.export":70,"./$.fails":71,"./$.for-of":72,"./$.global":74,"./$.hide":76,"./$.is-object":82,"./$.redefine-all":96,"./$.set-to-string-tag":101,"./$.strict-new":104}],64:[function(_dereq_,module,exports){
var core = module.exports = {version: '1.2.6'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],65:[function(_dereq_,module,exports){
// optional / simple context binding
var aFunction = _dereq_('./$.a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./$.a-function":56}],66:[function(_dereq_,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],67:[function(_dereq_,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !_dereq_('./$.fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./$.fails":71}],68:[function(_dereq_,module,exports){
var isObject = _dereq_('./$.is-object')
  , document = _dereq_('./$.global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./$.global":74,"./$.is-object":82}],69:[function(_dereq_,module,exports){
// all enumerable object keys, includes symbols
var $ = _dereq_('./$');
module.exports = function(it){
  var keys       = $.getKeys(it)
    , getSymbols = $.getSymbols;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = $.isEnum
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
  }
  return keys;
};
},{"./$":89}],70:[function(_dereq_,module,exports){
var global    = _dereq_('./$.global')
  , core      = _dereq_('./$.core')
  , ctx       = _dereq_('./$.ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && key in target;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(param){
        return this instanceof C ? new C(param) : C(param);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
  }
};
// type bitmap
$export.F = 1;  // forced
$export.G = 2;  // global
$export.S = 4;  // static
$export.P = 8;  // proto
$export.B = 16; // bind
$export.W = 32; // wrap
module.exports = $export;
},{"./$.core":64,"./$.ctx":65,"./$.global":74}],71:[function(_dereq_,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],72:[function(_dereq_,module,exports){
var ctx         = _dereq_('./$.ctx')
  , call        = _dereq_('./$.iter-call')
  , isArrayIter = _dereq_('./$.is-array-iter')
  , anObject    = _dereq_('./$.an-object')
  , toLength    = _dereq_('./$.to-length')
  , getIterFn   = _dereq_('./core.get-iterator-method');
module.exports = function(iterable, entries, fn, that){
  var iterFn = getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    call(iterator, f, step.value, entries);
  }
};
},{"./$.an-object":58,"./$.ctx":65,"./$.is-array-iter":80,"./$.iter-call":83,"./$.to-length":109,"./core.get-iterator-method":113}],73:[function(_dereq_,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = _dereq_('./$.to-iobject')
  , getNames  = _dereq_('./$').getNames
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return getNames(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.get = function getOwnPropertyNames(it){
  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
  return getNames(toIObject(it));
};
},{"./$":89,"./$.to-iobject":108}],74:[function(_dereq_,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],75:[function(_dereq_,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],76:[function(_dereq_,module,exports){
var $          = _dereq_('./$')
  , createDesc = _dereq_('./$.property-desc');
module.exports = _dereq_('./$.descriptors') ? function(object, key, value){
  return $.setDesc(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./$":89,"./$.descriptors":67,"./$.property-desc":95}],77:[function(_dereq_,module,exports){
module.exports = _dereq_('./$.global').document && document.documentElement;
},{"./$.global":74}],78:[function(_dereq_,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],79:[function(_dereq_,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = _dereq_('./$.cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./$.cof":60}],80:[function(_dereq_,module,exports){
// check on default Array iterator
var Iterators  = _dereq_('./$.iterators')
  , ITERATOR   = _dereq_('./$.wks')('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
},{"./$.iterators":88,"./$.wks":112}],81:[function(_dereq_,module,exports){
// 7.2.2 IsArray(argument)
var cof = _dereq_('./$.cof');
module.exports = Array.isArray || function(arg){
  return cof(arg) == 'Array';
};
},{"./$.cof":60}],82:[function(_dereq_,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],83:[function(_dereq_,module,exports){
// call something on iterator step with safe closing on error
var anObject = _dereq_('./$.an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./$.an-object":58}],84:[function(_dereq_,module,exports){
'use strict';
var $              = _dereq_('./$')
  , descriptor     = _dereq_('./$.property-desc')
  , setToStringTag = _dereq_('./$.set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
_dereq_('./$.hide')(IteratorPrototype, _dereq_('./$.wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./$":89,"./$.hide":76,"./$.property-desc":95,"./$.set-to-string-tag":101,"./$.wks":112}],85:[function(_dereq_,module,exports){
'use strict';
var LIBRARY        = _dereq_('./$.library')
  , $export        = _dereq_('./$.export')
  , redefine       = _dereq_('./$.redefine')
  , hide           = _dereq_('./$.hide')
  , has            = _dereq_('./$.has')
  , Iterators      = _dereq_('./$.iterators')
  , $iterCreate    = _dereq_('./$.iter-create')
  , setToStringTag = _dereq_('./$.set-to-string-tag')
  , getProto       = _dereq_('./$').getProto
  , ITERATOR       = _dereq_('./$.wks')('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , methods, key;
  // Fix native
  if($native){
    var IteratorPrototype = getProto($default.call(new Base));
    // Set @@toStringTag to native iterators
    setToStringTag(IteratorPrototype, TAG, true);
    // FF fix
    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    // fix Array#{values, @@iterator}.name in V8 / FF
    if(DEF_VALUES && $native.name !== VALUES){
      VALUES_BUG = true;
      $default = function values(){ return $native.call(this); };
    }
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES  ? $default : getMethod(VALUES),
      keys:    IS_SET      ? $default : getMethod(KEYS),
      entries: !DEF_VALUES ? $default : getMethod('entries')
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
},{"./$":89,"./$.export":70,"./$.has":75,"./$.hide":76,"./$.iter-create":84,"./$.iterators":88,"./$.library":91,"./$.redefine":97,"./$.set-to-string-tag":101,"./$.wks":112}],86:[function(_dereq_,module,exports){
var ITERATOR     = _dereq_('./$.wks')('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ safe = true; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./$.wks":112}],87:[function(_dereq_,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],88:[function(_dereq_,module,exports){
module.exports = {};
},{}],89:[function(_dereq_,module,exports){
var $Object = Object;
module.exports = {
  create:     $Object.create,
  getProto:   $Object.getPrototypeOf,
  isEnum:     {}.propertyIsEnumerable,
  getDesc:    $Object.getOwnPropertyDescriptor,
  setDesc:    $Object.defineProperty,
  setDescs:   $Object.defineProperties,
  getKeys:    $Object.keys,
  getNames:   $Object.getOwnPropertyNames,
  getSymbols: $Object.getOwnPropertySymbols,
  each:       [].forEach
};
},{}],90:[function(_dereq_,module,exports){
var $         = _dereq_('./$')
  , toIObject = _dereq_('./$.to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = $.getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./$":89,"./$.to-iobject":108}],91:[function(_dereq_,module,exports){
module.exports = true;
},{}],92:[function(_dereq_,module,exports){
var global    = _dereq_('./$.global')
  , macrotask = _dereq_('./$.task').set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , Promise   = global.Promise
  , isNode    = _dereq_('./$.cof')(process) == 'process'
  , head, last, notify;

var flush = function(){
  var parent, domain, fn;
  if(isNode && (parent = process.domain)){
    process.domain = null;
    parent.exit();
  }
  while(head){
    domain = head.domain;
    fn     = head.fn;
    if(domain)domain.enter();
    fn(); // <- currently we use it only for Promise - try / catch not required
    if(domain)domain.exit();
    head = head.next;
  } last = undefined;
  if(parent)parent.enter();
};

// Node.js
if(isNode){
  notify = function(){
    process.nextTick(flush);
  };
// browsers with MutationObserver
} else if(Observer){
  var toggle = 1
    , node   = document.createTextNode('');
  new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
  notify = function(){
    node.data = toggle = -toggle;
  };
// environments with maybe non-completely correct, but existent Promise
} else if(Promise && Promise.resolve){
  notify = function(){
    Promise.resolve().then(flush);
  };
// for other environments - macrotask based on:
// - setImmediate
// - MessageChannel
// - window.postMessag
// - onreadystatechange
// - setTimeout
} else {
  notify = function(){
    // strange IE + webpack dev server bug - use .call(global)
    macrotask.call(global, flush);
  };
}

module.exports = function asap(fn){
  var task = {fn: fn, next: undefined, domain: isNode && process.domain};
  if(last)last.next = task;
  if(!head){
    head = task;
    notify();
  } last = task;
};
},{"./$.cof":60,"./$.global":74,"./$.task":106}],93:[function(_dereq_,module,exports){
// 19.1.2.1 Object.assign(target, source, ...)
var $        = _dereq_('./$')
  , toObject = _dereq_('./$.to-object')
  , IObject  = _dereq_('./$.iobject');

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = _dereq_('./$.fails')(function(){
  var a = Object.assign
    , A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , $$    = arguments
    , $$len = $$.length
    , index = 1
    , getKeys    = $.getKeys
    , getSymbols = $.getSymbols
    , isEnum     = $.isEnum;
  while($$len > index){
    var S      = IObject($$[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  }
  return T;
} : Object.assign;
},{"./$":89,"./$.fails":71,"./$.iobject":79,"./$.to-object":110}],94:[function(_dereq_,module,exports){
// most Object methods by ES6 should accept primitives
var $export = _dereq_('./$.export')
  , core    = _dereq_('./$.core')
  , fails   = _dereq_('./$.fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./$.core":64,"./$.export":70,"./$.fails":71}],95:[function(_dereq_,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],96:[function(_dereq_,module,exports){
var redefine = _dereq_('./$.redefine');
module.exports = function(target, src){
  for(var key in src)redefine(target, key, src[key]);
  return target;
};
},{"./$.redefine":97}],97:[function(_dereq_,module,exports){
module.exports = _dereq_('./$.hide');
},{"./$.hide":76}],98:[function(_dereq_,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
},{}],99:[function(_dereq_,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var getDesc  = _dereq_('./$').getDesc
  , isObject = _dereq_('./$.is-object')
  , anObject = _dereq_('./$.an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = _dereq_('./$.ctx')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./$":89,"./$.an-object":58,"./$.ctx":65,"./$.is-object":82}],100:[function(_dereq_,module,exports){
'use strict';
var core        = _dereq_('./$.core')
  , $           = _dereq_('./$')
  , DESCRIPTORS = _dereq_('./$.descriptors')
  , SPECIES     = _dereq_('./$.wks')('species');

module.exports = function(KEY){
  var C = core[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])$.setDesc(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./$":89,"./$.core":64,"./$.descriptors":67,"./$.wks":112}],101:[function(_dereq_,module,exports){
var def = _dereq_('./$').setDesc
  , has = _dereq_('./$.has')
  , TAG = _dereq_('./$.wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./$":89,"./$.has":75,"./$.wks":112}],102:[function(_dereq_,module,exports){
var global = _dereq_('./$.global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./$.global":74}],103:[function(_dereq_,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = _dereq_('./$.an-object')
  , aFunction = _dereq_('./$.a-function')
  , SPECIES   = _dereq_('./$.wks')('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};
},{"./$.a-function":56,"./$.an-object":58,"./$.wks":112}],104:[function(_dereq_,module,exports){
module.exports = function(it, Constructor, name){
  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
  return it;
};
},{}],105:[function(_dereq_,module,exports){
var toInteger = _dereq_('./$.to-integer')
  , defined   = _dereq_('./$.defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./$.defined":66,"./$.to-integer":107}],106:[function(_dereq_,module,exports){
var ctx                = _dereq_('./$.ctx')
  , invoke             = _dereq_('./$.invoke')
  , html               = _dereq_('./$.html')
  , cel                = _dereq_('./$.dom-create')
  , global             = _dereq_('./$.global')
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listner = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(_dereq_('./$.cof')(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listner, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./$.cof":60,"./$.ctx":65,"./$.dom-create":68,"./$.global":74,"./$.html":77,"./$.invoke":78}],107:[function(_dereq_,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],108:[function(_dereq_,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = _dereq_('./$.iobject')
  , defined = _dereq_('./$.defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./$.defined":66,"./$.iobject":79}],109:[function(_dereq_,module,exports){
// 7.1.15 ToLength
var toInteger = _dereq_('./$.to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./$.to-integer":107}],110:[function(_dereq_,module,exports){
// 7.1.13 ToObject(argument)
var defined = _dereq_('./$.defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./$.defined":66}],111:[function(_dereq_,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],112:[function(_dereq_,module,exports){
var store  = _dereq_('./$.shared')('wks')
  , uid    = _dereq_('./$.uid')
  , Symbol = _dereq_('./$.global').Symbol;
module.exports = function(name){
  return store[name] || (store[name] =
    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
};
},{"./$.global":74,"./$.shared":102,"./$.uid":111}],113:[function(_dereq_,module,exports){
var classof   = _dereq_('./$.classof')
  , ITERATOR  = _dereq_('./$.wks')('iterator')
  , Iterators = _dereq_('./$.iterators');
module.exports = _dereq_('./$.core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./$.classof":59,"./$.core":64,"./$.iterators":88,"./$.wks":112}],114:[function(_dereq_,module,exports){
var anObject = _dereq_('./$.an-object')
  , get      = _dereq_('./core.get-iterator-method');
module.exports = _dereq_('./$.core').getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};
},{"./$.an-object":58,"./$.core":64,"./core.get-iterator-method":113}],115:[function(_dereq_,module,exports){
var classof   = _dereq_('./$.classof')
  , ITERATOR  = _dereq_('./$.wks')('iterator')
  , Iterators = _dereq_('./$.iterators');
module.exports = _dereq_('./$.core').isIterable = function(it){
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    || Iterators.hasOwnProperty(classof(O));
};
},{"./$.classof":59,"./$.core":64,"./$.iterators":88,"./$.wks":112}],116:[function(_dereq_,module,exports){
'use strict';
var ctx         = _dereq_('./$.ctx')
  , $export     = _dereq_('./$.export')
  , toObject    = _dereq_('./$.to-object')
  , call        = _dereq_('./$.iter-call')
  , isArrayIter = _dereq_('./$.is-array-iter')
  , toLength    = _dereq_('./$.to-length')
  , getIterFn   = _dereq_('./core.get-iterator-method');
$export($export.S + $export.F * !_dereq_('./$.iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , $$      = arguments
      , $$len   = $$.length
      , mapfn   = $$len > 1 ? $$[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        result[index] = mapping ? mapfn(O[index], index) : O[index];
      }
    }
    result.length = index;
    return result;
  }
});

},{"./$.ctx":65,"./$.export":70,"./$.is-array-iter":80,"./$.iter-call":83,"./$.iter-detect":86,"./$.to-length":109,"./$.to-object":110,"./core.get-iterator-method":113}],117:[function(_dereq_,module,exports){
'use strict';
var addToUnscopables = _dereq_('./$.add-to-unscopables')
  , step             = _dereq_('./$.iter-step')
  , Iterators        = _dereq_('./$.iterators')
  , toIObject        = _dereq_('./$.to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = _dereq_('./$.iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
},{"./$.add-to-unscopables":57,"./$.iter-define":85,"./$.iter-step":87,"./$.iterators":88,"./$.to-iobject":108}],118:[function(_dereq_,module,exports){
'use strict';
var strong = _dereq_('./$.collection-strong');

// 23.1 Map Objects
_dereq_('./$.collection')('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
},{"./$.collection":63,"./$.collection-strong":61}],119:[function(_dereq_,module,exports){
// 20.2.2.22 Math.log2(x)
var $export = _dereq_('./$.export');

$export($export.S, 'Math', {
  log2: function log2(x){
    return Math.log(x) / Math.LN2;
  }
});
},{"./$.export":70}],120:[function(_dereq_,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = _dereq_('./$.export');

$export($export.S + $export.F, 'Object', {assign: _dereq_('./$.object-assign')});
},{"./$.export":70,"./$.object-assign":93}],121:[function(_dereq_,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = _dereq_('./$.is-object');

_dereq_('./$.object-sap')('freeze', function($freeze){
  return function freeze(it){
    return $freeze && isObject(it) ? $freeze(it) : it;
  };
});
},{"./$.is-object":82,"./$.object-sap":94}],122:[function(_dereq_,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = _dereq_('./$.to-iobject');

_dereq_('./$.object-sap')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor){
  return function getOwnPropertyDescriptor(it, key){
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});
},{"./$.object-sap":94,"./$.to-iobject":108}],123:[function(_dereq_,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = _dereq_('./$.to-object');

_dereq_('./$.object-sap')('keys', function($keys){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./$.object-sap":94,"./$.to-object":110}],124:[function(_dereq_,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = _dereq_('./$.export');
$export($export.S, 'Object', {setPrototypeOf: _dereq_('./$.set-proto').set});
},{"./$.export":70,"./$.set-proto":99}],125:[function(_dereq_,module,exports){
module.exports=_dereq_(37)
},{"/Users/bcamper/Documents/dev/vector-map/node_modules/browser-resolve/empty.js":37}],126:[function(_dereq_,module,exports){
'use strict';
var $          = _dereq_('./$')
  , LIBRARY    = _dereq_('./$.library')
  , global     = _dereq_('./$.global')
  , ctx        = _dereq_('./$.ctx')
  , classof    = _dereq_('./$.classof')
  , $export    = _dereq_('./$.export')
  , isObject   = _dereq_('./$.is-object')
  , anObject   = _dereq_('./$.an-object')
  , aFunction  = _dereq_('./$.a-function')
  , strictNew  = _dereq_('./$.strict-new')
  , forOf      = _dereq_('./$.for-of')
  , setProto   = _dereq_('./$.set-proto').set
  , same       = _dereq_('./$.same-value')
  , SPECIES    = _dereq_('./$.wks')('species')
  , speciesConstructor = _dereq_('./$.species-constructor')
  , asap       = _dereq_('./$.microtask')
  , PROMISE    = 'Promise'
  , process    = global.process
  , isNode     = classof(process) == 'process'
  , P          = global[PROMISE]
  , Wrapper;

var testResolve = function(sub){
  var test = new P(function(){});
  if(sub)test.constructor = Object;
  return P.resolve(test) === test;
};

var USE_NATIVE = function(){
  var works = false;
  function P2(x){
    var self = new P(x);
    setProto(self, P2.prototype);
    return self;
  }
  try {
    works = P && P.resolve && testResolve();
    setProto(P2, P);
    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
    // actual Firefox has broken subclass support, test that
    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
      works = false;
    }
    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162
    if(works && _dereq_('./$.descriptors')){
      var thenableThenGotten = false;
      P.resolve($.setDesc({}, 'then', {
        get: function(){ thenableThenGotten = true; }
      }));
      works = thenableThenGotten;
    }
  } catch(e){ works = false; }
  return works;
}();

// helpers
var sameConstructor = function(a, b){
  // library wrapper special case
  if(LIBRARY && a === P && b === Wrapper)return true;
  return same(a, b);
};
var getConstructor = function(C){
  var S = anObject(C)[SPECIES];
  return S != undefined ? S : C;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var PromiseCapability = function(C){
  var resolve, reject;
  this.promise = new C(function($$resolve, $$reject){
    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject  = $$reject;
  });
  this.resolve = aFunction(resolve),
  this.reject  = aFunction(reject)
};
var perform = function(exec){
  try {
    exec();
  } catch(e){
    return {error: e};
  }
};
var notify = function(record, isReject){
  if(record.n)return;
  record.n = true;
  var chain = record.c;
  asap(function(){
    var value = record.v
      , ok    = record.s == 1
      , i     = 0;
    var run = function(reaction){
      var handler = ok ? reaction.ok : reaction.fail
        , resolve = reaction.resolve
        , reject  = reaction.reject
        , result, then;
      try {
        if(handler){
          if(!ok)record.h = true;
          result = handler === true ? value : handler(value);
          if(result === reaction.promise){
            reject(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(result)){
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch(e){
        reject(e);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    chain.length = 0;
    record.n = false;
    if(isReject)setTimeout(function(){
      var promise = record.p
        , handler, console;
      if(isUnhandled(promise)){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      } record.a = undefined;
    }, 1);
  });
};
var isUnhandled = function(promise){
  var record = promise._d
    , chain  = record.a || record.c
    , i      = 0
    , reaction;
  if(record.h)return false;
  while(chain.length > i){
    reaction = chain[i++];
    if(reaction.fail || !isUnhandled(reaction.promise))return false;
  } return true;
};
var $reject = function(value){
  var record = this;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  record.v = value;
  record.s = 2;
  record.a = record.c.slice();
  notify(record, true);
};
var $resolve = function(value){
  var record = this
    , then;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  try {
    if(record.p === value)throw TypeError("Promise can't be resolved itself");
    if(then = isThenable(value)){
      asap(function(){
        var wrapper = {r: record, d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      record.v = value;
      record.s = 1;
      notify(record, false);
    }
  } catch(e){
    $reject.call({r: record, d: false}, e); // wrap
  }
};

// constructor polyfill
if(!USE_NATIVE){
  // 25.4.3.1 Promise(executor)
  P = function Promise(executor){
    aFunction(executor);
    var record = this._d = {
      p: strictNew(this, P, PROMISE),         // <- promise
      c: [],                                  // <- awaiting reactions
      a: undefined,                           // <- checked in isUnhandled reactions
      s: 0,                                   // <- state
      d: false,                               // <- done
      v: undefined,                           // <- value
      h: false,                               // <- handled rejection
      n: false                                // <- notify
    };
    try {
      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
    } catch(err){
      $reject.call(record, err);
    }
  };
  _dereq_('./$.redefine-all')(P.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var reaction = new PromiseCapability(speciesConstructor(this, P))
        , promise  = reaction.promise
        , record   = this._d;
      reaction.ok   = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      record.c.push(reaction);
      if(record.a)record.a.push(reaction);
      if(record.s)notify(record, false);
      return promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
_dereq_('./$.set-to-string-tag')(P, PROMISE);
_dereq_('./$.set-species')(PROMISE);
Wrapper = _dereq_('./$.core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    var capability = new PromiseCapability(this)
      , $$reject   = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if(x instanceof P && sameConstructor(x.constructor, this))return x;
    var capability = new PromiseCapability(this)
      , $$resolve  = capability.resolve;
    $$resolve(x);
    return capability.promise;
  }
});
$export($export.S + $export.F * !(USE_NATIVE && _dereq_('./$.iter-detect')(function(iter){
  P.all(iter)['catch'](function(){});
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C          = getConstructor(this)
      , capability = new PromiseCapability(C)
      , resolve    = capability.resolve
      , reject     = capability.reject
      , values     = [];
    var abrupt = perform(function(){
      forOf(iterable, false, values.push, values);
      var remaining = values.length
        , results   = Array(remaining);
      if(remaining)$.each.call(values, function(promise, index){
        var alreadyCalled = false;
        C.resolve(promise).then(function(value){
          if(alreadyCalled)return;
          alreadyCalled = true;
          results[index] = value;
          --remaining || resolve(results);
        }, reject);
      });
      else resolve(results);
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C          = getConstructor(this)
      , capability = new PromiseCapability(C)
      , reject     = capability.reject;
    var abrupt = perform(function(){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  }
});
},{"./$":89,"./$.a-function":56,"./$.an-object":58,"./$.classof":59,"./$.core":64,"./$.ctx":65,"./$.descriptors":67,"./$.export":70,"./$.for-of":72,"./$.global":74,"./$.is-object":82,"./$.iter-detect":86,"./$.library":91,"./$.microtask":92,"./$.redefine-all":96,"./$.same-value":98,"./$.set-proto":99,"./$.set-species":100,"./$.set-to-string-tag":101,"./$.species-constructor":103,"./$.strict-new":104,"./$.wks":112}],127:[function(_dereq_,module,exports){
'use strict';
var strong = _dereq_('./$.collection-strong');

// 23.2 Set Objects
_dereq_('./$.collection')('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./$.collection":63,"./$.collection-strong":61}],128:[function(_dereq_,module,exports){
'use strict';
var $at  = _dereq_('./$.string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
_dereq_('./$.iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./$.iter-define":85,"./$.string-at":105}],129:[function(_dereq_,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var $              = _dereq_('./$')
  , global         = _dereq_('./$.global')
  , has            = _dereq_('./$.has')
  , DESCRIPTORS    = _dereq_('./$.descriptors')
  , $export        = _dereq_('./$.export')
  , redefine       = _dereq_('./$.redefine')
  , $fails         = _dereq_('./$.fails')
  , shared         = _dereq_('./$.shared')
  , setToStringTag = _dereq_('./$.set-to-string-tag')
  , uid            = _dereq_('./$.uid')
  , wks            = _dereq_('./$.wks')
  , keyOf          = _dereq_('./$.keyof')
  , $names         = _dereq_('./$.get-names')
  , enumKeys       = _dereq_('./$.enum-keys')
  , isArray        = _dereq_('./$.is-array')
  , anObject       = _dereq_('./$.an-object')
  , toIObject      = _dereq_('./$.to-iobject')
  , createDesc     = _dereq_('./$.property-desc')
  , getDesc        = $.getDesc
  , setDesc        = $.setDesc
  , _create        = $.create
  , getNames       = $names.get
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , setter         = false
  , HIDDEN         = wks('_hidden')
  , isEnum         = $.isEnum
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , useNative      = typeof $Symbol == 'function'
  , ObjectProto    = Object.prototype;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(setDesc({}, 'a', {
    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = getDesc(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  setDesc(it, key, D);
  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
} : setDesc;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol.prototype);
  sym._k = tag;
  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
    configurable: true,
    set: function(value){
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    }
  });
  return sym;
};

var isSymbol = function(it){
  return typeof it == 'symbol';
};

var $defineProperty = function defineProperty(it, key, D){
  if(D && has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return setDesc(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key);
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
    ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  var D = getDesc(it = toIObject(it), key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
  return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
  return result;
};
var $stringify = function stringify(it){
  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
  var args = [it]
    , i    = 1
    , $$   = arguments
    , replacer, $replacer;
  while($$.length > i)args.push($$[i++]);
  replacer = args[1];
  if(typeof replacer == 'function')$replacer = replacer;
  if($replacer || !isArray(replacer))replacer = function(key, value){
    if($replacer)value = $replacer.call(this, key, value);
    if(!isSymbol(value))return value;
  };
  args[1] = replacer;
  return _stringify.apply($JSON, args);
};
var buggyJSON = $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
});

// 19.4.1.1 Symbol([description])
if(!useNative){
  $Symbol = function Symbol(){
    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
  };
  redefine($Symbol.prototype, 'toString', function toString(){
    return this._k;
  });

  isSymbol = function(it){
    return it instanceof $Symbol;
  };

  $.create     = $create;
  $.isEnum     = $propertyIsEnumerable;
  $.getDesc    = $getOwnPropertyDescriptor;
  $.setDesc    = $defineProperty;
  $.setDescs   = $defineProperties;
  $.getNames   = $names.get = $getOwnPropertyNames;
  $.getSymbols = $getOwnPropertySymbols;

  if(DESCRIPTORS && !_dereq_('./$.library')){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }
}

var symbolStatics = {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    return keyOf(SymbolRegistry, key);
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
};
// 19.4.2.2 Symbol.hasInstance
// 19.4.2.3 Symbol.isConcatSpreadable
// 19.4.2.4 Symbol.iterator
// 19.4.2.6 Symbol.match
// 19.4.2.8 Symbol.replace
// 19.4.2.9 Symbol.search
// 19.4.2.10 Symbol.species
// 19.4.2.11 Symbol.split
// 19.4.2.12 Symbol.toPrimitive
// 19.4.2.13 Symbol.toStringTag
// 19.4.2.14 Symbol.unscopables
$.each.call((
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
  'species,split,toPrimitive,toStringTag,unscopables'
).split(','), function(it){
  var sym = wks(it);
  symbolStatics[it] = useNative ? sym : wrap(sym);
});

setter = true;

$export($export.G + $export.W, {Symbol: $Symbol});

$export($export.S, 'Symbol', symbolStatics);

$export($export.S + $export.F * !useNative, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});

// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);
},{"./$":89,"./$.an-object":58,"./$.descriptors":67,"./$.enum-keys":69,"./$.export":70,"./$.fails":71,"./$.get-names":73,"./$.global":74,"./$.has":75,"./$.is-array":81,"./$.keyof":90,"./$.library":91,"./$.property-desc":95,"./$.redefine":97,"./$.set-to-string-tag":101,"./$.shared":102,"./$.to-iobject":108,"./$.uid":111,"./$.wks":112}],130:[function(_dereq_,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = _dereq_('./$.export');

$export($export.P, 'Map', {toJSON: _dereq_('./$.collection-to-json')('Map')});
},{"./$.collection-to-json":62,"./$.export":70}],131:[function(_dereq_,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = _dereq_('./$.export');

$export($export.P, 'Set', {toJSON: _dereq_('./$.collection-to-json')('Set')});
},{"./$.collection-to-json":62,"./$.export":70}],132:[function(_dereq_,module,exports){
_dereq_('./es6.array.iterator');
var Iterators = _dereq_('./$.iterators');
Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
},{"./$.iterators":88,"./es6.array.iterator":117}],133:[function(_dereq_,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor } catch(e) { }

},{}],134:[function(_dereq_,module,exports){
"use strict"

function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe
},{}],135:[function(_dereq_,module,exports){
'use strict';

module.exports = earcut;

function earcut(points) {

    var outerNode = linkedList(points[0], true),
        node, minX, minY, maxX, maxY, x, y, size,
        len = 0,
        threshold = 80;

    for (var i = 0; len < threshold && i < points.length; i++) len += points[i].length;

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (len >= threshold) {
        node = outerNode.next;
        minX = maxX = node.p[0];
        minY = maxY = node.p[1];
        do {
            x = node.p[0];
            y = node.p[1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            node = node.next;
        } while (node !== outerNode);

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    if (points.length > 1) outerNode = eliminateHoles(points, outerNode);

    var triangles = [];
    if (outerNode) earcutLinked(outerNode, triangles, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(points, clockwise) {
    var sum = 0,
        len = points.length,
        i, j, last;

    // calculate original winding order of a polygon ring
    for (i = 0, j = len - 1; i < len; j = i++) {
        var p1 = points[i],
            p2 = points[j];
        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
    }

    // link points into circular doubly-linked list in the specified winding order
    if (clockwise === (sum > 0)) {
        for (i = 0; i < len; i++) last = insertNode(points[i], last);
    } else {
        for (i = len - 1; i >= 0; i--) last = insertNode(points[i], last);
    }

    return last;
}

function filterPoints(start) {
    // eliminate colinear or duplicate points
    var node = start,
        again;
    do {
        again = false;

        if (equals(node.p, node.next.p) || orient(node.prev.p, node.p, node.next.p) === 0) {

            node.prev.next = node.next;
            node.next.prev = node.prev;

            if (node.prevZ) node.prevZ.nextZ = node.nextZ;
            if (node.nextZ) node.nextZ.prevZ = node.prevZ;

            node = start = node.prev;

            if (node === node.next) return null;
            again = true;

        } else {
            node = node.next;
        }
    } while (again || node !== start);

    return start;
}

function earcutLinked(ear, triangles, minX, minY, size, secondPass) {
    ear = filterPoints(ear);
    if (!ear) return;

    if (!secondPass && minX !== undefined) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (isEar(ear, minX, minY, size)) {
            triangles.push(prev.p, ear.p, next.p);

            next.prev = prev;
            prev.next = next;

            if (ear.prevZ) ear.prevZ.nextZ = ear.nextZ;
            if (ear.nextZ) ear.nextZ.prevZ = ear.prevZ;

            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        if (ear === stop) {
            // if we can't find any more ears, try filtering points and cutting again
            if (!secondPass) earcutLinked(ear, triangles, minX, minY, size, true);
            // if this didn't work, try splitting the remaining polygon into two
            else splitEarcut(ear, triangles, minX, minY, size);
            break;
        }
    }
}

function isEar(ear, minX, minY, size) {

    var a = ear.prev.p,
        b = ear.p,
        c = ear.next.p,

        ax = a[0], bx = b[0], cx = c[0],
        ay = a[1], by = b[1], cy = c[1],

        abd = ax * by - ay * bx,
        acd = ax * cy - ay * cx,
        cbd = cx * by - cy * bx,
        A = abd - acd - cbd;

    if (A <= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear

    var cay = cy - ay,
        acx = ax - cx,
        aby = ay - by,
        bax = bx - ax,
        p, px, py, s, t, k, node;

    // if we use z-order curve hashing, iterate through the curve
    if (minX !== undefined) {

        // triangle bbox; min & max are calculated like this for speed
        var minTX = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
            minTY = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
            maxTX = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
            maxTY = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy),

            // z-order range for the current triangle bbox;
            minZ = zOrder(minTX, minTY, minX, minY, size),
            maxZ = zOrder(maxTX, maxTY, minX, minY, size);

        // first look for points inside the triangle in increasing z-order
        node = ear.nextZ;

        while (node && node.z <= maxZ) {
            p = node.p;
            node = node.nextZ;
            if (p === a || p === c) continue;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }

        // then look for points in decreasing z-order
        node = ear.prevZ;

        while (node && node.z >= minZ) {
            p = node.p;
            node = node.prevZ;
            if (p === a || p === c) continue;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }

    // if we don't use z-order curve hash, simply iterate through all other points
    } else {
        node = ear.next.next;

        while (node !== ear.prev) {
            p = node.p;
            node = node.next;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }
    }

    return true;
}

function splitEarcut(start, triangles, minX, minY, size) {
    // find a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // run earcut on each half
                earcutLinked(a, triangles, minX, minY, size);
                earcutLinked(c, triangles, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

function eliminateHoles(points, outerNode) {
    var len = points.length;

    var queue = [];
    for (var i = 1; i < len; i++) {
        var list = filterPoints(linkedList(points[i], false));
        if (list) queue.push(getLeftmost(list));
    }
    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode);
    }

    return outerNode;
}

function eliminateHole(holeNode, outerNode) {
    outerNode = findHoleBridge(holeNode, outerNode);
    if (outerNode) splitPolygon(holeNode, outerNode);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(holeNode, outerNode) {
    var node = outerNode,
        p = holeNode.p,
        px = p[0],
        py = p[1],
        qMax = -Infinity,
        mNode, a, b;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        a = node.p;
        b = node.next.p;

        if (py <= a[1] && py >= b[1]) {
            var qx = a[0] + (py - a[1]) * (b[0] - a[0]) / (b[1] - a[1]);
            if (qx <= px && qx > qMax) {
                qMax = qx;
                mNode = a[0] < b[0] ? node : node.next;
            }
        }
        node = node.next;
    } while (node !== outerNode);

    if (!mNode) return null;

    // look for points strictly inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var bx = mNode.p[0],
        by = mNode.p[1],
        pbd = px * by - py * bx,
        pcd = px * py - py * qMax,
        cpy = py - py,
        pcx = px - qMax,
        pby = py - by,
        bpx = bx - px,
        A = pbd - pcd - (qMax * by - py * bx),
        sign = A <= 0 ? -1 : 1,
        stop = mNode,
        tanMin = Infinity,
        mx, my, amx, s, t, tan;

    node = mNode.next;

    while (node !== stop) {

        mx = node.p[0];
        my = node.p[1];
        amx = px - mx;

        if (amx >= 0 && mx >= bx) {
            s = (cpy * mx + pcx * my - pcd) * sign;
            if (s >= 0) {
                t = (pby * mx + bpx * my + pbd) * sign;

                if (t >= 0 && A * sign - s - t >= 0) {
                    tan = Math.abs(py - my) / amx; // tangential
                    if (tan < tanMin && locallyInside(node, holeNode)) {
                        mNode = node;
                        tanMin = tan;
                    }
                }
            }
        }

        node = node.next;
    }

    return mNode;
}

function indexCurve(start, minX, minY, size) {
    var node = start;

    do {
        node.z = node.z || zOrder(node.p[0], node.p[1], minX, minY, size);
        node.prevZ = node.prev;
        node.nextZ = node.next;
        node = node.next;
    } while (node !== start);

    node.prevZ.nextZ = null;
    node.prevZ = null;

    sortLinked(node);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    while (true) {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }

            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize === 0) {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                } else if (qSize === 0 || !q) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else if (p.z <= q.z) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;

        if (numMerges <= 1) return list;

        inSize *= 2;
    }
}

// z-order of a point given coords and bbox
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into (0..1000) integer range
    x = 1000 * (x - minX) / size;
    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = 1000 * (y - minY) / size;
    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

function getLeftmost(start) {
    var node = start,
        leftmost = start;
    do {
        if (node.p[0] < leftmost.p[0]) leftmost = node;
        node = node.next;
    } while (node !== start);

    return leftmost;
}

function isValidDiagonal(a, b) {
    return !intersectsPolygon(a, a.p, b.p) &&
           locallyInside(a, b) && locallyInside(b, a) &&
           middleInside(a, a.p, b.p);
}

// winding order of triangle formed by 3 given points
function orient(p, q, r) {
    var o = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
    return o > 0 ? 1 :
           o < 0 ? -1 : 0;
}

function equals(p1, p2) {
    return p1[0] === p2[0] && p1[1] === p2[1];
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    return orient(p1, q1, p2) !== orient(p1, q1, q2) &&
           orient(p2, q2, p1) !== orient(p2, q2, q1);
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(start, a, b) {
    var node = start;
    do {
        var p1 = node.p,
            p2 = node.next.p;

        if (p1 !== a && p2 !== a && p1 !== b && p2 !== b && intersects(p1, p2, a, b)) return true;

        node = node.next;
    } while (node !== start);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return orient(a.prev.p, a.p, a.next.p) === -1 ?
        orient(a.p, b.p, a.next.p) !== -1 && orient(a.p, a.prev.p, b.p) !== -1 :
        orient(a.p, b.p, a.prev.p) === -1 || orient(a.p, a.next.p, b.p) === -1;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(start, a, b) {
    var node = start,
        inside = false,
        px = (a[0] + b[0]) / 2,
        py = (a[1] + b[1]) / 2;
    do {
        var p1 = node.p,
            p2 = node.next.p;

        if (((p1[1] > py) !== (p2[1] > py)) &&
            (px < (p2[0] - p1[0]) * (py - p1[1]) / (p2[1] - p1[1]) + p1[0])) inside = !inside;

        node = node.next;
    } while (node !== start);

    return inside;
}

function compareX(a, b) {
    return a.p[0] - b.p[0];
}

// split the polygon vertices circular doubly-linked linked list into two
function splitPolygon(a, b) {
    var a2 = new Node(a.p),
        b2 = new Node(b.p),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return a2;
}

function insertNode(point, last) {
    var node = new Node(point);

    if (!last) {
        node.prev = node;
        node.next = node;

    } else {
        node.next = last.next;
        node.prev = last;
        last.next.prev = node;
        last.next = node;
    }
    return node;
}

function Node(p) {
    this.p = p;
    this.prev = null;
    this.next = null;

    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
}

},{}],136:[function(_dereq_,module,exports){
'use strict';

module.exports = clip;

/* clip features between two axis-parallel lines:
 *     |        |
 *  ___|___     |     /
 * /   |   \____|____/
 *     |        |
 */

function clip(features, scale, k1, k2, axis, intersect, minAll, maxAll) {

    k1 /= scale;
    k2 /= scale;

    if (minAll >= k1 && maxAll <= k2) return features; // trivial accept
    else if (minAll > k2 || maxAll < k1) return null; // trivial reject

    var clipped = [];

    for (var i = 0; i < features.length; i++) {

        var feature = features[i],
            geometry = feature.geometry,
            type = feature.type,
            min, max;

        min = feature.min[axis];
        max = feature.max[axis];

        if (min >= k1 && max <= k2) { // trivial accept
            clipped.push(feature);
            continue;
        } else if (min > k2 || max < k1) continue; // trivial reject

        var slices = type === 1 ?
                clipPoints(geometry, k1, k2, axis) :
                clipGeometry(geometry, k1, k2, axis, intersect, type === 3);

        if (slices.length) {
            // if a feature got clipped, it will likely get clipped on the next zoom level as well,
            // so there's no need to recalculate bboxes
            clipped.push({
                geometry: slices,
                type: type,
                tags: features[i].tags || null,
                min: feature.min,
                max: feature.max
            });
        }
    }

    return clipped.length ? clipped : null;
}

function clipPoints(geometry, k1, k2, axis) {
    var slice = [];

    for (var i = 0; i < geometry.length; i++) {
        var a = geometry[i],
            ak = a[axis];

        if (ak >= k1 && ak <= k2) slice.push(a);
    }
    return slice;
}

function clipGeometry(geometry, k1, k2, axis, intersect, closed) {

    var slices = [];

    for (var i = 0; i < geometry.length; i++) {

        var ak = 0,
            bk = 0,
            b = null,
            points = geometry[i],
            area = points.area,
            dist = points.dist,
            len = points.length,
            a, j, last;

        var slice = [];

        for (j = 0; j < len - 1; j++) {
            a = b || points[j];
            b = points[j + 1];
            ak = bk || a[axis];
            bk = b[axis];

            if (ak < k1) {

                if ((bk > k2)) { // ---|-----|-->
                    slice.push(intersect(a, b, k1), intersect(a, b, k2));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk >= k1) slice.push(intersect(a, b, k1)); // ---|-->  |

            } else if (ak > k2) {

                if ((bk < k1)) { // <--|-----|---
                    slice.push(intersect(a, b, k2), intersect(a, b, k1));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk <= k2) slice.push(intersect(a, b, k2)); // |  <--|---

            } else {

                slice.push(a);

                if (bk < k1) { // <--|---  |
                    slice.push(intersect(a, b, k1));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk > k2) { // |  ---|-->
                    slice.push(intersect(a, b, k2));
                    if (!closed) slice = newSlice(slices, slice, area, dist);
                }
                // | --> |
            }
        }

        // add the last point
        a = points[len - 1];
        ak = a[axis];
        if (ak >= k1 && ak <= k2) slice.push(a);

        // close the polygon if its endpoints are not the same after clipping

        last = slice[slice.length - 1];
        if (closed && last && (slice[0][0] !== last[0] || slice[0][1] !== last[1])) slice.push(slice[0]);

        // add the final slice
        newSlice(slices, slice, area, dist);
    }

    return slices;
}

function newSlice(slices, slice, area, dist) {
    if (slice.length) {
        // we don't recalculate the area/length of the unclipped geometry because the case where it goes
        // below the visibility threshold as a result of clipping is rare, so we avoid doing unnecessary work
        slice.area = area;
        slice.dist = dist;

        slices.push(slice);
    }
    return [];
}

},{}],137:[function(_dereq_,module,exports){
'use strict';

module.exports = convert;

var simplify = _dereq_('./simplify');

// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data

function convert(data, tolerance) {
    var features = [];

    if (data.type === 'FeatureCollection') {
        for (var i = 0; i < data.features.length; i++) {
            convertFeature(features, data.features[i], tolerance);
        }
    } else if (data.type === 'Feature') {
        convertFeature(features, data, tolerance);

    } else {
        // single geometry or a geometry collection
        convertFeature(features, {geometry: data}, tolerance);
    }
    return features;
}

function convertFeature(features, feature, tolerance) {
    var geom = feature.geometry,
        type = geom.type,
        coords = geom.coordinates,
        tags = feature.properties,
        i, j, rings;

    if (type === 'Point') {
        features.push(create(tags, 1, [projectPoint(coords)]));

    } else if (type === 'MultiPoint') {
        features.push(create(tags, 1, project(coords)));

    } else if (type === 'LineString') {
        features.push(create(tags, 2, [project(coords, tolerance)]));

    } else if (type === 'MultiLineString' || type === 'Polygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            rings.push(project(coords[i], tolerance));
        }
        features.push(create(tags, type === 'Polygon' ? 3 : 2, rings));

    } else if (type === 'MultiPolygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
                rings.push(project(coords[i][j], tolerance));
            }
        }
        features.push(create(tags, 3, rings));

    } else if (type === 'GeometryCollection') {
        for (i = 0; i < geom.geometries.length; i++) {
            convertFeature(features, {
                geometry: geom.geometries[i],
                properties: tags
            }, tolerance);
        }

    } else {
        throw new Error('Input data is not a valid GeoJSON object.');
    }
}

function create(tags, type, geometry) {
    var feature = {
        geometry: geometry,
        type: type,
        tags: tags || null,
        min: [2, 1], // initial bbox values;
        max: [-1, 0]  // note that coords are usually in [0..1] range
    };
    calcBBox(feature);
    return feature;
}

function project(lonlats, tolerance) {
    var projected = [];
    for (var i = 0; i < lonlats.length; i++) {
        projected.push(projectPoint(lonlats[i]));
    }
    if (tolerance) {
        simplify(projected, tolerance);
        calcSize(projected);
    }
    return projected;
}

function projectPoint(p) {
    var sin = Math.sin(p[1] * Math.PI / 180),
        x = (p[0] / 360 + 0.5),
        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);

    y = y < -1 ? -1 :
        y > 1 ? 1 : y;

    return [x, y, 0];
}

// calculate area and length of the poly
function calcSize(points) {
    var area = 0,
        dist = 0;

    for (var i = 0, a, b; i < points.length - 1; i++) {
        a = b || points[i];
        b = points[i + 1];

        area += a[0] * b[1] - b[0] * a[1];

        // use Manhattan distance instead of Euclidian one to avoid expensive square root computation
        dist += Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]);
    }
    points.area = Math.abs(area / 2);
    points.dist = dist;
}

// calculate the feature bounding box for faster clipping later
function calcBBox(feature) {
    var geometry = feature.geometry,
        min = feature.min,
        max = feature.max;

    if (feature.type === 1) calcRingBBox(min, max, geometry);
    else for (var i = 0; i < geometry.length; i++) calcRingBBox(min, max, geometry[i]);

    return feature;
}

function calcRingBBox(min, max, points) {
    for (var i = 0, p; i < points.length; i++) {
        p = points[i];
        min[0] = Math.min(p[0], min[0]);
        max[0] = Math.max(p[0], max[0]);
        min[1] = Math.min(p[1], min[1]);
        max[1] = Math.max(p[1], max[1]);
    }
}

},{"./simplify":139}],138:[function(_dereq_,module,exports){
'use strict';

module.exports = geojsonvt;

var convert = _dereq_('./convert'), // GeoJSON conversion and preprocessing
    clip = _dereq_('./clip'),       // stripe clipping algorithm
    wrap = _dereq_('./wrap'),       // date line processing
    createTile = _dereq_('./tile'); // final simplified tile generation


function geojsonvt(data, options) {
    return new GeoJSONVT(data, options);
}

function GeoJSONVT(data, options) {
    options = this.options = extend(Object.create(this.options), options);

    var debug = options.debug;

    if (debug) console.time('preprocess data');

    var z2 = 1 << options.maxZoom, // 2^z
        features = convert(data, options.tolerance / (z2 * options.extent));

    this.tiles = {};
    this.tileCoords = [];

    if (debug) {
        console.timeEnd('preprocess data');
        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);
        console.time('generate tiles');
        this.stats = {};
        this.total = 0;
    }

    features = wrap(features, options.buffer / options.extent, intersectX);

    // start slicing from the top tile down
    if (features.length) this.splitTile(features, 0, 0, 0);

    if (debug) {
        if (features.length) console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);
        console.timeEnd('generate tiles');
        console.log('tiles generated:', this.total, JSON.stringify(this.stats));
    }
}

GeoJSONVT.prototype.options = {
    maxZoom: 14,            // max zoom to preserve detail on
    indexMaxZoom: 5,        // max zoom in the tile index
    indexMaxPoints: 100000, // max number of points per tile in the tile index
    solidChildren: false,   // whether to tile solid square tiles further
    tolerance: 3,           // simplification tolerance (higher means simpler)
    extent: 4096,           // tile extent
    buffer: 64,             // tile buffer on each side
    debug: 0                // logging level (0, 1 or 2)
};

GeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {

    var stack = [features, z, x, y],
        options = this.options,
        debug = options.debug;

    // avoid recursion by using a processing queue
    while (stack.length) {
        y = stack.pop();
        x = stack.pop();
        z = stack.pop();
        features = stack.pop();

        var z2 = 1 << z,
            id = toID(z, x, y),
            tile = this.tiles[id],
            tileTolerance = z === options.maxZoom ? 0 : options.tolerance / (z2 * options.extent);

        if (!tile) {
            if (debug > 1) console.time('creation');

            tile = this.tiles[id] = createTile(features, z2, x, y, tileTolerance, z === options.maxZoom);
            this.tileCoords.push({z: z, x: x, y: y});

            if (debug) {
                if (debug > 1) {
                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',
                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);
                    console.timeEnd('creation');
                }
                var key = 'z' + z;
                this.stats[key] = (this.stats[key] || 0) + 1;
                this.total++;
            }
        }

        // save reference to original geometry in tile so that we can drill down later if we stop now
        tile.source = features;

        // stop tiling if the tile is solid clipped square
        if (!options.solidChildren && isClippedSquare(tile, options.extent, options.buffer)) continue;

        // if it's the first-pass tiling
        if (!cz) {
            // stop tiling if we reached max zoom, or if the tile is too simple
            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;

        // if a drilldown to a specific tile
        } else {
            // stop tiling if we reached base zoom or our target tile zoom
            if (z === options.maxZoom || z === cz) continue;

            // stop tiling if it's not an ancestor of the target tile
            var m = 1 << (cz - z);
            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) continue;
        }

        // if we slice further down, no need to keep source geometry
        tile.source = null;

        if (debug > 1) console.time('clipping');

        // values we'll use for clipping
        var k1 = 0.5 * options.buffer / options.extent,
            k2 = 0.5 - k1,
            k3 = 0.5 + k1,
            k4 = 1 + k1,
            tl, bl, tr, br, left, right;

        tl = bl = tr = br = null;

        left  = clip(features, z2, x - k1, x + k3, 0, intersectX, tile.min[0], tile.max[0]);
        right = clip(features, z2, x + k2, x + k4, 0, intersectX, tile.min[0], tile.max[0]);

        if (left) {
            tl = clip(left, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            bl = clip(left, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (right) {
            tr = clip(right, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            br = clip(right, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (debug > 1) console.timeEnd('clipping');

        if (tl) stack.push(tl, z + 1, x * 2,     y * 2);
        if (bl) stack.push(bl, z + 1, x * 2,     y * 2 + 1);
        if (tr) stack.push(tr, z + 1, x * 2 + 1, y * 2);
        if (br) stack.push(br, z + 1, x * 2 + 1, y * 2 + 1);
    }
};

GeoJSONVT.prototype.getTile = function (z, x, y) {
    var options = this.options,
        extent = options.extent,
        debug = options.debug;

    var z2 = 1 << z;
    x = ((x % z2) + z2) % z2; // wrap tile x coordinate

    var id = toID(z, x, y);
    if (this.tiles[id]) return transformTile(this.tiles[id], extent);

    if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);

    var z0 = z,
        x0 = x,
        y0 = y,
        parent;

    while (!parent && z0 > 0) {
        z0--;
        x0 = Math.floor(x0 / 2);
        y0 = Math.floor(y0 / 2);
        parent = this.tiles[toID(z0, x0, y0)];
    }

    if (!parent) return null;

    if (debug > 1) console.log('found parent tile z%d-%d-%d', z0, x0, y0);

    // if we found a parent tile containing the original geometry, we can drill down from it
    if (parent.source) {
        if (isClippedSquare(parent, extent, options.buffer)) return transformTile(parent, extent);

        if (debug > 1) console.time('drilling down');
        this.splitTile(parent.source, z0, x0, y0, z, x, y);
        if (debug > 1) console.timeEnd('drilling down');
    }

    if (!this.tiles[id]) return null;

    return transformTile(this.tiles[id], extent);
};

function transformTile(tile, extent) {
    if (tile.transformed) return tile;

    var z2 = tile.z2,
        tx = tile.x,
        ty = tile.y,
        i, j, k;

    for (i = 0; i < tile.features.length; i++) {
        var feature = tile.features[i],
            geom = feature.geometry,
            type = feature.type;

        if (type === 1) {
            for (j = 0; j < geom.length; j++) geom[j] = transformPoint(geom[j], extent, z2, tx, ty);

        } else {
            for (j = 0; j < geom.length; j++) {
                var ring = geom[j];
                for (k = 0; k < ring.length; k++) ring[k] = transformPoint(ring[k], extent, z2, tx, ty);
            }
        }
    }

    tile.transformed = true;

    return tile;
}

function transformPoint(p, extent, z2, tx, ty) {
    var x = Math.round(extent * (p[0] * z2 - tx)),
        y = Math.round(extent * (p[1] * z2 - ty));
    return [x, y];
}

function toID(z, x, y) {
    return (((1 << z) * y + x) * 32) + z;
}

function intersectX(a, b, x) {
    return [x, (x - a[0]) * (b[1] - a[1]) / (b[0] - a[0]) + a[1], 1];
}
function intersectY(a, b, y) {
    return [(y - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0], y, 1];
}

function extend(dest, src) {
    for (var i in src) dest[i] = src[i];
    return dest;
}

// checks whether a tile is a whole-area fill after clipping; if it is, there's no sense slicing it further
function isClippedSquare(tile, extent, buffer) {

    var features = tile.source;
    if (features.length !== 1) return false;

    var feature = features[0];
    if (feature.type !== 3 || feature.geometry.length > 1) return false;

    var len = feature.geometry[0].length;
    if (len !== 5) return false;

    for (var i = 0; i < len; i++) {
        var p = transformPoint(feature.geometry[0][i], extent, tile.z2, tile.x, tile.y);
        if ((p[0] !== -buffer && p[0] !== extent + buffer) ||
            (p[1] !== -buffer && p[1] !== extent + buffer)) return false;
    }

    return true;
}

},{"./clip":136,"./convert":137,"./tile":140,"./wrap":141}],139:[function(_dereq_,module,exports){
'use strict';

module.exports = simplify;

// calculate simplification data using optimized Douglas-Peucker algorithm

function simplify(points, tolerance) {

    var sqTolerance = tolerance * tolerance,
        len = points.length,
        first = 0,
        last = len - 1,
        stack = [],
        i, maxSqDist, sqDist, index;

    // always retain the endpoints (1 is the max value)
    points[first][2] = 1;
    points[last][2] = 1;

    // avoid recursion by using a stack
    while (last) {

        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSqSegDist(points[i], points[first], points[last]);

            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            points[index][2] = maxSqDist; // save the point importance in squared pixels as a z coordinate
            stack.push(first);
            stack.push(index);
            first = index;

        } else {
            last = stack.pop();
            first = stack.pop();
        }
    }
}

// square distance from a point to a segment
function getSqSegDist(p, a, b) {

    var x = a[0], y = a[1],
        bx = b[0], by = b[1],
        px = p[0], py = p[1],
        dx = bx - x,
        dy = by - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = bx;
            y = by;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = px - x;
    dy = py - y;

    return dx * dx + dy * dy;
}

},{}],140:[function(_dereq_,module,exports){
'use strict';

module.exports = createTile;

function createTile(features, z2, tx, ty, tolerance, noSimplify) {
    var tile = {
        features: [],
        numPoints: 0,
        numSimplified: 0,
        numFeatures: 0,
        source: null,
        x: tx,
        y: ty,
        z2: z2,
        transformed: false,
        min: [2, 1],
        max: [-1, 0]
    };
    for (var i = 0; i < features.length; i++) {
        tile.numFeatures++;
        addFeature(tile, features[i], tolerance, noSimplify);

        var min = features[i].min,
            max = features[i].max;

        if (min[0] < tile.min[0]) tile.min[0] = min[0];
        if (min[1] < tile.min[1]) tile.min[1] = min[1];
        if (max[0] > tile.max[0]) tile.max[0] = max[0];
        if (max[1] > tile.max[1]) tile.max[1] = max[1];
    }
    return tile;
}

function addFeature(tile, feature, tolerance, noSimplify) {

    var geom = feature.geometry,
        type = feature.type,
        simplified = [],
        sqTolerance = tolerance * tolerance,
        i, j, ring, p;

    if (type === 1) {
        for (i = 0; i < geom.length; i++) {
            simplified.push(geom[i]);
            tile.numPoints++;
            tile.numSimplified++;
        }

    } else {

        // simplify and transform projected coordinates for tile geometry
        for (i = 0; i < geom.length; i++) {
            ring = geom[i];

            // filter out tiny polylines & polygons
            if (!noSimplify && ((type === 2 && ring.dist < tolerance) ||
                                (type === 3 && ring.area < sqTolerance))) {
                tile.numPoints += ring.length;
                continue;
            }

            var simplifiedRing = [];

            for (j = 0; j < ring.length; j++) {
                p = ring[j];
                // keep points with importance > tolerance
                if (noSimplify || p[2] > sqTolerance) {
                    simplifiedRing.push(p);
                    tile.numSimplified++;
                }
                tile.numPoints++;
            }

            simplified.push(simplifiedRing);
        }
    }

    if (simplified.length) {
        tile.features.push({
            geometry: simplified,
            type: type,
            tags: feature.tags || null
        });
    }
}

},{}],141:[function(_dereq_,module,exports){
'use strict';

var clip = _dereq_('./clip');

module.exports = wrap;

function wrap(features, buffer, intersectX) {
    var merged = features,
        left  = clip(features, 1, -1 - buffer, buffer,     0, intersectX, -1, 2), // left world copy
        right = clip(features, 1,  1 - buffer, 2 + buffer, 0, intersectX, -1, 2); // right world copy

    if (left || right) {
        merged = clip(features, 1, -buffer, 1 + buffer, 0, intersectX, -1, 2); // center world copy

        if (left) merged = shiftFeatureCoords(left, 1).concat(merged); // merge left into center
        if (right) merged = merged.concat(shiftFeatureCoords(right, -1)); // merge right into center
    }

    return merged;
}

function shiftFeatureCoords(features, offset) {
    var newFeatures = [];

    for (var i = 0; i < features.length; i++) {
        var feature = features[i],
            type = feature.type;

        var newGeometry;

        if (type === 1) {
            newGeometry = shiftCoords(feature.geometry, offset);
        } else {
            newGeometry = [];
            for (var j = 0; j < feature.geometry.length; j++) {
                newGeometry.push(shiftCoords(feature.geometry[j], offset));
            }
        }

        newFeatures.push({
            geometry: newGeometry,
            type: type,
            tags: feature.tags,
            min: [feature.min[0] + offset, feature.min[1]],
            max: [feature.max[0] + offset, feature.max[1]]
        });
    }

    return newFeatures;
}

function shiftCoords(points, offset) {
    var newPoints = [];
    newPoints.area = points.area;
    newPoints.dist = points.dist;

    for (var i = 0; i < points.length; i++) {
        newPoints.push([points[i][0] + offset, points[i][1], points[i][2]]);
    }
    return newPoints;
}

},{"./clip":136}],142:[function(_dereq_,module,exports){
module.exports = invert

/**
 * Inverts a mat3
 *
 * @alias mat3.invert
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2]
  var a10 = a[3], a11 = a[4], a12 = a[5]
  var a20 = a[6], a21 = a[7], a22 = a[8]

  var b01 = a22 * a11 - a12 * a21
  var b11 = -a22 * a10 + a12 * a20
  var b21 = a21 * a10 - a11 * a20

  // Calculate the determinant
  var det = a00 * b01 + a01 * b11 + a02 * b21

  if (!det) return null
  det = 1.0 / det

  out[0] = b01 * det
  out[1] = (-a22 * a01 + a02 * a21) * det
  out[2] = (a12 * a01 - a02 * a11) * det
  out[3] = b11 * det
  out[4] = (a22 * a00 - a02 * a20) * det
  out[5] = (-a12 * a00 + a02 * a10) * det
  out[6] = b21 * det
  out[7] = (-a21 * a00 + a01 * a20) * det
  out[8] = (a11 * a00 - a01 * a10) * det

  return out
}

},{}],143:[function(_dereq_,module,exports){
module.exports = normalFromMat4

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @alias mat3.normalFromMat4
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
function normalFromMat4(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3]
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7]
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11]
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15]

  var b00 = a00 * a11 - a01 * a10
  var b01 = a00 * a12 - a02 * a10
  var b02 = a00 * a13 - a03 * a10
  var b03 = a01 * a12 - a02 * a11
  var b04 = a01 * a13 - a03 * a11
  var b05 = a02 * a13 - a03 * a12
  var b06 = a20 * a31 - a21 * a30
  var b07 = a20 * a32 - a22 * a30
  var b08 = a20 * a33 - a23 * a30
  var b09 = a21 * a32 - a22 * a31
  var b10 = a21 * a33 - a23 * a31
  var b11 = a22 * a33 - a23 * a32

  // Calculate the determinant
  var det = b00 * b11
          - b01 * b10
          + b02 * b09
          + b03 * b08
          - b04 * b07
          + b05 * b06

  if (!det) return null
  det = 1.0 / det

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det

  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det

  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det

  return out
}

},{}],144:[function(_dereq_,module,exports){
module.exports = copy;

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],145:[function(_dereq_,module,exports){
module.exports = identity;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],146:[function(_dereq_,module,exports){
var identity = _dereq_('./identity');

module.exports = lookAt;

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < 0.000001 &&
        Math.abs(eyey - centery) < 0.000001 &&
        Math.abs(eyez - centerz) < 0.000001) {
        return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};
},{"./identity":145}],147:[function(_dereq_,module,exports){
module.exports = multiply;

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};
},{}],148:[function(_dereq_,module,exports){
module.exports = perspective;

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};
},{}],149:[function(_dereq_,module,exports){
module.exports = scale;

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],150:[function(_dereq_,module,exports){
module.exports = translate;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};
},{}],151:[function(_dereq_,module,exports){
module.exports = parseErrors

function parseErrors(log) {
  log = String(log)

  var logs = []
  var result

  while (result = log.match(/ERROR\:([^\n]+)/)) {
    log = log.slice(result.index + 1)

    var line = result[1].trim()
    var seps = line.split(':')
    var emsg = seps.slice(2).join(':').trim()
    var file = parseInt(seps[0], 10)
    var line = parseInt(seps[1], 10)

    logs.push({
        message: emsg
      , file: file
      , line: line
    })
  }

  return logs
}

},{}],152:[function(_dereq_,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],153:[function(_dereq_,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],154:[function(_dereq_,module,exports){
'use strict';


var yaml = _dereq_('./lib/js-yaml.js');


module.exports = yaml;

},{"./lib/js-yaml.js":155}],155:[function(_dereq_,module,exports){
'use strict';


var loader = _dereq_('./js-yaml/loader');
// var dumper = require('./js-yaml/dumper');


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = _dereq_('./js-yaml/type');
module.exports.Schema              = _dereq_('./js-yaml/schema');
module.exports.FAILSAFE_SCHEMA     = _dereq_('./js-yaml/schema/failsafe');
module.exports.JSON_SCHEMA         = _dereq_('./js-yaml/schema/json');
module.exports.CORE_SCHEMA         = _dereq_('./js-yaml/schema/core');
module.exports.DEFAULT_SAFE_SCHEMA = _dereq_('./js-yaml/schema/default_safe');
module.exports.DEFAULT_FULL_SCHEMA = _dereq_('./js-yaml/schema/default_full');
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
// module.exports.dump                = dumper.dump;
// module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = _dereq_('./js-yaml/exception');

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = _dereq_('./js-yaml/schema/failsafe');
module.exports.SAFE_SCHEMA    = _dereq_('./js-yaml/schema/default_safe');
module.exports.DEFAULT_SCHEMA = _dereq_('./js-yaml/schema/default_full');

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');

},{"./js-yaml/exception":157,"./js-yaml/loader":158,"./js-yaml/schema":160,"./js-yaml/schema/core":161,"./js-yaml/schema/default_full":162,"./js-yaml/schema/default_safe":163,"./js-yaml/schema/failsafe":164,"./js-yaml/schema/json":165,"./js-yaml/type":166}],156:[function(_dereq_,module,exports){
'use strict';


function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;

},{}],157:[function(_dereq_,module,exports){
// YAML error class. http://stackoverflow.com/questions/8458984
//
'use strict';

function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;

},{}],158:[function(_dereq_,module,exports){
'use strict';

/*eslint-disable max-len,no-use-before-define*/

var common              = _dereq_('./common');
var YAMLException       = _dereq_('./exception');
var Mark                = _dereq_('./mark');
var DEFAULT_SAFE_SCHEMA = _dereq_('./schema/default_safe');
var DEFAULT_FULL_SCHEMA = _dereq_('./schema/default_full');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(((c - 0x010000) >> 10) + 0xD800,
                             ((c - 0x010000) & 0x03FF) + 0xDC00);
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;
  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length;
           _position < _length;
           _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode) {
  var index, quantity;

  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = captureEnd = state.position;
        state.position++;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (detectedIndent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat('\n', emptyLines + 1);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (detectedIndent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else if (detectedIndent) {
      // If current line isn't the first one - count line break from the last content line.
      state.result += common.repeat('\n', emptyLines + 1);
    } else {
      // In case of the first content line - count only empty lines.
      state.result += common.repeat('\n', emptyLines);
    }

    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length;
           typeIndex < typeQuantity;
           typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
      type = state.typeMap[state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


function safeLoadAll(input, output, options) {
  loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;

},{"./common":156,"./exception":157,"./mark":159,"./schema/default_full":162,"./schema/default_safe":163}],159:[function(_dereq_,module,exports){
'use strict';


var common = _dereq_('./common');


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;

},{"./common":156}],160:[function(_dereq_,module,exports){
'use strict';

/*eslint-disable max-len*/

var common        = _dereq_('./common');
var YAMLException = _dereq_('./exception');
var Type          = _dereq_('./type');


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}


function compileMap(/* lists... */) {
  var result = {}, index, length;

  function collectType(type) {
    result[type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }

  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;

},{"./common":156,"./exception":157,"./type":166}],161:[function(_dereq_,module,exports){
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.


'use strict';


var Schema = _dereq_('../schema');


module.exports = new Schema({
  include: [
    _dereq_('./json')
  ]
});

},{"../schema":160,"./json":165}],162:[function(_dereq_,module,exports){
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.


'use strict';


var Schema = _dereq_('../schema');


module.exports = Schema.DEFAULT = new Schema({
  include: [
    _dereq_('./default_safe')
  ],
  explicit: [
    _dereq_('../type/js/undefined'),
    _dereq_('../type/js/regexp'),
    _dereq_('../type/js/function')
  ]
});

},{"../schema":160,"../type/js/function":171,"../type/js/regexp":172,"../type/js/undefined":173,"./default_safe":163}],163:[function(_dereq_,module,exports){
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)


'use strict';


var Schema = _dereq_('../schema');


module.exports = new Schema({
  include: [
    _dereq_('./core')
  ],
  implicit: [
    _dereq_('../type/timestamp'),
    _dereq_('../type/merge')
  ],
  explicit: [
    _dereq_('../type/binary'),
    _dereq_('../type/omap'),
    _dereq_('../type/pairs'),
    _dereq_('../type/set')
  ]
});

},{"../schema":160,"../type/binary":167,"../type/merge":175,"../type/omap":177,"../type/pairs":178,"../type/set":180,"../type/timestamp":182,"./core":161}],164:[function(_dereq_,module,exports){
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346


'use strict';


var Schema = _dereq_('../schema');


module.exports = new Schema({
  explicit: [
    _dereq_('../type/str'),
    _dereq_('../type/seq'),
    _dereq_('../type/map')
  ]
});

},{"../schema":160,"../type/map":174,"../type/seq":179,"../type/str":181}],165:[function(_dereq_,module,exports){
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.


'use strict';


var Schema = _dereq_('../schema');


module.exports = new Schema({
  include: [
    _dereq_('./failsafe')
  ],
  implicit: [
    _dereq_('../type/null'),
    _dereq_('../type/bool'),
    _dereq_('../type/int'),
    _dereq_('../type/float')
  ]
});

},{"../schema":160,"../type/bool":168,"../type/float":169,"../type/int":170,"../type/null":176,"./failsafe":164}],166:[function(_dereq_,module,exports){
'use strict';

var YAMLException = _dereq_('./exception');

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;

},{"./exception":157}],167:[function(_dereq_,module,exports){
'use strict';

/*eslint-disable no-bitwise*/

// A trick for browserified version.
// Since we make browserifier to ignore `buffer` module, NodeBuffer will be undefined
var NodeBuffer = _dereq_('buffer').Buffer;
var Type       = _dereq_('../type');


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) return new NodeBuffer(result);

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

},{"../type":166,"buffer":37}],168:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":166}],169:[function(_dereq_,module,exports){
'use strict';

var common = _dereq_('../common');
var Type   = _dereq_('../type');

var YAML_FLOAT_PATTERN = new RegExp(
  '^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' +
  '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' +
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  '|[-+]?\\.(?:inf|Inf|INF)' +
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data)) return false;

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;

  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

},{"../common":156,"../type":166}],170:[function(_dereq_,module,exports){
'use strict';

var common = _dereq_('../common');
var Type   = _dereq_('../type');

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits;
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits;
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits;
  }

  // base 10 (except 0) or base 60

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  if (!hasDigits) return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (object) { return '0b' + object.toString(2); },
    octal:       function (object) { return '0'  + object.toString(8); },
    decimal:     function (object) { return        object.toString(10); },
    hexadecimal: function (object) { return '0x' + object.toString(16).toUpperCase(); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

},{"../common":156,"../type":166}],171:[function(_dereq_,module,exports){
'use strict';

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = _dereq_;
  esprima = _require('esprima');
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

var Type = _dereq_('../../type');

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        ast.body[0].expression.type !== 'FunctionExpression') {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      ast.body[0].expression.type !== 'FunctionExpression') {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  /*eslint-disable no-new-func*/
  return new Function(params, source.slice(body[0] + 1, body[1] - 1));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

},{"../../type":166}],172:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../../type');

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

},{"../../type":166}],173:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../../type');

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

},{"../../type":166}],174:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});

},{"../type":166}],175:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

},{"../type":166}],176:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":166}],177:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

},{"../type":166}],178:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

},{"../type":166}],179:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});

},{"../type":166}],180:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

},{"../type":166}],181:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});

},{"../type":166}],182:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:(?:[Tt]|[ \\t]+)'              + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?)?$');         // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_TIMESTAMP_REGEXP.exec(data) === null) return false;
  return true;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

},{"../type":166}],183:[function(_dereq_,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    if (typeof module === 'object' && module.exports && typeof _dereq_ === 'function') {
        module.exports = definition();
    } else if (typeof define === 'function' && typeof define.amd === 'object') {
        define(definition);
    } else {
        root.log = definition();
    }
}(this, function () {
    var self = {};
    var noop = function() {};
    var undefinedType = "undefined";

    function realMethod(methodName) {
        if (typeof console === undefinedType) {
            return false; // We can't build a real method without a console to log to
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    function enableLoggingWhenConsoleArrives(methodName, level) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods(level);
                self[methodName].apply(self, arguments);
            }
        };
    }

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    function replaceLoggingMethods(level) {
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            self[methodName] = (i < level) ? noop : self.methodFactory(methodName, level);
        }
    }

    function persistLevelIfPossible(levelNum) {
        var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

        // Use localStorage if available
        try {
            window.localStorage['loglevel'] = levelName;
            return;
        } catch (ignore) {}

        // Use session cookie as fallback
        try {
            window.document.cookie = "loglevel=" + levelName + ";";
        } catch (ignore) {}
    }

    function loadPersistedLevel() {
        var storedLevel;

        try {
            storedLevel = window.localStorage['loglevel'];
        } catch (ignore) {}

        if (typeof storedLevel === undefinedType) {
            try {
                storedLevel = /loglevel=([^;]+)/.exec(window.document.cookie)[1];
            } catch (ignore) {}
        }
        
        if (self.levels[storedLevel] === undefined) {
            storedLevel = "WARN";
        }

        self.setLevel(self.levels[storedLevel]);
    }

    /*
     *
     * Public API
     *
     */

    self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
        "ERROR": 4, "SILENT": 5};

    self.methodFactory = function (methodName, level) {
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives(methodName, level);
    };

    self.setLevel = function (level) {
        if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
            level = self.levels[level.toUpperCase()];
        }
        if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
            persistLevelIfPossible(level);
            replaceLoggingMethods(level);
            if (typeof console === undefinedType && level < self.levels.SILENT) {
                return "No console available for logging";
            }
        } else {
            throw "log.setLevel() called with invalid level: " + level;
        }
    };

    self.enableAll = function() {
        self.setLevel(self.levels.TRACE);
    };

    self.disableAll = function() {
        self.setLevel(self.levels.SILENT);
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    self.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === self) {
            window.log = _log;
        }

        return self;
    };

    loadPersistedLevel();
    return self;
}));

},{}],184:[function(_dereq_,module,exports){
'use strict';

function notNull(x)  { return x != null; }
function wrap(x)     { return '(' + x + ')';}

function maybeQuote(value) {
    if (typeof value === 'string') {
        return '"' + value + '"';
    }
    return value;
}

function lookUp(key) {
    if (key[0] === '$') {
        return 'context.' + key.substring(1);
    }
    return 'context.feature.properties.' + key;
}

function nullValue(key, value) {
    return ' true ';
}

function propertyEqual(key, value) {
    return wrap(maybeQuote(value) + ' === ' + lookUp(key));
}

function propertyOr(key, values) {
    return wrap(values.map(function (x) { return propertyEqual(key, x); }).join(' || '));
}

function not(key, value) {
    return '!' + wrap(parseFilter(value));
}

function none(key, values) {
    return '!' + wrap(any(null, values));
}

function printNested(values, joiner) {
    return wrap(values.filter(notNull).map(function (x) {
        return wrap(x.join(' && '));
    }).join(' ' + joiner + ' '));
}

function any(_, values) {
    return printNested(values.map(parseFilter), '||');
}

function all(_, values) {
    return printNested(values.filter(notNull).map(parseFilter), '&&');
}

function propertyMatchesBoolean(key, value) {
    return wrap(lookUp(key) + (value ? ' != ' : ' == ')  + 'null');
}

function rangeMatch(key, values) {
    var expressions = [];

    if (values.max) {
        expressions.push('' + lookUp(key) + ' < ' + values.max);
    }

    if (values.min) {
        expressions.push('' + lookUp(key) + ' >= ' + values.min);
    }

    return wrap(expressions.join(' && '));
}

function parseFilter(filter) {
    var filterAST = [];

    // Function filter
    if (typeof filter === 'function') {
        filterAST.push(wrap(filter.toString() + '(context)'));
        return filterAST;
    }
    // Array filter, implicit 'any'
    else if (Array.isArray(filter)) {
        filterAST.push(any(null, filter));
        return filterAST;
    }

    // Object filter, e.g. implicit 'all'
    var keys = Object.keys(filter);
    for (var k=0; k < keys.length; k++) {
        var key = keys[k];

        var value = filter[key],
            type  = typeof value;
        if (type === 'string' || type === 'number') {
            filterAST.push(propertyEqual(key, value));
        } else if (type === 'boolean') {
            filterAST.push(propertyMatchesBoolean(key, value));
        } else if (value == null) {
            filterAST.push(nullValue(key, value));
        } else if (key === 'not') {
            filterAST.push(not(key, value));
        } else if (key === 'any') {
            filterAST.push(any(key, value));
        } else if (key === 'all') {
            filterAST.push(all(key, value));
        } else if (key === 'none') {
            filterAST.push(none(key, value));
        } else if (Array.isArray(value)) {
            filterAST.push(propertyOr(key, value));
        } else if (type === 'object' && value != null) {
            if (value.max || value.min) {
                filterAST.push(rangeMatch(key, value));
            }
        } else {
            throw new Error('Unknown Query sytnax: ' + value);
        }
    }

    return keys.length === 0 ? ['true'] : filterAST;
}

function filterToString(filterAST) {
    return wrap(filterAST.join(' && '));
}

function match(filter) {
    if (filter == null) { return function () { return true; }; }
    // jshint evil: true
    return new Function('context', 'return ' + filterToString(parseFilter(filter)) + ';');
}

module.exports = {
    match: match,
    filterToString: filterToString,
    parseFilter: parseFilter
};

},{}],185:[function(_dereq_,module,exports){
'use strict';

// lightweight Buffer shim for pbf browser build
// based on code from github.com/feross/buffer (MIT-licensed)

module.exports = Buffer;

var ieee754 = _dereq_('ieee754');

var BufferMethods;

function Buffer(length) {
    var arr;
    if (length && length.length) {
        arr = length;
        length = arr.length;
    }
    var buf = new Uint8Array(length || 0);
    if (arr) buf.set(arr);

    buf.readUInt32LE = BufferMethods.readUInt32LE;
    buf.writeUInt32LE = BufferMethods.writeUInt32LE;
    buf.readInt32LE = BufferMethods.readInt32LE;
    buf.writeInt32LE = BufferMethods.writeInt32LE;
    buf.readFloatLE = BufferMethods.readFloatLE;
    buf.writeFloatLE = BufferMethods.writeFloatLE;
    buf.readDoubleLE = BufferMethods.readDoubleLE;
    buf.writeDoubleLE = BufferMethods.writeDoubleLE;
    buf.toString = BufferMethods.toString;
    buf.write = BufferMethods.write;
    buf.slice = BufferMethods.slice;
    buf.copy = BufferMethods.copy;

    buf._isBuffer = true;
    return buf;
}

var lastStr, lastStrEncoded;

BufferMethods = {
    readUInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] * 0x1000000);
    },

    writeUInt32LE: function(val, pos) {
        this[pos] = val;
        this[pos + 1] = (val >>> 8);
        this[pos + 2] = (val >>> 16);
        this[pos + 3] = (val >>> 24);
    },

    readInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] << 24);
    },

    readFloatLE:  function(pos) { return ieee754.read(this, pos, true, 23, 4); },
    readDoubleLE: function(pos) { return ieee754.read(this, pos, true, 52, 8); },

    writeFloatLE:  function(val, pos) { return ieee754.write(this, val, pos, true, 23, 4); },
    writeDoubleLE: function(val, pos) { return ieee754.write(this, val, pos, true, 52, 8); },

    toString: function(encoding, start, end) {
        var str = '',
            tmp = '';

        start = start || 0;
        end = Math.min(this.length, end || this.length);

        for (var i = start; i < end; i++) {
            var ch = this[i];
            if (ch <= 0x7F) {
                str += decodeURIComponent(tmp) + String.fromCharCode(ch);
                tmp = '';
            } else {
                tmp += '%' + ch.toString(16);
            }
        }

        str += decodeURIComponent(tmp);

        return str;
    },

    write: function(str, pos) {
        var bytes = str === lastStr ? lastStrEncoded : encodeString(str);
        for (var i = 0; i < bytes.length; i++) {
            this[pos + i] = bytes[i];
        }
    },

    slice: function(start, end) {
        return this.subarray(start, end);
    },

    copy: function(buf, pos) {
        pos = pos || 0;
        for (var i = 0; i < this.length; i++) {
            buf[pos + i] = this[i];
        }
    }
};

BufferMethods.writeInt32LE = BufferMethods.writeUInt32LE;

Buffer.byteLength = function(str) {
    lastStr = str;
    lastStrEncoded = encodeString(str);
    return lastStrEncoded.length;
};

Buffer.isBuffer = function(buf) {
    return !!(buf && buf._isBuffer);
};

function encodeString(str) {
    var length = str.length,
        bytes = [];

    for (var i = 0, c, lead; i < length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {

            if (lead) {
                if (c < 0xDC00) {
                    bytes.push(0xEF, 0xBF, 0xBD);
                    lead = c;
                    continue;

                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }

            } else {
                if (c > 0xDBFF || (i + 1 === length)) bytes.push(0xEF, 0xBF, 0xBD);
                else lead = c;

                continue;
            }

        } else if (lead) {
            bytes.push(0xEF, 0xBF, 0xBD);
            lead = null;
        }

        if (c < 0x80) bytes.push(c);
        else if (c < 0x800) bytes.push(c >> 0x6 | 0xC0, c & 0x3F | 0x80);
        else if (c < 0x10000) bytes.push(c >> 0xC | 0xE0, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
        else bytes.push(c >> 0x12 | 0xF0, c >> 0xC & 0x3F | 0x80, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
    }
    return bytes;
}

},{"ieee754":152}],186:[function(_dereq_,module,exports){
(function (global){
'use strict';

module.exports = Pbf;

var Buffer = global.Buffer || _dereq_('./buffer');

function Pbf(buf) {
    this.buf = !Buffer.isBuffer(buf) ? new Buffer(buf || 0) : buf;
    this.pos = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32,
    POW_2_63 = Math.pow(2, 63);

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = this.buf.readUInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = this.buf.readInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readUInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = this.buf.readFloatLE(this.pos);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = this.buf.readDoubleLE(this.pos);
        this.pos += 8;
        return val;
    },

    readVarint: function() {
        var buf = this.buf,
            val, b, b0, b1, b2, b3;

        b0 = buf[this.pos++]; if (b0 < 0x80) return b0;                 b0 = b0 & 0x7f;
        b1 = buf[this.pos++]; if (b1 < 0x80) return b0 | b1 << 7;       b1 = (b1 & 0x7f) << 7;
        b2 = buf[this.pos++]; if (b2 < 0x80) return b0 | b1 | b2 << 14; b2 = (b2 & 0x7f) << 14;
        b3 = buf[this.pos++]; if (b3 < 0x80) return b0 | b1 | b2 | b3 << 21;

        val = b0 | b1 | b2 | (b3 & 0x7f) << 21;

        b = buf[this.pos++]; val += (b & 0x7f) * 0x10000000;         if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x800000000;        if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x40000000000;      if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x2000000000000;    if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x100000000000000;  if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x8000000000000000; if (b < 0x80) return val;

        throw new Error('Expected varint not more than 10 bytes');
    },

    readVarint64: function() {
        var startPos = this.pos,
            val = this.readVarint();

        if (val < POW_2_63) return val;

        var pos = this.pos - 2;
        while (this.buf[pos] === 0xff) pos--;
        if (pos < startPos) pos = startPos;

        val = 0;
        for (var i = 0; i < pos - startPos + 1; i++) {
            var b = ~this.buf[startPos + i] & 0x7f;
            val += i < 4 ? b << i * 7 : b * Math.pow(2, i * 7);
        }

        return -val - 1;
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos,
            str = this.buf.toString('utf8', this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.slice(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readVarint());
        return arr;
    },
    readPackedSVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            var buf = new Buffer(length);
            this.buf.copy(buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.slice(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        this.buf.writeUInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        this.buf.writeInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val;

        if (val <= 0x7f) {
            this.realloc(1);
            this.buf[this.pos++] = val;

        } else if (val <= 0x3fff) {
            this.realloc(2);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f);

        } else if (val <= 0x1fffff) {
            this.realloc(3);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 14) & 0x7f);

        } else if (val <= 0xfffffff) {
            this.realloc(4);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 14) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 21) & 0x7f);

        } else {
            var pos = this.pos;
            while (val >= 0x80) {
                this.realloc(1);
                this.buf[this.pos++] = (val & 0xff) | 0x80;
                val /= 0x80;
            }
            this.realloc(1);
            this.buf[this.pos++] = val | 0;
            if (this.pos - pos > 10) throw new Error('Given varint doesn\'t fit into 10 bytes');
        }
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        var bytes = Buffer.byteLength(str);
        this.writeVarint(bytes);
        this.realloc(bytes);
        this.buf.write(str, this.pos);
        this.pos += bytes;
    },

    writeFloat: function(val) {
        this.realloc(4);
        this.buf.writeFloatLE(val, this.pos);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        this.buf.writeDoubleLE(val, this.pos);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);

        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        var varintLen =
            len <= 0x7f ? 1 :
            len <= 0x3fff ? 2 :
            len <= 0x1fffff ? 3 :
            len <= 0xfffffff ? 4 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

        // if 1 byte isn't enough for encoding message length, shift the data to the right
        if (varintLen > 1) {
            this.realloc(varintLen - 1);
            for (var i = this.pos - 1; i >= startPos; i--) this.buf[i + varintLen - 1] = this.buf[i];
        }

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9wYmYvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGJmO1xuXG52YXIgQnVmZmVyID0gZ2xvYmFsLkJ1ZmZlciB8fCByZXF1aXJlKCcuL2J1ZmZlcicpO1xuXG5mdW5jdGlvbiBQYmYoYnVmKSB7XG4gICAgdGhpcy5idWYgPSAhQnVmZmVyLmlzQnVmZmVyKGJ1ZikgPyBuZXcgQnVmZmVyKGJ1ZiB8fCAwKSA6IGJ1ZjtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmJ1Zi5sZW5ndGg7XG59XG5cblBiZi5WYXJpbnQgID0gMDsgLy8gdmFyaW50OiBpbnQzMiwgaW50NjQsIHVpbnQzMiwgdWludDY0LCBzaW50MzIsIHNpbnQ2NCwgYm9vbCwgZW51bVxuUGJmLkZpeGVkNjQgPSAxOyAvLyA2NC1iaXQ6IGRvdWJsZSwgZml4ZWQ2NCwgc2ZpeGVkNjRcblBiZi5CeXRlcyAgID0gMjsgLy8gbGVuZ3RoLWRlbGltaXRlZDogc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHNcblBiZi5GaXhlZDMyID0gNTsgLy8gMzItYml0OiBmbG9hdCwgZml4ZWQzMiwgc2ZpeGVkMzJcblxudmFyIFNISUZUX0xFRlRfMzIgPSAoMSA8PCAxNikgKiAoMSA8PCAxNiksXG4gICAgU0hJRlRfUklHSFRfMzIgPSAxIC8gU0hJRlRfTEVGVF8zMixcbiAgICBQT1dfMl82MyA9IE1hdGgucG93KDIsIDYzKTtcblxuUGJmLnByb3RvdHlwZSA9IHtcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJ1ZiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8vID09PSBSRUFESU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICByZWFkRmllbGRzOiBmdW5jdGlvbihyZWFkRmllbGQsIHJlc3VsdCwgZW5kKSB7XG4gICAgICAgIGVuZCA9IGVuZCB8fCB0aGlzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLnJlYWRWYXJpbnQoKSxcbiAgICAgICAgICAgICAgICB0YWcgPSB2YWwgPj4gMyxcbiAgICAgICAgICAgICAgICBzdGFydFBvcyA9IHRoaXMucG9zO1xuXG4gICAgICAgICAgICByZWFkRmllbGQodGFnLCByZXN1bHQsIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0UG9zKSB0aGlzLnNraXAodmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICByZWFkTWVzc2FnZTogZnVuY3Rpb24ocmVhZEZpZWxkLCByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZpZWxkcyhyZWFkRmllbGQsIHJlc3VsdCwgdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcyk7XG4gICAgfSxcblxuICAgIHJlYWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRTRml4ZWQzMjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIC8vIDY0LWJpdCBpbnQgaGFuZGxpbmcgaXMgYmFzZWQgb24gZ2l0aHViLmNvbS9kcHcvbm9kZS1idWZmZXItbW9yZS1pbnRzIChNSVQtbGljZW5zZWQpXG5cbiAgICByZWFkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpICsgdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkU0ZpeGVkNjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zKSArIHRoaXMuYnVmLnJlYWRJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZEZsb2F0TEUodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWREb3VibGVMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYnVmID0gdGhpcy5idWYsXG4gICAgICAgICAgICB2YWwsIGIsIGIwLCBiMSwgYjIsIGIzO1xuXG4gICAgICAgIGIwID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjAgPCAweDgwKSByZXR1cm4gYjA7ICAgICAgICAgICAgICAgICBiMCA9IGIwICYgMHg3ZjtcbiAgICAgICAgYjEgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMSA8IDB4ODApIHJldHVybiBiMCB8IGIxIDw8IDc7ICAgICAgIGIxID0gKGIxICYgMHg3ZikgPDwgNztcbiAgICAgICAgYjIgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMiA8IDB4ODApIHJldHVybiBiMCB8IGIxIHwgYjIgPDwgMTQ7IGIyID0gKGIyICYgMHg3ZikgPDwgMTQ7XG4gICAgICAgIGIzID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjMgPCAweDgwKSByZXR1cm4gYjAgfCBiMSB8IGIyIHwgYjMgPDwgMjE7XG5cbiAgICAgICAgdmFsID0gYjAgfCBiMSB8IGIyIHwgKGIzICYgMHg3ZikgPDwgMjE7XG5cbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwOyAgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDsgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDQwMDAwMDAwMDAwOyAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDIwMDAwMDAwMDAwMDA7ICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwMDAwMDAwMDsgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDAwMDAwMDA7IGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhcmludCBub3QgbW9yZSB0aGFuIDEwIGJ5dGVzJyk7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zLFxuICAgICAgICAgICAgdmFsID0gdGhpcy5yZWFkVmFyaW50KCk7XG5cbiAgICAgICAgaWYgKHZhbCA8IFBPV18yXzYzKSByZXR1cm4gdmFsO1xuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcyAtIDI7XG4gICAgICAgIHdoaWxlICh0aGlzLmJ1Zltwb3NdID09PSAweGZmKSBwb3MtLTtcbiAgICAgICAgaWYgKHBvcyA8IHN0YXJ0UG9zKSBwb3MgPSBzdGFydFBvcztcblxuICAgICAgICB2YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvcyAtIHN0YXJ0UG9zICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYiA9IH50aGlzLmJ1ZltzdGFydFBvcyArIGldICYgMHg3ZjtcbiAgICAgICAgICAgIHZhbCArPSBpIDwgNCA/IGIgPDwgaSAqIDcgOiBiICogTWF0aC5wb3coMiwgaSAqIDcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC12YWwgLSAxO1xuICAgIH0sXG5cbiAgICByZWFkU1ZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBudW0gPSB0aGlzLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgcmV0dXJuIG51bSAlIDIgPT09IDEgPyAobnVtICsgMSkgLyAtMiA6IG51bSAvIDI7IC8vIHppZ3phZyBlbmNvZGluZ1xuICAgIH0sXG5cbiAgICByZWFkQm9vbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMucmVhZFZhcmludCgpKTtcbiAgICB9LFxuXG4gICAgcmVhZFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgc3RyID0gdGhpcy5idWYudG9TdHJpbmcoJ3V0ZjgnLCB0aGlzLnBvcywgZW5kKTtcbiAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIHJlYWRCeXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgYnVmZmVyID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIGVuZCk7XG4gICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH0sXG5cbiAgICAvLyB2ZXJib3NlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOyBkb2Vzbid0IGFmZmVjdCBnemlwcGVkIHNpemVcblxuICAgIHJlYWRQYWNrZWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkVmFyaW50KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU1ZhcmludCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRCb29sZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEJvb2xlYW4oKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRmxvYXQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU0ZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZFNGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG5cbiAgICBza2lwOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB2YWwgJiAweDc7XG4gICAgICAgIGlmICh0eXBlID09PSBQYmYuVmFyaW50KSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gPiAweDdmKSB7fVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuQnl0ZXMpIHRoaXMucG9zID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcztcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gUGJmLkZpeGVkMzIpIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBiZi5GaXhlZDY0KSB0aGlzLnBvcyArPSA4O1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCB0eXBlOiAnICsgdHlwZSk7XG4gICAgfSxcblxuICAgIC8vID09PSBXUklUSU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICB3cml0ZVRhZzogZnVuY3Rpb24odGFnLCB0eXBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoKHRhZyA8PCAzKSB8IHR5cGUpO1xuICAgIH0sXG5cbiAgICByZWFsbG9jOiBmdW5jdGlvbihtaW4pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDE2O1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGggPCB0aGlzLnBvcyArIG1pbikgbGVuZ3RoICo9IDI7XG5cbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5jb3B5KGJ1Zik7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgd3JpdGVGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQzMkxFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZVNGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgfSxcblxuICAgIHdyaXRlRml4ZWQ2NDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlU0ZpeGVkNjQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFsID0gK3ZhbDtcblxuICAgICAgICBpZiAodmFsIDw9IDB4N2YpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gdmFsO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4M2ZmZikge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDIpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMCkgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiA3KSAmIDB4N2YpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4MWZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMyk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMTQpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPD0gMHhmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMTQpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMjEpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHdoaWxlICh2YWwgPj0gMHg4MCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICh2YWwgJiAweGZmKSB8IDB4ODA7XG4gICAgICAgICAgICAgICAgdmFsIC89IDB4ODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMSk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IHZhbCB8IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgLSBwb3MgPiAxMCkgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiB2YXJpbnQgZG9lc25cXCd0IGZpdCBpbnRvIDEwIGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd3JpdGVTVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwgPCAwID8gLXZhbCAqIDIgLSAxIDogdmFsICogMik7XG4gICAgfSxcblxuICAgIHdyaXRlQm9vbGVhbjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoQm9vbGVhbih2YWwpKTtcbiAgICB9LFxuXG4gICAgd3JpdGVTdHJpbmc6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgdmFyIGJ5dGVzID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyKTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChieXRlcyk7XG4gICAgICAgIHRoaXMucmVhbGxvYyhieXRlcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlKHN0ciwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSBieXRlcztcbiAgICB9LFxuXG4gICAgd3JpdGVGbG9hdDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVGbG9hdExFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZURvdWJsZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVEb3VibGVMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICB9LFxuXG4gICAgd3JpdGVCeXRlczogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucmVhbGxvYyhsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IGJ1ZmZlcltpXTtcbiAgICB9LFxuXG4gICAgd3JpdGVNZXNzYWdlOiBmdW5jdGlvbih0YWcsIGZuLCBvYmopIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5CeXRlcyk7XG5cbiAgICAgICAgdGhpcy5wb3MrKzsgLy8gcmVzZXJ2ZSAxIGJ5dGUgZm9yIHNob3J0IG1lc3NhZ2UgbGVuZ3RoXG5cbiAgICAgICAgLy8gd3JpdGUgdGhlIG1lc3NhZ2UgZGlyZWN0bHkgdG8gdGhlIGJ1ZmZlciBhbmQgc2VlIGhvdyBtdWNoIHdhcyB3cml0dGVuXG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zO1xuICAgICAgICBmbihvYmosIHRoaXMpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5wb3MgLSBzdGFydFBvcztcblxuICAgICAgICB2YXIgdmFyaW50TGVuID1cbiAgICAgICAgICAgIGxlbiA8PSAweDdmID8gMSA6XG4gICAgICAgICAgICBsZW4gPD0gMHgzZmZmID8gMiA6XG4gICAgICAgICAgICBsZW4gPD0gMHgxZmZmZmYgPyAzIDpcbiAgICAgICAgICAgIGxlbiA8PSAweGZmZmZmZmYgPyA0IDogTWF0aC5jZWlsKE1hdGgubG9nKGxlbikgLyAoTWF0aC5MTjIgKiA3KSk7XG5cbiAgICAgICAgLy8gaWYgMSBieXRlIGlzbid0IGVub3VnaCBmb3IgZW5jb2RpbmcgbWVzc2FnZSBsZW5ndGgsIHNoaWZ0IHRoZSBkYXRhIHRvIHRoZSByaWdodFxuICAgICAgICBpZiAodmFyaW50TGVuID4gMSkge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKHZhcmludExlbiAtIDEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucG9zIC0gMTsgaSA+PSBzdGFydFBvczsgaS0tKSB0aGlzLmJ1ZltpICsgdmFyaW50TGVuIC0gMV0gPSB0aGlzLmJ1ZltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsbHksIHdyaXRlIHRoZSBtZXNzYWdlIGxlbmd0aCBpbiB0aGUgcmVzZXJ2ZWQgcGxhY2UgYW5kIHJlc3RvcmUgdGhlIHBvc2l0aW9uXG4gICAgICAgIHRoaXMucG9zID0gc3RhcnRQb3MgLSAxO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICB9LFxuXG4gICAgd3JpdGVQYWNrZWRWYXJpbnQ6ICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFZhcmludCwgYXJyKTsgICB9LFxuICAgIHdyaXRlUGFja2VkU1ZhcmludDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRTVmFyaW50LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZEJvb2xlYW46ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkQm9vbGVhbiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRGbG9hdDogICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZsb2F0LCBhcnIpOyAgICB9LFxuICAgIHdyaXRlUGFja2VkRG91YmxlOiAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWREb3VibGUsIGFycik7ICAgfSxcbiAgICB3cml0ZVBhY2tlZEZpeGVkMzI6ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRml4ZWQzMiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRTRml4ZWQzMjogZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNGaXhlZDMyLCBhcnIpOyB9LFxuICAgIHdyaXRlUGFja2VkRml4ZWQ2NDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRGaXhlZDY0LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU0ZpeGVkNjQsIGFycik7IH0sXG5cbiAgICB3cml0ZUJ5dGVzRmllbGQ6IGZ1bmN0aW9uKHRhZywgYnVmZmVyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlQnl0ZXMoYnVmZmVyKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQzMih2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkMzIodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQ2NCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkNjQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVNWYXJpbnQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU3RyaW5nRmllbGQ6IGZ1bmN0aW9uKHRhZywgc3RyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlU3RyaW5nKHN0cik7XG4gICAgfSxcbiAgICB3cml0ZUZsb2F0RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQzMik7XG4gICAgICAgIHRoaXMud3JpdGVGbG9hdCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVEb3VibGVGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcbiAgICAgICAgdGhpcy53cml0ZURvdWJsZSh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVCb29sZWFuRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnRGaWVsZCh0YWcsIEJvb2xlYW4odmFsKSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVQYWNrZWRWYXJpbnQoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlVmFyaW50KGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTVmFyaW50KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU1ZhcmludChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGbG9hdChhcnIsIHBiZikgICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRmxvYXQoYXJyW2ldKTsgICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWREb3VibGUoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRG91YmxlKGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRCb29sZWFuKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlQm9vbGVhbihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDMyKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQzMihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQzMihhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkMzIoYXJyW2ldKTsgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDY0KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQ2NChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQ2NChhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkNjQoYXJyW2ldKTsgfVxuIl19
},{"./buffer":185}],187:[function(_dereq_,module,exports){
'use strict';

module.exports = Point;

function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {
    clone: function() { return new Point(this.x, this.y); },

    add:     function(p) { return this.clone()._add(p);     },
    sub:     function(p) { return this.clone()._sub(p);     },
    mult:    function(k) { return this.clone()._mult(k);    },
    div:     function(k) { return this.clone()._div(k);     },
    rotate:  function(a) { return this.clone()._rotate(a);  },
    matMult: function(m) { return this.clone()._matMult(m); },
    unit:    function() { return this.clone()._unit(); },
    perp:    function() { return this.clone()._perp(); },
    round:   function() { return this.clone()._round(); },

    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    equals: function(p) {
        return this.x === p.x &&
               this.y === p.y;
    },

    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

// constructs Point from an array if necessary
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};

},{}],188:[function(_dereq_,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canMutationObserver = typeof window !== 'undefined'
    && window.MutationObserver;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    var queue = [];

    if (canMutationObserver) {
        var hiddenDiv = document.createElement("div");
        var observer = new MutationObserver(function () {
            var queueList = queue.slice();
            queue.length = 0;
            queueList.forEach(function (fn) {
                fn();
            });
        });

        observer.observe(hiddenDiv, { attributes: true });

        return function nextTick(fn) {
            if (!queue.length) {
                hiddenDiv.setAttribute('yes', 'no');
            }
            queue.push(fn);
        };
    }

    if (canPost) {
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],189:[function(_dereq_,module,exports){
/*!
 * strip-comments <https://github.com/jonschlinkert/strip-comments>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT license.
 */

'use stric';

var reBlock = '\\/\\*';
var reBlockIgnore = '\\/\\*(?!\\*?\\!)';
var reBlockEnd = '(.|[\\r\\n]|\\n)*?\\*\\/\\n?\\n?';
var reLine = /(^|[^\S\n])(?:\/\/)([\s\S]+?)$/gm;
var reLineIgnore = /(^|[^\S\n])(?:\/\/[^!])([\s\S]+?)$/gm;


/**
 * Strip all comments
 *
 * {%= docs("strip") %}
 *
 * @param   {String} `str`  file contents or string to strip.
 * @param   {Object} `opts`  options are passed to `.block`, and `.line`
 * @return  {String} String without comments.
 * @api public
 */

var strip = module.exports = function(str, opts) {
  return str ? strip.block(strip.line(str, opts), opts) : '';
};


/**
 * Strip only block comments, optionally leaving protected comments
 * (e.g. `/*!`) intact.
 *
 * {%= docs("block") %}
 *
 * @param   {String} `str`  file content or string to strip to
 * @param   {Object} `opts`  if `safe:true`, strip only comments that do not start with `/*!` or `/**!`
 * @return  {String} String without block comments.
 * @api public
 */

strip.block = function(str, opts) {
  opts = opts || {};
  var re = new RegExp(reBlock + reBlockEnd, 'gm');
  if(opts.safe) {
    re = new RegExp(reBlockIgnore + reBlockEnd, 'gm');
  }
  return str ? str.replace(re, '') : '';
};


/**
 * Strip only line comments
 *
 * {%= docs("line") %}
 *
 * @param   {String} `str`  file content or string to strip to
 * @param   {Object} `opts`  if `safe:true`, strip all that not starts with `//!`
 * @return  {String} String without line comments.
 * @api public
 */

strip.line = function(str, opts) {
  opts = opts || {};
  var re = reLine;
  if(opts.safe) {
    re = reLineIgnore;
  }
  return str ? str.replace(re, '') : '';
};

},{}],190:[function(_dereq_,module,exports){
!function() {
  var topojson = {
    version: "1.6.19",
    mesh: function(topology) { return object(topology, meshArcs.apply(this, arguments)); },
    meshArcs: meshArcs,
    merge: function(topology) { return object(topology, mergeArcs.apply(this, arguments)); },
    mergeArcs: mergeArcs,
    feature: featureOrCollection,
    neighbors: neighbors,
    presimplify: presimplify
  };

  function stitchArcs(topology, arcs) {
    var stitchedArcs = {},
        fragmentByStart = {},
        fragmentByEnd = {},
        fragments = [],
        emptyIndex = -1;

    // Stitch empty arcs first, since they may be subsumed by other arcs.
    arcs.forEach(function(i, j) {
      var arc = topology.arcs[i < 0 ? ~i : i], t;
      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
      }
    });

    arcs.forEach(function(i) {
      var e = ends(i),
          start = e[0],
          end = e[1],
          f, g;

      if (f = fragmentByEnd[start]) {
        delete fragmentByEnd[f.end];
        f.push(i);
        f.end = end;
        if (g = fragmentByStart[end]) {
          delete fragmentByStart[g.start];
          var fg = g === f ? f : f.concat(g);
          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else if (f = fragmentByStart[end]) {
        delete fragmentByStart[f.start];
        f.unshift(i);
        f.start = start;
        if (g = fragmentByEnd[start]) {
          delete fragmentByEnd[g.end];
          var gf = g === f ? f : g.concat(f);
          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else {
        f = [i];
        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
      }
    });

    function ends(i) {
      var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
      if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
      else p1 = arc[arc.length - 1];
      return i < 0 ? [p1, p0] : [p0, p1];
    }

    function flush(fragmentByEnd, fragmentByStart) {
      for (var k in fragmentByEnd) {
        var f = fragmentByEnd[k];
        delete fragmentByStart[f.start];
        delete f.start;
        delete f.end;
        f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
        fragments.push(f);
      }
    }

    flush(fragmentByEnd, fragmentByStart);
    flush(fragmentByStart, fragmentByEnd);
    arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

    return fragments;
  }

  function meshArcs(topology, o, filter) {
    var arcs = [];

    if (arguments.length > 1) {
      var geomsByArc = [],
          geom;

      function arc(i) {
        var j = i < 0 ? ~i : i;
        (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
      }

      function line(arcs) {
        arcs.forEach(arc);
      }

      function polygon(arcs) {
        arcs.forEach(line);
      }

      function geometry(o) {
        if (o.type === "GeometryCollection") o.geometries.forEach(geometry);
        else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);
      }

      var geometryType = {
        LineString: line,
        MultiLineString: polygon,
        Polygon: polygon,
        MultiPolygon: function(arcs) { arcs.forEach(polygon); }
      };

      geometry(o);

      geomsByArc.forEach(arguments.length < 3
          ? function(geoms) { arcs.push(geoms[0].i); }
          : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });
    } else {
      for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);
    }

    return {type: "MultiLineString", arcs: stitchArcs(topology, arcs)};
  }

  function mergeArcs(topology, objects) {
    var polygonsByArc = {},
        polygons = [],
        components = [];

    objects.forEach(function(o) {
      if (o.type === "Polygon") register(o.arcs);
      else if (o.type === "MultiPolygon") o.arcs.forEach(register);
    });

    function register(polygon) {
      polygon.forEach(function(ring) {
        ring.forEach(function(arc) {
          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
        });
      });
      polygons.push(polygon);
    }

    function exterior(ring) {
      return cartesianRingArea(object(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]) > 0; // TODO allow spherical?
    }

    polygons.forEach(function(polygon) {
      if (!polygon._) {
        var component = [],
            neighbors = [polygon];
        polygon._ = 1;
        components.push(component);
        while (polygon = neighbors.pop()) {
          component.push(polygon);
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
                if (!polygon._) {
                  polygon._ = 1;
                  neighbors.push(polygon);
                }
              });
            });
          });
        }
      }
    });

    polygons.forEach(function(polygon) {
      delete polygon._;
    });

    return {
      type: "MultiPolygon",
      arcs: components.map(function(polygons) {
        var arcs = [];

        // Extract the exterior (unique) arcs.
        polygons.forEach(function(polygon) {
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                arcs.push(arc);
              }
            });
          });
        });

        // Stitch the arcs into one or more rings.
        arcs = stitchArcs(topology, arcs);

        // If more than one ring is returned,
        // at most one of these rings can be the exterior;
        // this exterior ring has the same winding order
        // as any exterior ring in the original polygons.
        if ((n = arcs.length) > 1) {
          var sgn = exterior(polygons[0][0]);
          for (var i = 0, t; i < n; ++i) {
            if (sgn === exterior(arcs[i])) {
              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t;
              break;
            }
          }
        }

        return arcs;
      })
    };
  }

  function featureOrCollection(topology, o) {
    return o.type === "GeometryCollection" ? {
      type: "FeatureCollection",
      features: o.geometries.map(function(o) { return feature(topology, o); })
    } : feature(topology, o);
  }

  function feature(topology, o) {
    var f = {
      type: "Feature",
      id: o.id,
      properties: o.properties || {},
      geometry: object(topology, o)
    };
    if (o.id == null) delete f.id;
    return f;
  }

  function object(topology, o) {
    var absolute = transformAbsolute(topology.transform),
        arcs = topology.arcs;

    function arc(i, points) {
      if (points.length) points.pop();
      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {
        points.push(p = a[k].slice());
        absolute(p, k);
      }
      if (i < 0) reverse(points, n);
    }

    function point(p) {
      p = p.slice();
      absolute(p, 0);
      return p;
    }

    function line(arcs) {
      var points = [];
      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
      if (points.length < 2) points.push(points[0].slice());
      return points;
    }

    function ring(arcs) {
      var points = line(arcs);
      while (points.length < 4) points.push(points[0].slice());
      return points;
    }

    function polygon(arcs) {
      return arcs.map(ring);
    }

    function geometry(o) {
      var t = o.type;
      return t === "GeometryCollection" ? {type: t, geometries: o.geometries.map(geometry)}
          : t in geometryType ? {type: t, coordinates: geometryType[t](o)}
          : null;
    }

    var geometryType = {
      Point: function(o) { return point(o.coordinates); },
      MultiPoint: function(o) { return o.coordinates.map(point); },
      LineString: function(o) { return line(o.arcs); },
      MultiLineString: function(o) { return o.arcs.map(line); },
      Polygon: function(o) { return polygon(o.arcs); },
      MultiPolygon: function(o) { return o.arcs.map(polygon); }
    };

    return geometry(o);
  }

  function reverse(array, n) {
    var t, j = array.length, i = j - n; while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
  }

  function bisect(a, x) {
    var lo = 0, hi = a.length;
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (a[mid] < x) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }

  function neighbors(objects) {
    var indexesByArc = {}, // arc index -> array of object indexes
        neighbors = objects.map(function() { return []; });

    function line(arcs, i) {
      arcs.forEach(function(a) {
        if (a < 0) a = ~a;
        var o = indexesByArc[a];
        if (o) o.push(i);
        else indexesByArc[a] = [i];
      });
    }

    function polygon(arcs, i) {
      arcs.forEach(function(arc) { line(arc, i); });
    }

    function geometry(o, i) {
      if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
      else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
    }

    var geometryType = {
      LineString: line,
      MultiLineString: polygon,
      Polygon: polygon,
      MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
    };

    objects.forEach(geometry);

    for (var i in indexesByArc) {
      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
        for (var k = j + 1; k < m; ++k) {
          var ij = indexes[j], ik = indexes[k], n;
          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
        }
      }
    }

    return neighbors;
  }

  function presimplify(topology, triangleArea) {
    var absolute = transformAbsolute(topology.transform),
        relative = transformRelative(topology.transform),
        heap = minAreaHeap();

    if (!triangleArea) triangleArea = cartesianTriangleArea;

    topology.arcs.forEach(function(arc) {
      var triangles = [],
          maxArea = 0,
          triangle;

      // To store each point’s effective area, we create a new array rather than
      // extending the passed-in point to workaround a Chrome/V8 bug (getting
      // stuck in smi mode). For midpoints, the initial effective area of
      // Infinity will be computed in the next step.
      for (var i = 0, n = arc.length, p; i < n; ++i) {
        p = arc[i];
        absolute(arc[i] = [p[0], p[1], Infinity], i);
      }

      for (var i = 1, n = arc.length - 1; i < n; ++i) {
        triangle = arc.slice(i - 1, i + 2);
        triangle[1][2] = triangleArea(triangle);
        triangles.push(triangle);
        heap.push(triangle);
      }

      for (var i = 0, n = triangles.length; i < n; ++i) {
        triangle = triangles[i];
        triangle.previous = triangles[i - 1];
        triangle.next = triangles[i + 1];
      }

      while (triangle = heap.pop()) {
        var previous = triangle.previous,
            next = triangle.next;

        // If the area of the current point is less than that of the previous point
        // to be eliminated, use the latter's area instead. This ensures that the
        // current point cannot be eliminated without eliminating previously-
        // eliminated points.
        if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;
        else maxArea = triangle[1][2];

        if (previous) {
          previous.next = next;
          previous[2] = triangle[2];
          update(previous);
        }

        if (next) {
          next.previous = previous;
          next[0] = triangle[0];
          update(next);
        }
      }

      arc.forEach(relative);
    });

    function update(triangle) {
      heap.remove(triangle);
      triangle[1][2] = triangleArea(triangle);
      heap.push(triangle);
    }

    return topology;
  };

  function cartesianRingArea(ring) {
    var i = -1,
        n = ring.length,
        a,
        b = ring[n - 1],
        area = 0;

    while (++i < n) {
      a = b;
      b = ring[i];
      area += a[0] * b[1] - a[1] * b[0];
    }

    return area * .5;
  }

  function cartesianTriangleArea(triangle) {
    var a = triangle[0], b = triangle[1], c = triangle[2];
    return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));
  }

  function compareArea(a, b) {
    return a[1][2] - b[1][2];
  }

  function minAreaHeap() {
    var heap = {},
        array = [],
        size = 0;

    heap.push = function(object) {
      up(array[object._ = size] = object, size++);
      return size;
    };

    heap.pop = function() {
      if (size <= 0) return;
      var removed = array[0], object;
      if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);
      return removed;
    };

    heap.remove = function(removed) {
      var i = removed._, object;
      if (array[i] !== removed) return; // invalid request
      if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);
      return i;
    };

    function up(object, i) {
      while (i > 0) {
        var j = ((i + 1) >> 1) - 1,
            parent = array[j];
        if (compareArea(object, parent) >= 0) break;
        array[parent._ = i] = parent;
        array[object._ = i = j] = object;
      }
    }

    function down(object, i) {
      while (true) {
        var r = (i + 1) << 1,
            l = r - 1,
            j = i,
            child = array[j];
        if (l < size && compareArea(array[l], child) < 0) child = array[j = l];
        if (r < size && compareArea(array[r], child) < 0) child = array[j = r];
        if (j === i) break;
        array[child._ = i] = child;
        array[object._ = i = j] = object;
      }
    }

    return heap;
  }

  function transformAbsolute(transform) {
    if (!transform) return noop;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(point, i) {
      if (!i) x0 = y0 = 0;
      point[0] = (x0 += point[0]) * kx + dx;
      point[1] = (y0 += point[1]) * ky + dy;
    };
  }

  function transformRelative(transform) {
    if (!transform) return noop;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(point, i) {
      if (!i) x0 = y0 = 0;
      var x1 = (point[0] - dx) / kx | 0,
          y1 = (point[1] - dy) / ky | 0;
      point[0] = x1 - x0;
      point[1] = y1 - y0;
      x0 = x1;
      y0 = y1;
    };
  }

  function noop() {}

  if (typeof define === "function" && define.amd) define(topojson);
  else if (typeof module === "object" && module.exports) module.exports = topojson;
  else this.topojson = topojson;
}();

},{}],191:[function(_dereq_,module,exports){
(function (global,Buffer){
'use strict'

var bits = _dereq_('bit-twiddle')
var dup = _dereq_('dup')

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8   : dup([32, 0])
    , UINT16  : dup([32, 0])
    , UINT32  : dup([32, 0])
    , INT8    : dup([32, 0])
    , INT16   : dup([32, 0])
    , INT32   : dup([32, 0])
    , FLOAT   : dup([32, 0])
    , DOUBLE  : dup([32, 0])
    , DATA    : dup([32, 0])
    , UINT8C  : dup([32, 0])
    , BUFFER  : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},_dereq_("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy90eXBlZGFycmF5LXBvb2wvcG9vbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG52YXIgYml0cyA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJylcbnZhciBkdXAgPSByZXF1aXJlKCdkdXAnKVxuXG4vL0xlZ2FjeSBwb29sIHN1cHBvcnRcbmlmKCFnbG9iYWwuX19UWVBFREFSUkFZX1BPT0wpIHtcbiAgZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MID0ge1xuICAgICAgVUlOVDggICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDE2ICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDMyICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UOCAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UMTYgICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UMzIgICA6IGR1cChbMzIsIDBdKVxuICAgICwgRkxPQVQgICA6IGR1cChbMzIsIDBdKVxuICAgICwgRE9VQkxFICA6IGR1cChbMzIsIDBdKVxuICAgICwgREFUQSAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDhDICA6IGR1cChbMzIsIDBdKVxuICAgICwgQlVGRkVSICA6IGR1cChbMzIsIDBdKVxuICB9XG59XG5cbnZhciBoYXNVaW50OEMgPSAodHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSAhPT0gJ3VuZGVmaW5lZCdcbnZhciBQT09MID0gZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MXG5cbi8vVXBncmFkZSBwb29sXG5pZighUE9PTC5VSU5UOEMpIHtcbiAgUE9PTC5VSU5UOEMgPSBkdXAoWzMyLCAwXSlcbn1cbmlmKCFQT09MLkJVRkZFUikge1xuICBQT09MLkJVRkZFUiA9IGR1cChbMzIsIDBdKVxufVxuXG4vL05ldyB0ZWNobmlxdWU6IE9ubHkgYWxsb2NhdGUgZnJvbSBBcnJheUJ1ZmZlclZpZXcgYW5kIEJ1ZmZlclxudmFyIERBVEEgICAgPSBQT09MLkRBVEFcbiAgLCBCVUZGRVIgID0gUE9PTC5CVUZGRVJcblxuZXhwb3J0cy5mcmVlID0gZnVuY3Rpb24gZnJlZShhcnJheSkge1xuICBpZihCdWZmZXIuaXNCdWZmZXIoYXJyYXkpKSB7XG4gICAgQlVGRkVSW2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxuICB9IGVsc2Uge1xuICAgIGlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnJheSkgIT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIGFycmF5ID0gYXJyYXkuYnVmZmVyXG4gICAgfVxuICAgIGlmKCFhcnJheSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBuID0gYXJyYXkubGVuZ3RoIHx8IGFycmF5LmJ5dGVMZW5ndGhcbiAgICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobil8MFxuICAgIERBVEFbbG9nX25dLnB1c2goYXJyYXkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZnJlZUFycmF5QnVmZmVyKGJ1ZmZlcikge1xuICBpZighYnVmZmVyKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG4gPSBidWZmZXIubGVuZ3RoIHx8IGJ1ZmZlci5ieXRlTGVuZ3RoXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICBEQVRBW2xvZ19uXS5wdXNoKGJ1ZmZlcilcbn1cblxuZnVuY3Rpb24gZnJlZVR5cGVkQXJyYXkoYXJyYXkpIHtcbiAgZnJlZUFycmF5QnVmZmVyKGFycmF5LmJ1ZmZlcilcbn1cblxuZXhwb3J0cy5mcmVlVWludDggPVxuZXhwb3J0cy5mcmVlVWludDE2ID1cbmV4cG9ydHMuZnJlZVVpbnQzMiA9XG5leHBvcnRzLmZyZWVJbnQ4ID1cbmV4cG9ydHMuZnJlZUludDE2ID1cbmV4cG9ydHMuZnJlZUludDMyID1cbmV4cG9ydHMuZnJlZUZsb2F0MzIgPSBcbmV4cG9ydHMuZnJlZUZsb2F0ID1cbmV4cG9ydHMuZnJlZUZsb2F0NjQgPSBcbmV4cG9ydHMuZnJlZURvdWJsZSA9IFxuZXhwb3J0cy5mcmVlVWludDhDbGFtcGVkID0gXG5leHBvcnRzLmZyZWVEYXRhVmlldyA9IGZyZWVUeXBlZEFycmF5XG5cbmV4cG9ydHMuZnJlZUFycmF5QnVmZmVyID0gZnJlZUFycmF5QnVmZmVyXG5cbmV4cG9ydHMuZnJlZUJ1ZmZlciA9IGZ1bmN0aW9uIGZyZWVCdWZmZXIoYXJyYXkpIHtcbiAgQlVGRkVSW2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxufVxuXG5leHBvcnRzLm1hbGxvYyA9IGZ1bmN0aW9uIG1hbGxvYyhuLCBkdHlwZSkge1xuICBpZihkdHlwZSA9PT0gdW5kZWZpbmVkIHx8IGR0eXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgcmV0dXJuIG1hbGxvY0FycmF5QnVmZmVyKG4pXG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoKGR0eXBlKSB7XG4gICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OChuKVxuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQxNihuKVxuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQzMihuKVxuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQ4KG4pXG4gICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQxNihuKVxuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jSW50MzIobilcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jRmxvYXQobilcbiAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0RvdWJsZShuKVxuICAgICAgY2FzZSAndWludDhfY2xhbXBlZCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OENsYW1wZWQobilcbiAgICAgIGNhc2UgJ2J1ZmZlcic6XG4gICAgICAgIHJldHVybiBtYWxsb2NCdWZmZXIobilcbiAgICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgY2FzZSAnZGF0YXZpZXcnOlxuICAgICAgICByZXR1cm4gbWFsbG9jRGF0YVZpZXcobilcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gbWFsbG9jQXJyYXlCdWZmZXIobikge1xuICB2YXIgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBkID0gREFUQVtsb2dfbl1cbiAgaWYoZC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGQucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKG4pXG59XG5leHBvcnRzLm1hbGxvY0FycmF5QnVmZmVyID0gbWFsbG9jQXJyYXlCdWZmZXJcblxuZnVuY3Rpb24gbWFsbG9jVWludDgobikge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQ4ID0gbWFsbG9jVWludDhcblxuZnVuY3Rpb24gbWFsbG9jVWludDE2KG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShtYWxsb2NBcnJheUJ1ZmZlcigyKm4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50MTYgPSBtYWxsb2NVaW50MTZcblxuZnVuY3Rpb24gbWFsbG9jVWludDMyKG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50MzIgPSBtYWxsb2NVaW50MzJcblxuZnVuY3Rpb24gbWFsbG9jSW50OChuKSB7XG4gIHJldHVybiBuZXcgSW50OEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQ4ID0gbWFsbG9jSW50OFxuXG5mdW5jdGlvbiBtYWxsb2NJbnQxNihuKSB7XG4gIHJldHVybiBuZXcgSW50MTZBcnJheShtYWxsb2NBcnJheUJ1ZmZlcigyKm4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQxNiA9IG1hbGxvY0ludDE2XG5cbmZ1bmN0aW9uIG1hbGxvY0ludDMyKG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDMyID0gbWFsbG9jSW50MzJcblxuZnVuY3Rpb24gbWFsbG9jRmxvYXQobikge1xuICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NGbG9hdDMyID0gZXhwb3J0cy5tYWxsb2NGbG9hdCA9IG1hbGxvY0Zsb2F0XG5cbmZ1bmN0aW9uIG1hbGxvY0RvdWJsZShuKSB7XG4gIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDgqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0Zsb2F0NjQgPSBleHBvcnRzLm1hbGxvY0RvdWJsZSA9IG1hbGxvY0RvdWJsZVxuXG5mdW5jdGlvbiBtYWxsb2NVaW50OENsYW1wZWQobikge1xuICBpZihoYXNVaW50OEMpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYWxsb2NVaW50OChuKVxuICB9XG59XG5leHBvcnRzLm1hbGxvY1VpbnQ4Q2xhbXBlZCA9IG1hbGxvY1VpbnQ4Q2xhbXBlZFxuXG5mdW5jdGlvbiBtYWxsb2NEYXRhVmlldyhuKSB7XG4gIHJldHVybiBuZXcgRGF0YVZpZXcobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0RhdGFWaWV3ID0gbWFsbG9jRGF0YVZpZXdcblxuZnVuY3Rpb24gbWFsbG9jQnVmZmVyKG4pIHtcbiAgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBjYWNoZSA9IEJVRkZFUltsb2dfbl1cbiAgaWYoY2FjaGUubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBjYWNoZS5wb3AoKVxuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKG4pXG59XG5leHBvcnRzLm1hbGxvY0J1ZmZlciA9IG1hbGxvY0J1ZmZlclxuXG5leHBvcnRzLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICBmb3IodmFyIGk9MDsgaTwzMjsgKytpKSB7XG4gICAgUE9PTC5VSU5UOFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UMTZbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDMyW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDhbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UMTZbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UMzJbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuRkxPQVRbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuRE9VQkxFW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQ4Q1tpXS5sZW5ndGggPSAwXG4gICAgREFUQVtpXS5sZW5ndGggPSAwXG4gICAgQlVGRkVSW2ldLmxlbmd0aCA9IDBcbiAgfVxufSJdfQ==
},{"bit-twiddle":29,"buffer":38,"dup":134}],192:[function(_dereq_,module,exports){
module.exports.VectorTile = _dereq_('./lib/vectortile.js');
module.exports.VectorTileFeature = _dereq_('./lib/vectortilefeature.js');
module.exports.VectorTileLayer = _dereq_('./lib/vectortilelayer.js');

},{"./lib/vectortile.js":193,"./lib/vectortilefeature.js":194,"./lib/vectortilelayer.js":195}],193:[function(_dereq_,module,exports){
'use strict';

var VectorTileLayer = _dereq_('./vectortilelayer');

module.exports = VectorTile;

function VectorTile(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
    if (tag === 3) {
        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length) layers[layer.name] = layer;
    }
}


},{"./vectortilelayer":195}],194:[function(_dereq_,module,exports){
'use strict';

var Point = _dereq_('point-geometry');

module.exports = VectorTileFeature;

function VectorTileFeature(pbf, end, extent, keys, values) {
    // Public
    this.properties = {};
    this.extent = extent;
    this.type = 0;

    // Private
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;

    pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
    if (tag == 1) feature._id = pbf.readVarint();
    else if (tag == 2) readTag(pbf, feature);
    else if (tag == 3) feature.type = pbf.readVarint();
    else if (tag == 4) feature._geometry = pbf.pos;
}

function readTag(pbf, feature) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()],
            value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();

            if (cmd === 1) { // moveTo
                if (line) lines.push(line);
                line = [];
            }

            line.push(new Point(x, y));

        } else if (cmd === 7) {
            line.push(line[0].clone()); // closePolygon

        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) lines.push(line);

    return lines;
};

VectorTileFeature.prototype.bbox = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (x < x1) x1 = x;
            if (x > x2) x2 = x;
            if (y < y1) y1 = y;
            if (y > y2) y2 = y;

        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

VectorTileFeature.prototype.toGeoJSON = function(x, y, z) {
    var size = this.extent * Math.pow(2, z),
        x0 = this.extent * x,
        y0 = this.extent * y,
        coords = this.loadGeometry(),
        type = VectorTileFeature.types[this.type];

    for (var i = 0; i < coords.length; i++) {
        var line = coords[i];
        for (var j = 0; j < line.length; j++) {
            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [
                (p.x + x0) * 360 / size - 180,
                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
            ];
        }
    }

    if (type === 'Point' && coords.length === 1) {
        coords = coords[0][0];
    } else if (type === 'Point') {
        coords = coords[0];
        type = 'MultiPoint';
    } else if (type === 'LineString' && coords.length === 1) {
        coords = coords[0];
    } else if (type === 'LineString') {
        type = 'MultiLineString';
    }

    return {
        type: "Feature",
        geometry: {
            type: type,
            coordinates: coords
        },
        properties: this.properties
    };
};

},{"point-geometry":187}],195:[function(_dereq_,module,exports){
'use strict';

var VectorTileFeature = _dereq_('./vectortilefeature.js');

module.exports = VectorTileLayer;

function VectorTileLayer(pbf, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];

    pbf.readFields(readLayer, this, end);

    this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
    if (tag === 15) layer.version = pbf.readVarint();
    else if (tag === 1) layer.name = pbf.readString();
    else if (tag === 5) layer.extent = pbf.readVarint();
    else if (tag === 2) layer._features.push(pbf.pos);
    else if (tag === 3) layer._keys.push(pbf.readString());
    else if (tag === 4) layer._values.push(readValueMessage(pbf));
}

function readValueMessage(pbf) {
    var value = null,
        end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;

        value = tag === 1 ? pbf.readString() :
            tag === 2 ? pbf.readFloat() :
            tag === 3 ? pbf.readDouble() :
            tag === 4 ? pbf.readVarint64() :
            tag === 5 ? pbf.readVarint() :
            tag === 6 ? pbf.readSVarint() :
            tag === 7 ? pbf.readBoolean() : null;
    }

    return value;
}

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

    this._pbf.pos = this._features[i];

    var end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
};

},{"./vectortilefeature.js":194}],196:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsUtils = _dereq_('./utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _glShader_program = _dereq_('./gl/shader_program');

var _glShader_program2 = _interopRequireDefault(_glShader_program);

var _utilsGlMatrix = _dereq_('./utils/gl-matrix');

// Abstract base class

var Camera = (function () {
    function Camera(name, view) {
        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, Camera);

        this.view = view;
        this.position = options.position;
        this.zoom = options.zoom;
    }

    /**
        Perspective matrix projection
    
        This is a specialized perspective camera that, given a desired camera focal length (which can also vary by zoom level),
        constrains the camera height above the ground plane such that the displayed ground area of the map matches that of
        a traditional web mercator map. This means you can set the camera location by [lat, lng, zoom] as you would a typical
        web mercator map, then adjust the focal length as needed.
    
        Vanishing point can also be adjusted to achieve different "viewing angles", e.g. instead of looking straight down into
        the center of the viewport, the camera appears to be tilted at an angle. For example:
    
        [0, 0] = looking towards center of viewport
        [-250, -250] = looking 250 pixels from the viewport center to the lower-left corner
        [400, 0] = looking 400 pixels to the right of the viewport center
    */

    // Create a camera by type name, factory-style

    _createClass(Camera, [{
        key: 'update',

        // Update method called once per frame
        value: function update() {}

        // Called once per frame per program (e.g. for main render pass, then for each additional pass for feature selection, etc.)
    }, {
        key: 'setupProgram',
        value: function setupProgram(program) {}

        // Sync camera position/zoom to scene view
    }, {
        key: 'updateView',
        value: function updateView() {
            if (this.position || this.zoom) {
                var view = {};
                if (this.position) {
                    view = { lng: this.position[0], lat: this.position[1], zoom: this.position[2] };
                }
                if (this.zoom) {
                    view.zoom = this.zoom;
                }
                this.view.setView(view);
            }
        }

        // Set model-view and normal matrices
    }, {
        key: 'setupMatrices',
        value: function setupMatrices(matrices, program) {
            // Model view matrix - transform tile space into view space (meters, relative to camera)
            _utilsGlMatrix.mat4.multiply(matrices.model_view32, this.view_matrix, matrices.model);
            program.uniform('Matrix4fv', 'u_modelView', false, matrices.model_view32);

            // Normal matrices - transforms surface normals into view space
            _utilsGlMatrix.mat3.normalFromMat4(matrices.normal32, matrices.model_view32);
            _utilsGlMatrix.mat3.invert(matrices.inverse_normal32, matrices.normal32);
            program.uniform('Matrix3fv', 'u_normalMatrix', false, matrices.normal32);
            program.uniform('Matrix3fv', 'u_inverseNormalMatrix', false, matrices.inverse_normal32);
        }
    }], [{
        key: 'create',
        value: function create(name, view, config) {
            switch (config.type) {
                case 'isometric':
                    return new IsometricCamera(name, view, config);
                case 'flat':
                    return new FlatCamera(name, view, config);
                case 'perspective':
                /* falls through */
                default:
                    return new PerspectiveCamera(name, view, config);
            }
        }
    }]);

    return Camera;
})();

exports['default'] = Camera;

var PerspectiveCamera = (function (_Camera) {
    _inherits(PerspectiveCamera, _Camera);

    function PerspectiveCamera(name, view) {
        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, PerspectiveCamera);

        _get(Object.getPrototypeOf(PerspectiveCamera.prototype), 'constructor', this).call(this, name, view, options);
        this.type = 'perspective';

        // a single scalar, or pairs of stops mapping zoom levels, e.g. [zoom, focal length]
        this.focal_length = options.focal_length;
        this.fov = options.fov;
        if (!this.focal_length && !this.fov) {
            // Default focal length ranges by zoom
            this.focal_length = [[16, 2], [17, 2.5], [18, 3], [19, 4], [20, 6]];
        }

        this.vanishing_point = options.vanishing_point || [0, 0]; // [x, y]
        this.vanishing_point = this.vanishing_point.map(parseFloat); // we implicitly only support px units here
        this.vanishing_point_skew = [];

        this.position_meters = null;
        this.view_matrix = new Float64Array(16);
        this.projection_matrix = new Float32Array(16);

        // 'camera' is the name of the shader block, e.g. determines where in the shader this code is injected
        _glShader_program2['default'].replaceBlock('camera', '\n            uniform mat4 u_projection;\n            uniform vec3 u_eye;\n            uniform vec2 u_vanishing_point;\n\n            void cameraProjection (inout vec4 position) {\n                position = u_projection * position;\n            }');
    }

    // Isometric-style projection
    // Note: this is actually an "axonometric" projection, but I'm using the colloquial term isometric because it is more recognizable.
    // An isometric projection is a specific subset of axonometric projections.
    // 'axis' determines the xy skew applied to a vertex based on its z coordinate, e.g. [0, 1] axis causes buildings to be drawn
    // straight upwards on screen at their true height, [0, .5] would draw them up at half-height, [1, 0] would be sideways, etc.

    // Constrains the camera so that the viewable area matches given the viewport height
    // (in world space, e.g. meters), given either a camera focal length or field-of-view
    // (focal length is used if both are passed).

    _createClass(PerspectiveCamera, [{
        key: 'constrainCamera',
        value: function constrainCamera(_ref) {
            var view_height = _ref.view_height;
            var height = _ref.height;
            var focal_length = _ref.focal_length;
            var fov = _ref.fov;

            // Solve for camera height
            if (!height) {
                // We have focal length, calculate FOV
                if (focal_length) {
                    fov = Math.atan(1 / focal_length) * 2;
                }
                // We have FOV, calculate focal length
                else if (fov) {
                        fov = fov * Math.PI / 180; // convert FOV degrees to radians
                        focal_length = 1 / Math.tan(fov / 2);
                    }

                // Distance that camera should be from ground such that it fits the field of view expected
                // for a conventional web mercator map at the current zoom level and camera focal length
                height = view_height / 2 * focal_length;
            }
            // Solve for camera focal length / field-of-view
            else {
                    focal_length = 2 * height / view_height;
                    fov = Math.atan(1 / focal_length) * 2;
                }

            return { view_height: view_height, height: height, focal_length: focal_length, fov: fov };
        }
    }, {
        key: 'updateMatrices',
        value: function updateMatrices() {
            // TODO: only re-calculate these vars when necessary

            // Height of the viewport in meters at current zoom
            var viewport_height = this.view.size.css.height * this.view.meters_per_pixel;

            // Compute camera properties to fit desired view

            var _constrainCamera = this.constrainCamera({
                view_height: viewport_height,
                focal_length: _utilsUtils2['default'].interpolate(this.view.zoom, this.focal_length),
                fov: _utilsUtils2['default'].interpolate(this.view.zoom, this.fov)
            });

            var height = _constrainCamera.height;
            var fov = _constrainCamera.fov;

            // View matrix
            var position = [this.view.center.meters.x, this.view.center.meters.y, height];
            this.position_meters = position;

            // mat4.lookAt(this.view_matrix,
            //     vec3.fromValues(...position),
            //     vec3.fromValues(position[0], position[1], height - 1),
            //     vec3.fromValues(0, 1, 0));
            // Exclude camera height from view matrix
            _utilsGlMatrix.mat4.lookAt(this.view_matrix, _utilsGlMatrix.vec3.fromValues(position[0], position[1], 0), _utilsGlMatrix.vec3.fromValues(position[0], position[1], -1), _utilsGlMatrix.vec3.fromValues(0, 1, 0));

            // Projection matrix
            _utilsGlMatrix.mat4.perspective(this.projection_matrix, fov, this.view.aspect, 1, height * 2);

            // Convert vanishing point from pixels to viewport space
            this.vanishing_point_skew[0] = this.vanishing_point[0] / this.view.size.css.width;
            this.vanishing_point_skew[1] = this.vanishing_point[1] / this.view.size.css.height;

            // Adjust projection matrix to include vanishing point skew
            this.projection_matrix[8] = -this.vanishing_point_skew[0]; // z column of x row, e.g. amount z skews x
            this.projection_matrix[9] = -this.vanishing_point_skew[1]; // z column of y row, e.g. amount z skews y

            // Translate geometry into the distance so that camera is appropriate height above ground
            // Additionally, adjust xy to compensate for any vanishing point skew, e.g. move geometry so that the displayed g
            // plane of the map matches that expected by a traditional web mercator map at this [lat, lng, zoom].
            _utilsGlMatrix.mat4.translate(this.projection_matrix, this.projection_matrix, _utilsGlMatrix.vec3.fromValues(viewport_height / 2 * this.view.aspect * -this.vanishing_point_skew[0], viewport_height / 2 * -this.vanishing_point_skew[1], 0));

            // Include camera height in projection matrix
            _utilsGlMatrix.mat4.translate(this.projection_matrix, this.projection_matrix, _utilsGlMatrix.vec3.fromValues(0, 0, -height));
        }
    }, {
        key: 'update',
        value: function update() {
            _get(Object.getPrototypeOf(PerspectiveCamera.prototype), 'update', this).call(this);
            this.updateMatrices();
        }
    }, {
        key: 'setupProgram',
        value: function setupProgram(program) {
            program.uniform('Matrix4fv', 'u_projection', false, this.projection_matrix);
            program.uniform('3f', 'u_eye', 0, 0, this.position_meters[2]);
            program.uniform('2fv', 'u_vanishing_point', this.vanishing_point_skew);
        }
    }]);

    return PerspectiveCamera;
})(Camera);

var IsometricCamera = (function (_Camera2) {
    _inherits(IsometricCamera, _Camera2);

    function IsometricCamera(name, view) {
        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, IsometricCamera);

        _get(Object.getPrototypeOf(IsometricCamera.prototype), 'constructor', this).call(this, name, view, options);
        this.type = 'isometric';
        this.axis = options.axis || { x: 0, y: 1 };
        if (this.axis.length === 2) {
            this.axis = { x: this.axis[0], y: this.axis[1] }; // allow axis to also be passed as 2-elem array
        }

        this.position_meters = null;
        this.viewport_height = null;

        this.view_matrix = new Float64Array(16);
        this.projection_matrix = new Float32Array(16);

        // 'camera' is the name of the shader block, e.g. determines where in the shader this code is injected
        _glShader_program2['default'].replaceBlock('camera', '\n            uniform mat4 u_projection;\n            uniform vec3 u_eye;\n            uniform vec2 u_vanishing_point;\n\n            void cameraProjection (inout vec4 position) {\n                position = u_projection * position;\n                // position.xy += position.z * u_isometric_axis;\n\n                // Reverse z for depth buffer so up is negative,\n                // and scale down values so objects higher than one screen height will not get clipped\n                // pull forward slightly to avoid going past far clipping plane\n                position.z = -position.z / 100. + 1. - 0.001;\n            }');
    }

    // Flat projection (e.g. just top-down, no perspective) - a degenerate isometric camera

    _createClass(IsometricCamera, [{
        key: 'update',
        value: function update() {
            _get(Object.getPrototypeOf(IsometricCamera.prototype), 'update', this).call(this);

            this.viewport_height = this.view.size.css.height * this.view.meters_per_pixel;
            var position = [this.view.center.meters.x, this.view.center.meters.y, this.viewport_height];
            this.position_meters = position;

            // View
            _utilsGlMatrix.mat4.identity(this.view_matrix);
            _utilsGlMatrix.mat4.translate(this.view_matrix, this.view_matrix, _utilsGlMatrix.vec3.fromValues(-position[0], -position[1], 0));

            // Projection
            _utilsGlMatrix.mat4.identity(this.projection_matrix);

            // apply isometric skew
            this.projection_matrix[8] = this.axis.x / this.view.aspect; // z column of x row, e.g. amount z skews x
            this.projection_matrix[9] = this.axis.y; // z column of x row, e.g. amount z skews y

            // convert meters to viewport
            _utilsGlMatrix.mat4.scale(this.projection_matrix, this.projection_matrix, _utilsGlMatrix.vec3.fromValues(2 / this.view.size.meters.x, 2 / this.view.size.meters.y, 2 / this.view.size.meters.y));
        }
    }, {
        key: 'setupProgram',
        value: function setupProgram(program) {
            program.uniform('Matrix4fv', 'u_projection', false, this.projection_matrix);

            program.uniform('3f', 'u_eye', 0, 0, this.viewport_height);
            // program.uniform('3f', 'u_eye', this.viewport_height * this.axis.x, this.viewport_height * this.axis.y, this.viewport_height);
            program.uniform('2f', 'u_vanishing_point', 0, 0);
        }
    }]);

    return IsometricCamera;
})(Camera);

var FlatCamera = (function (_IsometricCamera) {
    _inherits(FlatCamera, _IsometricCamera);

    function FlatCamera(name, view) {
        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, FlatCamera);

        _get(Object.getPrototypeOf(FlatCamera.prototype), 'constructor', this).call(this, name, view, options);
        this.type = 'flat';
    }

    _createClass(FlatCamera, [{
        key: 'update',
        value: function update() {
            // Axis is fixed to (0, 0) for flat camera
            this.axis.x = 0;
            this.axis.y = 0;

            _get(Object.getPrototypeOf(FlatCamera.prototype), 'update', this).call(this);
        }
    }]);

    return FlatCamera;
})(IsometricCamera);

module.exports = exports['default'];

},{"./gl/shader_program":203,"./utils/gl-matrix":243,"./utils/utils":247,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/get":21,"babel-runtime/helpers/inherits":22,"babel-runtime/helpers/interop-require-default":23}],197:[function(_dereq_,module,exports){
// Miscellaneous geo functions

'use strict';

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});
var Geo;
exports['default'] = Geo = {};

// Projection constants
Geo.default_source_max_zoom = 18;
Geo.default_view_max_zoom = 20;
Geo.tile_size = 256;
Geo.half_circumference_meters = 20037508.342789244;
Geo.circumference_meters = Geo.half_circumference_meters * 2;
Geo.min_zoom_meters_per_pixel = Geo.circumference_meters / Geo.tile_size; // min zoom draws world as 2 tiles wide

var meters_per_pixel = [];
Geo.metersPerPixel = function (z) {
    meters_per_pixel[z] = meters_per_pixel[z] || Geo.min_zoom_meters_per_pixel / Math.pow(2, z);
    return meters_per_pixel[z];
};

var meters_per_tile = [];
Geo.metersPerTile = function (z) {
    meters_per_tile[z] = meters_per_tile[z] || Geo.circumference_meters / Math.pow(2, z);
    return meters_per_tile[z];
};

// Conversion functions based on an defined tile scale
Geo.tile_scale = 4096; // coordinates are locally scaled to the range [0, tile_scale]
Geo.units_per_pixel = Geo.tile_scale / Geo.tile_size;

var units_per_meter = [];
Geo.unitsPerMeter = function (z) {
    units_per_meter[z] = units_per_meter[z] || Geo.tile_scale / (Geo.tile_size * Geo.metersPerPixel(z));
    return units_per_meter[z];
};

// Convert tile location to mercator meters - multiply by pixels per tile, then by meters per pixel, adjust for map origin
Geo.metersForTile = function (tile) {
    return {
        x: tile.x * Geo.circumference_meters / Math.pow(2, tile.z) - Geo.half_circumference_meters,
        y: -(tile.y * Geo.circumference_meters / Math.pow(2, tile.z) - Geo.half_circumference_meters)
    };
};

/**
   Given a point in mercator meters and a zoom level, return the tile X/Y/Z that the point lies in
*/
Geo.tileForMeters = function (_ref, zoom) {
    var _ref2 = _slicedToArray(_ref, 2);

    var x = _ref2[0];
    var y = _ref2[1];

    return {
        x: Math.floor((x + Geo.half_circumference_meters) / (Geo.circumference_meters / Math.pow(2, zoom))),
        y: Math.floor((-y + Geo.half_circumference_meters) / (Geo.circumference_meters / Math.pow(2, zoom))),
        z: zoom
    };
};

// Wrap a tile to positive #s for zoom
// Optionally specify the axes to wrap
Geo.wrapTile = function (_ref3) {
    var x = _ref3.x;
    var y = _ref3.y;
    var z = _ref3.z;
    var mask = arguments.length <= 1 || arguments[1] === undefined ? { x: true, y: false } : arguments[1];

    var m = (1 << z) - 1;
    if (mask.x) {
        x = x & m;
    }
    if (mask.y) {
        y = y & m;
    }
    return { x: x, y: y, z: z };
};

/**
   Convert mercator meters to lat-lng
*/
Geo.metersToLatLng = function (_ref4) {
    var _ref42 = _slicedToArray(_ref4, 2);

    var x = _ref42[0];
    var y = _ref42[1];

    x /= Geo.half_circumference_meters;
    y /= Geo.half_circumference_meters;

    y = (2 * Math.atan(Math.exp(y * Math.PI)) - Math.PI / 2) / Math.PI;

    x *= 180;
    y *= 180;

    return [x, y];
};

/**
  Convert lat-lng to mercator meters
*/
Geo.latLngToMeters = function (_ref5) {
    var _ref52 = _slicedToArray(_ref5, 2);

    var x = _ref52[0];
    var y = _ref52[1];

    // Latitude
    y = Math.log(Math.tan(y * Math.PI / 360 + Math.PI / 4)) / Math.PI;
    y *= Geo.half_circumference_meters;

    // Longitude
    x *= Geo.half_circumference_meters / 180;

    return [x, y];
};

Geo.wrapLng = function (x) {
    if (x > 180 || x < -180) {
        x = ((x + 180) % 360 + 360) % 360 - 180;
    }
    return x;
};

// Run an in-place transform function on each cooordinate in a GeoJSON geometry
Geo.transformGeometry = function (geometry, transform) {
    if (geometry == null) {
        return; // skip if missing geometry (valid GeoJSON)
    }

    if (geometry.type === 'Point') {
        transform(geometry.coordinates);
    } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {
        geometry.coordinates.forEach(transform);
    } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {
        geometry.coordinates.forEach(function (coordinates) {
            return coordinates.forEach(transform);
        });
    } else if (geometry.type === 'MultiPolygon') {
        geometry.coordinates.forEach(function (polygon) {
            polygon.forEach(function (coordinates) {
                return coordinates.forEach(transform);
            });
        });
    }
    // TODO: support GeometryCollection
};

Geo.boxIntersect = function (b1, b2) {
    return !(b2.sw.x > b1.ne.x || b2.ne.x < b1.sw.x || b2.sw.y > b1.ne.y || b2.ne.y < b1.sw.y);
};

// Finds the axis-aligned bounding box for a polygon
Geo.findBoundingBox = function (polygon) {
    var min_x = Infinity,
        max_x = -Infinity,
        min_y = Infinity,
        max_y = -Infinity;

    // Only need to examine outer ring (polygon[0])
    var num_coords = polygon[0].length;
    for (var c = 0; c < num_coords; c++) {
        var coord = polygon[0][c];

        if (coord[0] < min_x) {
            min_x = coord[0];
        }
        if (coord[1] < min_y) {
            min_y = coord[1];
        }
        if (coord[0] > max_x) {
            max_x = coord[0];
        }
        if (coord[1] > max_y) {
            max_y = coord[1];
        }
    }

    return [min_x, min_y, max_x, max_y];
};

// Convert geometry type to one of: 'point', 'line', 'polygon'
Geo.geometryType = function (type) {
    if (type === 'Polygon' || type === 'MultiPolygon') {
        return 'polygon';
    } else if (type === 'LineString' || type === 'MultiLineString') {
        return 'line';
    }
    if (type === 'Point' || type === 'MultiPoint') {
        return 'point';
    }
};

Geo.centroid = function (polygon) {
    var n = polygon.length;
    var centroid = [0, 0];

    for (var p = 0; p < polygon.length; p++) {
        centroid[0] += polygon[p][0];
        centroid[1] += polygon[p][1];
    }

    centroid[0] /= n;
    centroid[1] /= n;

    return centroid;
};

Geo.multiCentroid = function (polygons) {
    var n = polygons.length;
    var centroid = [0, 0];

    for (var p = 0; p < polygons.length; p++) {
        var polygon = polygons[p][0];
        var c = Geo.centroid(polygon);
        centroid[0] += c[0];
        centroid[1] += c[1];
    }

    centroid[0] /= n;
    centroid[1] /= n;

    return centroid;
};

Geo.signedPolygonAreaSum = function (polygon) {
    var area = 0;
    var n = polygon.length;

    for (var i = 0; i < n - 1; i++) {
        var p0 = polygon[i];
        var p1 = polygon[i + 1];

        area += p0[0] * p1[1] - p1[0] * p0[1];
    }

    area += polygon[n - 1][0] * polygon[0][1] - polygon[0][0] * polygon[n - 1][1];
    return area;
};

// TODO: subtract inner ring areas
Geo.polygonArea = function (polygon) {
    return Math.abs(Geo.signedPolygonAreaSum(polygon)) / 2;
};

Geo.multiPolygonArea = function (polygons) {
    var area = 0;

    for (var p = 0; p < polygons.length; p++) {
        var polygon = polygons[p][0];
        area += Geo.polygonArea(polygon);
    }

    return area;
};

Geo.ringWinding = function (ring) {
    var area = Geo.signedPolygonAreaSum(ring);
    if (area > 0) {
        return 'CW';
    } else if (area < 0) {
        return 'CCW';
    }
    // return undefined on zero area polygon
};

// Enforce winding order on outer/inner rings
// winding: 'CW' or 'CCW'
Geo.enforceWinding = function (geom, winding) {
    var polys = undefined;
    if (geom.type === 'Polygon') {
        polys = [geom.coordinates];
    } else if (geom.type === 'MultiPolygon') {
        polys = geom.coordinates;
    } else {
        return geom;
    }

    for (var p = 0; p < polys.length; p++) {
        var poly = polys[p];

        // If first ring winding doesn't match, reverse all rings
        // NOTE: assumes ring winding orders already alternate as expected
        if (Geo.ringWinding(poly[0]) !== winding) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = _getIterator(poly), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var ring = _step.value;

                    ring.reverse();
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator['return']) {
                        _iterator['return']();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }
    return geom;
};
module.exports = exports['default'];

},{"babel-runtime/core-js/get-iterator":2,"babel-runtime/helpers/sliced-to-array":24}],198:[function(_dereq_,module,exports){
// WebGL constants - need to import these separately to make them available in the web worker

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var gl;
exports["default"] = gl = {};

/* DataType */
gl.BYTE = 0x1400;
gl.UNSIGNED_BYTE = 0x1401;
gl.SHORT = 0x1402;
gl.UNSIGNED_SHORT = 0x1403;
gl.INT = 0x1404;
gl.UNSIGNED_INT = 0x1405;
gl.FLOAT = 0x1406;
module.exports = exports["default"];

},{}],199:[function(_dereq_,module,exports){
// WebGL context wrapper

'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});
var Context;
exports['default'] = Context = {};

// Setup a WebGL context
// If no canvas element is provided, one is created and added to the document body
Context.getContext = function getContext(canvas, options) {
    var fullscreen = false;
    if (canvas == null) {
        canvas = document.createElement('canvas');
        canvas.style.position = 'absolute';
        canvas.style.top = 0;
        canvas.style.left = 0;
        canvas.style.zIndex = -1;
        document.body.appendChild(canvas);
        fullscreen = true;
    }

    var gl = canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);
    if (!gl) {
        throw new Error("Couldn't create WebGL context.");
    }

    Context.resize(gl, window.innerWidth, window.innerHeight, options.device_pixel_ratio);
    if (fullscreen === true) {
        window.addEventListener('resize', function () {
            Context.resize(gl, window.innerWidth, window.innerHeight);
        });
    }

    return gl;
};

Context.resize = function (gl, width, height, device_pixel_ratio) {
    device_pixel_ratio = device_pixel_ratio || window.devicePixelRatio || 1;
    gl.canvas.style.width = width + 'px';
    gl.canvas.style.height = height + 'px';
    gl.canvas.width = Math.round(gl.canvas.style.width * device_pixel_ratio);
    gl.canvas.height = Math.round(gl.canvas.style.width * device_pixel_ratio);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
};
module.exports = exports['default'];

},{}],200:[function(_dereq_,module,exports){
// WebGL extension wrapper
// Stores extensions by name and GL context

"use strict";

var _Map = _dereq_("babel-runtime/core-js/map")["default"];

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports["default"] = getExtension;
var extensions = new _Map(); // map of extensions by GL context

function getExtension(gl, name) {
    var exts = extensions.get(gl);
    if (!exts) {
        extensions.set(gl, new _Map());
        exts = extensions.get(gl);
    }

    if (!exts.get(name)) {
        exts.set(name, gl.getExtension(name));
    }
    return exts.get(name);
}

module.exports = exports["default"];

},{"babel-runtime/core-js/map":4}],201:[function(_dereq_,module,exports){
'use strict';

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});
var GLSL = {};
exports['default'] = GLSL;

/**
    Parse uniforms from a JS object, infers types and returns an array of objects with the
    necessary information to set uniform values on a GL program. Each object in the returned
    array has the form:
    { type, method, name, value }

    type: the GL uniform type, such as 'vec3', 'float', etc.
    method: the GL uniform setter method to use, such as '1f', '3fv', etc.
    name: the fully qualified name of the GL uniform location, e.g. 'array[0].field', etc.
    value: the value to be passed to the GL uniform setter for that type, e.g. [1, 2, 3] for a vec3

    Textures have special behavior: uniforms with string values are treated as textures, and
    the string is used as a unique texture 'key' to be interpreted by the caller (which is responsible
    for actually setting the uniforms). For example, this could be used as a key into a dictionary of
    known texture names, or it could simply be used as a URL to dynamically load the texture from.
*/
GLSL.parseUniforms = function (uniforms) {
    var prefix = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    var parsed = [];

    for (var name in uniforms) {
        var key = name; // save the original name
        var uniform = uniforms[name];
        var u;

        if (prefix) {
            name = prefix + '.' + name;
        }

        // Single float
        if (typeof uniform === 'number') {
            parsed.push({
                type: 'float',
                method: '1f',
                name: name,
                value: uniform,
                key: key,
                uniforms: uniforms
            });
        }
        // Array: vector, array of floats, array of textures, or array of structs
        else if (Array.isArray(uniform)) {
                // Numeric values
                if (typeof uniform[0] === 'number') {
                    // float vectors (vec2, vec3, vec4)
                    if (uniform.length >= 2 && uniform.length <= 4) {
                        parsed.push({
                            type: 'vec' + uniform.length,
                            method: uniform.length + 'fv',
                            name: name,
                            value: uniform,
                            key: key,
                            uniforms: uniforms
                        });
                    }
                    // float array
                    else if (uniform.length > 4) {
                            parsed.push({
                                type: 'float[]',
                                method: '1fv',
                                name: name + '[0]',
                                value: uniform,
                                key: key,
                                uniforms: uniforms
                            });
                        }
                    // TODO: assume matrix for (typeof == Float32Array && length == 16)?
                }
                // Array of textures
                else if (typeof uniform[0] === 'string') {
                        for (u = 0; u < uniform.length; u++) {
                            parsed.push({
                                type: 'sampler2D',
                                method: '1i',
                                name: name + '[' + u + ']',
                                value: uniform[u],
                                key: u,
                                uniforms: uniform
                            });
                        }
                    }
                    // Array of arrays - but only arrays of vectors are allowed in this case
                    else if (Array.isArray(uniform[0]) && typeof uniform[0][0] === 'number') {
                            // float vectors (vec2, vec3, vec4)
                            if (uniform[0].length >= 2 && uniform[0].length <= 4) {
                                // Set each vector in the array
                                for (u = 0; u < uniform.length; u++) {
                                    parsed.push({
                                        type: 'vec' + uniform[0].length,
                                        method: uniform[u].length + 'fv',
                                        name: name + '[' + u + ']',
                                        value: uniform[u],
                                        key: u,
                                        uniforms: uniform
                                    });
                                }
                            }
                            // else error?
                        }
                        // Array of structures
                        else if (typeof uniform[0] === 'object') {
                                for (u = 0; u < uniform.length; u++) {
                                    // Set each struct in the array
                                    parsed.push.apply(parsed, _toConsumableArray(GLSL.parseUniforms(uniform[u], name + '[' + u + ']')));
                                }
                            }
            }
            // Boolean
            else if (typeof uniform === 'boolean') {
                    parsed.push({
                        type: 'bool',
                        method: '1i',
                        name: name,
                        value: uniform,
                        key: key,
                        uniforms: uniforms
                    });
                }
                // Texture
                else if (typeof uniform === 'string') {
                        parsed.push({
                            type: 'sampler2D',
                            method: '1i',
                            name: name,
                            value: uniform,
                            key: key,
                            uniforms: uniforms
                        });
                    }
                    // Structure
                    else if (typeof uniform === 'object') {
                            // Set each field in the struct
                            parsed.push.apply(parsed, _toConsumableArray(GLSL.parseUniforms(uniform, name)));
                        }

        // TODO: support other non-float types? (int, etc.)
    }

    return parsed;
};

/**
    Generate a GLSL variable definition from a JS object
*/
GLSL.defineVariable = function (name, value) {
    var prefix = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

    var type, array;
    var structs = '';
    prefix = prefix ? prefix + '_' + name : name;

    // Single float
    if (typeof value === 'number') {
        type = 'float';
    }
    // Multiple floats - vector or array
    else if (Array.isArray(value)) {
            // Numeric values
            if (typeof value[0] === 'number') {
                // float vectors (vec2, vec3, vec4)
                if (value.length >= 2 && value.length <= 4) {
                    type = 'vec' + value.length;
                }
                // float array
                else {
                        //if (value.length > 4) {
                        type = 'float';
                        array = value.length;
                    }
                // TODO: assume matrix for (typeof == Float32Array && length == 16)?
            }
            // Array of textures
            else if (typeof value[0] === 'string') {
                    type = 'sampler2D';
                    array = value.length;
                }
                // Array of arrays - but only arrays of vectors are allowed in this case
                else if (Array.isArray(value[0]) && typeof value[0][0] === 'number') {
                        // float vectors (vec2, vec3, vec4)
                        if (value[0].length >= 2 && value[0].length <= 4) {
                            type = 'vec' + value[0].length;
                        }
                        // else error?
                        array = value[0].length;
                    }
                    // Array of structures
                    else if (typeof value[0] === 'object') {
                            type = '_type_' + prefix; // custom struct name
                            array = value.length;
                            structs += GLSL.defineStruct(type, value[0], prefix) + '\n'; // build & add to list of dependent structs
                        }
        }
        // Boolean
        else if (typeof value === 'boolean') {
                type = 'bool';
            }
            // Texture
            else if (typeof value === 'string') {
                    type = 'sampler2D';
                }
                // Structure
                else if (typeof value === 'object') {
                        type = '_type_' + prefix; // custom struct name
                        structs += GLSL.defineStruct(type, value, prefix) + '\n'; // build & add to list of dependent structs
                    }

    // Construct variable definition
    var variable = '';
    variable += type + ' ' + name;
    if (array) {
        variable += '[' + array + ']';
    }
    variable += ';\n';

    // Return the variable definition itself, and any dependent struct definitions
    return { variable: variable, structs: structs };
};

/**
    Generate a GLSL structure definition from a JS object
*/
GLSL.defineStruct = function (type, value) {
    var prefix = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

    var struct = 'struct ' + type + ' {\n';
    var dependents = '';
    for (var field in value) {
        var subvar = GLSL.defineVariable(field, value[field], prefix);
        struct += '    ' + subvar.variable;
        dependents += subvar.structs;
    }
    struct += '};\n';
    struct = dependents + struct;
    return struct;
};

/**
    Generate a GLSL uniform definition from a JS object
*/
GLSL.defineUniform = function (name, value) {
    var def = GLSL.defineVariable(name, value);
    def = def.structs + 'uniform ' + def.variable;
    return def;
};

/**
    Check for a uniform definition of 'name' in the provided GLSL source
    Simple regex check for 'uniform' keyword and var name, does not attempt to parse/extract GLSL
    NOTE: assumes comments have been stripped from source
*/
GLSL.isUniformDefined = function (name, source) {
    // Match, in order:
    // - the keyword 'uniform'
    // - at least one character that is anything except a semicolon, ;
    // - optionally, anything enclosed in curly braces, { ... } (an inline structure definition can go here)
    // - optionally, any # of characters that is not a semicolon, ;
    // - the name of the uniform

    var re = new RegExp('uniform[^;]+(?:{[\\s\\S]*})?[^;]*\\b' + name + '\\b', 'g');
    if (source.match(re)) {
        return true;
    }
    return false;
};

/**
    Check that a symbol is referenced in the GLSL source
    NOTE: assumes comments have been stripped from source
*/
GLSL.isSymbolReferenced = function (name, source) {
    var re = new RegExp('\\b' + name + '\\b', 'g');
    if (source.search(re) >= 0) {
        return true;
    }
    return false;
};

/**
    Expand a single value or 2-element array into a 3-element array, with the last ( z )
    coordinate defaulting to 1 (with option to specify). Also runs parseFloat to try to maintain
    data integrity. Returns null if input couldn't be parsed.
*/
GLSL.expandVec3 = function (v) {
    var z = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

    var x = undefined;
    if (Array.isArray(v) && v.length === 2) {
        x = [].concat(_toConsumableArray(v), [z]).map(parseFloat);
    } else {
        x = [v, v, v].map(parseFloat);
    }

    if (x && x.every(function (n) {
        return typeof n === 'number' && !isNaN(n);
    })) {
        return x;
    }
};

/**
    Expand a single value or 3-element array into a 4-element array, with the last (e.g. w or a)
    coordinate defaulting to 1 (with option to specify). Also runs parseFloat to try to maintain
    data integrity. Returns null if input couldn't be parsed.
*/
GLSL.expandVec4 = function (v) {
    var w = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

    var x = undefined;
    if (Array.isArray(v) && v.length === 3) {
        x = [].concat(_toConsumableArray(v), [w]).map(parseFloat);
    } else {
        x = [v, v, v, w].map(parseFloat);
    }

    if (x && x.every(function (n) {
        return typeof n === 'number' && !isNaN(n);
    })) {
        return x;
    }
};
module.exports = exports['default'];

},{"babel-runtime/helpers/to-consumable-array":25}],202:[function(_dereq_,module,exports){
"use strict";

var _createClass = _dereq_("babel-runtime/helpers/create-class")["default"];

var _classCallCheck = _dereq_("babel-runtime/helpers/class-call-check")["default"];

Object.defineProperty(exports, "__esModule", {
        value: true
});

var RenderState = (function () {
        function RenderState(value, setup) {
                _classCallCheck(this, RenderState);

                setup(value);
                this.value = value;
                this.setup = setup;
        }

        _createClass(RenderState, [{
                key: "set",
                value: function set(value) {
                        // if the states are different, call the GL context for a state change
                        if (JSON.stringify(this.value) !== JSON.stringify(value)) {
                                this.setup(value);
                                this.value = value;
                        }
                }
        }], [{
                key: "initialize",
                value: function initialize(gl) {
                        // Culling
                        RenderState.culling = new RenderState({ cull: true, face: gl.BACK }, function (value) {
                                if (value.cull) {
                                        gl.enable(gl.CULL_FACE);
                                        gl.cullFace(value.face);
                                } else {
                                        gl.disable(gl.CULL_FACE);
                                }
                        });

                        // Blending mode
                        RenderState.blending = new RenderState({ blend: false, src: gl.SRC_ALPHA, dst: gl.ONE_MINUS_SRC_ALPHA, src_alpha: gl.ONE, dst_alpha: gl.ONE_MINUS_SRC_ALPHA }, function (value) {
                                if (value.blend) {
                                        gl.enable(gl.BLEND);

                                        if (value.src_alpha && value.dst_alpha) {
                                                gl.blendFuncSeparate(value.src, value.dst, value.src_alpha, value.dst_alpha);
                                        } else {
                                                gl.blendFunc(value.src, value.dst);
                                        }
                                } else {
                                        gl.disable(gl.BLEND);
                                }
                        });

                        // Depth write
                        RenderState.depth_write = new RenderState({ depth_write: true }, function (value) {
                                gl.depthMask(value.depth_write);
                        });

                        // Depth test
                        RenderState.depth_test = new RenderState({ depth_test: true, depth_func: gl.LEQUAL }, function (value) {
                                if (value.depth_test) {
                                        gl.enable(gl.DEPTH_TEST);
                                        gl.depthFunc(value.depth_func);
                                } else {
                                        gl.disable(gl.DEPTH_TEST);
                                }
                        });
                }
        }]);

        return RenderState;
})();

exports["default"] = RenderState;
module.exports = exports["default"];

},{"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19}],203:[function(_dereq_,module,exports){
// GL program wrapper to cache uniform locations/values, do compile-time pre-processing
// (injecting #defines and #pragma blocks into shaders), etc.

'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _glsl = _dereq_('./glsl');

var _glsl2 = _interopRequireDefault(_glsl);

var _texture = _dereq_('./texture');

var _texture2 = _interopRequireDefault(_texture);

var _extensions = _dereq_('./extensions');

var _extensions2 = _interopRequireDefault(_extensions);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var _stripComments = _dereq_('strip-comments');

var _stripComments2 = _interopRequireDefault(_stripComments);

var _glShaderErrors = _dereq_('gl-shader-errors');

var _glShaderErrors2 = _interopRequireDefault(_glShaderErrors);

var ShaderProgram = (function () {
    function ShaderProgram(gl, vertex_source, fragment_source, options) {
        _classCallCheck(this, ShaderProgram);

        options = options || {};

        this.gl = gl;
        this.program = null;
        this.compiled = false;
        this.compiling = false;
        this.error = null;

        // key/values inserted as #defines into shaders at compile-time
        this.defines = _Object$assign({}, options.defines || {});

        // key/values for blocks that can be injected into shaders at compile-time
        this.blocks = _Object$assign({}, options.blocks || {});
        this.block_scopes = _Object$assign({}, options.block_scopes || {});

        // list of extensions to activate
        this.extensions = options.extensions || [];

        // JS-object uniforms that are expected by this program
        // If they are not found in the existing shader source, their types will be inferred and definitions
        // for each will be injected.
        this.dependent_uniforms = options.uniforms;

        this.uniforms = {}; // program locations of uniforms, lazily added as each uniform is set
        this.attribs = {}; // program locations of vertex attributes, lazily added as each attribute is accessed

        this.vertex_source = vertex_source;
        this.fragment_source = fragment_source;

        this.id = ShaderProgram.id++;
        ShaderProgram.programs[this.id] = this;
        this.name = options.name; // can provide a program name (useful for debugging)
    }

    // Static methods and state

    _createClass(ShaderProgram, [{
        key: 'destroy',
        value: function destroy() {
            this.gl.useProgram(null);
            this.gl.deleteProgram(this.program);
            this.program = null;
            this.uniforms = {};
            this.attribs = {};
            delete ShaderProgram.programs[this.id];
            this.compiled = false;
        }

        // Use program wrapper with simple state cache
    }, {
        key: 'use',
        value: function use() {
            if (!this.compiled) {
                return;
            }

            if (ShaderProgram.current !== this) {
                this.gl.useProgram(this.program);
            }
            ShaderProgram.current = this;
        }
    }, {
        key: 'compile',
        value: function compile() {
            if (this.compiling) {
                throw new Error('ShaderProgram.compile(): skipping for ' + this.id + ' (' + this.name + ') because already compiling');
            }
            this.compiling = true;
            this.compiled = false;
            this.error = null;

            // Copy sources from pre-modified template
            this.computed_vertex_source = this.vertex_source;
            this.computed_fragment_source = this.fragment_source;

            // Check for extension availability
            var extensions = this.checkExtensions();

            // Make list of defines to be injected later
            var defines = this.buildDefineList();

            // Inject user-defined blocks (arbitrary code points matching named #pragmas)
            // Replace according to this pattern:
            // #pragma tangram: [key]
            // e.g. #pragma tangram: global

            // Gather all block code snippets
            var blocks = this.buildShaderBlockList();
            var regexp;

            for (var key in blocks) {
                var block = blocks[key];
                if (!block || Array.isArray(block) && block.length === 0) {
                    continue;
                }

                // First find code replace points in shaders
                regexp = new RegExp('^\\s*#pragma\\s+tangram:\\s+' + key + '\\s*$', 'm');
                var inject_vertex = this.computed_vertex_source.match(regexp);
                var inject_fragment = this.computed_fragment_source.match(regexp);

                // Avoid network request if nothing to replace
                if (inject_vertex == null && inject_fragment == null) {
                    continue;
                }

                // Combine all blocks into one string
                var source = '';
                block.forEach(function (val) {
                    // Mark start and end of each block with metadata (which can be extracted from
                    // final source for error handling, debugging, etc.)
                    var mark = val.scope + ', ' + val.key + ', ' + val.num;
                    source += '\n// tangram-block-start: ' + mark + '\n';
                    source += val.source;
                    source += '\n// tangram-block-end: ' + mark + '\n';
                });

                // Inject
                if (inject_vertex != null) {
                    this.computed_vertex_source = this.computed_vertex_source.replace(regexp, source);
                }
                if (inject_fragment != null) {
                    this.computed_fragment_source = this.computed_fragment_source.replace(regexp, source);
                }

                // Add a #define for this injection point
                defines['TANGRAM_BLOCK_' + key.replace(/[\s-]+/g, '_').toUpperCase()] = true;
            }

            // Clean-up any #pragmas that weren't replaced (to prevent compiler warnings)
            regexp = new RegExp('^\\s*#pragma.*$', 'gm');
            this.computed_vertex_source = this.computed_vertex_source.replace(regexp, '');
            this.computed_fragment_source = this.computed_fragment_source.replace(regexp, '');

            // Detect uniform definitions, inject any missing ones
            this.ensureUniforms(this.dependent_uniforms);

            // Build & inject extensions & defines
            // This is done *after* code injection so that we can add defines for which code points were injected
            var info = this.name ? this.name + ' / id ' + this.id : 'id ' + this.id;
            var header = '// Program: ' + info + '\n';
            var precision = '';
            var high = this.gl.getShaderPrecisionFormat(this.gl.FRAGMENT_SHADER, this.gl.HIGH_FLOAT);
            if (high && high.precision > 0) {
                precision = 'precision highp float;\n';
            } else {
                precision = 'precision mediump float;\n';
            }

            defines['TANGRAM_VERTEX_SHADER'] = true;
            defines['TANGRAM_FRAGMENT_SHADER'] = false;
            this.computed_vertex_source = header + precision + ShaderProgram.buildDefineString(defines) + this.computed_vertex_source;

            // Precision qualifier only valid in fragment shader
            // NB: '#extension' statements added to fragment shader only, as IE11 throws error when they appear in
            // vertex shader (even when guarded by #ifdef), and no WebGL extensions require '#extension' in vertex shaders
            defines['TANGRAM_VERTEX_SHADER'] = false;
            defines['TANGRAM_FRAGMENT_SHADER'] = true;
            this.computed_fragment_source = ShaderProgram.buildExtensionString(extensions) + header + precision + ShaderProgram.buildDefineString(defines) + this.computed_fragment_source;

            // Compile & set uniforms to cached values
            try {
                this.program = ShaderProgram.updateProgram(this.gl, this.program, this.computed_vertex_source, this.computed_fragment_source);
                this.compiled = true;
                this.compiling = false;
            } catch (error) {
                this.program = null;
                this.compiled = false;
                this.compiling = false;
                this.error = error;

                // shader error info
                if (error.type === 'vertex' || error.type === 'fragment') {
                    this.shader_errors = error.errors;
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = _getIterator(this.shader_errors), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var e = _step.value;

                            e.type = error.type;
                            e.block = this.block(error.type, e.line);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator['return']) {
                                _iterator['return']();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }

                throw new Error('ShaderProgram.compile(): program ' + this.id + ' (' + this.name + ') error:', error);
            }

            this.use();
            this.refreshUniforms();
            this.refreshAttributes();
        }

        // Make list of defines (global, then program-specific)
    }, {
        key: 'buildDefineList',
        value: function buildDefineList() {
            var d,
                defines = {};
            for (d in ShaderProgram.defines) {
                defines[d] = ShaderProgram.defines[d];
            }
            for (d in this.defines) {
                defines[d] = this.defines[d];
            }
            return defines;
        }

        // Make list of shader blocks (global, then program-specific)
    }, {
        key: 'buildShaderBlockList',
        value: function buildShaderBlockList() {
            var key = undefined,
                blocks = {};

            // Global blocks
            for (key in ShaderProgram.blocks) {
                blocks[key] = [];

                if (Array.isArray(ShaderProgram.blocks[key])) {
                    var _blocks$key;

                    (_blocks$key = blocks[key]).push.apply(_blocks$key, _toConsumableArray(ShaderProgram.blocks[key].map(function (source, num) {
                        return { key: key, source: source, num: num, scope: 'ShaderProgram' };
                    })));
                } else {
                    blocks[key] = [{ key: key, source: ShaderProgram.blocks[key], num: 0, scope: 'ShaderProgram' }];
                }
            }

            // Program-specific blocks
            for (key in this.blocks) {
                blocks[key] = blocks[key] || [];

                if (Array.isArray(this.blocks[key])) {
                    var scopes = this.block_scopes && this.block_scopes[key] || [];
                    var cur_scope = null,
                        num = 0;

                    for (var b = 0; b < this.blocks[key].length; b++) {
                        // Count blocks relative to current scope
                        if (scopes[b] !== cur_scope) {
                            cur_scope = scopes[b];
                            num = 0;
                        }

                        blocks[key].push({
                            key: key,
                            source: this.blocks[key][b],
                            num: num,
                            scope: cur_scope || this.name
                        });

                        num++;
                    }
                } else {
                    // TODO: address discrepancy in array vs. single-value blocks
                    // styles assume array when tracking block scopes
                    blocks[key].push({ key: key, source: this.blocks[key], num: 0, scope: this.name });
                }
            }
            return blocks;
        }

        // Detect uniform definitions, inject any missing ones
    }, {
        key: 'ensureUniforms',
        value: function ensureUniforms(uniforms) {
            if (!uniforms) {
                return;
            }

            var vs = (0, _stripComments2['default'])(this.computed_vertex_source);
            var fs = (0, _stripComments2['default'])(this.computed_fragment_source);
            var inject,
                vs_injections = [],
                fs_injections = [];

            // Check for missing uniform definitions
            for (var name in uniforms) {
                inject = null;

                // Check vertex shader
                if (!_glsl2['default'].isUniformDefined(name, vs) && _glsl2['default'].isSymbolReferenced(name, vs)) {
                    if (!inject) {
                        inject = _glsl2['default'].defineUniform(name, uniforms[name]);
                    }
                    _loglevel2['default'].trace('Program ' + this.name + ': ' + name + ' not defined in vertex shader, injecting: \'' + inject + '\'');
                    vs_injections.push(inject);
                }
                // Check fragment shader
                if (!_glsl2['default'].isUniformDefined(name, fs) && _glsl2['default'].isSymbolReferenced(name, fs)) {
                    if (!inject) {
                        inject = _glsl2['default'].defineUniform(name, uniforms[name]);
                    }
                    _loglevel2['default'].trace('Program ' + this.name + ': ' + name + ' not defined in fragment shader, injecting: \'' + inject + '\'');
                    fs_injections.push(inject);
                }
            }

            // Inject missing uniforms
            // NOTE: these are injected at the very top of the shaders, even before any #defines or #pragmas are added
            // this could cause some issues with certain #pragmas, or other functions that might expect #defines
            if (vs_injections.length > 0) {
                this.computed_vertex_source = vs_injections.join('\n') + this.computed_vertex_source;
            }

            if (fs_injections.length > 0) {
                this.computed_fragment_source = fs_injections.join('\n') + this.computed_fragment_source;
            }
        }

        // Set uniforms from a JS object, with inferred types
    }, {
        key: 'setUniforms',
        value: function setUniforms(uniforms) {
            var reset_texture_unit = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

            if (!this.compiled) {
                return;
            }

            // TODO: only update uniforms when changed

            // Texture units must be tracked and incremented each time a texture sampler uniform is set.
            // By default, the texture unit is reset to 0 each time setUniforms is called, but they can
            // also be preserved, for example in cases where multiple calls to setUniforms are expected
            // (e.g. program-specific uniforms followed by mesh-specific ones).
            if (reset_texture_unit) {
                this.texture_unit = 0;
            }

            // Parse uniform types and values from the JS object
            var parsed = _glsl2['default'].parseUniforms(uniforms);

            // Set each uniform
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = _getIterator(parsed), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var uniform = _step2.value;

                    if (uniform.type === 'sampler2D') {
                        // For textures, we need to track texture units, so we have a special setter
                        this.setTextureUniform(uniform.name, uniform.value);
                    } else {
                        this.uniform(uniform.method, uniform.name, uniform.value);
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                        _iterator2['return']();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
        }

        // Cache some or all uniform values so they can be restored
    }, {
        key: 'saveUniforms',
        value: function saveUniforms(subset) {
            var uniforms = subset || this.uniforms;
            for (var u in uniforms) {
                var uniform = this.uniforms[u];
                if (uniform) {
                    uniform.saved_value = uniform.value;
                }
            }
            this.saved_texture_unit = this.texture_unit || 0;
        }

        // Restore some or all uniforms to saved values
    }, {
        key: 'restoreUniforms',
        value: function restoreUniforms(subset) {
            var uniforms = subset || this.uniforms;
            for (var u in uniforms) {
                var uniform = this.uniforms[u];
                if (uniform && uniform.saved_value) {
                    uniform.value = uniform.saved_value;
                    this.updateUniform(u);
                }
            }
            this.texture_unit = this.saved_texture_unit || 0;
        }

        // Set a texture uniform, finds texture by name or creates a new one
    }, {
        key: 'setTextureUniform',
        value: function setTextureUniform(uniform_name, texture_name) {
            var texture = _texture2['default'].textures[texture_name];
            if (texture == null) {
                texture = _texture2['default'].create(this.gl, texture_name, { url: texture_name });
            }

            texture.bind(this.texture_unit);
            this.uniform('1i', uniform_name, this.texture_unit);
            this.texture_unit++; // TODO: track max texture units and log/throw errors
        }

        // ex: program.uniform('3f', 'position', x, y, z);
        // TODO: only update uniforms when changed
    }, {
        key: 'uniform',
        value: function uniform(method, name) {
            // 'value' is a method-appropriate arguments list
            if (!this.compiled) {
                return;
            }

            this.uniforms[name] = this.uniforms[name] || {};
            var uniform = this.uniforms[name];
            uniform.name = name;
            if (uniform.location === undefined) {
                uniform.location = this.gl.getUniformLocation(this.program, name);
            }
            uniform.method = 'uniform' + method;

            for (var _len = arguments.length, value = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                value[_key - 2] = arguments[_key];
            }

            uniform.value = value;
            this.updateUniform(name);
        }

        // Set a single uniform
    }, {
        key: 'updateUniform',
        value: function updateUniform(name) {
            if (!this.compiled) {
                return;
            }

            var uniform = this.uniforms[name];
            if (!uniform || uniform.location == null) {
                return;
            }

            this.use();
            this.gl[uniform.method].apply(this.gl, [uniform.location].concat(uniform.value)); // call appropriate GL uniform method and pass through arguments
        }

        // Refresh uniform locations and set to last cached values
    }, {
        key: 'refreshUniforms',
        value: function refreshUniforms() {
            if (!this.compiled) {
                return;
            }

            for (var u in this.uniforms) {
                this.uniforms[u].location = this.gl.getUniformLocation(this.program, u);
                this.updateUniform(u);
            }
        }
    }, {
        key: 'refreshAttributes',
        value: function refreshAttributes() {
            // var len = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES);
            // for (var i=0; i < len; i++) {
            //     var a = this.gl.getActiveAttrib(this.program, i);
            // }
            this.attribs = {};
        }

        // Get the location of a vertex attribute
    }, {
        key: 'attribute',
        value: function attribute(name) {
            if (!this.compiled) {
                return;
            }

            var attrib = this.attribs[name] = this.attribs[name] || {};
            if (attrib.location != null) {
                return attrib;
            }

            attrib.name = name;
            attrib.location = this.gl.getAttribLocation(this.program, name);

            // var info = this.gl.getActiveAttrib(this.program, attrib.location);
            // attrib.type = info.type;
            // attrib.size = info.size;

            return attrib;
        }

        // Get shader source as string
    }, {
        key: 'source',
        value: function source(type) {
            if (type === 'vertex') {
                return this.computed_vertex_source;
            } else if (type === 'fragment') {
                return this.computed_fragment_source;
            }
        }

        // Get shader source as array of line strings
    }, {
        key: 'lines',
        value: function lines(type) {
            var source = this.source(type);
            if (source) {
                return source.split('\n');
            }
            return [];
        }

        // Get a specific line from shader source
    }, {
        key: 'line',
        value: function line(type, num) {
            var source = this.lines(type);
            if (source) {
                return source[num];
            }
        }

        // Get info on which shader block (if any) a particular line number in a shader is in
        // Returns an object with the following info if a block is found: { name, line, source }
        //  scope: where the shader block originated, either a style name, or global such as ShaderProgram
        //  name: shader block name (e.g. 'color', 'position', 'global')
        //  num: the block number *within* local scope (e.g. if a style has multiple 'color' blocks)
        //  line: line number *within* the shader block (not the whole shader program), useful for error highlighting
        //  source: the code for the line
        // NOTE: this does a bruteforce loop over the shader source and looks for shader block start/end markers
        // We could track line ranges for shader blocks as they are inserted, but as this code is only used for
        // error handling on compilation failure, it was simpler to keep it separate than to burden the core
        // compilation path.
    }, {
        key: 'block',
        value: function block(type, num) {
            var lines = this.lines(type);
            var block = undefined;
            for (var i = 0; i < num && i < lines.length; i++) {
                var line = lines[i];
                var match = line.match(/\/\/ tangram-block-start: ([A-Za-z0-9_-]+), ([A-Za-z0-9_-]+), (\d+)/);
                if (match && match.length > 1) {
                    // mark current block
                    block = {
                        scope: match[1],
                        name: match[2],
                        num: match[3]
                    };
                } else {
                    match = line.match(/\/\/ tangram-block-end: ([A-Za-z0-9_-]+), ([A-Za-z0-9_-]+), (\d+)/);
                    if (match && match.length > 1) {
                        block = null; // clear current block
                    }
                }

                // update line # and content
                if (block) {
                    // init to -1 so that line 0 is first actual line of block code, after comment marker
                    block.line = block.line == null ? -1 : block.line + 1;
                    block.source = line;
                }
            }
            return block;
        }

        // Returns list of available extensions from those requested
        // Sets internal #defines indicating availability of each requested extension
    }, {
        key: 'checkExtensions',
        value: function checkExtensions() {
            var exts = [];
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = _getIterator(this.extensions), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var _name = _step3.value;

                    var ext = (0, _extensions2['default'])(this.gl, _name);
                    var def = 'TANGRAM_EXTENSION_' + _name;

                    this.defines[def] = ext != null;

                    if (ext) {
                        exts.push(_name);
                    } else {
                        _loglevel2['default'].debug('Could not enable extension \'' + _name + '\'');
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                        _iterator3['return']();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            return exts;
        }
    }]);

    return ShaderProgram;
})();

exports['default'] = ShaderProgram;
ShaderProgram.id = 0; // assign each program a unique id
ShaderProgram.programs = {}; // programs, by id
ShaderProgram.current = null; // currently bound program

// Global config applied to all programs (duplicate properties for a specific program will take precedence)
ShaderProgram.defines = {};
ShaderProgram.blocks = {};

// Turn an object of key/value pairs into single string of #define statements
ShaderProgram.buildDefineString = function (defines) {
    var define_str = "";
    for (var d in defines) {
        if (defines[d] === false) {
            continue;
        } else if (typeof defines[d] === 'boolean' && defines[d] === true) {
            // booleans are simple defines with no value
            define_str += "#define " + d + "\n";
        } else if (typeof defines[d] === 'number' && Math.floor(defines[d]) === defines[d]) {
            // int to float conversion to satisfy GLSL floats
            define_str += "#define " + d + " " + defines[d].toFixed(1) + "\n";
        } else {
            // any other float or string value
            define_str += "#define " + d + " " + defines[d] + "\n";
        }
    }
    return define_str;
};

// Turn a list of extension names into single string of #extension statements
ShaderProgram.buildExtensionString = function (extensions) {
    extensions = extensions || [];
    var str = "";
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
        for (var _iterator4 = _getIterator(extensions), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var ext = _step4.value;

            str += '#ifdef GL_' + ext + '\n#extension GL_' + ext + ' : enable\n#endif\n';
        }
    } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                _iterator4['return']();
            }
        } finally {
            if (_didIteratorError4) {
                throw _iteratorError4;
            }
        }
    }

    return str;
};

ShaderProgram.addBlock = function (key) {
    var _ShaderProgram$blocks$key;

    ShaderProgram.blocks[key] = ShaderProgram.blocks[key] || [];

    for (var _len2 = arguments.length, blocks = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        blocks[_key2 - 1] = arguments[_key2];
    }

    (_ShaderProgram$blocks$key = ShaderProgram.blocks[key]).push.apply(_ShaderProgram$blocks$key, blocks);
};

// Remove all global shader blocks for a given key
ShaderProgram.removeBlock = function (key) {
    ShaderProgram.blocks[key] = [];
};

ShaderProgram.replaceBlock = function (key) {
    ShaderProgram.removeBlock(key);

    for (var _len3 = arguments.length, blocks = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        blocks[_key3 - 1] = arguments[_key3];
    }

    ShaderProgram.addBlock.apply(ShaderProgram, [key].concat(blocks));
};

// Compile & link a WebGL program from provided vertex and fragment shader sources
// update a program if one is passed in. Create one if not. Alert and don't update anything if the shaders don't compile.
ShaderProgram.updateProgram = function (gl, program, vertex_shader_source, fragment_shader_source) {
    try {
        var vertex_shader = ShaderProgram.createShader(gl, vertex_shader_source, gl.VERTEX_SHADER);
        var fragment_shader = ShaderProgram.createShader(gl, fragment_shader_source, gl.FRAGMENT_SHADER);
    } catch (err) {
        _loglevel2['default'].error(err.message);
        throw err;
    }

    gl.useProgram(null);
    if (program != null) {
        var old_shaders = gl.getAttachedShaders(program);
        for (var i = 0; i < old_shaders.length; i++) {
            gl.detachShader(program, old_shaders[i]);
        }
    } else {
        program = gl.createProgram();
    }

    if (vertex_shader == null || fragment_shader == null) {
        return program;
    }

    gl.attachShader(program, vertex_shader);
    gl.attachShader(program, fragment_shader);

    gl.deleteShader(vertex_shader);
    gl.deleteShader(fragment_shader);

    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        var message = new Error('WebGL program error:\n            VALIDATE_STATUS: ' + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + '\n            ERROR: ' + gl.getError() + '\n            --- Vertex Shader ---\n            ' + vertex_shader_source + '\n            --- Fragment Shader ---\n            ' + fragment_shader_source);

        var error = { type: 'program', message: message };
        _loglevel2['default'].error(error.message);
        throw error;
    }

    return program;
};

// Compile a vertex or fragment shader from provided source
ShaderProgram.createShader = function (gl, source, stype) {
    var shader = gl.createShader(stype);

    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        var type = stype === gl.VERTEX_SHADER ? 'vertex' : 'fragment';
        var message = gl.getShaderInfoLog(shader);
        var errors = (0, _glShaderErrors2['default'])(message);
        throw { type: type, message: message, errors: errors };
    }

    return shader;
};
module.exports = exports['default'];

},{"./extensions":200,"./glsl":201,"./texture":205,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/assign":6,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/interop-require-default":23,"babel-runtime/helpers/to-consumable-array":25,"gl-shader-errors":151,"loglevel":183,"strip-comments":189}],204:[function(_dereq_,module,exports){
// Generated from GLSL files, don't edit!
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var shaderSources = {};

shaderSources['gl/shaders/accessors'] = "#ifdef TANGRAM_VERTEX_SHADER\n" + "\n" + "// Vertex position in model space: [0, 1] range over the local tile\n" + "// Note positions can be outside that range due to unclipped geometry, geometry higher than a unit cube, etc.\n" + "vec4 modelPosition() {\n" + "    return\n" + "        vec4(\n" + "            SHORT(a_position.xyz)                       // scale normalized short to full range\n" + "            / TANGRAM_TILE_SCALE                        // scale coords to ~0-1 range\n" + "            * exp2(u_tile_origin.z - u_tile_origin.w),  // adjust for tile overzooming\n" + "        1.)\n" + "        + vec4(0., 1., 0., 0.);\n" + "        // NB: additional offset to account for unusual Tangram JS y coords,\n" + "        // should be refactored to remove\n" + "}\n" + "\n" + "#endif\n" + "\n" + "// Vertex position in world coordinates, useful for 3d procedural textures, etc.\n" + "vec4 worldPosition() {\n" + "    return v_world_position;\n" + "}\n" + "\n" + "// Optionally wrap world coordinates (allows more precision at higher zooms)\n" + "// e.g. at wrap 1000, the world space will wrap every 1000 meters\n" + "#ifdef TANGRAM_VERTEX_SHADER\n" + "\n" + "vec4 wrapWorldPosition(vec4 world_position) {\n" + "    #if defined(TANGRAM_WORLD_POSITION_WRAP)\n" + "    vec2 anchor = u_tile_origin.xy - mod(u_tile_origin.xy, TANGRAM_WORLD_POSITION_WRAP);\n" + "        world_position.xy -= anchor;\n" + "    #endif\n" + "    return world_position;\n" + "}\n" + "\n" + "#endif\n" + "\n" + "// Normal in world space\n" + "#if defined(TANGRAM_VERTEX_SHADER)\n" + "\n" + "vec3 worldNormal() {\n" + "    return TANGRAM_NORMAL;\n" + "}\n" + "\n" + "#elif defined(TANGRAM_FRAGMENT_SHADER)\n" + "\n" + "vec3 worldNormal() {\n" + "    return u_inverseNormalMatrix * TANGRAM_NORMAL;\n" + "}\n" + "\n" + "#endif\n" + "";

shaderSources['gl/shaders/ambientLight'] = "/*\n" + "\n" + "Expected globals:\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct AmbientLight {\n" + "    vec4 ambient;\n" + "};\n" + "\n" + "void calculateLight(in AmbientLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "    light_accumulator_ambient += _light.ambient;\n" + "}\n" + "";

shaderSources['gl/shaders/directionalLight'] = "/*\n" + "\n" + "Expected globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct DirectionalLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec3 direction;\n" + "};\n" + "\n" + "void calculateLight(in DirectionalLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "\n" + "    light_accumulator_ambient += _light.ambient;\n" + "\n" + "    float nDotVP = clamp(dot(_normal, -normalize(_light.direction)), 0.0, 1.0);\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        light_accumulator_diffuse += _light.diffuse * nDotVP;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        float pf = 0.0;\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(normalize(_light.direction), _normal);\n" + "            float eyeDotR = max(dot(normalize(_eyeToPoint), reflectVector), 0.0);\n" + "            pf = pow(eyeDotR, material.shininess);\n" + "        }\n" + "        light_accumulator_specular += _light.specular * pf;\n" + "    #endif\n" + "}\n" + "";

shaderSources['gl/shaders/layer_order'] = "// Apply layer ordering to avoid z-fighting\n" + "void applyLayerOrder (float layer, inout vec4 position) {\n" + "    position.z -= layer * TANGRAM_LAYER_DELTA * position.w;\n" + "}\n" + "";

shaderSources['gl/shaders/material'] = "/*\n" + "\n" + "Defines globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "\n" + "// MATERIALS\n" + "//\n" + "struct Material {\n" + "    #ifdef TANGRAM_MATERIAL_EMISSION\n" + "        vec4 emission;\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE\n" + "            vec3 emissionScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_AMBIENT\n" + "        vec4 ambient;\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE\n" + "            vec3 ambientScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        vec4 diffuse;\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE\n" + "            vec3 diffuseScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        vec4 specular;\n" + "        float shininess;\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE\n" + "            vec3 specularScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "        vec3 normalScale;\n" + "        float normalAmount;\n" + "    #endif\n" + "};\n" + "\n" + "// Note: uniform is copied to a global instance to allow modification\n" + "uniform Material u_material;\n" + "Material material;\n" + "\n" + "#ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE\n" + "uniform sampler2D u_material_emission_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE\n" + "uniform sampler2D u_material_ambient_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE\n" + "uniform sampler2D u_material_diffuse_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE\n" + "uniform sampler2D u_material_specular_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "uniform sampler2D u_material_normal_texture;\n" + "#endif\n" + "\n" + "// Global light accumulators for each property\n" + "vec4 light_accumulator_ambient = vec4(0.0);\n" + "vec4 light_accumulator_diffuse = vec4(0.0);\n" + "#ifdef TANGRAM_MATERIAL_SPECULAR\n" + "    vec4 light_accumulator_specular = vec4(0.0);\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_TEXTURE_SPHEREMAP\n" + "vec4 getSphereMap (in sampler2D _tex, in vec3 _eyeToPoint, in vec3 _normal, in vec2 _skew) {\n" + "    vec3 eye = normalize(_eyeToPoint);\n" + "    eye.xy -= _skew;\n" + "    eye = normalize(eye);\n" + "\n" + "    vec3 r = reflect(eye, _normal);\n" + "    r.z += 1.0;\n" + "    float m = 2. * length(r);\n" + "    vec2 uv = r.xy / m + .5;\n" + "    return texture2D(_tex, uv);\n" + "}\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_TEXTURE_TRIPLANAR\n" + "vec3 getTriPlanarBlend (in vec3 _normal) {\n" + "    vec3 blending = abs(_normal);\n" + "    blending = normalize(max(blending, 0.00001));\n" + "    float b = (blending.x + blending.y + blending.z);\n" + "    return blending / b;\n" + "}\n" + "\n" + "vec4 getTriPlanar (in sampler2D _tex, in vec3 _pos, in vec3 _normal, in vec3 _scale) {\n" + "    vec3 blending = getTriPlanarBlend(_normal);\n" + "    vec4 xaxis = texture2D(_tex, fract(_pos.yz * _scale.x));\n" + "    vec4 yaxis = texture2D(_tex, fract(_pos.xz * _scale.y));\n" + "    vec4 zaxis = texture2D(_tex, fract(_pos.xy * _scale.z));\n" + "    return  xaxis * blending.x + yaxis * blending.y + zaxis * blending.z;\n" + "}\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_TEXTURE_PLANAR\n" + "vec4 getPlanar (in sampler2D _tex, in vec3 _pos, in vec2 _scale) {\n" + "    return texture2D( _tex, fract(_pos.xy * _scale.x) );\n" + "}\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "void calculateNormal (inout vec3 _normal) {\n" + "    // Get NORMALMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE_UV\n" + "    _normal += texture2D(u_material_normal_texture, fract(v_texcoord*material.normalScale.xy)).rgb*2.0-1.0;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE_PLANAR\n" + "    vec3 normalTex = getPlanar(u_material_normal_texture, v_world_position.xyz, material.normalScale.xy).rgb*2.0-1.0;\n" + "    _normal += normalTex;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE_TRIPLANAR\n" + "    vec3 normalTex = getTriPlanar(u_material_normal_texture, v_world_position.xyz, _normal, material.normalScale).rgb*2.0-1.0;\n" + "    _normal += normalTex;\n" + "    #endif\n" + "\n" + "    _normal = normalize(_normal);\n" + "}\n" + "#endif\n" + "\n" + "void calculateMaterial (in vec3 _eyeToPoint, inout vec3 _normal) {\n" + "    // get EMISSION TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_UV\n" + "        material.emission *= texture2D(u_material_emission_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_PLANAR\n" + "        material.emission *= getPlanar(u_material_emission_texture, v_world_position.xyz, material.emissionScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_TRIPLANAR\n" + "        material.emission *= getTriPlanar(u_material_emission_texture, v_world_position.xyz, _normal, material.emissionScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_SPHEREMAP\n" + "        material.emission *= getSphereMap(u_material_emission_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // get AMBIENT TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_UV\n" + "        material.ambient *= texture2D(u_material_ambient_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_PLANAR\n" + "        material.ambient *= getPlanar(u_material_ambient_texture, v_world_position.xyz, material.ambientScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_TRIPLANAR\n" + "        material.ambient *= getTriPlanar(u_material_ambient_texture, v_world_position.xyz, _normal, material.ambientScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_SPHEREMAP\n" + "        material.ambient *= getSphereMap(u_material_ambient_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // get DIFFUSE TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_UV\n" + "        material.diffuse *= texture2D(u_material_diffuse_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_PLANAR\n" + "        material.diffuse *= getPlanar(u_material_diffuse_texture, v_world_position.xyz, material.diffuseScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_TRIPLANAR\n" + "        material.diffuse *= getTriPlanar(u_material_diffuse_texture, v_world_position.xyz, _normal, material.diffuseScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_SPHEREMAP\n" + "        material.diffuse *= getSphereMap(u_material_diffuse_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // get SPECULAR TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_UV\n" + "        material.specular *= texture2D(u_material_specular_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_PLANAR\n" + "        material.specular *= getPlanar(u_material_specular_texture, v_world_position.xyz, material.specularScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_TRIPLANAR\n" + "        material.specular *= getTriPlanar(u_material_specular_texture, v_world_position.xyz, _normal, material.specularScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_SPHEREMAP\n" + "        material.specular *= getSphereMap(u_material_specular_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "}\n" + "";

shaderSources['gl/shaders/pointLight'] = "/*\n" + "\n" + "Expected globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct PointLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec4 position;\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "    float attenuationExponent;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "    float innerRadius;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "    float outerRadius;\n" + "#endif\n" + "};\n" + "\n" + "void calculateLight(in PointLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "\n" + "    float dist = length(_light.position.xyz - _eyeToPoint);\n" + "\n" + "    // Compute vector from surface to light position\n" + "    vec3 VP = (_light.position.xyz - _eyeToPoint) / dist;\n" + "\n" + "    // Normalize the vector from surface to light position\n" + "    float nDotVP = clamp(dot(VP, _normal), 0.0, 1.0);\n" + "\n" + "    // Attenuation defaults\n" + "    float attenuation = 1.0;\n" + "    #ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "        float Rin = 1.0;\n" + "        float e = _light.attenuationExponent;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "            float Rdiff = _light.outerRadius-Rin;\n" + "            float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "            attenuation = 1.0-(pow(d,e));\n" + "        #else\n" + "            // If no outer is provide behaves like:\n" + "            // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "            float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "            attenuation = clamp(1.0/(pow(d,e)), 0.0, 1.0);\n" + "        #endif\n" + "    #else\n" + "        float Rin = 0.0;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float Rdiff = _light.outerRadius-Rin;\n" + "                float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                // If no outer is provide behaves like:\n" + "                // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "                float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "                attenuation = clamp(1.0/d, 0.0, 1.0);\n" + "            #endif\n" + "        #else\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float d = clamp(dist/_light.outerRadius, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                attenuation = 1.0;\n" + "            #endif\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // Computer accumulators\n" + "    light_accumulator_ambient += _light.ambient * attenuation;\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        light_accumulator_diffuse += _light.diffuse * nDotVP * attenuation;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        float pf = 0.0; // power factor for shiny speculars\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(-VP, _normal);\n" + "            float eyeDotR = max(0.0, dot(-normalize(_eyeToPoint), reflectVector));\n" + "            pf = pow(eyeDotR, material.shininess);\n" + "        }\n" + "\n" + "        light_accumulator_specular += _light.specular * pf * attenuation;\n" + "    #endif\n" + "}\n" + "";

shaderSources['gl/shaders/selection_fragment'] = "// Fragment shader for feature selection passes\n" + "// Renders in silhouette according to selection (picking) color, or black if none defined\n" + "\n" + "#ifdef TANGRAM_FEATURE_SELECTION\n" + "    varying vec4 v_selection_color;\n" + "#endif\n" + "\n" + "void main (void) {\n" + "    #ifdef TANGRAM_FEATURE_SELECTION\n" + "        gl_FragColor = v_selection_color;\n" + "    #else\n" + "        gl_FragColor = vec4(0., 0., 0., 1.);\n" + "    #endif\n" + "}\n" + "";

shaderSources['gl/shaders/selection_globals'] = "// Vertex attribute + varying for feature selection\n" + "#if defined(TANGRAM_FEATURE_SELECTION) && defined(TANGRAM_VERTEX_SHADER)\n" + "    attribute vec4 a_selection_color;\n" + "    varying vec4 v_selection_color;\n" + "#endif\n" + "";

shaderSources['gl/shaders/selection_vertex'] = "// Selection pass-specific rendering\n" + "#if defined(TANGRAM_FEATURE_SELECTION) && defined(TANGRAM_VERTEX_SHADER)\n" + "    if (a_selection_color.rgb == vec3(0.)) {\n" + "        // Discard by forcing invalid triangle if we\'re in the feature\n" + "        // selection pass but have no selection info\n" + "        // TODO: in some cases we may actually want non-selectable features to occlude selectable ones?\n" + "        gl_Position = vec4(0., 0., 0., 1.);\n" + "        return;\n" + "    }\n" + "    v_selection_color = a_selection_color;\n" + "#endif\n" + "";

shaderSources['gl/shaders/spherical_environment_map'] = "// Spherical environment map\n" + "// Based on: http://www.clicktorelease.com/blog/creating-spherical-environment-mapping-shader\n" + "\n" + "// view: location of camera\n" + "// position: location of current point on surface\n" + "// normal: normal of current point on surface\n" + "// skew: skewing factor (used to compensate for altered vanishing point)\n" + "// envmap: spherical environment map texture\n" + "\n" + "vec4 sphericalEnvironmentMap(vec3 view, vec3 position, vec3 normal, vec2 skew, sampler2D envmap) {\n" + "    // Normalized vector from camera to surface\n" + "    vec3 eye = normalize(position.xyz - view.xyz);\n" + "\n" + "    // Skew\n" + "    eye.xy -= skew;\n" + "    eye = normalize(eye);\n" + "\n" + "    // Reflection of eye off of surface normal\n" + "    vec3 r = reflect(eye, normal);\n" + "\n" + "    // Map reflected vector onto the surface of a sphere\n" + "    r.z += 1.;\n" + "    float m = 2. * length(r);\n" + "\n" + "    // Adjust xy to account for spherical shape, and center in middle of texture\n" + "    vec2 uv = r.xy / m + .5;\n" + "\n" + "    // Sample the environment map\n" + "    return texture2D(envmap, uv);\n" + "}\n" + "";

shaderSources['gl/shaders/spotLight'] = "/*\n" + "\n" + "Expected globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct SpotLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec4 position;\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "    float attenuationExponent;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "    float innerRadius;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "    float outerRadius;\n" + "#endif\n" + "\n" + "    vec3 direction;\n" + "    float spotCosCutoff;\n" + "    float spotExponent;\n" + "};\n" + "\n" + "void calculateLight(in SpotLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "\n" + "    float dist = length(_light.position.xyz - _eyeToPoint);\n" + "\n" + "    // Compute vector from surface to light position\n" + "    vec3 VP = (_light.position.xyz - _eyeToPoint) / dist;\n" + "\n" + "    // normal . light direction\n" + "    float nDotVP = clamp(dot(_normal, VP), 0.0, 1.0);\n" + "\n" + "    // Attenuation defaults\n" + "    float attenuation = 1.0;\n" + "    #ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "        float Rin = 1.0;\n" + "        float e = _light.attenuationExponent;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "            float Rdiff = _light.outerRadius-Rin;\n" + "            float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "            attenuation = 1.0-(pow(d,e));\n" + "        #else\n" + "            // If no outer is provide behaves like:\n" + "            // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "            float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "            attenuation = clamp(1.0/(pow(d,e)), 0.0, 1.0);\n" + "        #endif\n" + "    #else\n" + "        float Rin = 0.0;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float Rdiff = _light.outerRadius-Rin;\n" + "                float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                // If no outer is provide behaves like:\n" + "                // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "                float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "                attenuation = clamp(1.0/d, 0.0, 1.0);\n" + "            #endif\n" + "        #else\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float d = clamp(dist/_light.outerRadius, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                attenuation = 1.0;\n" + "            #endif\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // spotlight attenuation factor\n" + "    float spotAttenuation = 0.0;\n" + "\n" + "    // See if point on surface is inside cone of illumination\n" + "    float spotDot = clamp(dot(-VP, normalize(_light.direction)), 0.0, 1.0);\n" + "\n" + "    if (spotDot >= _light.spotCosCutoff) {\n" + "        spotAttenuation = pow(spotDot, _light.spotExponent);\n" + "    }\n" + "\n" + "    light_accumulator_ambient += _light.ambient * attenuation * spotAttenuation;\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        light_accumulator_diffuse += _light.diffuse * nDotVP * attenuation * spotAttenuation;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        // Power factor for shiny speculars\n" + "        float pf = 0.0;\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(-VP, _normal);\n" + "            float eyeDotR = max(dot(-normalize(_eyeToPoint), reflectVector), 0.0);\n" + "            pf = pow(eyeDotR, material.shininess);\n" + "        }\n" + "        light_accumulator_specular += _light.specular * pf * attenuation * spotAttenuation;\n" + "    #endif\n" + "}\n" + "";

shaderSources['gl/shaders/unpack'] = "\n" + "// Unpack normalized shorts back to their original integer values\n" + "#define SHORT(x) (x * 32767.)\n" + "#define UNSIGNED_SHORT(x) (x * 65535.)\n" + "\n" + "// Used for cases where an attribute is stored as a normalized int type,\n" + "// but is a floating point value that needs a range greater than [0, 1] or [-1, 1].\n" + "// The integer value is \"scaled\" to an 8.8 fixed point style integer before it is\n" + "// normalized in the VBO. Used for cases where low precision is suitable for both\n" + "// the integer and fractional portions of the number.\n" + "// Examples are extrusion vectors for dynamic lines, and screen-space size for point sprites.\n" + "#define SCALE_8(x) (x * 256.)\n" + "";

shaderSources['styles/points/points_fragment'] = "uniform vec2 u_resolution;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec4 u_tile_origin;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_device_pixel_ratio;\n" + "\n" + "uniform mat3 u_normalMatrix;\n" + "uniform mat3 u_inverseNormalMatrix;\n" + "\n" + "uniform sampler2D u_texture;\n" + "\n" + "varying vec4 v_color;\n" + "varying vec2 v_texcoord;\n" + "varying vec4 v_world_position;\n" + "\n" + "#define TANGRAM_NORMAL vec3(0., 0., 1.)\n" + "\n" + "// Alpha discard threshold (substitute for alpha blending)\n" + "#ifndef TANGRAM_ALPHA_DISCARD\n" + "#define TANGRAM_ALPHA_DISCARD 0.5\n" + "#endif\n" + "\n" + "// Alpha fade range for edges of points\n" + "#ifndef TANGRAM_FADE_RANGE\n" + "#define TANGRAM_FADE_RANGE .15\n" + "#endif\n" + "#define TANGRAM_FADE_START (1. - TANGRAM_FADE_RANGE)\n" + "\n" + "#pragma tangram: camera\n" + "#pragma tangram: material\n" + "#pragma tangram: lighting\n" + "#pragma tangram: global\n" + "\n" + "void main (void) {\n" + "    // Initialize globals\n" + "    #pragma tangram: setup\n" + "\n" + "    vec4 color = v_color;\n" + "\n" + "    // Apply a texture\n" + "    #ifdef TANGRAM_POINT_TEXTURE\n" + "        color *= texture2D(u_texture, v_texcoord);\n" + "\n" + "        // Manually un-multiply alpha, for cases where texture has pre-multiplied alpha\n" + "        #ifdef TANGRAM_UNMULTIPLY_ALPHA\n" + "            color.rgb /= max(color.a, 0.001);\n" + "        #endif\n" + "    // Draw a point\n" + "    #else\n" + "        // Fade alpha near circle edge\n" + "        vec2 uv = v_texcoord * 2. - 1.;\n" + "        float point_dist = length(uv);\n" + "        color.a = clamp(color.a - (smoothstep(0., TANGRAM_FADE_RANGE, (point_dist - TANGRAM_FADE_START)) / TANGRAM_FADE_RANGE), 0., color.a);\n" + "    #endif\n" + "\n" + "    // If blending is off, use alpha discard as a lower-quality substitute\n" + "    #if !defined(TANGRAM_BLEND_OVERLAY) && !defined(TANGRAM_BLEND_INLAY)\n" + "        if (color.a < TANGRAM_ALPHA_DISCARD) {\n" + "            discard;\n" + "        }\n" + "    #endif\n" + "\n" + "    #pragma tangram: color\n" + "\n" + "    // Fade out when tile is zooming out, e.g. acting as proxy tiles\n" + "    // NB: this is mostly done to compensate for text label collision happening at the label\'s 1x zoom. As labels\n" + "    // in proxy tiles are scaled down, they begin to overlap, and the fade is a simple way to ease the transition.\n" + "    #ifdef TANGRAM_FADE_ON_ZOOM_OUT\n" + "        color.a *= clamp(1. - TANGRAM_FADE_ON_ZOOM_OUT_RATE * (u_tile_origin.z - u_map_position.z), 0., 1.);\n" + "    #endif\n" + "\n" + "    #pragma tangram: filter\n" + "\n" + "    gl_FragColor = color;\n" + "}\n" + "";

shaderSources['styles/points/points_vertex'] = "uniform vec2 u_resolution;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec4 u_tile_origin;\n" + "uniform float u_tile_proxy_depth;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_device_pixel_ratio;\n" + "\n" + "uniform mat4 u_model;\n" + "uniform mat4 u_modelView;\n" + "uniform mat3 u_normalMatrix;\n" + "uniform mat3 u_inverseNormalMatrix;\n" + "\n" + "attribute vec4 a_position;\n" + "attribute vec4 a_shape;\n" + "attribute vec4 a_color;\n" + "attribute vec2 a_texcoord;\n" + "attribute vec2 a_offset;\n" + "\n" + "#define TANGRAM_NORMAL vec3(0., 0., 1.)\n" + "\n" + "varying vec4 v_color;\n" + "varying vec2 v_texcoord;\n" + "varying vec4 v_world_position;\n" + "\n" + "#pragma tangram: camera\n" + "#pragma tangram: material\n" + "#pragma tangram: lighting\n" + "#pragma tangram: global\n" + "\n" + "vec2 rotate2D(vec2 _st, float _angle) {\n" + "    return mat2(cos(_angle),-sin(_angle),\n" + "                sin(_angle),cos(_angle)) * _st;\n" + "}\n" + "\n" + "void main() {\n" + "    // Initialize globals\n" + "    #pragma tangram: setup\n" + "\n" + "    v_color = a_color;\n" + "    v_texcoord = a_texcoord;\n" + "\n" + "    // Position\n" + "    vec4 position = u_modelView * vec4(SHORT(a_position.xyz), 1.);\n" + "\n" + "    // Apply positioning and scaling in screen space\n" + "    float zscale = fract(u_map_position.z) * (SCALE_8(a_shape.w) - 1.) + 1.;\n" + "    // float zscale = log(fract(u_map_position.z) + 1.) / log(2.) * (a_shape.w - 1.) + 1.;\n" + "    vec2 shape = SCALE_8(a_shape.xy) * zscale;     //\n" + "    vec2 offset = vec2(a_offset.x, -a_offset.y); // flip y to make it point down\n" + "    float theta = radians(a_shape.z * 360.);\n" + "\n" + "    shape = rotate2D(shape, theta);             // apply rotation to vertex\n" + "    shape += rotate2D(SHORT(offset), theta);  // apply offset on rotated axis (e.g. so line labels follow text axis)\n" + "\n" + "    // World coordinates for 3d procedural textures\n" + "    v_world_position = u_model * position;\n" + "    v_world_position.xy += shape * u_meters_per_pixel;\n" + "    v_world_position = wrapWorldPosition(v_world_position);\n" + "\n" + "    // Modify position before camera projection\n" + "    #pragma tangram: position\n" + "\n" + "    cameraProjection(position);\n" + "\n" + "    #ifdef TANGRAM_LAYER_ORDER\n" + "        // +1 is to keep all layers including proxies > 0\n" + "        applyLayerOrder(SHORT(a_position.w) + u_tile_proxy_depth + 1., position);\n" + "    #endif\n" + "\n" + "    // Apply pixel offset in screen-space\n" + "    // Multiply by 2 is because screen is 2 units wide Normalized Device Coords (and u_resolution device pixels wide)\n" + "    // Device pixel ratio adjustment is because shape is in logical pixels\n" + "    position.xy += shape * position.w * 2. * u_device_pixel_ratio / u_resolution;\n" + "\n" + "    gl_Position = position;\n" + "}\n" + "";

shaderSources['styles/polygons/polygons_fragment'] = "uniform vec2 u_resolution;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec4 u_tile_origin;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_device_pixel_ratio;\n" + "\n" + "uniform mat3 u_normalMatrix;\n" + "uniform mat3 u_inverseNormalMatrix;\n" + "\n" + "varying vec4 v_position;\n" + "varying vec3 v_normal;\n" + "varying vec4 v_color;\n" + "varying vec4 v_world_position;\n" + "\n" + "#define TANGRAM_NORMAL v_normal\n" + "\n" + "#ifdef TANGRAM_TEXTURE_COORDS\n" + "    varying vec2 v_texcoord;\n" + "#endif\n" + "\n" + "#if defined(TANGRAM_LIGHTING_VERTEX)\n" + "    varying vec4 v_lighting;\n" + "#endif\n" + "\n" + "#pragma tangram: camera\n" + "#pragma tangram: material\n" + "#pragma tangram: lighting\n" + "#pragma tangram: global\n" + "\n" + "void main (void) {\n" + "    // Initialize globals\n" + "    #pragma tangram: setup\n" + "\n" + "    vec4 color = v_color;\n" + "    vec3 normal = TANGRAM_NORMAL;\n" + "\n" + "    // Normal material texture (fragment lighting only)\n" + "    #if defined(TANGRAM_LIGHTING_FRAGMENT) && defined(TANGRAM_MATERIAL_NORMAL_TEXTURE)\n" + "        calculateNormal(normal);\n" + "    #endif\n" + "\n" + "    // Normal modification applied here for fragment lighting or no lighting,\n" + "    // and in vertex shader for vertex lighting\n" + "    #if !defined(TANGRAM_LIGHTING_VERTEX)\n" + "        #pragma tangram: normal\n" + "    #endif\n" + "\n" + "    // Color modification before lighting is applied\n" + "    #pragma tangram: color\n" + "\n" + "    #if defined(TANGRAM_LIGHTING_FRAGMENT)\n" + "        // Calculate per-fragment lighting\n" + "        color = calculateLighting(v_position.xyz - u_eye, normal, color);\n" + "    #elif defined(TANGRAM_LIGHTING_VERTEX)\n" + "        // Apply lighting intensity interpolated from vertex shader\n" + "        color *= v_lighting;\n" + "    #endif\n" + "\n" + "    // Post-processing effects (modify color after lighting)\n" + "    #pragma tangram: filter\n" + "\n" + "    gl_FragColor = color;\n" + "}\n" + "";

shaderSources['styles/polygons/polygons_vertex'] = "uniform vec2 u_resolution;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec4 u_tile_origin;\n" + "uniform float u_tile_proxy_depth;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_device_pixel_ratio;\n" + "\n" + "uniform mat4 u_model;\n" + "uniform mat4 u_modelView;\n" + "uniform mat3 u_normalMatrix;\n" + "uniform mat3 u_inverseNormalMatrix;\n" + "\n" + "attribute vec4 a_position;\n" + "attribute vec4 a_color;\n" + "\n" + "// Optional normal attribute, otherwise default to up\n" + "#ifdef TANGRAM_NORMAL_ATTRIBUTE\n" + "    attribute vec3 a_normal;\n" + "    #define TANGRAM_NORMAL a_normal\n" + "#else\n" + "    #define TANGRAM_NORMAL vec3(0., 0., 1.)\n" + "#endif\n" + "\n" + "// Optional dynamic line extrusion\n" + "#ifdef TANGRAM_EXTRUDE_LINES\n" + "    // xy: extrusion direction in xy plane\n" + "    // z:  half-width of line (amount to extrude)\n" + "    // w:  scaling factor for interpolating width between zooms\n" + "    attribute vec4 a_extrude;\n" + "#endif\n" + "\n" + "varying vec4 v_position;\n" + "varying vec3 v_normal;\n" + "varying vec4 v_color;\n" + "varying vec4 v_world_position;\n" + "\n" + "// Optional texture UVs\n" + "#ifdef TANGRAM_TEXTURE_COORDS\n" + "    attribute vec2 a_texcoord;\n" + "    varying vec2 v_texcoord;\n" + "#endif\n" + "\n" + "#if defined(TANGRAM_LIGHTING_VERTEX)\n" + "    varying vec4 v_lighting;\n" + "#endif\n" + "\n" + "#pragma tangram: camera\n" + "#pragma tangram: material\n" + "#pragma tangram: lighting\n" + "#pragma tangram: global\n" + "\n" + "void main() {\n" + "    // Initialize globals\n" + "    #pragma tangram: setup\n" + "\n" + "    // Texture UVs\n" + "    #ifdef TANGRAM_TEXTURE_COORDS\n" + "        v_texcoord = a_texcoord;\n" + "    #endif\n" + "\n" + "    // Position\n" + "    vec4 position = vec4(SHORT(a_position.xyz), 1.);\n" + "\n" + "    #ifdef TANGRAM_EXTRUDE_LINES\n" + "        vec2 extrude = SCALE_8(a_extrude.xy);\n" + "        float width = SHORT(a_extrude.z);\n" + "        float dwdz = SHORT(a_extrude.w);\n" + "        float dz = clamp(u_map_position.z - u_tile_origin.z, 0., 1.);\n" + "\n" + "        // Interpolate between zoom levels\n" + "        width += dwdz * dz;\n" + "\n" + "        // Scale pixel dimensions to be consistent in screen space\n" + "        width *= exp2(-dz);\n" + "\n" + "        // Modify line width before extrusion\n" + "        #pragma tangram: width\n" + "\n" + "        position.xy += extrude * width;\n" + "    #endif\n" + "\n" + "    // World coordinates for 3d procedural textures\n" + "    v_world_position = wrapWorldPosition(u_model * position);\n" + "\n" + "    // Adjust for tile and view position\n" + "    position = u_modelView * position;\n" + "\n" + "    // Modify position before camera projection\n" + "    #pragma tangram: position\n" + "\n" + "    // Setup varyings\n" + "    v_position = position;\n" + "    v_normal = normalize(u_normalMatrix * TANGRAM_NORMAL);\n" + "    v_color = a_color;\n" + "\n" + "    #if defined(TANGRAM_LIGHTING_VERTEX)\n" + "        // Vertex lighting\n" + "        vec3 normal = v_normal;\n" + "\n" + "        // Modify normal before lighting\n" + "        #pragma tangram: normal\n" + "\n" + "        // Pass lighting intensity to fragment shader\n" + "        v_lighting = calculateLighting(position.xyz - u_eye, normal, vec4(1.));\n" + "    #endif\n" + "\n" + "    // Camera\n" + "    cameraProjection(position);\n" + "\n" + "    // +1 is to keep all layers including proxies > 0\n" + "    applyLayerOrder(SHORT(a_position.w) + u_tile_proxy_depth + 1., position);\n" + "\n" + "    gl_Position = position;\n" + "}\n" + "";

exports["default"] = shaderSources;
module.exports = exports["default"];

},{}],205:[function(_dereq_,module,exports){
// Texture management
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsUtils = _dereq_('../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _utilsSubscribe = _dereq_('../utils/subscribe');

var _utilsSubscribe2 = _interopRequireDefault(_utilsSubscribe);

var _utilsWorker_broker = _dereq_('../utils/worker_broker');

var _utilsWorker_broker2 = _interopRequireDefault(_utilsWorker_broker);

var _stylesBuilders = _dereq_('../styles/builders');

var _stylesBuilders2 = _interopRequireDefault(_stylesBuilders);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

// GL texture wrapper object for keeping track of a global set of textures, keyed by a unique user-defined name

var Texture = (function () {
    function Texture(gl, name) {
        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, Texture);

        this.gl = gl;
        this.texture = gl.createTexture();
        if (this.texture) {
            this.valid = true;
        }
        this.bind();

        this.name = name;
        this.source = null;
        this.source_type = null;
        this.config_type = null;
        this.loading = null; // a Promise object to track the loading state of this texture
        this.filtering = options.filtering;
        this.sprites = options.sprites;
        this.texcoords = {}; // sprite UVs ([0, 1] range)
        this.sizes = {}; // sprite sizes (pixel size)

        // Default to a 1-pixel black texture so we can safely render while we wait for an image to load
        // See: http://stackoverflow.com/questions/19722247/webgl-wait-for-texture-to-load
        this.setData(1, 1, new Uint8Array([0, 0, 0, 255]), { filtering: 'nearest' });

        // Destroy previous texture if present
        if (Texture.textures[this.name]) {
            Texture.textures[this.name].destroy();
        }

        // Cache texture instance and definition
        Texture.textures[this.name] = this;
        Texture.texture_configs[this.name] = _Object$assign({ name: name }, options);

        this.load(options);
        _loglevel2['default'].trace('creating Texture ' + this.name);
    }

    // Static/class methods and state

    // Destroy a single texture instance

    _createClass(Texture, [{
        key: 'destroy',
        value: function destroy() {
            if (!this.valid) {
                return;
            }
            this.gl.deleteTexture(this.texture);
            this.texture = null;
            delete this.data;
            this.data = null;
            delete Texture.textures[this.name];
            this.valid = false;
            _loglevel2['default'].trace('destroying Texture ' + this.name);
        }
    }, {
        key: 'bind',
        value: function bind(unit) {
            if (!this.valid) {
                return;
            }
            if (typeof unit === 'number') {
                if (Texture.activeUnit !== unit) {
                    this.gl.activeTexture(this.gl.TEXTURE0 + unit);
                    Texture.activeUnit = unit;
                }
            }
            if (Texture.activeTexture !== this.texture) {
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                Texture.activeTexture = this.texture;
            }
        }
    }, {
        key: 'load',
        value: function load(options) {
            var _this = this;

            if (!options) {
                return this.loading || _Promise.resolve(this);
            }

            this.loading = null;
            if (typeof options.url === 'string') {
                this.config_type = 'url';
                this.setUrl(options.url, options);
            } else if (options.element) {
                this.config_type = 'element';
                this.setElement(options.element, options);
            } else if (options.data && options.width && options.height) {
                this.config_type = 'data';
                this.setData(options.width, options.height, options.data, options);
            }

            this.loading = this.loading && this.loading.then(function () {
                _this.calculateSprites();return _this;
            }) || _Promise.resolve(this);
            return this.loading;
        }

        // Sets texture from an url
    }, {
        key: 'setUrl',
        value: function setUrl(url) {
            var _this2 = this;

            var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            if (!this.valid) {
                return;
            }

            if (Texture.base_url) {
                url = _utilsUtils2['default'].addBaseURL(url, Texture.base_url);
            }

            this.url = _utilsUtils2['default'].cacheBusterForUrl(url); // save URL reference (will be overwritten when element is loaded below)
            this.source = this.url;
            this.source_type = 'url';

            this.loading = new _Promise(function (resolve, reject) {
                var image = new Image();
                image.onload = function () {
                    try {
                        _this2.setElement(image, options);
                    } catch (e) {
                        _loglevel2['default'].warn('Texture \'' + _this2.name + '\': failed to load url: \'' + _this2.source + '\'', e, options);
                        Texture.trigger('warning', { message: 'Failed to load texture from ' + _this2.source, error: e, texture: options });
                    }

                    resolve(_this2);
                };
                image.onerror = function (e) {
                    // Warn and resolve on error
                    _loglevel2['default'].warn('Texture \'' + _this2.name + '\': failed to load url: \'' + _this2.source + '\'', e, options);
                    Texture.trigger('warning', { message: 'Failed to load texture from ' + _this2.source, error: e, texture: options });
                    resolve(_this2);
                };
                image.crossOrigin = 'anonymous';
                image.src = _this2.source;
            });
            return this.loading;
        }

        // Sets texture to a raw image buffer
    }, {
        key: 'setData',
        value: function setData(width, height, data) {
            var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

            this.width = width;
            this.height = height;

            this.source = data;
            this.source_type = 'data';

            this.update(options);
            this.setFiltering(options);

            this.loading = _Promise.resolve(this);
            return this.loading;
        }

        // Sets the texture to track a element (canvas/image)
    }, {
        key: 'setElement',
        value: function setElement(element, options) {
            var el = element;

            // a string element is interpeted as a CSS selector
            if (typeof element === 'string') {
                element = document.querySelector(element);
            }

            if (element instanceof HTMLCanvasElement || element instanceof HTMLImageElement || element instanceof HTMLVideoElement) {
                this.source = element;
                this.source_type = 'element';

                this.update(options);
                this.setFiltering(options);
            } else {
                var msg = 'the \'element\' parameter (`element: ' + JSON.stringify(el) + '`) must be a CSS ';
                msg += 'selector string, or a <canvas>, <image> or <video> object';
                _loglevel2['default'].warn('Texture \'' + this.name + '\': ' + msg, options);
                Texture.trigger('warning', { message: 'Failed to load texture because ' + msg, texture: options });
            }

            this.loading = _Promise.resolve(this);
            return this.loading;
        }

        // Uploads current image or buffer to the GPU (can be used to update animated textures on the fly)
    }, {
        key: 'update',
        value: function update() {
            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            if (!this.valid) {
                return;
            }

            this.bind();
            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, options.UNPACK_FLIP_Y_WEBGL === false ? false : true);
            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.UNPACK_PREMULTIPLY_ALPHA_WEBGL || false);

            // Image or Canvas element
            if (this.source instanceof HTMLCanvasElement || this.source instanceof HTMLVideoElement || this.source instanceof HTMLImageElement && this.source.complete) {

                this.width = this.source.width;
                this.height = this.source.height;
                this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.source);
            }
            // Raw image buffer
            else if (this.source_type === 'data') {
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.width, this.height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.source);
                }

            Texture.trigger('update', this);
        }

        // Determines appropriate filtering mode
    }, {
        key: 'setFiltering',
        value: function setFiltering() {
            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            if (!this.valid) {
                return;
            }

            options.filtering = options.filtering || 'linear';

            var gl = this.gl;
            this.bind();

            // For power-of-2 textures, the following presets are available:
            // mipmap: linear blend from nearest mip
            // linear: linear blend from original image (no mips)
            // nearest: nearest pixel from original image (no mips, 'blocky' look)
            if (_utilsUtils2['default'].isPowerOf2(this.width) && _utilsUtils2['default'].isPowerOf2(this.height)) {
                this.power_of_2 = true;
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.TEXTURE_WRAP_S || options.repeat && gl.REPEAT || gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.TEXTURE_WRAP_T || options.repeat && gl.REPEAT || gl.CLAMP_TO_EDGE);

                if (options.filtering === 'mipmap') {
                    this.filtering = 'mipmap';
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR); // TODO: use trilinear filtering by defualt instead?
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.generateMipmap(gl.TEXTURE_2D);
                } else if (options.filtering === 'linear') {
                    this.filtering = 'linear';
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                } else if (options.filtering === 'nearest') {
                    this.filtering = 'nearest';
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                }
            } else {
                // WebGL has strict requirements on non-power-of-2 textures:
                // No mipmaps and must clamp to edge
                this.power_of_2 = false;
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                if (options.filtering === 'nearest') {
                    this.filtering = 'nearest';
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                } else {
                    // default to linear for non-power-of-2 textures
                    this.filtering = 'linear';
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                }
            }

            Texture.trigger('update', this);
        }

        // Pre-calc sprite regions for a texture sprite in UV [0, 1] space
    }, {
        key: 'calculateSprites',
        value: function calculateSprites() {
            if (this.sprites) {
                for (var s in this.sprites) {
                    var sprite = this.sprites[s];

                    // Map [0, 0] to [1, 1] coords to the appropriate sprite sub-area of the texture
                    this.texcoords[s] = _stylesBuilders2['default'].getTexcoordsForSprite([sprite[0], sprite[1]], [sprite[2], sprite[3]], [this.width, this.height]);

                    // Pixel size of sprite
                    this.sizes[s] = [sprite[2], sprite[3]];
                }
            }
        }
    }]);

    return Texture;
})();

exports['default'] = Texture;
Texture.create = function constructor(gl, name, options) {
    return new Texture(gl, name, options);
};

// Destroy all texture instances for a given GL context
Texture.destroy = function (gl) {
    var textures = _Object$keys(Texture.textures);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = _getIterator(textures), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var t = _step.value;

            var texture = Texture.textures[t];
            if (texture.gl === gl) {
                texture.destroy();
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
                _iterator['return']();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
};

// Get sprite pixel size and UVs
Texture.getSpriteInfo = function (texname, sprite) {
    var texture = Texture.textures[texname];
    return texture && { size: texture.sizes[sprite], texcoords: texture.texcoords[sprite] };
};

// Create a set of textures keyed in an object
// Optionally load each if it has a URL specified
Texture.createFromObject = function (gl, textures) {
    var loading = [];
    if (textures) {
        for (var texname in textures) {
            var config = textures[texname];

            // If texture already exists and definition hasn't changed, no need to re-create
            // Note: to avoid flicker when other textures/scene items change
            if (!Texture.changed(texname, config)) {
                continue;
            }

            var texture = Texture.create(gl, texname, config);
            loading.push(texture.loading);
        }
    }
    return _Promise.all(loading);
};

// Indicate if a texture definition would be a change from the current cache
Texture.changed = function (name, config) {
    var texture = Texture.textures[name];
    if (texture) {
        // cached texture
        // canvas/image-based textures are considered dynamic and always refresh
        if (texture.config_type === 'element' || config.element != null) {
            return true;
        }

        // compare definitions
        if (JSON.stringify(Texture.texture_configs[name]) === JSON.stringify(_Object$assign({ name: name }, config))) {
            return false;
        }
    }
    return true;
};

// Get metadata for a texture by name
// Returns via promise, in case texture is still loading
// Can be called on main thread from worker, to sync texture info to worker
Texture.getInfo = function (name) {
    // Get info for all textures by default
    if (!name) {
        name = _Object$keys(Texture.textures);
    }

    // Get multiple textures
    if (Array.isArray(name)) {
        return _Promise.all(name.map(function (n) {
            return Texture.getInfo(n);
        }));
    }

    // Get single texture
    var tex = Texture.textures[name];
    if (tex) {
        // Wait for this texture to finish loading, or return immediately
        var loading = tex.loading || _Promise.resolve(tex);
        return loading.then(function () {
            // Return a subset of texture info
            // (compatible w/structured cloning, suitable for passing to a worker)
            return {
                name: tex.name,
                width: tex.width,
                height: tex.height,
                sprites: tex.sprites,
                texcoords: tex.texcoords,
                sizes: tex.sizes,
                filtering: tex.filtering,
                power_of_2: tex.power_of_2,
                valid: tex.valid
            };
        });
    } else {
        // No texture found
        return _Promise.resolve(null);
    }
};

// Sync texture info to worker
// Called from worker, gets info on one or more textures info from main thread via remote call, then stores it
// locally in worker. 'textures' can be an array of texture names to sync, or if null, all textures are synced.
Texture.syncTexturesToWorker = function (names) {
    return _utilsWorker_broker2['default'].postMessage('Texture.getInfo', names).then(function (textures) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = _getIterator(textures), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var tex = _step2.value;

                Texture.textures[tex.name] = tex;
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                    _iterator2['return']();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }

        return Texture.textures;
    });
};

// Report max texture size for a GL context
Texture.getMaxTextureSize = function (gl) {
    return gl.getParameter(gl.MAX_TEXTURE_SIZE);
};

// Global set of textures, by name
Texture.textures = {};
Texture.texture_configs = {};
Texture.boundTexture = -1;
Texture.activeUnit = -1;

Texture.base_url = null; // optional base URL to add to textures

_utilsWorker_broker2['default'].addTarget('Texture', Texture);
(0, _utilsSubscribe2['default'])(Texture);
module.exports = exports['default'];

},{"../styles/builders":227,"../utils/subscribe":246,"../utils/utils":247,"../utils/worker_broker":249,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/keys":12,"babel-runtime/core-js/promise":14,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/interop-require-default":23,"loglevel":183}],206:[function(_dereq_,module,exports){
// Creates a Vertex Array Object if the extension is available, or falls back on standard attribute calls

'use strict';

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var VertexArrayObject;
exports['default'] = VertexArrayObject = {};

VertexArrayObject.disabled = false; // set to true to disable VAOs even if extension is available
VertexArrayObject.bound_vao = null; // currently bound VAO

VertexArrayObject.init = function (gl) {
    if (VertexArrayObject.ext == null) {
        if (VertexArrayObject.disabled !== true) {
            VertexArrayObject.ext = gl.getExtension("OES_vertex_array_object");
        }

        if (VertexArrayObject.ext != null) {
            _loglevel2['default'].info('Vertex Array Object extension available');
        } else if (VertexArrayObject.disabled !== true) {
            _loglevel2['default'].warn('Vertex Array Object extension NOT available');
        } else {
            _loglevel2['default'].warn('Vertex Array Object extension force disabled');
        }
    }
};

VertexArrayObject.create = function (setup, teardown) {
    var vao = {};
    vao.setup = setup;
    vao.teardown = teardown;

    var ext = VertexArrayObject.ext;
    if (ext != null) {
        vao._vao = ext.createVertexArrayOES();
        ext.bindVertexArrayOES(vao._vao);
    }

    vao.setup(true);

    return vao;
};

VertexArrayObject.bind = function (vao) {
    var ext = VertexArrayObject.ext;
    if (vao != null) {
        if (ext != null && vao._vao != null) {
            ext.bindVertexArrayOES(vao._vao);
            VertexArrayObject.bound_vao = vao;
        } else {
            vao.setup(false);
        }
    } else {
        if (ext != null) {
            ext.bindVertexArrayOES(null);
        } else if (VertexArrayObject.bound_vao != null && typeof VertexArrayObject.bound_vao.teardown === 'function') {
            VertexArrayObject.bound_vao.teardown();
        }
        VertexArrayObject.bound_vao = null;
    }
};
module.exports = exports['default'];

},{"babel-runtime/helpers/interop-require-default":23,"loglevel":183}],207:[function(_dereq_,module,exports){
// Manage rendering for primitives
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _Map = _dereq_('babel-runtime/core-js/map')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _shader_program = _dereq_('./shader_program');

var _shader_program2 = _interopRequireDefault(_shader_program);

var _vao = _dereq_('./vao');

var _vao2 = _interopRequireDefault(_vao);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

// A single mesh/VBO, described by a vertex layout, that can be drawn with one or more programs

var VBOMesh = (function () {
    function VBOMesh(gl, vertex_data, vertex_layout, options) {
        _classCallCheck(this, VBOMesh);

        options = options || {};

        this.gl = gl;
        this.vertex_data = vertex_data; // typed array
        this.vertex_layout = vertex_layout;
        this.buffer = this.gl.createBuffer();
        this.draw_mode = options.draw_mode || this.gl.TRIANGLES;
        this.data_usage = options.data_usage || this.gl.STATIC_DRAW;
        this.vertices_per_geometry = 3; // TODO: support lines, strip, fan, etc.
        this.uniforms = options.uniforms;
        this.retain = options.retain || false; // whether to retain mesh data in CPU after uploading to GPU

        this.vertex_count = this.vertex_data.byteLength / this.vertex_layout.stride;
        this.geometry_count = this.vertex_count / this.vertices_per_geometry;
        this.vaos = new _Map(); // map of VertexArrayObjects, keyed by program

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vertex_data, this.data_usage);

        if (!this.retain) {
            delete this.vertex_data;
        }
        this.valid = true;
    }

    // Render, by default with currently bound program, or otherwise with optionally provided one

    _createClass(VBOMesh, [{
        key: 'render',
        value: function render() {
            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            if (!this.valid) {
                return false;
            }

            if (typeof this._render_setup === 'function') {
                this._render_setup();
            }

            var program = options.program || _shader_program2['default'].current;
            program.use();

            if (this.uniforms) {
                program.saveUniforms(this.uniforms);
                program.setUniforms(this.uniforms, false); // don't reset texture unit
            }

            this.bind(program);

            // TODO: support element array mode
            this.gl.drawArrays(this.draw_mode, 0, this.vertex_count);
            _vao2['default'].bind(null);

            if (this.uniforms) {
                program.restoreUniforms(this.uniforms);
            }

            return true;
        }

        // Bind buffers and vertex attributes to prepare for rendering
    }, {
        key: 'bind',
        value: function bind(program) {
            var _this = this;

            // Bind VAO for this progam, or create one
            var vao = this.vaos.get(program);
            if (vao) {
                _vao2['default'].bind(vao);
            } else {
                this.vaos.set(program, _vao2['default'].create(function (force) {
                    _this.gl.bindBuffer(_this.gl.ARRAY_BUFFER, _this.buffer);
                    _this.vertex_layout.enable(_this.gl, program, force);
                }));
            }
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            if (!this.valid) {
                return false;
            }
            this.valid = false;

            _loglevel2['default'].trace('VBOMesh.destroy: delete buffer' + (this.vertex_data ? ' of size ' + this.vertex_data.byteLength : ''));

            this.gl.deleteBuffer(this.buffer);
            this.buffer = null;
            delete this.vertex_data;

            return true;
        }
    }]);

    return VBOMesh;
})();

exports['default'] = VBOMesh;
module.exports = exports['default'];

},{"./shader_program":203,"./vao":206,"babel-runtime/core-js/map":4,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/interop-require-default":23,"loglevel":183}],208:[function(_dereq_,module,exports){
'use strict';

var _defineProperty = _dereq_('babel-runtime/helpers/define-property')['default'];

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _array_types;

var _constants = _dereq_('./constants');

var _constants2 = _interopRequireDefault(_constants);

// web workers don't have access to GL context, so import all GL constants

var _utilsUtils = _dereq_('../utils/utils');

// Maps GL types to JS array types
var array_types = (_array_types = {}, _defineProperty(_array_types, _constants2['default'].FLOAT, Float32Array), _defineProperty(_array_types, _constants2['default'].BYTE, Int8Array), _defineProperty(_array_types, _constants2['default'].UNSIGNED_BYTE, Uint8Array), _defineProperty(_array_types, _constants2['default'].INT, Int32Array), _defineProperty(_array_types, _constants2['default'].UNSIGNED_INT, Uint32Array), _defineProperty(_array_types, _constants2['default'].SHORT, Int16Array), _defineProperty(_array_types, _constants2['default'].UNSIGNED_SHORT, Uint16Array), _array_types);

// An intermediary object that holds vertex data in typed arrays, according to a given vertex layout
// Used to construct a mesh/VBO for rendering

var VertexData = (function () {
    function VertexData(vertex_layout) {
        var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        var prealloc = _ref.prealloc;

        _classCallCheck(this, VertexData);

        this.vertex_layout = vertex_layout;

        if (VertexData.array_pool.length > 0) {
            this.buffer = VertexData.array_pool.pop();
            this.buffer_length = this.buffer.byteLength;
            this.buffer_size = Math.floor(this.buffer_length / this.vertex_layout.stride);
            (0, _utilsUtils.log)('trace', 'VertexData: reused buffer of bytes ' + this.buffer_length + ', ' + this.buffer_size + ' vertices');
        } else {
            this.buffer_size = prealloc || 500; // # of vertices to allocate
            this.buffer_length = this.vertex_layout.stride * this.buffer_size;
            this.buffer = new Uint8Array(this.buffer_length);
        }
        this.buffer_offset = 0; // byte offset into currently allocated buffer

        this.components = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = _getIterator(this.vertex_layout.components), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var component = _step.value;

                this.components.push([].concat(_toConsumableArray(component)));
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                    _iterator['return']();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        this.vertex_count = 0;
        this.realloc_count = 0;
        this.setBufferViews();
    }

    // (Re-)allocate typed views into the main buffer - only create the types we need for this layout

    _createClass(VertexData, [{
        key: 'setBufferViews',
        value: function setBufferViews() {
            this.buffer_views = {};
            this.buffer_views[_constants2['default'].UNSIGNED_BYTE] = this.buffer;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = _getIterator(this.vertex_layout.attribs), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var attrib = _step2.value;

                    // Need view for this type?
                    if (this.buffer_views[attrib.type] == null) {
                        var array_type = array_types[attrib.type];
                        this.buffer_views[attrib.type] = new array_type(this.buffer.buffer);
                    }
                }

                // Update component buffer pointers
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                        _iterator2['return']();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = _getIterator(this.components), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var component = _step3.value;

                    component[1] = this.buffer_views[component[0]];
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                        _iterator3['return']();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }
        }

        // Check allocated buffer size, expand/realloc buffer if needed
    }, {
        key: 'checkBufferSize',
        value: function checkBufferSize() {
            if (this.buffer_offset + this.vertex_layout.stride > this.buffer_length) {
                this.buffer_size = Math.floor(this.buffer_size * 1.5);
                this.buffer_size -= this.buffer_size % 4;
                this.buffer_length = this.vertex_layout.stride * this.buffer_size;
                var new_view = new Uint8Array(this.buffer_length);
                new_view.set(this.buffer); // copy existing data to new buffer
                VertexData.array_pool.push(this.buffer); // save previous buffer for use by next tile
                this.buffer = new_view;
                this.setBufferViews();
                this.realloc_count++;
                // log.info(`VertexData: expanded vertex block to ${this.buffer_size} vertices`);
            }
        }

        // Add a vertex, copied from a plain JS array of elements matching the order of the vertex layout.
        // Note: uses pre-calculated info about each attribute, including pointer to appropriate typed array
        // view and offset into it. This was the fastest method profiled so far for filling a mixed-type
        // vertex layout (though still slower than the previous method that only supported Float32Array attributes).
    }, {
        key: 'addVertex',
        value: function addVertex(vertex) {
            this.checkBufferSize();
            var i = 0;

            var clen = this.components.length;
            for (var c = 0; c < clen; c++) {
                var component = this.components[c];
                component[1][(this.buffer_offset >> component[2]) + component[3]] = vertex[i++];
            }

            this.buffer_offset += this.vertex_layout.stride;
            this.vertex_count++;
        }

        // Finalize vertex buffer for use in constructing a mesh
    }, {
        key: 'end',
        value: function end() {
            // Clip the buffer to size used for this VBO
            this.buffer = this.buffer.subarray(0, this.buffer_offset);
            (0, _utilsUtils.log)('trace', 'VertexData: ' + this.buffer_size + ' vertices total, realloc count ' + this.realloc_count);
            return this;
        }
    }]);

    return VertexData;
})();

exports['default'] = VertexData;

VertexData.array_pool = []; // pool of currently available (previously used) buffers (uint8)
module.exports = exports['default'];

},{"../utils/utils":247,"./constants":198,"babel-runtime/core-js/get-iterator":2,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/define-property":20,"babel-runtime/helpers/interop-require-default":23,"babel-runtime/helpers/to-consumable-array":25}],209:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _constants = _dereq_('./constants');

var _constants2 = _interopRequireDefault(_constants);

// web workers don't have access to GL context, so import all GL constants

var _vertex_data = _dereq_('./vertex_data');

var _vertex_data2 = _interopRequireDefault(_vertex_data);

// Describes a vertex layout that can be used with many different GL programs.

var VertexLayout = (function () {
    // Attribs are an array, in layout order, of: name, size, type, normalized
    // ex: { name: 'position', size: 3, type: gl.FLOAT, normalized: false }

    function VertexLayout(attribs) {
        _classCallCheck(this, VertexLayout);

        this.attribs = attribs; // dictionary of attributes, specified as standard GL attrib options
        this.components = []; // list of type and offset info about each attribute component
        this.index = {}; // linear buffer index of each attribute component, e.g. this.index.position.x

        // Calc vertex stride
        this.stride = 0;

        var count = 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = _getIterator(this.attribs), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var attrib = _step.value;

                attrib.offset = this.stride;
                attrib.byte_size = attrib.size;
                var shift = 0;

                switch (attrib.type) {
                    case _constants2['default'].FLOAT:
                    case _constants2['default'].INT:
                    case _constants2['default'].UNSIGNED_INT:
                        attrib.byte_size *= 4;
                        shift = 2;
                        break;
                    case _constants2['default'].SHORT:
                    case _constants2['default'].UNSIGNED_SHORT:
                        attrib.byte_size *= 2;
                        shift = 1;
                        break;
                }

                // Force 4-byte alignment on attributes
                this.stride += attrib.byte_size;
                if (this.stride & 3) {
                    // pad to multiple of 4 bytes
                    this.stride += 4 - (this.stride & 3);
                }

                // Add info to list of attribute components
                // Used to build the vertex data, provides pointers and offsets into each typed array view
                // Each component is an array of:
                // [GL attrib type, pointer to typed array view, bits to shift right to determine buffer offset, additional buffer offset for the component]
                var offset_typed = attrib.offset >> shift;
                if (attrib.size > 1) {
                    for (var a = 0; a < attrib.size; a++) {
                        this.components.push([attrib.type, null, shift, offset_typed++]);
                    }
                } else {
                    this.components.push([attrib.type, null, shift, offset_typed]);
                }

                // Provide an index into the vertex data buffer for each attribute component
                this.index[attrib.name] = count;
                count += attrib.size;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                    _iterator['return']();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }

    // Track currently enabled attribs, by the program they are bound to
    // Static class property to reflect global GL state

    // Setup a vertex layout for a specific GL program
    // Assumes that the desired vertex buffer (VBO) is already bound
    // If a given program doesn't include all attributes, it can still use the vertex layout
    // to read those attribs that it does recognize, using the attrib offsets to skip others.

    _createClass(VertexLayout, [{
        key: 'enable',
        value: function enable(gl, program, force) {
            var attrib, location;

            // Enable all attributes for this layout
            for (var a = 0; a < this.attribs.length; a++) {
                attrib = this.attribs[a];
                location = program.attribute(attrib.name).location;

                if (location !== -1) {
                    if (!VertexLayout.enabled_attribs[location] || force) {
                        gl.enableVertexAttribArray(location);
                    }
                    gl.vertexAttribPointer(location, attrib.size, attrib.type, attrib.normalized, this.stride, attrib.offset);
                    VertexLayout.enabled_attribs[location] = program;
                }
            }

            // Disable any previously bound attributes that aren't for this layout
            for (location in VertexLayout.enabled_attribs) {
                this.disableUnusedAttribute(gl, location, program);
            }
        }

        // Disable an attribute if it was not enabled for the specified program
        // NOTE: this was moved out of the inner loop in enable() to assist w/VM optimization
    }, {
        key: 'disableUnusedAttribute',
        value: function disableUnusedAttribute(gl, location, program) {
            if (VertexLayout.enabled_attribs[location] !== program) {
                gl.disableVertexAttribArray(location);
                delete VertexLayout.enabled_attribs[location];
            }
        }
    }, {
        key: 'createVertexData',
        value: function createVertexData() {
            return new _vertex_data2['default'](this);
        }
    }]);

    return VertexLayout;
})();

exports['default'] = VertexLayout;
VertexLayout.enabled_attribs = {};
module.exports = exports['default'];

},{"./constants":198,"./vertex_data":208,"babel-runtime/core-js/get-iterator":2,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/interop-require-default":23}],210:[function(_dereq_,module,exports){
'use strict';

var _Set = _dereq_('babel-runtime/core-js/set')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _repeat_group = _dereq_('./repeat_group');

var _repeat_group2 = _interopRequireDefault(_repeat_group);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var Collision;

exports['default'] = Collision = {

    tiles: {},

    startTile: function startTile(tile) {
        var state = this.tiles[tile] = {
            bboxes: { // current set of placed bounding boxes
                aabb: [],
                obb: []
            },
            objects: {}, // objects to collide, grouped by priority, then by style
            keep: {}, // objects that were kept after collision, grouped by style
            styles: new _Set() // styles contributing collision objects
        };

        // Promise resolved when all registered styles have added objects
        state.complete = new _Promise(function (resolve, reject) {
            state.resolve = resolve;
            state.reject = reject;
        });
    },

    resetTile: function resetTile(tile) {
        delete this.tiles[tile];
    },

    // Add a style to the pending set, collision will block on all styles submitting to collision set
    addStyle: function addStyle(style, tile) {
        this.tiles[tile].styles.add(style);
    },

    // Add collision objects for a style
    collide: function collide(objects, style, tile) {
        var state = this.tiles[tile];
        if (!state) {
            _loglevel2['default'].trace('Collision.collide() called with null tile', tile, this.tiles, style, objects);
            return _Promise.reject(Error('Collision.collide() called with null tile', tile, this.tiles, style, objects));
        }

        // Group by priority and style
        var tile_objects = state.objects;
        for (var i = 0; i < objects.length; i++) {
            var obj = objects[i];
            var priority = obj.layout.priority;
            tile_objects[priority] = tile_objects[priority] || {};
            tile_objects[priority][style] = tile_objects[priority][style] || [];
            tile_objects[priority][style].push(obj);
        }

        // Remove from pending style set, if no more styles, do collision & finish tile
        state.styles['delete'](style);
        if (state.styles.size === 0) {
            this.endTile(tile);
        }

        // Wait for objects to be added from all styles
        return state.complete.then(function () {
            return state.keep[style] || [];
        });
    },

    // Test labels for collisions, higher to lower priority
    // When two collide, discard the lower-priority label
    endTile: function endTile(tile) {
        var state = this.tiles[tile];
        var bboxes = state.bboxes;
        var keep = state.keep;

        _repeat_group2['default'].clear(tile);

        // Process labels by priority, then by style
        var priorities = _Object$keys(state.objects).sort(function (a, b) {
            return a - b;
        });
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = _getIterator(priorities), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var priority = _step.value;

                var style_objects = state.objects[priority];
                if (!style_objects) {
                    // no labels at this priority, skip to next
                    continue;
                }

                // For each style
                for (var style in style_objects) {
                    var objects = style_objects[style];
                    keep[style] = keep[style] || [];

                    for (var i = 0; i < objects.length; i++) {
                        var _objects$i = objects[i];
                        var label = _objects$i.label;
                        var layout = _objects$i.layout;
                        // TODO: `label` should be generic

                        // test the label for intersections with other labels in the tile
                        if (!layout.collide || !label.discard(bboxes)) {
                            // check for repeats
                            var check = _repeat_group2['default'].check(label, layout, tile);
                            if (check) {
                                // log.trace(`discard label '${label.text}', (one_per_group: ${check.one_per_group}), dist ${Math.sqrt(check.dist_sq)/layout.units_per_pixel} < ${Math.sqrt(check.repeat_dist_sq)/layout.units_per_pixel}`);
                                continue;
                            }
                            // register as placed for future repeat culling
                            _repeat_group2['default'].add(label, layout, tile);

                            label.add(bboxes); // add label to currently visible set
                            keep[style].push(objects[i]);
                        }
                        // else if (layout.collide) {
                        //     log.trace(`discard label '${label.text}' due to collision`);
                        // }
                    }
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                    _iterator['return']();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        delete this.tiles[tile];
        state.resolve();
    }

};
module.exports = exports['default'];

},{"./repeat_group":214,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/keys":12,"babel-runtime/core-js/promise":14,"babel-runtime/core-js/set":15,"babel-runtime/helpers/interop-require-default":23,"loglevel":183}],211:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _boxIntersect = _dereq_('box-intersect');

var _boxIntersect2 = _interopRequireDefault(_boxIntersect);

// https://github.com/mikolalysenko/box-intersect

var _utilsUtils = _dereq_('../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _utilsObb = _dereq_('../utils/obb');

var _utilsObb2 = _interopRequireDefault(_utilsObb);

// import log from 'loglevel';

var Label = (function () {
    function Label(size) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        _classCallCheck(this, Label);

        this.size = size;
        this.options = options;
        this.position = null;
        this.aabb = null;
        this.obb = null;
    }

    // check for overlaps with other labels in the tile

    _createClass(Label, [{
        key: 'occluded',
        value: function occluded(bboxes) {
            var _this = this;

            var intersect = false;
            var aabbs = bboxes.aabb;
            var obbs = bboxes.obb;

            // Broad phase
            if (aabbs.length > 0) {
                (0, _boxIntersect2['default'])([this.aabb], aabbs, function (i, j) {
                    // log.trace('collision: broad phase collide', this.options.id, this, this.aabb, aabbs[j]);

                    // Skip narrow phase collision if no rotation
                    if (_this.obb.angle === 0 && obbs[j].angle === 0) {
                        // log.trace('collision: skip narrow phase collide because neither is rotated', this.options.id, this, this.obb, obbs[j]);
                        intersect = true;
                        return true;
                    }

                    // Narrow phase
                    if (_utilsObb2['default'].intersect(_this.obb, obbs[j])) {
                        // log.trace('collision: narrow phase collide', this.options.id, this, this.obb, obbs[j]);
                        intersect = true;
                        return true;
                    }
                });
            }
            return intersect;
        }

        // Add this label's bounding box to the provided set
    }, {
        key: 'add',
        value: function add(bboxes) {
            bboxes.aabb.push(this.aabb);
            bboxes.obb.push(this.obb);
        }

        // checks whether the label is within the tile boundaries
    }, {
        key: 'inTileBounds',
        value: function inTileBounds() {
            var min = [this.aabb[0], this.aabb[1]];
            var max = [this.aabb[2], this.aabb[3]];

            if (!_utilsUtils2['default'].pointInTile(min) || !_utilsUtils2['default'].pointInTile(max)) {
                return false;
            }

            return true;
        }

        // Whether the label should be discarded
        // Depends on whether label must fit in the tile bounds, and if so, can it be moved to fit there
    }, {
        key: 'discard',
        value: function discard(bboxes) {
            // Should the label be culled if it can't fit inside the tile bounds?
            if (this.options.cull_from_tile) {
                var in_tile = this.inTileBounds();

                // If it doesn't fit, should we try to move it into the tile bounds?
                if (!in_tile && this.options.move_into_tile) {
                    // Can we fit the label into the tile?
                    if (!this.moveIntoTile()) {
                        return true; // can't fit in tile, discard
                    }
                } else if (!in_tile) {
                        return true; // out of tile bounds, discard
                    }
            }

            // If the label hasn't been discarded yet, check to see if it's occluded by other labels
            return this.occluded(bboxes);
        }
    }]);

    return Label;
})();

exports['default'] = Label;

Label.epsilon = 0.9999; // tolerance around collision boxes, prevent perfectly adjacent objects from colliding
module.exports = exports['default'];

},{"../utils/obb":245,"../utils/utils":247,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/interop-require-default":23,"box-intersect":30}],212:[function(_dereq_,module,exports){
'use strict';

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _vector = _dereq_('../vector');

var _vector2 = _interopRequireDefault(_vector);

var _label = _dereq_('./label');

var _label2 = _interopRequireDefault(_label);

var _utilsObb = _dereq_('../utils/obb');

var _utilsObb2 = _interopRequireDefault(_utilsObb);

var LabelLine = (function (_Label) {
    _inherits(LabelLine, _Label);

    function LabelLine(size, lines, options) {
        _classCallCheck(this, LabelLine);

        _get(Object.getPrototypeOf(LabelLine.prototype), 'constructor', this).call(this, size, options);

        this.segment_index = 0;
        this.lines = lines;
        this.update();
    }

    _createClass(LabelLine, [{
        key: 'update',
        value: function update() {
            var segment = this.currentSegment();
            this.angle = this.computeAngle();
            this.position = [(segment[0][0] + segment[1][0]) / 2, (segment[0][1] + segment[1][1]) / 2];
            this.updateBBoxes();
        }
    }, {
        key: 'moveNextSegment',
        value: function moveNextSegment() {
            if (this.segment_index + 1 >= this.lines.length - 1) {
                return false;
            }

            this.segment_index++;
            this.update();

            return true;
        }
    }, {
        key: 'computeAngle',
        value: function computeAngle() {
            var segment = this.currentSegment();
            var p0p1 = _vector2['default'].sub(segment[0], segment[1]);

            p0p1 = _vector2['default'].normalize(p0p1);

            var PI_2 = Math.PI / 2;
            var theta = Math.atan2(p0p1[0], p0p1[1]) + PI_2;

            if (theta > PI_2 || theta < -PI_2) {
                theta += Math.PI;
            }
            theta %= Math.PI * 2;

            return theta;
        }
    }, {
        key: 'fitToSegment',
        value: function fitToSegment() {
            var segment = this.currentSegment();
            var p0p1 = _vector2['default'].sub(segment[0], segment[1]);
            var length = _vector2['default'].length(p0p1);

            var label_length = this.size[0] * this.options.units_per_pixel;

            if (label_length > length) {
                // an exceed heurestic of 100% would let the label fit in any cases
                var exceed = (1 - length / label_length) * 100;
                return exceed < this.options.line_exceed;
            }

            return label_length <= length;
        }
    }, {
        key: 'currentSegment',
        value: function currentSegment() {
            var p1 = this.lines[this.segment_index];
            var p2 = this.lines[this.segment_index + 1];

            return [p1, p2];
        }
    }, {
        key: 'updateBBoxes',
        value: function updateBBoxes() {
            var upp = this.options.units_per_pixel;
            var width = (this.size[0] + this.options.buffer[0] * 2) * upp * _label2['default'].epsilon;
            var height = (this.size[1] + this.options.buffer[1] * 2) * upp * _label2['default'].epsilon;

            // apply offset, x positive, y pointing down
            var offset = _vector2['default'].rot(this.options.offset, this.angle);
            var p = [this.position[0] + offset[0] * upp, this.position[1] - offset[1] * upp];

            // the angle of the obb is negative since it's the tile system y axis is pointing down
            this.obb = new _utilsObb2['default'](p[0], p[1], -this.angle, width, height);
            this.aabb = this.obb.getExtent();
        }

        // Try to move the label into the tile bounds
        // Returns true if label was moved into tile, false if it couldn't be moved
    }, {
        key: 'moveIntoTile',
        value: function moveIntoTile() {
            var in_tile = false;
            var fits_to_segment = this.fitToSegment();

            // Try line segments until we find one that fits the label (and is inside the tile)
            while (!in_tile || !fits_to_segment) {
                if (!this.moveNextSegment()) {
                    break; // we can't move further in this line
                }

                in_tile = this.inTileBounds();
                fits_to_segment = this.fitToSegment();
            }

            return in_tile && fits_to_segment;
        }
    }, {
        key: 'discard',
        value: function discard(bboxes) {
            // First find a line segment that fits the label
            if (this.lines && !this.fitToSegment()) {
                while (!this.fitToSegment()) {
                    if (!this.moveNextSegment()) {
                        return true;
                    }
                }
            }

            // If label fits in line, run standard discard tests
            return _get(Object.getPrototypeOf(LabelLine.prototype), 'discard', this).call(this, bboxes);
        }
    }]);

    return LabelLine;
})(_label2['default']);

exports['default'] = LabelLine;
module.exports = exports['default'];

},{"../utils/obb":245,"../vector":250,"./label":211,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/get":21,"babel-runtime/helpers/inherits":22,"babel-runtime/helpers/interop-require-default":23}],213:[function(_dereq_,module,exports){
'use strict';

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _label = _dereq_('./label');

var _label2 = _interopRequireDefault(_label);

var _geo = _dereq_('../geo');

var _geo2 = _interopRequireDefault(_geo);

var _utilsObb = _dereq_('../utils/obb');

var _utilsObb2 = _interopRequireDefault(_utilsObb);

var _stylesPointsPoint_anchor = _dereq_('../styles/points/point_anchor');

var _stylesPointsPoint_anchor2 = _interopRequireDefault(_stylesPointsPoint_anchor);

var LabelPoint = (function (_Label) {
    _inherits(LabelPoint, _Label);

    function LabelPoint(position, size, options) {
        _classCallCheck(this, LabelPoint);

        _get(Object.getPrototypeOf(LabelPoint.prototype), 'constructor', this).call(this, size, options);
        this.position = [position[0], position[1]];
        this.update();
    }

    _createClass(LabelPoint, [{
        key: 'update',
        value: function update() {
            this.options.offset = this.computeOffset();
            this.updateBBoxes();
        }
    }, {
        key: 'computeOffset',
        value: function computeOffset() {
            return _stylesPointsPoint_anchor2['default'].computeOffset(this.options.offset, this.size, this.options.anchor);
        }
    }, {
        key: 'updateBBoxes',
        value: function updateBBoxes() {
            var width = (this.size[0] + this.options.buffer[0] * 2) * this.options.units_per_pixel * _label2['default'].epsilon;
            var height = (this.size[1] + this.options.buffer[1] * 2) * this.options.units_per_pixel * _label2['default'].epsilon;

            var p = [this.position[0] + this.options.offset[0] * this.options.units_per_pixel, this.position[1] - this.options.offset[1] * this.options.units_per_pixel];

            this.obb = new _utilsObb2['default'](p[0], p[1], 0, width, height);
            this.aabb = this.obb.getExtent();
        }

        // Try to move the label into the tile bounds
        // Returns true if label was moved into tile, false if it couldn't be moved
    }, {
        key: 'moveIntoTile',
        value: function moveIntoTile() {
            var updated = false;

            if (this.aabb[0] < 0) {
                this.position[0] += -this.aabb[0];
                updated = true;
            }

            if (this.aabb[2] >= _geo2['default'].tile_scale) {
                this.position[0] -= this.aabb[2] - _geo2['default'].tile_scale + 1;
                updated = true;
            }

            if (this.aabb[3] > 0) {
                this.position[1] -= this.aabb[3];
                updated = true;
            }

            if (this.aabb[1] <= -_geo2['default'].tile_scale) {
                this.position[1] -= this.aabb[1] + _geo2['default'].tile_scale - 1;
                updated = true;
            }

            if (updated) {
                this.updateBBoxes();
            }

            return this.inTileBounds();
        }
    }]);

    return LabelPoint;
})(_label2['default']);

exports['default'] = LabelPoint;
module.exports = exports['default'];

},{"../geo":197,"../styles/points/point_anchor":229,"../utils/obb":245,"./label":211,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/get":21,"babel-runtime/helpers/inherits":22,"babel-runtime/helpers/interop-require-default":23}],214:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _geo = _dereq_('../geo');

var _geo2 = _interopRequireDefault(_geo);

var RepeatGroup = (function () {
    function RepeatGroup(key, repeat_dist, max_repeat_dist) {
        _classCallCheck(this, RepeatGroup);

        this.key = key;
        this.repeat_dist = repeat_dist;
        this.repeat_dist_sq = this.repeat_dist * this.repeat_dist;
        this.max_repeat_dist_sq = max_repeat_dist * max_repeat_dist;
        this.one_per_group = this.repeat_dist_sq >= this.max_repeat_dist_sq ? true : false;
        this.positions = [];
    }

    // Current set of repeat groups, grouped and keyed by tile

    // Check an object to see if it's a repeat in this group

    _createClass(RepeatGroup, [{
        key: 'check',
        value: function check(obj) {
            // If only one object allowed per group, shortcut distance logic
            if (this.one_per_group) {
                if (this.positions.length > 0) {
                    // reported distance maxes out at threshold in this case
                    // (not true dist value since we skipped calculating it)
                    return {
                        dist_sq: this.max_repeat_dist_sq,
                        repeat_dist_sq: this.repeat_dist_sq,
                        one_per_group: this.one_per_group
                    };
                }
                return; // no object for this group yet
            }

            // Check distance from new object to objects already in group
            var p1 = obj.position;
            for (var i = 0; i < this.positions.length; i++) {
                var p2 = this.positions[i];
                var dx = p1[0] - p2[0];
                var dy = p1[1] - p2[1];
                var dist_sq = dx * dx + dy * dy;

                // Found an existing object within allowed distance
                if (dist_sq < this.repeat_dist_sq) {
                    return {
                        dist_sq: dist_sq,
                        repeat_dist_sq: this.repeat_dist_sq
                    };
                }
            }
        }

        // Add object to this group
    }, {
        key: 'add',
        value: function add(obj) {
            // only store object's position, to save space / prevent unnecessary references
            if (obj && obj.position) {
                this.positions.push(obj.position);
            }
        }

        // Static methods are used to manage repeat groups, within and across tiles

        // Reset all groups for this tile
    }], [{
        key: 'clear',
        value: function clear(tile) {
            this.groups[tile] = {};
        }

        // Check an object to see if it's a repeat within its designated group
    }, {
        key: 'check',
        value: function check(obj, layout, tile) {
            if (layout.repeat_distance && this.groups[tile][layout.repeat_group]) {
                return this.groups[tile][layout.repeat_group].check(obj);
            }
        }

        // Add an object to its designated group
    }, {
        key: 'add',
        value: function add(obj, layout, tile) {
            if (layout.repeat_distance) {
                if (this.groups[tile][layout.repeat_group] == null) {
                    this.groups[tile][layout.repeat_group] = new RepeatGroup(layout.repeat_group, layout.repeat_distance, RepeatGroup.max_repeat_dist);
                }
                this.groups[tile][layout.repeat_group].add(obj);
            }
        }
    }]);

    return RepeatGroup;
})();

exports['default'] = RepeatGroup;
RepeatGroup.groups = {};

// Max repeat dist: for groups with a repeat dist beyond this threshold, only one label
// will be allowed per group, e.g. set to tile size for one-label-per-tile
RepeatGroup.max_repeat_dist = _geo2['default'].tile_scale;
module.exports = exports['default'];

},{"../geo":197,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/interop-require-default":23}],215:[function(_dereq_,module,exports){
'use strict';

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.leafletLayer = leafletLayer;

var _utilsUtils = _dereq_('./utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _scene = _dereq_('./scene');

var _scene2 = _interopRequireDefault(_scene);

var _geo = _dereq_('./geo');

var _geo2 = _interopRequireDefault(_geo);

// Exports must appear outside a function, but will only be defined in main thread (below)
var LeafletLayer;
exports.LeafletLayer = LeafletLayer;

function leafletLayer(options) {
    return extendLeaflet(options);
}

function extendLeaflet(options) {

    // If LeafletLayer is already defined when this is called just return that immediately
    // e.g. if you call leafletLayer multiple times (which is valid)
    if (typeof LeafletLayer !== 'undefined') {
        return new LeafletLayer(options);
    }

    // Leaflet layer functionality is only defined in main thread
    if (_utilsUtils2['default'].isMainThread) {
        var _ret = (function () {

            var L = options.leaflet || window.L;

            // Determine if we are extending the leaflet 0.7.x TileLayer class, or the newer
            // leaflet 1.x GridLayer class.
            var layerBaseClass = L.GridLayer ? L.GridLayer : L.TileLayer;
            var leafletVersion = layerBaseClass === L.GridLayer ? '1.x' : '0.7.x';
            var layerClassConfig = {};

            // If extending leaflet 0.7.x TileLayer, make add/remove tile no ops
            if (layerBaseClass === L.TileLayer) {
                layerClassConfig._addTile = function () {};
                layerClassConfig._removeTile = function () {};
            }

            // Define custom layer methods
            _Object$assign(layerClassConfig, {

                initialize: function initialize(options) {
                    var _this = this;

                    // Defaults
                    options.showDebug = !options.showDebug ? false : true;
                    options.wheelDebounceTime = options.wheelDebounceTime || 40;

                    L.setOptions(this, options);
                    this.createScene();
                    this.hooks = {};
                    this._updating_tangram = false;

                    // Force leaflet zoom animations off
                    this._zoomAnimated = false;

                    this.debounceViewReset = _utilsUtils2['default'].debounce(function () {
                        _this._map.fire('zoomend');
                        _this._map.fire('moveend');
                    }, this.options.wheelDebounceTime);
                },

                createScene: function createScene() {
                    this.scene = _scene2['default'].create(this.options.scene, {
                        numWorkers: this.options.numWorkers,
                        preUpdate: this.options.preUpdate,
                        postUpdate: this.options.postUpdate,
                        continuousZoom: LeafletLayer.leafletVersion === '1.x',
                        highDensityDisplay: this.options.highDensityDisplay,
                        logLevel: this.options.logLevel,
                        // advanced option, app will have to manually called scene.update() per frame
                        disableRenderLoop: this.options.disableRenderLoop,
                        // advanced option, will require library to be served as same host as page
                        allowCrossDomainWorkers: this.options.allowCrossDomainWorkers
                    });
                },

                // Finish initializing scene and setup events when layer is added to map
                onAdd: function onAdd(map) {
                    var _this2 = this;

                    if (!this.scene) {
                        this.createScene();
                    }

                    layerBaseClass.prototype.onAdd.apply(this, arguments);

                    this.hooks.resize = function () {
                        _this2._updating_tangram = true;
                        _this2.updateSize();
                        _this2._updating_tangram = false;
                    };
                    map.on('resize', this.hooks.resize);

                    this.hooks.move = function () {
                        if (_this2._updating_tangram) {
                            return;
                        }

                        _this2._updating_tangram = true;
                        var view = map.getCenter();
                        view.zoom = Math.min(map.getZoom(), map.getMaxZoom() || _geo2['default'].default_view_max_zoom);

                        _this2.scene.view.setView(view);
                        _this2.scene.immediateRedraw();
                        _this2.reverseTransform();
                        _this2._updating_tangram = false;
                    };
                    map.on('move', this.hooks.move);

                    this.hooks.zoomstart = function () {
                        if (_this2._updating_tangram) {
                            return;
                        }

                        _this2._updating_tangram = true;
                        _this2.scene.view.startZoom();
                        _this2._updating_tangram = false;
                    };
                    map.on('zoomstart', this.hooks.zoomstart);

                    this.hooks.dragstart = function () {
                        _this2.scene.view.panning = true;
                    };
                    map.on('dragstart', this.hooks.dragstart);

                    this.hooks.dragend = function () {
                        _this2.scene.view.panning = false;
                    };
                    map.on('dragend', this.hooks.dragend);

                    // Force leaflet zoom animations off
                    map._zoomAnimated = false;

                    // Modify default leaflet scroll wheel behavior
                    this.modifyScrollWheelBehavior(map);

                    // Add GL canvas to layer container
                    this.scene.container = this.getContainer();

                    // Initial view
                    this.updateView();

                    // Subscribe to tangram events
                    this.scene.subscribe({
                        move: this.onTangramViewUpdate.bind(this)
                    });

                    // Use leaflet's existing event system as the callback mechanism
                    this.scene.load().then(function () {
                        _this2._updating_tangram = true;

                        _this2.updateSize();
                        _this2.updateView();
                        _this2.reverseTransform();

                        _this2._updating_tangram = false;

                        _this2.fire('init');
                    })['catch'](function (error) {
                        _this2.fire('error', error);
                    });
                },

                onRemove: function onRemove(map) {
                    layerBaseClass.prototype.onRemove.apply(this, arguments);

                    map.off('resize', this.hooks.resize);
                    map.off('move', this.hooks.move);
                    map.off('zoomstart', this.hooks.zoomstart);
                    map.off('dragstart', this.hooks.dragstart);
                    map.off('dragend', this.hooks.dragend);
                    this.hooks = {};

                    if (this.scene) {
                        this.scene.destroy();
                        this.scene = null;
                    }
                },

                createTile: function createTile(coords) {
                    var key = coords.x + '/' + coords.y + '/' + coords.z;
                    var div = document.createElement('div');
                    div.setAttribute('data-tile-key', key);
                    div.style.width = '256px';
                    div.style.height = '256px';

                    if (this.options.showDebug) {
                        var debug_overlay = document.createElement('div');
                        debug_overlay.textContent = key;
                        debug_overlay.style.position = 'absolute';
                        debug_overlay.style.left = 0;
                        debug_overlay.style.top = 0;
                        debug_overlay.style.color = 'white';
                        debug_overlay.style.fontSize = '16px';
                        debug_overlay.style.textOutline = '1px #000000';
                        debug_overlay.style.padding = '8px';

                        div.appendChild(debug_overlay);
                        div.style.borderStyle = 'solid';
                        div.style.borderColor = 'white';
                        div.style.borderWidth = '1px';
                    }

                    return div;
                },

                // Modify leaflet's default scroll wheel behavior to have a much more sensitve/continuous zoom
                // Note: this should be deprecated once leaflet continuous zoom is more widely used and the
                // default behavior is presumably improved
                modifyScrollWheelBehavior: function modifyScrollWheelBehavior(map) {
                    var _this3 = this;

                    if (this.scene.view.continuous_zoom && map.scrollWheelZoom && this.options.modifyScrollWheel !== false) {
                        (function () {
                            var layer = _this3;
                            var enabled = map.scrollWheelZoom.enabled();
                            if (enabled) {
                                map.scrollWheelZoom.disable(); // disable before modifying
                            }

                            // modify prototype and current instance, so add/remove hooks work on existing references
                            L.Map.ScrollWheelZoom._onWheelScroll = map.scrollWheelZoom._onWheelScroll = function (e) {
                                // modify to skip debounce, as it seems to cause animation-sync issues in Chrome
                                // with Tangram continuous rendering
                                this._delta += L.DomEvent.getWheelDelta(e);
                                this._lastMousePos = this._map.mouseEventToContainerPoint(e);
                                this._performZoom();
                                L.DomEvent.stop(e);
                            };

                            L.Map.ScrollWheelZoom._performZoom = map.scrollWheelZoom._performZoom = function () {
                                var map = this._map,
                                    delta = this._delta,
                                    zoom = map.getZoom();

                                map.stop(); // stop panning and fly animations if any

                                // NOTE: this is the only real modification to default leaflet behavior
                                delta /= 40;

                                delta = Math.max(Math.min(delta, 4), -4);
                                delta = map._limitZoom(zoom + delta) - zoom;

                                this._delta = 0;
                                this._startTime = null;

                                if (!delta) {
                                    return;
                                }

                                if (map.options.scrollWheelZoom === 'center') {
                                    map.setZoom(zoom + delta);
                                } else {
                                    map.setZoomAround(this._lastMousePos, zoom + delta);
                                }

                                layer.debounceViewReset();
                            };

                            if (enabled) {
                                map.scrollWheelZoom.enable(); // re-enable after modifying
                            }
                        })();
                    }
                },

                updateView: function updateView() {
                    var view = this._map.getCenter();
                    view.zoom = Math.min(this._map.getZoom(), this._map.getMaxZoom() || _geo2['default'].default_view_max_zoom);
                    this.scene.view.setView(view);
                },

                updateSize: function updateSize() {
                    var size = this._map.getSize();
                    this.scene.resizeMap(size.x, size.y);
                },

                onTangramViewUpdate: function onTangramViewUpdate() {
                    if (!this._map || this._updating_tangram) {
                        return;
                    }
                    this._updating_tangram = true;
                    this._map.setView([this.scene.view.center.lat, this.scene.view.center.lng], this.scene.view.zoom, { animate: false });
                    this.reverseTransform();
                    this._updating_tangram = false;
                },

                render: function render() {
                    if (!this.scene) {
                        return;
                    }
                    this.scene.update();
                },

                // Reverse the CSS positioning Leaflet applies to the layer, since Tangram's WebGL canvas
                // is expected to be 'absolutely' positioned.
                reverseTransform: function reverseTransform() {
                    if (!this._map || !this.scene || !this.scene.container) {
                        return;
                    }

                    var top_left = this._map.containerPointToLayerPoint([0, 0]);
                    L.DomUtil.setPosition(this.scene.container, top_left);
                }

            });

            // Create the layer class
            exports.LeafletLayer = LeafletLayer = layerBaseClass.extend(layerClassConfig);

            // Polyfill some 1.0 methods
            if (typeof LeafletLayer.remove !== 'function') {
                LeafletLayer.prototype.remove = function () {
                    if (this._map) {
                        this._map.removeLayer(this);
                    }
                    this.fire('remove');
                };
            }

            LeafletLayer.layerBaseClass = layerBaseClass;
            LeafletLayer.leafletVersion = leafletVersion;

            return {
                v: new LeafletLayer(options)
            };
        })();

        if (typeof _ret === 'object') return _ret.v;
    }
}

},{"./geo":197,"./scene":219,"./utils/utils":247,"babel-runtime/core-js/object/assign":6,"babel-runtime/helpers/interop-require-default":23}],216:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _glShader_program = _dereq_('./gl/shader_program');

var _glShader_program2 = _interopRequireDefault(_glShader_program);

var _glShader_sources = _dereq_('./gl/shader_sources');

var _glShader_sources2 = _interopRequireDefault(_glShader_sources);

// built-in shaders

var _glGlsl = _dereq_('./gl/glsl');

var _glGlsl2 = _interopRequireDefault(_glGlsl);

var _geo = _dereq_('./geo');

var _geo2 = _interopRequireDefault(_geo);

var _stylesStyle_parser = _dereq_('./styles/style_parser');

// Abstract light

var Light = (function () {
    function Light(view, config) {
        _classCallCheck(this, Light);

        this.name = config.name;
        this.view = view;

        if (config.ambient == null || typeof config.ambient === 'number') {
            this.ambient = _glGlsl2['default'].expandVec4(config.ambient || 0);
        } else {
            this.ambient = _stylesStyle_parser.StyleParser.parseColor(config.ambient);
        }

        if (config.diffuse == null || typeof config.diffuse === 'number') {
            this.diffuse = _glGlsl2['default'].expandVec4(config.diffuse != null ? config.diffuse : 1);
        } else {
            this.diffuse = _stylesStyle_parser.StyleParser.parseColor(config.diffuse);
        }

        if (config.specular == null || typeof config.specular === 'number') {
            this.specular = _glGlsl2['default'].expandVec4(config.specular || 0);
        } else {
            this.specular = _stylesStyle_parser.StyleParser.parseColor(config.specular);
        }
    }

    // Create a light by type name, factory-style
    // 'config' must include 'name' and 'type', along with any other type-specific properties

    _createClass(Light, [{
        key: 'inject',

        // Common instance definition
        value: function inject() {
            var instance = '\n            uniform ' + this.struct_name + ' u_' + this.name + ';\n            ' + this.struct_name + ' ' + this.name + ';\n            ';
            var assign = '\n            ' + this.name + ' = u_' + this.name + ';\n\n        ';

            _glShader_program2['default'].addBlock(Light.block, instance);
            _glShader_program2['default'].addBlock('setup', assign);
        }

        // Update method called once per frame
    }, {
        key: 'update',
        value: function update() {}

        // Called once per frame per program (e.g. for main render pass, then for each additional
        // pass for feature selection, etc.)
    }, {
        key: 'setupProgram',
        value: function setupProgram(_program) {
            //  Three common light properties
            _program.uniform('4fv', 'u_' + this.name + '.ambient', this.ambient);
            _program.uniform('4fv', 'u_' + this.name + '.diffuse', this.diffuse);
            _program.uniform('4fv', 'u_' + this.name + '.specular', this.specular);
        }
    }], [{
        key: 'create',
        value: function create(view, config) {
            if (Light.types[config.type]) {
                return new Light.types[config.type](view, config);
            }
        }

        // Set light for a style: fragment lighting, vertex lighting, or none
    }, {
        key: 'setMode',
        value: function setMode(mode, style) {
            if (mode === true) {
                mode = 'fragment';
            }
            mode = Light.enabled && (mode != null ? mode : 'fragment'); // default to fragment lighting
            style.defines['TANGRAM_LIGHTING_FRAGMENT'] = mode === 'fragment';
            style.defines['TANGRAM_LIGHTING_VERTEX'] = mode === 'vertex';
        }

        // Inject all provided light definitions, and calculate cumulative light function
    }, {
        key: 'inject',
        value: function inject(lights) {
            // Clear previous injections
            _glShader_program2['default'].removeBlock(Light.block);

            // If lighting is globally disabled, nothing is injected (mostly for debugging or live editing)
            if (!Light.enabled) {
                return;
            }

            // Construct code to calculate each light instance
            var calculateLights = "";
            if (lights && _Object$keys(lights).length > 0) {
                // Collect uniques types of lights
                var types = {};
                for (var light_name in lights) {
                    types[lights[light_name].type] = true;
                }

                // Inject each type of light
                for (var type in types) {
                    Light.types[type].inject();
                }

                // Inject per-instance blocks and construct the list of functions to calculate each light
                for (var light_name in lights) {
                    // Define instance
                    lights[light_name].inject();

                    // Add the calculation function to the list
                    calculateLights += 'calculateLight(' + light_name + ', _eyeToPoint, _normal);\n';
                }
            } else {
                // If no light is defined, use 100% omnidirectional diffuse light
                calculateLights = '\n                #ifdef TANGRAM_MATERIAL_DIFFUSE\n                    light_accumulator_diffuse = vec4(1.);\n                #endif\n            ';
            }

            // Glue together the final lighting function that sums all the lights
            var calculateFunction = '\n            vec4 calculateLighting(in vec3 _eyeToPoint, in vec3 _normal, in vec4 _color) {\n\n                // Do initial material calculations over normal, emission, ambient, diffuse and specular values\n                calculateMaterial(_eyeToPoint,_normal);\n\n                // Un roll the loop of individual ligths to calculate\n                ' + calculateLights + '\n\n                //  Final light intensity calculation\n                vec4 color = vec4(0.0);\n\n                #ifdef TANGRAM_MATERIAL_EMISSION\n                    color = material.emission;\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_AMBIENT\n                    color += light_accumulator_ambient * _color * material.ambient;\n                #else\n                    #ifdef TANGRAM_MATERIAL_DIFFUSE\n                        color += light_accumulator_ambient * _color * material.diffuse;\n                    #endif\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_DIFFUSE\n                    color += light_accumulator_diffuse * _color * material.diffuse;\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_SPECULAR\n                    color += light_accumulator_specular * material.specular;\n                #endif\n\n                // Clamp final color\n                color = clamp(color, 0.0, 1.0);\n\n                return color;\n            }';

            _glShader_program2['default'].addBlock(Light.block, calculateFunction);
        }
    }]);

    return Light;
})();

exports['default'] = Light;

Light.types = {}; // references to subclasses by short name
Light.block = 'lighting'; // shader block name
Light.enabled = true; // lighting can be globally enabled/disabled

// Light subclasses

var AmbientLight = (function (_Light) {
    _inherits(AmbientLight, _Light);

    function AmbientLight(view, config) {
        _classCallCheck(this, AmbientLight);

        _get(Object.getPrototypeOf(AmbientLight.prototype), 'constructor', this).call(this, view, config);
        this.type = 'ambient';
        this.struct_name = 'AmbientLight';
    }

    // Inject struct and calculate function

    _createClass(AmbientLight, [{
        key: 'setupProgram',
        value: function setupProgram(_program) {
            _program.uniform('4fv', 'u_' + this.name + '.ambient', this.ambient);
        }
    }], [{
        key: 'inject',
        value: function inject() {
            _glShader_program2['default'].addBlock(Light.block, _glShader_sources2['default']['gl/shaders/ambientLight']);
        }
    }]);

    return AmbientLight;
})(Light);

Light.types['ambient'] = AmbientLight;

var DirectionalLight = (function (_Light2) {
    _inherits(DirectionalLight, _Light2);

    function DirectionalLight(view, config) {
        _classCallCheck(this, DirectionalLight);

        _get(Object.getPrototypeOf(DirectionalLight.prototype), 'constructor', this).call(this, view, config);
        this.type = 'directional';
        this.struct_name = 'DirectionalLight';

        this.direction = (config.direction || [0.2, 0.7, -0.5]).map(parseFloat); // [x, y, z]
    }

    // Inject struct and calculate function

    _createClass(DirectionalLight, [{
        key: 'setupProgram',
        value: function setupProgram(_program) {
            _get(Object.getPrototypeOf(DirectionalLight.prototype), 'setupProgram', this).call(this, _program);
            _program.uniform('3fv', 'u_' + this.name + '.direction', this.direction);
        }
    }], [{
        key: 'inject',
        value: function inject() {
            _glShader_program2['default'].addBlock(Light.block, _glShader_sources2['default']['gl/shaders/directionalLight']);
        }
    }]);

    return DirectionalLight;
})(Light);

Light.types['directional'] = DirectionalLight;

var PointLight = (function (_Light3) {
    _inherits(PointLight, _Light3);

    function PointLight(view, config) {
        _classCallCheck(this, PointLight);

        _get(Object.getPrototypeOf(PointLight.prototype), 'constructor', this).call(this, view, config);
        this.type = 'point';
        this.struct_name = 'PointLight';

        this.position = config.position || [0, 0, '100px'];
        this.position_eye = []; // position in eyespace
        this.origin = config.origin || 'ground';
        this.attenuation = !isNaN(parseFloat(config.attenuation)) ? parseFloat(config.attenuation) : 0;

        if (config.radius) {
            if (Array.isArray(config.radius) && config.radius.length === 2) {
                this.radius = config.radius;
            } else {
                this.radius = [null, config.radius];
            }
        } else {
            this.radius = null;
        }
    }

    // Inject struct and calculate function

    _createClass(PointLight, [{
        key: 'inject',

        // Inject isntance-specific settings
        value: function inject() {
            _get(Object.getPrototypeOf(PointLight.prototype), 'inject', this).call(this);

            _glShader_program2['default'].defines['TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT'] = this.attenuation !== 0;
            _glShader_program2['default'].defines['TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS'] = this.radius != null && this.radius[0] != null;
            _glShader_program2['default'].defines['TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS'] = this.radius != null;
        }
    }, {
        key: 'update',
        value: function update() {
            this.updateEyePosition();
        }
    }, {
        key: 'updateEyePosition',
        value: function updateEyePosition() {
            if (this.origin === 'world') {
                // For world origin, format is: [longitude, latitude, meters (default) or pixels w/px units]

                var _Geo$latLngToMeters = _geo2['default'].latLngToMeters(this.position);

                var _Geo$latLngToMeters2 = _slicedToArray(_Geo$latLngToMeters, 2);

                var x = _Geo$latLngToMeters2[0];
                var y = _Geo$latLngToMeters2[1];

                this.position_eye[0] = x - this.view.camera.position_meters[0];
                this.position_eye[1] = y - this.view.camera.position_meters[1];

                this.position_eye[2] = _stylesStyle_parser.StyleParser.convertUnits(this.position[2], { zoom: this.view.zoom, meters_per_pixel: _geo2['default'].metersPerPixel(this.view.zoom) });
                this.position_eye[2] = this.position_eye[2] - this.view.camera.position_meters[2];
            }
            if (this.origin === 'ground' || this.origin === 'camera') {
                // For camera or ground origin, format is: [x, y, z] in meters (default) or pixels w/px units

                // Light is in camera space by default
                this.position_eye = _stylesStyle_parser.StyleParser.convertUnits(this.position, { zoom: this.view.zoom, meters_per_pixel: _geo2['default'].metersPerPixel(this.view.zoom) });

                if (this.origin === 'ground') {
                    // Leave light's xy in camera space, but z needs to be moved relative to ground plane
                    this.position_eye[2] = this.position_eye[2] - this.view.camera.position_meters[2];
                }
            }
        }
    }, {
        key: 'setupProgram',
        value: function setupProgram(_program) {
            _get(Object.getPrototypeOf(PointLight.prototype), 'setupProgram', this).call(this, _program);

            _program.uniform('4f', 'u_' + this.name + '.position', this.position_eye[0], this.position_eye[1], this.position_eye[2], 1);

            if (_glShader_program2['default'].defines['TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT']) {
                _program.uniform('1f', 'u_' + this.name + '.attenuationExponent', this.attenuation);
            }

            if (_glShader_program2['default'].defines['TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS']) {
                _program.uniform('1f', 'u_' + this.name + '.innerRadius', _stylesStyle_parser.StyleParser.convertUnits(this.radius[0], { zoom: this.view.zoom, meters_per_pixel: _geo2['default'].metersPerPixel(this.view.zoom) }));
            }

            if (_glShader_program2['default'].defines['TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS']) {
                _program.uniform('1f', 'u_' + this.name + '.outerRadius', _stylesStyle_parser.StyleParser.convertUnits(this.radius[1], { zoom: this.view.zoom, meters_per_pixel: _geo2['default'].metersPerPixel(this.view.zoom) }));
            }
        }
    }], [{
        key: 'inject',
        value: function inject() {
            _glShader_program2['default'].addBlock(Light.block, _glShader_sources2['default']['gl/shaders/pointLight']);
        }
    }]);

    return PointLight;
})(Light);

Light.types['point'] = PointLight;

var SpotLight = (function (_PointLight) {
    _inherits(SpotLight, _PointLight);

    function SpotLight(view, config) {
        _classCallCheck(this, SpotLight);

        _get(Object.getPrototypeOf(SpotLight.prototype), 'constructor', this).call(this, view, config);
        this.type = 'spotlight';
        this.struct_name = 'SpotLight';

        this.direction = (config.direction || [0, 0, -1]).map(parseFloat); // [x, y, z]
        this.exponent = config.exponent ? parseFloat(config.exponent) : 0.2;
        this.angle = config.angle ? parseFloat(config.angle) : 20;
    }

    // Inject struct and calculate function

    _createClass(SpotLight, [{
        key: 'setupProgram',
        value: function setupProgram(_program) {
            _get(Object.getPrototypeOf(SpotLight.prototype), 'setupProgram', this).call(this, _program);

            _program.uniform('3fv', 'u_' + this.name + '.direction', this.direction);
            _program.uniform('1f', 'u_' + this.name + '.spotCosCutoff', Math.cos(this.angle * 3.14159 / 180));
            _program.uniform('1f', 'u_' + this.name + '.spotExponent', this.exponent);
        }
    }], [{
        key: 'inject',
        value: function inject() {
            _glShader_program2['default'].addBlock(Light.block, _glShader_sources2['default']['gl/shaders/spotLight']);
        }
    }]);

    return SpotLight;
})(PointLight);

Light.types['spotlight'] = SpotLight;
module.exports = exports['default'];
// Move light's world position into camera space

},{"./geo":197,"./gl/glsl":201,"./gl/shader_program":203,"./gl/shader_sources":204,"./styles/style_parser":235,"babel-runtime/core-js/object/keys":12,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/get":21,"babel-runtime/helpers/inherits":22,"babel-runtime/helpers/interop-require-default":23,"babel-runtime/helpers/sliced-to-array":24}],217:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _glShader_sources = _dereq_('./gl/shader_sources');

var _glShader_sources2 = _interopRequireDefault(_glShader_sources);

// built-in shaders

var _glGlsl = _dereq_('./gl/glsl');

var _glGlsl2 = _interopRequireDefault(_glGlsl);

var _stylesStyle_parser = _dereq_('./styles/style_parser');

var Material = (function () {
    function Material(config) {
        _classCallCheck(this, Material);

        config = config || {};

        // These properties all have the same defaults, so they can be set in bulk
        var _arr = ['emission', 'ambient', 'diffuse', 'specular'];
        for (var _i = 0; _i < _arr.length; _i++) {
            var prop = _arr[_i];
            if (config[prop] != null) {
                if (config[prop].texture) {
                    this[prop] = {
                        texture: config[prop].texture,
                        mapping: config[prop].mapping || 'spheremap',
                        scale: _glGlsl2['default'].expandVec3(config[prop].scale != null ? config[prop].scale : 1),
                        amount: _glGlsl2['default'].expandVec4(config[prop].amount != null ? config[prop].amount : 1)
                    };
                } else if (typeof config[prop] === 'number') {
                    this[prop] = { amount: _glGlsl2['default'].expandVec4(config[prop]) };
                } else if (typeof config[prop] === 'string') {
                    this[prop] = { amount: _stylesStyle_parser.StyleParser.parseColor(config[prop]) };
                } else {
                    this[prop] = config[prop];
                }
            }
        }

        // Extra specular props
        if (this.specular) {
            this.specular.shininess = config.shininess ? parseFloat(config.shininess) : 0.2;
        }

        // Normal mapping
        if (config.normal != null) {
            this.normal = {
                texture: config.normal.texture,
                mapping: config.normal.mapping || 'triplanar',
                scale: _glGlsl2['default'].expandVec3(config.normal.scale != null ? config.normal.scale : 1),
                amount: config.normal.amount != null ? config.normal.amount : 1
            };
        }
    }

    // Determine if a material config block has sufficient properties to create a material

    _createClass(Material, [{
        key: 'inject',
        value: function inject(style) {
            // For each property, sets defines to configure texture mapping, with a pattern like:
            //   TANGRAM_MATERIAL_DIFFUSE, TANGRAM_MATERIAL_DIFFUSE_TEXTURE, TANGRAM_MATERIAL_DIFFUSE_TEXTURE_SPHEREMAP
            // Also sets flags to keep track of each unique mapping type being used, e.g.:
            //   TANGRAM_MATERIAL_TEXTURE_SPHEREMAP
            // Enables texture coordinates if needed and not already on
            var _arr2 = ['emission', 'ambient', 'diffuse', 'specular'];
            for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                var prop = _arr2[_i2];
                var def = 'TANGRAM_MATERIAL_' + prop.toUpperCase();
                var texdef = def + '_TEXTURE';
                style.defines[def] = this[prop] != null;
                if (this[prop] && this[prop].texture) {
                    style.defines[texdef] = true;
                    style.defines[texdef + '_' + this[prop].mapping.toUpperCase()] = true;
                    style.defines['TANGRAM_MATERIAL_TEXTURE_' + this[prop].mapping.toUpperCase()] = true;
                    style.texcoords = style.texcoords || this[prop].mapping === 'uv';
                }
            }

            // Normal mapping
            // As anove, sets flags to keep track of each unique mapping type being used, e.g.:
            //   TANGRAM_MATERIAL_TEXTURE_SPHEREMAP
            if (this.normal && this.normal.texture) {
                style.defines['TANGRAM_MATERIAL_NORMAL_TEXTURE'] = true;
                style.defines['TANGRAM_MATERIAL_NORMAL_TEXTURE_' + this.normal.mapping.toUpperCase()] = true;
                style.defines['TANGRAM_MATERIAL_TEXTURE_' + this.normal.mapping.toUpperCase()] = true;
                style.texcoords = style.texcoords || this.normal.mapping === 'uv';
            }

            style.replaceShaderBlock(Material.block, _glShader_sources2['default']['gl/shaders/material'], 'Material');
            style.addShaderBlock('setup', '\nmaterial = u_material;\n', 'Material');
        }
    }, {
        key: 'setupProgram',
        value: function setupProgram(_program) {
            // For each property, sets uniforms in the pattern:
            // u_material.diffuse, u_material.diffuseScale u_material_diffuse_texture
            var _arr3 = ['emission', 'ambient', 'diffuse', 'specular'];
            for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
                var prop = _arr3[_i3];
                if (this[prop]) {
                    if (this[prop].texture) {
                        _program.setTextureUniform('u_material_' + prop + '_texture', this[prop].texture);
                        _program.uniform('3fv', 'u_material.' + prop + 'Scale', this[prop].scale);
                        _program.uniform('4fv', 'u_material.' + prop, this[prop].amount);
                    } else if (this[prop].amount) {
                        _program.uniform('4fv', 'u_material.' + prop, this[prop].amount);
                    }
                }
            }

            // Extra specular props
            if (this.specular) {
                _program.uniform('1f', 'u_material.shininess', this.specular.shininess);
            }

            // Normal mapping
            if (this.normal && this.normal.texture) {
                _program.setTextureUniform('u_material_normal_texture', this.normal.texture);
                _program.uniform('3fv', 'u_material.normalScale', this.normal.scale);
                _program.uniform('1f', 'u_material.normalAmount', this.normal.amount);
            }
        }
    }], [{
        key: 'isValid',
        value: function isValid(config) {
            if (config == null) {
                return false;
            }

            if (config.emission == null && config.ambient == null && config.diffuse == null && config.specular == null) {
                return false;
            }

            return true;
        }
    }]);

    return Material;
})();

exports['default'] = Material;

Material.block = 'material';
module.exports = exports['default'];

},{"./gl/glsl":201,"./gl/shader_sources":204,"./styles/style_parser":235,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/interop-require-default":23}],218:[function(_dereq_,module,exports){
/*jshint worker: true*/

// Modules and dependencies to expose in the public Tangram module
'use strict';

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

var _utilsUtils = _dereq_('./utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

// The leaflet layer plugin is currently the primary public API

var _leaflet_layer = _dereq_('./leaflet_layer');

// The scene worker is only activated when a worker thread is instantiated, but must always be loaded

var _scene = _dereq_('./scene');

var _scene2 = _interopRequireDefault(_scene);

var _scene_worker = _dereq_('./scene_worker');

// Additional modules are exposed for debugging

var _utilsVersion = _dereq_('./utils/version');

var _utilsVersion2 = _interopRequireDefault(_utilsVersion);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var _geo = _dereq_('./geo');

var _geo2 = _interopRequireDefault(_geo);

var _sourcesData_source = _dereq_('./sources/data_source');

var _sourcesData_source2 = _interopRequireDefault(_sourcesData_source);

_dereq_('./sources/geojson');

_dereq_('./sources/topojson');

_dereq_('./sources/mvt');

var _tile_manager = _dereq_('./tile_manager');

var _tile_manager2 = _interopRequireDefault(_tile_manager);

var _glGlsl = _dereq_('./gl/glsl');

var _glGlsl2 = _interopRequireDefault(_glGlsl);

var _glShader_program = _dereq_('./gl/shader_program');

var _glShader_program2 = _interopRequireDefault(_glShader_program);

var _glVertex_data = _dereq_('./gl/vertex_data');

var _glVertex_data2 = _interopRequireDefault(_glVertex_data);

var _glTexture = _dereq_('./gl/texture');

var _glTexture2 = _interopRequireDefault(_glTexture);

var _material = _dereq_('./material');

var _material2 = _interopRequireDefault(_material);

var _light = _dereq_('./light');

var _light2 = _interopRequireDefault(_light);

var _utilsWorker_broker = _dereq_('./utils/worker_broker');

var _utilsWorker_broker2 = _interopRequireDefault(_utilsWorker_broker);

var _stylesRule = _dereq_('./styles/rule');

var _stylesStyle_manager = _dereq_('./styles/style_manager');

var _stylesStyle_parser = _dereq_('./styles/style_parser');

var _labelsCollision = _dereq_('./labels/collision');

var _labelsCollision2 = _interopRequireDefault(_labelsCollision);

var _selection = _dereq_('./selection');

var _selection2 = _interopRequireDefault(_selection);

var _jsYaml = _dereq_('js-yaml');

var _jsYaml2 = _interopRequireDefault(_jsYaml);

// Make some modules accessible for debugging
var debug = {
    log: _loglevel2['default'],
    yaml: _jsYaml2['default'],
    Utils: _utilsUtils2['default'],
    Geo: _geo2['default'],
    DataSource: _sourcesData_source2['default'],
    TileManager: _tile_manager2['default'],
    GLSL: _glGlsl2['default'],
    ShaderProgram: _glShader_program2['default'],
    VertexData: _glVertex_data2['default'],
    Texture: _glTexture2['default'],
    Material: _material2['default'],
    Light: _light2['default'],
    Scene: _scene2['default'],
    SceneWorker: _scene_worker.SceneWorker,
    WorkerBroker: _utilsWorker_broker2['default'],
    ruleCache: _stylesRule.ruleCache,
    StyleManager: _stylesStyle_manager.StyleManager,
    StyleParser: _stylesStyle_parser.StyleParser,
    Collision: _labelsCollision2['default'],
    FeatureSelection: _selection2['default']
};

// Window can only be set in main thread
if (_utilsUtils2['default'].isMainThread) {

    window.Tangram = module.exports = {
        leafletLayer: _leaflet_layer.leafletLayer,
        debug: debug,
        version: _utilsVersion2['default'].string
    };
}

if (_utilsUtils2['default'].isWorkerThread) {
    self.Tangram = {
        debug: debug,
        version: _utilsVersion2['default'].string
    };
}

if (_utilsUtils2['default'].isMainThread) {
    _utilsUtils2['default'].requestAnimationFramePolyfill();
}

// Setup logging to prefix with Tangram version
var originalFactory = _loglevel2['default'].methodFactory;
_loglevel2['default'].methodFactory = function (methodName, logLevel) {
    var rawMethod = originalFactory(methodName, logLevel);
    return function () {
        for (var _len = arguments.length, message = Array(_len), _key = 0; _key < _len; _key++) {
            message[_key] = arguments[_key];
        }

        rawMethod.apply(undefined, ['Tangram ' + _utilsVersion2['default'].string + ':'].concat(message));
    };
};

},{"./geo":197,"./gl/glsl":201,"./gl/shader_program":203,"./gl/texture":205,"./gl/vertex_data":208,"./labels/collision":210,"./leaflet_layer":215,"./light":216,"./material":217,"./scene":219,"./scene_worker":221,"./selection":222,"./sources/data_source":223,"./sources/geojson":224,"./sources/mvt":225,"./sources/topojson":226,"./styles/rule":232,"./styles/style_manager":234,"./styles/style_parser":235,"./tile_manager":240,"./utils/utils":247,"./utils/version":248,"./utils/worker_broker":249,"babel-runtime/helpers/interop-require-default":23,"js-yaml":154,"loglevel":183}],219:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsUtils = _dereq_('./utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _utilsWorker_broker = _dereq_('./utils/worker_broker');

var _utilsWorker_broker2 = _interopRequireDefault(_utilsWorker_broker);

var _utilsSubscribe = _dereq_('./utils/subscribe');

var _utilsSubscribe2 = _interopRequireDefault(_utilsSubscribe);

var _glContext = _dereq_('./gl/context');

var _glContext2 = _interopRequireDefault(_glContext);

var _glTexture = _dereq_('./gl/texture');

var _glTexture2 = _interopRequireDefault(_glTexture);

var _glVao = _dereq_('./gl/vao');

var _glVao2 = _interopRequireDefault(_glVao);

var _stylesStyle = _dereq_('./styles/style');

var _stylesStyle_manager = _dereq_('./styles/style_manager');

var _stylesStyle_parser = _dereq_('./styles/style_parser');

var _scene_loader = _dereq_('./scene_loader');

var _scene_loader2 = _interopRequireDefault(_scene_loader);

var _view = _dereq_('./view');

var _view2 = _interopRequireDefault(_view);

var _light = _dereq_('./light');

var _light2 = _interopRequireDefault(_light);

var _tile_manager = _dereq_('./tile_manager');

var _tile_manager2 = _interopRequireDefault(_tile_manager);

var _sourcesData_source = _dereq_('./sources/data_source');

var _sourcesData_source2 = _interopRequireDefault(_sourcesData_source);

var _selection = _dereq_('./selection');

var _selection2 = _interopRequireDefault(_selection);

var _glRender_state = _dereq_('./gl/render_state');

var _glRender_state2 = _interopRequireDefault(_glRender_state);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var _stylesPolygonsPolygons = _dereq_('./styles/polygons/polygons');

var _stylesLinesLines = _dereq_('./styles/lines/lines');

var _stylesPointsPoints = _dereq_('./styles/points/points');

var _stylesTextText = _dereq_('./styles/text/text');

// Add built-in rendering styles
_stylesStyle_manager.StyleManager.register(_stylesPolygonsPolygons.Polygons);
_stylesStyle_manager.StyleManager.register(_stylesLinesLines.Lines);
_stylesStyle_manager.StyleManager.register(_stylesPointsPoints.Points);
_stylesStyle_manager.StyleManager.register(_stylesTextText.TextStyle);

// Load scene definition: pass an object directly, or a URL as string to load remotely

var Scene = (function () {
    function Scene(config_source, options) {
        var _this = this;

        _classCallCheck(this, Scene);

        options = options || {};
        (0, _utilsSubscribe2['default'])(this);

        this.initialized = false;
        this.initializing = null; // will be a promise that resolves when scene is loaded
        this.sources = {};

        this.view = new _view2['default'](this, options);
        this.tile_manager = _tile_manager2['default'];
        this.tile_manager.init({ scene: this, view: this.view });
        this.num_workers = options.numWorkers || 2;
        this.allow_cross_domain_workers = options.allowCrossDomainWorkers === false ? false : true;
        this.worker_url = options.workerUrl;
        if (options.disableVertexArrayObjects === true) {
            _glVao2['default'].disabled = true;
        }

        _utilsUtils2['default'].use_high_density_display = options.highDensityDisplay !== undefined ? options.highDensityDisplay : true;
        _utilsUtils2['default'].updateDevicePixelRatio();

        this.config = null;
        this.config_source = config_source;
        this.config_serialized = null;
        this.last_valid_config_source = null;

        this.styles = null;
        this.active_styles = {};

        this.building = null; // tracks current scene building state (tiles being built, etc.)
        this.dirty = true; // request a redraw
        this.animated = false; // request redraw every frame
        this.preUpdate = options.preUpdate; // optional pre-render loop hook
        this.postUpdate = options.postUpdate; // optional post-render loop hook
        this.render_loop = !options.disableRenderLoop; // disable render loop - app will have to manually call Scene.render() per frame
        this.render_loop_active = false;
        this.render_loop_stop = false;
        this.render_count = 0;
        this.last_render_count = 0;
        this.render_count_changed = false;
        this.frame = 0;
        this.queue_screenshot = null;
        this.selection = null;
        this.resetTime();

        this.container = options.container;

        this.lights = null;
        this.background = null;

        // Listen to related objects
        this.listeners = {
            view: {
                move: function move() {
                    return _this.trigger('move');
                }
            }
        };
        this.view.subscribe(this.listeners.view);

        this.updating = 0;
        this.generation = 0; // an id that is incremented each time the scene config is invalidated
        this.last_complete_generation = 0; // last generation id with a complete view
        this.setupDebug();

        this.logLevel = options.logLevel || 'warn';
        _loglevel2['default'].setLevel(this.logLevel);
    }

    _createClass(Scene, [{
        key: 'load',

        // Load (or reload) scene config
        // Optionally specify new scene file URL
        value: function load() {
            var _this2 = this;

            var config_source = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
            var config_path = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

            if (this.initializing) {
                return this.initializing;
            }

            this.updating++;
            this.initialized = false;

            // Load scene definition (sources, styles, etc.), then create styles & workers
            this.initializing = this.loadScene(config_source, config_path).then(function () {
                return _this2.createWorkers();
            }).then(function () {
                _this2.createCanvas();
                _this2.resetFeatureSelection();

                if (!_this2.listeners.texture) {
                    _this2.listeners.texture = {
                        update: function update() {
                            return _this2.dirty = true;
                        },
                        warning: function warning(data) {
                            return _this2.trigger('warning', _Object$assign({ type: 'textures' }, data));
                        }
                    };
                    _glTexture2['default'].subscribe(_this2.listeners.texture);
                }

                // Only retain visible tiles for rebuilding
                _this2.tile_manager.pruneToVisibleTiles();
                return _this2.updateConfig({ rebuild: true });
            }).then(function () {
                _this2.updating--;
                _this2.initializing = null;
                _this2.initialized = true;
                _this2.last_valid_config_source = _this2.config_source;
                _this2.last_valid_config_path = _this2.config_path;

                if (_this2.render_loop !== false) {
                    _this2.setupRenderLoop();
                }
                _this2.requestRedraw();
            })['catch'](function (error) {
                _this2.initializing = null;
                _this2.updating = 0;

                // Report and revert to last valid config if available
                var type = undefined,
                    message = undefined;
                if (error.name === 'YAMLException') {
                    type = 'yaml';
                    message = 'Error parsing scene YAML';
                } else {
                    // TODO: more error types
                    message = 'Error initializing scene';
                }
                _this2.trigger('error', { type: type, message: message, error: error, url: _this2.config_source });

                message = 'Scene.load() failed to load ' + _this2.config_source + ': ' + error.message;
                if (_this2.last_valid_config_source) {
                    _loglevel2['default'].warn(message, error);
                    _loglevel2['default'].info('Scene.load() reverting to last valid configuration');
                    return _this2.load(_this2.last_valid_config_source, _this2.last_valid_config_path);
                }
                _loglevel2['default'].error(message, error);
                throw error;
            });

            return this.initializing;
        }

        // For API compatibility
    }, {
        key: 'reload',
        value: function reload() {
            var config_source = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
            var config_path = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

            return this.load(config_source, config_path);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.initialized = false;
            this.render_loop_stop = true; // schedule render loop to stop

            this.unsubscribeAll(); // clear all event listeners

            this.view.unsubscribe(this.listeners.view);
            _glTexture2['default'].unsubscribe(this.listeners.texture);
            this.listeners = null;

            if (this.canvas && this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
                this.canvas = null;
            }
            this.container = null;

            if (this.selection) {
                this.selection.destroy();
            }

            if (this.gl) {
                _glTexture2['default'].destroy(this.gl);
                _stylesStyle_manager.StyleManager.destroy(this.gl);
                this.styles = {};

                this.gl = null;
            }

            this.sources = {};

            if (Array.isArray(this.workers)) {
                this.workers.forEach(function (worker) {
                    worker.terminate();
                });
                this.workers = null;
            }

            this.tile_manager.destroy();
        }
    }, {
        key: 'createCanvas',
        value: function createCanvas() {
            if (this.canvas) {
                return;
            }

            this.container = this.container || document.body;
            this.canvas = document.createElement('canvas');
            this.canvas.style.position = 'absolute';
            this.canvas.style.top = 0;
            this.canvas.style.left = 0;

            // Force tangram canvas underneath all leaflet layers, and set background to transparent
            this.container.style.backgroundColor = 'transparent';
            this.container.appendChild(this.canvas);

            try {
                this.gl = _glContext2['default'].getContext(this.canvas, {
                    alpha: true, premultipliedAlpha: true, // TODO: vary w/scene alpha
                    device_pixel_ratio: _utilsUtils2['default'].device_pixel_ratio
                });
            } catch (e) {
                throw new Error("Couldn't create WebGL context. " + "Your browser may not support WebGL, or it's turned off? " + "Visit http://webglreport.com/ for more info.");
            }

            this.resizeMap(this.container.clientWidth, this.container.clientHeight);
            _glVao2['default'].init(this.gl);
            _glRender_state2['default'].initialize(this.gl);
        }

        // Get the URL to load the web worker from
    }, {
        key: 'getWorkerUrl',
        value: function getWorkerUrl() {
            var worker_url = this.worker_url || _utilsUtils2['default'].findCurrentURL('tangram.debug.js', 'tangram.min.js');

            if (!worker_url) {
                throw new Error("Can't load worker because couldn't find base URL that library was loaded from");
            }

            if (this.allow_cross_domain_workers) {
                var body = 'importScripts(\'' + worker_url + '\');';
                return _utilsUtils2['default'].createObjectURL(new Blob([body], { type: 'application/javascript' }));
            }
            return worker_url;
        }

        // Web workers handle heavy duty tile construction: networking, geometry processing, etc.
    }, {
        key: 'createWorkers',
        value: function createWorkers() {
            if (!this.workers) {
                return this.makeWorkers(this.getWorkerUrl());
            }
            return _Promise.resolve();
        }

        // Instantiate workers from URL, init event handlers
    }, {
        key: 'makeWorkers',
        value: function makeWorkers(url) {
            var _this3 = this;

            var queue = [];

            this.workers = [];

            var _loop = function () {
                worker = new Worker(url);

                _this3.workers[id] = worker;

                worker.addEventListener('message', _this3.workerLogMessage.bind(_this3));
                _utilsWorker_broker2['default'].addWorker(worker);

                _loglevel2['default'].debug('Scene.makeWorkers: initializing worker ' + id);
                var _id = id;
                queue.push(_utilsWorker_broker2['default'].postMessage(worker, 'self.init', id, _this3.num_workers, _utilsUtils2['default'].device_pixel_ratio).then(function (id) {
                    _loglevel2['default'].debug('Scene.makeWorkers: initialized worker ' + id);
                    return id;
                }, function (error) {
                    _loglevel2['default'].error('Scene.makeWorkers: failed to initialize worker ' + _id + ':', error);
                    return _Promise.reject(error);
                }));
            };

            for (var id = 0; id < this.num_workers; id++) {
                var worker;

                _loop();
            }

            this.next_worker = 0;
            return _Promise.all(queue);
        }

        // Round robin selection of next worker
    }, {
        key: 'nextWorker',
        value: function nextWorker() {
            var worker = this.workers[this.next_worker];
            this.next_worker = (this.next_worker + 1) % this.workers.length;
            return worker;
        }

        // Scene is ready for rendering
    }, {
        key: 'ready',
        value: function ready() {
            if (!this.view.ready() || _Object$keys(this.sources).length === 0) {
                return false;
            }
            return true;
        }

        // Resize the map when device pixel ratio changes, e.g. when switching between displays
    }, {
        key: 'updateDevicePixelRatio',
        value: function updateDevicePixelRatio() {
            var _this4 = this;

            if (_utilsUtils2['default'].updateDevicePixelRatio()) {
                _utilsWorker_broker2['default'].postMessage(this.workers, 'self.updateDevicePixelRatio', _utilsUtils2['default'].device_pixel_ratio).then(function () {
                    return _this4.rebuild();
                }).then(function () {
                    return _this4.resizeMap(_this4.view.size.css.width, _this4.view.size.css.height);
                });
            }
        }
    }, {
        key: 'resizeMap',
        value: function resizeMap(width, height) {
            this.dirty = true;

            this.view.setViewportSize(width, height);

            if (this.canvas) {
                this.canvas.style.width = this.view.size.css.width + 'px';
                this.canvas.style.height = this.view.size.css.height + 'px';
                this.canvas.width = this.view.size.device.width;
                this.canvas.height = this.view.size.device.height;

                if (this.gl) {
                    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                }
            }
        }

        // Request scene be redrawn at next animation loop
    }, {
        key: 'requestRedraw',
        value: function requestRedraw() {
            this.dirty = true;
        }

        // Redraw scene immediately - don't wait for animation loop
        // Use sparingly, but for cases where you need the closest possible sync with other UI elements,
        // such as other, non-WebGL map layers (e.g. Leaflet raster layers, markers, etc.)
    }, {
        key: 'immediateRedraw',
        value: function immediateRedraw() {
            this.dirty = true;
            this.update();
        }
    }, {
        key: 'renderLoop',
        value: function renderLoop() {
            this.render_loop_active = true; // only let the render loop instantiate once

            if (this.initialized) {
                // Render the scene
                this.update();
            }

            // Request the next frame if not scheduled to stop
            if (!this.render_loop_stop) {
                window.requestAnimationFrame(this.renderLoop.bind(this));
            } else {
                this.render_loop_stop = false;
                this.render_loop_active = false;
            }
        }

        // Setup the render loop
    }, {
        key: 'setupRenderLoop',
        value: function setupRenderLoop() {
            var _this5 = this;

            if (!this.render_loop_active) {
                setTimeout(function () {
                    _this5.renderLoop();
                }, 0); // delay start by one tick
            }
        }
    }, {
        key: 'update',
        value: function update() {
            // Render on demand
            var will_render = !(this.dirty === false || this.initialized === false || this.updating > 0 || this.ready() === false);

            // Pre-render loop hook
            if (typeof this.preUpdate === 'function') {
                this.preUpdate(will_render);
            }

            // Bail if no need to render
            if (!will_render) {
                return false;
            }
            this.dirty = false; // subclasses can set this back to true when animation is needed

            // Render the scene
            this.updateDevicePixelRatio();
            this.render();
            this.completeScreenshot(); // completes screenshot capture if requested
            this.updateViewComplete(); // fires event when rendered tile set or style changes

            // Post-render loop hook
            if (typeof this.postUpdate === 'function') {
                this.postUpdate(will_render);
            }

            // Redraw every frame if animating
            if (this.animated === true) {
                this.dirty = true;
            }

            this.frame++;
            _loglevel2['default'].trace('Scene.render()');
            return true;
        }
    }, {
        key: 'render',
        value: function render() {
            var _this6 = this;

            var gl = this.gl;

            // Update styles, camera, lights
            this.view.update();
            _Object$keys(this.active_styles).forEach(function (i) {
                return _this6.styles[i].update();
            });
            _Object$keys(this.lights).forEach(function (i) {
                return _this6.lights[i].update();
            });

            // Renderable tile list
            this.renderable_tiles = this.tile_manager.getRenderableTiles();
            this.renderable_tiles_count = this.renderable_tiles.length;

            // Render main pass
            this.render_count = this.renderPass();

            // Render selection pass (if needed)
            if (this.selection.pendingRequests()) {
                if (this.view.panning) {
                    this.selection.clearPendingRequests();
                    return;
                }

                this.selection.bind(); // switch to FBO
                this.renderPass('selection_program', // render w/alternate program
                { allow_blend: false });
                this.selection.read(); // read results from selection buffer

                // Reset to screen buffer
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            this.render_count_changed = false;
            if (this.render_count !== this.last_render_count) {
                this.render_count_changed = true;

                this.getFeatureSelectionMapSize().then(function (size) {
                    _loglevel2['default'].info('Scene: rendered ' + _this6.render_count + ' primitives (' + size + ' features in selection map)');
                }, function () {}); // no op when promise rejects (only print last response)
            }
            this.last_render_count = this.render_count;

            return true;
        }

        // Render all active styles, grouped by blend/depth type (opaque, overlay, etc.) and by program (style)
        // Called both for main render pass, and for secondary passes like selection buffer
    }, {
        key: 'renderPass',
        value: function renderPass() {
            var _this7 = this;

            var program_key = arguments.length <= 0 || arguments[0] === undefined ? 'program' : arguments[0];

            var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            var allow_blend = _ref.allow_blend;

            // optionally force alpha off (e.g. for selection pass)
            allow_blend = allow_blend == null ? true : allow_blend;

            this.clearFrame({ clear_color: true, clear_depth: true });

            // Sort styles by blend order
            var styles = _Object$keys(this.active_styles).map(function (s) {
                return _this7.styles[s];
            }).sort(_stylesStyle.Style.blendOrderSort);

            // Render styles
            var count = 0; // how many primitives were rendered
            var last_blend = undefined;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = _getIterator(styles), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var style = _step.value;

                    // Only update render state when blend mode changes
                    if (style.blend !== last_blend) {
                        var state = _Object$assign({}, _stylesStyle.Style.render_states[style.blend], // render state for blend mode
                        { blend: allow_blend && style.blend } // enable/disable blending (e.g. no blend for selection)
                        );
                        this.setRenderState(state);
                    }
                    count += this.renderStyle(style.name, program_key);
                    last_blend = style.blend;
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator['return']) {
                        _iterator['return']();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return count;
        }
    }, {
        key: 'renderStyle',
        value: function renderStyle(style, program_key) {
            var first_for_style = true;
            var render_count = 0;

            var program = this.styles[style][program_key];
            if (!program || !program.compiled) {
                return 0;
            }

            // Render tile GL geometries
            for (var t in this.renderable_tiles) {
                var tile = this.renderable_tiles[t];

                if (tile.meshes[style] == null) {
                    continue;
                }

                // Style-specific state
                // Only setup style if rendering for first time this frame
                // (lazy init, not all styles will be used in all screen views; some styles might be defined but never used)
                if (first_for_style === true) {
                    first_for_style = false;

                    program.use();
                    this.styles[style].setup();

                    // TODO: don't set uniforms when they haven't changed
                    program.uniform('1f', 'u_time', this.animated ? (+new Date() - this.start_time) / 1000 : 0);
                    this.view.setupProgram(program);
                    for (var i in this.lights) {
                        this.lights[i].setupProgram(program);
                    }
                }

                // Tile-specific state
                this.view.setupTile(tile, program);

                // Render tile
                tile.meshes[style].render();
                render_count += tile.meshes[style].geometry_count;
            }

            return render_count;
        }
    }, {
        key: 'clearFrame',
        value: function clearFrame() {
            var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            var clear_color = _ref2.clear_color;
            var clear_depth = _ref2.clear_depth;

            if (!this.initialized) {
                return;
            }

            // Defaults
            clear_color = clear_color === false ? false : true; // default true
            clear_depth = clear_depth === false ? false : true; // default true

            // Reset frame state
            var gl = this.gl;

            if (clear_color) {
                gl.clearColor.apply(gl, _toConsumableArray(this.background.color));
            }

            if (clear_depth) {
                gl.depthMask(true); // always clear depth if requested, even if depth write will be turned off
            }

            if (clear_color || clear_depth) {
                var mask = (clear_color && gl.COLOR_BUFFER_BIT) | (clear_depth && gl.DEPTH_BUFFER_BIT);
                gl.clear(mask);
            }
        }
    }, {
        key: 'setRenderState',
        value: function setRenderState() {
            var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            var depth_test = _ref3.depth_test;
            var depth_write = _ref3.depth_write;
            var cull_face = _ref3.cull_face;
            var blend = _ref3.blend;

            if (!this.initialized) {
                return;
            }

            // Defaults
            // TODO: when we abstract out support for multiple render passes, these can be per-pass config options
            depth_test = depth_test === false ? false : true; // default true
            depth_write = depth_write === false ? false : true; // default true
            cull_face = cull_face === false ? false : true; // default true
            blend = blend != null ? blend : false; // default false

            // Reset frame state
            var gl = this.gl;

            _glRender_state2['default'].depth_test.set({ depth_test: depth_test, depth_func: gl.LEQUAL });
            _glRender_state2['default'].depth_write.set({ depth_write: depth_write });
            _glRender_state2['default'].culling.set({ cull: cull_face, face: gl.BACK });

            // Blending of alpha channel is modified to account for WebGL alpha behavior, see:
            // http://webglfundamentals.org/webgl/lessons/webgl-and-alpha.html
            // http://stackoverflow.com/a/11533416
            if (blend) {
                // Opaque: all source, no destination
                if (blend === 'opaque') {
                    _glRender_state2['default'].blending.set({
                        blend: true,
                        src: gl.SRC_ALPHA, dst: gl.ZERO
                    });
                }
                // Traditional alpha blending
                else if (blend === 'overlay' || blend === 'inlay') {
                        _glRender_state2['default'].blending.set({
                            blend: true,
                            src: gl.SRC_ALPHA, dst: gl.ONE_MINUS_SRC_ALPHA,
                            src_alpha: gl.ONE, dst_alpha: gl.ONE_MINUS_SRC_ALPHA
                        });
                    }
                    // Additive blending
                    else if (blend === 'add') {
                            _glRender_state2['default'].blending.set({
                                blend: true,
                                src: gl.ONE, dst: gl.ONE,
                                src_alpha: gl.ONE, dst_alpha: gl.ONE_MINUS_SRC_ALPHA
                            });
                        }
                        // Multiplicative blending
                        else if (blend === 'multiply') {
                                _glRender_state2['default'].blending.set({
                                    blend: true,
                                    src: gl.ZERO, dst: gl.SRC_COLOR,
                                    src_alpha: gl.ONE, dst_alpha: gl.ONE_MINUS_SRC_ALPHA
                                });
                            }
            } else {
                _glRender_state2['default'].blending.set({ blend: false });
            }
        }

        // Request feature selection at given pixel. Runs async and returns results via a promise.
    }, {
        key: 'getFeatureAt',
        value: function getFeatureAt(pixel) {
            if (!this.initialized) {
                _loglevel2['default'].debug("Scene.getFeatureAt() called before scene was initialized");
                return _Promise.resolve();
            }

            // Point scaled to [0..1] range
            var point = {
                x: pixel.x * _utilsUtils2['default'].device_pixel_ratio / this.view.size.device.width,
                y: pixel.y * _utilsUtils2['default'].device_pixel_ratio / this.view.size.device.height
            };

            this.dirty = true; // need to make sure the scene re-renders for these to be processed
            return this.selection.getFeatureAt(point)['catch'](function (r) {
                return _Promise.resolve(r);
            });
        }

        // Rebuild geometry, without re-parsing the config or re-compiling styles
        // TODO: detect which elements need to be refreshed/rebuilt (stylesheet changes, etc.)
    }, {
        key: 'rebuild',
        value: function rebuild(options) {
            return this.rebuildGeometry(options);
        }

        // Rebuild all tiles
    }, {
        key: 'rebuildGeometry',
        value: function rebuildGeometry() {
            var _this8 = this;

            var _ref4 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            var _ref4$sync = _ref4.sync;
            var sync = _ref4$sync === undefined ? true : _ref4$sync;

            return new _Promise(function (resolve, reject) {
                // Skip rebuild if already in progress
                if (_this8.building) {
                    // Queue up to one rebuild call at a time, only save last request
                    if (_this8.building.queued && _this8.building.queued.reject) {
                        // notify previous request that it did not complete
                        _loglevel2['default'].debug('Scene.rebuildGeometry: request superceded by a newer call');
                        _this8.building.queued.resolve(false); // false flag indicates rebuild request was superceded
                    }

                    // Save queued request
                    _this8.building.queued = { resolve: resolve, reject: reject };
                    _loglevel2['default'].trace('Scene.rebuildGeometry(): queuing request');
                    return;
                }

                // Track tile build state
                _this8.building = { resolve: resolve, reject: reject };

                // Profiling
                if (_this8.debug.profile.geometry_build) {
                    _this8._profile('rebuildGeometry');
                }

                // Update config (in case JS objects were manipulated directly)
                if (sync) {
                    _this8.syncConfigToWorker();
                    _stylesStyle_manager.StyleManager.compile(_this8.updateActiveStyles(), _this8); // only recompile newly active styles
                }
                _this8.resetFeatureSelection();
                _this8.resetTime();

                // Rebuild visible tiles, sorted from center
                var build = [];
                _this8.tile_manager.forEachTile(function (tile) {
                    if (tile.visible) {
                        build.push(tile);
                    } else {
                        _this8.tile_manager.removeTile(tile.key);
                    }
                });
                _this8.tile_manager.buildTiles(build);
            }).then(function () {
                // Profiling
                if (_this8.debug.profile.geometry_build) {
                    _this8._profileEnd('rebuildGeometry');
                }
            });
        }

        // Tile manager finished building tiles
        // TODO move to tile manager
    }, {
        key: 'tileManagerBuildDone',
        value: function tileManagerBuildDone() {
            if (this.building) {
                _loglevel2['default'].info('Scene: build geometry finished');
                if (this.building.resolve) {
                    this.building.resolve(true);
                }

                // Another rebuild queued?
                var queued = this.building.queued;
                this.building = null;
                if (queued) {
                    _loglevel2['default'].debug('Scene: starting queued rebuildGeometry() request');
                    this.rebuildGeometry().then(queued.resolve, queued.reject);
                }
            }
        }

        /**
           Load (or reload) the scene config
           @return {Promise}
        */
    }, {
        key: 'loadScene',
        value: function loadScene() {
            var _this9 = this;

            var config_source = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
            var config_path = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

            this.config_source = config_source || this.config_source;

            if (typeof this.config_source === 'string') {
                this.config_path = _utilsUtils2['default'].pathForURL(config_path || this.config_source);
            } else {
                this.config_path = _utilsUtils2['default'].pathForURL(config_path);
            }

            return _scene_loader2['default'].loadScene(this.config_source, this.config_path).then(function (config) {
                _this9.config = config;
                _this9.trigger('load', { config: _this9.config });
                return _this9.config;
            });
        }

        // Add source to a scene, arguments `name` and `config` need to be provided:
        //  - If the name doesn't match a sources it will create it
        //  - the `config` obj follow the YAML scene spec, ex: ```{type: 'TopoJSON', url: "//vector.mapzen.com/osm/all/{z}/{x}/{y}.topojson"]}```
        //    that looks like:
        //
        //      scene.setDataSource("osm", {type: 'TopoJSON', url: "//vector.mapzen.com/osm/all/{z}/{x}/{y}.topojson" });
        //
        //  - also can be pass a ```data``` obj: ```{type: 'GeoJSON', data: JSObj ]}```
        //
        //      var geojson_data = {};
        //      ...
        //      scene.setDataSource("dynamic_data", {type: 'GeoJSON', data: geojson_data });
        //
    }, {
        key: 'setDataSource',
        value: function setDataSource(name, config) {
            if (!name || !config || !config.type || !config.url && !config.data) {
                _loglevel2['default'].error("No name provided or not a valid config:", name, config);
                return;
            }

            var load = this.config.sources[name] == null;
            var source = this.config.sources[name] = _Object$assign({}, config);

            if (source.data && typeof source.data === 'object') {
                source.url = _utilsUtils2['default'].createObjectURL(new Blob([JSON.stringify(source.data)]));
                delete source.data;
            }

            if (load) {
                this.updateConfig({ rebuild: true });
            } else {
                this.rebuild();
            }
        }
    }, {
        key: 'loadDataSources',
        value: function loadDataSources() {
            var reset = []; // sources to reset
            var prev_source_names = _Object$keys(this.sources);

            for (var name in this.config.sources) {
                var source = this.config.sources[name];
                var prev_source = this.sources[name];

                try {
                    this.sources[name] = _sourcesData_source2['default'].create(_Object$assign({}, source, { name: name }));
                    if (!this.sources[name]) {
                        throw {};
                    }
                } catch (e) {
                    delete this.sources[name];
                    var message = 'Could not create data source: ' + e.message;
                    _loglevel2['default'].warn('Scene: ' + message, source);
                    this.trigger('warning', { type: 'sources', source: source, message: message });
                }

                // Data source changed?
                if (_sourcesData_source2['default'].changed(this.sources[name], prev_source)) {
                    reset.push(name);
                }
            }

            // Sources that were removed
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = _getIterator(prev_source_names), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var s = _step2.value;

                    if (!this.config.sources[s]) {
                        delete this.sources[s]; // TODO: remove from workers too?
                        reset.push(s);
                    }
                }

                // Remove tiles from sources that have changed
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                        _iterator2['return']();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            if (reset.length > 0) {
                this.tile_manager.removeTiles(function (tile) {
                    return reset.indexOf(tile.source.name) > -1;
                });
            }
        }

        // Load all textures in the scene definition
    }, {
        key: 'loadTextures',
        value: function loadTextures() {
            return _glTexture2['default'].createFromObject(this.gl, this.config.textures);
        }

        // Called (currently manually) after styles are updated in stylesheet
    }, {
        key: 'updateStyles',
        value: function updateStyles() {
            if (!this.initialized && !this.initializing) {
                throw new Error('Scene.updateStyles() called before scene was initialized');
            }

            // (Re)build styles from config
            this.styles = _stylesStyle_manager.StyleManager.build(this.config.styles, this);

            // Optionally set GL context (used when initializing or re-initializing GL resources)
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = _getIterator(_utilsUtils2['default'].values(this.styles)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var style = _step3.value;

                    style.setGL(this.gl);
                }

                // Find & compile active styles
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                        _iterator3['return']();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            this.updateActiveStyles();
            _stylesStyle_manager.StyleManager.compile(_Object$keys(this.active_styles), this);

            this.dirty = true;
        }
    }, {
        key: 'updateActiveStyles',
        value: function updateActiveStyles() {
            var _this10 = this;

            // Make a set of currently active styles (used in a draw rule)
            // Note: doesn't actually check if any geometry matches the rule, just that the style is potentially renderable
            var prev_styles = _Object$keys(this.active_styles || {});
            this.active_styles = {};
            var animated = false; // is any active style animated?
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
                for (var _iterator4 = _getIterator(_utilsUtils2['default'].recurseValues(this.config.layers)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var rule = _step4.value;

                    if (rule && rule.draw) {
                        var _iteratorNormalCompletion5 = true;
                        var _didIteratorError5 = false;
                        var _iteratorError5 = undefined;

                        try {
                            for (var _iterator5 = _getIterator(_utilsUtils2['default'].entries(rule.draw)), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                                var _step5$value = _slicedToArray(_step5.value, 2);

                                var _name = _step5$value[0];
                                var group = _step5$value[1];

                                // TODO: warn on non-object draw group
                                if (group != null && typeof group === 'object' && group.visible !== false) {
                                    var style_name = group.style || _name;
                                    var styles = [style_name];

                                    // optional additional outline style
                                    if (group.outline && group.outline.style) {
                                        styles.push(group.outline.style);
                                    }

                                    styles = styles.filter(function (x) {
                                        return _this10.styles[x];
                                    }).forEach(function (style_name) {
                                        var style = _this10.styles[style_name];
                                        if (style) {
                                            _this10.active_styles[style_name] = true;
                                            if (style.animated) {
                                                animated = true;
                                            }
                                        }
                                    });
                                }
                            }
                        } catch (err) {
                            _didIteratorError5 = true;
                            _iteratorError5 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion5 && _iterator5['return']) {
                                    _iterator5['return']();
                                }
                            } finally {
                                if (_didIteratorError5) {
                                    throw _iteratorError5;
                                }
                            }
                        }
                    }
                }

                // Use explicitly set scene animation flag if defined, otherwise turn on animation
                // if there are any animated styles
            } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                        _iterator4['return']();
                    }
                } finally {
                    if (_didIteratorError4) {
                        throw _iteratorError4;
                    }
                }
            }

            this.animated = this.config.scene.animated !== undefined ? this.config.scene.animated : animated;

            // Compile newly active styles
            return _Object$keys(this.active_styles).filter(function (s) {
                return prev_styles.indexOf(s) === -1;
            });
        }

        // Get active camera - for public API
    }, {
        key: 'getActiveCamera',
        value: function getActiveCamera() {
            return this.view.getActiveCamera();
        }

        // Set active camera - for public API
    }, {
        key: 'setActiveCamera',
        value: function setActiveCamera(name) {
            return this.view.setActiveCamera(name);
        }

        // Create lighting
    }, {
        key: 'createLights',
        value: function createLights() {
            this.lights = {};
            for (var i in this.config.lights) {
                if (!this.config.lights[i] || typeof this.config.lights[i] !== 'object') {
                    continue;
                }
                var light = this.config.lights[i];
                light.name = i.replace('-', '_'); // light names are injected in shaders, can't have hyphens
                light.visible = light.visible === false ? false : true;
                if (light.visible) {
                    this.lights[light.name] = _light2['default'].create(this.view, light);
                }
            }
            _light2['default'].inject(this.lights);
        }

        // Set background color
    }, {
        key: 'setBackground',
        value: function setBackground() {
            var bg = this.config.scene.background;
            this.background = {};
            if (bg && bg.color) {
                this.background.color = _stylesStyle_parser.StyleParser.parseColor(bg.color);
            }
            if (!this.background.color) {
                this.background.color = [0, 0, 0, 0]; // default background TODO: vary w/scene alpha
            }

            // if background is fully opaque, set canvas background to match
            if (this.background.color[3] === 1) {
                this.canvas.style.backgroundColor = 'rgba(' + this.background.color.map(function (c) {
                    return Math.floor(c * 255);
                }).join(', ') + ')';
            } else {
                this.canvas.style.backgroundColor = 'transparent';
            }
        }

        // Update scene config, and optionally rebuild geometry
    }, {
        key: 'updateConfig',
        value: function updateConfig() {
            var _this11 = this;

            var _ref5 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            var rebuild = _ref5.rebuild;

            this.generation++;
            this.updating++;
            this.config.scene = this.config.scene || {};

            _stylesStyle_manager.StyleManager.init();
            this.view.reset();
            this.createLights();
            this.loadDataSources();
            this.loadTextures();
            this.setBackground();

            // TODO: detect changes to styles? already (currently) need to recompile anyway when camera or lights change
            this.updateStyles();

            // Optionally rebuild geometry
            var done = undefined;
            if (rebuild) {
                done = this.rebuildGeometry();
            } else {
                done = this.syncConfigToWorker(); // rebuildGeometry() already syncs config
            }

            // Finish by updating bounds and re-rendering
            return done.then(function () {
                _this11.updating--;
                _this11.view.updateBounds();
                _this11.requestRedraw();
            });
        }

        // Serialize config and send to worker
    }, {
        key: 'syncConfigToWorker',
        value: function syncConfigToWorker() {
            // Tell workers we're about to rebuild (so they can update styles, etc.)
            this.config_serialized = _utilsUtils2['default'].serializeWithFunctions(this.config);
            return _utilsWorker_broker2['default'].postMessage(this.workers, 'self.updateConfig', {
                config: this.config_serialized,
                generation: this.generation
            });
        }
    }, {
        key: 'resetFeatureSelection',
        value: function resetFeatureSelection() {
            if (!this.selection) {
                this.selection = new _selection2['default'](this.gl, this.workers);
            } else if (this.workers) {
                _utilsWorker_broker2['default'].postMessage(this.workers, 'self.resetFeatureSelection');
            }
        }

        // Gets the current feature selection map size across all workers. Returns a promise.
    }, {
        key: 'getFeatureSelectionMapSize',
        value: function getFeatureSelectionMapSize() {
            var _this12 = this;

            if (this.fetching_selection_map) {
                return _Promise.reject();
            }
            this.fetching_selection_map = true;

            return _utilsWorker_broker2['default'].postMessage(this.workers, 'self.getFeatureSelectionMapSize').then(function (sizes) {
                _this12.fetching_selection_map = false;
                return sizes.reduce(function (a, b) {
                    return a + b;
                });
            });
        }

        // Reset internal clock, mostly useful for consistent experience when changing styles/debugging
    }, {
        key: 'resetTime',
        value: function resetTime() {
            this.start_time = +new Date();
        }

        // Fires event when rendered tile set or style changes
    }, {
        key: 'updateViewComplete',
        value: function updateViewComplete() {
            if ((this.render_count_changed || this.generation !== this.last_complete_generation) && !this.tile_manager.isLoadingVisibleTiles()) {
                this.last_complete_generation = this.generation;
                this.trigger('view_complete');
            }
        }
    }, {
        key: 'resetViewComplete',
        value: function resetViewComplete() {
            this.last_complete_generation = null;
        }

        // Take a screenshot
        // Asynchronous because we have to wait for next render to capture buffer
        // Returns a promise
    }, {
        key: 'screenshot',
        value: function screenshot() {
            var _this13 = this;

            if (this.queue_screenshot != null) {
                return this.queue_screenshot.promise; // only capture one screenshot at a time
            }

            this.requestRedraw();

            // Will resolve once rendering is complete and render buffer is captured
            this.queue_screenshot = {};
            this.queue_screenshot.promise = new _Promise(function (resolve, reject) {
                _this13.queue_screenshot.resolve = resolve;
                _this13.queue_screenshot.reject = reject;
            });
            return this.queue_screenshot.promise;
        }

        // Called after rendering, captures render buffer and resolves promise with image data
    }, {
        key: 'completeScreenshot',
        value: function completeScreenshot() {
            if (this.queue_screenshot != null) {
                // Get data URL, convert to blob
                // Strip host/mimetype/etc., convert base64 to binary without UTF-8 mangling
                // Adapted from: https://gist.github.com/unconed/4370822
                var url = this.canvas.toDataURL('image/png');
                var data = atob(url.slice(22));
                var buffer = new Uint8Array(data.length);
                for (var i = 0; i < data.length; ++i) {
                    buffer[i] = data.charCodeAt(i);
                }
                var blob = new Blob([buffer], { type: 'image/png' });

                // Resolve with screenshot data
                this.queue_screenshot.resolve({ url: url, blob: blob });
                this.queue_screenshot = null;
            }
        }

        // Stats/debug/profiling methods

        // Log messages pass through from web workers
    }, {
        key: 'workerLogMessage',
        value: function workerLogMessage(event) {
            var data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data; // optional un-stringify
            if (data.type !== 'log') {
                return;
            }

            var worker_id = data.worker_id;
            var level = data.level;
            var msg = data.msg;

            if (_loglevel2['default'][level]) {
                _loglevel2['default'][level].apply(_loglevel2['default'], ['worker ' + worker_id + ':'].concat(_toConsumableArray(msg)));
            } else {
                _loglevel2['default'].error('Scene.workerLogMessage: unrecognized log level ' + level);
            }
        }

        // Profile helpers, issues a profile on main thread & all workers
    }, {
        key: '_profile',
        value: function _profile(name) {
            console.profile('main thread: ' + name);
            _utilsWorker_broker2['default'].postMessage(this.workers, 'self.profile', name);
        }
    }, {
        key: '_profileEnd',
        value: function _profileEnd(name) {
            console.profileEnd('main thread: ' + name);
            _utilsWorker_broker2['default'].postMessage(this.workers, 'self.profileEnd', name);
        }

        // Debug config and functions
    }, {
        key: 'setupDebug',
        value: function setupDebug() {
            var scene = this;
            this.debug = {
                profile: {
                    geometry_build: false
                },

                // Rebuild geometry a given # of times and print average, min, max timings
                timeRebuild: function timeRebuild() {
                    var num = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];
                    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    var times = [];
                    var cycle = function cycle() {
                        var start = +new Date();
                        scene.rebuild(options).then(function () {
                            times.push(+new Date() - start);

                            if (times.length < num) {
                                cycle();
                            } else {
                                var avg = ~ ~(times.reduce(function (a, b) {
                                    return a + b;
                                }) / times.length);
                                _loglevel2['default'].info('Profiled rebuild ' + num + ' times: ' + avg + ' avg (' + Math.min.apply(Math, times) + ' min, ' + Math.max.apply(Math, times) + ' max)');
                            }
                        });
                    };
                    cycle();
                },

                // Return geometry counts of visible tiles, grouped by style name
                geometryCountByStyle: function geometryCountByStyle() {
                    var counts = {};
                    var _iteratorNormalCompletion6 = true;
                    var _didIteratorError6 = false;
                    var _iteratorError6 = undefined;

                    try {
                        for (var _iterator6 = _getIterator(scene.tile_manager.getRenderableTiles()), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                            var tile = _step6.value;

                            for (var style in tile.meshes) {
                                counts[style] = counts[style] || 0;
                                counts[style] += tile.meshes[style].geometry_count;
                            }
                        }
                    } catch (err) {
                        _didIteratorError6 = true;
                        _iteratorError6 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion6 && _iterator6['return']) {
                                _iterator6['return']();
                            }
                        } finally {
                            if (_didIteratorError6) {
                                throw _iteratorError6;
                            }
                        }
                    }

                    return counts;
                },

                geometryCountByBaseStyle: function geometryCountByBaseStyle() {
                    var style_counts = scene.debug.geometryCountByStyle();
                    var counts = {};
                    for (var style in style_counts) {
                        var base = scene.styles[style].built_in ? style : scene.styles[style].base;
                        counts[base] = counts[base] || 0;
                        counts[base] += style_counts[style];
                    }
                    return counts;
                }
            };
        }
    }], [{
        key: 'create',
        value: function create(config) {
            var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            return new Scene(config, options);
        }
    }]);

    return Scene;
})();

exports['default'] = Scene;
module.exports = exports['default'];

},{"./gl/context":199,"./gl/render_state":202,"./gl/texture":205,"./gl/vao":206,"./light":216,"./scene_loader":220,"./selection":222,"./sources/data_source":223,"./styles/lines/lines":228,"./styles/points/points":230,"./styles/polygons/polygons":231,"./styles/style":233,"./styles/style_manager":234,"./styles/style_parser":235,"./styles/text/text":237,"./tile_manager":240,"./utils/subscribe":246,"./utils/utils":247,"./utils/worker_broker":249,"./view":251,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/keys":12,"babel-runtime/core-js/promise":14,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/interop-require-default":23,"babel-runtime/helpers/sliced-to-array":24,"babel-runtime/helpers/to-consumable-array":25,"loglevel":183}],220:[function(_dereq_,module,exports){
'use strict';

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsUtils = _dereq_('./utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _glGlsl = _dereq_('./gl/glsl');

var _glGlsl2 = _interopRequireDefault(_glGlsl);

// import mergeObjects from './utils/merge';

var _stylesStyle_manager = _dereq_('./styles/style_manager');

var SceneLoader;

exports['default'] = SceneLoader = {

    // Load scenes definitions from URL & proprocess
    loadScene: function loadScene(url) {
        var path = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

        return SceneLoader.loadSceneRecursive(url, path).then(SceneLoader.finalize);
    },

    // Loads scene files from URL, recursively loading 'included' scenes
    // Optional *initial* path only (won't be passed to recursive 'include' calls)
    // Useful for loading resources in base scene file from a separate location
    // (e.g. in Tangram Play, when modified local scene should still refer to original resource URLs)
    loadSceneRecursive: function loadSceneRecursive(url) {
        var path = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

        if (!url) {
            return _Promise.resolve({});
        }

        if (typeof url === 'string') {
            path = path || _utilsUtils2['default'].pathForURL(url);
        }

        return _utilsUtils2['default'].loadResource(url).then(function (config) {
            return _stylesStyle_manager.StyleManager.loadRemoteStyles(config.styles, path).then(function (styles) {
                return _stylesStyle_manager.StyleManager.loadShaderBlocks(styles, path);
            }). // TODO: deprecate remote shader blocks?
            then(function () {
                // accept single-string or array
                // if (typeof config.include === 'string') {
                //     config.include = [config.include];
                // }

                // if (!Array.isArray(config.include)) {
                SceneLoader.normalize(config, path);
                return config;
                // }

                // Collect URLs of scenes to include
                // let includes = [];
                // for (let url of config.include) {
                //     includes.push(Utils.addBaseURL(url, path));
                // }
                // delete config.include; // don't want to merge this property

                // return Promise.
                //     all(includes.map(url => SceneLoader.loadSceneRecursive(url))).
                //     then(configs => {
                //         config = mergeObjects({}, ...configs, config);
                //         SceneLoader.normalize(config, path);
                //         return config;
                //     });
            });
        });
    },

    // Normalize properties that should be adjust within each local scene file (usually by path)
    normalize: function normalize(config, path) {
        SceneLoader.normalizeDataSources(config, path);
        SceneLoader.normalizeTextures(config, path);
        return config;
    },

    // Expand paths for data source
    normalizeDataSources: function normalizeDataSources(config, path) {
        config.sources = config.sources || {};

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = _getIterator(_utilsUtils2['default'].values(config.sources)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var source = _step.value;

                source.url = _utilsUtils2['default'].addBaseURL(source.url, path);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                    _iterator['return']();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        return config;
    },

    // Expand paths and centralize texture definitions for a scene object
    normalizeTextures: function normalizeTextures(config, path) {
        config.textures = config.textures || {};

        if (config.styles) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = _getIterator(_utilsUtils2['default'].entries(config.styles)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var _step2$value = _slicedToArray(_step2.value, 2);

                    var style_name = _step2$value[0];
                    var style = _step2$value[1];

                    if (style.texture) {
                        var tex = style.texture;

                        // Texture by URL, expand relative to scene file
                        if (typeof tex === 'string' && !config.textures[tex]) {
                            var texture_name = '__' + style_name;
                            config.textures[texture_name] = { url: tex };
                            style.texture = texture_name; // point style to location of texture
                        }
                        // Texture by object, move it to the global scene texture set and give it a default name
                        else if (typeof tex === 'object') {
                                var texture_name = '__' + style_name;
                                config.textures[texture_name] = tex;
                                style.texture = texture_name; // point style to location of texture
                            }
                    }

                    // If style has texture uniforms, expand texture URLs relative to scene file
                    if (style.shaders && style.shaders.uniforms) {
                        var _iteratorNormalCompletion3 = true;
                        var _didIteratorError3 = false;
                        var _iteratorError3 = undefined;

                        try {
                            for (var _iterator3 = _getIterator(_glGlsl2['default'].parseUniforms(style.shaders.uniforms)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                var _step3$value = _step3.value;
                                var type = _step3$value.type;
                                var value = _step3$value.value;
                                var key = _step3$value.key;
                                var uniforms = _step3$value.uniforms;

                                if (type === 'sampler2D' && typeof value === 'string' && !config.textures[value]) {
                                    var texture_name = '__' + style_name + '_uniform_' + key;
                                    config.textures[texture_name] = { url: value };
                                    uniforms[key] = texture_name; // point style to location of texture
                                }
                            }
                        } catch (err) {
                            _didIteratorError3 = true;
                            _iteratorError3 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                                    _iterator3['return']();
                                }
                            } finally {
                                if (_didIteratorError3) {
                                    throw _iteratorError3;
                                }
                            }
                        }
                    }

                    // If style has material, expand texture URLs relative to scene file
                    if (style.material) {
                        var _arr = ['emission', 'ambient', 'diffuse', 'specular', 'normal'];

                        for (var _i = 0; _i < _arr.length; _i++) {
                            var prop = _arr[_i];
                            // Material property has a texture
                            if (style.material[prop] != null && style.material[prop].texture) {
                                var tex = style.material[prop].texture;

                                // Texture by URL, expand relative to scene file
                                if (typeof tex === 'string' && !config.textures[tex]) {
                                    var texture_name = '__' + style_name + '_material_' + prop;
                                    config.textures[texture_name] = { url: tex };
                                    style.material[prop].texture = texture_name; // point style to location of texture
                                }
                                // Texture by object, move it to the global scene texture set and give it a default name
                                else if (typeof tex === 'object') {
                                        var texture_name = '__' + style_name + '_material_' + prop;
                                        config.textures[texture_name] = tex;
                                        style.material[prop].texture = texture_name; // point style to location of texture
                                    }
                            }
                        }
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                        _iterator2['return']();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
        }

        // Add path to textures
        if (config.textures) {
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
                for (var _iterator4 = _getIterator(_utilsUtils2['default'].values(config.textures)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var texture = _step4.value;

                    if (texture.url) {
                        texture.url = _utilsUtils2['default'].addBaseURL(texture.url, path);
                    }
                }
            } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                        _iterator4['return']();
                    }
                } finally {
                    if (_didIteratorError4) {
                        throw _iteratorError4;
                    }
                }
            }
        }

        return config;
    },

    // Normalize some scene-wide settings that apply to the final, merged scene
    finalize: function finalize(config) {
        // Assign ids to data sources
        var source_id = 0;
        for (var source in config.sources) {
            config.sources[source].id = source_id++;
        }

        // If only one camera specified, set it as default
        config.cameras = config.cameras || {};
        if (config.camera) {
            config.cameras['default'] = config.camera;
        }

        // If no cameras specified, create one
        if (_Object$keys(config.cameras).length === 0) {
            config.cameras['default'] = {};
        }

        // If no camera set as active, use first one
        var active = false;
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
            for (var _iterator5 = _getIterator(_utilsUtils2['default'].values(config.cameras)), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var camera = _step5.value;

                if (camera.active) {
                    active = true;
                    break;
                }
            }
        } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion5 && _iterator5['return']) {
                    _iterator5['return']();
                }
            } finally {
                if (_didIteratorError5) {
                    throw _iteratorError5;
                }
            }
        }

        if (!active) {
            config.cameras[_Object$keys(config.cameras)[0]].active = true;
        }

        // Ensure top-level properties
        config.lights = config.lights || {};
        config.styles = config.styles || {};

        return config;
    }

};
module.exports = exports['default'];

},{"./gl/glsl":201,"./styles/style_manager":234,"./utils/utils":247,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/keys":12,"babel-runtime/core-js/promise":14,"babel-runtime/helpers/interop-require-default":23,"babel-runtime/helpers/sliced-to-array":24}],221:[function(_dereq_,module,exports){
/*jshint worker: true*/
'use strict';

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsUtils = _dereq_('./utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _utilsWorker_broker = _dereq_('./utils/worker_broker');

var _utilsWorker_broker2 = _interopRequireDefault(_utilsWorker_broker);

// jshint ignore:line

var _utilsMerge = _dereq_('./utils/merge');

var _utilsMerge2 = _interopRequireDefault(_utilsMerge);

var _tile = _dereq_('./tile');

var _tile2 = _interopRequireDefault(_tile);

var _sourcesData_source = _dereq_('./sources/data_source');

var _sourcesData_source2 = _interopRequireDefault(_sourcesData_source);

var _selection = _dereq_('./selection');

var _selection2 = _interopRequireDefault(_selection);

var _stylesStyle_parser = _dereq_('./styles/style_parser');

var _stylesStyle_manager = _dereq_('./styles/style_manager');

var _stylesRule = _dereq_('./styles/rule');

var _glTexture = _dereq_('./gl/texture');

var _glTexture2 = _interopRequireDefault(_glTexture);

var SceneWorker = self;

exports.SceneWorker = SceneWorker;
// Worker functionality will only be defined in worker thread
if (_utilsUtils2['default'].isWorkerThread) {

    _Object$assign(self, {

        FeatureSelection: _selection2['default'],

        sources: {
            tiles: {},
            objects: {}
        },
        styles: {},
        rules: {},
        layers: {},
        tiles: {},
        objects: {},
        config: {}, // raw config (e.g. functions, etc. not expanded)

        // Initialize worker
        init: function init(worker_id, num_workers, device_pixel_ratio) {
            self._worker_id = worker_id;
            self.num_workers = num_workers;
            _utilsUtils2['default'].device_pixel_ratio = device_pixel_ratio;
            _selection2['default'].setPrefix(self._worker_id);
            return worker_id;
        },

        // Starts a config refresh
        updateConfig: function updateConfig(_ref) {
            var config = _ref.config;
            var generation = _ref.generation;

            config = JSON.parse(config);

            self.last_config = (0, _utilsMerge2['default'])({}, self.config);
            self.config = (0, _utilsMerge2['default'])({}, config);
            self.generation = generation;

            // Data block functions are not context wrapped like the rest of the style functions are
            // TODO: probably want a cleaner way to exclude these
            for (var layer in config.layers) {
                if (config.layers[layer]) {
                    config.layers[layer].data = _utilsUtils2['default'].stringsToFunctions(config.layers[layer].data);
                }
            }

            // Create data sources
            config.sources = _utilsUtils2['default'].stringsToFunctions(config.sources); // parse new sources
            self.sources.tiles = {}; // clear previous sources
            for (var _name in config.sources) {
                var source = undefined;
                try {
                    source = _sourcesData_source2['default'].create(_Object$assign({}, config.sources[_name], { name: _name }));
                } catch (e) {
                    continue;
                }

                if (!source) {
                    continue;
                }

                if (source.tiled) {
                    self.sources.tiles[_name] = source;
                } else {
                    // Distribute object sources across workers
                    if (source.id % self.num_workers === self._worker_id) {
                        // Load source if not cached
                        self.sources.objects[_name] = source;
                        if (!self.objects[source.name]) {
                            self.objects[source.name] = {};
                            source.load(self.objects[source.name]);
                        }
                    }
                }
            }

            // Clear tile cache if data source config changed
            if (!self.config.sources || !self.last_config.sources || _Object$keys(self.config.sources).some(function (s) {
                return JSON.stringify(self.config.sources[s]) !== JSON.stringify(self.last_config.sources[s]);
            })) {
                self.tiles = {};
            }

            // Expand styles
            config = _utilsUtils2['default'].stringsToFunctions(config, _stylesStyle_parser.StyleParser.wrapFunction);
            self.styles = _stylesStyle_manager.StyleManager.build(config.styles, { generation: self.generation });

            // Parse each top-level layer as a separate rule tree
            self.layers = config.layers;
            self.rules = (0, _stylesRule.parseRules)(self.layers);

            // Sync tetxure info from main thread
            self.syncing_textures = self.syncTextures(config.textures);

            // Return promise for when config refresh finishes
            self.configuring = self.syncing_textures.then(function () {
                _utilsUtils2['default'].log('debug', 'updated config');
            });
        },

        // Returns a promise that fulfills when config refresh is finished
        awaitConfiguration: function awaitConfiguration() {
            return self.configuring;
        },

        // Build a tile: load from tile source if building for first time, otherwise rebuild with existing data
        buildTile: function buildTile(_ref2) {
            var tile = _ref2.tile;

            // Tile cached?
            if (self.getTile(tile.key) != null) {
                // Already loading?
                if (self.getTile(tile.key).loading === true) {
                    return;
                }
            }

            // Update tile cache
            tile = self.tiles[tile.key] = _Object$assign(self.getTile(tile.key) || {}, tile);

            // Update config (styles, etc.), then build tile
            return self.awaitConfiguration().then(function () {
                // First time building the tile
                if (tile.loaded !== true) {

                    return new _Promise(function (resolve, reject) {

                        tile.loading = true;
                        tile.loaded = false;
                        tile.error = null;

                        self.loadTileSourceData(tile).then(function () {
                            if (!self.getTile(tile.key)) {
                                _utilsUtils2['default'].log('trace', 'stop tile build after data source load because tile was removed: ' + tile.key);
                                return;
                            }

                            // Warn and continue on data source error
                            if (tile.source_data.error) {
                                _utilsUtils2['default'].log('warn', 'tile load error(s) for ' + tile.key + ': ' + tile.source_data.error);
                            }

                            tile.loading = false;
                            tile.loaded = true;
                            _tile2['default'].buildGeometry(tile, self.layers, self.rules, self.styles).then(function (keys) {
                                resolve(_utilsWorker_broker2['default'].returnWithTransferables({ tile: _tile2['default'].slice(tile, keys) }));
                            });
                        })['catch'](function (error) {
                            tile.loading = false;
                            tile.loaded = false;
                            tile.error = error.toString();
                            _utilsUtils2['default'].log('error', 'tile load error for ' + tile.key + ': ' + tile.error + ' at: ' + error.stack);

                            resolve({ tile: _tile2['default'].slice(tile) });
                        });
                    });
                }
                // Tile already loaded, just rebuild
                else {
                        _utilsUtils2['default'].log('trace', 'used worker cache for tile ' + tile.key);

                        // Build geometry
                        return _tile2['default'].buildGeometry(tile, self.layers, self.rules, self.styles).then(function (keys) {
                            return _utilsWorker_broker2['default'].returnWithTransferables({ tile: _tile2['default'].slice(tile, keys) });
                        });
                    }
            });
        },

        // Load this tile's data source
        loadTileSourceData: function loadTileSourceData(tile) {
            if (self.sources.tiles[tile.source]) {
                return self.sources.tiles[tile.source].load(tile);
            } else {
                tile.source_data = { error: 'Data source \'' + tile.source + '\' not found' };
                return _Promise.resolve(tile);
            }
        },

        getTile: function getTile(key) {
            return self.tiles[key];
        },

        // Remove tile
        removeTile: function removeTile(key) {
            var tile = self.tiles[key];

            if (tile != null) {
                // Cancel if loading
                if (tile.loading === true) {
                    _utilsUtils2['default'].log('trace', 'cancel tile load for ' + key);
                    tile.loading = false;
                }

                _tile2['default'].cancel(tile);

                // Remove from cache
                _selection2['default'].clearTile(key);
                delete self.tiles[key];
                _utilsUtils2['default'].log('trace', 'remove tile from cache for ' + key);
            }
        },

        // Get a feature from the selection map
        getFeatureSelection: function getFeatureSelection() {
            var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            var id = _ref3.id;
            var key = _ref3.key;

            var selection = _selection2['default'].map[key];

            return {
                id: id,
                feature: selection && selection.feature
            };
        },

        // Resets the feature selection state
        resetFeatureSelection: function resetFeatureSelection() {
            _selection2['default'].reset();
        },

        // Selection map size for this worker
        getFeatureSelectionMapSize: function getFeatureSelectionMapSize() {
            return _selection2['default'].getMapSize();
        },

        // Texture info needs to be synced from main thread, e.g. width/height, which we only know after the texture loads
        syncTextures: function syncTextures(tex_config) {
            var textures = [];
            if (tex_config) {
                textures.push.apply(textures, _toConsumableArray(_Object$keys(tex_config)));
            }

            _utilsUtils2['default'].log('trace', 'sync textures to worker:', textures);
            if (textures.length > 0) {
                return _glTexture2['default'].syncTexturesToWorker(textures);
            }
            return _Promise.resolve();
        },

        // Sync device pixel ratio from main thread
        updateDevicePixelRatio: function updateDevicePixelRatio(device_pixel_ratio) {
            _utilsUtils2['default'].device_pixel_ratio = device_pixel_ratio;
        },

        // Profiling helpers
        profile: function profile(name) {
            console.profile('worker ' + self._worker_id + ': ' + name);
        },

        profileEnd: function profileEnd(name) {
            console.profileEnd('worker ' + self._worker_id + ': ' + name);
        }

    });

    _utilsWorker_broker2['default'].addTarget('self', self);
}

},{"./gl/texture":205,"./selection":222,"./sources/data_source":223,"./styles/rule":232,"./styles/style_manager":234,"./styles/style_parser":235,"./tile":239,"./utils/merge":244,"./utils/utils":247,"./utils/worker_broker":249,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/keys":12,"babel-runtime/core-js/promise":14,"babel-runtime/helpers/interop-require-default":23,"babel-runtime/helpers/to-consumable-array":25}],222:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _glTexture = _dereq_('./gl/texture');

var _glTexture2 = _interopRequireDefault(_glTexture);

var _utilsWorker_broker = _dereq_('./utils/worker_broker');

var _utilsWorker_broker2 = _interopRequireDefault(_utilsWorker_broker);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var FeatureSelection = (function () {
    function FeatureSelection(gl, workers) {
        _classCallCheck(this, FeatureSelection);

        this.gl = gl;
        this.workers = workers; // pool of workers to request feature look-ups from, keyed by id
        this.init();
    }

    // Static properties

    _createClass(FeatureSelection, [{
        key: 'init',
        value: function init() {
            // Selection state tracking
            this.requests = {}; // pending selection requests
            this.feature = null; // currently selected feature
            this.read_delay = 5; // delay time from selection render to framebuffer sample, to avoid CPU/GPU sync lock
            this.read_delay_timer = null; // current timer (setTimeout) for delayed selection reads

            this.pixel = new Uint8Array(4);
            this.pixel32 = new Float32Array(this.pixel.buffer);

            // Frame buffer for selection
            // TODO: initiate lazily in case we don't need to do any selection
            this.fbo = this.gl.createFramebuffer();
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
            this.fbo_size = { width: 256, height: 256 }; // TODO: make configurable / adaptive based on canvas size
            this.fbo_size.aspect = this.fbo_size.width / this.fbo_size.height;

            // Texture for the FBO color attachment
            var fbo_texture = _glTexture2['default'].create(this.gl, 'selection_fbo', { filtering: 'nearest' });
            fbo_texture.setData(this.fbo_size.width, this.fbo_size.height, null, { filtering: 'nearest' });
            this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, fbo_texture.texture, 0);

            // Renderbuffer for the FBO depth attachment
            var fbo_depth_rb = this.gl.createRenderbuffer();
            this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, fbo_depth_rb);
            this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, this.fbo_size.width, this.fbo_size.height);
            this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, fbo_depth_rb);

            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            if (this.gl && this.fbo) {
                this.gl.deleteFramebuffer(this.fbo);
                this.fbo = null;
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
            }

            // TODO: free texture?
        }
    }, {
        key: 'bind',
        value: function bind() {
            // Switch to FBO
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
            this.gl.viewport(0, 0, this.fbo_size.width, this.fbo_size.height);
        }

        // Request feature selection
        // Runs asynchronously, schedules selection buffer to be updated
    }, {
        key: 'getFeatureAt',
        value: function getFeatureAt(point) {
            var _this = this;

            return new _Promise(function (resolve, reject) {
                // Queue requests for feature selection, and they will be picked up by the render loop
                _this.selection_request_id = _this.selection_request_id + 1 || 0;
                _this.requests[_this.selection_request_id] = {
                    type: 'point',
                    id: _this.selection_request_id,
                    point: point,
                    resolve: resolve,
                    reject: reject
                };
            });
        }

        // Any pending selection requests
    }, {
        key: 'pendingRequests',
        value: function pendingRequests() {
            return this.requests;
        }
    }, {
        key: 'clearPendingRequests',
        value: function clearPendingRequests() {
            for (var r in this.requests) {
                var request = this.requests[r];

                // This request was already sent to the worker, we're just awaiting its reply
                if (request.sent) {
                    continue;
                }

                // Reject request since it will never be fulfilled
                // TODO: pass a reason for rejection?
                request.reject({ request: request });
                delete this.requests[r];
            }
        }

        // Read pending results from the selection buffer. Called after rendering to selection buffer.
    }, {
        key: 'read',
        value: function read() {
            var _this2 = this;

            // Delay reading the pixel result from the selection buffer to avoid CPU/GPU sync lock.
            // Calling readPixels synchronously caused a massive performance hit, presumably since it
            // forced this function to wait for the GPU to finish rendering and retrieve the texture contents.
            if (this.read_delay_timer != null) {
                clearTimeout(this.read_delay_timer);
            }
            this.read_delay_timer = setTimeout(function () {
                var gl = _this2.gl;

                gl.bindFramebuffer(gl.FRAMEBUFFER, _this2.fbo);

                for (var r in _this2.requests) {
                    var request = _this2.requests[r];

                    // This request was already sent to the worker, we're just awaiting its reply
                    if (request.sent) {
                        continue;
                    }

                    // TODO: support other selection types, such as features within a box
                    if (request.type !== 'point') {
                        continue;
                    }

                    // Check selection map against FBO
                    gl.readPixels(Math.floor(request.point.x * _this2.fbo_size.width), Math.floor((1 - request.point.y) * _this2.fbo_size.height), 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, _this2.pixel);
                    var feature_key = _this2.pixel[0] + (_this2.pixel[1] << 8) + (_this2.pixel[2] << 16) + (_this2.pixel[3] << 24) >>> 0;

                    // If feature found, ask appropriate web worker to lookup feature
                    var worker_id = _this2.pixel[3];
                    if (worker_id !== 255) {
                        // 255 indicates an empty selection buffer pixel
                        if (_this2.workers[worker_id] != null) {
                            _utilsWorker_broker2['default'].postMessage(_this2.workers[worker_id], 'self.getFeatureSelection', { id: request.id, key: feature_key }).then(function (message) {
                                _this2.finishRead(message);
                            });
                        }
                    }
                    // No feature found, but still need to resolve promise
                    else {
                            _this2.finishRead({ id: request.id, feature: null });
                        }

                    request.sent = true;
                }

                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }, this.read_delay);
        }

        // Called on main thread when a web worker finds a feature in the selection buffer
    }, {
        key: 'finishRead',
        value: function finishRead(message) {
            var request = this.requests[message.id];
            if (!request) {
                _loglevel2['default'].error("FeatureSelection.finishRead(): could not find message", message);
                return; // request was cleared before it returned
            }

            var feature = message.feature;
            var changed = false;
            if (feature != null && this.feature == null || feature == null && this.feature != null || feature != null && this.feature != null && JSON.stringify(feature) !== JSON.stringify(this.feature)) {
                changed = true;
            }

            this.feature = feature; // store the most recently selected feature

            // Resolve the request
            request.resolve({ feature: feature, changed: changed, request: request });
            delete this.requests[message.id]; // done processing this request
        }

        // Selection map generation
        // Each worker will create its own independent, 'local' selection map

        // Create a unique 32-bit color to identify a feature
        // Workers independently create/modify selection colors in their own threads, but we also
        // need the main thread to know where each feature color originated. To accomplish this,
        // we partition the map by setting the 4th component (alpha channel) to the worker's id.
    }], [{
        key: 'makeEntry',
        value: function makeEntry(tile) {
            // 32-bit color key
            this.map_entry++;
            var ir = this.map_entry & 255;
            var ig = this.map_entry >> 8 & 255;
            var ib = this.map_entry >> 16 & 255;
            var ia = this.map_prefix;
            var r = ir / 255;
            var g = ig / 255;
            var b = ib / 255;
            var a = ia / 255;
            var key = ir + (ig << 8) + (ib << 16) + (ia << 24) >>> 0; // need unsigned right shift to convert to positive #

            this.map[key] = {
                color: [r, g, b, a]
            };
            this.map_size++;

            // Initialize tile-specific tracking info
            if (!this.tiles[tile.key]) {
                this.tiles[tile.key] = {
                    entries: [], // set of feature entries in this thread
                    tile: { // subset of tile properties to pass back with feature
                        key: tile.key,
                        coords: tile.coords,
                        style_zoom: tile.style_zoom,
                        source: tile.source,
                        generation: tile.generation
                    }
                };
            }

            this.tiles[tile.key].entries.push(key);

            return this.map[key];
        }
    }, {
        key: 'makeColor',
        value: function makeColor(feature, tile, context) {
            var selector = this.makeEntry(tile);
            selector.feature = {
                id: feature.id,
                properties: feature.properties,
                layers: context.layers,
                tile: this.tiles[tile.key].tile
            };

            return selector.color;
        }
    }, {
        key: 'reset',
        value: function reset() {
            this.tiles = {};
            this.map = {};
            this.map_size = 0;
            this.map_entry = 0;
        }
    }, {
        key: 'clearTile',
        value: function clearTile(key) {
            var _this3 = this;

            if (this.tiles[key]) {
                this.tiles[key].entries.forEach(function (k) {
                    return delete _this3.map[k];
                });
                this.map_size -= this.tiles[key].entries.length;
                delete this.tiles[key];
            }
        }
    }, {
        key: 'getMapSize',
        value: function getMapSize() {
            return this.map_size;
        }
    }, {
        key: 'setPrefix',
        value: function setPrefix(prefix) {
            this.map_prefix = prefix;
        }
    }]);

    return FeatureSelection;
})();

exports['default'] = FeatureSelection;
FeatureSelection.map = {}; // this will be unique per module instance (so unique per worker)
FeatureSelection.tiles = {}; // selection keys, by tile
FeatureSelection.map_size = 0;
FeatureSelection.map_entry = 0;
FeatureSelection.map_prefix = 0; // set by worker to worker id #
FeatureSelection.defaultColor = [0, 0, 0, 1];
module.exports = exports['default'];

},{"./gl/texture":205,"./utils/worker_broker":249,"babel-runtime/core-js/promise":14,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/interop-require-default":23,"loglevel":183}],223:[function(_dereq_,module,exports){
/*jshint worker: true */
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _geo = _dereq_('../geo');

var _geo2 = _interopRequireDefault(_geo);

var _utilsErrors = _dereq_('../utils/errors');

var _utilsUtils = _dereq_('../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var DataSource = (function () {
    function DataSource(config) {
        _classCallCheck(this, DataSource);

        this.config = config; // save original config
        this.id = config.id;
        this.name = config.name;
        this.pad_scale = config.pad_scale || 0.0001; // scale tile up by small factor to cover seams
        this.default_winding = null; // winding order will adapt to data source

        // Optional function to transform source data
        this.transform = config.transform;
        if (typeof this.transform === 'function') {
            this.transform.bind(this);
        }

        // Optional additional data to pass to the transform function
        this.extra_data = config.extra_data;

        // Optional additional scripts made available to the transform function
        if (typeof importScripts === 'function' && config.scripts) {
            config.scripts.forEach(function (s, si) {
                try {
                    importScripts(s);
                    _utilsUtils2['default'].log('info', 'DataSource: loaded library: ' + s);
                } catch (e) {
                    _utilsUtils2['default'].log('error', 'DataSource: failed to load library: ' + s);
                    _utilsUtils2['default'].log('error', e);
                }
            });
        }

        // overzoom will apply for zooms higher than this
        this.max_zoom = config.max_zoom || _geo2['default'].default_source_max_zoom;
    }

    // Create a tile source by type, factory-style

    _createClass(DataSource, [{
        key: 'load',
        // flip coords positive
        value: function load(dest) {
            var _this = this;

            dest.source_data = {};
            dest.source_data.layers = {};
            dest.pad_scale = this.pad_scale;

            return this._load(dest).then(function (dest) {
                // Post-processing
                for (var layer in dest.source_data.layers) {
                    var data = dest.source_data.layers[layer];
                    if (data && data.features) {
                        data.features.forEach(function (feature) {
                            _geo2['default'].transformGeometry(feature.geometry, function (coord) {
                                // Flip Y coords
                                coord[1] = -coord[1];

                                // Slightly scale up tile to cover seams
                                if (_this.pad_scale) {
                                    coord[0] = Math.round(coord[0] * (1 + _this.pad_scale) - _geo2['default'].tile_scale * _this.pad_scale / 2);
                                    coord[1] = Math.round(coord[1] * (1 + _this.pad_scale) - _geo2['default'].tile_scale * _this.pad_scale / 2);
                                }
                            });

                            // Use first encountered polygon winding order as default for data source
                            _this.updateDefaultWinding(feature.geometry);
                        });
                    }
                }

                dest.default_winding = _this.default_winding || 'CCW';
            });
        }

        // Sub-classes must implement
    }, {
        key: '_load',
        value: function _load(dest) {
            throw new _utilsErrors.MethodNotImplemented('_load');
        }

        // Infer winding for data source from first ring of provided geometry
    }, {
        key: 'updateDefaultWinding',
        value: function updateDefaultWinding(geom) {
            if (this.default_winding == null) {
                if (geom.type === 'Polygon') {
                    this.default_winding = _geo2['default'].ringWinding(geom.coordinates[0]);
                } else if (geom.type === 'MultiPolygon') {
                    this.default_winding = _geo2['default'].ringWinding(geom.coordinates[0][0]);
                }
            }
            return this.default_winding;
        }

        // Register a new data source type, under a type name
    }], [{
        key: 'create',
        value: function create(source) {
            if (DataSource.types[source.type]) {
                return new DataSource.types[source.type](source);
            }
        }

        // Check if a data source definition changed
    }, {
        key: 'changed',
        value: function changed(source, prev_source) {
            if (!source || !prev_source) {
                return true;
            }

            var cur = _Object$assign({}, source.config, { id: null }); // null out ids since we don't want to compare them
            var prev = _Object$assign({}, prev_source.config, { id: null });

            return JSON.stringify(cur) !== JSON.stringify(prev);
        }

        // Mercator projection
    }, {
        key: 'projectData',
        value: function projectData(source) {
            var timer = +new Date();
            for (var t in source.layers) {
                var num_features = source.layers[t].features.length;
                for (var f = 0; f < num_features; f++) {
                    var feature = source.layers[t].features[f];
                    _geo2['default'].transformGeometry(feature.geometry, function (coord) {
                        var _Geo$latLngToMeters = _geo2['default'].latLngToMeters(coord);

                        var _Geo$latLngToMeters2 = _slicedToArray(_Geo$latLngToMeters, 2);

                        var x = _Geo$latLngToMeters2[0];
                        var y = _Geo$latLngToMeters2[1];

                        coord[0] = x;
                        coord[1] = y;
                    });
                }
            }

            if (source.debug !== undefined) {
                source.debug.projection = +new Date() - timer;
            }
        }

        /**
         Re-scale geometries within each source to internal tile units
        */
    }, {
        key: 'scaleData',
        value: function scaleData(source, _ref) {
            var z = _ref.coords.z;
            var min = _ref.min;
            var max = _ref.max;

            var units_per_meter = _geo2['default'].unitsPerMeter(z);
            for (var t in source.layers) {
                var num_features = source.layers[t].features.length;
                for (var f = 0; f < num_features; f++) {
                    var feature = source.layers[t].features[f];
                    _geo2['default'].transformGeometry(feature.geometry, function (coord) {
                        coord[0] = (coord[0] - min.x) * units_per_meter;
                        coord[1] = (coord[1] - min.y) * units_per_meter * -1;
                    });
                }
            }
        }
    }, {
        key: 'register',
        value: function register(type_class, type_name) {
            if (!type_class || !type_name) {
                return;
            }

            DataSource.types[type_name] = type_class;
        }
    }]);

    return DataSource;
})();

exports['default'] = DataSource;

DataSource.types = {}; // set of supported data source classes, referenced by type name

/*** Generic network loading source - abstract class ***/

var NetworkSource = (function (_DataSource) {
    _inherits(NetworkSource, _DataSource);

    function NetworkSource(source) {
        _classCallCheck(this, NetworkSource);

        _get(Object.getPrototypeOf(NetworkSource.prototype), 'constructor', this).call(this, source);
        this.url = _utilsUtils2['default'].addParamsToURL(source.url, source.url_params);
        this.response_type = ""; // use to set explicit XHR type

        if (this.url == null) {
            throw Error('Network data source must provide a `url` property');
        }
    }

    /*** Generic network tile loading - abstract class ***/

    _createClass(NetworkSource, [{
        key: '_load',
        value: function _load(dest) {
            var _this2 = this;

            var url = this.formatUrl(this.url, dest);

            var source_data = dest.source_data;
            source_data.url = url;
            dest.debug = dest.debug || {};
            dest.debug.network = +new Date();

            return new _Promise(function (resolve, reject) {
                source_data.error = null;
                // For testing network errors
                // var promise = Utils.io(url, 60 * 100, this.response_type);
                // if (Math.random() < .7) {
                //     promise = Promise.reject(Error('fake data source error'));
                // }
                // promise.then((body) => {
                var promise = _utilsUtils2['default'].io(url, 60 * 1000, _this2.response_type);
                source_data.request = promise.request;

                promise.then(function (body) {
                    dest.debug.response_size = body.length || body.byteLength;
                    dest.debug.network = +new Date() - dest.debug.network;
                    dest.debug.parsing = +new Date();
                    _this2.parseSourceData(dest, source_data, body);
                    dest.debug.parsing = +new Date() - dest.debug.parsing;
                    resolve(dest);
                })['catch'](function (error) {
                    source_data.error = error.toString();
                    resolve(dest); // resolve request but pass along error
                });
            });
        }

        // Sub-classes must implement:

    }, {
        key: 'formatUrl',
        value: function formatUrl(url_template, dest) {
            throw new _utilsErrors.MethodNotImplemented('formatUrl');
        }
    }, {
        key: 'parseSourceData',
        value: function parseSourceData(dest, source, reponse) {
            throw new _utilsErrors.MethodNotImplemented('parseSourceData');
        }
    }]);

    return NetworkSource;
})(DataSource);

exports.NetworkSource = NetworkSource;

var NetworkTileSource = (function (_NetworkSource) {
    _inherits(NetworkTileSource, _NetworkSource);

    function NetworkTileSource(source) {
        _classCallCheck(this, NetworkTileSource);

        _get(Object.getPrototypeOf(NetworkTileSource.prototype), 'constructor', this).call(this, source);

        this.tiled = true;
        this.url_hosts = null;
        var host_match = this.url.match(/{s:\[([^}+]+)\]}/);
        if (host_match != null && host_match.length > 1) {
            this.url_hosts = host_match[1].split(',');
            this.next_host = 0;
        }
    }

    _createClass(NetworkTileSource, [{
        key: 'formatUrl',
        value: function formatUrl(url_template, tile) {
            var coords = _geo2['default'].wrapTile(tile.coords, { x: true });
            var url = url_template.replace('{x}', coords.x).replace('{y}', coords.y).replace('{z}', coords.z);

            if (this.url_hosts != null) {
                url = url.replace(/{s:\[([^}+]+)\]}/, this.url_hosts[this.next_host]);
                this.next_host = (this.next_host + 1) % this.url_hosts.length;
            }
            return url;
        }

        // Checks for the x/y/z tile pattern in URL template
    }, {
        key: 'urlHasTilePattern',
        value: function urlHasTilePattern(url) {
            return url && url.search('{x}') > -1 && url.search('{y}') > -1 && url.search('{z}') > -1;
        }
    }]);

    return NetworkTileSource;
})(NetworkSource);

exports.NetworkTileSource = NetworkTileSource;

},{"../geo":197,"../utils/errors":242,"../utils/utils":247,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/promise":14,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/get":21,"babel-runtime/helpers/inherits":22,"babel-runtime/helpers/interop-require-default":23,"babel-runtime/helpers/sliced-to-array":24}],224:[function(_dereq_,module,exports){
'use strict';

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _data_source = _dereq_('./data_source');

var _data_source2 = _interopRequireDefault(_data_source);

var _mvt = _dereq_('./mvt');

var _geo = _dereq_('../geo');

var _geo2 = _interopRequireDefault(_geo);

// For tiling GeoJSON client-side

var _geojsonVt = _dereq_('geojson-vt');

var _geojsonVt2 = _interopRequireDefault(_geojsonVt);

/**
 GeoJSON standalone (non-tiled) source
 Uses geojson-vt split into tiles client-side
*/

var GeoJSONSource = (function (_NetworkSource) {
    _inherits(GeoJSONSource, _NetworkSource);

    function GeoJSONSource(source) {
        _classCallCheck(this, GeoJSONSource);

        _get(Object.getPrototypeOf(GeoJSONSource.prototype), 'constructor', this).call(this, source);
        this.tiled = true;
        this.load_data = null;
        this.tile_indexes = {}; // geojson-vt tile indices, by layer name
        this.max_zoom = Math.max(this.max_zoom || 0, 15); // TODO: max zoom < 15 causes artifacts/no-draw at 20, investigate
        this.pad_scale = 0; // we don't want padding on auto-tiled sources
    }

    /**
     Mapzen/OSM.US-style GeoJSON vector tiles
     @class GeoJSONTileSource
    */

    _createClass(GeoJSONSource, [{
        key: '_load',
        value: function _load(dest) {
            var _this = this;

            if (!this.load_data) {
                this.load_data = _get(Object.getPrototypeOf(GeoJSONSource.prototype), '_load', this).call(this, { source_data: { layers: {} } }).then(function (data) {
                    var layers = data.source_data.layers;
                    for (var layer_name in layers) {
                        _this.tile_indexes[layer_name] = (0, _geojsonVt2['default'])(layers[layer_name], {
                            maxZoom: _this.max_zoom, // max zoom to preserve detail on
                            tolerance: 3, // simplification tolerance (higher means simpler)
                            extent: _geo2['default'].tile_scale, // tile extent (both width and height)
                            buffer: 0 // tile buffer on each side
                        });
                    }

                    _this.loaded = true;
                    return data;
                });
            }

            return this.load_data.then(function () {
                for (var layer_name in _this.tile_indexes) {
                    dest.source_data.layers[layer_name] = _this.getTileFeatures(dest, layer_name);
                }
                return dest;
            });
        }
    }, {
        key: 'getTileFeatures',
        value: function getTileFeatures(tile, layer_name) {
            var coords = _geo2['default'].wrapTile(tile.coords, { x: true });

            // request a particular tile
            var t = this.tile_indexes[layer_name].getTile(coords.z, coords.x, coords.y);

            // Convert from MVT-style JSON struct to GeoJSON
            var collection = undefined;
            if (t && t.features) {
                collection = {
                    type: 'FeatureCollection',
                    features: []
                };

                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = _getIterator(t.features), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var feature = _step.value;

                        // GeoJSON feature
                        var f = {
                            type: 'Feature',
                            geometry: {},
                            properties: feature.tags
                        };

                        if (feature.type === 1) {
                            f.geometry.coordinates = feature.geometry.map(function (coord) {
                                return [coord[0], coord[1]];
                            });
                            f.geometry.type = 'MultiPoint';
                        } else if (feature.type === 2 || feature.type === 3) {
                            f.geometry.coordinates = feature.geometry.map(function (ring) {
                                return ring.map(function (coord) {
                                    return [coord[0], coord[1]];
                                });
                            });

                            if (feature.type === 2) {
                                f.geometry.type = 'MultiLineString';
                            } else {
                                f.geometry = _mvt.MVTSource.decodeMultiPolygon(f.geometry); // un-flatten rings
                            }
                        } else {
                                continue;
                            }

                        collection.features.push(f);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator['return']) {
                            _iterator['return']();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }

            return collection;
        }
    }, {
        key: 'formatUrl',
        value: function formatUrl(dest) {
            return this.url;
        }
    }, {
        key: 'parseSourceData',
        value: function parseSourceData(tile, source, response) {
            source.layers = this.getLayers(JSON.parse(response));
        }

        // Detect single or multiple layers in returned data
    }, {
        key: 'getLayers',
        value: function getLayers(data) {
            if (data.type === 'Feature' || data.type === 'FeatureCollection') {
                return { _default: data };
            } else {
                return data;
            }
        }
    }]);

    return GeoJSONSource;
})(_data_source.NetworkSource);

exports.GeoJSONSource = GeoJSONSource;

var GeoJSONTileSource = (function (_NetworkTileSource) {
    _inherits(GeoJSONTileSource, _NetworkTileSource);

    function GeoJSONTileSource(source) {
        _classCallCheck(this, GeoJSONTileSource);

        _get(Object.getPrototypeOf(GeoJSONTileSource.prototype), 'constructor', this).call(this, source);

        // Check for URL tile pattern, if not found, treat as standalone GeoJSON/TopoJSON object
        if (!this.urlHasTilePattern(this.url)) {
            // Check instance type from parent class
            if (this instanceof GeoJSONTileSource) {
                // Replace instance type
                return new GeoJSONSource(source);
            } else {
                // Pass back to parent class to instantiate
                return null;
            }
        }
        return this;
    }

    _createClass(GeoJSONTileSource, [{
        key: 'parseSourceData',
        value: function parseSourceData(tile, source, response) {
            var data = JSON.parse(response);
            this.prepareGeoJSON(data, tile, source);
        }
    }, {
        key: 'prepareGeoJSON',
        value: function prepareGeoJSON(data, tile, source) {
            // Apply optional data transform
            if (typeof this.transform === 'function') {
                data = this.transform(data, this.extra_data);
            }

            source.layers = GeoJSONSource.prototype.getLayers(data);

            // A "synthetic" tile that adjusts the tile min anchor to account for tile longitude wrapping
            var anchor = {
                coords: tile.coords,
                min: _geo2['default'].metersForTile(_geo2['default'].wrapTile(tile.coords, { x: true }))
            };

            _data_source2['default'].projectData(source); // mercator projection
            _data_source2['default'].scaleData(source, anchor); // re-scale from meters to local tile coords
        }
    }]);

    return GeoJSONTileSource;
})(_data_source.NetworkTileSource);

exports.GeoJSONTileSource = GeoJSONTileSource;

_data_source2['default'].register(GeoJSONTileSource, 'GeoJSON'); // prefered shorter name
_data_source2['default'].register(GeoJSONTileSource, 'GeoJSONTiles'); // for backwards-compatibility

},{"../geo":197,"./data_source":223,"./mvt":225,"babel-runtime/core-js/get-iterator":2,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/get":21,"babel-runtime/helpers/inherits":22,"babel-runtime/helpers/interop-require-default":23,"geojson-vt":138}],225:[function(_dereq_,module,exports){
'use strict';

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _data_source = _dereq_('./data_source');

var _data_source2 = _interopRequireDefault(_data_source);

var _geo = _dereq_('../geo');

var _geo2 = _interopRequireDefault(_geo);

var _pbf = _dereq_('pbf');

var _pbf2 = _interopRequireDefault(_pbf);

var _vectorTile = _dereq_('vector-tile');

/**
 Mapbox Vector Tile format
 @class MVTSource
*/

var MVTSource = (function (_NetworkTileSource) {
    _inherits(MVTSource, _NetworkTileSource);

    function MVTSource(source) {
        _classCallCheck(this, MVTSource);

        _get(Object.getPrototypeOf(MVTSource.prototype), 'constructor', this).call(this, source);
        this.response_type = "arraybuffer"; // binary data
    }

    _createClass(MVTSource, [{
        key: 'parseSourceData',
        value: function parseSourceData(tile, source, response) {
            // Convert Mapbox vector tile to GeoJSON
            var data = new Uint8Array(response);
            var buffer = new _pbf2['default'](data);
            source.data = new _vectorTile.VectorTile(buffer);
            source.layers = this.toGeoJSON(source.data);
            delete source.data; // comment out to save raw data for debugging
        }

        // Loop through layers/features using Mapbox lib API, convert to GeoJSON features
        // Returns an object with keys for each layer, e.g. { layer: geojson }
    }, {
        key: 'toGeoJSON',
        value: function toGeoJSON(tile) {
            var layers = {};
            for (var l in tile.layers) {
                var layer = tile.layers[l];
                var layer_geojson = {
                    type: 'FeatureCollection',
                    features: []
                };

                for (var f = 0; f < layer.length; f++) {
                    var feature = layer.feature(f);
                    var feature_geojson = {
                        type: 'Feature',
                        geometry: {},
                        properties: feature.properties
                    };

                    var geometry = feature_geojson.geometry;
                    var coordinates = feature.loadGeometry();
                    for (var r = 0; r < coordinates.length; r++) {
                        var ring = coordinates[r];
                        for (var c = 0; c < ring.length; c++) {
                            ring[c] = [ring[c].x, ring[c].y];
                        }
                    }
                    geometry.coordinates = coordinates;

                    if (_vectorTile.VectorTileFeature.types[feature.type] === 'Point') {
                        geometry.type = 'Point';
                        geometry.coordinates = geometry.coordinates[0][0];
                    } else if (_vectorTile.VectorTileFeature.types[feature.type] === 'LineString') {
                        if (coordinates.length === 1) {
                            geometry.type = 'LineString';
                            geometry.coordinates = geometry.coordinates[0];
                        } else {
                            geometry.type = 'MultiLineString';
                        }
                    } else if (_vectorTile.VectorTileFeature.types[feature.type] === 'Polygon') {
                        geometry = MVTSource.decodeMultiPolygon(geometry); // un-flatten rings
                    }

                    layer_geojson.features.push(feature_geojson);
                }
                layers[l] = layer_geojson;
            }
            return layers;
        }

        // Decode multipolygons, which are encoded as a single set of rings
        // Winding order of first ring is assumed to indicate exterior ring,
        // the opposite winding order indicates the start of a new polygon.
    }], [{
        key: 'decodeMultiPolygon',
        value: function decodeMultiPolygon(geom) {
            var polys = [];
            var poly = [];
            var outer_winding = undefined;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = _getIterator(geom.coordinates), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var ring = _step.value;

                    var winding = _geo2['default'].ringWinding(ring);
                    if (winding == null) {
                        continue; // skip zero-area rings
                    }

                    outer_winding = outer_winding || winding; // assume first ring indicates outer ring winding

                    if (winding === outer_winding && poly.length > 0) {
                        polys.push(poly);
                        poly = [];
                    }
                    poly.push(ring);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator['return']) {
                        _iterator['return']();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            if (poly.length > 0) {
                polys.push(poly);
            }

            // Single or multi?
            if (polys.length === 1) {
                geom.type = 'Polygon';
                geom.coordinates = polys[0];
            } else {
                geom.type = 'MultiPolygon';
                geom.coordinates = polys;
            }

            return geom;
        }
    }]);

    return MVTSource;
})(_data_source.NetworkTileSource);

exports.MVTSource = MVTSource;

_data_source2['default'].register(MVTSource, 'MVT');

},{"../geo":197,"./data_source":223,"babel-runtime/core-js/get-iterator":2,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/get":21,"babel-runtime/helpers/inherits":22,"babel-runtime/helpers/interop-require-default":23,"pbf":186,"vector-tile":192}],226:[function(_dereq_,module,exports){
'use strict';

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _data_source = _dereq_('./data_source');

var _data_source2 = _interopRequireDefault(_data_source);

var _geojson = _dereq_('./geojson');

var _topojson = _dereq_('topojson');

var _topojson2 = _interopRequireDefault(_topojson);

/**
 TopoJSON standalone (non-tiled) source
 Uses geojson-vt split into tiles client-side
*/

var TopoJSONSource = (function (_GeoJSONSource) {
    _inherits(TopoJSONSource, _GeoJSONSource);

    function TopoJSONSource() {
        _classCallCheck(this, TopoJSONSource);

        _get(Object.getPrototypeOf(TopoJSONSource.prototype), 'constructor', this).apply(this, arguments);
    }

    /**
     Mapzen/OSM.US-style TopoJSON vector tiles
     @class TopoJSONTileSource
    */

    _createClass(TopoJSONSource, [{
        key: 'parseSourceData',
        value: function parseSourceData(tile, source, response) {
            var data = JSON.parse(response);
            data = this.toGeoJSON(data);
            source.layers = this.getLayers(data);
        }
    }, {
        key: 'toGeoJSON',
        value: function toGeoJSON(data) {
            // Single layer
            if (data.objects && _Object$keys(data.objects).length === 1) {
                var layer = _Object$keys(data.objects)[0];
                data = _topojson2['default'].feature(data, data.objects[layer]);
            }
            // Multiple layers
            else {
                    var layers = {};
                    for (var key in data.objects) {
                        layers[key] = _topojson2['default'].feature(data, data.objects[key]);
                    }
                    data = layers;
                }
            return data;
        }
    }]);

    return TopoJSONSource;
})(_geojson.GeoJSONSource);

exports.TopoJSONSource = TopoJSONSource;

var TopoJSONTileSource = (function (_GeoJSONTileSource) {
    _inherits(TopoJSONTileSource, _GeoJSONTileSource);

    function TopoJSONTileSource(source) {
        _classCallCheck(this, TopoJSONTileSource);

        var _this = _get(Object.getPrototypeOf(TopoJSONTileSource.prototype), 'constructor', this).call(this, source);

        // Replace with non-tiled source if tiled source failed to instantiate
        if (_this !== this) {
            return new TopoJSONSource(source);
        }
    }

    _createClass(TopoJSONTileSource, [{
        key: 'parseSourceData',
        value: function parseSourceData(tile, source, response) {
            var data = JSON.parse(response);
            data = TopoJSONSource.prototype.toGeoJSON(data);
            this.prepareGeoJSON(data, tile, source);
        }
    }]);

    return TopoJSONTileSource;
})(_geojson.GeoJSONTileSource);

exports.TopoJSONTileSource = TopoJSONTileSource;

_data_source2['default'].register(TopoJSONTileSource, 'TopoJSON'); // prefered shorter name
_data_source2['default'].register(TopoJSONTileSource, 'TopoJSONTiles'); // for backwards-compatibility

},{"./data_source":223,"./geojson":224,"babel-runtime/core-js/object/keys":12,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/get":21,"babel-runtime/helpers/inherits":22,"babel-runtime/helpers/interop-require-default":23,"topojson":190}],227:[function(_dereq_,module,exports){
// Geometry building functions

'use strict';

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _vector = _dereq_('../vector');

var _vector2 = _interopRequireDefault(_vector);

var _geo = _dereq_('../geo');

var _geo2 = _interopRequireDefault(_geo);

var _earcut = _dereq_('earcut');

var _earcut2 = _interopRequireDefault(_earcut);

var Builders;
exports['default'] = Builders = {};

Builders.debug = false;

Builders.tile_bounds = [{ x: 0, y: 0 }, { x: _geo2['default'].tile_scale, y: -_geo2['default'].tile_scale } // TODO: correct for flipped y-axis?
];

var default_uvs = [0, 0, 1, 1];
var zero_vec2 = [0, 0];
var up_vec3 = [0, 0, 1];

// Re-scale UVs from [0, 1] range to a smaller area within the image
Builders.getTexcoordsForSprite = function (area_origin, area_size, tex_size) {
    var area_origin_y = tex_size[1] - area_origin[1] - area_size[1];

    return [area_origin[0] / tex_size[0], area_origin_y / tex_size[1], (area_size[0] + area_origin[0]) / tex_size[0], (area_size[1] + area_origin_y) / tex_size[1]];
};

// Tesselate a flat 2D polygon
// x & y coordinates will be set as first two elements of provided vertex_template
Builders.buildPolygons = function (polygons, vertex_data, vertex_template, _ref) {
    var texcoord_index = _ref.texcoord_index;
    var texcoord_scale = _ref.texcoord_scale;
    var texcoord_normalize = _ref.texcoord_normalize;

    if (texcoord_index) {
        texcoord_normalize = texcoord_normalize || 1;

        var _ref2 = texcoord_scale || default_uvs;

        var _ref22 = _slicedToArray(_ref2, 4);

        var min_u = _ref22[0];
        var min_v = _ref22[1];
        var max_u = _ref22[2];
        var max_v = _ref22[3];
    }

    var num_polygons = polygons.length;
    for (var p = 0; p < num_polygons; p++) {
        var polygon = polygons[p];

        // Find polygon extents to calculate UVs, fit them to the axis-aligned bounding box
        if (texcoord_index) {
            var _Geo$findBoundingBox = _geo2['default'].findBoundingBox(polygon);

            var _Geo$findBoundingBox2 = _slicedToArray(_Geo$findBoundingBox, 4);

            var min_x = _Geo$findBoundingBox2[0];
            var min_y = _Geo$findBoundingBox2[1];
            var max_x = _Geo$findBoundingBox2[2];
            var max_y = _Geo$findBoundingBox2[3];

            var span_x = max_x - min_x;
            var span_y = max_y - min_y;
            var scale_u = (max_u - min_u) / span_x;
            var scale_v = (max_v - min_v) / span_y;
        }

        // Tessellate
        var vertices = Builders.triangulatePolygon(polygon);

        // Add vertex data
        var num_vertices = vertices.length;
        for (var v = 0; v < num_vertices; v++) {
            var vertex = vertices[v];
            vertex_template[0] = vertex[0];
            vertex_template[1] = vertex[1];

            // Add UVs
            if (texcoord_index) {
                vertex_template[texcoord_index + 0] = ((vertex[0] - min_x) * scale_u + min_u) * texcoord_normalize;
                vertex_template[texcoord_index + 1] = ((vertex[1] - min_y) * scale_v + min_v) * texcoord_normalize;
            }

            vertex_data.addVertex(vertex_template);
        }
    }
};

// Tesselate and extrude a flat 2D polygon into a simple 3D model with fixed height and add to GL vertex buffer
Builders.buildExtrudedPolygons = function (polygons, z, height, min_height, vertex_data, vertex_template, normal_index, normal_normalize, _ref3) {
    var remove_tile_edges = _ref3.remove_tile_edges;
    var tile_edge_tolerance = _ref3.tile_edge_tolerance;
    var texcoord_index = _ref3.texcoord_index;
    var texcoord_scale = _ref3.texcoord_scale;
    var texcoord_normalize = _ref3.texcoord_normalize;
    var winding = _ref3.winding;

    // Top
    var min_z = z + (min_height || 0);
    var max_z = z + height;
    vertex_template[2] = max_z;
    Builders.buildPolygons(polygons, vertex_data, vertex_template, { texcoord_index: texcoord_index, texcoord_scale: texcoord_scale, texcoord_normalize: texcoord_normalize });

    // Walls
    // Fit UVs to wall quad
    if (texcoord_index) {
        texcoord_normalize = texcoord_normalize || 1;

        var _ref4 = texcoord_scale || default_uvs;

        var _ref42 = _slicedToArray(_ref4, 4);

        var min_u = _ref42[0];
        var min_v = _ref42[1];
        var max_u = _ref42[2];
        var max_v = _ref42[3];

        var texcoords = [[min_u, max_v], [min_u, min_v], [max_u, min_v], [max_u, min_v], [max_u, max_v], [min_u, max_v]];
    }

    var num_polygons = polygons.length;
    for (var p = 0; p < num_polygons; p++) {
        var polygon = polygons[p];

        for (var q = 0; q < polygon.length; q++) {
            var contour = polygon[q];

            for (var w = 0; w < contour.length - 1; w++) {
                if (remove_tile_edges && Builders.outsideTile(contour[w], contour[w + 1], tile_edge_tolerance)) {
                    continue; // don't extrude tile edges
                }

                // Wall order is dependent on winding order, so that normals face outward
                var w0 = undefined,
                    w1 = undefined;
                if (winding === 'CCW') {
                    w0 = w;
                    w1 = w + 1;
                } else {
                    w0 = w + 1;
                    w1 = w;
                }

                // Two triangles for the quad formed by each vertex pair, going from bottom to top height
                var wall_vertices = [
                // Triangle
                [contour[w1][0], contour[w1][1], max_z], [contour[w1][0], contour[w1][1], min_z], [contour[w0][0], contour[w0][1], min_z],
                // Triangle
                [contour[w0][0], contour[w0][1], min_z], [contour[w0][0], contour[w0][1], max_z], [contour[w1][0], contour[w1][1], max_z]];

                // Calc the normal of the wall from up vector and one segment of the wall triangles
                var wall_vec = _vector2['default'].normalize([contour[w1][0] - contour[w0][0], contour[w1][1] - contour[w0][1], 0]);
                var normal = _vector2['default'].cross(up_vec3, wall_vec);

                // Update vertex template with current surface normal
                vertex_template[normal_index + 0] = normal[0] * normal_normalize;
                vertex_template[normal_index + 1] = normal[1] * normal_normalize;
                vertex_template[normal_index + 2] = normal[2] * normal_normalize;

                for (var wv = 0; wv < wall_vertices.length; wv++) {
                    vertex_template[0] = wall_vertices[wv][0];
                    vertex_template[1] = wall_vertices[wv][1];
                    vertex_template[2] = wall_vertices[wv][2];

                    if (texcoord_index) {
                        vertex_template[texcoord_index + 0] = texcoords[wv][0] * texcoord_normalize;
                        vertex_template[texcoord_index + 1] = texcoords[wv][1] * texcoord_normalize;
                    }

                    vertex_data.addVertex(vertex_template);
                }
            }
        }
    }
};

// Build tessellated triangles for a polyline
var cornersForCap = {
    butt: 0,
    square: 2,
    round: 3
};

var trianglesForJoin = {
    miter: 0,
    bevel: 1,
    round: 3
};

Builders.buildPolylines = function (lines, width, vertex_data, vertex_template, _ref5) {
    var closed_polygon = _ref5.closed_polygon;
    var remove_tile_edges = _ref5.remove_tile_edges;
    var tile_edge_tolerance = _ref5.tile_edge_tolerance;
    var texcoord_index = _ref5.texcoord_index;
    var texcoord_scale = _ref5.texcoord_scale;
    var texcoord_normalize = _ref5.texcoord_normalize;
    var scaling_index = _ref5.scaling_index;
    var scaling_normalize = _ref5.scaling_normalize;
    var join = _ref5.join;
    var cap = _ref5.cap;
    var miter_limit = _ref5.miter_limit;

    var cornersOnCap = cornersForCap[cap] || 0; // default 'butt'
    var trianglesOnJoin = trianglesForJoin[join] || 0; // default 'miter'

    // Configure miter limit
    if (trianglesOnJoin === 0) {
        miter_limit = miter_limit || 3; // default miter limit
        var miter_len_sq = miter_limit * miter_limit;
    }

    // Build variables
    if (texcoord_index) {
        texcoord_normalize = texcoord_normalize || 1;

        var _ref6 = texcoord_scale || default_uvs;

        var _ref62 = _slicedToArray(_ref6, 4);

        var min_u = _ref62[0];
        var min_v = _ref62[1];
        var max_u = _ref62[2];
        var max_v = _ref62[3];
    }

    // Values that are constant for each line and are passed to helper functions
    var constants = {
        vertex_data: vertex_data,
        vertex_template: vertex_template,
        halfWidth: width / 2,
        vertices: [],
        scaling_index: scaling_index,
        scaling_normalize: scaling_normalize,
        scalingVecs: scaling_index && [],
        texcoord_index: texcoord_index,
        texcoords: texcoord_index && [],
        texcoord_normalize: texcoord_normalize,
        min_u: min_u, min_v: min_v, max_u: max_u, max_v: max_v,
        nPairs: 0
    };

    for (var ln = 0; ln < lines.length; ln++) {
        // Remove dupe points from lines
        var line = dedupeLine(lines[ln], closed_polygon);
        if (!line) {
            continue; // skip if no valid line remaining
        }

        var lineSize = line.length;

        // Ignore non-lines
        if (lineSize < 2) {
            continue;
        }

        //  Initialize variables
        var coordPrev = [0, 0],
            // Previous point coordinates
        coordCurr = [0, 0],
            // Current point coordinates
        coordNext = [0, 0]; // Next point coordinates

        var normPrev = [0, 0],
            // Right normal to segment between previous and current m_points
        normCurr = [0, 0],
            // Right normal at current point, scaled for miter joint
        normNext = [0, 0]; // Right normal to segment between current and next m_points

        var isPrev = false,
            isNext = true;

        // Add vertices to buffer according to their index
        indexPairs(constants);

        // Do this with the rest (except the last one)
        for (var i = 0; i < lineSize; i++) {

            // There is a next one?
            isNext = i + 1 < lineSize;

            if (isPrev) {
                // If there is a previous one, copy the current (previous) values on *Prev
                coordPrev = coordCurr;
                normPrev = _vector2['default'].normalize(_vector2['default'].perp(coordPrev, line[i]));
            } else if (i === 0 && closed_polygon === true) {
                // If it's the first point and is a closed polygon

                var needToClose = true;
                if (remove_tile_edges) {
                    if (Builders.outsideTile(line[i], line[lineSize - 2], tile_edge_tolerance)) {
                        needToClose = false;
                    }
                }

                if (needToClose) {
                    coordPrev = line[lineSize - 2];
                    normPrev = _vector2['default'].normalize(_vector2['default'].perp(coordPrev, line[i]));
                    isPrev = true;
                }
            }

            // Assign current coordinate
            coordCurr = line[i];

            if (isNext) {
                coordNext = line[i + 1];
            } else if (closed_polygon === true) {
                // If it's the last point in a closed polygon
                coordNext = line[1];
                isNext = true;
            }

            if (isNext) {
                // If it's not the last one get next coordinates and calculate the right normal

                normNext = _vector2['default'].normalize(_vector2['default'].perp(coordCurr, coordNext));
                if (remove_tile_edges) {
                    if (Builders.outsideTile(coordCurr, coordNext, tile_edge_tolerance)) {
                        normCurr = _vector2['default'].normalize(_vector2['default'].perp(coordPrev, coordCurr));
                        if (isPrev) {
                            addVertexPair(coordCurr, normCurr, i / lineSize, constants);
                            constants.nPairs++;

                            // Add vertices to buffer acording their index
                            indexPairs(constants);
                        }
                        isPrev = false;
                        continue;
                    }
                }
            }

            //  Compute current normal
            if (isPrev) {
                //  If there is a PREVIOUS ...
                if (isNext) {
                    // ... and a NEXT ONE, compute previous and next normals (scaled by the angle with the last prev)
                    normCurr = _vector2['default'].normalize(_vector2['default'].add(normPrev, normNext));
                    var scale = 2 / (1 + Math.abs(_vector2['default'].dot(normPrev, normCurr)));
                    normCurr = _vector2['default'].mult(normCurr, scale * scale);
                } else {
                    // ... and there is NOT a NEXT ONE, copy the previous next one (which is the current one)
                    normCurr = _vector2['default'].normalize(_vector2['default'].perp(coordPrev, coordCurr));
                }
            } else {
                // If there is NO PREVIOUS ...
                if (isNext) {
                    // ... and a NEXT ONE,
                    normNext = _vector2['default'].normalize(_vector2['default'].perp(coordCurr, coordNext));
                    normCurr = normNext;
                } else {
                    // ... and NO NEXT ONE, nothing to do (without prev or next one this is just a point)
                    continue;
                }
            }

            if (isPrev || isNext) {
                // If it's the BEGINNING of a LINE
                if (i === 0 && !isPrev && !closed_polygon) {
                    addCap(coordCurr, normCurr, cornersOnCap, true, constants);
                }

                //  Miter limit: if miter join is too sharp, convert to bevel instead
                if (trianglesOnJoin === 0 && _vector2['default'].lengthSq(normCurr) > miter_len_sq) {
                    trianglesOnJoin = trianglesForJoin['bevel']; // switch to bevel
                }

                // If it's a JOIN
                if (trianglesOnJoin !== 0 && isPrev && isNext) {
                    addJoin([coordPrev, coordCurr, coordNext], [normPrev, normCurr, normNext], i / lineSize, trianglesOnJoin, constants);
                } else {
                    addVertexPair(coordCurr, normCurr, i / (lineSize - 1), constants);
                }

                if (isNext) {
                    constants.nPairs++;
                }

                isPrev = true;
            }
        }

        // Add vertices to buffer according to their index
        indexPairs(constants);

        // If it's the END of a LINE
        if (!closed_polygon) {
            addCap(coordCurr, normCurr, cornersOnCap, false, constants);
        }
    }
};

// Remove duplicate points from a line, creating a new line only when points must be removed
function dedupeLine(line, closed) {
    var i = undefined,
        dupes = undefined;

    // Collect dupe points
    for (i = 0; i < line.length - 1; i++) {
        if (line[i][0] === line[i + 1][0] && line[i][1] === line[i + 1][1]) {
            dupes = dupes || [];
            dupes.push(i);
        }
    }

    // Remove dupe points
    if (dupes) {
        line = line.slice(0);
        dupes.forEach(function (d) {
            return line.splice(d, 1);
        });
    }

    // Line needs at least 2 points, polygon needs at least 3 (+1 to close)
    if (!closed && line.length < 2 || closed && line.length < 4) {
        return;
    }
    return line;
}

// Add to equidistant pairs of vertices (internal method for polyline builder)
function addVertex(coord, normal, uv, _ref7) {
    var halfWidth = _ref7.halfWidth;
    var vertices = _ref7.vertices;
    var scalingVecs = _ref7.scalingVecs;
    var texcoords = _ref7.texcoords;

    if (scalingVecs) {
        //  a. If scaling is on add the vertex (the currCoord) and the scaling Vecs (normals pointing where to extrude the vertices)
        vertices.push(coord);
        scalingVecs.push(normal);
    } else {
        //  b. Add the extruded vertices
        vertices.push([coord[0] + normal[0] * halfWidth, coord[1] + normal[1] * halfWidth]);
    }

    // c) Add UVs if they are enabled
    if (texcoords) {
        texcoords.push(uv);
    }
}

//  Add to equidistant pairs of vertices (internal method for polyline builder)
function addVertexPair(coord, normal, v_pct, constants) {
    if (constants.texcoords) {
        addVertex(coord, normal, [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v], constants);
        addVertex(coord, _vector2['default'].neg(normal), [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v], constants);
    } else {
        addVertex(coord, normal, null, constants);
        addVertex(coord, _vector2['default'].neg(normal), null, constants);
    }
}

//  Tessalate a FAN geometry between points A       B
//  using their normals from a center        \ . . /
//  and interpolating their UVs               \ p /
//                                             \./
//                                              C
function addFan(coord, nA, nC, nB, uA, uC, uB, signed, numTriangles, constants) {

    if (numTriangles < 1) {
        return;
    }

    // Add previous vertices to buffer and clear the buffers and index pairs
    // because we are going to add more triangles.
    indexPairs(constants);

    // Initial parameters
    var normCurr = _vector2['default'].set(nA);
    var normPrev = [0, 0];

    // Calculate the angle between A and B
    var angle_delta = _vector2['default'].angleBetween(nA, nB);

    // Calculate the angle for each triangle
    var angle_step = angle_delta / numTriangles;

    // Joins that turn left or right behave diferently...
    // triangles need to be rotated in diferent directions
    if (!signed) {
        angle_step *= -1;
    }

    if (constants.texcoords) {
        var uvCurr = _vector2['default'].set(uA);
        var uv_delta = _vector2['default'].div(_vector2['default'].sub(uB, uA), numTriangles);
    }

    //  Add the FIRST and CENTER vertex
    //  The triangles will be composed in a FAN style around it
    addVertex(coord, nC, uC, constants);

    //  Add first corner
    addVertex(coord, normCurr, uA, constants);

    // Iterate through the rest of the corners
    for (var t = 0; t < numTriangles; t++) {
        normPrev = _vector2['default'].normalize(normCurr);
        normCurr = _vector2['default'].rot(_vector2['default'].normalize(normCurr), angle_step); //  Rotate the extrusion normal
        if (constants.texcoords) {
            uvCurr = _vector2['default'].add(uvCurr, uv_delta);
        }
        addVertex(coord, normCurr, uvCurr, constants); //  Add computed corner
    }

    // Index the vertices
    for (var i = 0; i < numTriangles; i++) {
        if (signed) {
            addIndex(i + 2, constants);
            addIndex(0, constants);
            addIndex(i + 1, constants);
        } else {
            addIndex(i + 1, constants);
            addIndex(0, constants);
            addIndex(i + 2, constants);
        }
    }

    // Clear the buffer
    constants.vertices = [];
    if (constants.scalingVecs) {
        constants.scalingVecs = [];
    }
    if (constants.texcoords) {
        constants.texcoords = [];
    }
}

//  addBevel    A ----- B
//             / \ , . / \
//           /   /\   /\  \
//              /  \ /   \ \
//                / C \
function addBevel(coord, nA, nC, nB, uA, uC, uB, signed, constants) {
    // Add previous vertices to buffer and clear the buffers and index pairs
    // because we are going to add more triangles.
    indexPairs(constants);

    //  Add the FIRST and CENTER vertex
    addVertex(coord, nC, uC, constants);
    addVertex(coord, nA, uA, constants);
    addVertex(coord, nB, uB, constants);

    if (signed) {
        addIndex(2, constants);
        addIndex(0, constants);
        addIndex(1, constants);
    } else {
        addIndex(1, constants);
        addIndex(0, constants);
        addIndex(2, constants);
    }

    // Clear the buffer
    constants.vertices = [];
    if (constants.scalingVecs) {
        constants.scalingVecs = [];
    }
    if (constants.texcoords) {
        constants.texcoords = [];
    }
}

//  Tessalate a SQUARE geometry between A and B     + ........+
//  and interpolating their UVs                     : \  2  / :
//                                                  : 1\   /3 :
//                                                  A -- C -- B
function addSquare(coord, nA, nB, uA, uC, uB, signed, constants) {

    // Add previous vertices to buffer and clear the buffers and index pairs
    // because we are going to add more triangles.
    indexPairs(constants);

    // Initial parameters
    var normCurr = _vector2['default'].set(nA);
    var normPrev = [0, 0];
    if (constants.texcoords) {
        var uvCurr = _vector2['default'].set(uA);
        var uv_delta = _vector2['default'].div(_vector2['default'].sub(uB, uA), 4);
    }

    // First and last cap have different directions
    var angle_step = 0.78539816339; // PI/4 = 45 degrees
    if (!signed) {
        angle_step *= -1;
    }

    //  Add the FIRST and CENTER vertex
    //  The triangles will be add in a FAN style around it
    //
    //                       A -- C
    addVertex(coord, zero_vec2, uC, constants);

    //  Add first corner     +
    //                       :
    //                       A -- C
    addVertex(coord, normCurr, uA, constants);

    // Iterate through the rest of the coorners completing the triangles
    // (except the corner 1 to save one triangle to be draw )
    for (var t = 0; t < 4; t++) {

        // 0     1     2
        //  + ........+
        //  : \     / :
        //  :  \   /  :
        //  A -- C -- B  3

        normPrev = _vector2['default'].normalize(normCurr);
        normCurr = _vector2['default'].rot(_vector2['default'].normalize(normCurr), angle_step); //  Rotate the extrusion normal

        if (t === 0 || t === 2) {
            // In order to make this "fan" look like a square the mitters need to be streach
            var scale = 2 / (1 + Math.abs(_vector2['default'].dot(normPrev, normCurr)));
            normCurr = _vector2['default'].mult(normCurr, scale * scale);
        }

        if (constants.texcoords) {
            uvCurr = _vector2['default'].add(uvCurr, uv_delta);
        }

        if (t !== 1) {
            //  Add computed corner (except the corner 1)
            addVertex(coord, normCurr, uvCurr, constants);
        }
    }

    for (var i = 0; i < 3; i++) {
        if (signed) {
            addIndex(i + 2, constants);
            addIndex(0, constants);
            addIndex(i + 1, constants);
        } else {
            addIndex(i + 1, constants);
            addIndex(0, constants);
            addIndex(i + 2, constants);
        }
    }

    // Clear the buffer
    constants.vertices = [];
    if (constants.scalingVecs) {
        constants.scalingVecs = [];
    }
    if (constants.texcoords) {
        constants.texcoords = [];
    }
}

//  Add special joins (not miter) types that require FAN tessellations
//  Using http://www.codeproject.com/Articles/226569/Drawing-polylines-by-tessellation as reference
function addJoin(coords, normals, v_pct, nTriangles, constants) {
    var signed = _vector2['default'].signed_area(coords[0], coords[1], coords[2]) > 0;
    var nA = normals[0],
        // normal to point A (aT)
    nC = _vector2['default'].neg(normals[1]),
        // normal to center (-vP)
    nB = normals[2]; // normal to point B (bT)

    if (constants.texcoords) {
        var uA = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v],
            uC = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v],
            uB = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
    }

    if (signed) {
        addVertex(coords[1], nA, uA, constants);
        addVertex(coords[1], nC, uC, constants);
    } else {
        nA = _vector2['default'].neg(normals[0]);
        nC = normals[1];
        nB = _vector2['default'].neg(normals[2]);

        if (constants.texcoords) {
            uA = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
            uC = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
            uB = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
        }
        addVertex(coords[1], nC, uC, constants);
        addVertex(coords[1], nA, uA, constants);
    }

    if (nTriangles === 1) {
        addBevel(coords[1], nA, nC, nB, uA, uC, uB, signed, constants);
    } else if (nTriangles > 1) {
        addFan(coords[1], nA, nC, nB, uA, uC, uB, signed, nTriangles, constants);
    }

    if (signed) {
        addVertex(coords[1], nB, uB, constants);
        addVertex(coords[1], nC, uC, constants);
    } else {
        addVertex(coords[1], nC, uC, constants);
        addVertex(coords[1], nB, uB, constants);
    }
}

//  Function to add the vertex need for line caps,
//  because re-use the buffers needs to be at the end
function addCap(coord, normal, numCorners, isBeginning, constants) {

    if (numCorners < 1) {
        return;
    }

    // UVs
    var uvA, uvB, uvC;
    if (constants.texcoords) {
        uvC = [constants.min_u + (constants.max_u - constants.min_u) / 2, constants.min_v]; // Center point UVs

        if (isBeginning) {
            uvA = [constants.min_u, constants.min_v]; // Beginning angle UVs
            uvB = [constants.max_u, constants.min_v]; // Ending angle UVs
        } else {
                uvA = [constants.min_u, constants.max_v]; // Begining angle UVs
                uvB = [constants.max_u, constants.max_v]; // Ending angle UVs
            }
    }

    if (numCorners === 2) {
        // If caps are set as squares
        addSquare(coord, _vector2['default'].neg(normal), normal, uvA, uvC, uvB, isBeginning, constants);
    } else {
        // If caps are set as round ( numCorners===3 )
        addFan(coord, _vector2['default'].neg(normal), zero_vec2, normal, uvA, uvC, uvB, isBeginning, numCorners * 2, constants);
    }
}

// Add a vertex based on the index position into the VBO (internal method for polyline builder)
function addIndex(index, _ref8) {
    var vertex_data = _ref8.vertex_data;
    var vertex_template = _ref8.vertex_template;
    var halfWidth = _ref8.halfWidth;
    var vertices = _ref8.vertices;
    var scaling_index = _ref8.scaling_index;
    var scaling_normalize = _ref8.scaling_normalize;
    var scalingVecs = _ref8.scalingVecs;
    var texcoord_index = _ref8.texcoord_index;
    var texcoords = _ref8.texcoords;
    var texcoord_normalize = _ref8.texcoord_normalize;

    // Prevent access to undefined vertices
    if (index >= vertices.length) {
        return;
    }

    // set vertex position
    vertex_template[0] = vertices[index][0];
    vertex_template[1] = vertices[index][1];

    // set UVs
    if (texcoord_index) {
        vertex_template[texcoord_index + 0] = texcoords[index][0] * texcoord_normalize;
        vertex_template[texcoord_index + 1] = texcoords[index][1] * texcoord_normalize;
    }

    // set Scaling vertex (X, Y normal direction + Z halfwidth as attribute)
    if (scaling_index) {
        vertex_template[scaling_index + 0] = scalingVecs[index][0] * scaling_normalize;
        vertex_template[scaling_index + 1] = scalingVecs[index][1] * scaling_normalize;
        vertex_template[scaling_index + 2] = halfWidth;
    }

    //  Add vertex to VBO
    vertex_data.addVertex(vertex_template);
}

// Add the index vertex to the VBO and clean the buffers
function indexPairs(constants) {
    // Add vertices to buffer acording their index
    for (var i = 0; i < constants.nPairs; i++) {
        addIndex(2 * i + 2, constants);
        addIndex(2 * i + 1, constants);
        addIndex(2 * i + 0, constants);

        addIndex(2 * i + 2, constants);
        addIndex(2 * i + 3, constants);
        addIndex(2 * i + 1, constants);
    }

    constants.nPairs = 0;

    // Clean the buffer
    constants.vertices = [];
    if (constants.scalingVecs) {
        constants.scalingVecs = [];
    }
    if (constants.texcoords) {
        constants.texcoords = [];
    }
}

// Build a billboard sprite quad centered on a point. Sprites are intended to be drawn in screenspace, and have
// properties for width, height, angle, and a scale factor that can be used to interpolate the screenspace size
// of a sprite between two zoom levels.
Builders.buildQuadsForPoints = function (points, vertex_data, vertex_template, _ref9, _ref10) {
    var texcoord_index = _ref9.texcoord_index;
    var position_index = _ref9.position_index;
    var shape_index = _ref9.shape_index;
    var offset_index = _ref9.offset_index;
    var quad = _ref10.quad;
    var quad_scale = _ref10.quad_scale;
    var offset = _ref10.offset;
    var angle = _ref10.angle;
    var texcoord_scale = _ref10.texcoord_scale;
    var texcoord_normalize = _ref10.texcoord_normalize;

    var w2 = quad[0] / 2;
    var h2 = quad[1] / 2;
    var scaling = [[-w2, -h2], [w2, -h2], [w2, h2], [-w2, -h2], [w2, h2], [-w2, h2]];

    var texcoords = undefined;
    if (texcoord_index) {
        texcoord_normalize = texcoord_normalize || 1;

        var _ref11 = texcoord_scale || default_uvs;

        var _ref112 = _slicedToArray(_ref11, 4);

        var min_u = _ref112[0];
        var min_v = _ref112[1];
        var max_u = _ref112[2];
        var max_v = _ref112[3];

        texcoords = [[min_u, min_v], [max_u, min_v], [max_u, max_v], [min_u, min_v], [max_u, max_v], [min_u, max_v]];
    }

    var num_points = points.length;
    for (var p = 0; p < num_points; p++) {
        var point = points[p];

        for (var pos = 0; pos < 6; pos++) {
            // Add texcoords
            if (texcoord_index) {
                vertex_template[texcoord_index + 0] = texcoords[pos][0] * texcoord_normalize;
                vertex_template[texcoord_index + 1] = texcoords[pos][1] * texcoord_normalize;
            }

            vertex_template[position_index + 0] = point[0];
            vertex_template[position_index + 1] = point[1];

            vertex_template[shape_index + 0] = scaling[pos][0];
            vertex_template[shape_index + 1] = scaling[pos][1];
            vertex_template[shape_index + 2] = angle;
            vertex_template[shape_index + 3] = quad_scale;

            vertex_template[offset_index + 0] = offset[0];
            vertex_template[offset_index + 1] = offset[1];

            vertex_data.addVertex(vertex_template);
        }
    }
};

/* Utility functions */

// Triangulation using earcut
// https://github.com/mapbox/earcut
Builders.triangulatePolygon = function (contours) {
    return (0, _earcut2['default'])(contours);
};

// Tests if a line segment (from point A to B) is outside the tile bounds
// (within a certain tolerance to account for geometry nearly on tile edges)
Builders.outsideTile = function (_a, _b, tolerance) {
    var tile_min = Builders.tile_bounds[0];
    var tile_max = Builders.tile_bounds[1];

    // TODO: fix flipped Y coords here, confusing with 'max' reference
    if (_a[0] <= tile_min.x + tolerance && _b[0] <= tile_min.x + tolerance || _a[0] >= tile_max.x - tolerance && _b[0] >= tile_max.x - tolerance || _a[1] >= tile_min.y - tolerance && _b[1] >= tile_min.y - tolerance || _a[1] <= tile_max.y + tolerance && _b[1] <= tile_max.y + tolerance) {
        return true;
    }

    return false;
};
module.exports = exports['default'];

},{"../geo":197,"../vector":250,"babel-runtime/helpers/interop-require-default":23,"babel-runtime/helpers/sliced-to-array":24,"earcut":135}],228:[function(_dereq_,module,exports){
// Line rendering style

'use strict';

var _Object$create = _dereq_('babel-runtime/core-js/object/create')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _style = _dereq_('../style');

var _style_parser = _dereq_('../style_parser');

var _style_manager = _dereq_('../style_manager');

var _glConstants = _dereq_('../../gl/constants');

var _glConstants2 = _interopRequireDefault(_glConstants);

// web workers don't have access to GL context, so import all GL constants

var _glVertex_layout = _dereq_('../../gl/vertex_layout');

var _glVertex_layout2 = _interopRequireDefault(_glVertex_layout);

var _builders = _dereq_('../builders');

var _builders2 = _interopRequireDefault(_builders);

var _geo = _dereq_('../../geo');

var _geo2 = _interopRequireDefault(_geo);

var _utilsUtils = _dereq_('../../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var Lines = _Object$create(_style.Style);

exports.Lines = Lines;
_Object$assign(Lines, {
    name: 'lines',
    built_in: true,
    vertex_shader_key: 'styles/polygons/polygons_vertex', // re-use polygon shaders
    fragment_shader_key: 'styles/polygons/polygons_fragment',
    selection: true, // turn feature selection on

    init: function init() {
        _style.Style.init.apply(this, arguments);

        // Basic attributes, others can be added (see texture UVs below)
        var attribs = [{ name: 'a_position', size: 4, type: _glConstants2['default'].SHORT, normalized: true }, { name: 'a_extrude', size: 4, type: _glConstants2['default'].SHORT, normalized: true }, { name: 'a_color', size: 4, type: _glConstants2['default'].UNSIGNED_BYTE, normalized: true }];

        // Tell the shader we want a order in vertex attributes, and to extrude lines
        this.defines.TANGRAM_LAYER_ORDER = true;
        this.defines.TANGRAM_EXTRUDE_LINES = true;

        // Optional feature selection
        if (this.selection) {
            attribs.push({ name: 'a_selection_color', size: 4, type: _glConstants2['default'].UNSIGNED_BYTE, normalized: true });
        }

        // Optional texture UVs
        if (this.texcoords) {
            this.defines.TANGRAM_TEXTURE_COORDS = true;

            // Add vertex attribute for UVs only when needed
            attribs.push({ name: 'a_texcoord', size: 2, type: _glConstants2['default'].UNSIGNED_SHORT, normalized: true });
        }

        this.vertex_layout = new _glVertex_layout2['default'](attribs);

        // Additional single-allocated object used for holding outline style as it is processed
        // Separate from this.feature_style so that outline properties do not overwrite calculated
        // inline properties (outline call is made *within* the inline call)
        this.outline_feature_style = {};
        this.inline_feature_style = this.feature_style; // save reference to main computed style object
    },

    // Calculate width at zoom given in `context`
    calcWidth: function calcWidth(width, context) {
        return width && _style_parser.StyleParser.cacheDistance(width, context) || 0;
    },

    // Calculate width at next zoom (used for line width interpolation)
    calcWidthNextZoom: function calcWidthNextZoom(width, context) {
        context.zoom++;
        var val = this.calcWidth(width, context);
        context.zoom--;
        return val;
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        var style = this.feature_style;

        // line width in meters
        var width = this.calcWidth(rule_style.width, context);
        if (width < 0) {
            return; // skip lines with negative width
        }
        var next_width = this.calcWidthNextZoom(rule_style.next_width, context);

        if (width === 0 && next_width === 0 || next_width < 0) {
            return; // skip lines that don't interpolate to a positive value at next zoom
        }

        // convert to units and relative change from previous zoom
        // NB: multiply by 2 because a given width is twice as big in screen space at the next zoom
        style.width = width * context.units_per_meter;
        style.next_width = next_width * 2 - width;
        style.next_width *= context.units_per_meter;
        style.next_width /= 2; // NB: divide by 2 because extrusion width is halved in builder - remove?

        style.color = this.parseColor(rule_style.color, context);
        if (!style.color) {
            return;
        }

        // height defaults to feature height, but extrude style can dynamically adjust height by returning a number or array (instead of a boolean)
        style.z = rule_style.z && _style_parser.StyleParser.cacheDistance(rule_style.z || 0, context) || _style_parser.StyleParser.defaults.z;
        style.height = feature.properties.height || _style_parser.StyleParser.defaults.height;
        style.extrude = _style_parser.StyleParser.evalProp(rule_style.extrude, context);
        if (style.extrude) {
            if (typeof style.extrude === 'number') {
                style.height = style.extrude;
            } else if (Array.isArray(style.extrude)) {
                style.height = style.extrude[1];
            }
        }

        // Raise line height if extruded
        if (style.extrude && style.height) {
            style.z += style.height;
        }

        style.cap = rule_style.cap;
        style.join = rule_style.join;
        style.miter_limit = rule_style.miter_limit;
        style.tile_edges = rule_style.tile_edges; // usually activated for debugging, or rare visualization needs

        // Construct an outline style
        // Reusable outline style object, marked as already wrapped in cache objects (preprocessed = true)
        style.outline = style.outline || { width: {}, next_width: {}, preprocessed: true };

        if (rule_style.outline && rule_style.outline.color && rule_style.outline.width) {
            // outline width in meters
            // NB: multiply by 2 because outline is applied on both sides of line
            var outline_width = this.calcWidth(rule_style.outline.width, context) * 2;
            var outline_next_width = this.calcWidthNextZoom(rule_style.outline.next_width, context) * 2;

            if (outline_width === 0 && outline_next_width === 0 || outline_width < 0 || outline_next_width < 0) {
                // skip lines that don't interpolate between zero or greater width
                style.outline.width.value = null;
                style.outline.next_width.value = null;
                style.outline.color = null;
            } else {
                // Maintain consistent outline width around the line fill
                style.outline.width.value = outline_width + width;
                style.outline.next_width.value = outline_next_width + next_width;

                style.outline.color = rule_style.outline.color;
                style.outline.cap = rule_style.outline.cap || rule_style.cap;
                style.outline.join = rule_style.outline.join || rule_style.join;
                style.outline.miter_limit = rule_style.outline.miter_limit || rule_style.miter_limit;
                style.outline.style = rule_style.outline.style || this.name;

                // Explicitly defined outline order, or inherited from inner line
                if (rule_style.outline.order) {
                    style.outline.order = this.parseOrder(rule_style.outline.order, context);
                } else {
                    style.outline.order = style.order;
                }

                // Don't let outline be above inner line
                if (style.outline.order > style.order) {
                    style.outline.order = style.order;
                }

                // Outlines are always at half-layer intervals to avoid conflicting with inner lines
                style.outline.order -= 0.5;
            }
        } else {
            style.outline.width.value = null;
            style.outline.next_width.value = null;
            style.outline.color = null;
        }

        return style;
    },

    _preprocess: function _preprocess(draw) {
        draw.color = _style_parser.StyleParser.colorCacheObject(draw.color);
        draw.width = _style_parser.StyleParser.cacheObject(draw.width, _style_parser.StyleParser.cacheUnits);
        draw.next_width = _style_parser.StyleParser.cacheObject(draw.width, _style_parser.StyleParser.cacheUnits); // width will be computed for next zoom
        draw.z = _style_parser.StyleParser.cacheObject(draw.z, _style_parser.StyleParser.cacheUnits);

        if (draw.outline) {
            draw.outline.color = _style_parser.StyleParser.colorCacheObject(draw.outline.color);
            draw.outline.width = _style_parser.StyleParser.cacheObject(draw.outline.width, _style_parser.StyleParser.cacheUnits);
            draw.outline.next_width = _style_parser.StyleParser.cacheObject(draw.outline.width, _style_parser.StyleParser.cacheUnits); // width re-computed for next zoom
        }
        return draw;
    },

    /**
     * A "template" that sets constant attibutes for each vertex, which is then modified per vertex or per feature.
     * A plain JS array matching the order of the vertex layout.
     */
    makeVertexTemplate: function makeVertexTemplate(style) {
        var i = 0;

        // position - x & y coords will be filled in per-vertex below
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = style.z || 0;

        // layer order - w coord of 'position' attribute (for packing efficiency)
        this.vertex_template[i++] = this.scaleOrder(style.order);

        // extrusion vector
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;

        // scaling to previous and next zoom
        this.vertex_template[i++] = style.next_width;

        // color
        this.vertex_template[i++] = style.color[0] * 255;
        this.vertex_template[i++] = style.color[1] * 255;
        this.vertex_template[i++] = style.color[2] * 255;
        this.vertex_template[i++] = style.color[3] * 255;

        // selection color
        if (this.selection) {
            this.vertex_template[i++] = style.selection_color[0] * 255;
            this.vertex_template[i++] = style.selection_color[1] * 255;
            this.vertex_template[i++] = style.selection_color[2] * 255;
            this.vertex_template[i++] = style.selection_color[3] * 255;
        }

        // Add texture UVs to template only if needed
        if (this.texcoords) {
            this.vertex_template[i++] = 0;
            this.vertex_template[i++] = 0;
        }

        return this.vertex_template;
    },

    buildLines: function buildLines(lines, style, vertex_data, context, options) {
        // Outline (build first so that blended geometry without a depth test is drawn first/under the inner line)
        this.feature_style = this.outline_feature_style; // swap in outline-specific style holder
        if (style.outline && style.outline.color != null && style.outline.width.value != null) {
            var outline_style = _style_manager.StyleManager.styles[style.outline.style];
            if (outline_style) {
                outline_style.addFeature(context.feature, style.outline, context);
            }
        }

        // Main line
        this.feature_style = this.inline_feature_style; // restore calculated style for inline
        var vertex_template = this.makeVertexTemplate(style);
        _builders2['default'].buildPolylines(lines, style.width, vertex_data, vertex_template, {
            cap: style.cap,
            join: style.join,
            miter_limit: style.miter_limit,
            scaling_index: this.vertex_layout.index.a_extrude,
            scaling_normalize: _utilsUtils2['default'].scaleInt16(1, 256), // scale extrusion normals to signed shorts w/256 unit basis
            texcoord_index: this.vertex_layout.index.a_texcoord,
            texcoord_scale: this.texcoord_scale,
            texcoord_normalize: 65535, // scale UVs to unsigned shorts
            closed_polygon: options && options.closed_polygon,
            remove_tile_edges: !style.tile_edges && options && options.remove_tile_edges,
            tile_edge_tolerance: _geo2['default'].tile_scale * context.tile.pad_scale * 4
        });
    },

    buildPolygons: function buildPolygons(polygons, style, vertex_data, context) {
        // Render polygons as individual lines
        for (var p = 0; p < polygons.length; p++) {
            this.buildLines(polygons[p], style, vertex_data, context, { closed_polygon: true, remove_tile_edges: true });
        }
    }

});

},{"../../geo":197,"../../gl/constants":198,"../../gl/vertex_layout":209,"../../utils/utils":247,"../builders":227,"../style":233,"../style_manager":234,"../style_parser":235,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/create":7,"babel-runtime/helpers/interop-require-default":23}],229:[function(_dereq_,module,exports){
// Sets of values to match for directional and corner anchors
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});
var lefts = ['left', 'top-left', 'bottom-left'];
var rights = ['right', 'top-right', 'bottom-right'];
var tops = ['top', 'top-left', 'top-right'];
var bottoms = ['bottom', 'bottom-left', 'bottom-right'];

var PointAnchor;

exports['default'] = PointAnchor = {

    computeOffset: function computeOffset(offset, size, anchor) {
        if (!anchor || anchor === 'center') {
            return offset;
        }

        var offset2 = [offset[0], offset[1]];

        // An optional left/right offset
        if (this.isLeftAnchor(anchor)) {
            offset2[0] -= size[0] / 2;
        } else if (this.isRightAnchor(anchor)) {
            offset2[0] += size[0] / 2;
        }

        // An optional top/bottom offset
        if (this.isTopAnchor(anchor)) {
            offset2[1] -= size[1] / 2;
        } else if (this.isBottomAnchor(anchor)) {
            offset2[1] += size[1] / 2;
        }

        return offset2;
    },

    isLeftAnchor: function isLeftAnchor(anchor) {
        return lefts.indexOf(anchor) > -1;
    },

    isRightAnchor: function isRightAnchor(anchor) {
        return rights.indexOf(anchor) > -1;
    },

    isTopAnchor: function isTopAnchor(anchor) {
        return tops.indexOf(anchor) > -1;
    },

    isBottomAnchor: function isBottomAnchor(anchor) {
        return bottoms.indexOf(anchor) > -1;
    }

};
module.exports = exports['default'];

},{}],230:[function(_dereq_,module,exports){
// Point rendering style

'use strict';

var _Object$create = _dereq_('babel-runtime/core-js/object/create')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _style = _dereq_('../style');

var _style_parser = _dereq_('../style_parser');

var _glConstants = _dereq_('../../gl/constants');

var _glConstants2 = _interopRequireDefault(_glConstants);

// web workers don't have access to GL context, so import all GL constants

var _glVertex_layout = _dereq_('../../gl/vertex_layout');

var _glVertex_layout2 = _interopRequireDefault(_glVertex_layout);

var _builders = _dereq_('../builders');

var _builders2 = _interopRequireDefault(_builders);

var _glTexture = _dereq_('../../gl/texture');

var _glTexture2 = _interopRequireDefault(_glTexture);

var _geo = _dereq_('../../geo');

var _geo2 = _interopRequireDefault(_geo);

var _utilsUtils = _dereq_('../../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _vector = _dereq_('../../vector');

var _vector2 = _interopRequireDefault(_vector);

var _labelsCollision = _dereq_('../../labels/collision');

var _labelsCollision2 = _interopRequireDefault(_labelsCollision);

var _labelsLabel_point = _dereq_('../../labels/label_point');

var _labelsLabel_point2 = _interopRequireDefault(_labelsLabel_point);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var Points = _Object$create(_style.Style);

exports.Points = Points;
_Object$assign(Points, {
    name: 'points',
    built_in: true,
    selection: true, // turn feature selection on
    blend: 'overlay', // overlays drawn on top of all other styles, with blending

    init: function init() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        _style.Style.init.apply(this, arguments);

        // Base shaders
        this.vertex_shader_key = 'styles/points/points_vertex';
        this.fragment_shader_key = 'styles/points/points_fragment';

        var attribs = [{ name: 'a_position', size: 4, type: _glConstants2['default'].SHORT, normalized: true }, { name: 'a_shape', size: 4, type: _glConstants2['default'].SHORT, normalized: true }, { name: 'a_texcoord', size: 2, type: _glConstants2['default'].UNSIGNED_SHORT, normalized: true }, { name: 'a_offset', size: 2, type: _glConstants2['default'].SHORT, normalized: true }, { name: 'a_color', size: 4, type: _glConstants2['default'].UNSIGNED_BYTE, normalized: true }];

        // Optional feature selection
        if (this.selection) {
            attribs.push({ name: 'a_selection_color', size: 4, type: _glConstants2['default'].UNSIGNED_BYTE, normalized: true });
        }

        // If we're not rendering as overlay, we need a layer attribute
        if (this.blend !== 'overlay') {
            this.defines.TANGRAM_LAYER_ORDER = true;
        }

        this.vertex_layout = new _glVertex_layout2['default'](attribs);

        if (this.texture) {
            this.defines.TANGRAM_POINT_TEXTURE = true;
            this.shaders.uniforms = this.shaders.uniforms || {};
            this.shaders.uniforms.u_texture = this.texture;
        }

        this.queues = {};
    },

    reset: function reset() {
        this.queues = {};
    },

    // Override to queue features instead of processing immediately
    addFeature: function addFeature(feature, draw, context) {
        var tile = context.tile;

        // Called here because otherwise it will be delayed until the feature queue is parsed,
        // and we want the preprocessing done before we evaluate text style below
        draw = this.preprocess(draw);
        if (!draw) {
            return;
        }

        var style = {};
        style.color = this.parseColor(draw.color, context);

        // require color or texture
        if (!style.color && !this.texture) {
            return null;
        }

        var sprite = style.sprite = _style_parser.StyleParser.evalProp(draw.sprite, context);
        style.sprite_default = draw.sprite_default; // optional fallback if 'sprite' not found

        // if point has texture and sprites, require a valid sprite to draw
        if (this.texture && _glTexture2['default'].textures[this.texture] && _glTexture2['default'].textures[this.texture].sprites) {
            if (!sprite && !style.sprite_default) {
                return;
            } else if (!_glTexture2['default'].textures[this.texture].sprites[sprite]) {
                // If sprite not found, check for default sprite
                if (style.sprite_default) {
                    sprite = style.sprite_default;
                    if (!_glTexture2['default'].textures[this.texture].sprites[sprite]) {
                        _loglevel2['default'].warn('Style: in style \'' + this.name + '\', could not find default sprite \'' + sprite + '\' for texture \'' + this.texture + '\'');
                        return;
                    }
                } else {
                    _loglevel2['default'].warn('Style: in style \'' + this.name + '\', could not find sprite \'' + sprite + '\' for texture \'' + this.texture + '\'');
                    return;
                }
            }
        } else if (sprite) {
            _loglevel2['default'].warn('Style: in style \'' + this.name + '\', sprite \'' + sprite + '\' was specified, but texture \'' + this.texture + '\' has no sprites');
            sprite = null;
        }

        // Sets texcoord scale if needed (e.g. for sprite sub-area)
        var sprite_info = undefined;
        if (this.texture && sprite) {
            sprite_info = _glTexture2['default'].getSpriteInfo(this.texture, sprite);
            style.texcoords = sprite_info.texcoords;
        } else {
            style.texcoords = null;
        }

        // points can be placed off the ground
        style.z = draw.z && _style_parser.StyleParser.cacheDistance(draw.z, context) || _style_parser.StyleParser.defaults.z;

        // point size defined explicitly, or defaults to sprite size, or generic fallback
        style.size = draw.size;
        if (!style.size) {
            if (sprite_info) {
                style.size = sprite_info.size;
            } else {
                style.size = [16, 16];
            }
        } else {
            style.size = _style_parser.StyleParser.cacheProperty(style.size, context);
        }

        // size will be scaled to 16-bit signed int, so max allowed width + height of 256 pixels
        style.size = [Math.min(style.size[0] || style.size, 256), Math.min(style.size[1] || style.size, 256)];

        style.angle = _style_parser.StyleParser.evalProp(draw.angle, context) || 0;

        // polygons rendering as points will render at the polygon's centroid by default,
        // but can be set to render at each individual polygon point instead
        style.centroid = draw.centroid != null ? draw.centroid : true;

        this.computeLayout(style, feature, draw, context, tile);

        // Queue the feature for processing
        if (!this.tile_data[tile.key]) {
            this.startData(tile);
        }

        if (!this.queues[tile.key]) {
            this.queues[tile.key] = [];
        }

        this.queues[tile.key].push({
            feature: feature, draw: draw, context: context, style: style
        });

        // Register with collision manager
        _labelsCollision2['default'].addStyle(this.name, tile.key);
    },

    // Override
    endData: function endData(tile) {
        var _this = this;

        if (tile.canceled) {
            _utilsUtils2['default'].log('trace', 'Style ' + this.name + ': stop tile build because tile was canceled: ' + tile.key);
            return;
        }

        var queue = this.queues[tile.key];
        this.queues[tile.key] = [];

        // For each feature, create one or more point labels
        var boxes = [];
        queue.forEach(function (q) {
            var style = q.style;
            var feature = q.feature;
            var geometry = feature.geometry;

            var feature_labels = _this.buildLabelsFromGeometry(style.size, geometry, style);
            for (var i = 0; i < feature_labels.length; i++) {
                var label = feature_labels[i];
                boxes.push({
                    feature: feature,
                    draw: q.draw,
                    context: q.context,
                    style: style,
                    layout: style,
                    label: label
                });
            }
        });

        // Submit point labels for collision, then build geometry for remaining ones
        return _labelsCollision2['default'].collide(boxes, this.name, tile.key).then(function (boxes) {
            boxes.forEach(function (q) {
                _this.feature_style = q.style;
                _this.feature_style.label = q.label;

                _style.Style.addFeature.call(_this, q.feature, q.draw, q.context);
            });

            return _style.Style.endData.call(_this, tile);
        });
    },

    _preprocess: function _preprocess(draw) {
        draw.color = _style_parser.StyleParser.colorCacheObject(draw.color);
        draw.z = _style_parser.StyleParser.cacheObject(draw.z, _style_parser.StyleParser.cacheUnits);

        // Size (1d value or 2d array)
        draw.size = _style_parser.StyleParser.cacheObject(draw.size, function (v) {
            return Array.isArray(v) ? v.map(parseFloat) : parseFloat(v);
        });

        // Offset (2d array)
        draw.offset = _style_parser.StyleParser.cacheObject(draw.offset, function (v) {
            return Array.isArray(v) && v.map(parseFloat) || 0;
        });

        // Buffer (1d value or 2d array, expand 1d to 2d)
        draw.buffer = _style_parser.StyleParser.cacheObject(draw.buffer, function (v) {
            return (Array.isArray(v) ? v : [v, v]).map(parseFloat) || 0;
        });

        return draw;
    },

    // Compute label layout-related properties
    computeLayout: function computeLayout(target, feature, draw, context, tile) {
        var layout = target || {};
        layout.id = feature;
        layout.units_per_pixel = tile.units_per_pixel || 1;

        // collision flag
        layout.collide = draw.collide === false ? false : true;

        // label anchors (point labels only)
        // label position will be adjusted in the given direction, relative to its original point
        // one of: left, right, top, bottom, top-left, top-right, bottom-left, bottom-right
        layout.anchor = draw.anchor;

        // label offset and buffer in pixel (applied in screen space)
        layout.offset = _style_parser.StyleParser.cacheProperty(draw.offset, context) || _style_parser.StyleParser.zeroPair;
        layout.buffer = _style_parser.StyleParser.cacheProperty(draw.buffer, context) || _style_parser.StyleParser.zeroPair;

        // label priority (lower is higher)
        var priority = draw.priority;
        if (priority != null) {
            if (typeof priority === 'function') {
                priority = priority(context);
            }
        } else {
            priority = -1 >>> 0; // default to max priority value if none set
        }
        layout.priority = priority;

        return layout;
    },

    // Builds one or more point labels for a geometry
    buildLabelsFromGeometry: function buildLabelsFromGeometry(size, geometry, options) {
        var labels = [];

        if (geometry.type === "Point") {
            labels.push(new _labelsLabel_point2['default'](geometry.coordinates, size, options));
        } else if (geometry.type === "MultiPoint") {
            var points = geometry.coordinates;
            for (var i = 0; i < points.length; ++i) {
                var point = points[i];
                labels.push(new _labelsLabel_point2['default'](point, size, options));
            }
        } else if (geometry.type === "LineString") {
            // Point at each line vertex
            var points = geometry.coordinates;
            for (var i = 0; i < points.length; ++i) {
                labels.push(new _labelsLabel_point2['default'](points[i], size, options));
            }
        } else if (geometry.type === "MultiLineString") {
            // Point at each line vertex
            var lines = geometry.coordinates;
            for (var ln = 0; ln < lines.length; ln++) {
                var points = lines[ln];
                for (var i = 0; i < points.length; ++i) {
                    labels.push(new _labelsLabel_point2['default'](points[i], size, options));
                }
            }
        } else if (geometry.type === "Polygon") {
            // Point at polygon centroid (of outer ring)
            if (options.centroid) {
                var centroid = _geo2['default'].centroid(geometry.coordinates[0]);
                labels.push(new _labelsLabel_point2['default'](centroid, size, options));
            }
            // Point at each polygon vertex (all rings)
            else {
                    var rings = geometry.coordinates;
                    for (var ln = 0; ln < rings.length; ln++) {
                        var points = rings[ln];
                        for (var i = 0; i < points.length; ++i) {
                            labels.push(new _labelsLabel_point2['default'](points[i], size, options));
                        }
                    }
                }
        } else if (geometry.type === "MultiPolygon") {
            var centroid = _geo2['default'].multiCentroid(geometry.coordinates);
            labels.push(new _labelsLabel_point2['default'](centroid, size, options));
        }

        return labels;
    },

    /**
     * A "template" that sets constant attibutes for each vertex, which is then modified per vertex or per feature.
     * A plain JS array matching the order of the vertex layout.
     */
    makeVertexTemplate: function makeVertexTemplate(style) {
        var color = style.color || _style_parser.StyleParser.defaults.color;

        // position - x & y coords will be filled in per-vertex below
        this.fillVertexTemplate('a_position', 0, { size: 2 });
        this.fillVertexTemplate('a_position', style.z || 0, { size: 1, offset: 2 });
        // layer order - w coord of 'position' attribute (for packing efficiency)
        this.fillVertexTemplate('a_position', this.scaleOrder(style.order), { size: 1, offset: 3 });

        // scaling vector - (x, y) components per pixel, z = angle, w = scaling factor
        this.fillVertexTemplate('a_shape', 0, { size: 4 });

        // texture coords
        this.fillVertexTemplate('a_texcoord', 0, { size: 2 });

        // offsets
        this.fillVertexTemplate('a_offset', 0, { size: 2 });

        // color
        this.fillVertexTemplate('a_color', _vector2['default'].mult(color, 255), { size: 4 });

        // selection color
        if (this.selection) {
            this.fillVertexTemplate('a_selection_color', _vector2['default'].mult(style.selection_color, 255), { size: 4 });
        }

        return this.vertex_template;
    },

    buildQuad: function buildQuad(points, size, angle, offset, texcoord_scale, vertex_data, vertex_template) {
        _builders2['default'].buildQuadsForPoints(points, vertex_data, vertex_template, {
            texcoord_index: this.vertex_layout.index.a_texcoord,
            position_index: this.vertex_layout.index.a_position,
            shape_index: this.vertex_layout.index.a_shape,
            offset_index: this.vertex_layout.index.a_offset
        }, {
            quad: [_utilsUtils2['default'].scaleInt16(size[0], 256), _utilsUtils2['default'].scaleInt16(size[1], 256)],
            quad_scale: _utilsUtils2['default'].scaleInt16(1, 256),
            offset: offset,
            angle: _utilsUtils2['default'].scaleInt16(angle, 360),
            texcoord_scale: texcoord_scale,
            texcoord_normalize: 65535
        });
    },

    // Build quad for point sprite
    build: function build(style, vertex_data) {
        var vertex_template = this.makeVertexTemplate(style);
        var label = style.label;

        this.buildQuad([label.position], // position
        style.size, // size in pixels
        style.angle, // angle in degrees
        label.options.offset, // offset from center in pixels
        style.texcoords, // texture UVs
        vertex_data, vertex_template // VBO and data for current vertex
        );
    },

    // Override to pass-through to generic point builder
    buildLines: function buildLines(lines, style, vertex_data) {
        this.build(style, vertex_data);
    },

    buildPoints: function buildPoints(points, style, vertex_data) {
        this.build(style, vertex_data);
    },

    buildPolygons: function buildPolygons(points, style, vertex_data) {
        this.build(style, vertex_data);
    }

});

},{"../../geo":197,"../../gl/constants":198,"../../gl/texture":205,"../../gl/vertex_layout":209,"../../labels/collision":210,"../../labels/label_point":213,"../../utils/utils":247,"../../vector":250,"../builders":227,"../style":233,"../style_parser":235,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/create":7,"babel-runtime/helpers/interop-require-default":23,"loglevel":183}],231:[function(_dereq_,module,exports){
// Polygon rendering style

'use strict';

var _Object$create = _dereq_('babel-runtime/core-js/object/create')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _style = _dereq_('../style');

var _style_parser = _dereq_('../style_parser');

var _glConstants = _dereq_('../../gl/constants');

var _glConstants2 = _interopRequireDefault(_glConstants);

// web workers don't have access to GL context, so import all GL constants

var _glVertex_layout = _dereq_('../../gl/vertex_layout');

var _glVertex_layout2 = _interopRequireDefault(_glVertex_layout);

var _builders = _dereq_('../builders');

var _builders2 = _interopRequireDefault(_builders);

var _geo = _dereq_('../../geo');

var _geo2 = _interopRequireDefault(_geo);

var Polygons = _Object$create(_style.Style);

exports.Polygons = Polygons;
_Object$assign(Polygons, {
    name: 'polygons',
    built_in: true,
    vertex_shader_key: 'styles/polygons/polygons_vertex',
    fragment_shader_key: 'styles/polygons/polygons_fragment',
    selection: true, // turn feature selection on

    init: function init() {
        _style.Style.init.apply(this, arguments);

        // Basic attributes, others can be added (see texture UVs below)
        var attribs = [{ name: 'a_position', size: 4, type: _glConstants2['default'].SHORT, normalized: true }, { name: 'a_normal', size: 3, type: _glConstants2['default'].BYTE, normalized: true }, // gets padded to 4-bytes
        { name: 'a_color', size: 4, type: _glConstants2['default'].UNSIGNED_BYTE, normalized: true }];

        // Tell the shader we have a normal and order attributes
        this.defines.TANGRAM_NORMAL_ATTRIBUTE = true;
        this.defines.TANGRAM_LAYER_ORDER = true;

        // Optional feature selection
        if (this.selection) {
            attribs.push({ name: 'a_selection_color', size: 4, type: _glConstants2['default'].UNSIGNED_BYTE, normalized: true });
        }

        // Optional texture UVs
        if (this.texcoords) {
            this.defines.TANGRAM_TEXTURE_COORDS = true;

            // Add vertex attribute for UVs only when needed
            attribs.push({ name: 'a_texcoord', size: 2, type: _glConstants2['default'].UNSIGNED_SHORT, normalized: true });
        }

        this.vertex_layout = new _glVertex_layout2['default'](attribs);
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        var style = this.feature_style;

        style.color = this.parseColor(rule_style.color, context);
        if (!style.color) {
            return null;
        }

        // height defaults to feature height, but extrude style can dynamically adjust height by returning a number or array (instead of a boolean)
        style.z = rule_style.z && _style_parser.StyleParser.cacheDistance(rule_style.z, context) || _style_parser.StyleParser.defaults.z;
        style.height = feature.properties.height || _style_parser.StyleParser.defaults.height;
        style.min_height = feature.properties.min_height || _style_parser.StyleParser.defaults.min_height;
        style.extrude = _style_parser.StyleParser.evalProp(rule_style.extrude, context);
        if (style.extrude) {
            if (typeof style.extrude === 'number') {
                style.height = style.extrude;
            } else if (Array.isArray(style.extrude)) {
                style.min_height = style.extrude[0];
                style.height = style.extrude[1];
            }
        }

        style.tile_edges = rule_style.tile_edges; // usually activated for debugging, or rare visualization needs

        // style.outline = style.outline || {};
        // if (rule_style.outline) {
        //     style.outline.color = StyleParser.parseColor(rule_style.outline.color, context);
        //     style.outline.width = StyleParser.parseDistance(rule_style.outline.width, context);
        //     style.outline.tile_edges = rule_style.outline.tile_edges;
        //     style.outline.cap = rule_style.outline.cap || rule_style.cap;
        //     style.outline.join = rule_style.outline.join || rule_style.join;
        // }
        // else {
        //     style.outline.color = null;
        //     style.outline.width = null;
        //     style.outline.tile_edges = false;
        // }

        return style;
    },

    _preprocess: function _preprocess(draw) {
        draw.color = _style_parser.StyleParser.colorCacheObject(draw.color);
        draw.z = _style_parser.StyleParser.cacheObject(draw.z, _style_parser.StyleParser.cacheUnits);
        return draw;
    },

    /**
     * A "template" that sets constant attibutes for each vertex, which is then modified per vertex or per feature.
     * A plain JS array matching the order of the vertex layout.
     */
    makeVertexTemplate: function makeVertexTemplate(style) {
        var i = 0;

        // position - x & y coords will be filled in per-vertex below
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = style.z || 0;

        // layer order - w coord of 'position' attribute (for packing efficiency)
        this.vertex_template[i++] = this.scaleOrder(style.order);

        // normal
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 1 * 127;

        // color
        this.vertex_template[i++] = style.color[0] * 255;
        this.vertex_template[i++] = style.color[1] * 255;
        this.vertex_template[i++] = style.color[2] * 255;
        this.vertex_template[i++] = style.color[3] * 255;

        // selection color
        if (this.selection) {
            this.vertex_template[i++] = style.selection_color[0] * 255;
            this.vertex_template[i++] = style.selection_color[1] * 255;
            this.vertex_template[i++] = style.selection_color[2] * 255;
            this.vertex_template[i++] = style.selection_color[3] * 255;
        }

        // Add texture UVs to template only if needed
        if (this.texcoords) {
            this.vertex_template[i++] = 0;
            this.vertex_template[i++] = 0;
        }

        return this.vertex_template;
    },

    buildPolygons: function buildPolygons(polygons, style, vertex_data, context) {
        var vertex_template = this.makeVertexTemplate(style);
        var options = {
            texcoord_index: this.vertex_layout.index.a_texcoord,
            texcoord_scale: this.texcoord_scale,
            texcoord_normalize: 65535, // scale UVs to unsigned shorts
            remove_tile_edges: !style.tile_edges,
            tile_edge_tolerance: _geo2['default'].tile_scale * context.tile.pad_scale * 4,
            winding: context.winding
        };

        // Extruded polygons (e.g. 3D buildings)
        if (style.extrude && style.height) {
            _builders2['default'].buildExtrudedPolygons(polygons, style.z, style.height, style.min_height, vertex_data, vertex_template, this.vertex_layout.index.a_normal, 127, // scale normals to signed bytes
            options);
        }
        // Regular polygons
        else {
                _builders2['default'].buildPolygons(polygons, vertex_data, vertex_template, options);
            }
    }

});

},{"../../geo":197,"../../gl/constants":198,"../../gl/vertex_layout":209,"../builders":227,"../style":233,"../style_parser":235,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/create":7,"babel-runtime/helpers/interop-require-default":23}],232:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.mergeTrees = mergeTrees;
exports.walkUp = walkUp;
exports.walkDown = walkDown;
exports.groupProps = groupProps;
exports.calculateDraw = calculateDraw;
exports.parseRuleTree = parseRuleTree;
exports.parseRules = parseRules;
exports.matchFeature = matchFeature;

var _style_manager = _dereq_('./style_manager');

var _utilsMerge = _dereq_('../utils/merge');

var _utilsMerge2 = _interopRequireDefault(_utilsMerge);

var _matchFeature = _dereq_('match-feature');

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var whiteList = ['filter', 'draw', 'visible', 'data', 'properties'];

exports.whiteList = whiteList;
var ruleCache = {};

exports.ruleCache = ruleCache;
function cacheKey(rules) {
    if (rules.length > 1) {
        var k = rules[0];
        for (var i = 1; i < rules.length; i++) {
            k += '/' + rules[i];
        }

        return k;
    }
    return rules[0];
}

// Merge matching layer rule trees into a final draw group

function mergeTrees(matchingTrees, group) {
    var draws = undefined,
        treeDepth = 0;

    var draw = {
        visible: true // visible by default
    };

    // Find deepest tree
    for (var t = 0; t < matchingTrees.length; t++) {
        if (matchingTrees[t].length > treeDepth) {
            treeDepth = matchingTrees[t].length;
        }
    }

    // No rules to parse
    if (treeDepth === 0) {
        return null;
    }

    // Iterate trees in parallel

    var _loop = function (x) {
        // Pull out the requested draw group, for each tree, at this depth
        draws = matchingTrees.map(function (tree) {
            return tree[x] && tree[x][group];
        });
        if (draws.length === 0) {
            return 'continue';
        }

        // Sort by layer name before merging, so rules are applied deterministically
        // when multiple rules modify the same properties
        draws.sort(function (a, b) {
            return (a && a.layer_name) > (b && b.layer_name) ? 1 : -1;
        });

        // Merge draw objects
        _utilsMerge2['default'].apply(undefined, [draw].concat(_toConsumableArray(draws)));

        // Remove layer names, they were only used transiently to sort and calculate final layer
        // (final merged names will not be accurate since only one tree can win)
        delete draw.layer_name;
    };

    for (var x = 0; x < treeDepth; x++) {
        var _ret = _loop(x);

        if (_ret === 'continue') continue;
    }

    // Short-circuit if not visible
    if (draw.visible === false) {
        return null;
    }

    return draw;
}

var Rule = (function () {
    function Rule(_ref) {
        var name = _ref.name;
        var parent = _ref.parent;
        var draw = _ref.draw;
        var visible = _ref.visible;
        var filter = _ref.filter;
        var properties = _ref.properties;

        _classCallCheck(this, Rule);

        this.id = Rule.id++;
        this.parent = parent;
        this.name = name;
        this.full_name = this.parent ? this.parent.full_name + ':' + this.name : this.name;
        this.draw = draw;
        this.filter = filter;
        this.visible = visible !== undefined ? visible : this.parent && this.parent.visible;
        this.properties = properties !== undefined ? properties : this.parent && this.parent.properties;

        // Denormalize layer name & properties to draw groups
        if (this.draw) {
            for (var group in this.draw) {
                this.draw[group] = this.draw[group] || {};
                this.draw[group].layer_name = this.full_name;

                if (this.properties !== undefined) {
                    this.draw[group].properties = this.properties;
                }
            }
        }

        this.buildFilter();
        this.buildDraw();
    }

    _createClass(Rule, [{
        key: 'buildDraw',
        value: function buildDraw() {
            this.calculatedDraw = calculateDraw(this);
        }
    }, {
        key: 'buildFilter',
        value: function buildFilter() {
            var type = typeof this.filter;
            if (this.filter != null && type !== 'object' && type !== 'function') {
                // Invalid filter
                var msg = 'Filter for layer ' + this.full_name + ' is invalid, filter value must be an object or function, ';
                msg += 'but was set to `filter: ' + this.filter + '` instead';
                _loglevel2['default'].warn(msg);
                return;
            }

            try {
                this.buildZooms();
                this.filter = this.filter && (0, _matchFeature.match)(this.filter);
            } catch (e) {
                // Invalid filter
                var msg = 'Filter for layer ' + this.full_name + ' is invalid, `filter: ' + JSON.stringify(this.filter) + '` ';
                msg += 'failed with error ' + e.message + ', ' + e.stack;
                _loglevel2['default'].warn(msg);
            }
        }

        // Zooms often cull large swaths of the layer rule tree, so they get special treatment and are checked first
    }, {
        key: 'buildZooms',
        value: function buildZooms() {
            var zoom = this.filter && this.filter.$zoom;
            var ztype = typeof zoom;
            if (zoom != null && ztype !== 'function') {
                // don't accelerate function-based filters
                this.zooms = {};

                if (ztype === 'number') {
                    this.zooms[zoom] = true;
                } else if (Array.isArray(zoom)) {
                    for (var z = 0; z < zoom.length; z++) {
                        this.zooms[zoom[z]] = true;
                    }
                } else if (ztype === 'object' && (zoom.min != null || zoom.max != null)) {
                    var zmin = zoom.min || 0;
                    var zmax = zoom.max || 25; // TODO: replace constant for max possible zoom
                    for (var z = zmin; z < zmax; z++) {
                        this.zooms[z] = true;
                    }
                }

                delete this.filter.$zoom; // don't process zoom through usual generic filter logic
            }
        }
    }, {
        key: 'toJSON',
        value: function toJSON() {
            return {
                name: this.name,
                draw: this.draw
            };
        }
    }]);

    return Rule;
})();

Rule.id = 0;

var RuleLeaf = (function (_Rule) {
    _inherits(RuleLeaf, _Rule);

    function RuleLeaf(_ref2) {
        var name = _ref2.name;
        var parent = _ref2.parent;
        var draw = _ref2.draw;
        var visible = _ref2.visible;
        var filter = _ref2.filter;
        var properties = _ref2.properties;

        _classCallCheck(this, RuleLeaf);

        _get(Object.getPrototypeOf(RuleLeaf.prototype), 'constructor', this).call(this, { name: name, parent: parent, draw: draw, visible: visible, filter: filter, properties: properties });
    }

    return RuleLeaf;
})(Rule);

exports.RuleLeaf = RuleLeaf;

var RuleTree = (function (_Rule2) {
    _inherits(RuleTree, _Rule2);

    function RuleTree(_ref3) {
        var name = _ref3.name;
        var parent = _ref3.parent;
        var draw = _ref3.draw;
        var visible = _ref3.visible;
        var rules = _ref3.rules;
        var filter = _ref3.filter;
        var properties = _ref3.properties;

        _classCallCheck(this, RuleTree);

        _get(Object.getPrototypeOf(RuleTree.prototype), 'constructor', this).call(this, { name: name, parent: parent, draw: draw, visible: visible, filter: filter, properties: properties });
        this.rules = rules || [];
    }

    _createClass(RuleTree, [{
        key: 'addRule',
        value: function addRule(rule) {
            this.rules.push(rule);
        }
    }, {
        key: 'buildDrawGroups',
        value: function buildDrawGroups(context) {
            var rules = [],
                rule_ids = [];
            //TODO, should this function take a RuleTree
            matchFeature(context, [this], rules, rule_ids);

            if (rules.length > 0) {
                var cache_key = cacheKey(rule_ids);

                // Only evaluate each rule combination once (undefined means not yet evaluated,
                // null means evaluated with no draw object)
                if (ruleCache[cache_key] === undefined) {
                    // Find all the unique visible draw blocks for this rule tree
                    var draw_rules = rules.map(function (x) {
                        return x && x.visible !== false && x.calculatedDraw;
                    });
                    var draw_keys = {};

                    for (var r = 0; r < draw_rules.length; r++) {
                        var rule = draw_rules[r];
                        if (!rule) {
                            continue;
                        }
                        for (var g = 0; g < rule.length; g++) {
                            var group = rule[g];
                            for (var key in group) {
                                draw_keys[key] = true;
                            }
                        }
                    }

                    // Calculate each draw group
                    for (var draw_key in draw_keys) {
                        ruleCache[cache_key] = ruleCache[cache_key] || {};
                        ruleCache[cache_key][draw_key] = mergeTrees(draw_rules, draw_key);

                        // Only save the ones that weren't null
                        if (!ruleCache[cache_key][draw_key]) {
                            delete ruleCache[cache_key][draw_key];
                        } else {
                            ruleCache[cache_key][draw_key].key = cache_key + '/' + draw_key;
                            ruleCache[cache_key][draw_key].layers = rules.map(function (x) {
                                return x && x.full_name;
                            });
                        }
                    }

                    // No rules evaluated
                    if (ruleCache[cache_key] && _Object$keys(ruleCache[cache_key]).length === 0) {
                        ruleCache[cache_key] = null;
                    }
                }
                return ruleCache[cache_key];
            }
        }
    }]);

    return RuleTree;
})(Rule);

exports.RuleTree = RuleTree;

function isWhiteListed(key) {
    return whiteList.indexOf(key) > -1;
}

function isEmpty(obj) {
    return _Object$keys(obj).length === 0;
}

function walkUp(rule, cb) {

    if (rule.parent) {
        walkUp(rule.parent, cb);
    }

    cb(rule);
}

function walkDown(rule, cb) {

    if (rule.rules) {
        rule.rules.forEach(function (r) {
            walkDown(r, cb);
        });
    }

    cb(rule);
}

function groupProps(obj) {
    var whiteListed = {},
        nonWhiteListed = {};

    for (var key in obj) {
        if (isWhiteListed(key)) {
            whiteListed[key] = obj[key];
        } else {
            nonWhiteListed[key] = obj[key];
        }
    }
    return [whiteListed, nonWhiteListed];
}

function calculateDraw(rule) {

    var draw = [];

    if (rule.parent) {
        var cs = rule.parent.calculatedDraw || [];
        draw.push.apply(draw, _toConsumableArray(cs));
    }

    draw.push(rule.draw);
    return draw;
}

function parseRuleTree(name, rule, parent) {

    var properties = { name: name, parent: parent };

    var _groupProps = groupProps(rule);

    var _groupProps2 = _slicedToArray(_groupProps, 2);

    var whiteListed = _groupProps2[0];
    var nonWhiteListed = _groupProps2[1];

    var empty = isEmpty(nonWhiteListed);
    var Create = undefined;

    if (empty && parent != null) {
        Create = RuleLeaf;
    } else {
        Create = RuleTree;
    }

    var r = new Create(_Object$assign(properties, whiteListed));

    if (parent) {
        parent.addRule(r);
    }

    if (!empty) {
        for (var key in nonWhiteListed) {
            var property = nonWhiteListed[key];
            if (typeof property === 'object' && !Array.isArray(property)) {
                parseRuleTree(key, property, r);
            } else {
                // Invalid layer
                var msg = 'Layer value must be an object: can\'t create layer \'' + key + ': ' + JSON.stringify(property) + '\'';
                msg += ', under parent layer \'' + r.full_name + '\'.';

                // If the parent is a style name, this may be an incorrectly nested layer
                if (_style_manager.Styles[r.name]) {
                    msg += ' The parent \'' + r.name + '\' is also the name of a style, did you mean to create a \'draw\' group';
                    if (parent) {
                        msg += ' under \'' + parent.name + '\'';
                    }
                    msg += ' instead?';
                }
                _loglevel2['default'].warn(msg);
            }
        }
    }

    return r;
}

function parseRules(rules) {
    var ruleTrees = {};

    for (var key in rules) {
        var rule = rules[key];
        if (rule) {
            ruleTrees[key] = parseRuleTree(key, rule);
        }
    }

    return ruleTrees;
}

function doesMatch(rule, context) {
    // zoom pre-filter: skip rest of filter if out of rule zoom range
    if (rule.zooms != null && !rule.zooms[context.zoom]) {
        return false;
    }

    return typeof rule.filter === 'function' && rule.filter(context) || rule.filter == null;
}

function matchFeature(context, rules, collectedRules, collectedRulesIds) {
    var matched = false;
    var childMatched = false;

    if (rules.length === 0) {
        return;
    }

    for (var r = 0; r < rules.length; r++) {
        var current = rules[r];
        context.properties = current.properties;

        if (current instanceof RuleLeaf) {

            if (doesMatch(current, context)) {
                matched = true;
                collectedRules.push(current);
                collectedRulesIds.push(current.id);
            }
        } else if (current instanceof RuleTree) {
            if (doesMatch(current, context)) {
                matched = true;

                childMatched = matchFeature(context, current.rules, collectedRules, collectedRulesIds);

                if (!childMatched) {
                    collectedRules.push(current);
                    collectedRulesIds.push(current.id);
                }
            }
        }

        context.properties = null;
    }

    return matched;
}

},{"../utils/merge":244,"./style_manager":234,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/keys":12,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/get":21,"babel-runtime/helpers/inherits":22,"babel-runtime/helpers/interop-require-default":23,"babel-runtime/helpers/sliced-to-array":24,"babel-runtime/helpers/to-consumable-array":25,"loglevel":183,"match-feature":184}],233:[function(_dereq_,module,exports){
// Rendering styles

'use strict';

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _style_parser = _dereq_('./style_parser');

var _selection = _dereq_('../selection');

var _selection2 = _interopRequireDefault(_selection);

var _glShader_program = _dereq_('../gl/shader_program');

var _glShader_program2 = _interopRequireDefault(_glShader_program);

var _glVbo_mesh = _dereq_('../gl/vbo_mesh');

var _glVbo_mesh2 = _interopRequireDefault(_glVbo_mesh);

var _glTexture = _dereq_('../gl/texture');

var _glTexture2 = _interopRequireDefault(_glTexture);

var _material = _dereq_('../material');

var _material2 = _interopRequireDefault(_material);

var _light = _dereq_('../light');

var _light2 = _interopRequireDefault(_light);

var _glShader_sources = _dereq_('../gl/shader_sources');

var _glShader_sources2 = _interopRequireDefault(_glShader_sources);

// built-in shaders

var _utilsUtils = _dereq_('../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

// Base class

var Style = {
    init: function init() {
        var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        var generation = _ref.generation;

        if (!this.isBuiltIn()) {
            this.built_in = false; // explicitly set to false to avoid any confusion
        }

        this.generation = generation; // scene generation id this style was created for
        this.defines = this.hasOwnProperty('defines') && this.defines || {}; // #defines to be injected into the shaders
        this.shaders = this.hasOwnProperty('shaders') && this.shaders || {}; // shader customization (uniforms, defines, blocks, etc.)
        this.selection = this.selection || false; // flag indicating if this style supports feature selection
        this.compiling = false; // programs are currently compiling
        this.compiled = false; // programs are finished compiling
        this.program = null; // GL program reference (for main render pass)
        this.selection_program = null; // GL program reference for feature selection render pass
        this.feature_style = {}; // style for feature currently being parsed, shared to lessen GC/memory thrash
        this.vertex_template = []; // shared single-vertex template, filled out by each style
        this.tile_data = {};

        // Default world coords to wrap every 100,000 meters, can turn off by setting this to 'false'
        this.defines.TANGRAM_WORLD_POSITION_WRAP = 100000;

        // Blending
        this.blend = this.blend || 'opaque'; // default: opaque styles are drawn first, without blending
        this.defines['TANGRAM_BLEND_' + this.blend.toUpperCase()] = true;
        if (this.blend_order == null) {
            // controls order of rendering for styles w/non-opaque blending
            this.blend_order = -1; // defaults to first
        }

        // If the style defines its own material, replace the inherited material instance
        if (!(this.material instanceof _material2['default'])) {
            if (!_material2['default'].isValid(this.material)) {
                this.material = _style_parser.StyleParser.defaults.material;
            }
            this.material = new _material2['default'](this.material);
        }
        this.material.inject(this);

        // Set lighting mode: fragment, vertex, or none (specified as 'false')
        _light2['default'].setMode(this.lighting, this);

        this.initialized = true;
    },

    destroy: function destroy() {
        if (this.program) {
            this.program.destroy();
            this.program = null;
        }

        if (this.selection_program) {
            this.selection_program.destroy();
            this.selection_program = null;
        }

        this.gl = null;
        this.initialized = false;
    },

    reset: function reset() {},

    isBuiltIn: function isBuiltIn() {
        return this.hasOwnProperty('built_in') && this.built_in;
    },

    fillVertexTemplate: function fillVertexTemplate(attribute, value, _ref2) {
        var size = _ref2.size;
        var offset = _ref2.offset;

        offset = offset === undefined ? 0 : offset;

        var index = this.vertex_layout.index[attribute];
        if (index === undefined) {
            _loglevel2['default'].warn('Style: in style \'' + this.name + '\', no index found in vertex layout for attribute \'' + attribute + '\'');
            return;
        }

        for (var i = 0; i < size; ++i) {
            var v = value.length > i ? value[i] : value;
            this.vertex_template[index + i + offset] = v;
        }
    },

    /*** Style parsing and geometry construction ***/

    // Returns an object to hold feature data (for a tile or other object)
    startData: function startData(tile) {
        this.tile_data[tile.key] = {
            vertex_data: null,
            uniforms: null
        };
        return this.tile_data[tile.key];
    },

    // Finalizes an object holding feature data (for a tile or other object)
    endData: function endData(tile) {
        if (tile.canceled) {
            _utilsUtils2['default'].log('debug', 'stop tile build because tile was removed: ' + tile.key);
            return;
        }

        var tile_data = this.tile_data[tile.key];
        this.tile_data[tile.key] = null;

        if (tile_data && tile_data.vertex_data && tile_data.vertex_data.vertex_count > 0) {
            // Only keep final byte buffer
            tile_data.vertex_data.end();
            tile_data.vertex_data = tile_data.vertex_data.buffer;
        } else {
            tile_data = null; // don't send tile data back if doesn't have geometry
        }

        return _Promise.resolve(tile_data);
    },

    // Has mesh data for a given tile?
    hasDataForTile: function hasDataForTile(tile_key) {
        return this.tile_data[tile_key] != null;
    },

    addFeature: function addFeature(feature, rule, context) {
        var tile = context.tile;
        if (tile.generation !== this.generation) {
            return;
        }

        if (!this.tile_data[tile.key]) {
            this.startData(tile);
        }

        var style = this.parseFeature.apply(this, arguments); // allow subclasses to pass extra args

        // Skip feature?
        if (!style) {
            return;
        }

        // First feature in this render style?
        if (!this.tile_data[tile.key].vertex_data) {
            this.tile_data[tile.key].vertex_data = this.vertex_layout.createVertexData();
        }

        this.buildGeometry(feature.geometry, style, this.tile_data[tile.key].vertex_data, context);
    },

    buildGeometry: function buildGeometry(geometry, style, vertex_data, context) {
        if (geometry.type === 'Polygon') {
            this.buildPolygons([geometry.coordinates], style, vertex_data, context);
        } else if (geometry.type === 'MultiPolygon') {
            this.buildPolygons(geometry.coordinates, style, vertex_data, context);
        } else if (geometry.type === 'LineString') {
            this.buildLines([geometry.coordinates], style, vertex_data, context);
        } else if (geometry.type === 'MultiLineString') {
            this.buildLines(geometry.coordinates, style, vertex_data, context);
        } else if (geometry.type === 'Point') {
            this.buildPoints([geometry.coordinates], style, vertex_data, context);
        } else if (geometry.type === 'MultiPoint') {
            this.buildPoints(geometry.coordinates, style, vertex_data, context);
        }
    },

    parseFeature: function parseFeature(feature, rule_style, context) {
        try {
            var style = this.feature_style;

            rule_style = this.preprocess(rule_style);
            if (!rule_style) {
                return;
            }

            // Calculate order if it was not cached
            style.order = this.parseOrder(rule_style.order, context);

            // Feature selection (only if style supports it)
            var selectable = false;
            style.interactive = rule_style.interactive;
            if (this.selection) {
                selectable = _style_parser.StyleParser.evalProp(style.interactive, context);
            }

            // If feature is marked as selectable
            if (selectable) {
                style.selection_color = _selection2['default'].makeColor(feature, context.tile, context);
            } else {
                style.selection_color = _selection2['default'].defaultColor;
            }

            // Subclass implementation
            style = this._parseFeature.apply(this, arguments); // allow subclasses to pass extra args

            return style;
        } catch (error) {
            _loglevel2['default'].error('Style.parseFeature: style parsing error', feature, style, error);
        }
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        return this.feature_style;
    },

    preprocess: function preprocess(rule_style) {
        // Preprocess first time
        if (!rule_style.preprocessed) {
            rule_style = this._preprocess(rule_style); // optional subclass implementation
            if (!rule_style) {
                return;
            }
            rule_style.preprocessed = true;
        }
        return rule_style;
    },

    // optionally implemented by subclass
    _preprocess: function _preprocess(rule_style) {
        return rule_style;
    },

    // Parse an order value
    parseOrder: function parseOrder(order, context) {
        // Calculate order if it was not cached
        if (typeof order !== 'number') {
            return _style_parser.StyleParser.calculateOrder(order, context);
        }
        return order;
    },

    // Expand final precision for half-layers (for outlines)
    scaleOrder: function scaleOrder(order) {
        return order * 2;
    },

    // Parse a color of choose a default if acceptable, return undefined if color missing
    parseColor: function parseColor(color, context) {
        // Need either a color, or a shader block for 'color' or 'filter'
        if (color) {
            return _style_parser.StyleParser.cacheColor(color, context);
        } else if (this.shaders.blocks.color || this.shaders.blocks.filter) {
            return _style_parser.StyleParser.defaults.color;
        }
    },

    // Build functions are no-ops until overriden
    buildPolygons: function buildPolygons() {},
    buildLines: function buildLines() {},
    buildPoints: function buildPoints() {},

    /*** GL state and rendering ***/

    setGL: function setGL(gl) {
        this.gl = gl;
        this.max_texture_size = _glTexture2['default'].getMaxTextureSize(this.gl);
    },

    makeMesh: function makeMesh(vertex_data) {
        var _ref3 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        var uniforms = _ref3.uniforms;

        return new _glVbo_mesh2['default'](this.gl, vertex_data, this.vertex_layout, { uniforms: uniforms });
    },

    compile: function compile() {
        if (!this.gl) {
            throw new Error('style.compile(): skipping for ' + this.name + ' because no GL context');
        }

        if (this.compiling) {
            throw new Error('style.compile(): skipping for ' + this.name + ' because style is already compiling');
        }
        this.compiling = true;
        this.compiled = false;

        // Build defines & for selection (need to create a new object since the first is stored as a reference by the program)
        var defines = this.buildDefineList();
        if (this.selection) {
            var selection_defines = _Object$assign({}, defines);
            selection_defines.TANGRAM_FEATURE_SELECTION = true;
        }

        // Get any custom code blocks, uniform dependencies, etc.
        var blocks = this.shaders && this.shaders.blocks;
        var block_scopes = this.shaders && this.shaders.block_scopes;
        var uniforms = this.shaders && this.shaders.uniforms;

        // accept a single extension, or an array of extensions
        var extensions = this.shaders && this.shaders.extensions;
        if (typeof extensions === 'string') {
            extensions = [extensions];
        }

        // Create shaders
        try {
            this.program = new _glShader_program2['default'](this.gl, _glShader_sources2['default'][this.vertex_shader_key], _glShader_sources2['default'][this.fragment_shader_key], {
                name: this.name,
                defines: defines,
                uniforms: uniforms,
                blocks: blocks,
                block_scopes: block_scopes,
                extensions: extensions
            });
            this.program.compile();

            if (this.selection) {
                this.selection_program = new _glShader_program2['default'](this.gl, _glShader_sources2['default'][this.vertex_shader_key], _glShader_sources2['default']['gl/shaders/selection_fragment'], {
                    name: this.name + ' (selection)',
                    defines: selection_defines,
                    uniforms: uniforms,
                    blocks: blocks,
                    block_scopes: block_scopes,
                    extensions: extensions
                });
                this.selection_program.compile();
            } else {
                this.selection_program = null;
            }
        } catch (error) {
            this.compiling = false;
            this.compiled = false;
            throw new Error('style.compile(): style ' + this.name + ' error:', error);
        }

        this.compiling = false;
        this.compiled = true;
    },

    // Add a shader block
    addShaderBlock: function addShaderBlock(key, block) {
        var scope = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

        this.shaders.blocks = this.shaders.blocks || {};
        this.shaders.blocks[key] = this.shaders.blocks[key] || [];
        this.shaders.blocks[key].push(block);

        this.shaders.block_scopes = this.shaders.block_scopes || {};
        this.shaders.block_scopes[key] = this.shaders.block_scopes[key] || [];
        this.shaders.block_scopes[key].push(scope);
    },

    // Remove all shader blocks for key
    removeShaderBlock: function removeShaderBlock(key) {
        if (this.shaders.blocks) {
            this.shaders.blocks[key] = null;
        }
    },

    replaceShaderBlock: function replaceShaderBlock(key, block) {
        var scope = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

        this.removeShaderBlock(key);
        this.addShaderBlock(key, block, scope);
    },

    /** TODO: could probably combine and generalize this with similar method in ShaderProgram
     * (list of define objects that inherit from each other)
     */
    buildDefineList: function buildDefineList() {
        // Add any custom defines to built-in style defines
        var defines = {}; // create a new object to avoid mutating a prototype value that may be shared with other styles
        if (this.defines != null) {
            for (var d in this.defines) {
                defines[d] = this.defines[d];
            }
        }
        if (this.shaders != null && this.shaders.defines != null) {
            for (d in this.shaders.defines) {
                defines[d] = this.shaders.defines[d];
            }
        }
        return defines;
    },

    // Setup any GL state for rendering
    setup: function setup() {
        this.setUniforms();
        this.material.setupProgram(_glShader_program2['default'].current);
    },

    // Set style uniforms on currently bound program
    setUniforms: function setUniforms() {
        var program = _glShader_program2['default'].current;
        if (!program) {
            return;
        }

        program.setUniforms(this.shaders && this.shaders.uniforms, true); // reset texture unit to 0
    },

    // Render state settings by blend mode
    render_states: {
        opaque: { depth_test: true, depth_write: true },
        add: { depth_test: true, depth_write: false },
        multiply: { depth_test: true, depth_write: false },
        inlay: { depth_test: true, depth_write: false },
        overlay: { depth_test: false, depth_write: false }
    },

    // Default sort order for blend modes
    default_blend_orders: {
        opaque: 0,
        add: 1,
        multiply: 2,
        inlay: 3,
        overlay: 4
    },

    // Comparison function for sorting styles by blend
    blendOrderSort: function blendOrderSort(a, b) {
        // opaque always comes first
        if (a.blend === 'opaque' || b.blend === 'opaque') {
            if (a.blend === 'opaque' && b.blend === 'opaque') {
                // if both are opaque
                return a.name < b.name ? -1 : 1; // use name as tie breaker
            } else if (a.blend === 'opaque') {
                    return -1; // only `a` was opaque
                } else {
                        return 1; // only `b` was opaque
                    }
        }

        // use explicit blend order if possible
        if (a.blend_order < b.blend_order) {
            return -1;
        } else if (a.blend_order > b.blend_order) {
            return 1;
        }

        // if blend orders are equal, use default order by blend mode
        if (Style.default_blend_orders[a.blend] < Style.default_blend_orders[b.blend]) {
            return -1;
        } else if (Style.default_blend_orders[a.blend] > Style.default_blend_orders[b.blend]) {
            return 1;
        }

        return a.name < b.name ? -1 : 1; // use name as tie breaker
    },

    update: function update() {
        // Style-specific animation
        // if (typeof this.animation === 'function') {
        //     this.animation();
        // }
    }

};
exports.Style = Style;

},{"../gl/shader_program":203,"../gl/shader_sources":204,"../gl/texture":205,"../gl/vbo_mesh":207,"../light":216,"../material":217,"../selection":222,"../utils/utils":247,"./style_parser":235,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/promise":14,"babel-runtime/helpers/interop-require-default":23,"loglevel":183}],234:[function(_dereq_,module,exports){
// Manage rendering styles

'use strict';

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _Object$defineProperty = _dereq_('babel-runtime/core-js/object/define-property')['default'];

var _Object$create = _dereq_('babel-runtime/core-js/object/create')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsUtils = _dereq_('../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _glShader_program = _dereq_('../gl/shader_program');

var _glShader_program2 = _interopRequireDefault(_glShader_program);

var _glShader_sources = _dereq_('../gl/shader_sources');

var _glShader_sources2 = _interopRequireDefault(_glShader_sources);

// built-in shaders

var _style = _dereq_('./style');

var _utilsMerge = _dereq_('../utils/merge');

var _utilsMerge2 = _interopRequireDefault(_utilsMerge);

var _geo = _dereq_('../geo');

var _geo2 = _interopRequireDefault(_geo);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var StyleManager = {};
exports.StyleManager = StyleManager;
var Styles = {};
exports.Styles = Styles;
var BaseStyles = {};

exports.BaseStyles = BaseStyles;
StyleManager.styles = Styles;

// Set the base object used to instantiate styles
StyleManager.baseStyle = _style.Style;

// Global configuration for all styles
StyleManager.init = function () {
    _glShader_program2['default'].removeBlock('global');
    _glShader_program2['default'].removeBlock('setup');

    // Unpacking functions (for normalized vertex attributes)
    _glShader_program2['default'].addBlock('global', _glShader_sources2['default']['gl/shaders/unpack']);

    // Model and world position accessors
    _glShader_program2['default'].addBlock('global', _glShader_sources2['default']['gl/shaders/accessors']);

    // Layer re-ordering function
    _glShader_program2['default'].addBlock('global', _glShader_sources2['default']['gl/shaders/layer_order']);

    // Feature selection global
    _glShader_program2['default'].addBlock('global', _glShader_sources2['default']['gl/shaders/selection_globals']);

    // Feature selection vertex shader support
    _glShader_program2['default'].replaceBlock('setup', _glShader_sources2['default']['gl/shaders/selection_vertex']);

    // Minimum value for float comparisons
    _glShader_program2['default'].defines.TANGRAM_EPSILON = 0.00001;

    // assume min 16-bit depth buffer, in practice uses 14-bits, 1 extra bit to handle virtual half-layers
    // for outlines (inserted in between layers), another extra bit to prevent precision loss
    _glShader_program2['default'].defines.TANGRAM_LAYER_DELTA = 1 / (1 << 14);

    // Internal tile scale
    _glShader_program2['default'].defines.TANGRAM_TILE_SCALE = 'vec3(' + _geo2['default'].tile_scale + '., ' + _geo2['default'].tile_scale + '., u_meters_per_pixel * ' + _geo2['default'].tile_size + '.)';
};

// Destroy all styles for a given GL context
StyleManager.destroy = function (gl) {
    _Object$keys(Styles).forEach(function (_name) {
        var style = Styles[_name];
        if (style.gl === gl) {
            _loglevel2['default'].trace('StyleManager.destroy: destroying render style ' + style.name);

            if (!style.isBuiltIn()) {
                StyleManager.remove(style.name);
            }
            style.destroy();
        }
    });
};

// Register a style
StyleManager.register = function (style) {
    Styles[style.name] = style;
    BaseStyles[style.name] = style;
};

// Remove a style
StyleManager.remove = function (name) {
    delete Styles[name];
};

// Load style definitions from external URLs
StyleManager.loadRemoteStyles = function (styles, base) {
    var _this = this;

    // Collect URLs and modes to import from them
    // This is done as a separate step becuase it is possible to import multiple modes from a single
    // URL, and we want to avoid duplicate calls for the same file.
    var urls = {};
    for (var name in styles) {
        var style = styles[name];
        if (style.url) {
            var url = style.url;
            if (base) {
                url = _utilsUtils2['default'].addBaseURL(url, base);
            }

            if (!urls[url]) {
                urls[url] = [];
            }

            // Make a list of the styles to import for this URL
            urls[url].push({
                target_name: name,
                source_name: style.name || name
            });
        }
    }

    // As each URL finishes loading, replace the target style(s)
    return _Promise.all(_Object$keys(urls).map(function (url) {
        return new _Promise(function (resolve, reject) {
            _utilsUtils2['default'].loadResource(url).then(function (data) {
                // Mixin remote styles, within each remote file
                // TODO: may not handle multiple levels of mixins, and will not handle nested remote files
                for (var source_name in data) {
                    var source_import = urls[url] && urls[url].filter(function (s) {
                        return s.source_name === source_name;
                    });
                    source_import = source_import && source_import[0];

                    if (source_import) {
                        // use imported name if different from name in source file
                        data[source_name].name = source_import.target_name;
                    } else {
                        data[source_name].name = source_name;
                    }

                    data[source_name] = StyleManager.mix(data[source_name], data);
                }

                // Add remote styles to local styles
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = _getIterator(urls[url]), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var target = _step.value;

                        if (data && data[target.source_name]) {
                            styles[target.target_name] = data[target.source_name];
                        } else {
                            delete styles[target.target_name];
                            return reject(new Error('StyleManager.loadRemoteStyles: error importing style ' + target.target_name + ', could not find source style ' + target.source_name + ' in ' + url));
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator['return']) {
                            _iterator['return']();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                resolve();

                _this.selection = false;
            })['catch'](function (error) {
                _loglevel2['default'].error('StyleManager.loadRemoteStyles: error importing style(s) ' + JSON.stringify(urls[url]) + ' from ' + url, error);
            });
        });
    })).then(function () {
        return _Promise.resolve(styles);
    });
};

// Preload shader blocks from external URLs
StyleManager.loadShaderBlocks = function (styles, base) {
    if (!styles) {
        return _Promise.resolve({});
    }
    var queue = [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = _getIterator(_utilsUtils2['default'].values(styles)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var style = _step2.value;

            if (style.shaders && style.shaders.blocks) {
                var _iteratorNormalCompletion3;

                var _didIteratorError3;

                var _iteratorError3;

                var _iterator3, _step3;

                (function () {
                    var _blocks = style.shaders.blocks;

                    _iteratorNormalCompletion3 = true;
                    _didIteratorError3 = false;
                    _iteratorError3 = undefined;

                    try {
                        var _loop = function () {
                            var _step3$value = _slicedToArray(_step3.value, 2);

                            var key = _step3$value[0];
                            var block = _step3$value[1];

                            var _key = key;

                            // Array of blocks
                            if (Array.isArray(block)) {
                                for (var b = 0; b < block.length; b++) {
                                    if (typeof block[b] === 'object' && block[b].url) {
                                        (function () {
                                            var _index = b;
                                            var url = block[b].url;
                                            if (base) {
                                                url = _utilsUtils2['default'].addBaseURL(url, base);
                                            }

                                            queue.push(_utilsUtils2['default'].io(_utilsUtils2['default'].cacheBusterForUrl(url)).then(function (data) {
                                                _blocks[_key][_index] = data;
                                            })['catch'](function (error) {
                                                _loglevel2['default'].error('StyleManager.loadShaderBlocks: error loading shader block', _blocks, _key, _index, error);
                                            }));
                                        })();
                                    }
                                }
                            }
                            // Single block
                            else if (typeof block === 'object' && block.url) {
                                    var url = block.url;
                                    if (base) {
                                        url = _utilsUtils2['default'].addBaseURL(url, base);
                                    }

                                    queue.push(_utilsUtils2['default'].io(_utilsUtils2['default'].cacheBusterForUrl(url)).then(function (data) {
                                        _blocks[_key] = data;
                                    })['catch'](function (error) {
                                        _loglevel2['default'].error('StyleManager.loadShaderBlocks: error loading shader block', _blocks, _key, error);
                                    }));
                                }
                        };

                        for (_iterator3 = _getIterator(_utilsUtils2['default'].entries(style.shaders.blocks)); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                            _loop();
                        }
                    } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                                _iterator3['return']();
                            }
                        } finally {
                            if (_didIteratorError3) {
                                throw _iteratorError3;
                            }
                        }
                    }
                })();
            }
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                _iterator2['return']();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    return _Promise.all(queue).then(function () {
        return _Promise.resolve(styles);
    }); // TODO: add error
};

StyleManager.mix = function (style, styles) {
    // Exit early if we have already applied mixins to this style
    if (style.mixed) {
        return style;
    }
    style.mixed = {};

    // Mixin sources, in order
    var sources = [];
    if (style.mix) {
        if (Array.isArray(style.mix)) {
            var _sources;

            (_sources = sources).push.apply(_sources, _toConsumableArray(style.mix));
        } else {
            sources.push(style.mix);
        }
        sources = sources.map(function (x) {
            return styles[x];
        }).filter(function (x) {
            return x && x !== style;
        }); // TODO: warning on trying to mix into self

        // Track which styles were mixed into this one
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
            for (var _iterator4 = _getIterator(sources), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var s = _step4.value;

                style.mixed[s.name] = true;
            }
        } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                    _iterator4['return']();
                }
            } finally {
                if (_didIteratorError4) {
                    throw _iteratorError4;
                }
            }
        }
    }
    sources.push(style);

    // Flags - OR'd, true if any style has it set
    style.animated = sources.some(function (x) {
        return x && x.animated;
    });
    style.texcoords = sources.some(function (x) {
        return x && x.texcoords;
    });

    // Overwrites - last definition wins
    style.base = sources.map(function (x) {
        return x.base;
    }).filter(function (x) {
        return x;
    }).pop();
    style.lighting = sources.map(function (x) {
        return x.lighting;
    }).filter(function (x) {
        return x != null;
    }).pop();
    style.texture = sources.map(function (x) {
        return x.texture;
    }).filter(function (x) {
        return x;
    }).pop();
    if (sources.some(function (x) {
        return x.hasOwnProperty('blend') && x.blend;
    })) {
        // only mix blend if explicitly set, otherwise let base style choose blending mode
        // hasOwnProperty check gives preference to base style prototype
        style.blend = sources.map(function (x) {
            return x.hasOwnProperty('blend') && x.blend;
        }).filter(function (x) {
            return x;
        }).pop();
    }
    style.blend_order = sources.map(function (x) {
        return x.blend_order;
    }).filter(function (x) {
        return x != null;
    }).pop();

    // Merges - property-specific rules for merging values
    style.defines = _Object$assign.apply(Object, [{}].concat(_toConsumableArray(sources.map(function (x) {
        return x.defines;
    }).filter(function (x) {
        return x;
    })))); // internal defines (not user-defined)
    style.material = _Object$assign.apply(Object, [{}].concat(_toConsumableArray(sources.map(function (x) {
        return x.material;
    }).filter(function (x) {
        return x;
    }))));

    // Mix shader properties
    StyleManager.mixShaders(style, styles, sources);
    return style;
};

// Mix the propertes in the "shaders" block
StyleManager.mixShaders = function (style, styles, sources) {
    var shaders = {}; // newly mixed shaders properties
    var shader_merges = sources.map(function (x) {
        return x.shaders;
    }).filter(function (x) {
        return x;
    }); // just the source styles with shader properties

    // Defines
    shaders.defines = _Object$assign.apply(Object, [{}].concat(_toConsumableArray(shader_merges.map(function (x) {
        return x.defines;
    }).filter(function (x) {
        return x;
    }))));

    // Uniforms
    shaders.uniforms = {}; // uniforms for this style, both explicitly defined, and mixed from other styles
    shaders._uniforms = style.shaders && style.shaders.uniforms || {}; // uniforms explicitly defined by *this* style
    shaders._uniform_scopes = {}; // tracks which style each uniform originated from (this one, or ancestor)

    // Mix in uniforms from ancestors, providing means to access
    sources.filter(function (x) {
        return x.shaders && x.shaders.uniforms;
    }).forEach(function (x) {
        var _loop2 = function (u) {
            shaders._uniform_scopes[u] = x.name;

            // Define getter and setter for this uniform
            // Getter returns value for this style if present, otherwise asks appropriate ancestor for it
            // Setter sets the value for this style (whether previously present in this style or not)
            // Mimics JS prototype/hasOwnProperty behavior, but with multiple ancestors (via mixins)
            _Object$defineProperty(shaders.uniforms, u, {
                enumerable: true,
                configurable: true,
                get: function get() {
                    // Uniform is explicitly defined on this style
                    if (shaders._uniforms[u] !== undefined) {
                        return shaders._uniforms[u];
                    }
                    // Uniform was mixed from another style, forward request there
                    // Identify check is needed to prevent infinite recursion if a previously defined uniform
                    // is set to undefined
                    else if (styles[shaders._uniform_scopes[u]].shaders.uniforms !== shaders.uniforms) {
                            return styles[shaders._uniform_scopes[u]].shaders.uniforms[u];
                        }
                },
                set: function set(v) {
                    shaders._uniforms[u] = v;
                }
            });
        };

        for (var u in x.shaders.uniforms) {
            _loop2(u);
        }
    });

    // Extensions: build a list of unique extensions
    shaders.extensions = _Object$keys(shader_merges.map(function (x) {
        return x.extensions;
    }).filter(function (x) {
        return x;
    }).reduce(function (prev, cur) {
        // single extension
        if (typeof cur === 'string') {
            prev[cur] = true;
        }
        // array of extensions
        else {
                cur.forEach(function (x) {
                    return prev[x] = true;
                });
            }
        return prev;
    }, {}) || {});

    // Shader blocks
    // Mark all shader blocks for the target style as originating with its own name
    if (style.shaders && style.shaders.blocks) {
        style.shaders.block_scopes = style.shaders.block_scopes || {};
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
            for (var _iterator5 = _getIterator(_utilsUtils2['default'].entries(style.shaders.blocks)), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var _step5$value = _slicedToArray(_step5.value, 2);

                var k = _step5$value[0];
                var block = _step5$value[1];

                style.shaders.block_scopes[k] = style.shaders.block_scopes[k] || [];
                if (Array.isArray(block)) {
                    var _style$shaders$block_scopes$k;

                    (_style$shaders$block_scopes$k = style.shaders.block_scopes[k]).push.apply(_style$shaders$block_scopes$k, _toConsumableArray(block.map(function () {
                        return style.name;
                    })));
                } else {
                    style.shaders.block_scopes[k].push(style.name);
                }
            }
        } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion5 && _iterator5['return']) {
                    _iterator5['return']();
                }
            } finally {
                if (_didIteratorError5) {
                    throw _iteratorError5;
                }
            }
        }
    }

    // Merge shader blocks, keeping track of which style each block originated from
    var mixed = {}; // all scopes mixed so far
    var _iteratorNormalCompletion6 = true;
    var _didIteratorError6 = false;
    var _iteratorError6 = undefined;

    try {
        for (var _iterator6 = _getIterator(shader_merges), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var source = _step6.value;

            if (!source.blocks) {
                continue;
            }

            shaders.blocks = shaders.blocks || {};
            shaders.block_scopes = shaders.block_scopes || {};
            var mixed_source = {}; // scopes mixed for this source style

            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
                for (var _iterator7 = _getIterator(_utilsUtils2['default'].entries(source.blocks)), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                    var _step7$value = _slicedToArray(_step7.value, 2);

                    var t = _step7$value[0];
                    var block = _step7$value[1];

                    var block_scope = source.block_scopes[t];

                    shaders.blocks[t] = shaders.blocks[t] || [];
                    shaders.block_scopes[t] = shaders.block_scopes[t] || [];

                    // standardize on arrays (block can be single or multi-value)
                    block = Array.isArray(block) ? block : [block];
                    block_scope = Array.isArray(block_scope) ? block_scope : [block_scope];

                    for (var b = 0; b < block.length; b++) {
                        // Skip blocks we've already mixed in from the same scope
                        // Repeating scope indicates a diamond pattern where a style is being mixed multiple times
                        if (mixed[block_scope[b]]) {
                            continue;
                        }
                        mixed_source[block_scope[b]] = true;

                        shaders.blocks[t].push(block[b]);
                        shaders.block_scopes[t].push(block_scope[b]);
                    }
                }

                // Add styles mixed in from this source - they could be multi-level ancestors,
                // beyond the first-level "parents" defined in this style's `mix` list
            } catch (err) {
                _didIteratorError7 = true;
                _iteratorError7 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion7 && _iterator7['return']) {
                        _iterator7['return']();
                    }
                } finally {
                    if (_didIteratorError7) {
                        throw _iteratorError7;
                    }
                }
            }

            _Object$assign(style.mixed, mixed_source);
        }
    } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion6 && _iterator6['return']) {
                _iterator6['return']();
            }
        } finally {
            if (_didIteratorError6) {
                throw _iteratorError6;
            }
        }
    }

    style.shaders = shaders; // assign back to style
    return style;
};

// Create a new style
// name: name of new style
// config: properties of new style
// styles: working set of styles being built (used for mixing in existing styles)
StyleManager.create = function (name, config) {
    var styles = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var style = (0, _utilsMerge2['default'])({}, config); // deep copy
    style.name = name;

    // Style mixins
    style = StyleManager.mix(style, styles);

    // Has base style?
    // Only renderable (instantiated) styles should be included for run-time use
    // Others are intermediary/abstract, used during style composition but not execution
    if (style.base && BaseStyles[style.base]) {
        Styles[name] = style = _Object$assign(_Object$create(BaseStyles[style.base]), style);
    }

    return style;
};

// Called to create and initialize styles
StyleManager.build = function (styles) {
    var scene = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    // Sort styles by dependency, then build them
    var style_deps = _Object$keys(styles).sort(function (a, b) {
        return StyleManager.inheritanceDepth(a, styles) - StyleManager.inheritanceDepth(b, styles);
    });

    // Only keep built-in base styles
    for (var sname in Styles) {
        if (!BaseStyles[sname]) {
            delete Styles[sname];
        } else {
            Styles[sname].reset();
        }
    }

    // Working set of styles being built
    var ws = {};
    var _iteratorNormalCompletion8 = true;
    var _didIteratorError8 = false;
    var _iteratorError8 = undefined;

    try {
        for (var _iterator8 = _getIterator(style_deps), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var sname = _step8.value;

            ws[sname] = StyleManager.create(sname, styles[sname], ws);
        }
    } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion8 && _iterator8['return']) {
                _iterator8['return']();
            }
        } finally {
            if (_didIteratorError8) {
                throw _iteratorError8;
            }
        }
    }

    StyleManager.initStyles(scene);
    return Styles;
};

// Initialize all styles
StyleManager.initStyles = function (scene) {
    // Initialize all
    for (var sname in Styles) {
        Styles[sname].init(scene);
    }
};

// Given a style key in a set of styles to add, count the length of the inheritance chain
// TODO: remove current (Styles) and future (styles) duplication, confusing
StyleManager.inheritanceDepth = function (key, styles) {
    var parents = 0;

    while (true) {
        var style = styles[key];
        if (!style) {
            // this is a scene def error, trying to extend a style that doesn't exist
            break;
        }

        // Dependency chain ends when this style isn't mixing in any others
        if (!style.mix) {
            break;
        }

        // Traverse next parent style
        parents++;

        if (Array.isArray(style.mix)) {
            // If multiple mixins, find the deepest one
            parents += Math.max.apply(Math, _toConsumableArray(style.mix.map(function (s) {
                // Trying to mix into itself!
                if (key === s) {
                    return;
                }

                return StyleManager.inheritanceDepth(s, styles);
            })));
            break;
        } else {
            // Trying to mix into itself!
            if (key === style.mix) {
                break;
            }

            // If single mixin, continue loop up the tree
            key = style.mix;
        }
    }
    return parents;
};

// Compile all styles
StyleManager.compile = function (keys, scene) {
    keys = keys || _Object$keys(Styles);
    var _iteratorNormalCompletion9 = true;
    var _didIteratorError9 = false;
    var _iteratorError9 = undefined;

    try {
        for (var _iterator9 = _getIterator(keys), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var key = _step9.value;

            var style = Styles[key];
            try {
                style.compile();
                _loglevel2['default'].trace('StyleManager.compile(): compiled style ' + key);
            } catch (error) {
                _loglevel2['default'].error('StyleManager.compile(): error compiling style ' + key + ':', error);

                scene.trigger('warning', {
                    type: 'styles',
                    message: 'Error compiling style ' + key,
                    style: style,
                    shader_errors: style.program && style.program.shader_errors
                });
            }
        }
    } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion9 && _iterator9['return']) {
                _iterator9['return']();
            }
        } finally {
            if (_didIteratorError9) {
                throw _iteratorError9;
            }
        }
    }

    _loglevel2['default'].debug('StyleManager.compile(): compiled all styles');
};

// Get all styles with mesh data for a given tile
StyleManager.stylesForTile = function (tile_key) {
    var styles = [];
    for (var s in Styles) {
        if (Styles[s].hasDataForTile(tile_key)) {
            styles.push(s);
        }
    }
    return styles;
};

},{"../geo":197,"../gl/shader_program":203,"../gl/shader_sources":204,"../utils/merge":244,"../utils/utils":247,"./style":233,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/create":7,"babel-runtime/core-js/object/define-property":9,"babel-runtime/core-js/object/keys":12,"babel-runtime/core-js/promise":14,"babel-runtime/helpers/interop-require-default":23,"babel-runtime/helpers/sliced-to-array":24,"babel-runtime/helpers/to-consumable-array":25,"loglevel":183}],235:[function(_dereq_,module,exports){
'use strict';

var _Object$freeze = _dereq_('babel-runtime/core-js/object/freeze')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsUtils = _dereq_('../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _geo = _dereq_('../geo');

var _geo2 = _interopRequireDefault(_geo);

var _csscolorparser = _dereq_('csscolorparser');

var _csscolorparser2 = _interopRequireDefault(_csscolorparser);

var StyleParser = {};

exports.StyleParser = StyleParser;
// Wraps style functions and provides a scope of commonly accessible data:
// - feature: the 'properties' of the feature, e.g. accessed as 'feature.name'
// - $zoom: the current map zoom level
// - $geometry: the type of geometry, 'point', 'line', or 'polygon'
// - $meters_per_pixel: conversion for meters/pixels at current map zoom
// - properties: user-defined properties on the style-rule object in the stylesheet
StyleParser.wrapFunction = function (func) {
    var f = 'function(context) {\n                var feature = context.feature.properties;\n                var $zoom = context.zoom;\n                var $layer = context.layer;\n                var $geometry = context.geometry;\n                var $meters_per_pixel = context.meters_per_pixel;\n                var properties = context.properties;\n\n                var val = (' + func + '());\n\n                if (typeof val === \'number\' && isNaN(val)) {\n                    val = null; // convert NaNs to nulls\n                }\n\n                return val;\n            }';
    return f;
};

// Style parsing

StyleParser.zeroPair = _Object$freeze([0, 0]); // single allocation for zero values that won't be modified

// Style defaults
StyleParser.defaults = {
    color: [1, 1, 1, 1],
    width: 1,
    size: 1,
    extrude: false,
    height: 20,
    min_height: 0,
    order: 0,
    z: 0,
    material: {
        ambient: 1,
        diffuse: 1
    }
};

// Style macros
StyleParser.macros = {
    // pseudo-random color by geometry id
    'Style.color.pseudoRandomColor': function StyleColorPseudoRandomColor() {
        return [0.7 * (parseInt(feature.id, 16) / 100 % 1), // jshint ignore:line
        0.7 * (parseInt(feature.id, 16) / 10000 % 1), // jshint ignore:line
        0.7 * (parseInt(feature.id, 16) / 1000000 % 1), // jshint ignore:line
        1];
    },

    // random color
    'Style.color.randomColor': function StyleColorRandomColor() {
        return [0.7 * Math.random(), 0.7 * Math.random(), 0.7 * Math.random(), 1];
    }
};

// A context object that is passed to style parsing functions to provide a scope of commonly used values
StyleParser.getFeatureParseContext = function (feature, tile) {
    return {
        feature: feature,
        tile: tile,
        zoom: tile.style_zoom,
        geometry: _geo2['default'].geometryType(feature.geometry.type),
        meters_per_pixel: tile.meters_per_pixel,
        units_per_meter: tile.units_per_meter
    };
};

// Build a style param cache object
// `value` is raw value, cache methods will add other properties as needed
// `transform` is optional transform function to run on values (except function values)
StyleParser.cacheObject = function (obj) {
    var transform = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (obj == null) {
        return;
    }

    if (obj.value) {
        return { value: obj.value, zoom: obj.zoom ? {} : null }; // clone existing cache object
    }

    var c = { value: obj };

    if (typeof transform === 'function') {
        if (Array.isArray(c.value) && Array.isArray(c.value[0])) {
            // zoom stops
            c.value = c.value.map(function (v) {
                return [v[0], transform(v[1])];
            });
            c.zoom = {}; // will hold values interpolated by zoom
        } else if (typeof c.value !== 'function') {
                // don't transform functions
                c.value = transform(c.value); // single value
            }
    }

    return c;
};

// Convert old-style color macro into a function
// TODO: deprecate this macro syntax
StyleParser.colorCacheObject = function (obj) {
    return StyleParser.cacheObject(obj, function (v) {
        if (v === 'Style.color.pseudoRandomColor') {
            return _utilsUtils2['default'].stringToFunction(StyleParser.wrapFunction(StyleParser.macros['Style.color.pseudoRandomColor']));
        } else if (v === 'Style.color.randomColor') {
            return StyleParser.macros['Style.color.randomColor'];
        }

        return v;
    });
};

// Interpolation and caching for a generic property (not a color or distance)
// { value: original, static: val, zoom: { 1: val1, 2: val2, ... }, dynamic: function(){...} }
StyleParser.cacheProperty = function (val, context) {
    if (val == null) {
        return;
    } else if (val.dynamic) {
        // function, compute each time (no caching)
        var v = val.dynamic(context);
        return v;
    } else if (val['static']) {
        // single static value
        return val['static'];
    } else if (val.zoom && val.zoom[context.zoom]) {
        // interpolated, cached
        return val.zoom[context.zoom];
    } else {
        // not yet evaulated for cache
        // Dynamic function-based
        if (typeof val.value === 'function') {
            val.dynamic = val.value;
            var v = val.dynamic(context);
            return v;
        }
        // Array of zoom-interpolated stops, e.g. [zoom, value] pairs
        else if (Array.isArray(val.value) && Array.isArray(val.value[0])) {
                // Calculate value for current zoom
                val.zoom = val.zoom || {};
                val.zoom = {};
                val.zoom[context.zoom] = _utilsUtils2['default'].interpolate(context.zoom, val.value);
                return val.zoom[context.zoom];
            }
            // Single static value
            else {
                    val['static'] = val.value;
                    return val['static'];
                }
    }
};

StyleParser.convertUnits = function (val, context) {
    // pre-parsed units
    if (val.val != null) {
        if (val.units === 'px') {
            // convert from pixels
            return val.val * _geo2['default'].metersPerPixel(context.zoom);
        }
        return val.val;
    }
    // un-parsed unit string
    else if (typeof val === 'string') {
            var units = val.match(/([0-9.-]+)([a-z]+)/);
            if (units && units.length === 3) {
                val = parseFloat(units[1]);
                units = units[2];
            }

            if (units === 'px') {
                // convert from pixels
                val *= _geo2['default'].metersPerPixel(context.zoom);
            }
        }
        // multiple values or stops
        else if (Array.isArray(val)) {
                // Array of arrays, e.g. zoom-interpolated stops
                if (Array.isArray(val[0])) {
                    return val.map(function (v) {
                        return [v[0], StyleParser.convertUnits(v[1], context)];
                    });
                }
                // Array of values
                else {
                        return val.map(function (v) {
                            return StyleParser.convertUnits(v, context);
                        });
                    }
            }
    return val;
};

// Pre-parse units from string values
StyleParser.cacheUnits = function (val) {
    var obj = { val: parseFloat(val) };
    if (obj.val !== 0 && typeof val === 'string' && val.trim().slice(-2) === 'px') {
        obj.units = 'px';
    }
    return obj;
};

// Takes a distance cache object and returns a distance value for this zoom
// (caching the result for future use)
// { value: original, zoom: { z: meters }, dynamic: function(){...} }
StyleParser.cacheDistance = function (val, context) {
    if (val.dynamic) {
        var v = val.dynamic(context);
        return v;
    } else if (val.zoom && val.zoom[context.zoom]) {
        return val.zoom[context.zoom];
    } else {
        // Dynamic function-based
        if (typeof val.value === 'function') {
            val.dynamic = val.value;
            var v = val.dynamic(context);
            return v;
        }
        // Array of zoom-interpolated stops, e.g. [zoom, value] pairs
        else if (val.zoom) {
                // Calculate value for current zoom
                // Do final unit conversion as late as possible, when interpolation values have been determined
                val.zoom[context.zoom] = _utilsUtils2['default'].interpolate(context.zoom, val.value, function (v) {
                    return StyleParser.convertUnits(v, context);
                });

                return val.zoom[context.zoom];
            } else {
                return StyleParser.convertUnits(val.value, context);
            }
    }
};

// Cache previously parsed color strings
StyleParser.string_colors = {};
StyleParser.colorForString = function (string) {
    // Cached
    if (StyleParser.string_colors[string]) {
        return StyleParser.string_colors[string];
    }

    // Calculate and cache
    var color = _csscolorparser2['default'].parseCSSColor(string);
    if (color && color.length === 4) {
        color[0] /= 255;
        color[1] /= 255;
        color[2] /= 255;
    } else {
        color = StyleParser.defaults.color;
    }
    StyleParser.string_colors[string] = color;
    return color;
};

// Takes a color cache object and returns a color value for this zoom
// (caching the result for future use)
// { value: original, static: [r,g,b,a], zoom: { z: [r,g,b,a] }, dynamic: function(){...} }
StyleParser.cacheColor = function (val) {
    var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    if (val.dynamic) {
        var v = val.dynamic(context);

        if (typeof v === 'string') {
            v = StyleParser.colorForString(v);
        }

        if (v && v[3] == null) {
            v[3] = 1; // default alpha
        }
        return v;
    } else if (val['static']) {
        return val['static'];
    } else if (val.zoom && val.zoom[context.zoom]) {
        return val.zoom[context.zoom];
    } else {
        // Dynamic function-based color
        if (typeof val.value === 'function') {
            val.dynamic = val.value;
            var v = val.dynamic(context);

            if (typeof v === 'string') {
                v = StyleParser.colorForString(v);
            }

            if (v && v[3] == null) {
                v[3] = 1; // default alpha
            }
            return v;
        }
        // Single string color
        else if (typeof val.value === 'string') {
                val['static'] = StyleParser.colorForString(val.value);
                return val['static'];
            }
            // Array of zoom-interpolated stops, e.g. [zoom, color] pairs
            else if (val.zoom) {
                    // Parse any string colors inside stops, the first time we encounter this property
                    if (!val.zoom_preprocessed) {
                        for (var i = 0; i < val.value.length; i++) {
                            var v = val.value[i];
                            if (v && typeof v[1] === 'string') {
                                v[1] = StyleParser.colorForString(v[1]);
                            }
                        }
                        val.zoom_preprocessed = true;
                    }

                    // Calculate color for current zoom
                    val.zoom[context.zoom] = _utilsUtils2['default'].interpolate(context.zoom, val.value);
                    val.zoom[context.zoom][3] = val.zoom[context.zoom][3] || 1; // default alpha
                    return val.zoom[context.zoom];
                }
                // Single array color
                else {
                        val['static'] = val.value;
                        if (val['static'] && val['static'][3] == null) {
                            val['static'][3] = 1; // default alpha
                        }
                        return val['static'];
                    }
    }
};

StyleParser.parseColor = function (val) {
    var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    if (typeof val === 'function') {
        val = val(context);
    }

    // Parse CSS-style colors
    // TODO: change all colors to use 0-255 range internally to avoid dividing and then re-multiplying in geom builder
    if (typeof val === 'string') {
        val = StyleParser.colorForString(val);
    } else if (Array.isArray(val) && Array.isArray(val[0])) {
        // Array of zoom-interpolated stops, e.g. [zoom, color] pairs
        for (var i = 0; i < val.length; i++) {
            var v = val[i];
            if (typeof v[1] === 'string') {
                v[1] = StyleParser.colorForString(v[1]);
            }
        }

        if (context.zoom) {
            val = _utilsUtils2['default'].interpolate(context.zoom, val);
        }
    }

    // Defaults
    if (val) {
        // alpha
        if (val[3] == null) {
            val[3] = 1;
        }
    } else {
        val = [0, 0, 0, 1];
    }

    return val;
};

StyleParser.calculateOrder = function (order, context) {
    // Computed order
    if (typeof order === 'function') {
        order = order(context);
    } else if (typeof order === 'string') {
        // Order tied to feature property
        if (context.feature.properties[order]) {
            order = context.feature.properties[order];
        }
        // Explicit order value
        else {
                order = parseFloat(order);
            }
    }

    return order;
};

// Evaluate a function-based property, or pass-through static value
StyleParser.evalProp = function (prop, context) {
    if (typeof prop === 'function') {
        return prop(context);
    }
    return prop;
};

},{"../geo":197,"../utils/utils":247,"babel-runtime/core-js/object/freeze":10,"babel-runtime/helpers/interop-require-default":23,"csscolorparser":133}],236:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsUtils = _dereq_('../../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _builders = _dereq_('../builders');

var _builders2 = _interopRequireDefault(_builders);

var CanvasText = (function () {
    function CanvasText() {
        _classCallCheck(this, CanvasText);

        this.canvas = document.createElement('canvas');
        this.canvas.style.backgroundColor = 'transparent'; // render text on transparent background
        this.context = this.canvas.getContext('2d');
    }

    // Extract font size and units

    _createClass(CanvasText, [{
        key: 'resize',
        value: function resize(width, height) {
            this.canvas.width = width;
            this.canvas.height = height;
            this.context.clearRect(0, 0, width, height);
        }

        // Set font style params for canvas drawing
    }, {
        key: 'setFont',
        value: function setFont(tile, _ref) {
            var font_css = _ref.font_css;
            var fill = _ref.fill;
            var stroke = _ref.stroke;
            var stroke_width = _ref.stroke_width;
            var px_size = _ref.px_size;

            this.px_size = px_size;
            this.text_buffer = 8; // pixel padding around text
            var ctx = this.context;

            ctx.font = font_css;
            if (stroke) {
                ctx.strokeStyle = stroke;
                ctx.lineWidth = stroke_width;
            } else {
                ctx.strokeStyle = null;
                ctx.lineWidth = 0;
            }
            ctx.fillStyle = fill;
            ctx.miterLimit = 2;
        }
    }, {
        key: 'textSizes',
        value: function textSizes(tile, texts) {
            for (var style in texts) {
                var text_infos = texts[style];

                for (var text in text_infos) {
                    var text_settings = text_infos[text].text_settings;
                    // update text sizes
                    this.setFont(tile, text_settings); // TODO: only set once above
                    _Object$assign(text_infos[text], this.textSize(text, tile, text_settings.transform, text_settings.text_wrap));
                }
            }

            return texts;
        }

        // Computes width and height of text based on current font style
        // Includes word wrapping, returns size info for whole text block and individual lines
    }, {
        key: 'textSize',
        value: function textSize(text, tile, transform, text_wrap) {
            var str = this.applyTextTransform(text, transform);
            var ctx = this.context;
            var buffer = this.text_buffer * _utilsUtils2['default'].device_pixel_ratio;
            var leading = 2 * _utilsUtils2['default'].device_pixel_ratio; // make configurable and/or use Canvas TextMetrics when available
            var line_height = this.px_size + leading; // px_size already in device pixels

            // Word wrapping
            // Line breaks can be caused by:
            //  - implicit line break when a maximum character threshold is exceeded per line (text_wrap)
            //  - explicit line break in the label text (\n)
            var words = undefined;
            if (typeof text_wrap === 'number') {
                words = str.split(' '); // split words on spaces
            } else {
                    words = [str]; // no max line word wrapping (but new lines will still be in effect)
                }
            var new_line_template = { width: 0, chars: 0, text: '' };
            var line = _Object$assign({}, new_line_template); // current line
            var lines = []; // completed lines
            var max_width = 0; // max width to fit all lines

            // add current line buffer to completed lines, optionally start new line
            function addLine(new_line) {
                line.text = line.text.trim();
                if (line.text.length > 0) {
                    line.width = ctx.measureText(line.text).width;
                    max_width = Math.max(max_width, Math.ceil(line.width));
                    lines.push(line);
                }
                if (new_line) {
                    line = _Object$assign({}, new_line_template);
                }
            }

            // First iterate on space-break groups (will be one if max line length off), then iterate on line-break groups
            for (var w = 0; w < words.length; w++) {
                var breaks = words[w].split('\n'); // split on line breaks

                for (var n = 0; n < breaks.length; n++) {
                    var word = breaks[n];

                    // if adding current word would overflow, add a new line instead
                    if (line.chars + word.length > text_wrap && line.chars > 0) {
                        addLine(true);
                    }

                    // add current word (plus space)
                    line.chars += word.length + 1;
                    line.text += word + ' ';

                    // if line breaks present, add new line (unless on last line)
                    if (breaks.length > 1 && n < breaks.length - 1) {
                        addLine(true);
                    }
                }
            }
            addLine(false);

            // Final dimensions of text
            var height = lines.length * line_height;

            var collision_size = [max_width / _utilsUtils2['default'].device_pixel_ratio, height / _utilsUtils2['default'].device_pixel_ratio];

            var texture_size = [max_width + buffer * 2, height + buffer * 2];

            var logical_size = texture_size.map(function (v) {
                return v / _utilsUtils2['default'].device_pixel_ratio;
            });

            // Returns lines (w/per-line info for drawing) and text's overall bounding box + canvas size
            return {
                lines: lines,
                size: { collision_size: collision_size, texture_size: texture_size, logical_size: logical_size, line_height: line_height }
            };
        }

        // Draw one or more lines of text at specified location, adjusting for buffer and baseline
    }, {
        key: 'drawText',
        value: function drawText(lines, _ref2, size, tile, _ref3) {
            var _ref22 = _slicedToArray(_ref2, 2);

            var x = _ref22[0];
            var y = _ref22[1];
            var stroke = _ref3.stroke;
            var transform = _ref3.transform;
            var align = _ref3.align;

            align = align || 'center';

            for (var line_num = 0; line_num < lines.length; line_num++) {
                var line = lines[line_num];
                var str = this.applyTextTransform(line.text, transform);
                var buffer = this.text_buffer * _utilsUtils2['default'].device_pixel_ratio;
                var texture_size = size.texture_size;
                var line_height = size.line_height;

                // Text alignment
                var tx = undefined;
                if (align === 'left') {
                    tx = x + buffer;
                } else if (align === 'center') {
                    tx = x + texture_size[0] / 2 - line.width / 2;
                } else if (align === 'right') {
                    tx = x + texture_size[0] - line.width - buffer;
                }

                // In the absence of better Canvas TextMetrics (not supported by browsers yet),
                // 0.75 buffer produces a better approximate vertical centering of text
                var ty = y + buffer * 0.75 + (line_num + 1) * line_height;

                if (stroke) {
                    this.context.strokeText(str, tx, ty);
                }
                this.context.fillText(str, tx, ty);
            }
        }
    }, {
        key: 'rasterize',
        value: function rasterize(tile, texts, texture_size) {
            for (var style in texts) {
                var text_infos = texts[style];

                for (var text in text_infos) {
                    var info = text_infos[text];

                    this.setFont(tile, info.text_settings); // TODO: only set once above
                    this.drawText(info.lines, info.position, info.size, tile, {
                        stroke: info.text_settings.stroke,
                        transform: info.text_settings.transform,
                        align: info.text_settings.align
                    });

                    info.texcoords = _builders2['default'].getTexcoordsForSprite(info.position, info.size.texture_size, texture_size);
                }
            }
        }

        // Place text labels within an atlas of the given max size
    }, {
        key: 'setTextureTextPositions',
        value: function setTextureTextPositions(texts, max_texture_size) {
            // Find widest label
            var widest = 0;
            for (var style in texts) {
                var text_infos = texts[style];
                for (var text in text_infos) {
                    var size = text_infos[text].size.texture_size;
                    if (size[0] > widest) {
                        widest = size[0];
                    }
                }
            }

            // Layout labels, stacked in columns
            var cx = 0,
                cy = 0; // current x/y position in atlas
            var height = 0; // overall atlas height
            for (var style in texts) {
                var text_infos = texts[style];
                for (var text in text_infos) {
                    var text_info = text_infos[text];
                    var size = text_info.size.texture_size;
                    if (cy + size[1] < max_texture_size) {
                        text_info.position = [cx, cy]; // add label to current column
                        cy += size[1];
                        if (cy > height) {
                            height = cy;
                        }
                    } else {
                        // start new column if taller than texture
                        cx += widest;
                        cy = 0;
                        text_info.position = [cx, cy];
                    }
                }
            }

            return [cx + widest, height]; // overall atlas size
        }

        // Called before rasterization
    }, {
        key: 'applyTextTransform',
        value: function applyTextTransform(text, transform) {
            if (transform === 'capitalize') {
                return text.replace(/\w\S*/g, function (txt) {
                    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                });
            } else if (transform === 'uppercase') {
                return text.toUpperCase();
            } else if (transform === 'lowercase') {
                return text.toLowerCase();
            }
            return text;
        }

        // Convert font CSS-style size ('12px', '14pt', '1.5em', etc.) to pixel size (adjusted for device pixel ratio)
        // Defaults units to pixels if not specified
    }], [{
        key: 'fontPixelSize',
        value: function fontPixelSize(size) {
            if (size == null) {
                return;
            }
            size = typeof size === 'string' ? size : String(size); // need a string for regex

            var _ref4 = size.match(CanvasText.font_size_re) || [];

            var _ref42 = _slicedToArray(_ref4, 3);

            var px_size = _ref42[1];
            var units = _ref42[2];

            units = units || 'px';

            if (units === "em") {
                px_size *= 16;
            } else if (units === "pt") {
                px_size /= 0.75;
            } else if (units === "%") {
                px_size /= 6.25;
            }

            px_size = parseFloat(px_size);
            px_size *= _utilsUtils2['default'].device_pixel_ratio;
            return px_size;
        }
    }]);

    return CanvasText;
})();

exports['default'] = CanvasText;
CanvasText.font_size_re = /((?:[0-9]*\.)?[0-9]+)\s*(px|pt|em|%)?/;
module.exports = exports['default'];

},{"../../utils/utils":247,"../builders":227,"babel-runtime/core-js/object/assign":6,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/interop-require-default":23,"babel-runtime/helpers/sliced-to-array":24}],237:[function(_dereq_,module,exports){
// Text rendering style

'use strict';

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

var _Object$create = _dereq_('babel-runtime/core-js/object/create')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _glTexture = _dereq_('../../gl/texture');

var _glTexture2 = _interopRequireDefault(_glTexture);

var _utilsWorker_broker = _dereq_('../../utils/worker_broker');

var _utilsWorker_broker2 = _interopRequireDefault(_utilsWorker_broker);

var _utilsUtils = _dereq_('../../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _geo = _dereq_('../../geo');

var _geo2 = _interopRequireDefault(_geo);

var _style = _dereq_('../style');

var _pointsPoints = _dereq_('../points/points');

var _canvas_text = _dereq_('./canvas_text');

var _canvas_text2 = _interopRequireDefault(_canvas_text);

var _labelsCollision = _dereq_('../../labels/collision');

var _labelsCollision2 = _interopRequireDefault(_labelsCollision);

var _labelsLabel_point = _dereq_('../../labels/label_point');

var _labelsLabel_point2 = _interopRequireDefault(_labelsLabel_point);

var _labelsLabel_line = _dereq_('../../labels/label_line');

var _labelsLabel_line2 = _interopRequireDefault(_labelsLabel_line);

var _text_settings = _dereq_('./text_settings');

var _text_settings2 = _interopRequireDefault(_text_settings);

var _style_parser = _dereq_('../style_parser');

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var TextStyle = _Object$create(_pointsPoints.Points);

exports.TextStyle = TextStyle;
_Object$assign(TextStyle, {
    name: 'text',
    'super': _pointsPoints.Points,
    built_in: true,
    selection: false, // no feature selection for text by default

    init: function init() {
        this['super'].init.apply(this, arguments);

        // Provide a hook for this object to be called from worker threads
        this.main_thread_target = 'TextStyle-' + this.name;
        if (_utilsUtils2['default'].isMainThread) {
            _utilsWorker_broker2['default'].addTarget(this.main_thread_target, this);
        }

        // Point style (parent class) requires texturing to be turned on
        // (labels are always drawn with textures)
        this.defines.TANGRAM_POINT_TEXTURE = true;

        // Manually un-multiply alpha, because Canvas text rasterization is pre-multiplied
        this.defines.TANGRAM_UNMULTIPLY_ALPHA = true;

        // Fade out text when tile is zooming out, e.g. acting as proxy tiles
        this.defines.TANGRAM_FADE_ON_ZOOM_OUT = true;
        this.defines.TANGRAM_FADE_ON_ZOOM_OUT_RATE = 2; // fade at 2x, e.g. fully transparent at 0.5 zoom level away

        this.reset();
    },

    reset: function reset() {
        this['super'].reset.call(this);
        if (_utilsUtils2['default'].isMainThread) {
            this.canvas = new _canvas_text2['default']();
        } else if (_utilsUtils2['default'].isWorkerThread) {
            this.texts = {}; // unique texts, grouped by tile, by style
        }
    },

    // Called on worker thread to release tile-specific resources
    freeTile: function freeTile(tile) {
        delete this.texts[tile.key];
    },

    // Free tile-specific resources before finshing style construction
    finishTile: function finishTile(tile) {
        this.freeTile(tile);
        return _style.Style.endData.call(this, tile);
    },

    // Override to queue features instead of processing immediately
    addFeature: function addFeature(feature, draw, context) {
        var tile = context.tile;
        if (tile.generation !== this.generation) {
            return;
        }

        // Called here because otherwise it will be delayed until the feature queue is parsed,
        // and we want the preprocessing done before we evaluate text style below
        draw = this.preprocess(draw);
        if (!draw) {
            return;
        }

        // Compute label text
        var text = this.parseTextSource(feature, draw, context);
        if (text == null) {
            return; // no text for this feature
        }

        // Compute text style and layout settings for this feature label
        var layout = this.computeLayout({}, feature, draw, context, tile, text);
        var text_settings = _text_settings2['default'].compute(feature, draw, context);
        var text_settings_key = _text_settings2['default'].key(text_settings);

        // first label in tile, or with this style?
        this.texts[tile.key] = this.texts[tile.key] || {};
        this.texts[tile.key][text_settings_key] = this.texts[tile.key][text_settings_key] || {};

        // unique text strings, grouped by text drawing style
        if (!this.texts[tile.key][text_settings_key][text]) {
            // first label with this text/style/tile combination, make a new label entry
            this.texts[tile.key][text_settings_key][text] = {
                text_settings: text_settings,
                ref: 0 // # of times this text/style combo appears in tile
            };
        }

        // Queue the feature for processing
        if (!this.tile_data[tile.key]) {
            this.startData(tile);
        }

        if (!this.queues[tile.key]) {
            this.queues[tile.key] = [];
        }

        this.queues[tile.key].push({
            feature: feature, draw: draw, context: context,
            text: text, text_settings_key: text_settings_key, layout: layout
        });

        // Register with collision manager
        _labelsCollision2['default'].addStyle(this.name, tile.key);
    },

    // Override
    endData: function endData(tile) {
        var _this = this;

        var queue = this.queues[tile.key];
        this.queues[tile.key] = [];

        if (_Object$keys(this.texts[tile.key] || {}).length === 0) {
            return _Promise.resolve();
        }

        // first call to main thread, ask for text pixel sizes
        return _utilsWorker_broker2['default'].postMessage(this.main_thread_target + '.calcTextSizes', tile.key, this.texts[tile.key]).then(function (texts) {
            if (tile.canceled) {
                _utilsUtils2['default'].log('trace', 'Style ' + _this.name + ': stop tile build because tile was canceled: ' + tile.key + ', post-calcTextSizes()');
                return;
            }

            if (!texts) {
                _labelsCollision2['default'].collide({}, _this.name, tile.key);
                return _this.finishTile(tile);
            }
            _this.texts[tile.key] = texts;

            var labels = _this.createLabels(tile.key, queue);

            return _labelsCollision2['default'].collide(labels, _this.name, tile.key).then(function (labels) {
                if (tile.canceled) {
                    _utilsUtils2['default'].log('trace', 'stop tile build because tile was canceled: ' + tile.key + ', post-collide()');
                    return;
                }

                if (labels.length === 0) {
                    return _this.finishTile(tile); // no labels visible for this tile
                }

                _this.cullTextStyles(texts, labels);

                // second call to main thread, for rasterizing the set of texts
                return _utilsWorker_broker2['default'].postMessage(_this.main_thread_target + '.rasterizeTexts', tile.key, texts).then(function (_ref) {
                    var texts = _ref.texts;
                    var texture = _ref.texture;

                    if (tile.canceled) {
                        _utilsUtils2['default'].log('trace', 'stop tile build because tile was canceled: ' + tile.key + ', post-rasterizeTexts()');
                        return;
                    }

                    if (texts) {
                        _this.texts[tile.key] = texts;

                        // Build queued features
                        labels.forEach(function (q) {
                            var text_settings_key = q.text_settings_key;
                            var text_info = _this.texts[tile.key] && _this.texts[tile.key][text_settings_key] && _this.texts[tile.key][text_settings_key][q.text];

                            // setup styling object expected by Style class
                            var style = _this.feature_style;
                            style.label = q.label;
                            style.size = text_info.size.logical_size;
                            style.angle = _utilsUtils2['default'].radToDeg(q.label.angle) || 0;
                            style.texcoords = text_info.texcoords;

                            _style.Style.addFeature.call(_this, q.feature, q.draw, q.context);
                        });
                    }

                    return _this.finishTile(tile).then(function (tile_data) {
                        // Attach tile-specific label atlas to mesh as a texture uniform
                        if (texture && tile_data) {
                            tile_data.uniforms = { u_texture: texture };
                            tile_data.textures = [texture]; // assign texture ownership to tile
                            return tile_data;
                        }
                    });
                });
            });
        });
    },

    createLabels: function createLabels(tile_key, feature_queue) {
        var labels = [];

        for (var f = 0; f < feature_queue.length; f++) {
            var _feature_queue$f = feature_queue[f];
            var feature = _feature_queue$f.feature;
            var draw = _feature_queue$f.draw;
            var context = _feature_queue$f.context;
            var text = _feature_queue$f.text;
            var text_settings_key = _feature_queue$f.text_settings_key;
            var layout = _feature_queue$f.layout;

            var text_info = this.texts[tile_key][text_settings_key][text];

            var feature_labels = this.buildLabelsFromGeometry(text_info.size.collision_size, feature.geometry, layout);
            for (var i = 0; i < feature_labels.length; i++) {
                var label = feature_labels[i];
                labels.push({
                    feature: feature, draw: draw, context: context,
                    text: text, text_settings_key: text_settings_key, layout: layout, label: label
                });
            }
        }

        return labels;
    },

    // Remove unused text/style combinations to avoid unnecessary rasterization
    cullTextStyles: function cullTextStyles(texts, labels) {
        // Count how many times each text/style combination is used
        for (var i = 0; i < labels.length; i++) {
            texts[labels[i].text_settings_key][labels[i].text].ref++;
        }

        // Remove text/style combinations that have no visible labels
        for (var style in texts) {
            for (var text in texts[style]) {
                // no labels for this text
                if (texts[style][text].ref < 1) {
                    // console.log(`drop label text ${text} in style ${style}`);
                    delete texts[style][text];
                }
            }
        }

        for (var style in texts) {
            // no labels for this style
            if (_Object$keys(texts[style]).length === 0) {
                // console.log(`drop label text style ${style}`);
                delete texts[style];
            }
        }
    },

    // Called on main thread from worker, to compute the size of each text string,
    // were it to be rendered. This info is then used to perform initial label culling, *before*
    // labels are actually rendered.
    calcTextSizes: function calcTextSizes(tile_key, texts) {
        return this.canvas.textSizes(tile_key, texts);
    },

    // Called on main thread from worker, to create atlas of labels for a tile
    rasterizeTexts: function rasterizeTexts(tile_key, texts) {
        var canvas = new _canvas_text2['default']();
        var texture_size = canvas.setTextureTextPositions(texts, this.max_texture_size);
        _loglevel2['default'].trace('text summary for tile ' + tile_key + ': fits in ' + texture_size[0] + 'x' + texture_size[1] + 'px');

        // fits in max texture size?
        if (texture_size[0] < this.max_texture_size && texture_size[1] < this.max_texture_size) {
            // update canvas size & rasterize all the text strings we need
            canvas.resize.apply(canvas, _toConsumableArray(texture_size));
            canvas.rasterize(tile_key, texts, texture_size);
        } else {
            _loglevel2['default'].error(['Label atlas for tile ' + tile_key + ' is ' + texture_size[0] + 'x' + texture_size[1] + 'px, ', 'but max GL texture size is ' + this.max_texture_size + 'x' + this.max_texture_size + 'px'].join(''));
        }

        // create a texture
        var t = 'labels-' + tile_key + '-' + TextStyle.texture_id++;
        _glTexture2['default'].create(this.gl, t, {
            element: canvas.canvas,
            filtering: 'linear',
            UNPACK_PREMULTIPLY_ALPHA_WEBGL: true
        });

        return { texts: texts, texture: t }; // texture is returned by name (not instance)
    },

    // Sets up caching for draw rule properties
    _preprocess: function _preprocess(draw) {
        if (!draw.font) {
            return;
        }

        // Colors
        draw.font.fill = _style_parser.StyleParser.cacheObject(draw.font.fill);
        if (draw.font.stroke) {
            draw.font.stroke.color = _style_parser.StyleParser.cacheObject(draw.font.stroke.color);
        }

        // Convert font and text stroke sizes
        draw.font.px_size = _style_parser.StyleParser.cacheObject(draw.font.size, _canvas_text2['default'].fontPixelSize);
        if (draw.font.stroke && draw.font.stroke.width != null) {
            draw.font.stroke.width = _style_parser.StyleParser.cacheObject(draw.font.stroke.width, parseFloat);
        }

        // Offset (2d array)
        draw.offset = _style_parser.StyleParser.cacheObject(draw.offset, function (v) {
            return Array.isArray(v) && v.map(parseFloat) || 0;
        });

        // Buffer (1d value or or 2d array)
        draw.buffer = _style_parser.StyleParser.cacheObject(draw.buffer, function (v) {
            return (Array.isArray(v) ? v : [v, v]).map(parseFloat) || 0;
        });

        // Repeat rules
        draw.repeat_distance = _style_parser.StyleParser.cacheObject(draw.repeat_distance, parseFloat);

        return draw;
    },

    // Compute the label text, default is value of feature.properties.name
    // - String value indicates a feature property look-up, e.g. `short_name` means use feature.properties.short_name
    // - Function will use the return value as the label text (for custom labels)
    // - Array (of strings and/or functions) defines a list of fallbacks, evaluated according to the above rules,
    //   with the first non-null value used as the label text
    //   e.g. `[name:es, name:en, name]` prefers Spanish names, followed by English, and last the default local name
    parseTextSource: function parseTextSource(feature, draw, context) {
        var text = undefined;
        var source = draw.text_source || 'name';

        if (Array.isArray(source)) {
            for (var s = 0; s < source.length; s++) {
                if (typeof source[s] === 'string') {
                    text = feature.properties[source[s]];
                } else if (typeof source[s] === 'function') {
                    text = source[s](context);
                }

                if (text) {
                    break; // stop if we found a text property
                }
            }
        } else if (typeof source === 'string') {
                text = feature.properties[source];
            } else if (typeof source === 'function') {
                text = source(context);
            }
        return text;
    },

    // Additional text-specific layout settings
    computeLayout: function computeLayout(target, feature, draw, context, tile, text) {
        var layout = target || {};

        // common settings w/points
        layout = _pointsPoints.Points.computeLayout(layout, feature, draw, context, tile);

        // tile boundary handling
        layout.cull_from_tile = draw.cull_from_tile != null ? draw.cull_from_tile : true;
        layout.move_into_tile = draw.move_into_tile != null ? draw.move_into_tile : true;

        // label line exceed percentage
        if (draw.line_exceed && draw.line_exceed.substr(-1) === '%') {
            layout.line_exceed = parseFloat(draw.line_exceed.substr(0, draw.line_exceed.length - 1));
        } else {
            layout.line_exceed = 80;
        }

        // repeat minimum distance
        layout.repeat_distance = _style_parser.StyleParser.cacheProperty(draw.repeat_distance, context);
        if (layout.repeat_distance == null) {
            layout.repeat_distance = _geo2['default'].tile_size;
        }
        layout.repeat_distance *= layout.units_per_pixel;

        // repeat group key
        if (typeof draw.repeat_group === 'function') {
            layout.repeat_group = draw.repeat_group(context);
        } else if (typeof draw.repeat_group === 'string') {
            layout.repeat_group = draw.repeat_group;
        } else {
            layout.repeat_group = draw.key; // default to unique set of matching layers
        }
        layout.repeat_group += '/' + text;

        return layout;
    },

    // Builds one or more labels for a geometry
    buildLabelsFromGeometry: function buildLabelsFromGeometry(size, geometry, options) {
        var labels = [];

        if (geometry.type === "LineString") {
            var lines = geometry.coordinates;

            labels.push(new _labelsLabel_line2['default'](size, lines, options));
        } else if (geometry.type === "MultiLineString") {
            var lines = geometry.coordinates;

            for (var i = 0; i < lines.length; ++i) {
                var line = lines[i];
                labels.push(new _labelsLabel_line2['default'](size, line, options));
            }
        } else if (geometry.type === "Point") {
            labels.push(new _labelsLabel_point2['default'](geometry.coordinates, size, options));
        } else if (geometry.type === "MultiPoint") {
            var points = geometry.coordinates;

            for (var i = 0; i < points.length; ++i) {
                var point = points[i];
                labels.push(new _labelsLabel_point2['default'](point, size, options));
            }
        } else if (geometry.type === "Polygon") {
            var centroid = _geo2['default'].centroid(geometry.coordinates[0]);
            labels.push(new _labelsLabel_point2['default'](centroid, size, options));
        } else if (geometry.type === "MultiPolygon") {
            var centroid = _geo2['default'].multiCentroid(geometry.coordinates);
            labels.push(new _labelsLabel_point2['default'](centroid, size, options));
        }

        return labels;
    }

});

TextStyle.texture_id = 0; // namespaces per-tile label textures

},{"../../geo":197,"../../gl/texture":205,"../../labels/collision":210,"../../labels/label_line":212,"../../labels/label_point":213,"../../utils/utils":247,"../../utils/worker_broker":249,"../points/points":230,"../style":233,"../style_parser":235,"./canvas_text":236,"./text_settings":238,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/create":7,"babel-runtime/core-js/object/keys":12,"babel-runtime/core-js/promise":14,"babel-runtime/helpers/interop-require-default":23,"babel-runtime/helpers/to-consumable-array":25,"loglevel":183}],238:[function(_dereq_,module,exports){
'use strict';

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsUtils = _dereq_('../../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _geo = _dereq_('../../geo');

var _geo2 = _interopRequireDefault(_geo);

var _style_parser = _dereq_('../style_parser');

var _pointsPoint_anchor = _dereq_('../points/point_anchor');

var _pointsPoint_anchor2 = _interopRequireDefault(_pointsPoint_anchor);

var TextSettings;

exports['default'] = TextSettings = {

    // A key for grouping all labels of the same text style (e.g. same Canvas state, to minimize state changes)
    key: function key(settings) {
        return [settings.style, settings.weight, settings.family, settings.px_size, settings.fill, settings.stroke, settings.stroke_width, settings.transform, settings.typeface, settings.text_wrap, settings.align].join('/'); // typeface for legacy
    },

    defaults: {
        style: 'normal',
        weight: null,
        size: '12px',
        px_size: 12,
        family: 'Helvetica',
        fill: 'white',
        text_wrap: 15,
        align: 'center'
    },

    compute: function compute(feature, draw, context) {
        var style = {};

        draw.font = draw.font || this.defaults;

        // Use fill if specified, or default
        style.fill = draw.font.fill && _utilsUtils2['default'].toCSSColor(_style_parser.StyleParser.cacheColor(draw.font.fill, context)) || this.defaults.fill;

        // Font properties are modeled after CSS names:
        // - family: Helvetica, Futura, etc.
        // - size: in pt, px, or em
        // - style: normal, italic, oblique
        // - weight: normal, bold, etc.
        // - transform: capitalize, uppercase, lowercase
        style.style = draw.font.style || this.defaults.style;
        style.weight = draw.font.weight || this.defaults.weight;
        style.family = (draw.font.family ? draw.font.family + ', ' : '') + this.defaults.family;
        style.transform = draw.font.transform;

        // original size (not currently used, but useful for debugging)
        style.size = draw.font.size || draw.font.typeface || this.defaults.size; // TODO: 'typeface' legacy syntax, deprecate

        // calculated pixel size
        style.px_size = _style_parser.StyleParser.cacheProperty(draw.font.px_size, context) || this.defaults.px_size;

        // Use stroke if specified
        if (draw.font.stroke && draw.font.stroke.color) {
            style.stroke = _utilsUtils2['default'].toCSSColor(_style_parser.StyleParser.cacheColor(draw.font.stroke.color, context) || this.defaults.stroke);
            style.stroke_width = _style_parser.StyleParser.cacheProperty(draw.font.stroke.width, context) || this.defaults.stroke_width;
            style.stroke_width *= _utilsUtils2['default'].device_pixel_ratio;
        }

        if (draw.font.typeface) {
            // 'typeface' legacy syntax, deprecate
            style.font_css = draw.font.typeface;
        } else {
            style.font_css = this.fontCSS(style);
        }

        // Word wrap and text alignment
        // Not a font properties, but affect atlas of unique text textures
        var text_wrap = draw.text_wrap; // use explicitly set value
        if (text_wrap == null && _geo2['default'].geometryType(feature.geometry.type) !== 'line') {
            // point labels (for point and polygon features) have word wrap on w/default max length,
            // line labels default off
            text_wrap = true;
        }

        // setting to 'true' causes default wrap value to be used
        if (text_wrap === true) {
            text_wrap = this.defaults.text_wrap;
        }
        style.text_wrap = text_wrap;

        // default alignment to match anchor
        if (!draw.align && draw.anchor && draw.anchor !== 'center') {
            if (_pointsPoint_anchor2['default'].isLeftAnchor(draw.anchor)) {
                draw.align = 'right';
            } else if (_pointsPoint_anchor2['default'].isRightAnchor(draw.anchor)) {
                draw.align = 'left';
            }
        }

        style.align = draw.align || this.defaults.align;

        return style;
    },

    // Build CSS-style font string (to set Canvas draw state)
    fontCSS: function fontCSS(_ref) {
        var style = _ref.style;
        var weight = _ref.weight;
        var px_size = _ref.px_size;
        var family = _ref.family;

        return [style, weight, px_size + 'px', family].filter(function (x) {
            return x;
        }) // remove null props
        .join(' ');
    }

};
module.exports = exports['default'];

},{"../../geo":197,"../../utils/utils":247,"../points/point_anchor":229,"../style_parser":235,"babel-runtime/helpers/interop-require-default":23}],239:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _geo = _dereq_('./geo');

var _geo2 = _interopRequireDefault(_geo);

var _stylesStyle_parser = _dereq_('./styles/style_parser');

var _stylesStyle_manager = _dereq_('./styles/style_manager');

var _labelsCollision = _dereq_('./labels/collision');

var _labelsCollision2 = _interopRequireDefault(_labelsCollision);

var _utilsWorker_broker = _dereq_('./utils/worker_broker');

var _utilsWorker_broker2 = _interopRequireDefault(_utilsWorker_broker);

var _glTexture = _dereq_('./gl/texture');

var _glTexture2 = _interopRequireDefault(_glTexture);

var _utilsUtils = _dereq_('./utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _utilsGlMatrix = _dereq_('./utils/gl-matrix');

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var Tile = (function () {

    /**
        Tile
        @constructor
        Required properties:
        coords: object with {x, y, z} properties identifying tile coordinate location
        worker: web worker to handle tile construction
    */

    function Tile(_ref) {
        var coords = _ref.coords;
        var style_zoom = _ref.style_zoom;
        var source = _ref.source;
        var worker = _ref.worker;
        var view = _ref.view;

        _classCallCheck(this, Tile);

        this.worker = worker;
        this.view = view;
        this.source = source;
        this.generation = null;

        this.visible = false;
        this.proxy = null;
        this.proxy_depth = 0;
        this.loading = false;
        this.loaded = false;
        this.error = null;
        this.debug = {};

        this.coords = Tile.coordinateWithMaxZoom(coords, this.source.max_zoom);
        this.style_zoom = style_zoom; // zoom level to be used for styling
        this.key = Tile.key(this.coords, this.source, this.style_zoom);
        this.min = _geo2['default'].metersForTile(this.coords);
        this.max = _geo2['default'].metersForTile({ x: this.coords.x + 1, y: this.coords.y + 1, z: this.coords.z }), this.span = { x: this.max.x - this.min.x, y: this.max.y - this.min.y };
        this.bounds = { sw: { x: this.min.x, y: this.max.y }, ne: { x: this.max.x, y: this.min.y } };
        this.center_dist = 0;

        // Units per pixel needs to account for over-zooming
        this.units_per_pixel = _geo2['default'].units_per_pixel;
        if (this.style_zoom > this.coords.z) {
            this.units_per_pixel /= Math.pow(2, this.style_zoom - this.coords.z);
        }

        this.meters_per_pixel = _geo2['default'].metersPerPixel(this.coords.z);
        this.units_per_meter = _geo2['default'].unitsPerMeter(this.coords.z);

        this.meshes = {}; // renderable VBO meshes keyed by style
        this.textures = []; // textures that the tile owns (labels, etc.)
    }

    _createClass(Tile, [{
        key: 'freeResources',

        // Free resources owned by tile
        // Optionally pass textures to preserve
        value: function freeResources() {
            var preserve = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            if (this.meshes) {
                for (var m in this.meshes) {
                    this.meshes[m].destroy();
                }
            }

            if (this.textures) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = _getIterator(this.textures), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var t = _step.value;

                        if (!preserve.textures || preserve.textures.indexOf(t) === -1) {
                            var texture = _glTexture2['default'].textures[t];
                            if (texture) {
                                texture.destroy();
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator['return']) {
                            _iterator['return']();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }

            this.meshes = {};
            this.textures = [];
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.workerMessage('self.removeTile', this.key);
            this.freeResources();
            this.worker = null;
        }
    }, {
        key: 'buildAsMessage',
        value: function buildAsMessage() {
            return {
                key: this.key,
                source: this.source.name,
                coords: this.coords,
                min: this.min,
                max: this.max,
                units_per_pixel: this.units_per_pixel,
                meters_per_pixel: this.meters_per_pixel,
                units_per_meter: this.units_per_meter,
                style_zoom: this.style_zoom,
                generation: this.generation,
                debug: this.debug
            };
        }
    }, {
        key: 'workerMessage',
        value: function workerMessage() {
            for (var _len = arguments.length, message = Array(_len), _key = 0; _key < _len; _key++) {
                message[_key] = arguments[_key];
            }

            return _utilsWorker_broker2['default'].postMessage.apply(_utilsWorker_broker2['default'], [this.worker].concat(message));
        }
    }, {
        key: 'build',
        value: function build(generation) {
            this.generation = generation;
            if (!this.loaded) {
                this.loading = true;
            }
            return this.workerMessage('self.buildTile', { tile: this.buildAsMessage() })['catch'](function (e) {
                throw e;
            });
        }

        /**
            Called on worker to cancel loading
            Static method because the worker only has object representations of tile data, there is no
            tile instance created yet.
        */
    }, {
        key: 'buildMeshes',

        /**
           Called on main thread when a web worker completes processing
           for a single tile.
        */
        value: function buildMeshes(styles) {
            if (this.error) {
                return;
            }

            // Debug
            this.debug.geometries = 0;
            this.debug.buffer_size = 0;

            // Create VBOs
            var meshes = {},
                textures = []; // new resources, to be swapped in
            var mesh_data = this.mesh_data;
            if (mesh_data) {
                for (var s in mesh_data) {
                    if (mesh_data[s].vertex_data) {
                        this.debug.buffer_size += mesh_data[s].vertex_data.byteLength;
                        if (!styles[s]) {
                            _loglevel2['default'].warn('Could not create mesh because style \'' + s + '\' not found, for tile ' + this.key + ', aborting tile');
                            break;
                        }
                        meshes[s] = styles[s].makeMesh(mesh_data[s].vertex_data, mesh_data[s]);
                        this.debug.geometries += meshes[s].geometry_count;
                    }

                    // Assign ownership to textures if needed
                    if (mesh_data[s].textures) {
                        textures.push.apply(textures, _toConsumableArray(mesh_data[s].textures));
                    }
                }
            }
            delete this.mesh_data; // TODO: might want to preserve this for rebuilding geometries when styles/etc. change?

            // Swap in new data, free old data
            this.freeResources({ textures: textures }); // textures to preserve are passed (avoid flickering from delete/re-create)
            this.meshes = meshes;
            this.textures = textures;

            this.debug.geom_ratio = (this.debug.geometries / this.debug.features).toFixed(1);
            this.printDebug();
        }

        /**
            Called on main thread when web worker completes processing, but tile has since been discarded
            Frees resources that would have been transferred to the tile object.
            Static method because the tile object no longer exists (the tile data returned by the worker is passed instead).
        */
    }, {
        key: 'update',

        // Update relative to view
        value: function update() {
            var coords = this.coords;
            if (coords.z !== this.view.center.tile.z) {
                coords = Tile.coordinateAtZoom(coords, this.view.center.tile.z);
            }
            this.center_dist = Math.abs(this.view.center.tile.x - coords.x) + Math.abs(this.view.center.tile.y - coords.y);
        }

        // Set as a proxy tile for another tile
    }, {
        key: 'setProxyFor',
        value: function setProxyFor(tile) {
            this.proxy = tile;
            if (tile) {
                this.visible = true;
                this.proxy_depth = 1; // draw proxies a half-layer back (order is scaled 2x to avoid integer truncation)
                this.update();
            } else {
                this.proxy_depth = 0;
            }
        }

        // Update model matrix and tile uniforms
    }, {
        key: 'setupProgram',
        value: function setupProgram(_ref2, program) {
            var model = _ref2.model;
            var model32 = _ref2.model32;

            // Tile origin
            program.uniform('4f', 'u_tile_origin', this.min.x, this.min.y, this.style_zoom, this.coords.z);
            program.uniform('1f', 'u_tile_proxy_depth', this.proxy_depth);

            // Model - transform tile space into world space (meters, absolute mercator position)
            _utilsGlMatrix.mat4.identity(model);
            _utilsGlMatrix.mat4.translate(model, model, _utilsGlMatrix.vec3.fromValues(this.min.x, this.min.y, 0));
            _utilsGlMatrix.mat4.scale(model, model, _utilsGlMatrix.vec3.fromValues(this.span.x / _geo2['default'].tile_scale, -1 * this.span.y / _geo2['default'].tile_scale, 1)); // scale tile local coords to meters
            _utilsGlMatrix.mat4.copy(model32, model);
            program.uniform('Matrix4fv', 'u_model', false, model32);
        }

        // Slice a subset of keys out of a tile
        // Includes a minimum set of pre-defined keys for load state, debug. etc.
        // We use this to send a subset of the tile back to the main thread, to minimize unnecessary data transfer
        // (e.g. very large items like feature geometry are not needed on the main thread)
    }, {
        key: 'merge',
        value: function merge(other) {
            for (var key in other) {
                if (key !== 'key') {
                    this[key] = other[key];
                }
            }
            return this;
        }
    }, {
        key: 'printDebug',
        value: function printDebug() {
            _loglevel2['default'].debug('Tile: debug for ' + this.key + ': [  ' + JSON.stringify(this.debug) + ' ]');
        }
    }], [{
        key: 'create',
        value: function create(spec) {
            return new Tile(spec);
        }
    }, {
        key: 'coord',
        value: function coord(c) {
            return { x: c.x, y: c.y, z: c.z, key: Tile.coordKey(c) };
        }
    }, {
        key: 'coordKey',
        value: function coordKey(_ref3) {
            var x = _ref3.x;
            var y = _ref3.y;
            var z = _ref3.z;

            return x + '/' + y + '/' + z;
        }
    }, {
        key: 'key',
        value: function key(coords, source, style_zoom) {
            coords = Tile.coordinateWithMaxZoom(coords, source.max_zoom);
            if (coords.y < 0 || coords.y >= 1 << coords.z || coords.z < 0) {
                return; // cull tiles out of range (x will wrap)
            }
            return [source.name, style_zoom, coords.x, coords.y, coords.z].join('/');
        }
    }, {
        key: 'coordinateAtZoom',
        value: function coordinateAtZoom(_ref4, zoom) {
            var x = _ref4.x;
            var y = _ref4.y;
            var z = _ref4.z;
            var key = _ref4.key;

            if (z !== zoom) {
                var zscale = Math.pow(2, z - zoom);
                x = Math.floor(x / zscale);
                y = Math.floor(y / zscale);
                z = zoom;
            }
            return Tile.coord({ x: x, y: y, z: z });
        }
    }, {
        key: 'coordinateWithMaxZoom',
        value: function coordinateWithMaxZoom(_ref5, max_zoom) {
            var x = _ref5.x;
            var y = _ref5.y;
            var z = _ref5.z;

            if (max_zoom !== undefined && z > max_zoom) {
                return Tile.coordinateAtZoom({ x: x, y: y, z: z }, max_zoom);
            }
            return Tile.coord({ x: x, y: y, z: z });
        }
    }, {
        key: 'childrenForCoordinate',
        value: function childrenForCoordinate(_ref6) {
            var x = _ref6.x;
            var y = _ref6.y;
            var z = _ref6.z;
            var key = _ref6.key;

            if (!Tile.coord_children[key]) {
                z++;
                x *= 2;
                y *= 2;
                Tile.coord_children[key] = [Tile.coord({ x: x, y: y, z: z }), Tile.coord({ x: x + 1, y: y, z: z }), Tile.coord({ x: x, y: y + 1, z: z }), Tile.coord({ x: x + 1, y: y + 1, z: z })];
            }
            return Tile.coord_children[key];
        }
    }, {
        key: 'isDescendant',
        value: function isDescendant(parent, descendant) {
            if (descendant.z > parent.z) {
                var _Tile$coordinateAtZoom = Tile.coordinateAtZoom(descendant, parent.z);

                var x = _Tile$coordinateAtZoom.x;
                var y = _Tile$coordinateAtZoom.y;

                return parent.x === x && parent.y === y;
            }
            return false;
        }

        // Sort a set of tile instances (which already have a distance from center tile computed)
    }, {
        key: 'sort',
        value: function sort(tiles) {
            return tiles.sort(function (a, b) {
                var ad = a.center_dist;
                var bd = b.center_dist;
                return bd > ad ? -1 : bd === ad ? 0 : 1;
            });
        }
    }, {
        key: 'cancel',
        value: function cancel(tile) {
            if (tile) {
                tile.canceled = true;
                if (tile.source_data && tile.source_data.request) {
                    tile.source_data.request.abort();
                }
                Tile.abortBuild(tile);
            }
        }

        // Process geometry for tile - called by web worker
        // Returns a set of tile keys that should be sent to the main thread (so that we can minimize data exchange between worker and main thread)
    }, {
        key: 'buildGeometry',
        value: function buildGeometry(tile, layers, rules, styles) {
            tile.debug.rendering = +new Date();
            tile.debug.features = 0;

            var data = tile.source_data;

            _labelsCollision2['default'].startTile(tile.key);

            // Treat top-level style rules as 'layers'
            for (var layer_name in layers) {
                var layer = layers[layer_name];
                // Skip layers with no data source defined
                if (!layer || !layer.data) {
                    _loglevel2['default'].warn('Layer ' + layer + ' was defined without a geometry data source and will not be rendered.');
                    continue;
                }

                // Source names don't match
                if (layer.data.source !== tile.source) {
                    continue;
                }

                // Get data for one or more layers from source
                var source_layers = Tile.getDataForSource(data, layer.data, layer_name);

                // Render features in layer
                for (var s = 0; s < source_layers.length; s++) {
                    var source_layer = source_layers[s];
                    var geom = source_layer.geom;
                    if (!geom) {
                        continue;
                    }

                    for (var f = 0; f < geom.features.length; f++) {
                        var feature = geom.features[f];
                        if (feature.geometry == null) {
                            continue; // skip features w/o geometry (valid GeoJSON)
                        }

                        if (tile.canceled) {
                            _utilsUtils2['default'].log('debug', 'stop tile build because tile after ' + tile.debug.features + ' because it was removed: ' + tile.key);
                            return;
                        }

                        var context = _stylesStyle_parser.StyleParser.getFeatureParseContext(feature, tile);
                        context.winding = tile.default_winding;
                        context.layer = source_layer.layer; // add data source layer name

                        // Get draw groups for this feature
                        var layer_rules = rules[layer_name];
                        var draw_groups = layer_rules.buildDrawGroups(context, true);
                        if (!draw_groups) {
                            continue;
                        }

                        // Render draw groups
                        for (var group_name in draw_groups) {
                            var group = draw_groups[group_name];
                            if (!group.visible) {
                                continue;
                            }

                            // Add to style
                            var style_name = group.style || group_name;
                            var style = styles[style_name];

                            if (!style) {
                                _loglevel2['default'].warn('Style \'' + style_name + '\' not found for rule in layer \'' + layer_name + '\':', group, feature);
                                continue;
                            }

                            context.layers = group.layers; // add matching draw layers
                            context.properties = group.properties; // add rule-specific properties to context

                            style.addFeature(feature, group, context);

                            context.properties = null; // clear group-specific properties
                        }

                        tile.debug.features++;
                    }
                }
            }
            tile.debug.rendering = +new Date() - tile.debug.rendering;

            // Finalize array buffer for each render style
            var tile_styles = _stylesStyle_manager.StyleManager.stylesForTile(tile.key);
            tile.mesh_data = {};
            var queue = [];

            var _loop = function (s) {
                var style_name = tile_styles[s];
                var style = styles[style_name];
                queue.push(style.endData(tile).then(function (style_data) {
                    if (style_data) {
                        tile.mesh_data[style_name] = {
                            vertex_data: style_data.vertex_data,
                            uniforms: style_data.uniforms,
                            textures: style_data.textures
                        };
                    }
                }));
            };

            for (var s = 0; s < tile_styles.length; s++) {
                _loop(s);
            }

            return _Promise.all(queue).then(function () {
                _labelsCollision2['default'].resetTile(tile.key);

                // Return keys to be transfered to main thread
                return ['mesh_data'];
            });
        }

        /**
            Retrieves geometry from a tile according to a data source definition
            Returns an array of objects with:
                layer: source layer name
                geom: GeoJSON FeatureCollection
        */
    }, {
        key: 'getDataForSource',
        value: function getDataForSource(source_data, source_config) {
            var default_layer = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

            var layers = [];

            if (source_config != null) {
                // If no layer specified, and a default source layer exists
                if (!source_config.layer && source_data.layers._default) {
                    layers.push({
                        layer: '_default',
                        geom: source_data.layers._default
                    });
                }
                // If no layer specified, and a default requested layer exists
                else if (!source_config.layer && default_layer) {
                        layers.push({
                            layer: default_layer,
                            geom: source_data.layers[default_layer]
                        });
                    }
                    // If a layer is specified by name, use it
                    else if (typeof source_config.layer === 'string') {
                            layers.push({
                                layer: source_config.layer,
                                geom: source_data.layers[source_config.layer]
                            });
                        }
                        // If multiple layers are specified by name, combine them
                        else if (Array.isArray(source_config.layer)) {
                                source_config.layer.forEach(function (layer) {
                                    if (source_data.layers[layer] && source_data.layers[layer].features) {
                                        layers.push({
                                            layer: layer,
                                            geom: source_data.layers[layer]
                                        });
                                    }
                                });
                            }
                            // Assemble a custom layer via a function, which is called with all source layers
                            else if (typeof source_config.layer === 'function') {
                                    layers.push({
                                        geom: source_config.layer(source_data.layers)
                                        // custom layer has no name
                                    });
                                }
            }

            return layers;
        }
    }, {
        key: 'abortBuild',
        value: function abortBuild(tile) {
            if (tile.mesh_data) {
                for (var s in tile.mesh_data) {
                    var textures = tile.mesh_data[s].textures;
                    if (textures) {
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = _getIterator(textures), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var t = _step2.value;

                                var texture = _glTexture2['default'].textures[t];
                                if (texture) {
                                    _loglevel2['default'].trace('destroying texture ' + t + ' for tile ' + tile.key);
                                    texture.destroy();
                                }
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                                    _iterator2['return']();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }
                    }
                }
            }
        }
    }, {
        key: 'slice',
        value: function slice(tile, keys) {
            var keep = ['key', 'loading', 'loaded', 'generation', 'error', 'debug'];
            if (Array.isArray(keys)) {
                keep.push.apply(keep, _toConsumableArray(keys));
            }

            // Build the tile subset
            var tile_subset = {};
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = _getIterator(keep), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var key = _step3.value;

                    tile_subset[key] = tile[key];
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                        _iterator3['return']();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            return tile_subset;
        }
    }]);

    return Tile;
})();

exports['default'] = Tile;

Tile.coord_children = {}; // only allocate children coordinates once per coordinate
module.exports = exports['default'];

},{"./geo":197,"./gl/texture":205,"./labels/collision":210,"./styles/style_manager":234,"./styles/style_parser":235,"./utils/gl-matrix":243,"./utils/utils":247,"./utils/worker_broker":249,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/promise":14,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/interop-require-default":23,"babel-runtime/helpers/to-consumable-array":25,"loglevel":183}],240:[function(_dereq_,module,exports){
'use strict';

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _tile = _dereq_('./tile');

var _tile2 = _interopRequireDefault(_tile);

var _tile_pyramid = _dereq_('./tile_pyramid');

var _tile_pyramid2 = _interopRequireDefault(_tile_pyramid);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var TileManager = {

    init: function init(_ref) {
        var scene = _ref.scene;
        var view = _ref.view;

        this.scene = scene;
        this.view = view;
        this.tiles = {};
        this.pyramid = _tile_pyramid2['default'];
        this.pyramid.reset();
        this.visible_coords = {};
        this.queued_coords = [];
        this.building_tiles = null;
    },

    destroy: function destroy() {
        this.forEachTile(function (tile) {
            return tile.destroy();
        });
        this.tiles = {};
        this.pyramid.reset();
        this.visible_coords = {};
        this.queued_coords = [];
        this.scene = null;
        this.view = null;
    },

    keepTile: function keepTile(tile) {
        this.tiles[tile.key] = tile;
        this.pyramid.addTile(tile);
    },

    hasTile: function hasTile(key) {
        return this.tiles[key] !== undefined;
    },

    forgetTile: function forgetTile(key) {
        if (this.hasTile(key)) {
            var tile = this.tiles[key];
            this.pyramid.removeTile(tile);
        }

        delete this.tiles[key];
        this.tileBuildStop(key);
    },

    // Remove a single tile
    removeTile: function removeTile(key) {
        _loglevel2['default'].trace('tile unload for ' + key);

        var tile = this.tiles[key];

        if (tile != null) {
            tile.destroy();
        }

        this.forgetTile(tile.key);
        this.scene.requestRedraw();
    },

    // Run a function on each tile
    forEachTile: function forEachTile(func) {
        for (var t in this.tiles) {
            func(this.tiles[t]);
        }
    },

    // Remove tiles that pass a filter condition
    removeTiles: function removeTiles(filter) {
        var remove_tiles = [];
        for (var t in this.tiles) {
            var tile = this.tiles[t];
            if (filter(tile)) {
                remove_tiles.push(t);
            }
        }
        for (var r = 0; r < remove_tiles.length; r++) {
            var key = remove_tiles[r];
            this.removeTile(key);
        }
    },

    updateTilesForView: function updateTilesForView() {
        // Find visible tiles and load new ones
        var prev_coords = _Object$keys(this.visible_coords);
        this.visible_coords = {};
        var tile_coords = this.view.findVisibleTileCoordinates();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = _getIterator(tile_coords), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var coords = _step.value;

                this.queueCoordinate(coords);
                this.visible_coords[coords.key] = coords;
            }

            // Check if visible coords changed
            // TODO: move to a new view manager object
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                    _iterator['return']();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        var new_coords = _Object$keys(this.visible_coords);
        var coords_changed = false;
        if (prev_coords.length !== new_coords.length) {
            coords_changed = true;
        } else {
            prev_coords.sort();
            new_coords.sort();
            if (!prev_coords.every(function (c, i) {
                return new_coords[i] === c;
            })) {
                coords_changed = true;
            }
        }

        this.updateTileStates();
    },

    updateTileStates: function updateTileStates() {
        var _this = this;

        this.forEachTile(function (tile) {
            _this.updateVisibility(tile);
            tile.update();
        });

        this.loadQueuedCoordinates();
        this.updateProxyTiles();
        this.view.pruneTilesForView();
    },

    updateProxyTiles: function updateProxyTiles() {
        var _this2 = this;

        if (this.view.zoom_direction === 0) {
            return;
        }

        // Clear previous proxies
        this.forEachTile(function (tile) {
            return tile.setProxyFor(null);
        });

        var proxy = false;
        this.forEachTile(function (tile) {
            if (_this2.view.zoom_direction === 1) {
                if (tile.visible && tile.loading && tile.coords.z > 0) {
                    var p = _this2.pyramid.getAncestor(tile);
                    if (p) {
                        p.setProxyFor(tile);
                        proxy = true;
                    }
                }
            } else if (_this2.view.zoom_direction === -1) {
                if (tile.visible && tile.loading) {
                    var d = _this2.pyramid.getDescendants(tile);
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = undefined;

                    try {
                        for (var _iterator2 = _getIterator(d), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            var t = _step2.value;

                            t.setProxyFor(tile);
                            proxy = true;
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                                _iterator2['return']();
                            }
                        } finally {
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }
                }
            }
        });

        if (!proxy) {
            this.view.zoom_direction = 0;
        }
    },

    updateVisibility: function updateVisibility(tile) {
        tile.visible = false;
        if (tile.style_zoom === this.view.tile_zoom) {
            if (this.visible_coords[tile.coords.key]) {
                tile.visible = true;
            } else {
                // brute force
                for (var key in this.visible_coords) {
                    if (_tile2['default'].isDescendant(tile.coords, this.visible_coords[key])) {
                        tile.visible = true;
                        break;
                    }
                }
            }
        }
    },

    // Remove tiles that aren't visible, and flag remaining visible ones to be updated (for loading, proxy, etc.)
    pruneToVisibleTiles: function pruneToVisibleTiles() {
        this.removeTiles(function (tile) {
            return !tile.visible;
        });
    },

    getRenderableTiles: function getRenderableTiles() {
        var tiles = [];
        for (var t in this.tiles) {
            var tile = this.tiles[t];
            if (tile.visible && tile.loaded) {
                tiles.push(tile);
            }
        }
        return tiles;
    },

    isLoadingVisibleTiles: function isLoadingVisibleTiles() {
        var _this3 = this;

        return _Object$keys(this.tiles).some(function (k) {
            return _this3.tiles[k].visible && _this3.tiles[k].loading;
        });
    },

    // Queue a tile for load
    queueCoordinate: function queueCoordinate(coords) {
        this.queued_coords[this.queued_coords.length] = coords;
    },

    // Load all queued tiles
    loadQueuedCoordinates: function loadQueuedCoordinates() {
        var _this4 = this;

        if (this.queued_coords.length === 0) {
            return;
        }

        // Sort queued tiles from center tile
        this.queued_coords.sort(function (a, b) {
            var ad = Math.abs(_this4.view.center.tile.x - a.x) + Math.abs(_this4.view.center.tile.y - a.y);
            var bd = Math.abs(_this4.view.center.tile.x - b.x) + Math.abs(_this4.view.center.tile.y - b.y);
            return bd > ad ? -1 : bd === ad ? 0 : 1;
        });
        this.queued_coords.forEach(function (coords) {
            return _this4.loadCoordinate(coords);
        });
        this.queued_coords = [];
    },

    // Load all tiles to cover a given logical tile coordinate
    loadCoordinate: function loadCoordinate(coords) {
        // Skip if not at current scene zoom
        if (coords.z !== this.view.center.tile.z) {
            return;
        }

        // Determine necessary tiles for each source
        for (var s in this.scene.sources) {
            var source = this.scene.sources[s];
            if (!source.tiled) {
                continue;
            }

            var key = _tile2['default'].key(coords, source, this.view.tile_zoom);
            if (key && !this.hasTile(key)) {
                var tile = _tile2['default'].create({
                    source: source,
                    coords: coords,
                    worker: this.scene.nextWorker(),
                    style_zoom: this.view.styleZoom(coords.z),
                    view: this.view
                });

                this.keepTile(tile);
                this.buildTile(tile);
            }
        }
    },

    // Sort and build a list of tiles
    buildTiles: function buildTiles(tiles) {
        var _this5 = this;

        _tile2['default'].sort(tiles).forEach(function (tile) {
            return _this5.buildTile(tile);
        });
        this.checkBuildQueue();
    },

    buildTile: function buildTile(tile) {
        var _this6 = this;

        this.tileBuildStart(tile.key);
        this.updateVisibility(tile);
        tile.update();
        tile.build(this.scene.generation).then(function (message) {
            if (message) {
                // empty message means tile build was aborted
                _this6.buildTileCompleted(message);
            }
        })['catch'](function (e) {
            _loglevel2['default'].error('Error building tile ' + tile.key + ':', e);
            _this6.forgetTile(tile.key);
            _tile2['default'].abortBuild(tile);
        });
    },

    // Called on main thread when a web worker completes processing for a single tile (initial load, or rebuild)
    buildTileCompleted: function buildTileCompleted(_ref2) {
        var tile = _ref2.tile;

        // Removed this tile during load?
        if (this.tiles[tile.key] == null) {
            _loglevel2['default'].trace('discarded tile ' + tile.key + ' in TileManager.buildTileCompleted because previously removed');
            _tile2['default'].abortBuild(tile);
            this.updateTileStates();
        }
        // Built with an outdated scene configuration?
        else if (tile.generation !== this.scene.generation) {
                _loglevel2['default'].debug('discarded tile ' + tile.key + ' in TileManager.buildTileCompleted because built with ' + ('scene config gen ' + tile.generation + ', current ' + this.scene.generation));
                this.forgetTile(tile.key);
                _tile2['default'].abortBuild(tile);
                this.updateTileStates();
            } else {
                // Update tile with properties from worker
                if (this.tiles[tile.key]) {
                    tile = this.tiles[tile.key].merge(tile);
                }

                tile.buildMeshes(this.scene.styles);
                this.updateTileStates();
                this.scene.requestRedraw();
            }

        this.tileBuildStop(tile.key);
    },

    // Track tile build state
    tileBuildStart: function tileBuildStart(key) {
        this.building_tiles = this.building_tiles || {};
        this.building_tiles[key] = true;
        _loglevel2['default'].trace('tileBuildStart for ' + key + ': ' + _Object$keys(this.building_tiles).length);
    },

    tileBuildStop: function tileBuildStop(key) {
        // Done building?
        if (this.building_tiles) {
            _loglevel2['default'].trace('tileBuildStop for ' + key + ': ' + _Object$keys(this.building_tiles).length);
            delete this.building_tiles[key];
            this.checkBuildQueue();
        }
    },

    // Check status of tile building queue and notify scene when we're done
    checkBuildQueue: function checkBuildQueue() {
        if (!this.building_tiles || _Object$keys(this.building_tiles).length === 0) {
            this.building_tiles = null;
            this.scene.tileManagerBuildDone();
        }
    },

    // Sum of a debug property across tiles
    getDebugSum: function getDebugSum(prop, filter) {
        var sum = 0;
        for (var t in this.tiles) {
            if (this.tiles[t].debug[prop] != null && (typeof filter !== 'function' || filter(this.tiles[t]) === true)) {
                sum += this.tiles[t].debug[prop];
            }
        }
        return sum;
    },

    // Average of a debug property across tiles
    getDebugAverage: function getDebugAverage(prop, filter) {
        return this.getDebugSum(prop, filter) / _Object$keys(this.tiles).length;
    }

};

exports['default'] = TileManager;
module.exports = exports['default'];

},{"./tile":239,"./tile_pyramid":241,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/keys":12,"babel-runtime/helpers/interop-require-default":23,"loglevel":183}],241:[function(_dereq_,module,exports){
'use strict';

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

var _Map = _dereq_('babel-runtime/core-js/map')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _geo = _dereq_('./geo');

var _geo2 = _interopRequireDefault(_geo);

var _tile = _dereq_('./tile');

var _tile2 = _interopRequireDefault(_tile);

var TilePyramid = {

    coords: {},
    max_proxy_descendant_depth: 3, // # of levels deep to search for descendant proxy tiles

    reset: function reset() {
        this.coords = {};
    },

    sourceTiles: function sourceTiles(coord, source) {
        return this.coords[coord.key] && this.coords[coord.key].sources && this.coords[coord.key].sources.get(source.name);
    },

    addTile: function addTile(tile) {
        // Add target tile
        var key = tile.coords.key;
        var coord = this.coords[key];
        if (!coord) {
            coord = this.coords[key] = { descendants: 0 };
        }

        if (!coord.sources) {
            coord.sources = new _Map();
        }

        if (!coord.sources.get(tile.source.name)) {
            coord.sources.set(tile.source.name, new _Map());
        }
        coord.sources.get(tile.source.name).set(tile.style_zoom, tile);

        // Increment reference count up the tile pyramid
        for (var z = tile.coords.z - 1; z >= 0; z--) {
            var up = _tile2['default'].coordinateAtZoom(tile.coords, z);
            if (!this.coords[up.key]) {
                this.coords[up.key] = { descendants: 0 };
            }
            this.coords[up.key].descendants++;
        }
    },

    removeTile: function removeTile(tile) {
        // Remove target tile
        var source_tiles = this.sourceTiles(tile.coords, tile.source);
        var key = tile.coords.key;

        if (source_tiles) {
            source_tiles['delete'](tile.style_zoom);
            if (source_tiles.size === 0) {
                // remove source
                this.coords[key].sources['delete'](tile.source.name);
                if (this.coords[key].sources.size === 0) {
                    delete this.coords[key].sources;

                    if (this.coords[key].descendants === 0) {
                        // remove whole coord
                        delete this.coords[key];
                    }
                }
            }
        }

        // Decrement reference count up the tile pyramid
        for (var z = tile.coords.z - 1; z >= 0; z--) {
            var down = _tile2['default'].coordinateAtZoom(tile.coords, z);
            if (this.coords[down.key] && this.coords[down.key].descendants > 0) {
                this.coords[down.key].descendants--;
                if (this.coords[down.key].descendants === 0 && !this.coords[down.key].sources) {
                    delete this.coords[down.key];
                }
            }
        }
    },

    getAncestor: function getAncestor(_ref) {
        var coords = _ref.coords;
        var style_zoom = _ref.style_zoom;
        var source = _ref.source;

        // First check overzoomed tiles at same coordinate zoom
        if (style_zoom > source.max_zoom) {
            var source_tiles = this.sourceTiles(coords, source);
            if (source_tiles) {
                for (var z = style_zoom - 1; z >= source.max_zoom; z--) {
                    if (source_tiles.has(z) && source_tiles.get(z).loaded) {
                        return source_tiles.get(z);
                    }
                }
            }
            style_zoom = source.max_zoom;
        }

        // Check tiles at next zoom up
        style_zoom--;
        var parent = _tile2['default'].coordinateAtZoom(coords, coords.z - 1);
        var parent_tiles = this.sourceTiles(parent, source);
        if (parent_tiles && parent_tiles.has(style_zoom) && parent_tiles.get(style_zoom).loaded) {
            return parent_tiles.get(style_zoom);
        }
        // didn't find ancestor, try next level
        // TODO: max depth levels to check
        if (parent.z > 0) {
            return this.getAncestor({ coords: parent, style_zoom: style_zoom, source: source });
        }
    },

    getDescendants: function getDescendants(_ref2) {
        var coords = _ref2.coords;
        var style_zoom = _ref2.style_zoom;
        var source = _ref2.source;
        var level = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

        var descendants = [];

        // First check overzoomed tiles at same coordinate zoom
        if (style_zoom >= source.max_zoom) {
            var source_tiles = this.sourceTiles(coords, source);
            if (source_tiles) {
                var search_max_zoom = Math.max(_geo2['default'].default_view_max_zoom, style_zoom + this.max_proxy_descendant_depth);
                for (var z = style_zoom + 1; z <= search_max_zoom; z++) {
                    if (source_tiles.has(z) && source_tiles.get(z).loaded) {
                        descendants.push(source_tiles.get(z));
                        return descendants;
                    }
                }
            }
            return descendants;
        }

        // Check tiles at next zoom down
        if (this.coords[coords.key] && this.coords[coords.key].descendants > 0) {
            style_zoom++;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = _getIterator(_tile2['default'].childrenForCoordinate(coords)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var child = _step.value;

                    var child_tiles = this.sourceTiles(child, source);
                    if (child_tiles && child_tiles.has(style_zoom) && child_tiles.get(style_zoom).loaded) {
                        descendants.push(child_tiles.get(style_zoom));
                    }
                    // didn't find child, try next level
                    else if (level <= this.max_proxy_descendant_depth && child.z <= source.max_zoom) {
                            descendants.push.apply(descendants, _toConsumableArray(this.getDescendants({ coords: child, source: source, style_zoom: style_zoom }, level + 1)));
                        }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator['return']) {
                        _iterator['return']();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }

        return descendants;
    }

};

exports['default'] = TilePyramid;
module.exports = exports['default'];

},{"./geo":197,"./tile":239,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/map":4,"babel-runtime/helpers/interop-require-default":23,"babel-runtime/helpers/to-consumable-array":25}],242:[function(_dereq_,module,exports){
'use strict';

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var MethodNotImplemented = (function (_Error) {
    _inherits(MethodNotImplemented, _Error);

    function MethodNotImplemented(methodName) {
        _classCallCheck(this, MethodNotImplemented);

        _get(Object.getPrototypeOf(MethodNotImplemented.prototype), 'constructor', this).call(this);
        this.name = 'MethodNotImplemented';
        this.message = 'Method ' + methodName + ' must be implemented in subclass';
    }

    return MethodNotImplemented;
})(Error);

exports.MethodNotImplemented = MethodNotImplemented;

},{"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/get":21,"babel-runtime/helpers/inherits":22}],243:[function(_dereq_,module,exports){
// Partial import of gl-matrix via modularized stack-gl forks
// https://github.com/toji/gl-matrix
// https://github.com/stackgl

// vec3

// Substitute 64-bit version
// We need the extra precision when multiplying matrices w/mercator projected values
'use strict';

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

// mat3

var _glMat3NormalFromMat4 = _dereq_('gl-mat3/normal-from-mat4');

var _glMat3NormalFromMat42 = _interopRequireDefault(_glMat3NormalFromMat4);

var _glMat3Invert = _dereq_('gl-mat3/invert');

var _glMat3Invert2 = _interopRequireDefault(_glMat3Invert);

// mat4

var _glMat4Multiply = _dereq_('gl-mat4/multiply');

var _glMat4Multiply2 = _interopRequireDefault(_glMat4Multiply);

var _glMat4Translate = _dereq_('gl-mat4/translate');

var _glMat4Translate2 = _interopRequireDefault(_glMat4Translate);

var _glMat4Scale = _dereq_('gl-mat4/scale');

var _glMat4Scale2 = _interopRequireDefault(_glMat4Scale);

var _glMat4Perspective = _dereq_('gl-mat4/perspective');

var _glMat4Perspective2 = _interopRequireDefault(_glMat4Perspective);

var _glMat4LookAt = _dereq_('gl-mat4/lookAt');

var _glMat4LookAt2 = _interopRequireDefault(_glMat4LookAt);

var _glMat4Identity = _dereq_('gl-mat4/identity');

var _glMat4Identity2 = _interopRequireDefault(_glMat4Identity);

var _glMat4Copy = _dereq_('gl-mat4/copy');

var _glMat4Copy2 = _interopRequireDefault(_glMat4Copy);

var vec3 = {
    fromValues: function fromValues(x, y, z) {
        var out = new Float64Array(3);
        out[0] = x;
        out[1] = y;
        out[2] = z;
        return out;
    }
};

var mat3 = {
    normalFromMat4: _glMat3NormalFromMat42['default'],
    invert: _glMat3Invert2['default']
};

var mat4 = {
    multiply: _glMat4Multiply2['default'],
    translate: _glMat4Translate2['default'],
    scale: _glMat4Scale2['default'],
    perspective: _glMat4Perspective2['default'],
    lookAt: _glMat4LookAt2['default'],
    identity: _glMat4Identity2['default'],
    copy: _glMat4Copy2['default']
};

exports.vec3 = vec3;
exports.mat3 = mat3;
exports.mat4 = mat4;

},{"babel-runtime/helpers/interop-require-default":23,"gl-mat3/invert":142,"gl-mat3/normal-from-mat4":143,"gl-mat4/copy":144,"gl-mat4/identity":145,"gl-mat4/lookAt":146,"gl-mat4/multiply":147,"gl-mat4/perspective":148,"gl-mat4/scale":149,"gl-mat4/translate":150}],244:[function(_dereq_,module,exports){
// Deep/recursive merge of one or more source objects into a destination object
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports['default'] = mergeObjects;

function mergeObjects(dest) {
    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        sources[_key - 1] = arguments[_key];
    }

    for (var s = 0; s < sources.length; s++) {
        var source = sources[s];
        if (!source) {
            continue;
        }
        for (var key in source) {
            var value = source[key];
            // Recursively merge the source into the destination if it is a a non-null key/value object
            // (e.g. don't merge arrays, those are treated as scalar values; null values will overwrite/erase
            // the previous destination value)
            if (value !== null && typeof value === 'object' && !Array.isArray(value)) {
                dest[key] = mergeObjects(dest[key] || {}, value);
            }
            // Overwrite the previous destination value if the source property is: a scalar (number/string),
            // an array, or a null value
            else if (value !== undefined) {
                    dest[key] = value;
                }
            // Undefined source properties are ignored
        }
    }
    return dest;
}

module.exports = exports['default'];

},{}],245:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _vector = _dereq_('../vector');

var _vector2 = _interopRequireDefault(_vector);

var OBB = (function () {
    function OBB(x, y, a, w, h) {
        _classCallCheck(this, OBB);

        this.dimension = [w, h];
        this.angle = a;
        this.centroid = [x, y];
        this.quad = [];
        this.axes = [];

        this.update();
    }

    _createClass(OBB, [{
        key: 'move',
        value: function move(px, py) {
            this.centroid = [px, py];

            this.update();
        }
    }, {
        key: 'getExtent',
        value: function getExtent() {
            var inf = 1e6;
            var aabb = [inf, inf, -inf, -inf];

            for (var i = 0; i < 4; ++i) {
                aabb[0] = Math.min(this.quad[i][0], aabb[0]);
                aabb[1] = Math.min(this.quad[i][1], aabb[1]);
                aabb[2] = Math.max(this.quad[i][0], aabb[2]);
                aabb[3] = Math.max(this.quad[i][1], aabb[3]);
            }

            return aabb;
        }
    }, {
        key: 'perpAxes',
        value: function perpAxes() {
            this.axes[0] = _vector2['default'].normalize(_vector2['default'].sub(this.quad[2], this.quad[3]));
            this.axes[1] = _vector2['default'].normalize(_vector2['default'].sub(this.quad[2], this.quad[1]));
        }
    }, {
        key: 'update',
        value: function update() {
            var x = [Math.cos(this.angle), Math.sin(this.angle)];
            var y = [-Math.sin(this.angle), Math.cos(this.angle)];

            x = _vector2['default'].mult(x, this.dimension[0] / 2.0);
            y = _vector2['default'].mult(y, this.dimension[1] / 2.0);

            this.quad[0] = _vector2['default'].sub(_vector2['default'].sub(this.centroid, x), y); // lower-left
            this.quad[1] = _vector2['default'].sub(_vector2['default'].add(this.centroid, x), y); // lower-right
            this.quad[2] = _vector2['default'].add(_vector2['default'].add(this.centroid, x), y); // uper-right
            this.quad[3] = _vector2['default'].add(_vector2['default'].sub(this.centroid, x), y); // uper-left

            this.perpAxes();
        }
    }], [{
        key: 'projectToAxis',
        value: function projectToAxis(obb, axis) {
            var inf = 1e6;
            var min = inf;
            var max = -inf;

            var quad = obb.quad;

            // for each axis, project obb quad to it and find min and max values
            for (var i = 0; i < 4; ++i) {
                var d = _vector2['default'].dot(quad[i], axis);
                min = Math.min(min, d);
                max = Math.max(max, d);
            }

            return [min, max];
        }
    }, {
        key: 'axisCollide',
        value: function axisCollide(obb_a, obb_b, axes) {
            for (var i = 0; i < 2; ++i) {
                var a_proj = OBB.projectToAxis(obb_a, axes[i]);
                var b_proj = OBB.projectToAxis(obb_b, axes[i]);

                if (b_proj[0] > a_proj[1] || b_proj[1] < a_proj[0]) {
                    return false;
                }
            }
            return true;
        }
    }, {
        key: 'intersect',
        value: function intersect(obb_a, obb_b) {
            return OBB.axisCollide(obb_a, obb_b, obb_a.axes) && OBB.axisCollide(obb_a, obb_b, obb_b.axes);
        }
    }]);

    return OBB;
})();

exports['default'] = OBB;
module.exports = exports['default'];

},{"../vector":250,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/interop-require-default":23}],246:[function(_dereq_,module,exports){
'use strict';

var _Set = _dereq_('babel-runtime/core-js/set')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports['default'] = subscribeMixin;

function subscribeMixin(target) {

    var listeners = new _Set();
    // var listeners = [];

    return _Object$assign(target, {

        subscribe: function subscribe(listener) {
            listeners.add(listener);
            // listeners.push(listener);
        },

        unsubscribe: function unsubscribe(listener) {
            listeners['delete'](listener);
            // var index = listeners.indexOf(listener);
            // if (index > -1) {
            //     listeners.splice(index, 1);
            // }
        },

        unsubscribeAll: function unsubscribeAll() {
            listeners.clear();
            // listeners = [];
        },

        trigger: function trigger(event) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    data[_key - 1] = arguments[_key];
                }

                for (var _iterator = _getIterator(listeners), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var listener = _step.value;

                    if (typeof listener[event] === 'function') {
                        listener[event].apply(listener, data);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator['return']) {
                        _iterator['return']();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }

    });
}

module.exports = exports['default'];

},{"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/set":15}],247:[function(_dereq_,module,exports){
// Miscellaneous utilities
/*jshint worker: true*/

'use strict';

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _Math$log2 = _dereq_('babel-runtime/core-js/math/log2')['default'];

var _regeneratorRuntime = _dereq_('babel-runtime/regenerator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var _jsYaml = _dereq_('js-yaml');

var _jsYaml2 = _interopRequireDefault(_jsYaml);

var _geo = _dereq_('../geo');

var _geo2 = _interopRequireDefault(_geo);

var Utils;
exports['default'] = Utils = {};

// Add a base URL for schemeless or protocol-less URLs
// Defaults to adding current window protocol and base, or adds a custom base if specified
// Maybe use https://github.com/medialize/URI.js if more robust functionality is needed
Utils.addBaseURL = function (url, base) {
    if (!url) {
        return;
    }

    // Schemeless, add protocol
    if (url.substr(0, 2) === '//') {
        url = window.location.protocol + url;
    }
    // No http(s) or data, add base
    else if (url.search(/^(http|https|data|blob):/) < 0) {
            var relative = url[0] !== '/';
            var base_info;
            if (base) {
                base_info = document.createElement('a'); // use a temporary element to parse URL
                base_info.href = base;
            } else {
                base_info = window.location;
            }

            if (relative) {
                var path = base_info.href.match(/([^\#]+)/); // strip hash
                path = path && path.length > 1 ? path[0] : '';
                url = path + url;
            } else {
                // Easy way
                if (base_info.origin) {
                    url = base_info.origin + '/' + url;
                }
                // Hard way (IE11)
                else {
                        var origin = url.match(/^((http|https|data|blob):\/\/[^\/]*\/)/);
                        origin = origin && origin.length > 1 ? origin[0] : '';
                        url = origin + url;
                    }
            }
        }
    return url;
};

Utils.pathForURL = function (url) {
    if (url && url.search(/^(data|blob):/) === -1) {
        return url.substr(0, url.lastIndexOf('/') + 1) || './';
    }
    return './';
};

Utils.cacheBusterForUrl = function (url) {
    if (url.search(/^(data|blob):/) > -1) {
        return url; // no cache-busting on object or data URLs
    }
    if (url.indexOf('?') > -1) {
        url += '&' + +new Date();
    } else {
        url += '?' + +new Date();
    }
    return url;
};

// Add a set of query string params to a URL
// params: hash of key/value pairs of query string parameters
Utils.addParamsToURL = function (url, params) {
    if (!params || _Object$keys(params).length === 0) {
        return url;
    }

    var qs_index = url.indexOf('?');
    var hash_index = url.indexOf('#');

    // Save and trim hash
    var hash = '';
    if (hash_index > -1) {
        hash = url.slice(hash_index);
        url = url.slice(0, hash_index);
    }

    // Start query string
    if (qs_index === -1) {
        qs_index = url.length;
        url += '?';
    }
    qs_index++; // advanced past '?'

    // Build query string params
    var url_params = '';
    for (var p in params) {
        url_params += p + '=' + params[p] + '&';
    }

    // Insert new query string params and restore hash
    // NOTE: doesn't replace any values already present on query string, just inserts dupe values
    url = url.slice(0, qs_index) + url_params + url.slice(qs_index) + hash;

    return url;
};

// Polyfill (for Safari compatibility)
Utils._createObjectURL = undefined;
Utils.createObjectURL = function (url) {
    if (Utils._createObjectURL === undefined) {
        Utils._createObjectURL = window.URL && window.URL.createObjectURL || window.webkitURL && window.webkitURL.createObjectURL;

        if (typeof Utils._createObjectURL !== 'function') {
            Utils._createObjectURL = null;
            _loglevel2['default'].warn('window.URL.createObjectURL (or vendor prefix) not found, unable to create local blob URLs');
        }
    }

    if (Utils._createObjectURL) {
        return Utils._createObjectURL(url);
    } else {
        return url;
    }
};

Utils.io = function (url) {
    var timeout = arguments.length <= 1 || arguments[1] === undefined ? 60000 : arguments[1];
    var responseType = arguments.length <= 2 || arguments[2] === undefined ? 'text' : arguments[2];
    var method = arguments.length <= 3 || arguments[3] === undefined ? 'GET' : arguments[3];
    var headers = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];

    var request = new XMLHttpRequest();
    var promise = new _Promise(function (resolve, reject) {
        request.open(method, url, true);
        request.timeout = timeout;
        request.responseType = responseType;
        request.onload = function () {
            if (request.status === 200) {
                if (['text', 'json'].indexOf(request.responseType) > -1) {
                    resolve(request.responseText);
                } else {
                    resolve(request.response);
                }
            } else {
                reject(Error('Request error with a status of ' + request.statusText));
            }
        };
        request.onerror = function (evt) {
            reject(Error('There was a network error' + evt.toString()));
        };
        request.ontimeout = function (evt) {
            reject(Error('timeout ' + evt.toString()));
        };
        request.send();
    });

    Object.defineProperty(promise, 'request', {
        value: request
    });

    return promise;
};

Utils.parseResource = function (body) {
    var data;
    try {
        // jsyaml 'json' option allows duplicate keys
        // Keeping this for backwards compatibility, but should consider migrating to requiring
        // unique keys, as this is YAML spec. But Tangram ES currently accepts dupe keys as well,
        // so should consider how best to unify.
        data = _jsYaml2['default'].safeLoad(body, { json: true });
    } catch (e) {
        throw e;
    }
    return data;
};

Utils.loadResource = function (source) {
    return new _Promise(function (resolve, reject) {
        if (typeof source === 'string') {
            Utils.io(Utils.cacheBusterForUrl(source)).then(function (body) {
                try {
                    var data = Utils.parseResource(body);
                    resolve(data);
                } catch (e) {
                    reject(e);
                }
            }, reject);
        } else {
            resolve(source);
        }
    });
};

// Needed for older browsers that still support WebGL (Safari 6 etc.)
Utils.requestAnimationFramePolyfill = function () {
    if (typeof window.requestAnimationFrame !== 'function') {
        window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (cb) {
            setTimeout(cb, 1000 / 60);
        };
    }
};

// Stringify an object into JSON, but convert functions to strings
Utils.serializeWithFunctions = function (obj) {
    var serialized = JSON.stringify(obj, function (k, v) {
        // Convert functions to strings
        if (typeof v === 'function') {
            return v.toString();
        }
        return v;
    });

    return serialized;
};

// Parse a JSON string, but convert function-like strings back into functions
Utils.deserializeWithFunctions = function (serialized, wrap) {
    var obj = JSON.parse(serialized);
    obj = Utils.stringsToFunctions(obj, wrap);
    return obj;
};

// Recursively parse an object, attempting to convert string properties that look like functions back into functions
Utils.stringsToFunctions = function (obj, wrap) {
    // Convert string
    if (typeof obj === 'string') {
        obj = Utils.stringToFunction(obj, wrap);
    }
    // Loop through object properties
    else if (typeof obj === 'object') {
            for (var p in obj) {
                obj[p] = Utils.stringsToFunctions(obj[p], wrap);
            }
        }
    return obj;
};

// Convert string back into a function
// TODO: make function matching tolerant of whitespace and multilines
Utils.stringToFunction = function (val, wrap) {
    // Convert strings back into functions
    if (val.match(/^\s*function\s*\w*\s*\([\s\S]*\)\s*\{[\s\S]*\}/m) != null) {
        var f;
        try {
            if (typeof wrap === 'function') {
                eval('f = ' + wrap(val)); // jshint ignore:line
            } else {
                    eval('f = ' + val); // jshint ignore:line
                }
            return f;
        } catch (e) {
            // fall-back to original value if parsing failed
            return val;
        }
    }
    return val;
};

// Log wrapper, sends message to main thread for display, and includes worker id #
Utils.log = function (level) {
    for (var _len = arguments.length, msg = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        msg[_key - 1] = arguments[_key];
    }

    level = level || 'info';
    if (Utils.isWorkerThread) {
        self.postMessage(JSON.stringify({
            type: 'log',
            level: level,
            worker_id: self._worker_id,
            msg: msg
        }));
    } else if (typeof _loglevel2['default'][level] === 'function') {
        _loglevel2['default'][level].apply(_loglevel2['default'], msg);
    }
};

// Default to allowing high pixel density
// Returns true if display density changed
Utils.use_high_density_display = true;
Utils.updateDevicePixelRatio = function () {
    var prev = Utils.device_pixel_ratio;
    Utils.device_pixel_ratio = Utils.use_high_density_display && window.devicePixelRatio || 1;
    return Utils.device_pixel_ratio !== prev;
};

// Mark thread as main or worker
(function () {
    try {
        if (window.document !== undefined) {
            Utils.isWorkerThread = false;
            Utils.isMainThread = true;
            Utils.updateDevicePixelRatio();
        }
    } catch (e) {
        if (self !== undefined) {
            Utils.isWorkerThread = true;
            Utils.isMainThread = false;
        }
    }
})();

// Get URL that the current script was loaded from
// If currentScript is not available, loops through <script> elements searching for a list of provided paths
// e.g. Utils.findCurrentURL('tangram.debug.js', 'tangram.min.js');
Utils.findCurrentURL = function () {
    // Find currently executing script
    var script = document.currentScript;

    for (var _len2 = arguments.length, paths = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        paths[_key2] = arguments[_key2];
    }

    if (script) {
        return script.src;
    } else if (Array.isArray(paths)) {
        // Fallback on looping through <script> elements if document.currentScript is not supported
        var scripts = document.getElementsByTagName('script');
        for (var s = 0; s < scripts.length; s++) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = _getIterator(paths), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var path = _step.value;

                    if (scripts[s].src.indexOf(path) > -1) {
                        return scripts[s].src;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator['return']) {
                        _iterator['return']();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }
};

// Used for differentiating between power-of-2 and non-power-of-2 textures
// Via: http://stackoverflow.com/questions/19722247/webgl-wait-for-texture-to-load
Utils.isPowerOf2 = function (value) {
    return (value & value - 1) === 0;
};

Utils.nextPowerOf2 = function (value) {
    return Math.pow(2, Math.ceil(_Math$log2(value)));
};

// Interpolate 'x' along a series of control points
// 'points' is an array of control points in the form [x, y]
//
// Example:
//     Control points:
//         [0, 5]:  when x=0, y=5
//         [4, 10]: when x=4, y=10
//
//     Utils.interpolate(2, [[0, 5], [4, 10]]);
//     -> computes x=2, halfway between x=0 and x=4: (10 - 5) / 2 +5
//     -> returns 7.5
//
// TODO: add other interpolation methods besides linear
//
Utils.interpolate = function (x, points, transform) {
    // If this doesn't resemble a list of control points, just return the original value
    if (!Array.isArray(points) || !Array.isArray(points[0])) {
        return points;
    } else if (points.length < 1) {
        return points;
    }

    var x1, x2, d, y, y1, y2;

    // Min bounds
    if (x <= points[0][0]) {
        y = points[0][1];
        if (typeof transform === 'function') {
            y = transform(y);
        }
    }
    // Max bounds
    else if (x >= points[points.length - 1][0]) {
            y = points[points.length - 1][1];
            if (typeof transform === 'function') {
                y = transform(y);
            }
        }
        // Find which control points x is between
        else {
                for (var i = 0; i < points.length - 1; i++) {
                    if (x >= points[i][0] && x < points[i + 1][0]) {
                        // Linear interpolation
                        x1 = points[i][0];
                        x2 = points[i + 1][0];

                        // Multiple values
                        if (Array.isArray(points[i][1])) {
                            y = [];
                            for (var c = 0; c < points[i][1].length; c++) {
                                if (typeof transform === 'function') {
                                    y1 = transform(points[i][1][c]);
                                    y2 = transform(points[i + 1][1][c]);
                                    d = y2 - y1;
                                    y[c] = d * (x - x1) / (x2 - x1) + y1;
                                } else {
                                    d = points[i + 1][1][c] - points[i][1][c];
                                    y[c] = d * (x - x1) / (x2 - x1) + points[i][1][c];
                                }
                            }
                        }
                        // Single value
                        else {
                                if (typeof transform === 'function') {
                                    y1 = transform(points[i][1]);
                                    y2 = transform(points[i + 1][1]);
                                    d = y2 - y1;
                                    y = d * (x - x1) / (x2 - x1) + y1;
                                } else {
                                    d = points[i + 1][1] - points[i][1];
                                    y = d * (x - x1) / (x2 - x1) + points[i][1];
                                }
                            }
                        break;
                    }
                }
            }
    return y;
};

// Iterators (ES6 generators)

// Iterator for key/value pairs of an object
Utils.entries = _regeneratorRuntime.mark(function callee$0$0(obj) {
    var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, key;

    return _regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                context$1$0.prev = 3;
                _iterator2 = _getIterator(_Object$keys(obj));

            case 5:
                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                    context$1$0.next = 12;
                    break;
                }

                key = _step2.value;
                context$1$0.next = 9;
                return [key, obj[key]];

            case 9:
                _iteratorNormalCompletion2 = true;
                context$1$0.next = 5;
                break;

            case 12:
                context$1$0.next = 18;
                break;

            case 14:
                context$1$0.prev = 14;
                context$1$0.t0 = context$1$0['catch'](3);
                _didIteratorError2 = true;
                _iteratorError2 = context$1$0.t0;

            case 18:
                context$1$0.prev = 18;
                context$1$0.prev = 19;

                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                    _iterator2['return']();
                }

            case 21:
                context$1$0.prev = 21;

                if (!_didIteratorError2) {
                    context$1$0.next = 24;
                    break;
                }

                throw _iteratorError2;

            case 24:
                return context$1$0.finish(21);

            case 25:
                return context$1$0.finish(18);

            case 26:
            case 'end':
                return context$1$0.stop();
        }
    }, callee$0$0, this, [[3, 14, 18, 26], [19,, 21, 25]]);
});

// Iterator for values of an object
Utils.values = _regeneratorRuntime.mark(function callee$0$0(obj) {
    var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, key;

    return _regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                _iteratorNormalCompletion3 = true;
                _didIteratorError3 = false;
                _iteratorError3 = undefined;
                context$1$0.prev = 3;
                _iterator3 = _getIterator(_Object$keys(obj));

            case 5:
                if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                    context$1$0.next = 12;
                    break;
                }

                key = _step3.value;
                context$1$0.next = 9;
                return obj[key];

            case 9:
                _iteratorNormalCompletion3 = true;
                context$1$0.next = 5;
                break;

            case 12:
                context$1$0.next = 18;
                break;

            case 14:
                context$1$0.prev = 14;
                context$1$0.t0 = context$1$0['catch'](3);
                _didIteratorError3 = true;
                _iteratorError3 = context$1$0.t0;

            case 18:
                context$1$0.prev = 18;
                context$1$0.prev = 19;

                if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                    _iterator3['return']();
                }

            case 21:
                context$1$0.prev = 21;

                if (!_didIteratorError3) {
                    context$1$0.next = 24;
                    break;
                }

                throw _iteratorError3;

            case 24:
                return context$1$0.finish(21);

            case 25:
                return context$1$0.finish(18);

            case 26:
            case 'end':
                return context$1$0.stop();
        }
    }, callee$0$0, this, [[3, 14, 18, 26], [19,, 21, 25]]);
});

// Recursive iterators for all properties of an object, no matter how deeply nested
// TODO: fix for circular structures
Utils.recurseEntries = _regeneratorRuntime.mark(function callee$0$0(obj) {
    var _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, key;

    return _regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                if (obj) {
                    context$1$0.next = 2;
                    break;
                }

                return context$1$0.abrupt('return');

            case 2:
                _iteratorNormalCompletion4 = true;
                _didIteratorError4 = false;
                _iteratorError4 = undefined;
                context$1$0.prev = 5;
                _iterator4 = _getIterator(_Object$keys(obj));

            case 7:
                if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
                    context$1$0.next = 17;
                    break;
                }

                key = _step4.value;

                if (!obj[key]) {
                    context$1$0.next = 14;
                    break;
                }

                context$1$0.next = 12;
                return [key, obj[key], obj];

            case 12:
                if (!(typeof obj[key] === 'object')) {
                    context$1$0.next = 14;
                    break;
                }

                return context$1$0.delegateYield(Utils.recurseEntries(obj[key]), 't0', 14);

            case 14:
                _iteratorNormalCompletion4 = true;
                context$1$0.next = 7;
                break;

            case 17:
                context$1$0.next = 23;
                break;

            case 19:
                context$1$0.prev = 19;
                context$1$0.t1 = context$1$0['catch'](5);
                _didIteratorError4 = true;
                _iteratorError4 = context$1$0.t1;

            case 23:
                context$1$0.prev = 23;
                context$1$0.prev = 24;

                if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                    _iterator4['return']();
                }

            case 26:
                context$1$0.prev = 26;

                if (!_didIteratorError4) {
                    context$1$0.next = 29;
                    break;
                }

                throw _iteratorError4;

            case 29:
                return context$1$0.finish(26);

            case 30:
                return context$1$0.finish(23);

            case 31:
            case 'end':
                return context$1$0.stop();
        }
    }, callee$0$0, this, [[5, 19, 23, 31], [24,, 26, 30]]);
});

Utils.recurseValues = _regeneratorRuntime.mark(function callee$0$0(obj) {
    var _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, key;

    return _regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                if (obj) {
                    context$1$0.next = 2;
                    break;
                }

                return context$1$0.abrupt('return');

            case 2:
                _iteratorNormalCompletion5 = true;
                _didIteratorError5 = false;
                _iteratorError5 = undefined;
                context$1$0.prev = 5;
                _iterator5 = _getIterator(_Object$keys(obj));

            case 7:
                if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
                    context$1$0.next = 17;
                    break;
                }

                key = _step5.value;

                if (!obj[key]) {
                    context$1$0.next = 14;
                    break;
                }

                context$1$0.next = 12;
                return obj[key];

            case 12:
                if (!(typeof obj[key] === 'object')) {
                    context$1$0.next = 14;
                    break;
                }

                return context$1$0.delegateYield(Utils.recurseValues(obj[key]), 't0', 14);

            case 14:
                _iteratorNormalCompletion5 = true;
                context$1$0.next = 7;
                break;

            case 17:
                context$1$0.next = 23;
                break;

            case 19:
                context$1$0.prev = 19;
                context$1$0.t1 = context$1$0['catch'](5);
                _didIteratorError5 = true;
                _iteratorError5 = context$1$0.t1;

            case 23:
                context$1$0.prev = 23;
                context$1$0.prev = 24;

                if (!_iteratorNormalCompletion5 && _iterator5['return']) {
                    _iterator5['return']();
                }

            case 26:
                context$1$0.prev = 26;

                if (!_didIteratorError5) {
                    context$1$0.next = 29;
                    break;
                }

                throw _iteratorError5;

            case 29:
                return context$1$0.finish(26);

            case 30:
                return context$1$0.finish(23);

            case 31:
            case 'end':
                return context$1$0.stop();
        }
    }, callee$0$0, this, [[5, 19, 23, 31], [24,, 26, 30]]);
});

// Scale a *signed* short for use in a GL VBO
// `unit` is an optional scaling factor to mimic fixed point, since these values will be
// normalized to 0-1, e.g. divide input by unit on the way in, multiply it back in the shader
Utils.scaleInt16 = function (val, unit) {
    return val / unit * 32767;
};

Utils.degToRad = function (degrees) {
    return degrees * Math.PI / 180;
};

Utils.radToDeg = function (radians) {
    return radians * 180 / Math.PI;
};

Utils.toCSSColor = function (color) {
    if (color[3] === 1) {
        // full opacity
        return 'rgb(' + color.slice(0, 3).map(function (c) {
            return Math.round(c * 255);
        }).join(', ') + ')';
    }
    // RGB is between [0, 255] opacity is between [0, 1]
    return 'rgba(' + color.map(function (c, i) {
        return i < 3 && Math.round(c * 255) || c;
    }).join(', ') + ')';
};

Utils.pointInTile = function (point) {
    return point[0] >= 0 && point[1] > -_geo2['default'].tile_scale && point[0] < _geo2['default'].tile_scale && point[1] <= 0;
};

// http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery
Utils.hashString = function (str) {
    if (str.length === 0) {
        return 0;
    }
    var hash = 0;

    for (var i = 0, len = str.length; i < len; i++) {
        var chr = str.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash |= 0;
    }
    return hash;
};

Utils.debounce = function (func, wait, immediate) {
    var timeout = undefined;
    return function () {
        var context = this,
            args = arguments;
        var later = function later() {
            timeout = null;
            if (!immediate) {
                func.apply(context, args);
            }
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) {
            func.apply(context, args);
        }
    };
};
module.exports = exports['default'];

},{"../geo":197,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/math/log2":5,"babel-runtime/core-js/object/keys":12,"babel-runtime/core-js/promise":14,"babel-runtime/helpers/interop-require-default":23,"babel-runtime/regenerator":26,"js-yaml":154,"loglevel":183}],248:[function(_dereq_,module,exports){
"use strict";

var _Object$defineProperties = _dereq_("babel-runtime/core-js/object/define-properties")["default"];

Object.defineProperty(exports, "__esModule", {
    value: true
});
var version;
exports["default"] = version = _Object$defineProperties({
    major: 0,
    minor: 6,
    patch: 1,
    pre: false
}, {
    string: {
        get: function get() {
            return "v" + version.major + "." + version.minor + "." + version.patch;
        },
        configurable: true,
        enumerable: true
    }
});
module.exports = exports["default"];

},{"babel-runtime/core-js/object/define-properties":8}],249:[function(_dereq_,module,exports){
/*jshint worker: true*/

// WorkerBroker routes messages between web workers and the main thread, allowing for simpler
// async code via promises. Example usage:
//
// In web worker, register self as target define a method:
//
//     WorkerBroker.addTarget('self', self);
//
//     self.square = function (x) {
//         return x * x;
//     };
//
// In main thread, invoke that method and receive the result (if any) as a promise:
//
//     worker = new Worker(...);
//     WorkerBroker.addWorker(worker);
//
//     WorkerBroker.postMessage(worker, 'self.square', 5).then(function(y) {
//         console.log(y);
//     });
//
//     -> prints 25
//
// Async code:
//
// For synchronous code that must pass a return value to the main thread, the function can simply
// return an immediate value (see example above). For cases where the worker method needs to run
// asynchronous code, the function can return a promise, and the resolved or rejected value will
// be sent back to the main thread when the promise is fulfilled.
//
// Error handling:
//
// If the worker method either throws an error, or returns a promise that is rejected, it will be
// sent back to the main thread as a promise rejection. These two examples are equivalent:
//
//     In worker, throwing an error:
//
//         self.broken = function () {
//             throw new Error('error in worker!');
//         };
//
//     In worker, returning a rejected promise:
//
//         self.broken = function () {
//             return Promise.reject(new Error('error in worker!'));
//         };
//
//     In main thread, both errors are received as a promise rejection:
//
//         WorkerBroker.postMessage(worker, 'self.broken').then(
//             // Promise resolved
//             function() {
//                 console.log('success!');
//             },
//             // Promise rejected
//             function(error) {
//                 console.log('error!', error);
//             });
//
//         -> prints 'error! error in worker'
//
// Calling from worker to main thread:
//
// The same style of calls can be made *from* a web worker, to the main thread. The API is the same
// with the exception that the first argument, 'worker', is not needed for WorkerBroker.postMessage(),
// since the main thread is the implicit target.
//
// In main thread, define a method and register it:
//
//     var geometry = {
//         length: function(x, y) {
//             return Math.sqrt(x * x + y * y);
//         }
//     };
//
//     WorkerBroker.addTarget('geometry', geometry);
//
// In worker thread:
//
//     WorkerBroker.postMessage('geometry.length', 3, 4).then(function(d) {
//         console.log(d);
//     });
//
//     -> prints 5
//

'use strict';

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _Map = _dereq_('babel-runtime/core-js/map')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utils = _dereq_('./utils');

var _utils2 = _interopRequireDefault(_utils);

var WorkerBroker;
exports['default'] = WorkerBroker = {};

// Global list of all worker messages
// Uniquely tracks every call made between main thread and a worker
var message_id = 0;
var messages = {};

// Register an object to receive calls from other thread
var targets = {};
WorkerBroker.addTarget = function (name, target) {
    targets[name] = target;
};

// Given a dot-notation-style method name, e.g. 'Object.object.method',
// find the object to call the method on from the list of registered targets
function findTarget(method) {
    var chain = [];
    if (typeof method === 'string') {
        chain = method.split('.');
        method = chain.pop();
    }

    // target = target || (Utils.isMainThread && window) || (Utils.isWorkerThread && self);
    var target = targets;

    for (var m = 0; m < chain.length; m++) {
        if (target[chain[m]]) {
            target = target[chain[m]];
        } else {
            return [];
        }
    }

    return [method, target];
}

// Main thread:
// - Send messages to workers, and optionally receive an async response as a promise
// - Receive messages from workers, and optionally send an async response back as a promise
function setupMainThread() {

    // Send a message to a worker, and optionally get an async response
    // Arguments:
    //   - worker: one or more web worker instances to send the message to (single value or array)
    //   - method: the method with this name, specified with dot-notation, will be invoked in the worker
    //   - message: will be passed to the method call
    // Returns:
    //   - a promise that will be fulfilled if the worker method returns a value (could be immediately, or async)
    //
    WorkerBroker.postMessage = function (worker, method) {
        for (var _len = arguments.length, message = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            message[_key - 2] = arguments[_key];
        }

        // If more than one worker specified, post to multiple
        if (Array.isArray(worker)) {
            return _Promise.all(worker.map(function (w) {
                var _WorkerBroker;

                return (_WorkerBroker = WorkerBroker).postMessage.apply(_WorkerBroker, [w, method].concat(message));
            }));
        }

        // Track state of this message
        var promise = new _Promise(function (resolve, reject) {
            messages[message_id] = { method: method, message: message, resolve: resolve, reject: reject };
        });

        worker.postMessage(JSON.stringify({
            type: 'main_send', // mark message as method invocation from main thread
            message_id: message_id, // unique id for this message, for life of program
            method: method, // will dispatch to a function of this name within the worker
            message: message // message payload
        }));

        message_id++;
        return promise;
    };

    // Add a worker to communicate with - each worker must be registered from the main thread
    var worker_id = 0;
    var workers = new _Map();

    WorkerBroker.addWorker = function (worker) {

        // Keep track of all registered workers
        workers.set(worker, worker_id++);

        // Listen for messages coming back from the worker, and fulfill that message's promise
        worker.addEventListener('message', function (event) {
            var data = maybeDecode(event.data);
            if (data.type !== 'worker_reply') {
                return;
            }

            // Pass the result to the promise
            var id = data.message_id;
            if (messages[id]) {
                if (data.error) {
                    messages[id].reject(data.error);
                } else {
                    messages[id].resolve(data.message);
                }
                delete messages[id];
            }
        });

        // Listen for messages initiating a call from the worker, dispatch them,
        // and send any return value back to the worker
        worker.addEventListener('message', function (event) {
            var data = maybeDecode(event.data);

            // Unique id for this message & return call to main thread
            var id = data.message_id;
            if (data.type !== 'worker_send' || id == null) {
                return;
            }

            // Call the requested method and save the return value
            // var target = targets[data.target];

            var _findTarget = findTarget(data.method);

            var _findTarget2 = _slicedToArray(_findTarget, 2);

            var method_name = _findTarget2[0];
            var target = _findTarget2[1];

            if (!target) {
                throw Error('Worker broker could not dispatch message type ' + data.method + ' on target ' + data.target + ' because no object with that name is registered on main thread');
            }

            var method = typeof target[method_name] === 'function' && target[method_name];
            if (!method) {
                throw Error('Worker broker could not dispatch message type ' + data.method + ' on target ' + data.target + ' because object has no method with that name');
            }

            var result, error;
            try {
                result = method.apply(target, data.message);
            } catch (e) {
                // Thrown errors will be passed back (in string form) to worker
                error = e;
            }

            // Send return value to worker
            var payload = undefined,
                transferables = [];

            // Async result
            if (result instanceof _Promise) {
                result.then(function (value) {
                    if (value instanceof WorkerBroker.returnWithTransferables) {
                        transferables = value.transferables;
                        value = value.value;
                    }

                    payload = {
                        type: 'main_reply',
                        message_id: id,
                        message: value
                    };
                    payload = maybeEncode(payload, transferables);
                    worker.postMessage(payload, transferables.map(function (t) {
                        return t.object;
                    }));
                    freeTransferables(transferables);
                    // if (transferables.length > 0) {
                    //     Utils.log('trace', `'${method_name}' transferred ${transferables.length} objects to worker thread`);
                    // }
                }, function (error) {
                    worker.postMessage({
                        type: 'main_reply',
                        message_id: id,
                        error: error instanceof Error ? error.message + ': ' + error.stack : error
                    });
                });
            }
            // Immediate result
            else {
                    if (result instanceof WorkerBroker.returnWithTransferables) {
                        transferables = result.transferables;
                        result = result.value;
                    }

                    payload = {
                        type: 'main_reply',
                        message_id: id,
                        message: result,
                        error: error instanceof Error ? error.message + ': ' + error.stack : error
                    };
                    payload = maybeEncode(payload, transferables);
                    worker.postMessage(payload, transferables.map(function (t) {
                        return t.object;
                    }));
                    freeTransferables(transferables);
                    // if (transferables.length > 0) {
                    //     Utils.log('trace', `'${method_name}' transferred ${transferables.length} objects to worker thread`);
                    // }
                }
        });
    };

    // Expose for debugging
    WorkerBroker.getMessages = function () {
        return messages;
    };

    WorkerBroker.getMessageId = function () {
        return message_id;
    };
}

// Worker threads:
// - Receive messages from main thread, and optionally send an async response back as a promise
// - Send messages to main thread, and optionally receive an async response as a promise
function setupWorkerThread() {

    // Send a message to the main thread, and optionally get an async response as a promise
    // Arguments:
    //   - method: the method with this name, specified with dot-notation, will be invoked on the main thread
    //   - message: will be passed to the method call
    // Returns:
    //   - a promise that will be fulfilled if the main thread method returns a value (could be immediately, or async)
    //
    WorkerBroker.postMessage = function (method) {
        for (var _len2 = arguments.length, message = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            message[_key2 - 1] = arguments[_key2];
        }

        // Track state of this message
        var promise = new _Promise(function (resolve, reject) {
            messages[message_id] = { method: method, message: message, resolve: resolve, reject: reject };
        });

        self.postMessage({
            type: 'worker_send', // mark message as method invocation from worker
            message_id: message_id, // unique id for this message, for life of program
            method: method, // will dispatch to a method of this name on the main thread
            message: message // message payload
        });

        message_id++;
        return promise;
    };

    // Listen for messages coming back from the main thread, and fulfill that message's promise
    self.addEventListener('message', function (event) {
        var data = maybeDecode(event.data);
        if (data.type !== 'main_reply') {
            return;
        }

        // Pass the result to the promise
        var id = data.message_id;
        if (messages[id]) {
            if (data.error) {
                messages[id].reject(data.error);
            } else {
                messages[id].resolve(data.message);
            }
            delete messages[id];
        }
    });

    // Receive messages from main thread, dispatch them, and send back a reply
    self.addEventListener('message', function (event) {
        var data = maybeDecode(event.data);

        // Unique id for this message & return call to main thread
        var id = data.message_id;
        if (data.type !== 'main_send' || id == null) {
            return;
        }

        // Call the requested worker method and save the return value

        var _findTarget3 = findTarget(data.method);

        var _findTarget32 = _slicedToArray(_findTarget3, 2);

        var method_name = _findTarget32[0];
        var target = _findTarget32[1];

        if (!target) {
            throw Error('Worker broker could not dispatch message type ' + data.method + ' on target ' + data.target + ' because no object with that name is registered on main thread');
        }

        var method = typeof target[method_name] === 'function' && target[method_name];

        if (!method) {
            throw Error('Worker broker could not dispatch message type ' + data.method + ' because worker has no method with that name');
        }

        var result, error;
        try {
            result = method.apply(target, data.message);
        } catch (e) {
            // Thrown errors will be passed back (in string form) to main thread
            error = e;
        }

        // Send return value to main thread
        var payload = undefined,
            transferables = [];

        // Async result
        if (result instanceof _Promise) {
            result.then(function (value) {
                if (value instanceof WorkerBroker.returnWithTransferables) {
                    transferables = value.transferables;
                    value = value.value;
                }

                payload = {
                    type: 'worker_reply',
                    message_id: id,
                    message: value
                };
                payload = maybeEncode(payload, transferables);
                self.postMessage(payload, transferables.map(function (t) {
                    return t.object;
                }));
                freeTransferables(transferables);
                // if (transferables.length > 0) {
                //     Utils.log('trace', `'${method_name}' transferred ${transferables.length} objects to main thread`);
                // }
            }, function (error) {
                self.postMessage({
                    type: 'worker_reply',
                    message_id: id,
                    error: error instanceof Error ? error.message + ': ' + error.stack : error
                });
            });
        }
        // Immediate result
        else {
                if (result instanceof WorkerBroker.returnWithTransferables) {
                    transferables = result.transferables;
                    result = result.value;
                }

                payload = {
                    type: 'worker_reply',
                    message_id: id,
                    message: result,
                    error: error instanceof Error ? error.message + ': ' + error.stack : error
                };
                payload = maybeEncode(payload, transferables);
                self.postMessage(payload, transferables.map(function (t) {
                    return t.object;
                }));
                freeTransferables(transferables);
                // if (transferables.length > 0) {
                //     Utils.log('trace', `'${method_name}' transferred ${transferables.length} objects to main thread`);
                // }
            }
    });
}

// Special return value wrapper, to indicate that we want to find and include
// transferable objects in the response message
WorkerBroker.returnWithTransferables = function (value) {
    if (!(this instanceof WorkerBroker.returnWithTransferables)) {
        return new WorkerBroker.returnWithTransferables(value);
    }

    this.value = value;
    this.transferables = findTransferables(this.value);
};

// Build a list of transferable objects from a source object
// Returns a list of info about each transferable:
//   - object: the actual transferable object
//   - parent: the parent object that the transferable is a property of (if any)
//   - property: the property name of the transferable on the parent object (if any)
// TODO: add option in case you DON'T want to transfer objects
function findTransferables(source) {
    var parent = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    var property = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
    var list = arguments.length <= 3 || arguments[3] === undefined ? [] : arguments[3];

    if (!source) {
        return list;
    }

    if (Array.isArray(source)) {
        // Check each array element
        source.forEach(function (x, i) {
            return findTransferables(x, source, i, list);
        });
    } else if (typeof source === 'object') {
        // Is the object a transferable array buffer?
        if (source instanceof ArrayBuffer) {
            list.push({ object: source, parent: parent, property: property });
        }
        // Or looks like a typed array (has an array buffer property)?
        else if (source.buffer instanceof ArrayBuffer) {
                list.push({ object: source.buffer, parent: parent, property: property });
            }
            // Otherwise check each property
            else {
                    for (var prop in source) {
                        findTransferables(source[prop], source, prop, list);
                    }
                }
    }
    return list;
}

// Remove neutered transferables from parent objects, as they should no longer be accessed after transfer
function freeTransferables(transferables) {
    if (!Array.isArray(transferables)) {
        return;
    }
    transferables.filter(function (t) {
        return t.parent && t.property;
    }).forEach(function (t) {
        return delete t.parent[t.property];
    });
}

// Message payload can be stringified for faster transfer, if it does not include transferable objects
function maybeEncode(payload, transferables) {
    if (transferables.length === 0) {
        payload = JSON.stringify(payload);
    }
    return payload;
}

// Parse stringified message payload
function maybeDecode(data) {
    return typeof data === 'string' ? JSON.parse(data) : data;
}

// Setup this thread as appropriate
if (_utils2['default'].isMainThread) {
    setupMainThread();
}

if (_utils2['default'].isWorkerThread) {
    setupWorkerThread();
}
module.exports = exports['default'];

},{"./utils":247,"babel-runtime/core-js/map":4,"babel-runtime/core-js/promise":14,"babel-runtime/helpers/interop-require-default":23,"babel-runtime/helpers/sliced-to-array":24}],250:[function(_dereq_,module,exports){
/*** Vector functions - vectors provided as [x, y, z] arrays ***/

'use strict';

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});
var Vector;
exports['default'] = Vector = {};

Vector.set = function (v) {
    var V = [];
    var lim = v.length;
    for (var i = 0; i < lim; i++) {
        V[i] = v[i];
    }
    return V;
};

Vector.neg = function (v) {
    var V = [];
    var lim = v.length;
    for (var i = 0; i < lim; i++) {
        V[i] = v[i] * -1;
    }
    return V;
};

// Addition of two vectors
Vector.add = function (v1, v2) {
    var v = [];
    var lim = Math.min(v1.length, v2.length);
    for (var i = 0; i < lim; i++) {
        v[i] = v1[i] + v2[i];
    }
    return v;
};

// Substraction of two vectors
Vector.sub = function (v1, v2) {
    var v = [];
    var lim = Math.min(v1.length, v2.length);

    for (var i = 0; i < lim; i++) {
        v[i] = v1[i] - v2[i];
    }
    return v;
};

Vector.signed_area = function (v1, v2, v3) {
    return (v2[0] - v1[0]) * (v3[1] - v1[1]) - (v3[0] - v1[0]) * (v2[1] - v1[1]);
};

// Multiplication of two vectors
Vector.mult = function (v1, v2) {
    var v = [],
        len = v1.length,
        i;

    if (typeof v2 === 'number') {
        // Mulitply by scalar
        for (i = 0; i < len; i++) {
            v[i] = v1[i] * v2;
        }
    } else {
        // Multiply two vectors
        len = Math.min(v1.length, v2.length);
        for (i = 0; i < len; i++) {
            v[i] = v1[i] * v2[i];
        }
    }
    return v;
};

// Division of two vectors
Vector.div = function (v1, v2) {
    var v = [],
        i;
    if (typeof v2 === 'number') {
        // Divide by scalar
        for (i = 0; i < v1.length; i++) {
            v[i] = v1[i] / v2;
        }
    } else {
        // Divide to vectors
        var len = Math.min(v1.length, v2.length);
        for (i = 0; i < len; i++) {
            v[i] = v1[i] / v2[i];
        }
    }
    return v;
};

// Get 2D perpendicular
Vector.perp = function (v1, v2) {
    return [v2[1] - v1[1], v1[0] - v2[0]];
};

// Get 2D vector rotated
Vector.rot = function (v, a) {
    var c = Math.cos(a);
    var s = Math.sin(a);
    return [v[0] * c - v[1] * s, v[0] * s + v[1] * c];
};

// Get 2D heading angle
Vector.angle = function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2);

    var x = _ref2[0];
    var y = _ref2[1];

    return Math.atan2(y, x);
};

// Get angle between two vectors
Vector.angleBetween = function (A, B) {
    var delta = Vector.dot(A, B);
    if (delta < -1) {
        delta = -1;
    }
    return Math.acos(delta);
};

// Compare two points
Vector.isEqual = function (v1, v2) {
    var len = v1.length;
    for (var i = 0; i < len; i++) {
        if (v1[i] !== v2[i]) {
            return false;
        }
    }
    return true;
};

// Vector length squared
Vector.lengthSq = function (v) {
    if (v.length === 2) {
        return v[0] * v[0] + v[1] * v[1];
    } else {
        return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
    }
};

// Vector length
Vector.length = function (v) {
    return Math.sqrt(Vector.lengthSq(v));
};

// Normalize a vector
Vector.normalize = function (v) {
    var d;
    if (v.length === 2) {
        d = v[0] * v[0] + v[1] * v[1];
        d = Math.sqrt(d);

        if (d !== 0) {
            return [v[0] / d, v[1] / d];
        }
        return [0, 0];
    } else {
        d = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
        d = Math.sqrt(d);

        if (d !== 0) {
            return [v[0] / d, v[1] / d, v[2] / d];
        }
        return [0, 0, 0];
    }
};

// Cross product of two vectors
Vector.cross = function (v1, v2) {
    return [v1[1] * v2[2] - v1[2] * v2[1], v1[2] * v2[0] - v1[0] * v2[2], v1[0] * v2[1] - v1[1] * v2[0]];
};

// Dot product of two vectors
Vector.dot = function (v1, v2) {
    var n = 0;
    var lim = Math.min(v1.length, v2.length);
    for (var i = 0; i < lim; i++) {
        n += v1[i] * v2[i];
    }
    return n;
};

// Find the intersection of two lines specified as segments from points (p1, p2) and (p3, p4)
// http://en.wikipedia.org/wiki/Line-line_intersection
// http://en.wikipedia.org/wiki/Cramer's_rule
Vector.lineIntersection = function (p1, p2, p3, p4, parallel_tolerance) {
    parallel_tolerance = parallel_tolerance || 0.01;

    // a1*x + b1*y = c1 for line (x1, y1) to (x2, y2)
    // a2*x + b2*y = c2 for line (x3, y3) to (x4, y4)
    var a1 = p1[1] - p2[1]; // y1 - y2
    var b1 = p1[0] - p2[0]; // x1 - x2
    var a2 = p3[1] - p4[1]; // y3 - y4
    var b2 = p3[0] - p4[0]; // x3 - x4
    var c1 = p1[0] * p2[1] - p1[1] * p2[0]; // x1*y2 - y1*x2
    var c2 = p3[0] * p4[1] - p3[1] * p4[0]; // x3*y4 - y3*x4
    var denom = b1 * a2 - a1 * b2;

    if (Math.abs(denom) > parallel_tolerance) {
        return [(c1 * b2 - b1 * c2) / denom, (c1 * a2 - a1 * c2) / denom];
    }
    return null; // return null if lines are (close to) parallel
};
module.exports = exports['default'];

},{"babel-runtime/helpers/sliced-to-array":24}],251:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _geo = _dereq_('./geo');

var _geo2 = _interopRequireDefault(_geo);

var _tile = _dereq_('./tile');

var _tile2 = _interopRequireDefault(_tile);

var _camera = _dereq_('./camera');

var _camera2 = _interopRequireDefault(_camera);

var _utilsUtils = _dereq_('./utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _utilsSubscribe = _dereq_('./utils/subscribe');

var _utilsSubscribe2 = _interopRequireDefault(_utilsSubscribe);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var View = (function () {
    function View(scene, options) {
        _classCallCheck(this, View);

        (0, _utilsSubscribe2['default'])(this);

        this.scene = scene;
        this.createMatrices();

        this.zoom = null;
        this.center = null;
        this.bounds = null;
        this.meters_per_pixel = null;

        this.panning = false;
        this.zooming = false;
        this.zoom_direction = 0;

        // Size of viewport in CSS pixels, device pixels, and mercator meters
        this.size = {
            css: {},
            device: {},
            meters: {}
        };
        this.aspect = null;

        this.buffer = 0;
        this.continuous_zoom = typeof options.continuousZoom === 'boolean' ? options.continuousZoom : true;
        this.tile_simplification_level = 0; // level-of-detail downsampling to apply to tile loading
        this.preserve_tiles_within_zoom = 1;

        this.reset();
    }

    // Reset state before scene config is updated

    _createClass(View, [{
        key: 'reset',
        value: function reset() {
            this.createCamera();
        }

        // Create camera
    }, {
        key: 'createCamera',
        value: function createCamera() {
            var active_camera = this.getActiveCamera();
            if (active_camera) {
                this.camera = _camera2['default'].create(active_camera, this, this.scene.config.cameras[active_camera]);
                this.camera.updateView();
            }
        }

        // Get active camera - for public API
    }, {
        key: 'getActiveCamera',
        value: function getActiveCamera() {
            if (this.scene.config && this.scene.config.cameras) {
                for (var _name in this.scene.config.cameras) {
                    if (this.scene.config.cameras[_name].active) {
                        return _name;
                    }
                }
            }
        }

        // Set active camera and recompile - for public API
    }, {
        key: 'setActiveCamera',
        value: function setActiveCamera(name) {
            var prev = this.getActiveCamera();
            if (this.scene.config.cameras[name]) {
                this.scene.config.cameras[name].active = true;

                // Clear previously active camera
                if (prev && prev !== name && this.scene.config.cameras[prev]) {
                    delete this.scene.config.cameras[prev].active;
                }
            }

            this.scene.updateConfig();
            return this.getActiveCamera();
        }

        // Update method called once per frame
    }, {
        key: 'update',
        value: function update() {
            this.camera.update();
        }

        // Set logical pixel size of viewport
    }, {
        key: 'setViewportSize',
        value: function setViewportSize(width, height) {
            this.size.css = { width: width, height: height };
            this.size.device = {
                width: Math.round(this.size.css.width * _utilsUtils2['default'].device_pixel_ratio),
                height: Math.round(this.size.css.height * _utilsUtils2['default'].device_pixel_ratio)
            };
            this.aspect = this.size.css.width / this.size.css.height;
            this.updateBounds();
        }

        // Set the map view, can be passed an object with lat/lng and/or zoom
    }, {
        key: 'setView',
        value: function setView() {
            var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            var lng = _ref.lng;
            var lat = _ref.lat;
            var zoom = _ref.zoom;

            var changed = false;

            // Set center
            if (typeof lng === 'number' && typeof lat === 'number') {
                if (!this.center || lng !== this.center.lng || lat !== this.center.lat) {
                    changed = true;
                    this.center = { lng: _geo2['default'].wrapLng(lng), lat: lat };
                }
            }

            // Set zoom
            if (typeof zoom === 'number' && zoom !== this.zoom) {
                changed = true;
                this.setZoom(zoom);
            }

            if (changed) {
                this.updateBounds();
            }
            return changed;
        }
    }, {
        key: 'setZoom',
        value: function setZoom(zoom) {
            if (this.zooming) {
                this.zooming = false;
            } else {
                this.last_zoom = this.zoom;
            }

            var last_tile_zoom = this.tile_zoom;
            var tile_zoom = this.tileZoom(zoom);
            if (!this.continuous_zoom) {
                zoom = tile_zoom;
            }

            if (tile_zoom !== last_tile_zoom) {
                this.zoom_direction = tile_zoom > last_tile_zoom ? 1 : -1;
            }

            this.last_zoom = this.zoom;
            this.zoom = zoom;
            this.tile_zoom = tile_zoom;

            this.updateBounds();
            this.scene.requestRedraw();
        }
    }, {
        key: 'startZoom',
        value: function startZoom() {
            this.last_zoom = this.zoom;
            this.zooming = true;
        }

        // Choose the base zoom level to use for a given fractional zoom
    }, {
        key: 'baseZoom',
        value: function baseZoom(zoom) {
            return Math.floor(zoom);
        }

        // For a given view zoom, what tile zoom should be loaded?
    }, {
        key: 'tileZoom',
        value: function tileZoom(view_zoom) {
            return this.baseZoom(view_zoom) - this.tile_simplification_level;
        }

        // For a given tile zoom, what style zoom should be used?
    }, {
        key: 'styleZoom',
        value: function styleZoom(tile_zoom) {
            return this.baseZoom(tile_zoom) + this.tile_simplification_level;
        }
    }, {
        key: 'ready',
        value: function ready() {
            // TODO: better concept of "readiness" state?
            if (this.size.css == null || this.center == null || this.zoom == null) {
                return false;
            }
            return true;
        }

        // Calculate viewport bounds based on current center and zoom
    }, {
        key: 'updateBounds',
        value: function updateBounds() {
            if (!this.ready()) {
                return;
            }

            this.meters_per_pixel = _geo2['default'].metersPerPixel(this.zoom);

            // Size of the half-viewport in meters at current zoom
            this.size.meters = {
                x: this.size.css.width * this.meters_per_pixel,
                y: this.size.css.height * this.meters_per_pixel
            };

            // Center of viewport in meters, and tile

            var _Geo$latLngToMeters = _geo2['default'].latLngToMeters([this.center.lng, this.center.lat]);

            var _Geo$latLngToMeters2 = _slicedToArray(_Geo$latLngToMeters, 2);

            var x = _Geo$latLngToMeters2[0];
            var y = _Geo$latLngToMeters2[1];

            this.center.meters = { x: x, y: y };

            this.center.tile = _geo2['default'].tileForMeters([this.center.meters.x, this.center.meters.y], this.tile_zoom);

            // Bounds in meters
            this.bounds = {
                sw: {
                    x: this.center.meters.x - this.size.meters.x / 2,
                    y: this.center.meters.y - this.size.meters.y / 2
                },
                ne: {
                    x: this.center.meters.x + this.size.meters.x / 2,
                    y: this.center.meters.y + this.size.meters.y / 2
                }
            };

            this.scene.tile_manager.updateTilesForView(this.view);

            this.trigger('move');
            this.scene.requestRedraw(); // TODO automate via move event?
        }
    }, {
        key: 'findVisibleTileCoordinates',
        value: function findVisibleTileCoordinates() {
            if (!this.bounds) {
                return [];
            }

            var z = this.tile_zoom;
            var sw = _geo2['default'].tileForMeters([this.bounds.sw.x, this.bounds.sw.y], z);
            var ne = _geo2['default'].tileForMeters([this.bounds.ne.x, this.bounds.ne.y], z);

            var coords = [];
            for (var x = sw.x - this.buffer; x <= ne.x + this.buffer; x++) {
                for (var y = ne.y - this.buffer; y <= sw.y + this.buffer; y++) {
                    coords.push(_tile2['default'].coord({ x: x, y: y, z: z }));
                }
            }
            return coords;
        }

        // Remove tiles too far outside of view
    }, {
        key: 'pruneTilesForView',
        value: function pruneTilesForView() {
            var _this = this;

            // TODO: will this function ever be called when view isn't ready?
            if (!this.ready()) {
                return;
            }

            // Remove tiles that are a specified # of tiles outside of the viewport border
            var border_tiles = [Math.ceil((Math.floor(this.size.css.width / _geo2['default'].tile_size) + 2) / 2), Math.ceil((Math.floor(this.size.css.height / _geo2['default'].tile_size) + 2) / 2)];

            this.scene.tile_manager.removeTiles(function (tile) {
                // Ignore visible tiles
                if (tile.visible || tile.proxy) {
                    return false;
                }

                // Remove tiles outside given zoom that are still loading
                if (tile.loading && tile.style_zoom !== _this.tile_zoom) {
                    return true;
                }

                // Discard if too far from current zoom
                var zdiff = Math.abs(tile.style_zoom - _this.tile_zoom);
                if (zdiff > _this.preserve_tiles_within_zoom) {
                    return true;
                }

                // Handle tiles at different zooms
                var coords = _tile2['default'].coordinateAtZoom(tile.coords, _this.tile_zoom);

                // Discard tiles outside an area surrounding the viewport
                if (Math.abs(coords.x - _this.center.tile.x) - border_tiles[0] > _this.buffer) {
                    _loglevel2['default'].trace('View: remove tile ' + tile.key + ' (as ' + coords.x + '/' + coords.y + '/' + _this.tile_zoom + ') for being too far out of visible area ***');
                    return true;
                } else if (Math.abs(coords.y - _this.center.tile.y) - border_tiles[1] > _this.buffer) {
                    _loglevel2['default'].trace('View: remove tile ' + tile.key + ' (as ' + coords.x + '/' + coords.y + '/' + _this.tile_zoom + ') for being too far out of visible area ***');
                    return true;
                }
                return false;
            });
        }

        // Allocate model-view matrices
        // 64-bit versions are for CPU calcuations
        // 32-bit versions are downsampled and sent to GPU
    }, {
        key: 'createMatrices',
        value: function createMatrices() {
            this.matrices = {};
            this.matrices.model = new Float64Array(16);
            this.matrices.model32 = new Float32Array(16);
            this.matrices.model_view = new Float64Array(16);
            this.matrices.model_view32 = new Float32Array(16);
            this.matrices.normal = new Float64Array(9);
            this.matrices.normal32 = new Float32Array(9);
            this.matrices.inverse_normal32 = new Float32Array(9);
        }

        // Calculate and set model/view and normal matrices for a tile
    }, {
        key: 'setupTile',
        value: function setupTile(tile, program) {
            // Tile-specific state
            // TODO: calc these once per tile (currently being needlessly re-calculated per-tile-per-style)
            tile.setupProgram(this.matrices, program);

            // Model-view and normal matrices
            this.camera.setupMatrices(this.matrices, program);
        }

        // Set general uniforms that must be updated once per program
    }, {
        key: 'setupProgram',
        value: function setupProgram(program) {
            program.uniform('2f', 'u_resolution', this.size.device.width, this.size.device.height);
            program.uniform('3f', 'u_map_position', this.center.meters.x, this.center.meters.y, this.zoom);
            program.uniform('1f', 'u_meters_per_pixel', this.meters_per_pixel);
            program.uniform('1f', 'u_device_pixel_ratio', _utilsUtils2['default'].device_pixel_ratio);

            this.camera.setupProgram(program);
        }
    }]);

    return View;
})();

exports['default'] = View;
module.exports = exports['default'];

},{"./camera":196,"./geo":197,"./tile":239,"./utils/subscribe":246,"./utils/utils":247,"babel-runtime/helpers/class-call-check":18,"babel-runtime/helpers/create-class":19,"babel-runtime/helpers/interop-require-default":23,"babel-runtime/helpers/sliced-to-array":24,"loglevel":183}]},{},[218])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvaXMtaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL21hcC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbWF0aC9sb2cyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9mcmVlemUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3MtY2FsbC1jaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlLWNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2dldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2ludGVyb3AtcmVxdWlyZS1kZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWQtdG8tYXJyYXkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3RvLWNvbnN1bWFibGUtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCJub2RlX21vZHVsZXMvYml0LXR3aWRkbGUvdHdpZGRsZS5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL2JydXRlLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL2ludGVyc2VjdC5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9tZWRpYW4uanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9saWIvcGFydGl0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL3NvcnQuanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9saWIvc3dlZXAuanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vbWFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9tYXRoL2xvZzIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2ZyZWV6ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuYS1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmFkZC10by11bnNjb3BhYmxlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmFuLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNsYXNzb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNvbGxlY3Rpb24tdG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY3R4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmRlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmVudW0ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmV4cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZm9yLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZ2V0LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmh0bWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pbnZva2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXMtYXJyYXktaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmlzLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1jYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItZGV0ZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1zdGVwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5rZXlvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmxpYnJhcnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5taWNyb3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5vYmplY3QtYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQub2JqZWN0LXNhcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnByb3BlcnR5LWRlc2MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5yZWRlZmluZS1hbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5yZWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNhbWUtdmFsdWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zZXQtcHJvdG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zZXQtc3BlY2llcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNldC10by1zdHJpbmctdGFnLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnN0cmljdC1uZXcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zdHJpbmctYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC50YXNrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudG8taW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRvLWlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC50by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC50by1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC51aWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC53a3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm1hdGgubG9nMi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc2V0LnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jc3Njb2xvcnBhcnNlci9jc3Njb2xvcnBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9kdXAvZHVwLmpzIiwibm9kZV9tb2R1bGVzL2VhcmN1dC9zcmMvZWFyY3V0LmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL2NsaXAuanMiLCJub2RlX21vZHVsZXMvZ2VvanNvbi12dC9zcmMvY29udmVydC5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy9zaW1wbGlmeS5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy90aWxlLmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL3dyYXAuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0My9pbnZlcnQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0My9ub3JtYWwtZnJvbS1tYXQ0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvY29weS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvbG9va0F0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvbXVsdGlwbHkuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9wZXJzcGVjdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3NjYWxlLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvdHJhbnNsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXNoYWRlci1lcnJvcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1hcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9jb21tb24uanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9leGNlcHRpb24uanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9sb2FkZXIuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9tYXJrLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hL2NvcmUuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZS5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZS5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9qc29uLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvYmluYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9ib29sLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9mbG9hdC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvaW50LmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy9mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvcmVnZXhwLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy91bmRlZmluZWQuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL21hcC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvbWVyZ2UuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL251bGwuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL29tYXAuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3BhaXJzLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zZXEuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3NldC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvc3RyLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS90aW1lc3RhbXAuanMiLCJub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwibm9kZV9tb2R1bGVzL21hdGNoLWZlYXR1cmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGJmL2J1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9wYmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcG9pbnQtZ2VvbWV0cnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3N0cmlwLWNvbW1lbnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvcG9qc29uL3RvcG9qc29uLmpzIiwibm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9wb29sLmpzIiwibm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2xpYi92ZWN0b3J0aWxlLmpzIiwibm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2xpYi92ZWN0b3J0aWxlZmVhdHVyZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9saWIvdmVjdG9ydGlsZWxheWVyLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9jYW1lcmEuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2dlby5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvZ2wvY29uc3RhbnRzLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC9jb250ZXh0LmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC9leHRlbnNpb25zLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC9nbHNsLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC9yZW5kZXJfc3RhdGUuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2dsL3NoYWRlcl9wcm9ncmFtLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC9zaGFkZXJfc291cmNlcy5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvZ2wvdGV4dHVyZS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvZ2wvdmFvLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC92Ym9fbWVzaC5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvZ2wvdmVydGV4X2RhdGEuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2dsL3ZlcnRleF9sYXlvdXQuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2xhYmVscy9jb2xsaXNpb24uanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2xhYmVscy9sYWJlbC5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvbGFiZWxzL2xhYmVsX2xpbmUuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2xhYmVscy9sYWJlbF9wb2ludC5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvbGFiZWxzL3JlcGVhdF9ncm91cC5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvbGVhZmxldF9sYXllci5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvbGlnaHQuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL21hdGVyaWFsLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9tb2R1bGUuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3NjZW5lLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zY2VuZV9sb2FkZXIuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3NjZW5lX3dvcmtlci5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc2VsZWN0aW9uLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zb3VyY2VzL2RhdGFfc291cmNlLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zb3VyY2VzL2dlb2pzb24uanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3NvdXJjZXMvbXZ0LmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zb3VyY2VzL3RvcG9qc29uLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvYnVpbGRlcnMuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy9saW5lcy9saW5lcy5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc3R5bGVzL3BvaW50cy9wb2ludF9hbmNob3IuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy9wb2ludHMvcG9pbnRzLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvcG9seWdvbnMvcG9seWdvbnMuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy9ydWxlLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvc3R5bGUuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy9zdHlsZV9tYW5hZ2VyLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvc3R5bGVfcGFyc2VyLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvdGV4dC9jYW52YXNfdGV4dC5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc3R5bGVzL3RleHQvdGV4dC5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc3R5bGVzL3RleHQvdGV4dF9zZXR0aW5ncy5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvdGlsZS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvdGlsZV9tYW5hZ2VyLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy90aWxlX3B5cmFtaWQuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3V0aWxzL2Vycm9ycy5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvdXRpbHMvZ2wtbWF0cml4LmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy91dGlscy9tZXJnZS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvdXRpbHMvb2JiLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy91dGlscy9zdWJzY3JpYmUuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3V0aWxzL3V0aWxzLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy91dGlscy92ZXJzaW9uLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy91dGlscy93b3JrZXJfYnJva2VyLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy92ZWN0b3IuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3ZpZXcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcG5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1aENBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7O0FDRkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE9BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2prQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hOQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFDN0YsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsRUFBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQUFBQyxFQUFFLENBQUMsRUFBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQUFBQyxFQUFFLENBQUM7QUFDM0UsWUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztBQUM3RixZQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQzs7O0FBR3JCLFlBQUksQ0FBQyxlQUFlLEdBQUcsaUJBQUksZUFBZSxDQUFDO0FBQzNDLFlBQUksSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRTtBQUNqQyxnQkFBSSxDQUFDLGVBQWUsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDeEU7O0FBRUQsWUFBSSxDQUFDLGdCQUFnQixHQUFHLGlCQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzFELFlBQUksQ0FBQyxlQUFlLEdBQUcsaUJBQUksYUFBYSxD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LE1BQU0sQ0FBQyxHQUFHLEdBQUcsVUFBVSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQzNCLFFBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNYLFFBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDeEMsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMxQixTQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUN4QjtBQUNELFdBQU8sQ0FBQyxDQUFDO0NBQ1osQ0FBQzs7O0FBR0YsTUFBTSxDQUFDLEdBQUcsR0FBRyxVQUFVLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDM0IsUUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQ1gsUUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQzs7QUFFeEMsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMxQixTQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUN4QjtBQUNELFdBQU8sQ0FBQyxDQUFDO0NBQ1osQ0FBQzs7QUFFRixNQUFNLENBQUMsV0FBVyxHQUFHLFVBQVUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDdkMsV0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUEsSUFBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBLEFBQUMsR0FBRyxD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QUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUU7S0FDOUM7Q0FDSixDQUFDOzs7QUFHRixNQUFNLENBQUMsTUFBTSxHQUFHLFVBQVUsQ0FBQyxFQUMzQjtBQUNJLFdBQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDeEMsQ0FBQzs7O0FBR0YsTUFBTSxDQUFDLFNBQVMsR0FBRyxVQUFVLENBQUMsRUFDOUI7QUFDSSxRQUFJLENBQUMsQ0FBQztBQUNOLFFBQUksQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7QUFDaEIsU0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMxQixTQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQzs7QUFFakIsWUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQ1QsbUJBQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUMvQjtBQUNELGVBQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7S0FDakIsTUFBTTtBQUNILFNBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0QyxTQUFDLEdBQUcs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QUFPLENBQUMsQ0FBQztTQUNyRDs7Ozs7ZUFHWSxzQkFBQyxPQUFPLEVBQUU7QUFDbkIsbUJBQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLGNBQWMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDdkYsbUJBQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLGdCQUFnQixFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQy9GLG1CQUFPLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxvQkFBb0IsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUNuRSxtQkFBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsc0JBQXNCLEVBQUUsd0JBQU0sa0JBQWtCLENBQUMsQ0FBQzs7QUFFeEUsZ0JBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ3JDOzs7V0E5U2dCLElBQUk7OztxQkFBSixJQUFJIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9tYXBcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vbWF0aC9sb2cyXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ25cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnRpZXNcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZnJlZXplXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXNcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zZXRcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX09iamVjdCRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKVtcImRlZmF1bHRcIl07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG5cbiAgICAgIF9PYmplY3QkZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0pKCk7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfT2JqZWN0JGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpW1wiZGVmYXVsdFwiXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgX09iamVjdCRkZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIilbXCJkZWZhdWx0XCJdO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHtcbiAgdmFyIF9hZ2FpbiA9IHRydWU7XG5cbiAgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7XG4gICAgdmFyIG9iamVjdCA9IF94LFxuICAgICAgICBwcm9wZXJ0eSA9IF94MixcbiAgICAgICAgcmVjZWl2ZXIgPSBfeDM7XG4gICAgX2FnYWluID0gZmFsc2U7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gICAgdmFyIGRlc2MgPSBfT2JqZWN0JGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcblxuICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3ggPSBwYXJlbnQ7XG4gICAgICAgIF94MiA9IHByb3BlcnR5O1xuICAgICAgICBfeDMgPSByZWNlaXZlcjtcbiAgICAgICAgX2FnYWluID0gdHJ1ZTtcbiAgICAgICAgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udGludWUgX2Z1bmN0aW9uO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHtcbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9PYmplY3QkY3JlYXRlID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpW1wiZGVmYXVsdFwiXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gX09iamVjdCRjcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9PYmplY3Qkc2V0UHJvdG90eXBlT2YgPyBfT2JqZWN0JHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2dldEl0ZXJhdG9yID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3JcIilbXCJkZWZhdWx0XCJdO1xuXG52YXIgX2lzSXRlcmFibGUgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2lzLWl0ZXJhYmxlXCIpW1wiZGVmYXVsdFwiXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSBfZ2V0SXRlcmF0b3IoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmIChfaXNJdGVyYWJsZShPYmplY3QoYXJyKSkpIHtcbiAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfQXJyYXkkZnJvbSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbVwiKVtcImRlZmF1bHRcIl07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBfQXJyYXkkZnJvbShhcnIpO1xuICB9XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXG52YXIgZyA9XG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpcztcblxuLy8gVXNlIGBnZXRPd25Qcm9wZXJ0eU5hbWVzYCBiZWNhdXNlIG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCBjYWxsaW5nXG4vLyBgaGFzT3duUHJvcGVydHlgIG9uIHRoZSBnbG9iYWwgYHNlbGZgIG9iamVjdCBpbiBhIHdvcmtlci4gU2VlICMxODMuXG52YXIgaGFkUnVudGltZSA9IGcucmVnZW5lcmF0b3JSdW50aW1lICYmXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGcpLmluZGV4T2YoXCJyZWdlbmVyYXRvclJ1bnRpbWVcIikgPj0gMDtcblxuLy8gU2F2ZSB0aGUgb2xkIHJlZ2VuZXJhdG9yUnVudGltZSBpbiBjYXNlIGl0IG5lZWRzIHRvIGJlIHJlc3RvcmVkIGxhdGVyLlxudmFyIG9sZFJ1bnRpbWUgPSBoYWRSdW50aW1lICYmIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuXG4vLyBGb3JjZSByZWV2YWx1dGF0aW9uIG9mIHJ1bnRpbWUuanMuXG5nLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9ydW50aW1lXCIpO1xuXG5pZiAoaGFkUnVudGltZSkge1xuICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBydW50aW1lLlxuICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IG9sZFJ1bnRpbWU7XG59IGVsc2Uge1xuICAvLyBSZW1vdmUgdGhlIGdsb2JhbCBwcm9wZXJ0eSBhZGRlZCBieSBydW50aW1lLmpzLlxuICB0cnkge1xuICAgIGRlbGV0ZSBnLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBtb2R1bGUuZXhwb3J0cywgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpWVdKbGJDMXlkVzUwYVcxbEwzSmxaMlZ1WlhKaGRHOXlMMmx1WkdWNExtcHpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTSXNJbVpwYkdVaU9pSm5aVzVsY21GMFpXUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpTHk4Z1ZHaHBjeUJ0WlhSb2IyUWdiMllnYjJKMFlXbHVhVzVuSUdFZ2NtVm1aWEpsYm1ObElIUnZJSFJvWlNCbmJHOWlZV3dnYjJKcVpXTjBJRzVsWldSeklIUnZJR0psWEc0dkx5QnJaWEIwSUdsa1pXNTBhV05oYkNCMGJ5QjBhR1VnZDJGNUlHbDBJR2x6SUc5aWRHRnBibVZrSUdsdUlISjFiblJwYldVdWFuTmNiblpoY2lCbklEMWNiaUFnZEhsd1pXOW1JR2RzYjJKaGJDQTlQVDBnWENKdlltcGxZM1JjSWlBL0lHZHNiMkpoYkNBNlhHNGdJSFI1Y0dWdlppQjNhVzVrYjNjZ1BUMDlJRndpYjJKcVpXTjBYQ0lnUHlCM2FXNWtiM2NnT2x4dUlDQjBlWEJsYjJZZ2MyVnNaaUE5UFQwZ1hDSnZZbXBsWTNSY0lpQS9JSE5sYkdZZ09pQjBhR2x6TzF4dVhHNHZMeUJWYzJVZ1lHZGxkRTkzYmxCeWIzQmxjblI1VG1GdFpYTmdJR0psWTJGMWMyVWdibTkwSUdGc2JDQmljbTkzYzJWeWN5QnpkWEJ3YjNKMElHTmhiR3hwYm1kY2JpOHZJR0JvWVhOUGQyNVFjbTl3WlhKMGVXQWdiMjRnZEdobElHZHNiMkpoYkNCZ2MyVnNabUFnYjJKcVpXTjBJR2x1SUdFZ2QyOXlhMlZ5TGlCVFpXVWdJekU0TXk1Y2JuWmhjaUJvWVdSU2RXNTBhVzFsSUQwZ1p5NXlaV2RsYm1WeVlYUnZjbEoxYm5ScGJXVWdKaVpjYmlBZ1QySnFaV04wTG1kbGRFOTNibEJ5YjNCbGNuUjVUbUZ0WlhNb1p5a3VhVzVrWlhoUFppaGNJbkpsWjJWdVpYSmhkRzl5VW5WdWRHbHRaVndpS1NBK1BTQXdPMXh1WEc0dkx5QlRZWFpsSUhSb1pTQnZiR1FnY21WblpXNWxjbUYwYjNKU2RXNTBhVzFsSUdsdUlHTmhjMlVnYVhRZ2JtVmxaSE1nZEc4Z1ltVWdjbVZ6ZEc5eVpXUWdiR0YwWlhJdVhHNTJZWElnYjJ4a1VuVnVkR2x0WlNBOUlHaGhaRkoxYm5ScGJXVWdKaVlnWnk1eVpXZGxibVZ5WVhSdmNsSjFiblJwYldVN1hHNWNiaTh2SUVadmNtTmxJSEpsWlhaaGJIVjBZWFJwYjI0Z2IyWWdjblZ1ZEdsdFpTNXFjeTVjYm1jdWNtVm5aVzVsY21GMGIzSlNkVzUwYVcxbElEMGdkVzVrWldacGJtVmtPMXh1WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUhKbGNYVnBjbVVvWENJdUwzSjFiblJwYldWY0lpazdYRzVjYm1sbUlDaG9ZV1JTZFc1MGFXMWxLU0I3WEc0Z0lDOHZJRkpsYzNSdmNtVWdkR2hsSUc5eWFXZHBibUZzSUhKMWJuUnBiV1V1WEc0Z0lHY3VjbVZuWlc1bGNtRjBiM0pTZFc1MGFXMWxJRDBnYjJ4a1VuVnVkR2x0WlR0Y2JuMGdaV3h6WlNCN1hHNGdJQzh2SUZKbGJXOTJaU0IwYUdVZ1oyeHZZbUZzSUhCeWIzQmxjblI1SUdGa1pHVmtJR0o1SUhKMWJuUnBiV1V1YW5NdVhHNGdJSFJ5ZVNCN1hHNGdJQ0FnWkdWc1pYUmxJR2N1Y21WblpXNWxjbUYwYjNKU2RXNTBhVzFsTzF4dUlDQjlJR05oZEdOb0tHVXBJSHRjYmlBZ0lDQm5MbkpsWjJWdVpYSmhkRzl5VW5WdWRHbHRaU0E5SUhWdVpHVm1hVzVsWkR0Y2JpQWdmVnh1ZlZ4dVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlIc2dYQ0prWldaaGRXeDBYQ0k2SUcxdlpIVnNaUzVsZUhCdmNuUnpMQ0JmWDJWelRXOWtkV3hsT2lCMGNuVmxJSDA3WEc0aVhYMD0iLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX1N5bWJvbCA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9TeW1ib2wkaXRlcmF0b3IgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBfT2JqZWN0JGNyZWF0ZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBfUHJvbWlzZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiKVtcImRlZmF1bHRcIl07XG5cbiEoZnVuY3Rpb24gKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciBpdGVyYXRvclN5bWJvbCA9IHR5cGVvZiBfU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgX1N5bWJvbCRpdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBnZW5lcmF0b3IgPSBfT2JqZWN0JGNyZWF0ZSgob3V0ZXJGbiB8fCBHZW5lcmF0b3IpLnByb3RvdHlwZSk7XG5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiB8fCBudWxsLCBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSkpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3IgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICBnZW5GdW4ucHJvdG90eXBlID0gX09iamVjdCRjcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGB2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnRgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLiBTb21lIG1heSBjb25zaWRlciB0aGUgbmFtZSBvZiB0aGlzIG1ldGhvZCB0b29cbiAgLy8gY3V0ZXN5LCBidXQgdGhleSBhcmUgY3VybXVkZ2VvbnMuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIG5ldyBBd2FpdEFyZ3VtZW50KGFyZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQXdhaXRBcmd1bWVudChhcmcpIHtcbiAgICB0aGlzLmFyZyA9IGFyZztcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgLy8gVGhpcyBpbnZva2UgZnVuY3Rpb24gaXMgd3JpdHRlbiBpbiBhIHN0eWxlIHRoYXQgYXNzdW1lcyBzb21lXG4gICAgLy8gY2FsbGluZyBmdW5jdGlvbiAob3IgUHJvbWlzZSkgd2lsbCBoYW5kbGUgZXhjZXB0aW9ucy5cbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZW5lcmF0b3JbbWV0aG9kXShhcmcpO1xuICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudCA/IF9Qcm9taXNlLnJlc29sdmUodmFsdWUuYXJnKS50aGVuKGludm9rZU5leHQsIGludm9rZVRocm93KSA6IF9Qcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkge1xuICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBpbnZva2VOZXh0ID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcIm5leHRcIik7XG4gICAgdmFyIGludm9rZVRocm93ID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInRocm93XCIpO1xuICAgIHZhciBpbnZva2VSZXR1cm4gPSBpbnZva2UuYmluZChnZW5lcmF0b3IsIFwicmV0dXJuXCIpO1xuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICB2YXIgZW5xdWV1ZVJlc3VsdCA9XG4gICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pIDogbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHJlc29sdmUoaW52b2tlKG1ldGhvZCwgYXJnKSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZW5xdWV1ZVJlc3VsdCBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieVxuICAgICAgLy8gbGF0ZXIgaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgcHJldmlvdXNQcm9taXNlID0gZW5xdWV1ZVJlc3VsdFtcImNhdGNoXCJdKGZ1bmN0aW9uIChpZ25vcmVkKSB7fSk7XG5cbiAgICAgIHJldHVybiBlbnF1ZXVlUmVzdWx0O1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIgfHwgbWV0aG9kID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIExpa2UgcmV0dXJuaW5nIGdlbmVyYXRvci50aHJvdyh1bmNhdWdodCksIGJ1dCB3aXRob3V0IHRoZVxuICAgICAgICAgICAgLy8gb3ZlcmhlYWQgb2YgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCkge1xuICAgICAgICAgICAgY29udGV4dC5zZW50ID0gYXJnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IEdlblN0YXRlQ29tcGxldGVkIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlICYmIG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICB0aGlzLnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJiAodHlwZSA9PT0gXCJicmVha1wiIHx8IHR5cGUgPT09IFwiY29udGludWVcIikgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHwgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbi8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbi8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbnR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdW5kZWZpbmVkKTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aVlXSmxiQzF5ZFc1MGFXMWxMM0psWjJWdVpYSmhkRzl5TDNKMWJuUnBiV1V1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVpTENKbWFXeGxJam9pWjJWdVpYSmhkR1ZrTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklpOHFLbHh1SUNvZ1EyOXdlWEpwWjJoMElDaGpLU0F5TURFMExDQkdZV05sWW05dmF5d2dTVzVqTGx4dUlDb2dRV3hzSUhKcFoyaDBjeUJ5WlhObGNuWmxaQzVjYmlBcVhHNGdLaUJVYUdseklITnZkWEpqWlNCamIyUmxJR2x6SUd4cFkyVnVjMlZrSUhWdVpHVnlJSFJvWlNCQ1UwUXRjM1I1YkdVZ2JHbGpaVzV6WlNCbWIzVnVaQ0JwYmlCMGFHVmNiaUFxSUdoMGRIQnpPaTh2Y21GM0xtZHBkR2gxWWk1amIyMHZabUZqWldKdmIyc3ZjbVZuWlc1bGNtRjBiM0l2YldGemRHVnlMMHhKUTBWT1UwVWdabWxzWlM0Z1FXNWNiaUFxSUdGa1pHbDBhVzl1WVd3Z1ozSmhiblFnYjJZZ2NHRjBaVzUwSUhKcFoyaDBjeUJqWVc0Z1ltVWdabTkxYm1RZ2FXNGdkR2hsSUZCQlZFVk9WRk1nWm1sc1pTQnBibHh1SUNvZ2RHaGxJSE5oYldVZ1pHbHlaV04wYjNKNUxseHVJQ292WEc1Y2Jsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNTJZWElnWDFONWJXSnZiQ0E5SUhKbGNYVnBjbVVvWENKaVlXSmxiQzF5ZFc1MGFXMWxMMk52Y21VdGFuTXZjM2x0WW05c1hDSXBXMXdpWkdWbVlYVnNkRndpWFR0Y2JseHVkbUZ5SUY5VGVXMWliMndrYVhSbGNtRjBiM0lnUFNCeVpYRjFhWEpsS0Z3aVltRmlaV3d0Y25WdWRHbHRaUzlqYjNKbExXcHpMM041YldKdmJDOXBkR1Z5WVhSdmNsd2lLVnRjSW1SbFptRjFiSFJjSWwwN1hHNWNiblpoY2lCZlQySnFaV04wSkdOeVpXRjBaU0E5SUhKbGNYVnBjbVVvWENKaVlXSmxiQzF5ZFc1MGFXMWxMMk52Y21VdGFuTXZiMkpxWldOMEwyTnlaV0YwWlZ3aUtWdGNJbVJsWm1GMWJIUmNJbDA3WEc1Y2JuWmhjaUJmVUhKdmJXbHpaU0E5SUhKbGNYVnBjbVVvWENKaVlXSmxiQzF5ZFc1MGFXMWxMMk52Y21VdGFuTXZjSEp2YldselpWd2lLVnRjSW1SbFptRjFiSFJjSWwwN1hHNWNiaUVvWm5WdVkzUnBiMjRnS0dkc2IySmhiQ2tnZTF4dUlDQmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseHVJQ0IyWVhJZ2FHRnpUM2R1SUQwZ1QySnFaV04wTG5CeWIzUnZkSGx3WlM1b1lYTlBkMjVRY205d1pYSjBlVHRjYmlBZ2RtRnlJSFZ1WkdWbWFXNWxaRHNnTHk4Z1RXOXlaU0JqYjIxd2NtVnpjMmxpYkdVZ2RHaGhiaUIyYjJsa0lEQXVYRzRnSUhaaGNpQnBkR1Z5WVhSdmNsTjViV0p2YkNBOUlIUjVjR1Z2WmlCZlUzbHRZbTlzSUQwOVBTQmNJbVoxYm1OMGFXOXVYQ0lnSmlZZ1gxTjViV0p2YkNScGRHVnlZWFJ2Y2lCOGZDQmNJa0JBYVhSbGNtRjBiM0pjSWp0Y2JseHVJQ0IyWVhJZ2FXNU5iMlIxYkdVZ1BTQjBlWEJsYjJZZ2JXOWtkV3hsSUQwOVBTQmNJbTlpYW1WamRGd2lPMXh1SUNCMllYSWdjblZ1ZEdsdFpTQTlJR2RzYjJKaGJDNXlaV2RsYm1WeVlYUnZjbEoxYm5ScGJXVTdYRzRnSUdsbUlDaHlkVzUwYVcxbEtTQjdYRzRnSUNBZ2FXWWdLR2x1VFc5a2RXeGxLU0I3WEc0Z0lDQWdJQ0F2THlCSlppQnlaV2RsYm1WeVlYUnZjbEoxYm5ScGJXVWdhWE1nWkdWbWFXNWxaQ0JuYkc5aVlXeHNlU0JoYm1RZ2QyVW5jbVVnYVc0Z1lTQnRiMlIxYkdVc1hHNGdJQ0FnSUNBdkx5QnRZV3RsSUhSb1pTQmxlSEJ2Y25SeklHOWlhbVZqZENCcFpHVnVkR2xqWVd3Z2RHOGdjbVZuWlc1bGNtRjBiM0pTZFc1MGFXMWxMbHh1SUNBZ0lDQWdiVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQnlkVzUwYVcxbE8xeHVJQ0FnSUgxY2JpQWdJQ0F2THlCRWIyNG5kQ0JpYjNSb1pYSWdaWFpoYkhWaGRHbHVaeUIwYUdVZ2NtVnpkQ0J2WmlCMGFHbHpJR1pwYkdVZ2FXWWdkR2hsSUhKMWJuUnBiV1VnZDJGelhHNGdJQ0FnTHk4Z1lXeHlaV0ZrZVNCa1pXWnBibVZrSUdkc2IySmhiR3g1TGx4dUlDQWdJSEpsZEhWeWJqdGNiaUFnZlZ4dVhHNGdJQzh2SUVSbFptbHVaU0IwYUdVZ2NuVnVkR2x0WlNCbmJHOWlZV3hzZVNBb1lYTWdaWGh3WldOMFpXUWdZbmtnWjJWdVpYSmhkR1ZrSUdOdlpHVXBJR0Z6SUdWcGRHaGxjbHh1SUNBdkx5QnRiMlIxYkdVdVpYaHdiM0owY3lBb2FXWWdkMlVuY21VZ2FXNGdZU0J0YjJSMWJHVXBJRzl5SUdFZ2JtVjNMQ0JsYlhCMGVTQnZZbXBsWTNRdVhHNGdJSEoxYm5ScGJXVWdQU0JuYkc5aVlXd3VjbVZuWlc1bGNtRjBiM0pTZFc1MGFXMWxJRDBnYVc1TmIyUjFiR1VnUHlCdGIyUjFiR1V1Wlhod2IzSjBjeUE2SUh0OU8xeHVYRzRnSUdaMWJtTjBhVzl1SUhkeVlYQW9hVzV1WlhKR2Jpd2diM1YwWlhKR2Jpd2djMlZzWml3Z2RISjVURzlqYzB4cGMzUXBJSHRjYmlBZ0lDQXZMeUJKWmlCdmRYUmxja1p1SUhCeWIzWnBaR1ZrTENCMGFHVnVJRzkxZEdWeVJtNHVjSEp2ZEc5MGVYQmxJR2x1YzNSaGJtTmxiMllnUjJWdVpYSmhkRzl5TGx4dUlDQWdJSFpoY2lCblpXNWxjbUYwYjNJZ1BTQmZUMkpxWldOMEpHTnlaV0YwWlNnb2IzVjBaWEpHYmlCOGZDQkhaVzVsY21GMGIzSXBMbkJ5YjNSdmRIbHdaU2s3WEc1Y2JpQWdJQ0JuWlc1bGNtRjBiM0l1WDJsdWRtOXJaU0E5SUcxaGEyVkpiblp2YTJWTlpYUm9iMlFvYVc1dVpYSkdiaXdnYzJWc1ppQjhmQ0J1ZFd4c0xDQnVaWGNnUTI5dWRHVjRkQ2gwY25sTWIyTnpUR2x6ZENCOGZDQmJYU2twTzF4dVhHNGdJQ0FnY21WMGRYSnVJR2RsYm1WeVlYUnZjanRjYmlBZ2ZWeHVJQ0J5ZFc1MGFXMWxMbmR5WVhBZ1BTQjNjbUZ3TzF4dVhHNGdJQzh2SUZSeWVTOWpZWFJqYUNCb1pXeHdaWElnZEc4Z2JXbHVhVzFwZW1VZ1pHVnZjSFJwYldsNllYUnBiMjV6TGlCU1pYUjFjbTV6SUdFZ1kyOXRjR3hsZEdsdmJseHVJQ0F2THlCeVpXTnZjbVFnYkdsclpTQmpiMjUwWlhoMExuUnllVVZ1ZEhKcFpYTmJhVjB1WTI5dGNHeGxkR2x2Ymk0Z1ZHaHBjeUJwYm5SbGNtWmhZMlVnWTI5MWJHUmNiaUFnTHk4Z2FHRjJaU0JpWldWdUlDaGhibVFnZDJGeklIQnlaWFpwYjNWemJIa3BJR1JsYzJsbmJtVmtJSFJ2SUhSaGEyVWdZU0JqYkc5emRYSmxJSFJ2SUdKbFhHNGdJQzh2SUdsdWRtOXJaV1FnZDJsMGFHOTFkQ0JoY21kMWJXVnVkSE1zSUdKMWRDQnBiaUJoYkd3Z2RHaGxJR05oYzJWeklIZGxJR05oY21VZ1lXSnZkWFFnZDJWY2JpQWdMeThnWVd4eVpXRmtlU0JvWVhabElHRnVJR1Y0YVhOMGFXNW5JRzFsZEdodlpDQjNaU0IzWVc1MElIUnZJR05oYkd3c0lITnZJSFJvWlhKbEozTWdibThnYm1WbFpGeHVJQ0F2THlCMGJ5QmpjbVZoZEdVZ1lTQnVaWGNnWm5WdVkzUnBiMjRnYjJKcVpXTjBMaUJYWlNCallXNGdaWFpsYmlCblpYUWdZWGRoZVNCM2FYUm9JR0Z6YzNWdGFXNW5YRzRnSUM4dklIUm9aU0J0WlhSb2IyUWdkR0ZyWlhNZ1pYaGhZM1JzZVNCdmJtVWdZWEpuZFcxbGJuUXNJSE5wYm1ObElIUm9ZWFFnYUdGd2NHVnVjeUIwYnlCaVpTQjBjblZsWEc0Z0lDOHZJR2x1SUdWMlpYSjVJR05oYzJVc0lITnZJSGRsSUdSdmJpZDBJR2hoZG1VZ2RHOGdkRzkxWTJnZ2RHaGxJR0Z5WjNWdFpXNTBjeUJ2WW1wbFkzUXVJRlJvWlZ4dUlDQXZMeUJ2Ym14NUlHRmtaR2wwYVc5dVlXd2dZV3hzYjJOaGRHbHZiaUJ5WlhGMWFYSmxaQ0JwY3lCMGFHVWdZMjl0Y0d4bGRHbHZiaUJ5WldOdmNtUXNJSGRvYVdOb1hHNGdJQzh2SUdoaGN5QmhJSE4wWVdKc1pTQnphR0Z3WlNCaGJtUWdjMjhnYUc5d1pXWjFiR3g1SUhOb2IzVnNaQ0JpWlNCamFHVmhjQ0IwYnlCaGJHeHZZMkYwWlM1Y2JpQWdablZ1WTNScGIyNGdkSEo1UTJGMFkyZ29abTRzSUc5aWFpd2dZWEpuS1NCN1hHNGdJQ0FnZEhKNUlIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCN0lIUjVjR1U2SUZ3aWJtOXliV0ZzWENJc0lHRnlaem9nWm00dVkyRnNiQ2h2WW1vc0lHRnlaeWtnZlR0Y2JpQWdJQ0I5SUdOaGRHTm9JQ2hsY25JcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCN0lIUjVjR1U2SUZ3aWRHaHliM2RjSWl3Z1lYSm5PaUJsY25JZ2ZUdGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQjJZWElnUjJWdVUzUmhkR1ZUZFhOd1pXNWtaV1JUZEdGeWRDQTlJRndpYzNWemNHVnVaR1ZrVTNSaGNuUmNJanRjYmlBZ2RtRnlJRWRsYmxOMFlYUmxVM1Z6Y0dWdVpHVmtXV2xsYkdRZ1BTQmNJbk4xYzNCbGJtUmxaRmxwWld4a1hDSTdYRzRnSUhaaGNpQkhaVzVUZEdGMFpVVjRaV04xZEdsdVp5QTlJRndpWlhobFkzVjBhVzVuWENJN1hHNGdJSFpoY2lCSFpXNVRkR0YwWlVOdmJYQnNaWFJsWkNBOUlGd2lZMjl0Y0d4bGRHVmtYQ0k3WEc1Y2JpQWdMeThnVW1WMGRYSnVhVzVuSUhSb2FYTWdiMkpxWldOMElHWnliMjBnZEdobElHbHVibVZ5Um00Z2FHRnpJSFJvWlNCellXMWxJR1ZtWm1WamRDQmhjMXh1SUNBdkx5QmljbVZoYTJsdVp5QnZkWFFnYjJZZ2RHaGxJR1JwYzNCaGRHTm9JSE4zYVhSamFDQnpkR0YwWlcxbGJuUXVYRzRnSUhaaGNpQkRiMjUwYVc1MVpWTmxiblJwYm1Wc0lEMGdlMzA3WEc1Y2JpQWdMeThnUkhWdGJYa2dZMjl1YzNSeWRXTjBiM0lnWm5WdVkzUnBiMjV6SUhSb1lYUWdkMlVnZFhObElHRnpJSFJvWlNBdVkyOXVjM1J5ZFdOMGIzSWdZVzVrWEc0Z0lDOHZJQzVqYjI1emRISjFZM1J2Y2k1d2NtOTBiM1I1Y0dVZ2NISnZjR1Z5ZEdsbGN5Qm1iM0lnWm5WdVkzUnBiMjV6SUhSb1lYUWdjbVYwZFhKdUlFZGxibVZ5WVhSdmNseHVJQ0F2THlCdlltcGxZM1J6TGlCR2IzSWdablZzYkNCemNHVmpJR052YlhCc2FXRnVZMlVzSUhsdmRTQnRZWGtnZDJsemFDQjBieUJqYjI1bWFXZDFjbVVnZVc5MWNseHVJQ0F2THlCdGFXNXBabWxsY2lCdWIzUWdkRzhnYldGdVoyeGxJSFJvWlNCdVlXMWxjeUJ2WmlCMGFHVnpaU0IwZDI4Z1puVnVZM1JwYjI1ekxseHVJQ0JtZFc1amRHbHZiaUJIWlc1bGNtRjBiM0lvS1NCN2ZWeHVJQ0JtZFc1amRHbHZiaUJIWlc1bGNtRjBiM0pHZFc1amRHbHZiaWdwSUh0OVhHNGdJR1oxYm1OMGFXOXVJRWRsYm1WeVlYUnZja1oxYm1OMGFXOXVVSEp2ZEc5MGVYQmxLQ2tnZTMxY2JseHVJQ0IyWVhJZ1IzQWdQU0JIWlc1bGNtRjBiM0pHZFc1amRHbHZibEJ5YjNSdmRIbHdaUzV3Y205MGIzUjVjR1VnUFNCSFpXNWxjbUYwYjNJdWNISnZkRzkwZVhCbE8xeHVJQ0JIWlc1bGNtRjBiM0pHZFc1amRHbHZiaTV3Y205MGIzUjVjR1VnUFNCSGNDNWpiMjV6ZEhKMVkzUnZjaUE5SUVkbGJtVnlZWFJ2Y2taMWJtTjBhVzl1VUhKdmRHOTBlWEJsTzF4dUlDQkhaVzVsY21GMGIzSkdkVzVqZEdsdmJsQnliM1J2ZEhsd1pTNWpiMjV6ZEhKMVkzUnZjaUE5SUVkbGJtVnlZWFJ2Y2taMWJtTjBhVzl1TzF4dUlDQkhaVzVsY21GMGIzSkdkVzVqZEdsdmJpNWthWE53YkdGNVRtRnRaU0E5SUZ3aVIyVnVaWEpoZEc5eVJuVnVZM1JwYjI1Y0lqdGNibHh1SUNBdkx5QklaV3h3WlhJZ1ptOXlJR1JsWm1sdWFXNW5JSFJvWlNBdWJtVjRkQ3dnTG5Sb2NtOTNMQ0JoYm1RZ0xuSmxkSFZ5YmlCdFpYUm9iMlJ6SUc5bUlIUm9aVnh1SUNBdkx5QkpkR1Z5WVhSdmNpQnBiblJsY21aaFkyVWdhVzRnZEdWeWJYTWdiMllnWVNCemFXNW5iR1VnTGw5cGJuWnZhMlVnYldWMGFHOWtMbHh1SUNCbWRXNWpkR2x2YmlCa1pXWnBibVZKZEdWeVlYUnZjazFsZEdodlpITW9jSEp2ZEc5MGVYQmxLU0I3WEc0Z0lDQWdXMXdpYm1WNGRGd2lMQ0JjSW5Sb2NtOTNYQ0lzSUZ3aWNtVjBkWEp1WENKZExtWnZja1ZoWTJnb1puVnVZM1JwYjI0Z0tHMWxkR2h2WkNrZ2UxeHVJQ0FnSUNBZ2NISnZkRzkwZVhCbFcyMWxkR2h2WkYwZ1BTQm1kVzVqZEdsdmJpQW9ZWEpuS1NCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbDlwYm5admEyVW9iV1YwYUc5a0xDQmhjbWNwTzF4dUlDQWdJQ0FnZlR0Y2JpQWdJQ0I5S1R0Y2JpQWdmVnh1WEc0Z0lISjFiblJwYldVdWFYTkhaVzVsY21GMGIzSkdkVzVqZEdsdmJpQTlJR1oxYm1OMGFXOXVJQ2huWlc1R2RXNHBJSHRjYmlBZ0lDQjJZWElnWTNSdmNpQTlJSFI1Y0dWdlppQm5aVzVHZFc0Z1BUMDlJRndpWm5WdVkzUnBiMjVjSWlBbUppQm5aVzVHZFc0dVkyOXVjM1J5ZFdOMGIzSTdYRzRnSUNBZ2NtVjBkWEp1SUdOMGIzSWdQeUJqZEc5eUlEMDlQU0JIWlc1bGNtRjBiM0pHZFc1amRHbHZiaUI4ZkZ4dUlDQWdJQzh2SUVadmNpQjBhR1VnYm1GMGFYWmxJRWRsYm1WeVlYUnZja1oxYm1OMGFXOXVJR052Ym5OMGNuVmpkRzl5TENCMGFHVWdZbVZ6ZENCM1pTQmpZVzVjYmlBZ0lDQXZMeUJrYnlCcGN5QjBieUJqYUdWamF5QnBkSE1nTG01aGJXVWdjSEp2Y0dWeWRIa3VYRzRnSUNBZ0tHTjBiM0l1WkdsemNHeGhlVTVoYldVZ2ZId2dZM1J2Y2k1dVlXMWxLU0E5UFQwZ1hDSkhaVzVsY21GMGIzSkdkVzVqZEdsdmJsd2lJRG9nWm1Gc2MyVTdYRzRnSUgwN1hHNWNiaUFnY25WdWRHbHRaUzV0WVhKcklEMGdablZ1WTNScGIyNGdLR2RsYmtaMWJpa2dlMXh1SUNBZ0lHZGxia1oxYmk1ZlgzQnliM1J2WDE4Z1BTQkhaVzVsY21GMGIzSkdkVzVqZEdsdmJsQnliM1J2ZEhsd1pUdGNiaUFnSUNCblpXNUdkVzR1Y0hKdmRHOTBlWEJsSUQwZ1gwOWlhbVZqZENSamNtVmhkR1VvUjNBcE8xeHVJQ0FnSUhKbGRIVnliaUJuWlc1R2RXNDdYRzRnSUgwN1hHNWNiaUFnTHk4Z1YybDBhR2x1SUhSb1pTQmliMlI1SUc5bUlHRnVlU0JoYzNsdVl5Qm1kVzVqZEdsdmJpd2dZR0YzWVdsMElIaGdJR2x6SUhSeVlXNXpabTl5YldWa0lIUnZYRzRnSUM4dklHQjVhV1ZzWkNCeVpXZGxibVZ5WVhSdmNsSjFiblJwYldVdVlYZHlZWEFvZUNsZ0xDQnpieUIwYUdGMElIUm9aU0J5ZFc1MGFXMWxJR05oYmlCMFpYTjBYRzRnSUM4dklHQjJZV3gxWlNCcGJuTjBZVzVqWlc5bUlFRjNZV2wwUVhKbmRXMWxiblJnSUhSdklHUmxkR1Z5YldsdVpTQnBaaUIwYUdVZ2VXbGxiR1JsWkNCMllXeDFaU0JwYzF4dUlDQXZMeUJ0WldGdWRDQjBieUJpWlNCaGQyRnBkR1ZrTGlCVGIyMWxJRzFoZVNCamIyNXphV1JsY2lCMGFHVWdibUZ0WlNCdlppQjBhR2x6SUcxbGRHaHZaQ0IwYjI5Y2JpQWdMeThnWTNWMFpYTjVMQ0JpZFhRZ2RHaGxlU0JoY21VZ1kzVnliWFZrWjJWdmJuTXVYRzRnSUhKMWJuUnBiV1V1WVhkeVlYQWdQU0JtZFc1amRHbHZiaUFvWVhKbktTQjdYRzRnSUNBZ2NtVjBkWEp1SUc1bGR5QkJkMkZwZEVGeVozVnRaVzUwS0dGeVp5azdYRzRnSUgwN1hHNWNiaUFnWm5WdVkzUnBiMjRnUVhkaGFYUkJjbWQxYldWdWRDaGhjbWNwSUh0Y2JpQWdJQ0IwYUdsekxtRnlaeUE5SUdGeVp6dGNiaUFnZlZ4dVhHNGdJR1oxYm1OMGFXOXVJRUZ6ZVc1alNYUmxjbUYwYjNJb1oyVnVaWEpoZEc5eUtTQjdYRzRnSUNBZ0x5OGdWR2hwY3lCcGJuWnZhMlVnWm5WdVkzUnBiMjRnYVhNZ2QzSnBkSFJsYmlCcGJpQmhJSE4wZVd4bElIUm9ZWFFnWVhOemRXMWxjeUJ6YjIxbFhHNGdJQ0FnTHk4Z1kyRnNiR2x1WnlCbWRXNWpkR2x2YmlBb2IzSWdVSEp2YldselpTa2dkMmxzYkNCb1lXNWtiR1VnWlhoalpYQjBhVzl1Y3k1Y2JpQWdJQ0JtZFc1amRHbHZiaUJwYm5admEyVW9iV1YwYUc5a0xDQmhjbWNwSUh0Y2JpQWdJQ0FnSUhaaGNpQnlaWE4xYkhRZ1BTQm5aVzVsY21GMGIzSmJiV1YwYUc5a1hTaGhjbWNwTzF4dUlDQWdJQ0FnZG1GeUlIWmhiSFZsSUQwZ2NtVnpkV3gwTG5aaGJIVmxPMXh1SUNBZ0lDQWdjbVYwZFhKdUlIWmhiSFZsSUdsdWMzUmhibU5sYjJZZ1FYZGhhWFJCY21kMWJXVnVkQ0EvSUY5UWNtOXRhWE5sTG5KbGMyOXNkbVVvZG1Gc2RXVXVZWEpuS1M1MGFHVnVLR2x1ZG05clpVNWxlSFFzSUdsdWRtOXJaVlJvY205M0tTQTZJRjlRY205dGFYTmxMbkpsYzI5c2RtVW9kbUZzZFdVcExuUm9aVzRvWm5WdVkzUnBiMjRnS0hWdWQzSmhjSEJsWkNrZ2UxeHVJQ0FnSUNBZ0lDQXZMeUJYYUdWdUlHRWdlV2xsYkdSbFpDQlFjbTl0YVhObElHbHpJSEpsYzI5c2RtVmtMQ0JwZEhNZ1ptbHVZV3dnZG1Gc2RXVWdZbVZqYjIxbGMxeHVJQ0FnSUNBZ0lDQXZMeUIwYUdVZ0xuWmhiSFZsSUc5bUlIUm9aU0JRY205dGFYTmxQSHQyWVd4MVpTeGtiMjVsZlQ0Z2NtVnpkV3gwSUdadmNpQjBhR1ZjYmlBZ0lDQWdJQ0FnTHk4Z1kzVnljbVZ1ZENCcGRHVnlZWFJwYjI0dUlFbG1JSFJvWlNCUWNtOXRhWE5sSUdseklISmxhbVZqZEdWa0xDQm9iM2RsZG1WeUxDQjBhR1ZjYmlBZ0lDQWdJQ0FnTHk4Z2NtVnpkV3gwSUdadmNpQjBhR2x6SUdsMFpYSmhkR2x2YmlCM2FXeHNJR0psSUhKbGFtVmpkR1ZrSUhkcGRHZ2dkR2hsSUhOaGJXVmNiaUFnSUNBZ0lDQWdMeThnY21WaGMyOXVMaUJPYjNSbElIUm9ZWFFnY21WcVpXTjBhVzl1Y3lCdlppQjVhV1ZzWkdWa0lGQnliMjFwYzJWeklHRnlaU0J1YjNSY2JpQWdJQ0FnSUNBZ0x5OGdkR2h5YjNkdUlHSmhZMnNnYVc1MGJ5QjBhR1VnWjJWdVpYSmhkRzl5SUdaMWJtTjBhVzl1TENCaGN5QnBjeUIwYUdVZ1kyRnpaVnh1SUNBZ0lDQWdJQ0F2THlCM2FHVnVJR0Z1SUdGM1lXbDBaV1FnVUhKdmJXbHpaU0JwY3lCeVpXcGxZM1JsWkM0Z1ZHaHBjeUJrYVdabVpYSmxibU5sSUdsdVhHNGdJQ0FnSUNBZ0lDOHZJR0psYUdGMmFXOXlJR0psZEhkbFpXNGdlV2xsYkdRZ1lXNWtJR0YzWVdsMElHbHpJR2x0Y0c5eWRHRnVkQ3dnWW1WallYVnpaU0JwZEZ4dUlDQWdJQ0FnSUNBdkx5QmhiR3h2ZDNNZ2RHaGxJR052Ym5OMWJXVnlJSFJ2SUdSbFkybGtaU0IzYUdGMElIUnZJR1J2SUhkcGRHZ2dkR2hsSUhscFpXeGtaV1JjYmlBZ0lDQWdJQ0FnTHk4Z2NtVnFaV04wYVc5dUlDaHpkMkZzYkc5M0lHbDBJR0Z1WkNCamIyNTBhVzUxWlN3Z2JXRnVkV0ZzYkhrZ0xuUm9jbTkzSUdsMElHSmhZMnRjYmlBZ0lDQWdJQ0FnTHk4Z2FXNTBieUIwYUdVZ1oyVnVaWEpoZEc5eUxDQmhZbUZ1Wkc5dUlHbDBaWEpoZEdsdmJpd2dkMmhoZEdWMlpYSXBMaUJYYVhSb1hHNGdJQ0FnSUNBZ0lDOHZJR0YzWVdsMExDQmllU0JqYjI1MGNtRnpkQ3dnZEdobGNtVWdhWE1nYm04Z2IzQndiM0owZFc1cGRIa2dkRzhnWlhoaGJXbHVaU0IwYUdWY2JpQWdJQ0FnSUNBZ0x5OGdjbVZxWldOMGFXOXVJSEpsWVhOdmJpQnZkWFJ6YVdSbElIUm9aU0JuWlc1bGNtRjBiM0lnWm5WdVkzUnBiMjRzSUhOdklIUm9aVnh1SUNBZ0lDQWdJQ0F2THlCdmJteDVJRzl3ZEdsdmJpQnBjeUIwYnlCMGFISnZkeUJwZENCbWNtOXRJSFJvWlNCaGQyRnBkQ0JsZUhCeVpYTnphVzl1TENCaGJtUmNiaUFnSUNBZ0lDQWdMeThnYkdWMElIUm9aU0JuWlc1bGNtRjBiM0lnWm5WdVkzUnBiMjRnYUdGdVpHeGxJSFJvWlNCbGVHTmxjSFJwYjI0dVhHNGdJQ0FnSUNBZ0lISmxjM1ZzZEM1MllXeDFaU0E5SUhWdWQzSmhjSEJsWkR0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhKbGMzVnNkRHRjYmlBZ0lDQWdJSDBwTzF4dUlDQWdJSDFjYmx4dUlDQWdJR2xtSUNoMGVYQmxiMllnY0hKdlkyVnpjeUE5UFQwZ1hDSnZZbXBsWTNSY0lpQW1KaUJ3Y205alpYTnpMbVJ2YldGcGJpa2dlMXh1SUNBZ0lDQWdhVzUyYjJ0bElEMGdjSEp2WTJWemN5NWtiMjFoYVc0dVltbHVaQ2hwYm5admEyVXBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lIWmhjaUJwYm5admEyVk9aWGgwSUQwZ2FXNTJiMnRsTG1KcGJtUW9aMlZ1WlhKaGRHOXlMQ0JjSW01bGVIUmNJaWs3WEc0Z0lDQWdkbUZ5SUdsdWRtOXJaVlJvY205M0lEMGdhVzUyYjJ0bExtSnBibVFvWjJWdVpYSmhkRzl5TENCY0luUm9jbTkzWENJcE8xeHVJQ0FnSUhaaGNpQnBiblp2YTJWU1pYUjFjbTRnUFNCcGJuWnZhMlV1WW1sdVpDaG5aVzVsY21GMGIzSXNJRndpY21WMGRYSnVYQ0lwTzF4dUlDQWdJSFpoY2lCd2NtVjJhVzkxYzFCeWIyMXBjMlU3WEc1Y2JpQWdJQ0JtZFc1amRHbHZiaUJsYm5GMVpYVmxLRzFsZEdodlpDd2dZWEpuS1NCN1hHNGdJQ0FnSUNCMllYSWdaVzV4ZFdWMVpWSmxjM1ZzZENBOVhHNGdJQ0FnSUNBdkx5QkpaaUJsYm5GMVpYVmxJR2hoY3lCaVpXVnVJR05oYkd4bFpDQmlaV1p2Y21Vc0lIUm9aVzRnZDJVZ2QyRnVkQ0IwYnlCM1lXbDBJSFZ1ZEdsc1hHNGdJQ0FnSUNBdkx5QmhiR3dnY0hKbGRtbHZkWE1nVUhKdmJXbHpaWE1nYUdGMlpTQmlaV1Z1SUhKbGMyOXNkbVZrSUdKbFptOXlaU0JqWVd4c2FXNW5JR2x1ZG05clpTeGNiaUFnSUNBZ0lDOHZJSE52SUhSb1lYUWdjbVZ6ZFd4MGN5QmhjbVVnWVd4M1lYbHpJR1JsYkdsMlpYSmxaQ0JwYmlCMGFHVWdZMjl5Y21WamRDQnZjbVJsY2k0Z1NXWmNiaUFnSUNBZ0lDOHZJR1Z1Y1hWbGRXVWdhR0Z6SUc1dmRDQmlaV1Z1SUdOaGJHeGxaQ0JpWldadmNtVXNJSFJvWlc0Z2FYUWdhWE1nYVcxd2IzSjBZVzUwSUhSdlhHNGdJQ0FnSUNBdkx5QmpZV3hzSUdsdWRtOXJaU0JwYlcxbFpHbGhkR1ZzZVN3Z2QybDBhRzkxZENCM1lXbDBhVzVuSUc5dUlHRWdZMkZzYkdKaFkyc2dkRzhnWm1seVpTeGNiaUFnSUNBZ0lDOHZJSE52SUhSb1lYUWdkR2hsSUdGemVXNWpJR2RsYm1WeVlYUnZjaUJtZFc1amRHbHZiaUJvWVhNZ2RHaGxJRzl3Y0c5eWRIVnVhWFI1SUhSdklHUnZYRzRnSUNBZ0lDQXZMeUJoYm5rZ2JtVmpaWE56WVhKNUlITmxkSFZ3SUdsdUlHRWdjSEpsWkdsamRHRmliR1VnZDJGNUxpQlVhR2x6SUhCeVpXUnBZM1JoWW1sc2FYUjVYRzRnSUNBZ0lDQXZMeUJwY3lCM2FIa2dkR2hsSUZCeWIyMXBjMlVnWTI5dWMzUnlkV04wYjNJZ2MzbHVZMmh5YjI1dmRYTnNlU0JwYm5admEyVnpJR2wwYzF4dUlDQWdJQ0FnTHk4Z1pYaGxZM1YwYjNJZ1kyRnNiR0poWTJzc0lHRnVaQ0IzYUhrZ1lYTjVibU1nWm5WdVkzUnBiMjV6SUhONWJtTm9jbTl1YjNWemJIbGNiaUFnSUNBZ0lDOHZJR1Y0WldOMWRHVWdZMjlrWlNCaVpXWnZjbVVnZEdobElHWnBjbk4wSUdGM1lXbDBMaUJUYVc1alpTQjNaU0JwYlhCc1pXMWxiblFnYzJsdGNHeGxYRzRnSUNBZ0lDQXZMeUJoYzNsdVl5Qm1kVzVqZEdsdmJuTWdhVzRnZEdWeWJYTWdiMllnWVhONWJtTWdaMlZ1WlhKaGRHOXljeXdnYVhRZ2FYTWdaWE53WldOcFlXeHNlVnh1SUNBZ0lDQWdMeThnYVcxd2IzSjBZVzUwSUhSdklHZGxkQ0IwYUdseklISnBaMmgwTENCbGRtVnVJSFJvYjNWbmFDQnBkQ0J5WlhGMWFYSmxjeUJqWVhKbExseHVJQ0FnSUNBZ2NISmxkbWx2ZFhOUWNtOXRhWE5sSUQ4Z2NISmxkbWx2ZFhOUWNtOXRhWE5sTG5Sb1pXNG9ablZ1WTNScGIyNGdLQ2tnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnYVc1MmIydGxLRzFsZEdodlpDd2dZWEpuS1R0Y2JpQWdJQ0FnSUgwcElEb2dibVYzSUY5UWNtOXRhWE5sS0daMWJtTjBhVzl1SUNoeVpYTnZiSFpsS1NCN1hHNGdJQ0FnSUNBZ0lISmxjMjlzZG1Vb2FXNTJiMnRsS0cxbGRHaHZaQ3dnWVhKbktTazdYRzRnSUNBZ0lDQjlLVHRjYmx4dUlDQWdJQ0FnTHk4Z1FYWnZhV1FnY0hKdmNHRm5ZWFJwYm1jZ1pXNXhkV1YxWlZKbGMzVnNkQ0JtWVdsc2RYSmxjeUIwYnlCUWNtOXRhWE5sY3lCeVpYUjFjbTVsWkNCaWVWeHVJQ0FnSUNBZ0x5OGdiR0YwWlhJZ2FXNTJiMk5oZEdsdmJuTWdiMllnZEdobElHbDBaWEpoZEc5eUxseHVJQ0FnSUNBZ2NISmxkbWx2ZFhOUWNtOXRhWE5sSUQwZ1pXNXhkV1YxWlZKbGMzVnNkRnRjSW1OaGRHTm9YQ0pkS0daMWJtTjBhVzl1SUNocFoyNXZjbVZrS1NCN2ZTazdYRzVjYmlBZ0lDQWdJSEpsZEhWeWJpQmxibkYxWlhWbFVtVnpkV3gwTzF4dUlDQWdJSDFjYmx4dUlDQWdJQzh2SUVSbFptbHVaU0IwYUdVZ2RXNXBabWxsWkNCb1pXeHdaWElnYldWMGFHOWtJSFJvWVhRZ2FYTWdkWE5sWkNCMGJ5QnBiWEJzWlcxbGJuUWdMbTVsZUhRc1hHNGdJQ0FnTHk4Z0xuUm9jbTkzTENCaGJtUWdMbkpsZEhWeWJpQW9jMlZsSUdSbFptbHVaVWwwWlhKaGRHOXlUV1YwYUc5a2N5a3VYRzRnSUNBZ2RHaHBjeTVmYVc1MmIydGxJRDBnWlc1eGRXVjFaVHRjYmlBZ2ZWeHVYRzRnSUdSbFptbHVaVWwwWlhKaGRHOXlUV1YwYUc5a2N5aEJjM2x1WTBsMFpYSmhkRzl5TG5CeWIzUnZkSGx3WlNrN1hHNWNiaUFnTHk4Z1RtOTBaU0IwYUdGMElITnBiWEJzWlNCaGMzbHVZeUJtZFc1amRHbHZibk1nWVhKbElHbHRjR3hsYldWdWRHVmtJRzl1SUhSdmNDQnZabHh1SUNBdkx5QkJjM2x1WTBsMFpYSmhkRzl5SUc5aWFtVmpkSE03SUhSb1pYa2dhblZ6ZENCeVpYUjFjbTRnWVNCUWNtOXRhWE5sSUdadmNpQjBhR1VnZG1Gc2RXVWdiMlpjYmlBZ0x5OGdkR2hsSUdacGJtRnNJSEpsYzNWc2RDQndjbTlrZFdObFpDQmllU0IwYUdVZ2FYUmxjbUYwYjNJdVhHNGdJSEoxYm5ScGJXVXVZWE41Ym1NZ1BTQm1kVzVqZEdsdmJpQW9hVzV1WlhKR2Jpd2diM1YwWlhKR2Jpd2djMlZzWml3Z2RISjVURzlqYzB4cGMzUXBJSHRjYmlBZ0lDQjJZWElnYVhSbGNpQTlJRzVsZHlCQmMzbHVZMGwwWlhKaGRHOXlLSGR5WVhBb2FXNXVaWEpHYml3Z2IzVjBaWEpHYml3Z2MyVnNaaXdnZEhKNVRHOWpjMHhwYzNRcEtUdGNibHh1SUNBZ0lISmxkSFZ5YmlCeWRXNTBhVzFsTG1selIyVnVaWEpoZEc5eVJuVnVZM1JwYjI0b2IzVjBaWEpHYmlrZ1B5QnBkR1Z5SUM4dklFbG1JRzkxZEdWeVJtNGdhWE1nWVNCblpXNWxjbUYwYjNJc0lISmxkSFZ5YmlCMGFHVWdablZzYkNCcGRHVnlZWFJ2Y2k1Y2JpQWdJQ0E2SUdsMFpYSXVibVY0ZENncExuUm9aVzRvWm5WdVkzUnBiMjRnS0hKbGMzVnNkQ2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJSEpsYzNWc2RDNWtiMjVsSUQ4Z2NtVnpkV3gwTG5aaGJIVmxJRG9nYVhSbGNpNXVaWGgwS0NrN1hHNGdJQ0FnZlNrN1hHNGdJSDA3WEc1Y2JpQWdablZ1WTNScGIyNGdiV0ZyWlVsdWRtOXJaVTFsZEdodlpDaHBibTVsY2tadUxDQnpaV3htTENCamIyNTBaWGgwS1NCN1hHNGdJQ0FnZG1GeUlITjBZWFJsSUQwZ1IyVnVVM1JoZEdWVGRYTndaVzVrWldSVGRHRnlkRHRjYmx4dUlDQWdJSEpsZEhWeWJpQm1kVzVqZEdsdmJpQnBiblp2YTJVb2JXVjBhRzlrTENCaGNtY3BJSHRjYmlBZ0lDQWdJR2xtSUNoemRHRjBaU0E5UFQwZ1IyVnVVM1JoZEdWRmVHVmpkWFJwYm1jcElIdGNiaUFnSUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtGd2lSMlZ1WlhKaGRHOXlJR2x6SUdGc2NtVmhaSGtnY25WdWJtbHVaMXdpS1R0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2FXWWdLSE4wWVhSbElEMDlQU0JIWlc1VGRHRjBaVU52YlhCc1pYUmxaQ2tnZTF4dUlDQWdJQ0FnSUNCcFppQW9iV1YwYUc5a0lEMDlQU0JjSW5Sb2NtOTNYQ0lwSUh0Y2JpQWdJQ0FnSUNBZ0lDQjBhSEp2ZHlCaGNtYzdYRzRnSUNBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnSUNBdkx5QkNaU0JtYjNKbmFYWnBibWNzSUhCbGNpQXlOUzR6TGpNdU15NHpJRzltSUhSb1pTQnpjR1ZqT2x4dUlDQWdJQ0FnSUNBdkx5Qm9kSFJ3Y3pvdkwzQmxiM0JzWlM1dGIzcHBiR3hoTG05eVp5OSthbTl5Wlc1a2IzSm1aaTlsY3pZdFpISmhablF1YUhSdGJDTnpaV010WjJWdVpYSmhkRzl5Y21WemRXMWxYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmtiMjVsVW1WemRXeDBLQ2s3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUhkb2FXeGxJQ2gwY25WbEtTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCa1pXeGxaMkYwWlNBOUlHTnZiblJsZUhRdVpHVnNaV2RoZEdVN1hHNGdJQ0FnSUNBZ0lHbG1JQ2hrWld4bFoyRjBaU2tnZTF4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2h0WlhSb2IyUWdQVDA5SUZ3aWNtVjBkWEp1WENJZ2ZId2diV1YwYUc5a0lEMDlQU0JjSW5Sb2NtOTNYQ0lnSmlZZ1pHVnNaV2RoZEdVdWFYUmxjbUYwYjNKYmJXVjBhRzlrWFNBOVBUMGdkVzVrWldacGJtVmtLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQXZMeUJCSUhKbGRIVnliaUJ2Y2lCMGFISnZkeUFvZDJobGJpQjBhR1VnWkdWc1pXZGhkR1VnYVhSbGNtRjBiM0lnYUdGeklHNXZJSFJvY205M1hHNGdJQ0FnSUNBZ0lDQWdJQ0F2THlCdFpYUm9iMlFwSUdGc2QyRjVjeUIwWlhKdGFXNWhkR1Z6SUhSb1pTQjVhV1ZzWkNvZ2JHOXZjQzVjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZiblJsZUhRdVpHVnNaV2RoZEdVZ1BTQnVkV3hzTzF4dVhHNGdJQ0FnSUNBZ0lDQWdJQ0F2THlCSlppQjBhR1VnWkdWc1pXZGhkR1VnYVhSbGNtRjBiM0lnYUdGeklHRWdjbVYwZFhKdUlHMWxkR2h2WkN3Z1oybDJaU0JwZENCaFhHNGdJQ0FnSUNBZ0lDQWdJQ0F2THlCamFHRnVZMlVnZEc4Z1kyeGxZVzRnZFhBdVhHNGdJQ0FnSUNBZ0lDQWdJQ0IyWVhJZ2NtVjBkWEp1VFdWMGFHOWtJRDBnWkdWc1pXZGhkR1V1YVhSbGNtRjBiM0piWENKeVpYUjFjbTVjSWwwN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2NtVjBkWEp1VFdWMGFHOWtLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJSFpoY2lCeVpXTnZjbVFnUFNCMGNubERZWFJqYUNoeVpYUjFjbTVOWlhSb2IyUXNJR1JsYkdWbllYUmxMbWwwWlhKaGRHOXlMQ0JoY21jcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCcFppQW9jbVZqYjNKa0xuUjVjR1VnUFQwOUlGd2lkR2h5YjNkY0lpa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQzh2SUVsbUlIUm9aU0J5WlhSMWNtNGdiV1YwYUc5a0lIUm9jbVYzSUdGdUlHVjRZMlZ3ZEdsdmJpd2diR1YwSUhSb1lYUmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQXZMeUJsZUdObGNIUnBiMjRnY0hKbGRtRnBiQ0J2ZG1WeUlIUm9aU0J2Y21sbmFXNWhiQ0J5WlhSMWNtNGdiM0lnZEdoeWIzY3VYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdiV1YwYUc5a0lEMGdYQ0owYUhKdmQxd2lPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR0Z5WnlBOUlISmxZMjl5WkM1aGNtYzdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjl1ZEdsdWRXVTdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHMWxkR2h2WkNBOVBUMGdYQ0p5WlhSMWNtNWNJaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0F2THlCRGIyNTBhVzUxWlNCM2FYUm9JSFJvWlNCdmRYUmxjaUJ5WlhSMWNtNHNJRzV2ZHlCMGFHRjBJSFJvWlNCa1pXeGxaMkYwWlZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0F2THlCcGRHVnlZWFJ2Y2lCb1lYTWdZbVZsYmlCMFpYSnRhVzVoZEdWa0xseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyNTBhVzUxWlR0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdJQ0IyWVhJZ2NtVmpiM0prSUQwZ2RISjVRMkYwWTJnb1pHVnNaV2RoZEdVdWFYUmxjbUYwYjNKYmJXVjBhRzlrWFN3Z1pHVnNaV2RoZEdVdWFYUmxjbUYwYjNJc0lHRnlaeWs3WEc1Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvY21WamIzSmtMblI1Y0dVZ1BUMDlJRndpZEdoeWIzZGNJaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1ZEdWNGRDNWtaV3hsWjJGMFpTQTlJRzUxYkd3N1hHNWNiaUFnSUNBZ0lDQWdJQ0FnSUM4dklFeHBhMlVnY21WMGRYSnVhVzVuSUdkbGJtVnlZWFJ2Y2k1MGFISnZkeWgxYm1OaGRXZG9kQ2tzSUdKMWRDQjNhWFJvYjNWMElIUm9aVnh1SUNBZ0lDQWdJQ0FnSUNBZ0x5OGdiM1psY21obFlXUWdiMllnWVc0Z1pYaDBjbUVnWm5WdVkzUnBiMjRnWTJGc2JDNWNiaUFnSUNBZ0lDQWdJQ0FnSUcxbGRHaHZaQ0E5SUZ3aWRHaHliM2RjSWp0Y2JpQWdJQ0FnSUNBZ0lDQWdJR0Z5WnlBOUlISmxZMjl5WkM1aGNtYzdYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNTBhVzUxWlR0Y2JpQWdJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnSUNBdkx5QkVaV3hsWjJGMFpTQm5aVzVsY21GMGIzSWdjbUZ1SUdGdVpDQm9ZVzVrYkdWa0lHbDBjeUJ2ZDI0Z1pYaGpaWEIwYVc5dWN5QnpiMXh1SUNBZ0lDQWdJQ0FnSUM4dklISmxaMkZ5Wkd4bGMzTWdiMllnZDJoaGRDQjBhR1VnYldWMGFHOWtJSGRoY3l3Z2QyVWdZMjl1ZEdsdWRXVWdZWE1nYVdZZ2FYUWdhWE5jYmlBZ0lDQWdJQ0FnSUNBdkx5QmNJbTVsZUhSY0lpQjNhWFJvSUdGdUlIVnVaR1ZtYVc1bFpDQmhjbWN1WEc0Z0lDQWdJQ0FnSUNBZ2JXVjBhRzlrSUQwZ1hDSnVaWGgwWENJN1hHNGdJQ0FnSUNBZ0lDQWdZWEpuSUQwZ2RXNWtaV1pwYm1Wa08xeHVYRzRnSUNBZ0lDQWdJQ0FnZG1GeUlHbHVabThnUFNCeVpXTnZjbVF1WVhKbk8xeHVJQ0FnSUNBZ0lDQWdJR2xtSUNocGJtWnZMbVJ2Ym1VcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmJuUmxlSFJiWkdWc1pXZGhkR1V1Y21WemRXeDBUbUZ0WlYwZ1BTQnBibVp2TG5aaGJIVmxPMXh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVkR1Y0ZEM1dVpYaDBJRDBnWkdWc1pXZGhkR1V1Ym1WNGRFeHZZenRjYmlBZ0lDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdjM1JoZEdVZ1BTQkhaVzVUZEdGMFpWTjFjM0JsYm1SbFpGbHBaV3hrTzF4dUlDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlHbHVabTg3WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQWdJQ0FnWTI5dWRHVjRkQzVrWld4bFoyRjBaU0E5SUc1MWJHdzdYRzRnSUNBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnSUNCcFppQW9iV1YwYUc5a0lEMDlQU0JjSW01bGVIUmNJaWtnZTF4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2h6ZEdGMFpTQTlQVDBnUjJWdVUzUmhkR1ZUZFhOd1pXNWtaV1JaYVdWc1pDa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVkR1Y0ZEM1elpXNTBJRDBnWVhKbk8xeHVJQ0FnSUNBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNTBaWGgwTG5ObGJuUWdQU0IxYm1SbFptbHVaV1E3WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLRzFsZEdodlpDQTlQVDBnWENKMGFISnZkMXdpS1NCN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0hOMFlYUmxJRDA5UFNCSFpXNVRkR0YwWlZOMWMzQmxibVJsWkZOMFlYSjBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnpkR0YwWlNBOUlFZGxibE4wWVhSbFEyOXRjR3hsZEdWa08xeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdoeWIzY2dZWEpuTzF4dUlDQWdJQ0FnSUNBZ0lIMWNibHh1SUNBZ0lDQWdJQ0FnSUdsbUlDaGpiMjUwWlhoMExtUnBjM0JoZEdOb1JYaGpaWEIwYVc5dUtHRnlaeWtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQzh2SUVsbUlIUm9aU0JrYVhOd1lYUmphR1ZrSUdWNFkyVndkR2x2YmlCM1lYTWdZMkYxWjJoMElHSjVJR0VnWTJGMFkyZ2dZbXh2WTJzc1hHNGdJQ0FnSUNBZ0lDQWdJQ0F2THlCMGFHVnVJR3hsZENCMGFHRjBJR05oZEdOb0lHSnNiMk5ySUdoaGJtUnNaU0IwYUdVZ1pYaGpaWEIwYVc5dUlHNXZjbTFoYkd4NUxseHVJQ0FnSUNBZ0lDQWdJQ0FnYldWMGFHOWtJRDBnWENKdVpYaDBYQ0k3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmhjbWNnUFNCMWJtUmxabWx1WldRN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0cxbGRHaHZaQ0E5UFQwZ1hDSnlaWFIxY201Y0lpa2dlMXh1SUNBZ0lDQWdJQ0FnSUdOdmJuUmxlSFF1WVdKeWRYQjBLRndpY21WMGRYSnVYQ0lzSUdGeVp5azdYRzRnSUNBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnSUNCemRHRjBaU0E5SUVkbGJsTjBZWFJsUlhobFkzVjBhVzVuTzF4dVhHNGdJQ0FnSUNBZ0lIWmhjaUJ5WldOdmNtUWdQU0IwY25sRFlYUmphQ2hwYm01bGNrWnVMQ0J6Wld4bUxDQmpiMjUwWlhoMEtUdGNiaUFnSUNBZ0lDQWdhV1lnS0hKbFkyOXlaQzUwZVhCbElEMDlQU0JjSW01dmNtMWhiRndpS1NCN1hHNGdJQ0FnSUNBZ0lDQWdMeThnU1dZZ1lXNGdaWGhqWlhCMGFXOXVJR2x6SUhSb2NtOTNiaUJtY205dElHbHVibVZ5Um00c0lIZGxJR3hsWVhabElITjBZWFJsSUQwOVBWeHVJQ0FnSUNBZ0lDQWdJQzh2SUVkbGJsTjBZWFJsUlhobFkzVjBhVzVuSUdGdVpDQnNiMjl3SUdKaFkyc2dabTl5SUdGdWIzUm9aWElnYVc1MmIyTmhkR2x2Ymk1Y2JpQWdJQ0FnSUNBZ0lDQnpkR0YwWlNBOUlHTnZiblJsZUhRdVpHOXVaU0EvSUVkbGJsTjBZWFJsUTI5dGNHeGxkR1ZrSURvZ1IyVnVVM1JoZEdWVGRYTndaVzVrWldSWmFXVnNaRHRjYmx4dUlDQWdJQ0FnSUNBZ0lIWmhjaUJwYm1adklEMGdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2RtRnNkV1U2SUhKbFkyOXlaQzVoY21jc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JrYjI1bE9pQmpiMjUwWlhoMExtUnZibVZjYmlBZ0lDQWdJQ0FnSUNCOU8xeHVYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tISmxZMjl5WkM1aGNtY2dQVDA5SUVOdmJuUnBiblZsVTJWdWRHbHVaV3dwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoamIyNTBaWGgwTG1SbGJHVm5ZWFJsSUNZbUlHMWxkR2h2WkNBOVBUMGdYQ0p1WlhoMFhDSXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdMeThnUkdWc2FXSmxjbUYwWld4NUlHWnZjbWRsZENCMGFHVWdiR0Z6ZENCelpXNTBJSFpoYkhWbElITnZJSFJvWVhRZ2QyVWdaRzl1SjNSY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnTHk4Z1lXTmphV1JsYm5SaGJHeDVJSEJoYzNNZ2FYUWdiMjRnZEc4Z2RHaGxJR1JsYkdWbllYUmxMbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQmhjbWNnUFNCMWJtUmxabWx1WldRN1hHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQnBibVp2TzF4dUlDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdmU0JsYkhObElHbG1JQ2h5WldOdmNtUXVkSGx3WlNBOVBUMGdYQ0owYUhKdmQxd2lLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2MzUmhkR1VnUFNCSFpXNVRkR0YwWlVOdmJYQnNaWFJsWkR0Y2JpQWdJQ0FnSUNBZ0lDQXZMeUJFYVhOd1lYUmphQ0IwYUdVZ1pYaGpaWEIwYVc5dUlHSjVJR3h2YjNCcGJtY2dZbUZqYXlCaGNtOTFibVFnZEc4Z2RHaGxYRzRnSUNBZ0lDQWdJQ0FnTHk4Z1kyOXVkR1Y0ZEM1a2FYTndZWFJqYUVWNFkyVndkR2x2YmloaGNtY3BJR05oYkd3Z1lXSnZkbVV1WEc0Z0lDQWdJQ0FnSUNBZ2JXVjBhRzlrSUQwZ1hDSjBhSEp2ZDF3aU8xeHVJQ0FnSUNBZ0lDQWdJR0Z5WnlBOUlISmxZMjl5WkM1aGNtYzdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlPMXh1SUNCOVhHNWNiaUFnTHk4Z1JHVm1hVzVsSUVkbGJtVnlZWFJ2Y2k1d2NtOTBiM1I1Y0dVdWUyNWxlSFFzZEdoeWIzY3NjbVYwZFhKdWZTQnBiaUIwWlhKdGN5QnZaaUIwYUdWY2JpQWdMeThnZFc1cFptbGxaQ0F1WDJsdWRtOXJaU0JvWld4d1pYSWdiV1YwYUc5a0xseHVJQ0JrWldacGJtVkpkR1Z5WVhSdmNrMWxkR2h2WkhNb1IzQXBPMXh1WEc0Z0lFZHdXMmwwWlhKaGRHOXlVM2x0WW05c1hTQTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdkR2hwY3p0Y2JpQWdmVHRjYmx4dUlDQkhjQzUwYjFOMGNtbHVaeUE5SUdaMWJtTjBhVzl1SUNncElIdGNiaUFnSUNCeVpYUjFjbTRnWENKYmIySnFaV04wSUVkbGJtVnlZWFJ2Y2wxY0lqdGNiaUFnZlR0Y2JseHVJQ0JtZFc1amRHbHZiaUJ3ZFhOb1ZISjVSVzUwY25rb2JHOWpjeWtnZTF4dUlDQWdJSFpoY2lCbGJuUnllU0E5SUhzZ2RISjVURzlqT2lCc2IyTnpXekJkSUgwN1hHNWNiaUFnSUNCcFppQW9NU0JwYmlCc2IyTnpLU0I3WEc0Z0lDQWdJQ0JsYm5SeWVTNWpZWFJqYUV4dll5QTlJR3h2WTNOYk1WMDdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLRElnYVc0Z2JHOWpjeWtnZTF4dUlDQWdJQ0FnWlc1MGNua3VabWx1WVd4c2VVeHZZeUE5SUd4dlkzTmJNbDA3WEc0Z0lDQWdJQ0JsYm5SeWVTNWhablJsY2t4dll5QTlJR3h2WTNOYk0xMDdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2RHaHBjeTUwY25sRmJuUnlhV1Z6TG5CMWMyZ29aVzUwY25rcE8xeHVJQ0I5WEc1Y2JpQWdablZ1WTNScGIyNGdjbVZ6WlhSVWNubEZiblJ5ZVNobGJuUnllU2tnZTF4dUlDQWdJSFpoY2lCeVpXTnZjbVFnUFNCbGJuUnllUzVqYjIxd2JHVjBhVzl1SUh4OElIdDlPMXh1SUNBZ0lISmxZMjl5WkM1MGVYQmxJRDBnWENKdWIzSnRZV3hjSWp0Y2JpQWdJQ0JrWld4bGRHVWdjbVZqYjNKa0xtRnlaenRjYmlBZ0lDQmxiblJ5ZVM1amIyMXdiR1YwYVc5dUlEMGdjbVZqYjNKa08xeHVJQ0I5WEc1Y2JpQWdablZ1WTNScGIyNGdRMjl1ZEdWNGRDaDBjbmxNYjJOelRHbHpkQ2tnZTF4dUlDQWdJQzh2SUZSb1pTQnliMjkwSUdWdWRISjVJRzlpYW1WamRDQW9aV1ptWldOMGFYWmxiSGtnWVNCMGNua2djM1JoZEdWdFpXNTBJSGRwZEdodmRYUWdZU0JqWVhSamFGeHVJQ0FnSUM4dklHOXlJR0VnWm1sdVlXeHNlU0JpYkc5amF5a2daMmwyWlhNZ2RYTWdZU0J3YkdGalpTQjBieUJ6ZEc5eVpTQjJZV3gxWlhNZ2RHaHliM2R1SUdaeWIyMWNiaUFnSUNBdkx5QnNiMk5oZEdsdmJuTWdkMmhsY21VZ2RHaGxjbVVnYVhNZ2JtOGdaVzVqYkc5emFXNW5JSFJ5ZVNCemRHRjBaVzFsYm5RdVhHNGdJQ0FnZEdocGN5NTBjbmxGYm5SeWFXVnpJRDBnVzNzZ2RISjVURzlqT2lCY0luSnZiM1JjSWlCOVhUdGNiaUFnSUNCMGNubE1iMk56VEdsemRDNW1iM0pGWVdOb0tIQjFjMmhVY25sRmJuUnllU3dnZEdocGN5azdYRzRnSUNBZ2RHaHBjeTV5WlhObGRDaDBjblZsS1R0Y2JpQWdmVnh1WEc0Z0lISjFiblJwYldVdWEyVjVjeUE5SUdaMWJtTjBhVzl1SUNodlltcGxZM1FwSUh0Y2JpQWdJQ0IyWVhJZ2EyVjVjeUE5SUZ0ZE8xeHVJQ0FnSUdadmNpQW9kbUZ5SUd0bGVTQnBiaUJ2WW1wbFkzUXBJSHRjYmlBZ0lDQWdJR3RsZVhNdWNIVnphQ2hyWlhrcE8xeHVJQ0FnSUgxY2JpQWdJQ0JyWlhsekxuSmxkbVZ5YzJVb0tUdGNibHh1SUNBZ0lDOHZJRkpoZEdobGNpQjBhR0Z1SUhKbGRIVnlibWx1WnlCaGJpQnZZbXBsWTNRZ2QybDBhQ0JoSUc1bGVIUWdiV1YwYUc5a0xDQjNaU0JyWldWd1hHNGdJQ0FnTHk4Z2RHaHBibWR6SUhOcGJYQnNaU0JoYm1RZ2NtVjBkWEp1SUhSb1pTQnVaWGgwSUdaMWJtTjBhVzl1SUdsMGMyVnNaaTVjYmlBZ0lDQnlaWFIxY200Z1puVnVZM1JwYjI0Z2JtVjRkQ2dwSUh0Y2JpQWdJQ0FnSUhkb2FXeGxJQ2hyWlhsekxteGxibWQwYUNrZ2UxeHVJQ0FnSUNBZ0lDQjJZWElnYTJWNUlEMGdhMlY1Y3k1d2IzQW9LVHRjYmlBZ0lDQWdJQ0FnYVdZZ0tHdGxlU0JwYmlCdlltcGxZM1FwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnVaWGgwTG5aaGJIVmxJRDBnYTJWNU8xeHVJQ0FnSUNBZ0lDQWdJRzVsZUhRdVpHOXVaU0E5SUdaaGJITmxPMXh1SUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUJ1WlhoME8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQzh2SUZSdklHRjJiMmxrSUdOeVpXRjBhVzVuSUdGdUlHRmtaR2wwYVc5dVlXd2diMkpxWldOMExDQjNaU0JxZFhOMElHaGhibWNnZEdobElDNTJZV3gxWlZ4dUlDQWdJQ0FnTHk4Z1lXNWtJQzVrYjI1bElIQnliM0JsY25ScFpYTWdiMlptSUhSb1pTQnVaWGgwSUdaMWJtTjBhVzl1SUc5aWFtVmpkQ0JwZEhObGJHWXVJRlJvYVhOY2JpQWdJQ0FnSUM4dklHRnNjMjhnWlc1emRYSmxjeUIwYUdGMElIUm9aU0J0YVc1cFptbGxjaUIzYVd4c0lHNXZkQ0JoYm05dWVXMXBlbVVnZEdobElHWjFibU4wYVc5dUxseHVJQ0FnSUNBZ2JtVjRkQzVrYjI1bElEMGdkSEoxWlR0Y2JpQWdJQ0FnSUhKbGRIVnliaUJ1WlhoME8xeHVJQ0FnSUgwN1hHNGdJSDA3WEc1Y2JpQWdablZ1WTNScGIyNGdkbUZzZFdWektHbDBaWEpoWW14bEtTQjdYRzRnSUNBZ2FXWWdLR2wwWlhKaFlteGxLU0I3WEc0Z0lDQWdJQ0IyWVhJZ2FYUmxjbUYwYjNKTlpYUm9iMlFnUFNCcGRHVnlZV0pzWlZ0cGRHVnlZWFJ2Y2xONWJXSnZiRjA3WEc0Z0lDQWdJQ0JwWmlBb2FYUmxjbUYwYjNKTlpYUm9iMlFwSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUdsMFpYSmhkRzl5VFdWMGFHOWtMbU5oYkd3b2FYUmxjbUZpYkdVcE8xeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQnBaaUFvZEhsd1pXOW1JR2wwWlhKaFlteGxMbTVsZUhRZ1BUMDlJRndpWm5WdVkzUnBiMjVjSWlrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2FYUmxjbUZpYkdVN1hHNGdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lHbG1JQ2doYVhOT1lVNG9hWFJsY21GaWJHVXViR1Z1WjNSb0tTa2dlMXh1SUNBZ0lDQWdJQ0IyWVhJZ2FTQTlJQzB4TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdibVY0ZENBOUlHWjFibU4wYVc5dUlHNWxlSFFvS1NCN1hHNGdJQ0FnSUNBZ0lDQWdkMmhwYkdVZ0tDc3JhU0E4SUdsMFpYSmhZbXhsTG14bGJtZDBhQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdhV1lnS0doaGMwOTNiaTVqWVd4c0tHbDBaWEpoWW14bExDQnBLU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0J1WlhoMExuWmhiSFZsSUQwZ2FYUmxjbUZpYkdWYmFWMDdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lHNWxlSFF1Wkc5dVpTQTlJR1poYkhObE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnYm1WNGREdGNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnSUNCdVpYaDBMblpoYkhWbElEMGdkVzVrWldacGJtVmtPMXh1SUNBZ0lDQWdJQ0FnSUc1bGVIUXVaRzl1WlNBOUlIUnlkV1U3WEc1Y2JpQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2JtVjRkRHRjYmlBZ0lDQWdJQ0FnZlR0Y2JseHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2JtVjRkQzV1WlhoMElEMGdibVY0ZER0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2THlCU1pYUjFjbTRnWVc0Z2FYUmxjbUYwYjNJZ2QybDBhQ0J1YnlCMllXeDFaWE11WEc0Z0lDQWdjbVYwZFhKdUlIc2dibVY0ZERvZ1pHOXVaVkpsYzNWc2RDQjlPMXh1SUNCOVhHNGdJSEoxYm5ScGJXVXVkbUZzZFdWeklEMGdkbUZzZFdWek8xeHVYRzRnSUdaMWJtTjBhVzl1SUdSdmJtVlNaWE4xYkhRb0tTQjdYRzRnSUNBZ2NtVjBkWEp1SUhzZ2RtRnNkV1U2SUhWdVpHVm1hVzVsWkN3Z1pHOXVaVG9nZEhKMVpTQjlPMXh1SUNCOVhHNWNiaUFnUTI5dWRHVjRkQzV3Y205MGIzUjVjR1VnUFNCN1hHNGdJQ0FnWTI5dWMzUnlkV04wYjNJNklFTnZiblJsZUhRc1hHNWNiaUFnSUNCeVpYTmxkRG9nWm5WdVkzUnBiMjRnY21WelpYUW9jMnRwY0ZSbGJYQlNaWE5sZENrZ2UxeHVJQ0FnSUNBZ2RHaHBjeTV3Y21WMklEMGdNRHRjYmlBZ0lDQWdJSFJvYVhNdWJtVjRkQ0E5SURBN1hHNGdJQ0FnSUNCMGFHbHpMbk5sYm5RZ1BTQjFibVJsWm1sdVpXUTdYRzRnSUNBZ0lDQjBhR2x6TG1SdmJtVWdQU0JtWVd4elpUdGNiaUFnSUNBZ0lIUm9hWE11WkdWc1pXZGhkR1VnUFNCdWRXeHNPMXh1WEc0Z0lDQWdJQ0IwYUdsekxuUnllVVZ1ZEhKcFpYTXVabTl5UldGamFDaHlaWE5sZEZSeWVVVnVkSEo1S1R0Y2JseHVJQ0FnSUNBZ2FXWWdLQ0Z6YTJsd1ZHVnRjRkpsYzJWMEtTQjdYRzRnSUNBZ0lDQWdJR1p2Y2lBb2RtRnlJRzVoYldVZ2FXNGdkR2hwY3lrZ2UxeHVJQ0FnSUNBZ0lDQWdJQzh2SUU1dmRDQnpkWEpsSUdGaWIzVjBJSFJvWlNCdmNIUnBiV0ZzSUc5eVpHVnlJRzltSUhSb1pYTmxJR052Ym1ScGRHbHZibk02WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLRzVoYldVdVkyaGhja0YwS0RBcElEMDlQU0JjSW5SY0lpQW1KaUJvWVhOUGQyNHVZMkZzYkNoMGFHbHpMQ0J1WVcxbEtTQW1KaUFoYVhOT1lVNG9LMjVoYldVdWMyeHBZMlVvTVNrcEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpXMjVoYldWZElEMGdkVzVrWldacGJtVmtPMXh1SUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgwc1hHNWNiaUFnSUNCemRHOXdPaUJtZFc1amRHbHZiaUJ6ZEc5d0tDa2dlMXh1SUNBZ0lDQWdkR2hwY3k1a2IyNWxJRDBnZEhKMVpUdGNibHh1SUNBZ0lDQWdkbUZ5SUhKdmIzUkZiblJ5ZVNBOUlIUm9hWE11ZEhKNVJXNTBjbWxsYzFzd1hUdGNiaUFnSUNBZ0lIWmhjaUJ5YjI5MFVtVmpiM0prSUQwZ2NtOXZkRVZ1ZEhKNUxtTnZiWEJzWlhScGIyNDdYRzRnSUNBZ0lDQnBaaUFvY205dmRGSmxZMjl5WkM1MGVYQmxJRDA5UFNCY0luUm9jbTkzWENJcElIdGNiaUFnSUNBZ0lDQWdkR2h5YjNjZ2NtOXZkRkpsWTI5eVpDNWhjbWM3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxuSjJZV3c3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJR1JwYzNCaGRHTm9SWGhqWlhCMGFXOXVPaUJtZFc1amRHbHZiaUJrYVhOd1lYUmphRVY0WTJWd2RHbHZiaWhsZUdObGNIUnBiMjRwSUh0Y2JpQWdJQ0FnSUdsbUlDaDBhR2x6TG1SdmJtVXBJSHRjYmlBZ0lDQWdJQ0FnZEdoeWIzY2daWGhqWlhCMGFXOXVPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0IyWVhJZ1kyOXVkR1Y0ZENBOUlIUm9hWE03WEc0Z0lDQWdJQ0JtZFc1amRHbHZiaUJvWVc1a2JHVW9iRzlqTENCallYVm5hSFFwSUh0Y2JpQWdJQ0FnSUNBZ2NtVmpiM0prTG5SNWNHVWdQU0JjSW5Sb2NtOTNYQ0k3WEc0Z0lDQWdJQ0FnSUhKbFkyOXlaQzVoY21jZ1BTQmxlR05sY0hScGIyNDdYRzRnSUNBZ0lDQWdJR052Ym5SbGVIUXVibVY0ZENBOUlHeHZZenRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJQ0VoWTJGMVoyaDBPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ2RHaHBjeTUwY25sRmJuUnlhV1Z6TG14bGJtZDBhQ0F0SURFN0lHa2dQajBnTURzZ0xTMXBLU0I3WEc0Z0lDQWdJQ0FnSUhaaGNpQmxiblJ5ZVNBOUlIUm9hWE11ZEhKNVJXNTBjbWxsYzF0cFhUdGNiaUFnSUNBZ0lDQWdkbUZ5SUhKbFkyOXlaQ0E5SUdWdWRISjVMbU52YlhCc1pYUnBiMjQ3WEc1Y2JpQWdJQ0FnSUNBZ2FXWWdLR1Z1ZEhKNUxuUnllVXh2WXlBOVBUMGdYQ0p5YjI5MFhDSXBJSHRjYmlBZ0lDQWdJQ0FnSUNBdkx5QkZlR05sY0hScGIyNGdkR2h5YjNkdUlHOTFkSE5wWkdVZ2IyWWdZVzU1SUhSeWVTQmliRzlqYXlCMGFHRjBJR052ZFd4a0lHaGhibVJzWlZ4dUlDQWdJQ0FnSUNBZ0lDOHZJR2wwTENCemJ5QnpaWFFnZEdobElHTnZiWEJzWlhScGIyNGdkbUZzZFdVZ2IyWWdkR2hsSUdWdWRHbHlaU0JtZFc1amRHbHZiaUIwYjF4dUlDQWdJQ0FnSUNBZ0lDOHZJSFJvY205M0lIUm9aU0JsZUdObGNIUnBiMjR1WEc0Z0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUdoaGJtUnNaU2hjSW1WdVpGd2lLVHRjYmlBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lHbG1JQ2hsYm5SeWVTNTBjbmxNYjJNZ1BEMGdkR2hwY3k1d2NtVjJLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2RtRnlJR2hoYzBOaGRHTm9JRDBnYUdGelQzZHVMbU5oYkd3b1pXNTBjbmtzSUZ3aVkyRjBZMmhNYjJOY0lpazdYRzRnSUNBZ0lDQWdJQ0FnZG1GeUlHaGhjMFpwYm1Gc2JIa2dQU0JvWVhOUGQyNHVZMkZzYkNobGJuUnllU3dnWENKbWFXNWhiR3g1VEc5alhDSXBPMXh1WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLR2hoYzBOaGRHTm9JQ1ltSUdoaGMwWnBibUZzYkhrcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDaDBhR2x6TG5CeVpYWWdQQ0JsYm5SeWVTNWpZWFJqYUV4dll5a2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2FHRnVaR3hsS0dWdWRISjVMbU5oZEdOb1RHOWpMQ0IwY25WbEtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2RHaHBjeTV3Y21WMklEd2daVzUwY25rdVptbHVZV3hzZVV4dll5a2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2FHRnVaR3hsS0dWdWRISjVMbVpwYm1Gc2JIbE1iMk1wTzF4dUlDQWdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2FHRnpRMkYwWTJncElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDaDBhR2x6TG5CeVpYWWdQQ0JsYm5SeWVTNWpZWFJqYUV4dll5a2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2FHRnVaR3hsS0dWdWRISjVMbU5oZEdOb1RHOWpMQ0IwY25WbEtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLR2hoYzBacGJtRnNiSGtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoMGFHbHpMbkJ5WlhZZ1BDQmxiblJ5ZVM1bWFXNWhiR3g1VEc5aktTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCb1lXNWtiR1VvWlc1MGNua3VabWx1WVd4c2VVeHZZeWs3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2loY0luUnllU0J6ZEdGMFpXMWxiblFnZDJsMGFHOTFkQ0JqWVhSamFDQnZjaUJtYVc1aGJHeDVYQ0lwTzF4dUlDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1SUNBZ0lIMHNYRzVjYmlBZ0lDQmhZbkoxY0hRNklHWjFibU4wYVc5dUlHRmljblZ3ZENoMGVYQmxMQ0JoY21jcElIdGNiaUFnSUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0IwYUdsekxuUnllVVZ1ZEhKcFpYTXViR1Z1WjNSb0lDMGdNVHNnYVNBK1BTQXdPeUF0TFdrcElIdGNiaUFnSUNBZ0lDQWdkbUZ5SUdWdWRISjVJRDBnZEdocGN5NTBjbmxGYm5SeWFXVnpXMmxkTzF4dUlDQWdJQ0FnSUNCcFppQW9aVzUwY25rdWRISjVURzlqSUR3OUlIUm9hWE11Y0hKbGRpQW1KaUJvWVhOUGQyNHVZMkZzYkNobGJuUnllU3dnWENKbWFXNWhiR3g1VEc5alhDSXBJQ1ltSUhSb2FYTXVjSEpsZGlBOElHVnVkSEo1TG1acGJtRnNiSGxNYjJNcElIdGNiaUFnSUNBZ0lDQWdJQ0IyWVhJZ1ptbHVZV3hzZVVWdWRISjVJRDBnWlc1MGNuazdYRzRnSUNBZ0lDQWdJQ0FnWW5KbFlXczdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnYVdZZ0tHWnBibUZzYkhsRmJuUnllU0FtSmlBb2RIbHdaU0E5UFQwZ1hDSmljbVZoYTF3aUlIeDhJSFI1Y0dVZ1BUMDlJRndpWTI5dWRHbHVkV1ZjSWlrZ0ppWWdabWx1WVd4c2VVVnVkSEo1TG5SeWVVeHZZeUE4UFNCaGNtY2dKaVlnWVhKbklEdzlJR1pwYm1Gc2JIbEZiblJ5ZVM1bWFXNWhiR3g1VEc5aktTQjdYRzRnSUNBZ0lDQWdJQzh2SUVsbmJtOXlaU0IwYUdVZ1ptbHVZV3hzZVNCbGJuUnllU0JwWmlCamIyNTBjbTlzSUdseklHNXZkQ0JxZFcxd2FXNW5JSFJ2SUdGY2JpQWdJQ0FnSUNBZ0x5OGdiRzlqWVhScGIyNGdiM1YwYzJsa1pTQjBhR1VnZEhKNUwyTmhkR05vSUdKc2IyTnJMbHh1SUNBZ0lDQWdJQ0JtYVc1aGJHeDVSVzUwY25rZ1BTQnVkV3hzTzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCMllYSWdjbVZqYjNKa0lEMGdabWx1WVd4c2VVVnVkSEo1SUQ4Z1ptbHVZV3hzZVVWdWRISjVMbU52YlhCc1pYUnBiMjRnT2lCN2ZUdGNiaUFnSUNBZ0lISmxZMjl5WkM1MGVYQmxJRDBnZEhsd1pUdGNiaUFnSUNBZ0lISmxZMjl5WkM1aGNtY2dQU0JoY21jN1hHNWNiaUFnSUNBZ0lHbG1JQ2htYVc1aGJHeDVSVzUwY25rcElIdGNiaUFnSUNBZ0lDQWdkR2hwY3k1dVpYaDBJRDBnWm1sdVlXeHNlVVZ1ZEhKNUxtWnBibUZzYkhsTWIyTTdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TG1OdmJYQnNaWFJsS0hKbFkyOXlaQ2s3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUhKbGRIVnliaUJEYjI1MGFXNTFaVk5sYm5ScGJtVnNPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQmpiMjF3YkdWMFpUb2dablZ1WTNScGIyNGdZMjl0Y0d4bGRHVW9jbVZqYjNKa0xDQmhablJsY2t4dll5a2dlMXh1SUNBZ0lDQWdhV1lnS0hKbFkyOXlaQzUwZVhCbElEMDlQU0JjSW5Sb2NtOTNYQ0lwSUh0Y2JpQWdJQ0FnSUNBZ2RHaHliM2NnY21WamIzSmtMbUZ5Wnp0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2FXWWdLSEpsWTI5eVpDNTBlWEJsSUQwOVBTQmNJbUp5WldGclhDSWdmSHdnY21WamIzSmtMblI1Y0dVZ1BUMDlJRndpWTI5dWRHbHVkV1ZjSWlrZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TG01bGVIUWdQU0J5WldOdmNtUXVZWEpuTzF4dUlDQWdJQ0FnZlNCbGJITmxJR2xtSUNoeVpXTnZjbVF1ZEhsd1pTQTlQVDBnWENKeVpYUjFjbTVjSWlrZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TG5KMllXd2dQU0J5WldOdmNtUXVZWEpuTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbTVsZUhRZ1BTQmNJbVZ1WkZ3aU8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaHlaV052Y21RdWRIbHdaU0E5UFQwZ1hDSnViM0p0WVd4Y0lpQW1KaUJoWm5SbGNreHZZeWtnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbTVsZUhRZ1BTQmhablJsY2t4dll6dGNiaUFnSUNBZ0lIMWNiaUFnSUNCOUxGeHVYRzRnSUNBZ1ptbHVhWE5vT2lCbWRXNWpkR2x2YmlCbWFXNXBjMmdvWm1sdVlXeHNlVXh2WXlrZ2UxeHVJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ2FTQTlJSFJvYVhNdWRISjVSVzUwY21sbGN5NXNaVzVuZEdnZ0xTQXhPeUJwSUQ0OUlEQTdJQzB0YVNrZ2UxeHVJQ0FnSUNBZ0lDQjJZWElnWlc1MGNua2dQU0IwYUdsekxuUnllVVZ1ZEhKcFpYTmJhVjA3WEc0Z0lDQWdJQ0FnSUdsbUlDaGxiblJ5ZVM1bWFXNWhiR3g1VEc5aklEMDlQU0JtYVc1aGJHeDVURzlqS1NCN1hHNGdJQ0FnSUNBZ0lDQWdkR2hwY3k1amIyMXdiR1YwWlNobGJuUnllUzVqYjIxd2JHVjBhVzl1TENCbGJuUnllUzVoWm5SbGNreHZZeWs3WEc0Z0lDQWdJQ0FnSUNBZ2NtVnpaWFJVY25sRmJuUnllU2hsYm5SeWVTazdYRzRnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJRU52Ym5ScGJuVmxVMlZ1ZEdsdVpXdzdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdYQ0pqWVhSamFGd2lPaUJtZFc1amRHbHZiaUJmWTJGMFkyZ29kSEo1VEc5aktTQjdYRzRnSUNBZ0lDQm1iM0lnS0haaGNpQnBJRDBnZEdocGN5NTBjbmxGYm5SeWFXVnpMbXhsYm1kMGFDQXRJREU3SUdrZ1BqMGdNRHNnTFMxcEtTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCbGJuUnllU0E5SUhSb2FYTXVkSEo1Ulc1MGNtbGxjMXRwWFR0Y2JpQWdJQ0FnSUNBZ2FXWWdLR1Z1ZEhKNUxuUnllVXh2WXlBOVBUMGdkSEo1VEc5aktTQjdYRzRnSUNBZ0lDQWdJQ0FnZG1GeUlISmxZMjl5WkNBOUlHVnVkSEo1TG1OdmJYQnNaWFJwYjI0N1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0hKbFkyOXlaQzUwZVhCbElEMDlQU0JjSW5Sb2NtOTNYQ0lwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFpoY2lCMGFISnZkMjRnUFNCeVpXTnZjbVF1WVhKbk8xeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WelpYUlVjbmxGYm5SeWVTaGxiblJ5ZVNrN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUIwYUhKdmQyNDdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnTHk4Z1ZHaGxJR052Ym5SbGVIUXVZMkYwWTJnZ2JXVjBhRzlrSUcxMWMzUWdiMjVzZVNCaVpTQmpZV3hzWldRZ2QybDBhQ0JoSUd4dlkyRjBhVzl1WEc0Z0lDQWdJQ0F2THlCaGNtZDFiV1Z1ZENCMGFHRjBJR052Y25KbGMzQnZibVJ6SUhSdklHRWdhMjV2ZDI0Z1kyRjBZMmdnWW14dlkyc3VYRzRnSUNBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb1hDSnBiR3hsWjJGc0lHTmhkR05vSUdGMGRHVnRjSFJjSWlrN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUdSbGJHVm5ZWFJsV1dsbGJHUTZJR1oxYm1OMGFXOXVJR1JsYkdWbllYUmxXV2xsYkdRb2FYUmxjbUZpYkdVc0lISmxjM1ZzZEU1aGJXVXNJRzVsZUhSTWIyTXBJSHRjYmlBZ0lDQWdJSFJvYVhNdVpHVnNaV2RoZEdVZ1BTQjdYRzRnSUNBZ0lDQWdJR2wwWlhKaGRHOXlPaUIyWVd4MVpYTW9hWFJsY21GaWJHVXBMRnh1SUNBZ0lDQWdJQ0J5WlhOMWJIUk9ZVzFsT2lCeVpYTjFiSFJPWVcxbExGeHVJQ0FnSUNBZ0lDQnVaWGgwVEc5ak9pQnVaWGgwVEc5alhHNGdJQ0FnSUNCOU8xeHVYRzRnSUNBZ0lDQnlaWFIxY200Z1EyOXVkR2x1ZFdWVFpXNTBhVzVsYkR0Y2JpQWdJQ0I5WEc0Z0lIMDdYRzU5S1NoY2JpOHZJRUZ0YjI1bklIUm9aU0IyWVhKcGIzVnpJSFJ5YVdOcmN5Qm1iM0lnYjJKMFlXbHVhVzVuSUdFZ2NtVm1aWEpsYm1ObElIUnZJSFJvWlNCbmJHOWlZV3hjYmk4dklHOWlhbVZqZEN3Z2RHaHBjeUJ6WldWdGN5QjBieUJpWlNCMGFHVWdiVzl6ZENCeVpXeHBZV0pzWlNCMFpXTm9ibWx4ZFdVZ2RHaGhkQ0JrYjJWeklHNXZkRnh1THk4Z2RYTmxJR2x1WkdseVpXTjBJR1YyWVd3Z0tIZG9hV05vSUhacGIyeGhkR1Z6SUVOdmJuUmxiblFnVTJWamRYSnBkSGtnVUc5c2FXTjVLUzVjYm5SNWNHVnZaaUJuYkc5aVlXd2dQVDA5SUZ3aWIySnFaV04wWENJZ1B5Qm5iRzlpWVd3Z09pQjBlWEJsYjJZZ2QybHVaRzkzSUQwOVBTQmNJbTlpYW1WamRGd2lJRDhnZDJsdVpHOTNJRG9nZEhsd1pXOW1JSE5sYkdZZ1BUMDlJRndpYjJKcVpXTjBYQ0lnUHlCelpXeG1JRG9nZFc1a1pXWnBibVZrS1RzaVhYMD0iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSClcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIiwiLyoqXG4gKiBCaXQgdHdpZGRsaW5nIGhhY2tzIGZvciBKYXZhU2NyaXB0LlxuICpcbiAqIEF1dGhvcjogTWlrb2xhIEx5c2Vua29cbiAqXG4gKiBQb3J0ZWQgZnJvbSBTdGFuZm9yZCBiaXQgdHdpZGRsaW5nIGhhY2sgbGlicmFyeTpcbiAqICAgIGh0dHA6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvfnNlYW5kZXIvYml0aGFja3MuaHRtbFxuICovXG5cblwidXNlIHN0cmljdFwiOyBcInVzZSByZXN0cmljdFwiO1xuXG4vL051bWJlciBvZiBiaXRzIGluIGFuIGludGVnZXJcbnZhciBJTlRfQklUUyA9IDMyO1xuXG4vL0NvbnN0YW50c1xuZXhwb3J0cy5JTlRfQklUUyAgPSBJTlRfQklUUztcbmV4cG9ydHMuSU5UX01BWCAgID0gIDB4N2ZmZmZmZmY7XG5leHBvcnRzLklOVF9NSU4gICA9IC0xPDwoSU5UX0JJVFMtMSk7XG5cbi8vUmV0dXJucyAtMSwgMCwgKzEgZGVwZW5kaW5nIG9uIHNpZ24gb2YgeFxuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gKHYgPiAwKSAtICh2IDwgMCk7XG59XG5cbi8vQ29tcHV0ZXMgYWJzb2x1dGUgdmFsdWUgb2YgaW50ZWdlclxuZXhwb3J0cy5hYnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBtYXNrID0gdiA+PiAoSU5UX0JJVFMtMSk7XG4gIHJldHVybiAodiBeIG1hc2spIC0gbWFzaztcbn1cblxuLy9Db21wdXRlcyBtaW5pbXVtIG9mIGludGVnZXJzIHggYW5kIHlcbmV4cG9ydHMubWluID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4geSBeICgoeCBeIHkpICYgLSh4IDwgeSkpO1xufVxuXG4vL0NvbXB1dGVzIG1heGltdW0gb2YgaW50ZWdlcnMgeCBhbmQgeVxuZXhwb3J0cy5tYXggPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiB4IF4gKCh4IF4geSkgJiAtKHggPCB5KSk7XG59XG5cbi8vQ2hlY2tzIGlmIGEgbnVtYmVyIGlzIGEgcG93ZXIgb2YgdHdvXG5leHBvcnRzLmlzUG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICEodiAmICh2LTEpKSAmJiAoISF2KTtcbn1cblxuLy9Db21wdXRlcyBsb2cgYmFzZSAyIG9mIHZcbmV4cG9ydHMubG9nMiA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHIsIHNoaWZ0O1xuICByID0gICAgICh2ID4gMHhGRkZGKSA8PCA0OyB2ID4+Pj0gcjtcbiAgc2hpZnQgPSAodiA+IDB4RkYgICkgPDwgMzsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICBzaGlmdCA9ICh2ID4gMHhGICAgKSA8PCAyOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAweDMgICApIDw8IDE7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgcmV0dXJuIHIgfCAodiA+PiAxKTtcbn1cblxuLy9Db21wdXRlcyBsb2cgYmFzZSAxMCBvZiB2XG5leHBvcnRzLmxvZzEwID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gICh2ID49IDEwMDAwMDAwMDApID8gOSA6ICh2ID49IDEwMDAwMDAwMCkgPyA4IDogKHYgPj0gMTAwMDAwMDApID8gNyA6XG4gICAgICAgICAgKHYgPj0gMTAwMDAwMCkgPyA2IDogKHYgPj0gMTAwMDAwKSA/IDUgOiAodiA+PSAxMDAwMCkgPyA0IDpcbiAgICAgICAgICAodiA+PSAxMDAwKSA/IDMgOiAodiA+PSAxMDApID8gMiA6ICh2ID49IDEwKSA/IDEgOiAwO1xufVxuXG4vL0NvdW50cyBudW1iZXIgb2YgYml0c1xuZXhwb3J0cy5wb3BDb3VudCA9IGZ1bmN0aW9uKHYpIHtcbiAgdiA9IHYgLSAoKHYgPj4+IDEpICYgMHg1NTU1NTU1NSk7XG4gIHYgPSAodiAmIDB4MzMzMzMzMzMpICsgKCh2ID4+PiAyKSAmIDB4MzMzMzMzMzMpO1xuICByZXR1cm4gKCh2ICsgKHYgPj4+IDQpICYgMHhGMEYwRjBGKSAqIDB4MTAxMDEwMSkgPj4+IDI0O1xufVxuXG4vL0NvdW50cyBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3NcbmZ1bmN0aW9uIGNvdW50VHJhaWxpbmdaZXJvcyh2KSB7XG4gIHZhciBjID0gMzI7XG4gIHYgJj0gLXY7XG4gIGlmICh2KSBjLS07XG4gIGlmICh2ICYgMHgwMDAwRkZGRikgYyAtPSAxNjtcbiAgaWYgKHYgJiAweDAwRkYwMEZGKSBjIC09IDg7XG4gIGlmICh2ICYgMHgwRjBGMEYwRikgYyAtPSA0O1xuICBpZiAodiAmIDB4MzMzMzMzMzMpIGMgLT0gMjtcbiAgaWYgKHYgJiAweDU1NTU1NTU1KSBjIC09IDE7XG4gIHJldHVybiBjO1xufVxuZXhwb3J0cy5jb3VudFRyYWlsaW5nWmVyb3MgPSBjb3VudFRyYWlsaW5nWmVyb3M7XG5cbi8vUm91bmRzIHRvIG5leHQgcG93ZXIgb2YgMlxuZXhwb3J0cy5uZXh0UG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgdiArPSB2ID09PSAwO1xuICAtLXY7XG4gIHYgfD0gdiA+Pj4gMTtcbiAgdiB8PSB2ID4+PiAyO1xuICB2IHw9IHYgPj4+IDQ7XG4gIHYgfD0gdiA+Pj4gODtcbiAgdiB8PSB2ID4+PiAxNjtcbiAgcmV0dXJuIHYgKyAxO1xufVxuXG4vL1JvdW5kcyBkb3duIHRvIHByZXZpb3VzIHBvd2VyIG9mIDJcbmV4cG9ydHMucHJldlBvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHYgfD0gdiA+Pj4gMTtcbiAgdiB8PSB2ID4+PiAyO1xuICB2IHw9IHYgPj4+IDQ7XG4gIHYgfD0gdiA+Pj4gODtcbiAgdiB8PSB2ID4+PiAxNjtcbiAgcmV0dXJuIHYgLSAodj4+PjEpO1xufVxuXG4vL0NvbXB1dGVzIHBhcml0eSBvZiB3b3JkXG5leHBvcnRzLnBhcml0eSA9IGZ1bmN0aW9uKHYpIHtcbiAgdiBePSB2ID4+PiAxNjtcbiAgdiBePSB2ID4+PiA4O1xuICB2IF49IHYgPj4+IDQ7XG4gIHYgJj0gMHhmO1xuICByZXR1cm4gKDB4Njk5NiA+Pj4gdikgJiAxO1xufVxuXG52YXIgUkVWRVJTRV9UQUJMRSA9IG5ldyBBcnJheSgyNTYpO1xuXG4oZnVuY3Rpb24odGFiKSB7XG4gIGZvcih2YXIgaT0wOyBpPDI1NjsgKytpKSB7XG4gICAgdmFyIHYgPSBpLCByID0gaSwgcyA9IDc7XG4gICAgZm9yICh2ID4+Pj0gMTsgdjsgdiA+Pj49IDEpIHtcbiAgICAgIHIgPDw9IDE7XG4gICAgICByIHw9IHYgJiAxO1xuICAgICAgLS1zO1xuICAgIH1cbiAgICB0YWJbaV0gPSAociA8PCBzKSAmIDB4ZmY7XG4gIH1cbn0pKFJFVkVSU0VfVEFCTEUpO1xuXG4vL1JldmVyc2UgYml0cyBpbiBhIDMyIGJpdCB3b3JkXG5leHBvcnRzLnJldmVyc2UgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAgKFJFVkVSU0VfVEFCTEVbIHYgICAgICAgICAmIDB4ZmZdIDw8IDI0KSB8XG4gICAgICAgICAgKFJFVkVSU0VfVEFCTEVbKHYgPj4+IDgpICAmIDB4ZmZdIDw8IDE2KSB8XG4gICAgICAgICAgKFJFVkVSU0VfVEFCTEVbKHYgPj4+IDE2KSAmIDB4ZmZdIDw8IDgpICB8XG4gICAgICAgICAgIFJFVkVSU0VfVEFCTEVbKHYgPj4+IDI0KSAmIDB4ZmZdO1xufVxuXG4vL0ludGVybGVhdmUgYml0cyBvZiAyIGNvb3JkaW5hdGVzIHdpdGggMTYgYml0cy4gIFVzZWZ1bCBmb3IgZmFzdCBxdWFkdHJlZSBjb2Rlc1xuZXhwb3J0cy5pbnRlcmxlYXZlMiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgeCAmPSAweEZGRkY7XG4gIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgeSAmPSAweEZGRkY7XG4gIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gIHkgPSAoeSB8ICh5IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy9FeHRyYWN0cyB0aGUgbnRoIGludGVybGVhdmVkIGNvbXBvbmVudFxuZXhwb3J0cy5kZWludGVybGVhdmUyID0gZnVuY3Rpb24odiwgbikge1xuICB2ID0gKHYgPj4+IG4pICYgMHg1NTU1NTU1NTtcbiAgdiA9ICh2IHwgKHYgPj4+IDEpKSAgJiAweDMzMzMzMzMzO1xuICB2ID0gKHYgfCAodiA+Pj4gMikpICAmIDB4MEYwRjBGMEY7XG4gIHYgPSAodiB8ICh2ID4+PiA0KSkgICYgMHgwMEZGMDBGRjtcbiAgdiA9ICh2IHwgKHYgPj4+IDE2KSkgJiAweDAwMEZGRkY7XG4gIHJldHVybiAodiA8PCAxNikgPj4gMTY7XG59XG5cblxuLy9JbnRlcmxlYXZlIGJpdHMgb2YgMyBjb29yZGluYXRlcywgZWFjaCB3aXRoIDEwIGJpdHMuICBVc2VmdWwgZm9yIGZhc3Qgb2N0cmVlIGNvZGVzXG5leHBvcnRzLmludGVybGVhdmUzID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICB4ICY9IDB4M0ZGO1xuICB4ICA9ICh4IHwgKHg8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB4ICA9ICh4IHwgKHg8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHggID0gKHggfCAoeDw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHggID0gKHggfCAoeDw8MikpICAmIDEyMjcxMzM1MTM7XG5cbiAgeSAmPSAweDNGRjtcbiAgeSAgPSAoeSB8ICh5PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeSAgPSAoeSB8ICh5PDw4KSkgICYgMjUxNzE5Njk1O1xuICB5ICA9ICh5IHwgKHk8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB5ICA9ICh5IHwgKHk8PDIpKSAgJiAxMjI3MTMzNTEzO1xuICB4IHw9ICh5IDw8IDEpO1xuICBcbiAgeiAmPSAweDNGRjtcbiAgeiAgPSAoeiB8ICh6PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeiAgPSAoeiB8ICh6PDw4KSkgICYgMjUxNzE5Njk1O1xuICB6ICA9ICh6IHwgKHo8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB6ICA9ICh6IHwgKHo8PDIpKSAgJiAxMjI3MTMzNTEzO1xuICBcbiAgcmV0dXJuIHggfCAoeiA8PCAyKTtcbn1cblxuLy9FeHRyYWN0cyBudGggaW50ZXJsZWF2ZWQgY29tcG9uZW50IG9mIGEgMy10dXBsZVxuZXhwb3J0cy5kZWludGVybGVhdmUzID0gZnVuY3Rpb24odiwgbikge1xuICB2ID0gKHYgPj4+IG4pICAgICAgICYgMTIyNzEzMzUxMztcbiAgdiA9ICh2IHwgKHY+Pj4yKSkgICAmIDMyNzIzNTYwMzU7XG4gIHYgPSAodiB8ICh2Pj4+NCkpICAgJiAyNTE3MTk2OTU7XG4gIHYgPSAodiB8ICh2Pj4+OCkpICAgJiA0Mjc4MTkwMzM1O1xuICB2ID0gKHYgfCAodj4+PjE2KSkgICYgMHgzRkY7XG4gIHJldHVybiAodjw8MjIpPj4yMjtcbn1cblxuLy9Db21wdXRlcyBuZXh0IGNvbWJpbmF0aW9uIGluIGNvbGV4aWNvZ3JhcGhpYyBvcmRlciAodGhpcyBpcyBtaXN0YWtlbmx5IGNhbGxlZCBuZXh0UGVybXV0YXRpb24gb24gdGhlIGJpdCB0d2lkZGxpbmcgaGFja3MgcGFnZSlcbmV4cG9ydHMubmV4dENvbWJpbmF0aW9uID0gZnVuY3Rpb24odikge1xuICB2YXIgdCA9IHYgfCAodiAtIDEpO1xuICByZXR1cm4gKHQgKyAxKSB8ICgoKH50ICYgLX50KSAtIDEpID4+PiAoY291bnRUcmFpbGluZ1plcm9zKHYpICsgMSkpO1xufVxuXG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBib3hJbnRlcnNlY3RXcmFwcGVyXG5cbnZhciBwb29sID0gcmVxdWlyZSgndHlwZWRhcnJheS1wb29sJylcbnZhciBzd2VlcCA9IHJlcXVpcmUoJy4vbGliL3N3ZWVwJylcbnZhciBib3hJbnRlcnNlY3RJdGVyID0gcmVxdWlyZSgnLi9saWIvaW50ZXJzZWN0JylcblxuZnVuY3Rpb24gYm94RW1wdHkoZCwgYm94KSB7XG4gIGZvcih2YXIgaj0wOyBqPGQ7ICsraikge1xuICAgIGlmKCEoYm94W2pdIDw9IGJveFtqK2RdKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vVW5wYWNrIGJveGVzIGludG8gYSBmbGF0IHR5cGVkIGFycmF5LCByZW1vdmUgZW1wdHkgYm94ZXNcbmZ1bmN0aW9uIGNvbnZlcnRCb3hlcyhib3hlcywgZCwgZGF0YSwgaWRzKSB7XG4gIHZhciBwdHIgPSAwXG4gIHZhciBjb3VudCA9IDBcbiAgZm9yKHZhciBpPTAsIG49Ym94ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHZhciBiID0gYm94ZXNbaV1cbiAgICBpZihib3hFbXB0eShkLCBiKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgZm9yKHZhciBqPTA7IGo8MipkOyArK2opIHtcbiAgICAgIGRhdGFbcHRyKytdID0gYltqXVxuICAgIH1cbiAgICBpZHNbY291bnQrK10gPSBpXG4gIH1cbiAgcmV0dXJuIGNvdW50XG59XG5cbi8vUGVyZm9ybSB0eXBlIGNvbnZlcnNpb25zLCBjaGVjayBib3VuZHNcbmZ1bmN0aW9uIGJveEludGVyc2VjdChyZWQsIGJsdWUsIHZpc2l0LCBmdWxsKSB7XG4gIHZhciBuID0gcmVkLmxlbmd0aFxuICB2YXIgbSA9IGJsdWUubGVuZ3RoXG5cbiAgLy9JZiBlaXRoZXIgYXJyYXkgaXMgZW1wdHksIHRoZW4gd2UgY2FuIHNraXAgdGhpcyB3aG9sZSB0aGluZ1xuICBpZihuIDw9IDAgfHwgbSA8PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvL0NvbXB1dGUgZGltZW5zaW9uLCBpZiBpdCBpcyAwIHRoZW4gd2Ugc2tpcFxuICB2YXIgZCA9IChyZWRbMF0ubGVuZ3RoKT4+PjFcbiAgaWYoZCA8PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgcmV0dmFsXG5cbiAgLy9Db252ZXJ0IHJlZCBib3hlc1xuICB2YXIgcmVkTGlzdCAgPSBwb29sLm1hbGxvY0RvdWJsZSgyKmQqbilcbiAgdmFyIHJlZElkcyAgID0gcG9vbC5tYWxsb2NJbnQzMihuKVxuICBuID0gY29udmVydEJveGVzKHJlZCwgZCwgcmVkTGlzdCwgcmVkSWRzKVxuXG4gIGlmKG4gPiAwKSB7XG4gICAgaWYoZCA9PT0gMSAmJiBmdWxsKSB7XG4gICAgICAvL1NwZWNpYWwgY2FzZTogMWQgY29tcGxldGVcbiAgICAgIHN3ZWVwLmluaXQobilcbiAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQ29tcGxldGUoXG4gICAgICAgIGQsIHZpc2l0LCBcbiAgICAgICAgMCwgbiwgcmVkTGlzdCwgcmVkSWRzLFxuICAgICAgICAwLCBuLCByZWRMaXN0LCByZWRJZHMpXG4gICAgfSBlbHNlIHtcblxuICAgICAgLy9Db252ZXJ0IGJsdWUgYm94ZXNcbiAgICAgIHZhciBibHVlTGlzdCA9IHBvb2wubWFsbG9jRG91YmxlKDIqZCptKVxuICAgICAgdmFyIGJsdWVJZHMgID0gcG9vbC5tYWxsb2NJbnQzMihtKVxuICAgICAgbSA9IGNvbnZlcnRCb3hlcyhibHVlLCBkLCBibHVlTGlzdCwgYmx1ZUlkcylcblxuICAgICAgaWYobSA+IDApIHtcbiAgICAgICAgc3dlZXAuaW5pdChuK20pXG5cbiAgICAgICAgaWYoZCA9PT0gMSkge1xuICAgICAgICAgIC8vU3BlY2lhbCBjYXNlOiAxZCBiaXBhcnRpdGVcbiAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcEJpcGFydGl0ZShcbiAgICAgICAgICAgIGQsIHZpc2l0LCBcbiAgICAgICAgICAgIDAsIG4sIHJlZExpc3QsICByZWRJZHMsXG4gICAgICAgICAgICAwLCBtLCBibHVlTGlzdCwgYmx1ZUlkcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL0dlbmVyYWwgY2FzZTogIGQ+MVxuICAgICAgICAgIHJldHZhbCA9IGJveEludGVyc2VjdEl0ZXIoXG4gICAgICAgICAgICBkLCB2aXNpdCwgICAgZnVsbCxcbiAgICAgICAgICAgIG4sIHJlZExpc3QsICByZWRJZHMsXG4gICAgICAgICAgICBtLCBibHVlTGlzdCwgYmx1ZUlkcylcbiAgICAgICAgfVxuXG4gICAgICAgIHBvb2wuZnJlZShibHVlTGlzdClcbiAgICAgICAgcG9vbC5mcmVlKGJsdWVJZHMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcG9vbC5mcmVlKHJlZExpc3QpXG4gICAgcG9vbC5mcmVlKHJlZElkcylcbiAgfVxuXG4gIHJldHVybiByZXR2YWxcbn1cblxuLy9Vc2VyLWZyaWVuZGx5IHdyYXBwZXIsIGhhbmRsZSBmdWxsIGlucHV0IGFuZCBuby12aXNpdG9yIGNhc2VzXG5mdW5jdGlvbiBib3hJbnRlcnNlY3RXcmFwcGVyKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgdmFyIHJlc3VsdFxuICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJlc3VsdCA9IFtdXG4gICAgICBib3hJbnRlcnNlY3QoYXJnMCwgYXJnMCwgZnVuY3Rpb24oaSxqKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtpLCBqXSlcbiAgICAgIH0sIHRydWUpXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgY2FzZSAyOlxuICAgICAgaWYodHlwZW9mIGFyZzEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHZpc2l0ID0gYXJnMVxuICAgICAgICByZXR1cm4gYm94SW50ZXJzZWN0KGFyZzAsIGFyZzAsIHZpc2l0LCB0cnVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gW11cbiAgICAgICAgYm94SW50ZXJzZWN0KGFyZzAsIGFyZzEsIGZ1bmN0aW9uKGksaikge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKFtpLCBqXSlcbiAgICAgICAgfSwgZmFsc2UpXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gYm94SW50ZXJzZWN0KGFyZzAsIGFyZzEsIGFyZzIsIGZhbHNlKVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JveC1pbnRlcnNlY3Q6IEludmFsaWQgYXJndW1lbnRzJylcbiAgfVxufSIsIid1c2Ugc3RyaWN0J1xuXG52YXIgRElNRU5TSU9OICAgPSAnZCdcbnZhciBBWElTICAgICAgICA9ICdheCdcbnZhciBWSVNJVCAgICAgICA9ICd2didcbnZhciBGTElQICAgICAgICA9ICdmcCdcblxudmFyIEVMRU1fU0laRSAgID0gJ2VzJ1xuXG52YXIgUkVEX1NUQVJUICAgPSAncnMnXG52YXIgUkVEX0VORCAgICAgPSAncmUnXG52YXIgUkVEX0JPWEVTICAgPSAncmInXG52YXIgUkVEX0lOREVYICAgPSAncmknXG52YXIgUkVEX1BUUiAgICAgPSAncnAnXG5cbnZhciBCTFVFX1NUQVJUICA9ICdicydcbnZhciBCTFVFX0VORCAgICA9ICdiZSdcbnZhciBCTFVFX0JPWEVTICA9ICdiYidcbnZhciBCTFVFX0lOREVYICA9ICdiaSdcbnZhciBCTFVFX1BUUiAgICA9ICdicCdcblxudmFyIFJFVFZBTCAgICAgID0gJ3J2J1xuXG52YXIgSU5ORVJfTEFCRUwgPSAnUSdcblxudmFyIEFSR1MgPSBbXG4gIERJTUVOU0lPTixcbiAgQVhJUyxcbiAgVklTSVQsXG4gIFJFRF9TVEFSVCxcbiAgUkVEX0VORCxcbiAgUkVEX0JPWEVTLFxuICBSRURfSU5ERVgsXG4gIEJMVUVfU1RBUlQsXG4gIEJMVUVfRU5ELFxuICBCTFVFX0JPWEVTLFxuICBCTFVFX0lOREVYXG5dXG5cbmZ1bmN0aW9uIGdlbmVyYXRlQnJ1dGVGb3JjZShyZWRNYWpvciwgZmxpcCwgZnVsbCkge1xuICB2YXIgZnVuY05hbWUgPSAnYnJ1dGVGb3JjZScgKyBcbiAgICAocmVkTWFqb3IgPyAnUmVkJyA6ICdCbHVlJykgKyBcbiAgICAoZmxpcCA/ICdGbGlwJyA6ICcnKSArXG4gICAgKGZ1bGwgPyAnRnVsbCcgOiAnJylcblxuICB2YXIgY29kZSA9IFsnZnVuY3Rpb24gJywgZnVuY05hbWUsICcoJywgQVJHUy5qb2luKCksICcpeycsXG4gICAgJ3ZhciAnLCBFTEVNX1NJWkUsICc9MionLCBESU1FTlNJT04sICc7J11cblxuICB2YXIgcmVkTG9vcCA9IFxuICAgICdmb3IodmFyIGk9JyArIFJFRF9TVEFSVCArICcsJyArIFJFRF9QVFIgKyAnPScgKyBFTEVNX1NJWkUgKyAnKicgKyBSRURfU1RBUlQgKyAnOycgK1xuICAgICAgICAnaTwnICsgUkVEX0VORCArJzsnICtcbiAgICAgICAgJysraSwnICsgUkVEX1BUUiArICcrPScgKyBFTEVNX1NJWkUgKyAnKXsnICtcbiAgICAgICAgJ3ZhciB4MD0nICsgUkVEX0JPWEVTICsgJ1snICsgQVhJUyArICcrJyArIFJFRF9QVFIgKyAnXSwnICtcbiAgICAgICAgICAgICd4MT0nICsgUkVEX0JPWEVTICsgJ1snICsgQVhJUyArICcrJyArIFJFRF9QVFIgKyAnKycgKyBESU1FTlNJT04gKyAnXSwnICtcbiAgICAgICAgICAgICd4aT0nICsgUkVEX0lOREVYICsgJ1tpXTsnXG5cbiAgdmFyIGJsdWVMb29wID0gXG4gICAgJ2Zvcih2YXIgaj0nICsgQkxVRV9TVEFSVCArICcsJyArIEJMVUVfUFRSICsgJz0nICsgRUxFTV9TSVpFICsgJyonICsgQkxVRV9TVEFSVCArICc7JyArXG4gICAgICAgICdqPCcgKyBCTFVFX0VORCArICc7JyArXG4gICAgICAgICcrK2osJyArIEJMVUVfUFRSICsgJys9JyArIEVMRU1fU0laRSArICcpeycgK1xuICAgICAgICAndmFyIHkwPScgKyBCTFVFX0JPWEVTICsgJ1snICsgQVhJUyArICcrJyArIEJMVUVfUFRSICsgJ10sJyArXG4gICAgICAgICAgICAoZnVsbCA/ICd5MT0nICsgQkxVRV9CT1hFUyArICdbJyArIEFYSVMgKyAnKycgKyBCTFVFX1BUUiArICcrJyArIERJTUVOU0lPTiArICddLCcgOiAnJykgK1xuICAgICAgICAgICAgJ3lpPScgKyBCTFVFX0lOREVYICsgJ1tqXTsnXG5cbiAgaWYocmVkTWFqb3IpIHtcbiAgICBjb2RlLnB1c2gocmVkTG9vcCwgSU5ORVJfTEFCRUwsICc6JywgYmx1ZUxvb3ApXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKGJsdWVMb29wLCBJTk5FUl9MQUJFTCwgJzonLCByZWRMb29wKVxuICB9XG5cbiAgaWYoZnVsbCkge1xuICAgIGNvZGUucHVzaCgnaWYoeTE8eDB8fHgxPHkwKWNvbnRpbnVlOycpXG4gIH0gZWxzZSBpZihmbGlwKSB7XG4gICAgY29kZS5wdXNoKCdpZih5MDw9eDB8fHgxPHkwKWNvbnRpbnVlOycpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKCdpZih5MDx4MHx8eDE8eTApY29udGludWU7JylcbiAgfVxuXG4gIGNvZGUucHVzaCgnZm9yKHZhciBrPScrQVhJUysnKzE7azwnK0RJTUVOU0lPTisnOysrayl7JytcbiAgICAndmFyIHIwPScrUkVEX0JPWEVTKydbaysnK1JFRF9QVFIrJ10sJytcbiAgICAgICAgJ3IxPScrUkVEX0JPWEVTKydbaysnK0RJTUVOU0lPTisnKycrUkVEX1BUUisnXSwnK1xuICAgICAgICAnYjA9JytCTFVFX0JPWEVTKydbaysnK0JMVUVfUFRSKyddLCcrXG4gICAgICAgICdiMT0nK0JMVUVfQk9YRVMrJ1trKycrRElNRU5TSU9OKycrJytCTFVFX1BUUisnXTsnK1xuICAgICAgJ2lmKHIxPGIwfHxiMTxyMCljb250aW51ZSAnICsgSU5ORVJfTEFCRUwgKyAnO30nICtcbiAgICAgICd2YXIgJyArIFJFVFZBTCArICc9JyArIFZJU0lUICsgJygnKVxuXG4gIGlmKGZsaXApIHtcbiAgICBjb2RlLnB1c2goJ3lpLHhpJylcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goJ3hpLHlpJylcbiAgfVxuXG4gIGNvZGUucHVzaCgnKTtpZignICsgUkVUVkFMICsgJyE9PXZvaWQgMClyZXR1cm4gJyArIFJFVFZBTCArICc7fX19JylcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IGZ1bmNOYW1lLCBcbiAgICBjb2RlOiBjb2RlLmpvaW4oJycpXG4gIH1cbn1cblxuZnVuY3Rpb24gYnJ1dGVGb3JjZVBsYW5uZXIoZnVsbCkge1xuICB2YXIgZnVuY05hbWUgPSAnYnJ1dGVGb3JjZScgKyAoZnVsbCA/ICdGdWxsJyA6ICdQYXJ0aWFsJylcbiAgdmFyIHByZWZpeCA9IFtdXG4gIHZhciBmYXJncyA9IEFSR1Muc2xpY2UoKVxuICBpZighZnVsbCkge1xuICAgIGZhcmdzLnNwbGljZSgzLCAwLCBGTElQKVxuICB9XG5cbiAgdmFyIGNvZGUgPSBbJ2Z1bmN0aW9uICcgKyBmdW5jTmFtZSArICcoJyArIGZhcmdzLmpvaW4oKSArICcpeyddXG5cbiAgZnVuY3Rpb24gaW52b2tlKHJlZE1ham9yLCBmbGlwKSB7XG4gICAgdmFyIHJlcyA9IGdlbmVyYXRlQnJ1dGVGb3JjZShyZWRNYWpvciwgZmxpcCwgZnVsbClcbiAgICBwcmVmaXgucHVzaChyZXMuY29kZSlcbiAgICBjb2RlLnB1c2goJ3JldHVybiAnICsgcmVzLm5hbWUgKyAnKCcgKyBBUkdTLmpvaW4oKSArICcpOycpXG4gIH1cblxuICBjb2RlLnB1c2goJ2lmKCcgKyBSRURfRU5EICsgJy0nICsgUkVEX1NUQVJUICsgJz4nICtcbiAgICAgICAgICAgICAgICAgICAgQkxVRV9FTkQgKyAnLScgKyBCTFVFX1NUQVJUICsgJyl7JylcblxuICBpZihmdWxsKSB7XG4gICAgaW52b2tlKHRydWUsIGZhbHNlKVxuICAgIGNvZGUucHVzaCgnfWVsc2V7JylcbiAgICBpbnZva2UoZmFsc2UsIGZhbHNlKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaCgnaWYoJyArIEZMSVAgKyAnKXsnKVxuICAgIGludm9rZSh0cnVlLCB0cnVlKVxuICAgIGNvZGUucHVzaCgnfWVsc2V7JylcbiAgICBpbnZva2UodHJ1ZSwgZmFsc2UpXG4gICAgY29kZS5wdXNoKCd9fWVsc2V7aWYoJyArIEZMSVAgKyAnKXsnKVxuICAgIGludm9rZShmYWxzZSwgdHJ1ZSlcbiAgICBjb2RlLnB1c2goJ31lbHNleycpXG4gICAgaW52b2tlKGZhbHNlLCBmYWxzZSlcbiAgICBjb2RlLnB1c2goJ30nKVxuICB9XG4gIGNvZGUucHVzaCgnfX1yZXR1cm4gJyArIGZ1bmNOYW1lKVxuXG4gIHZhciBjb2RlU3RyID0gcHJlZml4LmpvaW4oJycpICsgY29kZS5qb2luKCcnKVxuICB2YXIgcHJvYyA9IG5ldyBGdW5jdGlvbihjb2RlU3RyKVxuICByZXR1cm4gcHJvYygpXG59XG5cblxuZXhwb3J0cy5wYXJ0aWFsID0gYnJ1dGVGb3JjZVBsYW5uZXIoZmFsc2UpXG5leHBvcnRzLmZ1bGwgICAgPSBicnV0ZUZvcmNlUGxhbm5lcih0cnVlKSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJveEludGVyc2VjdEl0ZXJcblxudmFyIHBvb2wgPSByZXF1aXJlKCd0eXBlZGFycmF5LXBvb2wnKVxudmFyIGJpdHMgPSByZXF1aXJlKCdiaXQtdHdpZGRsZScpXG52YXIgYnJ1dGVGb3JjZSA9IHJlcXVpcmUoJy4vYnJ1dGUnKVxudmFyIGJydXRlRm9yY2VQYXJ0aWFsID0gYnJ1dGVGb3JjZS5wYXJ0aWFsXG52YXIgYnJ1dGVGb3JjZUZ1bGwgPSBicnV0ZUZvcmNlLmZ1bGxcbnZhciBzd2VlcCA9IHJlcXVpcmUoJy4vc3dlZXAnKVxudmFyIGZpbmRNZWRpYW4gPSByZXF1aXJlKCcuL21lZGlhbicpXG52YXIgZ2VuUGFydGl0aW9uID0gcmVxdWlyZSgnLi9wYXJ0aXRpb24nKVxuXG4vL1R3aWRkbGUgcGFyYW1ldGVyc1xudmFyIEJSVVRFX0ZPUkNFX0NVVE9GRiAgICA9IDEyOCAgICAgICAvL0N1dCBvZmYgZm9yIGJydXRlIGZvcmNlIHNlYXJjaFxudmFyIFNDQU5fQ1VUT0ZGICAgICAgICAgICA9ICgxPDwyMikgICAvL0N1dCBvZmYgZm9yIHR3byB3YXkgc2NhblxudmFyIFNDQU5fQ09NUExFVEVfQ1VUT0ZGICA9ICgxPDwyMikgIFxuXG4vL1BhcnRpdGlvbiBmdW5jdGlvbnNcbnZhciBwYXJ0aXRpb25JbnRlcmlvckNvbnRhaW5zSW50ZXJ2YWwgPSBnZW5QYXJ0aXRpb24oXG4gICchKGxvPj1wMCkmJiEocDE+PWhpKScsIFxuICBbJ3AwJywgJ3AxJ10pXG5cbnZhciBwYXJ0aXRpb25TdGFydEVxdWFsID0gZ2VuUGFydGl0aW9uKFxuICAnbG89PT1wMCcsXG4gIFsncDAnXSlcblxudmFyIHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4gPSBnZW5QYXJ0aXRpb24oXG4gICdsbzxwMCcsXG4gIFsncDAnXSlcblxudmFyIHBhcnRpdGlvbkVuZExlc3NUaGFuRXF1YWwgPSBnZW5QYXJ0aXRpb24oXG4gICdoaTw9cDAnLFxuICBbJ3AwJ10pXG5cbnZhciBwYXJ0aXRpb25Db250YWluc1BvaW50ID0gZ2VuUGFydGl0aW9uKFxuICAnbG88PXAwJiZwMDw9aGknLFxuICBbJ3AwJ10pXG5cbnZhciBwYXJ0aXRpb25Db250YWluc1BvaW50UHJvcGVyID0gZ2VuUGFydGl0aW9uKFxuICAnbG88cDAmJnAwPD1oaScsXG4gIFsncDAnXSlcblxuLy9GcmFtZSBzaXplIGZvciBpdGVyYXRpdmUgbG9vcFxudmFyIElGUkFNRV9TSVpFID0gNlxudmFyIERGUkFNRV9TSVpFID0gMlxuXG4vL0RhdGEgZm9yIGJveCBzdGF0Y2tcbnZhciBJTklUX0NBUEFDSVRZID0gMTAyNFxudmFyIEJPWF9JU1RBQ0sgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIEJPWF9EU1RBQ0sgID0gcG9vbC5tYWxsb2NEb3VibGUoSU5JVF9DQVBBQ0lUWSlcblxuLy9Jbml0aWFsaXplIGl0ZXJhdGl2ZSBsb29wIHF1ZXVlXG5mdW5jdGlvbiBpdGVySW5pdChkLCBjb3VudCkge1xuICB2YXIgbGV2ZWxzID0gKDggKiBiaXRzLmxvZzIoY291bnQrMSkgKiAoZCsxKSl8MFxuICB2YXIgbWF4SW50cyA9IGJpdHMubmV4dFBvdzIoSUZSQU1FX1NJWkUqbGV2ZWxzKVxuICBpZihCT1hfSVNUQUNLLmxlbmd0aCA8IG1heEludHMpIHtcbiAgICBwb29sLmZyZWUoQk9YX0lTVEFDSylcbiAgICBCT1hfSVNUQUNLID0gcG9vbC5tYWxsb2NJbnQzMihtYXhJbnRzKVxuICB9XG4gIHZhciBtYXhEb3VibGVzID0gYml0cy5uZXh0UG93MihERlJBTUVfU0laRSpsZXZlbHMpXG4gIGlmKEJPWF9EU1RBQ0sgPCBtYXhEb3VibGVzKSB7XG4gICAgcG9vbC5mcmVlKEJPWF9EU1RBQ0spXG4gICAgQk9YX0RTVEFDSyA9IHBvb2wubWFsbG9jRG91YmxlKG1heERvdWJsZXMpXG4gIH1cbn1cblxuLy9BcHBlbmQgaXRlbSB0byBxdWV1ZVxuZnVuY3Rpb24gaXRlclB1c2gocHRyLFxuICBheGlzLCBcbiAgcmVkU3RhcnQsIHJlZEVuZCwgXG4gIGJsdWVTdGFydCwgYmx1ZUVuZCwgXG4gIHN0YXRlLCBcbiAgbG8sIGhpKSB7XG5cbiAgdmFyIGlwdHIgPSBJRlJBTUVfU0laRSAqIHB0clxuICBCT1hfSVNUQUNLW2lwdHJdICAgPSBheGlzXG4gIEJPWF9JU1RBQ0tbaXB0cisxXSA9IHJlZFN0YXJ0XG4gIEJPWF9JU1RBQ0tbaXB0cisyXSA9IHJlZEVuZFxuICBCT1hfSVNUQUNLW2lwdHIrM10gPSBibHVlU3RhcnRcbiAgQk9YX0lTVEFDS1tpcHRyKzRdID0gYmx1ZUVuZFxuICBCT1hfSVNUQUNLW2lwdHIrNV0gPSBzdGF0ZVxuXG4gIHZhciBkcHRyID0gREZSQU1FX1NJWkUgKiBwdHJcbiAgQk9YX0RTVEFDS1tkcHRyXSAgID0gbG9cbiAgQk9YX0RTVEFDS1tkcHRyKzFdID0gaGlcbn1cblxuLy9TcGVjaWFsIGNhc2U6ICBJbnRlcnNlY3Qgc2luZ2xlIHBvaW50IHdpdGggbGlzdCBvZiBpbnRlcnZhbHNcbmZ1bmN0aW9uIG9uZVBvaW50UGFydGlhbChcbiAgZCwgYXhpcywgdmlzaXQsIGZsaXAsXG4gIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gIGJsdWVPZmZzZXQsIGJsdWUsIGJsdWVJZCkge1xuXG4gIHZhciBlbGVtU2l6ZSA9IDIgKiBkXG4gIHZhciBibHVlUHRyICA9IGJsdWVPZmZzZXQgKiBlbGVtU2l6ZVxuICB2YXIgYmx1ZVggICAgPSBibHVlW2JsdWVQdHIgKyBheGlzXVxuXG5yZWRfbG9vcDpcbiAgZm9yKHZhciBpPXJlZFN0YXJ0LCByZWRQdHI9cmVkU3RhcnQqZWxlbVNpemU7IGk8cmVkRW5kOyArK2ksIHJlZFB0cis9ZWxlbVNpemUpIHtcbiAgICB2YXIgcjAgPSByZWRbcmVkUHRyK2F4aXNdXG4gICAgdmFyIHIxID0gcmVkW3JlZFB0citheGlzK2RdXG4gICAgaWYoYmx1ZVggPCByMCB8fCByMSA8IGJsdWVYKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZihmbGlwICYmIGJsdWVYID09PSByMCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdmFyIHJlZElkID0gcmVkSW5kZXhbaV1cbiAgICBmb3IodmFyIGo9YXhpcysxOyBqPGQ7ICsraikge1xuICAgICAgdmFyIHIwID0gcmVkW3JlZFB0citqXVxuICAgICAgdmFyIHIxID0gcmVkW3JlZFB0citqK2RdXG4gICAgICB2YXIgYjAgPSBibHVlW2JsdWVQdHIral1cbiAgICAgIHZhciBiMSA9IGJsdWVbYmx1ZVB0citqK2RdXG4gICAgICBpZihyMSA8IGIwIHx8IGIxIDwgcjApIHtcbiAgICAgICAgY29udGludWUgcmVkX2xvb3BcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJldHZhbFxuICAgIGlmKGZsaXApIHtcbiAgICAgIHJldHZhbCA9IHZpc2l0KGJsdWVJZCwgcmVkSWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHZhbCA9IHZpc2l0KHJlZElkLCBibHVlSWQpXG4gICAgfVxuICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcmV0dmFsXG4gICAgfVxuICB9XG59XG5cbi8vU3BlY2lhbCBjYXNlOiAgSW50ZXJzZWN0IG9uZSBwb2ludCB3aXRoIGxpc3Qgb2YgaW50ZXJ2YWxzXG5mdW5jdGlvbiBvbmVQb2ludEZ1bGwoXG4gIGQsIGF4aXMsIHZpc2l0LFxuICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlT2Zmc2V0LCBibHVlLCBibHVlSWQpIHtcblxuICB2YXIgZWxlbVNpemUgPSAyICogZFxuICB2YXIgYmx1ZVB0ciAgPSBibHVlT2Zmc2V0ICogZWxlbVNpemVcbiAgdmFyIGJsdWVYICAgID0gYmx1ZVtibHVlUHRyICsgYXhpc11cblxucmVkX2xvb3A6XG4gIGZvcih2YXIgaT1yZWRTdGFydCwgcmVkUHRyPXJlZFN0YXJ0KmVsZW1TaXplOyBpPHJlZEVuZDsgKytpLCByZWRQdHIrPWVsZW1TaXplKSB7XG4gICAgdmFyIHJlZElkID0gcmVkSW5kZXhbaV1cbiAgICBpZihyZWRJZCA9PT0gYmx1ZUlkKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB2YXIgcjAgPSByZWRbcmVkUHRyK2F4aXNdXG4gICAgdmFyIHIxID0gcmVkW3JlZFB0citheGlzK2RdXG4gICAgaWYoYmx1ZVggPCByMCB8fCByMSA8IGJsdWVYKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBmb3IodmFyIGo9YXhpcysxOyBqPGQ7ICsraikge1xuICAgICAgdmFyIHIwID0gcmVkW3JlZFB0citqXVxuICAgICAgdmFyIHIxID0gcmVkW3JlZFB0citqK2RdXG4gICAgICB2YXIgYjAgPSBibHVlW2JsdWVQdHIral1cbiAgICAgIHZhciBiMSA9IGJsdWVbYmx1ZVB0citqK2RdXG4gICAgICBpZihyMSA8IGIwIHx8IGIxIDwgcjApIHtcbiAgICAgICAgY29udGludWUgcmVkX2xvb3BcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJldHZhbCA9IHZpc2l0KHJlZElkLCBibHVlSWQpXG4gICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiByZXR2YWxcbiAgICB9XG4gIH1cbn1cblxuLy9UaGUgbWFpbiBib3ggaW50ZXJzZWN0aW9uIHJvdXRpbmVcbmZ1bmN0aW9uIGJveEludGVyc2VjdEl0ZXIoXG4gIGQsIHZpc2l0LCBpbml0RnVsbCxcbiAgeFNpemUsIHhCb3hlcywgeEluZGV4LFxuICB5U2l6ZSwgeUJveGVzLCB5SW5kZXgpIHtcblxuICAvL1Jlc2VydmUgbWVtb3J5IGZvciBzdGFja1xuICBpdGVySW5pdChkLCB4U2l6ZSArIHlTaXplKVxuXG4gIHZhciB0b3AgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyICogZFxuICB2YXIgcmV0dmFsXG5cbiAgaXRlclB1c2godG9wKyssXG4gICAgICAwLFxuICAgICAgMCwgeFNpemUsXG4gICAgICAwLCB5U2l6ZSxcbiAgICAgIGluaXRGdWxsID8gMTYgOiAwLCBcbiAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gIGlmKCFpbml0RnVsbCkge1xuICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgMCxcbiAgICAgIDAsIHlTaXplLFxuICAgICAgMCwgeFNpemUsXG4gICAgICAxLCBcbiAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gIH1cblxuICB3aGlsZSh0b3AgPiAwKSB7XG4gICAgdG9wICAtPSAxXG5cbiAgICB2YXIgaXB0ciA9IHRvcCAqIElGUkFNRV9TSVpFXG4gICAgdmFyIGF4aXMgICAgICA9IEJPWF9JU1RBQ0tbaXB0cl1cbiAgICB2YXIgcmVkU3RhcnQgID0gQk9YX0lTVEFDS1tpcHRyKzFdXG4gICAgdmFyIHJlZEVuZCAgICA9IEJPWF9JU1RBQ0tbaXB0cisyXVxuICAgIHZhciBibHVlU3RhcnQgPSBCT1hfSVNUQUNLW2lwdHIrM11cbiAgICB2YXIgYmx1ZUVuZCAgID0gQk9YX0lTVEFDS1tpcHRyKzRdXG4gICAgdmFyIHN0YXRlICAgICA9IEJPWF9JU1RBQ0tbaXB0cis1XVxuXG4gICAgdmFyIGRwdHIgPSB0b3AgKiBERlJBTUVfU0laRVxuICAgIHZhciBsbyAgICAgICAgPSBCT1hfRFNUQUNLW2RwdHJdXG4gICAgdmFyIGhpICAgICAgICA9IEJPWF9EU1RBQ0tbZHB0cisxXVxuXG4gICAgLy9VbnBhY2sgc3RhdGUgaW5mb1xuICAgIHZhciBmbGlwICAgICAgPSAoc3RhdGUgJiAxKVxuICAgIHZhciBmdWxsICAgICAgPSAhIShzdGF0ZSAmIDE2KVxuXG4gICAgLy9VbnBhY2sgaW5kaWNlc1xuICAgIHZhciByZWQgICAgICAgPSB4Qm94ZXNcbiAgICB2YXIgcmVkSW5kZXggID0geEluZGV4XG4gICAgdmFyIGJsdWUgICAgICA9IHlCb3hlc1xuICAgIHZhciBibHVlSW5kZXggPSB5SW5kZXhcbiAgICBpZihmbGlwKSB7XG4gICAgICByZWQgICAgICAgICA9IHlCb3hlc1xuICAgICAgcmVkSW5kZXggICAgPSB5SW5kZXhcbiAgICAgIGJsdWUgICAgICAgID0geEJveGVzXG4gICAgICBibHVlSW5kZXggICA9IHhJbmRleFxuICAgIH1cblxuICAgIGlmKHN0YXRlICYgMikge1xuICAgICAgcmVkRW5kID0gcGFydGl0aW9uU3RhcnRMZXNzVGhhbihcbiAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgaGkpXG4gICAgICBpZihyZWRTdGFydCA+PSByZWRFbmQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoc3RhdGUgJiA0KSB7XG4gICAgICByZWRTdGFydCA9IHBhcnRpdGlvbkVuZExlc3NUaGFuRXF1YWwoXG4gICAgICAgIGQsIGF4aXMsXG4gICAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgIGxvKVxuICAgICAgaWYocmVkU3RhcnQgPj0gcmVkRW5kKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHZhciByZWRDb3VudCAgPSByZWRFbmQgIC0gcmVkU3RhcnRcbiAgICB2YXIgYmx1ZUNvdW50ID0gYmx1ZUVuZCAtIGJsdWVTdGFydFxuXG4gICAgaWYoZnVsbCkge1xuICAgICAgaWYoZCAqIHJlZENvdW50ICogKHJlZENvdW50ICsgYmx1ZUNvdW50KSA8IFNDQU5fQ09NUExFVEVfQ1VUT0ZGKSB7XG4gICAgICAgIHJldHZhbCA9IHN3ZWVwLnNjYW5Db21wbGV0ZShcbiAgICAgICAgICBkLCBheGlzLCB2aXNpdCwgXG4gICAgICAgICAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoZCAqIE1hdGgubWluKHJlZENvdW50LCBibHVlQ291bnQpIDwgQlJVVEVfRk9SQ0VfQ1VUT0ZGKSB7XG4gICAgICAgIC8vSWYgaW5wdXQgc21hbGwsIHRoZW4gdXNlIGJydXRlIGZvcmNlXG4gICAgICAgIHJldHZhbCA9IGJydXRlRm9yY2VQYXJ0aWFsKFxuICAgICAgICAgICAgZCwgYXhpcywgdmlzaXQsIGZsaXAsXG4gICAgICAgICAgICByZWRTdGFydCwgIHJlZEVuZCwgIHJlZCwgIHJlZEluZGV4LFxuICAgICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2UgaWYoZCAqIHJlZENvdW50ICogYmx1ZUNvdW50IDwgU0NBTl9DVVRPRkYpIHtcbiAgICAgICAgLy9JZiBpbnB1dCBtZWRpdW0gc2l6ZWQsIHRoZW4gdXNlIHN3ZWVwIGFuZCBwcnVuZVxuICAgICAgICByZXR2YWwgPSBzd2VlcC5zY2FuQmlwYXJ0aXRlKFxuICAgICAgICAgIGQsIGF4aXMsIHZpc2l0LCBmbGlwLCBcbiAgICAgICAgICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvL0ZpcnN0LCBmaW5kIGFsbCByZWQgaW50ZXJ2YWxzIHdob3NlIGludGVyaW9yIGNvbnRhaW5zIChsbyxoaSlcbiAgICB2YXIgcmVkMCA9IHBhcnRpdGlvbkludGVyaW9yQ29udGFpbnNJbnRlcnZhbChcbiAgICAgIGQsIGF4aXMsIFxuICAgICAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgIGxvLCBoaSlcblxuICAgIC8vTG93ZXIgZGltZW5zaW9uYWwgY2FzZVxuICAgIGlmKHJlZFN0YXJ0IDwgcmVkMCkge1xuXG4gICAgICBpZihkICogKHJlZDAgLSByZWRTdGFydCkgPCBCUlVURV9GT1JDRV9DVVRPRkYpIHtcbiAgICAgICAgLy9TcGVjaWFsIGNhc2UgZm9yIHNtYWxsIGlucHV0czogdXNlIGJydXRlIGZvcmNlXG4gICAgICAgIHJldHZhbCA9IGJydXRlRm9yY2VGdWxsKFxuICAgICAgICAgIGQsIGF4aXMrMSwgdmlzaXQsXG4gICAgICAgICAgcmVkU3RhcnQsIHJlZDAsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoYXhpcyA9PT0gZC0yKSB7XG4gICAgICAgIGlmKGZsaXApIHtcbiAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcEJpcGFydGl0ZShcbiAgICAgICAgICAgIGQsIHZpc2l0LFxuICAgICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgsXG4gICAgICAgICAgICByZWRTdGFydCwgcmVkMCwgcmVkLCByZWRJbmRleClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcEJpcGFydGl0ZShcbiAgICAgICAgICAgIGQsIHZpc2l0LFxuICAgICAgICAgICAgcmVkU3RhcnQsIHJlZDAsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgfVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgYXhpcysxLFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCxcbiAgICAgICAgICBmbGlwLFxuICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsXG4gICAgICAgICAgcmVkU3RhcnQsIHJlZDAsXG4gICAgICAgICAgZmxpcF4xLFxuICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9EaXZpZGUgYW5kIGNvbnF1ZXIgcGhhc2VcbiAgICBpZihyZWQwIDwgcmVkRW5kKSB7XG5cbiAgICAgIC8vQ3V0IGJsdWUgaW50byAzIHBhcnRzOlxuICAgICAgLy9cbiAgICAgIC8vICBQb2ludHMgPCBtaWQgcG9pbnRcbiAgICAgIC8vICBQb2ludHMgPSBtaWQgcG9pbnRcbiAgICAgIC8vICBQb2ludHMgPiBtaWQgcG9pbnRcbiAgICAgIC8vXG4gICAgICB2YXIgYmx1ZTAgPSBmaW5kTWVkaWFuKFxuICAgICAgICBkLCBheGlzLCBcbiAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICB2YXIgbWlkID0gYmx1ZVtlbGVtU2l6ZSAqIGJsdWUwICsgYXhpc11cbiAgICAgIHZhciBibHVlMSA9IHBhcnRpdGlvblN0YXJ0RXF1YWwoXG4gICAgICAgIGQsIGF4aXMsXG4gICAgICAgIGJsdWUwLCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgsXG4gICAgICAgIG1pZClcblxuICAgICAgLy9SaWdodCBjYXNlXG4gICAgICBpZihibHVlMSA8IGJsdWVFbmQpIHtcbiAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgYXhpcyxcbiAgICAgICAgICByZWQwLCByZWRFbmQsXG4gICAgICAgICAgYmx1ZTEsIGJsdWVFbmQsXG4gICAgICAgICAgKGZsaXB8NCkgKyAoZnVsbCA/IDE2IDogMCksXG4gICAgICAgICAgbWlkLCBoaSlcbiAgICAgIH1cblxuICAgICAgLy9MZWZ0IGNhc2VcbiAgICAgIGlmKGJsdWVTdGFydCA8IGJsdWUwKSB7XG4gICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgIGF4aXMsXG4gICAgICAgICAgcmVkMCwgcmVkRW5kLFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZTAsXG4gICAgICAgICAgKGZsaXB8MikgKyAoZnVsbCA/IDE2IDogMCksXG4gICAgICAgICAgbG8sIG1pZClcbiAgICAgIH1cblxuICAgICAgLy9DZW50ZXIgY2FzZSAodGhlIGhhcmQgcGFydClcbiAgICAgIGlmKGJsdWUwICsgMSA9PT0gYmx1ZTEpIHtcbiAgICAgICAgLy9PcHRpbWl6YXRpb246IFJhbmdlIHdpdGggZXhhY3RseSAxIHBvaW50LCB1c2UgYSBicnV0ZSBmb3JjZSBzY2FuXG4gICAgICAgIGlmKGZ1bGwpIHtcbiAgICAgICAgICByZXR2YWwgPSBvbmVQb2ludEZ1bGwoXG4gICAgICAgICAgICBkLCBheGlzLCB2aXNpdCxcbiAgICAgICAgICAgIHJlZDAsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgIGJsdWUwLCBibHVlLCBibHVlSW5kZXhbYmx1ZTBdKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHZhbCA9IG9uZVBvaW50UGFydGlhbChcbiAgICAgICAgICAgIGQsIGF4aXMsIHZpc2l0LCBmbGlwLFxuICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgYmx1ZTAsIGJsdWUsIGJsdWVJbmRleFtibHVlMF0pXG4gICAgICAgIH1cbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihibHVlMCA8IGJsdWUxKSB7XG4gICAgICAgIHZhciByZWQxXG4gICAgICAgIGlmKGZ1bGwpIHtcbiAgICAgICAgICAvL0lmIGZ1bGwgaW50ZXJzZWN0aW9uLCBuZWVkIHRvIGhhbmRsZSBzcGVjaWFsIGNhc2VcbiAgICAgICAgICByZWQxID0gcGFydGl0aW9uQ29udGFpbnNQb2ludChcbiAgICAgICAgICAgIGQsIGF4aXMsXG4gICAgICAgICAgICByZWQwLCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICBtaWQpXG4gICAgICAgICAgaWYocmVkMCA8IHJlZDEpIHtcbiAgICAgICAgICAgIHZhciByZWRYID0gcGFydGl0aW9uU3RhcnRFcXVhbChcbiAgICAgICAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgICAgICAgcmVkMCwgcmVkMSwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgICAgbWlkKVxuICAgICAgICAgICAgaWYoYXhpcyA9PT0gZC0yKSB7XG4gICAgICAgICAgICAgIC8vRGVnZW5lcmF0ZSBzd2VlcCBpbnRlcnNlY3Rpb246XG4gICAgICAgICAgICAgIC8vICBbcmVkMCwgcmVkWF0gd2l0aCBbYmx1ZTAsIGJsdWUxXVxuICAgICAgICAgICAgICBpZihyZWQwIDwgcmVkWCkge1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQ29tcGxldGUoXG4gICAgICAgICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgICAgICAgIHJlZDAsIHJlZFgsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vTm9ybWFsIHN3ZWVwIGludGVyc2VjdGlvbjpcbiAgICAgICAgICAgICAgLy8gIFtyZWRYLCByZWQxXSB3aXRoIFtibHVlMCwgYmx1ZTFdXG4gICAgICAgICAgICAgIGlmKHJlZFggPCByZWQxKSB7XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgICAgICAgIHJlZFgsIHJlZDEsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYocmVkMCA8IHJlZFgpIHtcbiAgICAgICAgICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICAgICAgICAgIHJlZDAsIHJlZFgsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsXG4gICAgICAgICAgICAgICAgICAxNixcbiAgICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYocmVkWCA8IHJlZDEpIHtcbiAgICAgICAgICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICAgICAgICAgIHJlZFgsIHJlZDEsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgICAgICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSxcbiAgICAgICAgICAgICAgICAgIHJlZFgsIHJlZDEsXG4gICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZihmbGlwKSB7XG4gICAgICAgICAgICByZWQxID0gcGFydGl0aW9uQ29udGFpbnNQb2ludFByb3BlcihcbiAgICAgICAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICBtaWQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlZDEgPSBwYXJ0aXRpb25Db250YWluc1BvaW50KFxuICAgICAgICAgICAgICBkLCBheGlzLFxuICAgICAgICAgICAgICByZWQwLCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgIG1pZClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmVkMCA8IHJlZDEpIHtcbiAgICAgICAgICAgIGlmKGF4aXMgPT09IGQtMikge1xuICAgICAgICAgICAgICBpZihmbGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSwgYmx1ZSwgYmx1ZUluZGV4LFxuICAgICAgICAgICAgICAgICAgcmVkMCwgcmVkMSwgcmVkLCByZWRJbmRleClcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcEJpcGFydGl0ZShcbiAgICAgICAgICAgICAgICAgIGQsIHZpc2l0LFxuICAgICAgICAgICAgICAgICAgcmVkMCwgcmVkMSwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgcmVkMCwgcmVkMSxcbiAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsXG4gICAgICAgICAgICAgICAgZmxpcCxcbiAgICAgICAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsXG4gICAgICAgICAgICAgICAgZmxpcF4xLFxuICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZmluZE1lZGlhblxuXG52YXIgZ2VuUGFydGl0aW9uID0gcmVxdWlyZSgnLi9wYXJ0aXRpb24nKVxuXG52YXIgcGFydGl0aW9uU3RhcnRMZXNzVGhhbiA9IGdlblBhcnRpdGlvbignbG88cDAnLCBbJ3AwJ10pXG5cbnZhciBQQVJUSVRJT05fVEhSRVNIT0xEID0gOCAgIC8vQ3V0IG9mZiBmb3IgdXNpbmcgaW5zZXJ0aW9uIHNvcnQgaW4gZmluZE1lZGlhblxuXG4vL0Jhc2UgY2FzZSBmb3IgbWVkaWFuIGZpbmRpbmc6ICBVc2UgaW5zZXJ0aW9uIHNvcnRcbmZ1bmN0aW9uIGluc2VydGlvblNvcnQoZCwgYXhpcywgc3RhcnQsIGVuZCwgYm94ZXMsIGlkcykge1xuICB2YXIgZWxlbVNpemUgPSAyICogZFxuICB2YXIgYm94UHRyID0gZWxlbVNpemUgKiAoc3RhcnQrMSkgKyBheGlzXG4gIGZvcih2YXIgaT1zdGFydCsxOyBpPGVuZDsgKytpLCBib3hQdHIrPWVsZW1TaXplKSB7XG4gICAgdmFyIHggPSBib3hlc1tib3hQdHJdXG4gICAgZm9yKHZhciBqPWksIHB0cj1lbGVtU2l6ZSooaS0xKTsgXG4gICAgICAgIGo+c3RhcnQgJiYgYm94ZXNbcHRyK2F4aXNdID4geDsgXG4gICAgICAgIC0taiwgcHRyLT1lbGVtU2l6ZSkge1xuICAgICAgLy9Td2FwXG4gICAgICB2YXIgYVB0ciA9IHB0clxuICAgICAgdmFyIGJQdHIgPSBwdHIrZWxlbVNpemVcbiAgICAgIGZvcih2YXIgaz0wOyBrPGVsZW1TaXplOyArK2ssICsrYVB0ciwgKytiUHRyKSB7XG4gICAgICAgIHZhciB5ID0gYm94ZXNbYVB0cl1cbiAgICAgICAgYm94ZXNbYVB0cl0gPSBib3hlc1tiUHRyXVxuICAgICAgICBib3hlc1tiUHRyXSA9IHlcbiAgICAgIH1cbiAgICAgIHZhciB0bXAgPSBpZHNbal1cbiAgICAgIGlkc1tqXSA9IGlkc1tqLTFdXG4gICAgICBpZHNbai0xXSA9IHRtcFxuICAgIH1cbiAgfVxufVxuXG4vL0ZpbmQgbWVkaWFuIHVzaW5nIHF1aWNrIHNlbGVjdCBhbGdvcml0aG1cbi8vICB0YWtlcyBPKG4pIHRpbWUgd2l0aCBoaWdoIHByb2JhYmlsaXR5XG5mdW5jdGlvbiBmaW5kTWVkaWFuKGQsIGF4aXMsIHN0YXJ0LCBlbmQsIGJveGVzLCBpZHMpIHtcbiAgaWYoZW5kIDw9IHN0YXJ0KzEpIHtcbiAgICByZXR1cm4gc3RhcnRcbiAgfVxuXG4gIHZhciBsbyAgICAgICA9IHN0YXJ0XG4gIHZhciBoaSAgICAgICA9IGVuZFxuICB2YXIgbWlkICAgICAgPSAoKGVuZCArIHN0YXJ0KSA+Pj4gMSlcbiAgdmFyIGVsZW1TaXplID0gMipkXG4gIHZhciBwaXZvdCAgICA9IG1pZFxuICB2YXIgdmFsdWUgICAgPSBib3hlc1tlbGVtU2l6ZSptaWQrYXhpc11cbiAgXG4gIHdoaWxlKGxvIDwgaGkpIHtcbiAgICBpZihoaSAtIGxvIDwgUEFSVElUSU9OX1RIUkVTSE9MRCkge1xuICAgICAgaW5zZXJ0aW9uU29ydChkLCBheGlzLCBsbywgaGksIGJveGVzLCBpZHMpXG4gICAgICB2YWx1ZSA9IGJveGVzW2VsZW1TaXplKm1pZCtheGlzXVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgXG4gICAgLy9TZWxlY3QgcGl2b3QgdXNpbmcgbWVkaWFuLW9mLTNcbiAgICB2YXIgY291bnQgID0gaGkgLSBsb1xuICAgIHZhciBwaXZvdDAgPSAoTWF0aC5yYW5kb20oKSpjb3VudCtsbyl8MFxuICAgIHZhciB2YWx1ZTAgPSBib3hlc1tlbGVtU2l6ZSpwaXZvdDAgKyBheGlzXVxuICAgIHZhciBwaXZvdDEgPSAoTWF0aC5yYW5kb20oKSpjb3VudCtsbyl8MFxuICAgIHZhciB2YWx1ZTEgPSBib3hlc1tlbGVtU2l6ZSpwaXZvdDEgKyBheGlzXVxuICAgIHZhciBwaXZvdDIgPSAoTWF0aC5yYW5kb20oKSpjb3VudCtsbyl8MFxuICAgIHZhciB2YWx1ZTIgPSBib3hlc1tlbGVtU2l6ZSpwaXZvdDIgKyBheGlzXVxuICAgIGlmKHZhbHVlMCA8PSB2YWx1ZTEpIHtcbiAgICAgIGlmKHZhbHVlMiA+PSB2YWx1ZTEpIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDFcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTFcbiAgICAgIH0gZWxzZSBpZih2YWx1ZTAgPj0gdmFsdWUyKSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QwXG4gICAgICAgIHZhbHVlID0gdmFsdWUwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaXZvdCA9IHBpdm90MlxuICAgICAgICB2YWx1ZSA9IHZhbHVlMlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZih2YWx1ZTEgPj0gdmFsdWUyKSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QxXG4gICAgICAgIHZhbHVlID0gdmFsdWUxXG4gICAgICB9IGVsc2UgaWYodmFsdWUyID49IHZhbHVlMCkge1xuICAgICAgICBwaXZvdCA9IHBpdm90MFxuICAgICAgICB2YWx1ZSA9IHZhbHVlMFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTJcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1N3YXAgcGl2b3QgdG8gZW5kIG9mIGFycmF5XG4gICAgdmFyIGFQdHIgPSBlbGVtU2l6ZSAqIChoaS0xKVxuICAgIHZhciBiUHRyID0gZWxlbVNpemUgKiBwaXZvdFxuICAgIGZvcih2YXIgaT0wOyBpPGVsZW1TaXplOyArK2ksICsrYVB0ciwgKytiUHRyKSB7XG4gICAgICB2YXIgeCA9IGJveGVzW2FQdHJdXG4gICAgICBib3hlc1thUHRyXSA9IGJveGVzW2JQdHJdXG4gICAgICBib3hlc1tiUHRyXSA9IHhcbiAgICB9XG4gICAgdmFyIHkgPSBpZHNbaGktMV1cbiAgICBpZHNbaGktMV0gPSBpZHNbcGl2b3RdXG4gICAgaWRzW3Bpdm90XSA9IHlcblxuICAgIC8vUGFydGl0aW9uIHVzaW5nIHBpdm90XG4gICAgcGl2b3QgPSBwYXJ0aXRpb25TdGFydExlc3NUaGFuKFxuICAgICAgZCwgYXhpcywgXG4gICAgICBsbywgaGktMSwgYm94ZXMsIGlkcyxcbiAgICAgIHZhbHVlKVxuXG4gICAgLy9Td2FwIHBpdm90IGJhY2tcbiAgICB2YXIgYVB0ciA9IGVsZW1TaXplICogKGhpLTEpXG4gICAgdmFyIGJQdHIgPSBlbGVtU2l6ZSAqIHBpdm90XG4gICAgZm9yKHZhciBpPTA7IGk8ZWxlbVNpemU7ICsraSwgKythUHRyLCArK2JQdHIpIHtcbiAgICAgIHZhciB4ID0gYm94ZXNbYVB0cl1cbiAgICAgIGJveGVzW2FQdHJdID0gYm94ZXNbYlB0cl1cbiAgICAgIGJveGVzW2JQdHJdID0geFxuICAgIH1cbiAgICB2YXIgeSA9IGlkc1toaS0xXVxuICAgIGlkc1toaS0xXSA9IGlkc1twaXZvdF1cbiAgICBpZHNbcGl2b3RdID0geVxuXG4gICAgLy9Td2FwIHBpdm90IHRvIGxhc3QgcGl2b3RcbiAgICBpZihtaWQgPCBwaXZvdCkge1xuICAgICAgaGkgPSBwaXZvdC0xXG4gICAgICB3aGlsZShsbyA8IGhpICYmIFxuICAgICAgICBib3hlc1tlbGVtU2l6ZSooaGktMSkrYXhpc10gPT09IHZhbHVlKSB7XG4gICAgICAgIGhpIC09IDFcbiAgICAgIH1cbiAgICAgIGhpICs9IDFcbiAgICB9IGVsc2UgaWYocGl2b3QgPCBtaWQpIHtcbiAgICAgIGxvID0gcGl2b3QgKyAxXG4gICAgICB3aGlsZShsbyA8IGhpICYmXG4gICAgICAgIGJveGVzW2VsZW1TaXplKmxvK2F4aXNdID09PSB2YWx1ZSkge1xuICAgICAgICBsbyArPSAxXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy9NYWtlIHN1cmUgcGl2b3QgaXMgYXQgc3RhcnRcbiAgcmV0dXJuIHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4oXG4gICAgZCwgYXhpcywgXG4gICAgc3RhcnQsIG1pZCwgYm94ZXMsIGlkcyxcbiAgICBib3hlc1tlbGVtU2l6ZSptaWQrYXhpc10pXG59IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuUGFydGl0aW9uXG5cbnZhciBjb2RlID0gJ2Zvcih2YXIgaj0yKmEsaz1qKmMsbD1rLG09YyxuPWIsbz1hK2IscD1jO2Q+cDsrK3Asays9ail7dmFyIF87aWYoJClpZihtPT09cCltKz0xLGwrPWo7ZWxzZXtmb3IodmFyIHM9MDtqPnM7KytzKXt2YXIgdD1lW2src107ZVtrK3NdPWVbbF0sZVtsKytdPXR9dmFyIHU9ZltwXTtmW3BdPWZbbV0sZlttKytdPXV9fXJldHVybiBtJ1xuXG5mdW5jdGlvbiBnZW5QYXJ0aXRpb24ocHJlZGljYXRlLCBhcmdzKSB7XG4gIHZhciBmYXJncyA9J2FiY2RlZicuc3BsaXQoJycpLmNvbmNhdChhcmdzKVxuICB2YXIgcmVhZHMgPSBbXVxuICBpZihwcmVkaWNhdGUuaW5kZXhPZignbG8nKSA+PSAwKSB7XG4gICAgcmVhZHMucHVzaCgnbG89ZVtrK25dJylcbiAgfVxuICBpZihwcmVkaWNhdGUuaW5kZXhPZignaGknKSA+PSAwKSB7XG4gICAgcmVhZHMucHVzaCgnaGk9ZVtrK29dJylcbiAgfVxuICBmYXJncy5wdXNoKFxuICAgIGNvZGUucmVwbGFjZSgnXycsIHJlYWRzLmpvaW4oKSlcbiAgICAgICAgLnJlcGxhY2UoJyQnLCBwcmVkaWNhdGUpKVxuICByZXR1cm4gRnVuY3Rpb24uYXBwbHkodm9pZCAwLCBmYXJncylcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8vVGhpcyBjb2RlIGlzIGV4dHJhY3RlZCBmcm9tIG5kYXJyYXktc29ydFxuLy9JdCBpcyBpbmxpbmVkIGhlcmUgYXMgYSB0ZW1wb3Jhcnkgd29ya2Fyb3VuZFxuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBwZXI7XG5cbnZhciBJTlNFUlRfU09SVF9DVVRPRkYgPSAzMlxuXG5mdW5jdGlvbiB3cmFwcGVyKGRhdGEsIG4wKSB7XG4gIGlmIChuMCA8PSA0KklOU0VSVF9TT1JUX0NVVE9GRikge1xuICAgIGluc2VydGlvblNvcnQoMCwgbjAgLSAxLCBkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBxdWlja1NvcnQoMCwgbjAgLSAxLCBkYXRhKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRpb25Tb3J0KGxlZnQsIHJpZ2h0LCBkYXRhKSB7XG4gIHZhciBwdHIgPSAyKihsZWZ0KzEpXG4gIGZvcih2YXIgaT1sZWZ0KzE7IGk8PXJpZ2h0OyArK2kpIHtcbiAgICB2YXIgYSA9IGRhdGFbcHRyKytdXG4gICAgdmFyIGIgPSBkYXRhW3B0cisrXVxuICAgIHZhciBqID0gaVxuICAgIHZhciBqcHRyID0gcHRyLTJcbiAgICB3aGlsZShqLS0gPiBsZWZ0KSB7XG4gICAgICB2YXIgeCA9IGRhdGFbanB0ci0yXVxuICAgICAgdmFyIHkgPSBkYXRhW2pwdHItMV1cbiAgICAgIGlmKHggPCBhKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYoeCA9PT0gYSAmJiB5IDwgYikge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZGF0YVtqcHRyXSAgID0geFxuICAgICAgZGF0YVtqcHRyKzFdID0geVxuICAgICAganB0ciAtPSAyXG4gICAgfVxuICAgIGRhdGFbanB0cl0gICA9IGFcbiAgICBkYXRhW2pwdHIrMV0gPSBiXG4gIH1cbn1cblxuZnVuY3Rpb24gc3dhcChpLCBqLCBkYXRhKSB7XG4gIGkgKj0gMlxuICBqICo9IDJcbiAgdmFyIHggPSBkYXRhW2ldXG4gIHZhciB5ID0gZGF0YVtpKzFdXG4gIGRhdGFbaV0gPSBkYXRhW2pdXG4gIGRhdGFbaSsxXSA9IGRhdGFbaisxXVxuICBkYXRhW2pdID0geFxuICBkYXRhW2orMV0gPSB5XG59XG5cbmZ1bmN0aW9uIG1vdmUoaSwgaiwgZGF0YSkge1xuICBpICo9IDJcbiAgaiAqPSAyXG4gIGRhdGFbaV0gPSBkYXRhW2pdXG4gIGRhdGFbaSsxXSA9IGRhdGFbaisxXVxufVxuXG5mdW5jdGlvbiByb3RhdGUoaSwgaiwgaywgZGF0YSkge1xuICBpICo9IDJcbiAgaiAqPSAyXG4gIGsgKj0gMlxuICB2YXIgeCA9IGRhdGFbaV1cbiAgdmFyIHkgPSBkYXRhW2krMV1cbiAgZGF0YVtpXSA9IGRhdGFbal1cbiAgZGF0YVtpKzFdID0gZGF0YVtqKzFdXG4gIGRhdGFbal0gPSBkYXRhW2tdXG4gIGRhdGFbaisxXSA9IGRhdGFbaysxXVxuICBkYXRhW2tdID0geFxuICBkYXRhW2srMV0gPSB5XG59XG5cbmZ1bmN0aW9uIHNodWZmbGVQaXZvdChpLCBqLCBweCwgcHksIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICBkYXRhW2ldID0gZGF0YVtqXVxuICBkYXRhW2pdID0gcHhcbiAgZGF0YVtpKzFdID0gZGF0YVtqKzFdXG4gIGRhdGFbaisxXSA9IHB5XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUoaSwgaiwgZGF0YSkge1xuICBpICo9IDJcbiAgaiAqPSAyXG4gIHZhciB4ID0gZGF0YVtpXSxcbiAgICAgIHkgPSBkYXRhW2pdXG4gIGlmKHggPCB5KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZih4ID09PSB5KSB7XG4gICAgcmV0dXJuIGRhdGFbaSsxXSA+IGRhdGFbaisxXVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVQaXZvdChpLCB5LCBiLCBkYXRhKSB7XG4gIGkgKj0gMlxuICB2YXIgeCA9IGRhdGFbaV1cbiAgaWYoeCA8IHkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYoeCA9PT0geSkge1xuICAgIHJldHVybiBkYXRhW2krMV0gPCBiXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHF1aWNrU29ydChsZWZ0LCByaWdodCwgZGF0YSkge1xuICB2YXIgc2l4dGggPSAocmlnaHQgLSBsZWZ0ICsgMSkgLyA2IHwgMCwgXG4gICAgICBpbmRleDEgPSBsZWZ0ICsgc2l4dGgsIFxuICAgICAgaW5kZXg1ID0gcmlnaHQgLSBzaXh0aCwgXG4gICAgICBpbmRleDMgPSBsZWZ0ICsgcmlnaHQgPj4gMSwgXG4gICAgICBpbmRleDIgPSBpbmRleDMgLSBzaXh0aCwgXG4gICAgICBpbmRleDQgPSBpbmRleDMgKyBzaXh0aCwgXG4gICAgICBlbDEgPSBpbmRleDEsIFxuICAgICAgZWwyID0gaW5kZXgyLCBcbiAgICAgIGVsMyA9IGluZGV4MywgXG4gICAgICBlbDQgPSBpbmRleDQsIFxuICAgICAgZWw1ID0gaW5kZXg1LCBcbiAgICAgIGxlc3MgPSBsZWZ0ICsgMSwgXG4gICAgICBncmVhdCA9IHJpZ2h0IC0gMSwgXG4gICAgICB0bXAgPSAwXG4gIGlmKGNvbXBhcmUoZWwxLCBlbDIsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwxXG4gICAgZWwxID0gZWwyXG4gICAgZWwyID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDQsIGVsNSwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDRcbiAgICBlbDQgPSBlbDVcbiAgICBlbDUgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMSwgZWwzLCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMVxuICAgIGVsMSA9IGVsM1xuICAgIGVsMyA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwyLCBlbDMsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwyXG4gICAgZWwyID0gZWwzXG4gICAgZWwzID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDEsIGVsNCwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDFcbiAgICBlbDEgPSBlbDRcbiAgICBlbDQgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMywgZWw0LCBkYXRhKSkge1xuICAgIHRtcCA9IGVsM1xuICAgIGVsMyA9IGVsNFxuICAgIGVsNCA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwyLCBlbDUsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwyXG4gICAgZWwyID0gZWw1XG4gICAgZWw1ID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDIsIGVsMywgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDJcbiAgICBlbDIgPSBlbDNcbiAgICBlbDMgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsNCwgZWw1LCBkYXRhKSkge1xuICAgIHRtcCA9IGVsNFxuICAgIGVsNCA9IGVsNVxuICAgIGVsNSA9IHRtcFxuICB9XG5cbiAgdmFyIHBpdm90MVggPSBkYXRhWzIqZWwyXVxuICB2YXIgcGl2b3QxWSA9IGRhdGFbMiplbDIrMV1cbiAgdmFyIHBpdm90MlggPSBkYXRhWzIqZWw0XVxuICB2YXIgcGl2b3QyWSA9IGRhdGFbMiplbDQrMV1cblxuICB2YXIgcHRyMCA9IDIgKiBlbDE7XG4gIHZhciBwdHIyID0gMiAqIGVsMztcbiAgdmFyIHB0cjQgPSAyICogZWw1O1xuICB2YXIgcHRyNSA9IDIgKiBpbmRleDE7XG4gIHZhciBwdHI2ID0gMiAqIGluZGV4MztcbiAgdmFyIHB0cjcgPSAyICogaW5kZXg1O1xuICBmb3IgKHZhciBpMSA9IDA7IGkxIDwgMjsgKytpMSkge1xuICAgIHZhciB4ID0gZGF0YVtwdHIwK2kxXTtcbiAgICB2YXIgeSA9IGRhdGFbcHRyMitpMV07XG4gICAgdmFyIHogPSBkYXRhW3B0cjQraTFdO1xuICAgIGRhdGFbcHRyNStpMV0gPSB4O1xuICAgIGRhdGFbcHRyNitpMV0gPSB5O1xuICAgIGRhdGFbcHRyNytpMV0gPSB6O1xuICB9XG5cbiAgbW92ZShpbmRleDIsIGxlZnQsIGRhdGEpXG4gIG1vdmUoaW5kZXg0LCByaWdodCwgZGF0YSlcbiAgZm9yICh2YXIgayA9IGxlc3M7IGsgPD0gZ3JlYXQ7ICsraykge1xuICAgIGlmIChjb21wYXJlUGl2b3QoaywgcGl2b3QxWCwgcGl2b3QxWSwgZGF0YSkpIHtcbiAgICAgIGlmIChrICE9PSBsZXNzKSB7XG4gICAgICAgIHN3YXAoaywgbGVzcywgZGF0YSlcbiAgICAgIH1cbiAgICAgICsrbGVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjb21wYXJlUGl2b3QoaywgcGl2b3QyWCwgcGl2b3QyWSwgZGF0YSkpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBpZiAoIWNvbXBhcmVQaXZvdChncmVhdCwgcGl2b3QyWCwgcGl2b3QyWSwgZGF0YSkpIHtcbiAgICAgICAgICAgIGlmICgtLWdyZWF0IDwgaykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29tcGFyZVBpdm90KGdyZWF0LCBwaXZvdDFYLCBwaXZvdDFZLCBkYXRhKSkge1xuICAgICAgICAgICAgICByb3RhdGUoaywgbGVzcywgZ3JlYXQsIGRhdGEpXG4gICAgICAgICAgICAgICsrbGVzcztcbiAgICAgICAgICAgICAgLS1ncmVhdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN3YXAoaywgZ3JlYXQsIGRhdGEpXG4gICAgICAgICAgICAgIC0tZ3JlYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2h1ZmZsZVBpdm90KGxlZnQsIGxlc3MtMSwgcGl2b3QxWCwgcGl2b3QxWSwgZGF0YSlcbiAgc2h1ZmZsZVBpdm90KHJpZ2h0LCBncmVhdCsxLCBwaXZvdDJYLCBwaXZvdDJZLCBkYXRhKVxuICBpZiAobGVzcyAtIDIgLSBsZWZ0IDw9IElOU0VSVF9TT1JUX0NVVE9GRikge1xuICAgIGluc2VydGlvblNvcnQobGVmdCwgbGVzcyAtIDIsIGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHF1aWNrU29ydChsZWZ0LCBsZXNzIC0gMiwgZGF0YSk7XG4gIH1cbiAgaWYgKHJpZ2h0IC0gKGdyZWF0ICsgMikgPD0gSU5TRVJUX1NPUlRfQ1VUT0ZGKSB7XG4gICAgaW5zZXJ0aW9uU29ydChncmVhdCArIDIsIHJpZ2h0LCBkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBxdWlja1NvcnQoZ3JlYXQgKyAyLCByaWdodCwgZGF0YSk7XG4gIH1cbiAgaWYgKGdyZWF0IC0gbGVzcyA8PSBJTlNFUlRfU09SVF9DVVRPRkYpIHtcbiAgICBpbnNlcnRpb25Tb3J0KGxlc3MsIGdyZWF0LCBkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBxdWlja1NvcnQobGVzcywgZ3JlYXQsIGRhdGEpO1xuICB9XG59IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbml0OiAgICAgICAgICAgc3FJbml0LFxuICBzd2VlcEJpcGFydGl0ZTogc3dlZXBCaXBhcnRpdGUsXG4gIHN3ZWVwQ29tcGxldGU6ICBzd2VlcENvbXBsZXRlLFxuICBzY2FuQmlwYXJ0aXRlOiAgc2NhbkJpcGFydGl0ZSxcbiAgc2NhbkNvbXBsZXRlOiAgIHNjYW5Db21wbGV0ZVxufVxuXG52YXIgcG9vbCAgPSByZXF1aXJlKCd0eXBlZGFycmF5LXBvb2wnKVxudmFyIGJpdHMgID0gcmVxdWlyZSgnYml0LXR3aWRkbGUnKVxudmFyIGlzb3J0ID0gcmVxdWlyZSgnLi9zb3J0JylcblxuLy9GbGFnIGZvciBibHVlXG52YXIgQkxVRV9GTEFHID0gKDE8PDI4KVxuXG4vLzFEIHN3ZWVwIGV2ZW50IHF1ZXVlIHN0dWZmICh1c2UgcG9vbCB0byBzYXZlIHNwYWNlKVxudmFyIElOSVRfQ0FQQUNJVFkgICAgICA9IDEwMjRcbnZhciBSRURfU1dFRVBfUVVFVUUgICAgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgUkVEX1NXRUVQX0lOREVYICAgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIEJMVUVfU1dFRVBfUVVFVUUgICA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBCTFVFX1NXRUVQX0lOREVYICAgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgQ09NTU9OX1NXRUVQX1FVRVVFID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIENPTU1PTl9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBTV0VFUF9FVkVOVFMgICAgICAgPSBwb29sLm1hbGxvY0RvdWJsZShJTklUX0NBUEFDSVRZICogOClcblxuLy9SZXNlcnZlcyBtZW1vcnkgZm9yIHRoZSAxRCBzd2VlcCBkYXRhIHN0cnVjdHVyZXNcbmZ1bmN0aW9uIHNxSW5pdChjb3VudCkge1xuICB2YXIgcmNvdW50ID0gYml0cy5uZXh0UG93Mihjb3VudClcbiAgaWYoUkVEX1NXRUVQX1FVRVVFLmxlbmd0aCA8IHJjb3VudCkge1xuICAgIHBvb2wuZnJlZShSRURfU1dFRVBfUVVFVUUpXG4gICAgUkVEX1NXRUVQX1FVRVVFID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgaWYoUkVEX1NXRUVQX0lOREVYLmxlbmd0aCA8IHJjb3VudCkge1xuICAgIHBvb2wuZnJlZShSRURfU1dFRVBfSU5ERVgpXG4gICAgUkVEX1NXRUVQX0lOREVYID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgaWYoQkxVRV9TV0VFUF9RVUVVRS5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoQkxVRV9TV0VFUF9RVUVVRSlcbiAgICBCTFVFX1NXRUVQX1FVRVVFID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgaWYoQkxVRV9TV0VFUF9JTkRFWC5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoQkxVRV9TV0VFUF9JTkRFWClcbiAgICBCTFVFX1NXRUVQX0lOREVYID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgaWYoQ09NTU9OX1NXRUVQX1FVRVVFLmxlbmd0aCA8IHJjb3VudCkge1xuICAgIHBvb2wuZnJlZShDT01NT05fU1dFRVBfUVVFVUUpXG4gICAgQ09NTU9OX1NXRUVQX1FVRVVFID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgaWYoQ09NTU9OX1NXRUVQX0lOREVYLmxlbmd0aCA8IHJjb3VudCkge1xuICAgIHBvb2wuZnJlZShDT01NT05fU1dFRVBfSU5ERVgpXG4gICAgQ09NTU9OX1NXRUVQX0lOREVYID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgdmFyIGV2ZW50TGVuZ3RoID0gOCAqIHJjb3VudFxuICBpZihTV0VFUF9FVkVOVFMubGVuZ3RoIDwgZXZlbnRMZW5ndGgpIHtcbiAgICBwb29sLmZyZWUoU1dFRVBfRVZFTlRTKVxuICAgIFNXRUVQX0VWRU5UUyA9IHBvb2wubWFsbG9jRG91YmxlKGV2ZW50TGVuZ3RoKVxuICB9XG59XG5cbi8vUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgYWN0aXZlIHF1ZXVlIGluIE8oMSlcbmZ1bmN0aW9uIHNxUG9wKHF1ZXVlLCBpbmRleCwgY291bnQsIGl0ZW0pIHtcbiAgdmFyIGlkeCA9IGluZGV4W2l0ZW1dXG4gIHZhciB0b3AgPSBxdWV1ZVtjb3VudC0xXVxuICBxdWV1ZVtpZHhdID0gdG9wXG4gIGluZGV4W3RvcF0gPSBpZHhcbn1cblxuLy9JbnNlcnQgYW4gaXRlbSBpbnRvIHRoZSBhY3RpdmUgcXVldWUgaW4gTygxKVxuZnVuY3Rpb24gc3FQdXNoKHF1ZXVlLCBpbmRleCwgY291bnQsIGl0ZW0pIHtcbiAgcXVldWVbY291bnRdID0gaXRlbVxuICBpbmRleFtpdGVtXSAgPSBjb3VudFxufVxuXG4vL1JlY3Vyc2lvbiBiYXNlIGNhc2U6IHVzZSAxRCBzd2VlcCBhbGdvcml0aG1cbmZ1bmN0aW9uIHN3ZWVwQmlwYXJ0aXRlKFxuICAgIGQsIHZpc2l0LFxuICAgIHJlZFN0YXJ0LCAgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KSB7XG5cbiAgLy9zdG9yZSBldmVudHMgYXMgcGFpcnMgW2Nvb3JkaW5hdGUsIGlkeF1cbiAgLy9cbiAgLy8gIHJlZCBjcmVhdGU6ICAtKGlkeCsxKVxuICAvLyAgcmVkIGRlc3Ryb3k6IGlkeFxuICAvLyAgYmx1ZSBjcmVhdGU6IC0oaWR4K0JMVUVfRkxBRylcbiAgLy8gIGJsdWUgZGVzdHJveTogaWR4K0JMVUVfRkxBR1xuICAvL1xuICB2YXIgcHRyICAgICAgPSAwXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgaXN0YXJ0ICAgPSBkLTFcbiAgdmFyIGllbmQgICAgID0gZWxlbVNpemUtMVxuXG4gIGZvcih2YXIgaT1yZWRTdGFydDsgaTxyZWRFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSByZWRJbmRleFtpXVxuICAgIHZhciByZWRPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtKGlkeCsxKVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2llbmRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGlkeFxuICB9XG5cbiAgZm9yKHZhciBpPWJsdWVTdGFydDsgaTxibHVlRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gYmx1ZUluZGV4W2ldK0JMVUVfRkxBR1xuICAgIHZhciBibHVlT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuXG4gIC8vcHJvY2VzcyBldmVudHMgZnJvbSBsZWZ0LT5yaWdodFxuICB2YXIgbiA9IHB0ciA+Pj4gMVxuICBpc29ydChTV0VFUF9FVkVOVFMsIG4pXG4gIFxuICB2YXIgcmVkQWN0aXZlICA9IDBcbiAgdmFyIGJsdWVBY3RpdmUgPSAwXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBlID0gU1dFRVBfRVZFTlRTWzIqaSsxXXwwXG4gICAgaWYoZSA+PSBCTFVFX0ZMQUcpIHtcbiAgICAgIC8vYmx1ZSBkZXN0cm95IGV2ZW50XG4gICAgICBlID0gKGUtQkxVRV9GTEFHKXwwXG4gICAgICBzcVBvcChCTFVFX1NXRUVQX1FVRVVFLCBCTFVFX1NXRUVQX0lOREVYLCBibHVlQWN0aXZlLS0sIGUpXG4gICAgfSBlbHNlIGlmKGUgPj0gMCkge1xuICAgICAgLy9yZWQgZGVzdHJveSBldmVudFxuICAgICAgc3FQb3AoUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZS0tLCBlKVxuICAgIH0gZWxzZSBpZihlIDw9IC1CTFVFX0ZMQUcpIHtcbiAgICAgIC8vYmx1ZSBjcmVhdGUgZXZlbnRcbiAgICAgIGUgPSAoLWUtQkxVRV9GTEFHKXwwXG4gICAgICBmb3IodmFyIGo9MDsgajxyZWRBY3RpdmU7ICsraikge1xuICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoUkVEX1NXRUVQX1FVRVVFW2pdLCBlKVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3FQdXNoKEJMVUVfU1dFRVBfUVVFVUUsIEJMVUVfU1dFRVBfSU5ERVgsIGJsdWVBY3RpdmUrKywgZSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy9yZWQgY3JlYXRlIGV2ZW50XG4gICAgICBlID0gKC1lLTEpfDBcbiAgICAgIGZvcih2YXIgaj0wOyBqPGJsdWVBY3RpdmU7ICsraikge1xuICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoZSwgQkxVRV9TV0VFUF9RVUVVRVtqXSlcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNxUHVzaChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlKyssIGUpXG4gICAgfVxuICB9XG59XG5cbi8vQ29tcGxldGUgc3dlZXBcbmZ1bmN0aW9uIHN3ZWVwQ29tcGxldGUoZCwgdmlzaXQsIFxuICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCkge1xuXG4gIHZhciBwdHIgICAgICA9IDBcbiAgdmFyIGVsZW1TaXplID0gMipkXG4gIHZhciBpc3RhcnQgICA9IGQtMVxuICB2YXIgaWVuZCAgICAgPSBlbGVtU2l6ZS0xXG5cbiAgZm9yKHZhciBpPXJlZFN0YXJ0OyBpPHJlZEVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IChyZWRJbmRleFtpXSsxKTw8MVxuICAgIHZhciByZWRPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4XG4gIH1cblxuICBmb3IodmFyIGk9Ymx1ZVN0YXJ0OyBpPGJsdWVFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSAoYmx1ZUluZGV4W2ldKzEpPDwxXG4gICAgdmFyIGJsdWVPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9ICgtaWR4KXwxXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHh8MVxuICB9XG5cbiAgLy9wcm9jZXNzIGV2ZW50cyBmcm9tIGxlZnQtPnJpZ2h0XG4gIHZhciBuID0gcHRyID4+PiAxXG4gIGlzb3J0KFNXRUVQX0VWRU5UUywgbilcbiAgXG4gIHZhciByZWRBY3RpdmUgICAgPSAwXG4gIHZhciBibHVlQWN0aXZlICAgPSAwXG4gIHZhciBjb21tb25BY3RpdmUgPSAwXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBlICAgICA9IFNXRUVQX0VWRU5UU1syKmkrMV18MFxuICAgIHZhciBjb2xvciA9IGUmMVxuICAgIGlmKGkgPCBuLTEgJiYgKGU+PjEpID09PSAoU1dFRVBfRVZFTlRTWzIqaSszXT4+MSkpIHtcbiAgICAgIGNvbG9yID0gMlxuICAgICAgaSArPSAxXG4gICAgfVxuICAgIFxuICAgIGlmKGUgPCAwKSB7XG4gICAgICAvL0NyZWF0ZSBldmVudFxuICAgICAgdmFyIGlkID0gLShlPj4xKSAtIDFcblxuICAgICAgLy9JbnRlcnNlY3Qgd2l0aCBjb21tb25cbiAgICAgIGZvcih2YXIgaj0wOyBqPGNvbW1vbkFjdGl2ZTsgKytqKSB7XG4gICAgICAgIHZhciByZXR2YWwgPSB2aXNpdChDT01NT05fU1dFRVBfUVVFVUVbal0sIGlkKVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihjb2xvciAhPT0gMCkge1xuICAgICAgICAvL0ludGVyc2VjdCB3aXRoIHJlZFxuICAgICAgICBmb3IodmFyIGo9MDsgajxyZWRBY3RpdmU7ICsraikge1xuICAgICAgICAgIHZhciByZXR2YWwgPSB2aXNpdChSRURfU1dFRVBfUVVFVUVbal0sIGlkKVxuICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKGNvbG9yICE9PSAxKSB7XG4gICAgICAgIC8vSW50ZXJzZWN0IHdpdGggYmx1ZVxuICAgICAgICBmb3IodmFyIGo9MDsgajxibHVlQWN0aXZlOyArK2opIHtcbiAgICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoQkxVRV9TV0VFUF9RVUVVRVtqXSwgaWQpXG4gICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoY29sb3IgPT09IDApIHtcbiAgICAgICAgLy9SZWRcbiAgICAgICAgc3FQdXNoKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUrKywgaWQpXG4gICAgICB9IGVsc2UgaWYoY29sb3IgPT09IDEpIHtcbiAgICAgICAgLy9CbHVlXG4gICAgICAgIHNxUHVzaChCTFVFX1NXRUVQX1FVRVVFLCBCTFVFX1NXRUVQX0lOREVYLCBibHVlQWN0aXZlKyssIGlkKVxuICAgICAgfSBlbHNlIGlmKGNvbG9yID09PSAyKSB7XG4gICAgICAgIC8vQm90aFxuICAgICAgICBzcVB1c2goQ09NTU9OX1NXRUVQX1FVRVVFLCBDT01NT05fU1dFRVBfSU5ERVgsIGNvbW1vbkFjdGl2ZSsrLCBpZClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9EZXN0cm95IGV2ZW50XG4gICAgICB2YXIgaWQgPSAoZT4+MSkgLSAxXG4gICAgICBpZihjb2xvciA9PT0gMCkge1xuICAgICAgICAvL1JlZFxuICAgICAgICBzcVBvcChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlLS0sIGlkKVxuICAgICAgfSBlbHNlIGlmKGNvbG9yID09PSAxKSB7XG4gICAgICAgIC8vQmx1ZVxuICAgICAgICBzcVBvcChCTFVFX1NXRUVQX1FVRVVFLCBCTFVFX1NXRUVQX0lOREVYLCBibHVlQWN0aXZlLS0sIGlkKVxuICAgICAgfSBlbHNlIGlmKGNvbG9yID09PSAyKSB7XG4gICAgICAgIC8vQm90aFxuICAgICAgICBzcVBvcChDT01NT05fU1dFRVBfUVVFVUUsIENPTU1PTl9TV0VFUF9JTkRFWCwgY29tbW9uQWN0aXZlLS0sIGlkKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vL1N3ZWVwIGFuZCBwcnVuZS9zY2FubGluZSBhbGdvcml0aG06XG4vLyAgU2NhbiBhbG9uZyBheGlzLCBkZXRlY3QgaW50ZXJzZWN0aW9uc1xuLy8gIEJydXRlIGZvcmNlIGFsbCBib3hlcyBhbG9uZyBheGlzXG5mdW5jdGlvbiBzY2FuQmlwYXJ0aXRlKFxuICBkLCBheGlzLCB2aXNpdCwgZmxpcCxcbiAgcmVkU3RhcnQsICByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KSB7XG4gIFxuICB2YXIgcHRyICAgICAgPSAwXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgaXN0YXJ0ICAgPSBheGlzXG4gIHZhciBpZW5kICAgICA9IGF4aXMrZFxuXG4gIHZhciByZWRTaGlmdCAgPSAxXG4gIHZhciBibHVlU2hpZnQgPSAxXG4gIGlmKGZsaXApIHtcbiAgICBibHVlU2hpZnQgPSBCTFVFX0ZMQUdcbiAgfSBlbHNlIHtcbiAgICByZWRTaGlmdCAgPSBCTFVFX0ZMQUdcbiAgfVxuXG4gIGZvcih2YXIgaT1yZWRTdGFydDsgaTxyZWRFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSBpICsgcmVkU2hpZnRcbiAgICB2YXIgcmVkT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2llbmRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGlkeFxuICB9XG4gIGZvcih2YXIgaT1ibHVlU3RhcnQ7IGk8Ymx1ZUVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IGkgKyBibHVlU2hpZnRcbiAgICB2YXIgYmx1ZU9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICB9XG5cbiAgLy9wcm9jZXNzIGV2ZW50cyBmcm9tIGxlZnQtPnJpZ2h0XG4gIHZhciBuID0gcHRyID4+PiAxXG4gIGlzb3J0KFNXRUVQX0VWRU5UUywgbilcbiAgXG4gIHZhciByZWRBY3RpdmUgICAgPSAwXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBlID0gU1dFRVBfRVZFTlRTWzIqaSsxXXwwXG4gICAgaWYoZSA8IDApIHtcbiAgICAgIHZhciBpZHggICA9IC1lXG4gICAgICB2YXIgaXNSZWQgPSBmYWxzZVxuICAgICAgaWYoaWR4ID49IEJMVUVfRkxBRykge1xuICAgICAgICBpc1JlZCA9ICFmbGlwXG4gICAgICAgIGlkeCAtPSBCTFVFX0ZMQUcgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc1JlZCA9ICEhZmxpcFxuICAgICAgICBpZHggLT0gMVxuICAgICAgfVxuICAgICAgaWYoaXNSZWQpIHtcbiAgICAgICAgc3FQdXNoKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUrKywgaWR4KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJsdWVJZCAgPSBibHVlSW5kZXhbaWR4XVxuICAgICAgICB2YXIgYmx1ZVB0ciA9IGVsZW1TaXplICogaWR4XG4gICAgICAgIFxuICAgICAgICB2YXIgYjAgPSBibHVlW2JsdWVQdHIrYXhpcysxXVxuICAgICAgICB2YXIgYjEgPSBibHVlW2JsdWVQdHIrYXhpcysxK2RdXG5cbnJlZF9sb29wOlxuICAgICAgICBmb3IodmFyIGo9MDsgajxyZWRBY3RpdmU7ICsraikge1xuICAgICAgICAgIHZhciBvaWR4ICAgPSBSRURfU1dFRVBfUVVFVUVbal1cbiAgICAgICAgICB2YXIgcmVkUHRyID0gZWxlbVNpemUgKiBvaWR4XG5cbiAgICAgICAgICBpZihiMSA8IHJlZFtyZWRQdHIrYXhpcysxXSB8fCBcbiAgICAgICAgICAgICByZWRbcmVkUHRyK2F4aXMrMStkXSA8IGIwKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvcih2YXIgaz1heGlzKzI7IGs8ZDsgKytrKSB7XG4gICAgICAgICAgICBpZihibHVlW2JsdWVQdHIgKyBrICsgZF0gPCByZWRbcmVkUHRyICsga10gfHwgXG4gICAgICAgICAgICAgICByZWRbcmVkUHRyICsgayArIGRdIDwgYmx1ZVtibHVlUHRyICsga10pIHtcbiAgICAgICAgICAgICAgY29udGludWUgcmVkX2xvb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVkSWQgID0gcmVkSW5kZXhbb2lkeF1cbiAgICAgICAgICB2YXIgcmV0dmFsXG4gICAgICAgICAgaWYoZmxpcCkge1xuICAgICAgICAgICAgcmV0dmFsID0gdmlzaXQoYmx1ZUlkLCByZWRJZClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dmFsID0gdmlzaXQocmVkSWQsIGJsdWVJZClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXR2YWwgXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNxUG9wKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUtLSwgZSAtIHJlZFNoaWZ0KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzY2FuQ29tcGxldGUoXG4gIGQsIGF4aXMsIHZpc2l0LFxuICByZWRTdGFydCwgIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpIHtcblxuICB2YXIgcHRyICAgICAgPSAwXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgaXN0YXJ0ICAgPSBheGlzXG4gIHZhciBpZW5kICAgICA9IGF4aXMrZFxuXG4gIGZvcih2YXIgaT1yZWRTdGFydDsgaTxyZWRFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSBpICsgQkxVRV9GTEFHXG4gICAgdmFyIHJlZE9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuICBmb3IodmFyIGk9Ymx1ZVN0YXJ0OyBpPGJsdWVFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSBpICsgMVxuICAgIHZhciBibHVlT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gIH1cblxuICAvL3Byb2Nlc3MgZXZlbnRzIGZyb20gbGVmdC0+cmlnaHRcbiAgdmFyIG4gPSBwdHIgPj4+IDFcbiAgaXNvcnQoU1dFRVBfRVZFTlRTLCBuKVxuICBcbiAgdmFyIHJlZEFjdGl2ZSAgICA9IDBcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgdmFyIGUgPSBTV0VFUF9FVkVOVFNbMippKzFdfDBcbiAgICBpZihlIDwgMCkge1xuICAgICAgdmFyIGlkeCAgID0gLWVcbiAgICAgIGlmKGlkeCA+PSBCTFVFX0ZMQUcpIHtcbiAgICAgICAgUkVEX1NXRUVQX1FVRVVFW3JlZEFjdGl2ZSsrXSA9IGlkeCAtIEJMVUVfRkxBR1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWR4IC09IDFcbiAgICAgICAgdmFyIGJsdWVJZCAgPSBibHVlSW5kZXhbaWR4XVxuICAgICAgICB2YXIgYmx1ZVB0ciA9IGVsZW1TaXplICogaWR4XG5cbiAgICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2F4aXMrMV1cbiAgICAgICAgdmFyIGIxID0gYmx1ZVtibHVlUHRyK2F4aXMrMStkXVxuXG5yZWRfbG9vcDpcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgICB2YXIgb2lkeCAgID0gUkVEX1NXRUVQX1FVRVVFW2pdXG4gICAgICAgICAgdmFyIHJlZElkICA9IHJlZEluZGV4W29pZHhdXG5cbiAgICAgICAgICBpZihyZWRJZCA9PT0gYmx1ZUlkKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWRQdHIgPSBlbGVtU2l6ZSAqIG9pZHhcbiAgICAgICAgICBpZihiMSA8IHJlZFtyZWRQdHIrYXhpcysxXSB8fCBcbiAgICAgICAgICAgIHJlZFtyZWRQdHIrYXhpcysxK2RdIDwgYjApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGZvcih2YXIgaz1heGlzKzI7IGs8ZDsgKytrKSB7XG4gICAgICAgICAgICBpZihibHVlW2JsdWVQdHIgKyBrICsgZF0gPCByZWRbcmVkUHRyICsga10gfHwgXG4gICAgICAgICAgICAgICByZWRbcmVkUHRyICsgayArIGRdICAgPCBibHVlW2JsdWVQdHIgKyBrXSkge1xuICAgICAgICAgICAgICBjb250aW51ZSByZWRfbG9vcFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZXR2YWwgPSB2aXNpdChyZWRJZCwgYmx1ZUlkKVxuICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsIFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaWR4ID0gZSAtIEJMVUVfRkxBR1xuICAgICAgZm9yKHZhciBqPXJlZEFjdGl2ZS0xOyBqPj0wOyAtLWopIHtcbiAgICAgICAgaWYoUkVEX1NXRUVQX1FVRVVFW2pdID09PSBpZHgpIHtcbiAgICAgICAgICBmb3IodmFyIGs9aisxOyBrPHJlZEFjdGl2ZTsgKytrKSB7XG4gICAgICAgICAgICBSRURfU1dFRVBfUVVFVUVbay0xXSA9IFJFRF9TV0VFUF9RVUVVRVtrXVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAtLXJlZEFjdGl2ZVxuICAgIH1cbiAgfVxufSIsbnVsbCwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzLWFycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIGtNYXhMZW5ndGggPSAweDNmZmZmZmZmXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIE5vdGU6XG4gKlxuICogLSBJbXBsZW1lbnRhdGlvbiBtdXN0IHN1cHBvcnQgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMuXG4gKiAgIEZpcmVmb3ggNC0yOSBsYWNrZWQgc3VwcG9ydCwgZml4ZWQgaW4gRmlyZWZveCAzMCsuXG4gKiAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG4gKlxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXkgd2lsbFxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgd2lsbCB3b3JrIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoMSkuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gc3ViamVjdCA+IDAgPyBzdWJqZWN0ID4+PiAwIDogMFxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpXG4gICAgICBzdWJqZWN0ID0gYmFzZTY0Y2xlYW4oc3ViamVjdClcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiBzdWJqZWN0ICE9PSBudWxsKSB7IC8vIGFzc3VtZSBvYmplY3QgaXMgYXJyYXktbGlrZVxuICAgIGlmIChzdWJqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkoc3ViamVjdC5kYXRhKSlcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0LmRhdGFcbiAgICBsZW5ndGggPSArc3ViamVjdC5sZW5ndGggPiAwID8gTWF0aC5mbG9vcigrc3ViamVjdC5sZW5ndGgpIDogMFxuICB9IGVsc2VcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG5cbiAgaWYgKHRoaXMubGVuZ3RoID4ga01heExlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYnVmW2ldID0gKChzdWJqZWN0W2ldICUgMjU2KSArIDI1NikgJSAyNTZcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuICYmIGFbaV0gPT09IGJbaV07IGkrKykge31cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdFssIGxlbmd0aF0pJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0b3RhbExlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ciArICcnXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoID4+PiAxXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGIpIHtcbiAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpXG4gICAgICBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgMilcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuO1xuICAgIGlmIChzdGFydCA8IDApXG4gICAgICBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMClcbiAgICAgIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydClcbiAgICBlbmQgPSBzdGFydFxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpXG4gICAgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGlmICh0YXJnZXRfc3RhcnQgPCAwIHx8IHRhcmdldF9zdGFydCA+PSB0YXJnZXQubGVuZ3RoKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHNvdXJjZS5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLXpdL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKSB7XG4gICAgICBieXRlQXJyYXkucHVzaChiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgsIHVuaXRTaXplKSB7XG4gIGlmICh1bml0U2l6ZSkgbGVuZ3RoIC09IGxlbmd0aCAlIHVuaXRTaXplO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLkFycmF5LmZyb207IiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvcicpOyIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZScpOyIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvJC5jb3JlJykuTWFwOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm1hdGgubG9nMicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLk1hdGgubG9nMjsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuT2JqZWN0LmFzc2lnbjsiLCJ2YXIgJCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCl7XG4gIHJldHVybiAkLmNyZWF0ZShQLCBEKTtcbn07IiwidmFyICQgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhULCBEKXtcbiAgcmV0dXJuICQuc2V0RGVzY3MoVCwgRCk7XG59OyIsInZhciAkID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2Mpe1xuICByZXR1cm4gJC5zZXREZXNjKGl0LCBrZXksIGRlc2MpO1xufTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuT2JqZWN0LmZyZWV6ZTsiLCJ2YXIgJCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIHJldHVybiAkLmdldERlc2MoaXQsIGtleSk7XG59OyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuT2JqZWN0LmtleXM7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kLmNvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7IiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy8kLmNvcmUnKS5Qcm9taXNlOyIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvJC5jb3JlJykuU2V0OyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLlN5bWJvbDsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQud2tzJykoJ2l0ZXJhdG9yJyk7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vJC53a3MnKSgndG9TdHJpbmdUYWcnKVxuICAvLyBFUzMgd3JvbmcgaGVyZVxuICAsIEFSRyA9IGNvZihmdW5jdGlvbigpeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gKE8gPSBPYmplY3QoaXQpKVtUQUddKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07IiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBoaWRlICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGlkZScpXG4gICwgcmVkZWZpbmVBbGwgID0gcmVxdWlyZSgnLi8kLnJlZGVmaW5lLWFsbCcpXG4gICwgY3R4ICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgc3RyaWN0TmV3ICAgID0gcmVxdWlyZSgnLi8kLnN0cmljdC1uZXcnKVxuICAsIGRlZmluZWQgICAgICA9IHJlcXVpcmUoJy4vJC5kZWZpbmVkJylcbiAgLCBmb3JPZiAgICAgICAgPSByZXF1aXJlKCcuLyQuZm9yLW9mJylcbiAgLCAkaXRlckRlZmluZSAgPSByZXF1aXJlKCcuLyQuaXRlci1kZWZpbmUnKVxuICAsIHN0ZXAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyLXN0ZXAnKVxuICAsIElEICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC51aWQnKSgnaWQnKVxuICAsICRoYXMgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oYXMnKVxuICAsIGlzT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIHNldFNwZWNpZXMgICA9IHJlcXVpcmUoJy4vJC5zZXQtc3BlY2llcycpXG4gICwgREVTQ1JJUFRPUlMgID0gcmVxdWlyZSgnLi8kLmRlc2NyaXB0b3JzJylcbiAgLCBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGlzT2JqZWN0XG4gICwgU0laRSAgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnXG4gICwgaWQgICAgICAgICAgID0gMDtcblxudmFyIGZhc3RLZXkgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZighaXNPYmplY3QoaXQpKXJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmKCEkaGFzKGl0LCBJRCkpe1xuICAgIC8vIGNhbid0IHNldCBpZCB0byBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBpZFxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBvYmplY3QgaWRcbiAgICBoaWRlKGl0LCBJRCwgKytpZCk7XG4gIC8vIHJldHVybiBvYmplY3QgaWQgd2l0aCBwcmVmaXhcbiAgfSByZXR1cm4gJ08nICsgaXRbSURdO1xufTtcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24odGhhdCwga2V5KXtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KSwgZW50cnk7XG4gIGlmKGluZGV4ICE9PSAnRicpcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgaWYoZW50cnkuayA9PSBrZXkpcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICBzdHJpY3ROZXcodGhhdCwgQywgTkFNRSk7XG4gICAgICB0aGF0Ll9pID0gJC5jcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpe1xuICAgICAgICBmb3IodmFyIHRoYXQgPSB0aGlzLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZihlbnRyeS5wKWVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgICAsIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYoZW50cnkpe1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkublxuICAgICAgICAgICAgLCBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZihwcmV2KXByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYobmV4dCluZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmKHRoYXQuX2YgPT0gZW50cnkpdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYodGhhdC5fbCA9PSBlbnRyeSl0aGF0Ll9sID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKVxuICAgICAgICAgICwgZW50cnk7XG4gICAgICAgIHdoaWxlKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZil7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZihERVNDUklQVE9SUykkLnNldERlc2MoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gZGVmaW5lZCh0aGlzW1NJWkVdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbih0aGF0LCBrZXksIHZhbHVlKXtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpXG4gICAgICAsIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmKGVudHJ5KXtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmKCF0aGF0Ll9mKXRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmKHByZXYpcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmKGluZGV4ICE9PSAnRicpdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24oQywgTkFNRSwgSVNfTUFQKXtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgJGl0ZXJEZWZpbmUoQywgTkFNRSwgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICAgICAgdGhpcy5fdCA9IGl0ZXJhdGVkOyAgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICwga2luZCAgPSB0aGF0Ll9rXG4gICAgICAgICwgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZighdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKXtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycgLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgZm9yT2YgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsIGNsYXNzb2YgPSByZXF1aXJlKCcuLyQuY2xhc3NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRvSlNPTigpe1xuICAgIGlmKGNsYXNzb2YodGhpcykgIT0gTkFNRSl0aHJvdyBUeXBlRXJyb3IoTkFNRSArIFwiI3RvSlNPTiBpc24ndCBnZW5lcmljXCIpO1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBmb3JPZih0aGlzLCBmYWxzZSwgYXJyLnB1c2gsIGFycik7XG4gICAgcmV0dXJuIGFycjtcbiAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpXG4gICwgZmFpbHMgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZmFpbHMnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhpZGUnKVxuICAsIHJlZGVmaW5lQWxsICAgID0gcmVxdWlyZSgnLi8kLnJlZGVmaW5lLWFsbCcpXG4gICwgZm9yT2YgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZm9yLW9mJylcbiAgLCBzdHJpY3ROZXcgICAgICA9IHJlcXVpcmUoJy4vJC5zdHJpY3QtbmV3JylcbiAgLCBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi8kLnNldC10by1zdHJpbmctdGFnJylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vJC5kZXNjcmlwdG9ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKXtcbiAgdmFyIEJhc2UgID0gZ2xvYmFsW05BTUVdXG4gICAgLCBDICAgICA9IEJhc2VcbiAgICAsIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJ1xuICAgICwgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlXG4gICAgLCBPICAgICA9IHt9O1xuICBpZighREVTQ1JJUFRPUlMgfHwgdHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSl7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgfSBlbHNlIHtcbiAgICBDID0gd3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIGl0ZXJhYmxlKXtcbiAgICAgIHN0cmljdE5ldyh0YXJnZXQsIEMsIE5BTUUpO1xuICAgICAgdGFyZ2V0Ll9jID0gbmV3IEJhc2U7XG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGFyZ2V0W0FEREVSXSwgdGFyZ2V0KTtcbiAgICB9KTtcbiAgICAkLmVhY2guY2FsbCgnYWRkLGNsZWFyLGRlbGV0ZSxmb3JFYWNoLGdldCxoYXMsc2V0LGtleXMsdmFsdWVzLGVudHJpZXMnLnNwbGl0KCcsJyksZnVuY3Rpb24oS0VZKXtcbiAgICAgIHZhciBJU19BRERFUiA9IEtFWSA9PSAnYWRkJyB8fCBLRVkgPT0gJ3NldCc7XG4gICAgICBpZihLRVkgaW4gcHJvdG8gJiYgIShJU19XRUFLICYmIEtFWSA9PSAnY2xlYXInKSloaWRlKEMucHJvdG90eXBlLCBLRVksIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgICBpZighSVNfQURERVIgJiYgSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkpcmV0dXJuIEtFWSA9PSAnZ2V0JyA/IHVuZGVmaW5lZCA6IGZhbHNlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fY1tLRVldKGEgPT09IDAgPyAwIDogYSwgYik7XG4gICAgICAgIHJldHVybiBJU19BRERFUiA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZignc2l6ZScgaW4gcHJvdG8pJC5zZXREZXNjKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Muc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiwgTyk7XG5cbiAgaWYoIUlTX1dFQUspY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTsiLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcxLjIuNid9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi8kLmEtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07IiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vJC5mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTsiLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyICQgPSByZXF1aXJlKCcuLyQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIga2V5cyAgICAgICA9ICQuZ2V0S2V5cyhpdClcbiAgICAsIGdldFN5bWJvbHMgPSAkLmdldFN5bWJvbHM7XG4gIGlmKGdldFN5bWJvbHMpe1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcbiAgICAgICwgaXNFbnVtICA9ICQuaXNFbnVtXG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpa2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuLyQuY29yZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIElTX1dSQVAgICA9IHR5cGUgJiAkZXhwb3J0LldcbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBrZXksIG93biwgb3V0O1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIGtleSBpbiB0YXJnZXQ7XG4gICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKHBhcmFtKXtcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBDID8gbmV3IEMocGFyYW0pIDogQyhwYXJhbSk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIGlmKElTX1BST1RPKShleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KSlba2V5XSA9IG91dDtcbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgLy8gd3JhcFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59OyIsInZhciBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsIGNhbGwgICAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuLyQuaXMtYXJyYXktaXRlcicpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vJC50by1sZW5ndGgnKVxuICAsIGdldEl0ZXJGbiAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0KXtcbiAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihpdGVyYWJsZSlcbiAgICAsIGYgICAgICA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKVxuICAgICwgaW5kZXggID0gMFxuICAgICwgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvcjtcbiAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYoaXNBcnJheUl0ZXIoaXRlckZuKSlmb3IobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgIGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgfSBlbHNlIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyApe1xuICAgIGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICB9XG59OyIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpXG4gICwgZ2V0TmFtZXMgID0gcmVxdWlyZSgnLi8kJykuZ2V0TmFtZXNcbiAgLCB0b1N0cmluZyAgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuICB0cnkge1xuICAgIHJldHVybiBnZXROYW1lcyhpdCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldCA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICBpZih3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJylyZXR1cm4gZ2V0V2luZG93TmFtZXMoaXQpO1xuICByZXR1cm4gZ2V0TmFtZXModG9JT2JqZWN0KGl0KSk7XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTsiLCJ2YXIgJCAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vJC5wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuICQuc2V0RGVzYyhvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsiLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIGFyZ3MsIHRoYXQpe1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07IiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuLyQuY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59OyIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgID0gcmVxdWlyZSgnLi8kLml0ZXJhdG9ycycpXG4gICwgSVRFUkFUT1IgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTsiLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vJC5jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59OyIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaChlKXtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmKHJldCAhPT0gdW5kZWZpbmVkKWFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGRlc2NyaXB0b3IgICAgID0gcmVxdWlyZSgnLi8kLnByb3BlcnR5LWRlc2MnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi8kLnNldC10by1zdHJpbmctdGFnJylcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi8kLmhpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpe1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSAkLmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vJC5saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi8kLnJlZGVmaW5lJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oYXMnKVxuICAsIEl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXJhdG9ycycpXG4gICwgJGl0ZXJDcmVhdGUgICAgPSByZXF1aXJlKCcuLyQuaXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi8kLnNldC10by1zdHJpbmctdGFnJylcbiAgLCBnZXRQcm90byAgICAgICA9IHJlcXVpcmUoJy4vJCcpLmdldFByb3RvXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBCVUdHWSAgICAgICAgICA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKSAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gICwgRkZfSVRFUkFUT1IgICAgPSAnQEBpdGVyYXRvcidcbiAgLCBLRVlTICAgICAgICAgICA9ICdrZXlzJ1xuICAsIFZBTFVFUyAgICAgICAgID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKXtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oa2luZCl7XG4gICAgaWYoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHICAgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuICAgICwgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTXG4gICAgLCBWQUxVRVNfQlVHID0gZmFsc2VcbiAgICAsIHByb3RvICAgICAgPSBCYXNlLnByb3RvdHlwZVxuICAgICwgJG5hdGl2ZSAgICA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuICAgICwgJGRlZmF1bHQgICA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpXG4gICAgLCBtZXRob2RzLCBrZXk7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYoJG5hdGl2ZSl7XG4gICAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8oJGRlZmF1bHQuY2FsbChuZXcgQmFzZSkpO1xuICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAvLyBGRiBmaXhcbiAgICBpZighTElCUkFSWSAmJiBoYXMocHJvdG8sIEZGX0lURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICAgIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpe1xuICAgICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICAgIH1cbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJylcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07IiwidmFyIElURVJBVE9SICAgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMsIHNraXBDbG9zaW5nKXtcbiAgaWYoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgID0gWzddXG4gICAgICAsIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgc2FmZSA9IHRydWU7IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XG4gIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHt9OyIsInZhciAkT2JqZWN0ID0gT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZTogICAgICRPYmplY3QuY3JlYXRlLFxuICBnZXRQcm90bzogICAkT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICBpc0VudW06ICAgICB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgZ2V0RGVzYzogICAgJE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIHNldERlc2M6ICAgICRPYmplY3QuZGVmaW5lUHJvcGVydHksXG4gIHNldERlc2NzOiAgICRPYmplY3QuZGVmaW5lUHJvcGVydGllcyxcbiAgZ2V0S2V5czogICAgJE9iamVjdC5rZXlzLFxuICBnZXROYW1lczogICAkT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsXG4gIGdldFN5bWJvbHM6ICRPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICBlYWNoOiAgICAgICBbXS5mb3JFYWNoXG59OyIsInZhciAkICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vJC50by1pb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGtleXMgICA9ICQuZ2V0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlOyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuLyQudGFzaycpLnNldFxuICAsIE9ic2VydmVyICA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyXG4gICwgcHJvY2VzcyAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBQcm9taXNlICAgPSBnbG9iYWwuUHJvbWlzZVxuICAsIGlzTm9kZSAgICA9IHJlcXVpcmUoJy4vJC5jb2YnKShwcm9jZXNzKSA9PSAncHJvY2VzcydcbiAgLCBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbnZhciBmbHVzaCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBwYXJlbnQsIGRvbWFpbiwgZm47XG4gIGlmKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKXtcbiAgICBwcm9jZXNzLmRvbWFpbiA9IG51bGw7XG4gICAgcGFyZW50LmV4aXQoKTtcbiAgfVxuICB3aGlsZShoZWFkKXtcbiAgICBkb21haW4gPSBoZWFkLmRvbWFpbjtcbiAgICBmbiAgICAgPSBoZWFkLmZuO1xuICAgIGlmKGRvbWFpbilkb21haW4uZW50ZXIoKTtcbiAgICBmbigpOyAvLyA8LSBjdXJyZW50bHkgd2UgdXNlIGl0IG9ubHkgZm9yIFByb21pc2UgLSB0cnkgLyBjYXRjaCBub3QgcmVxdWlyZWRcbiAgICBpZihkb21haW4pZG9tYWluLmV4aXQoKTtcbiAgICBoZWFkID0gaGVhZC5uZXh0O1xuICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gIGlmKHBhcmVudClwYXJlbnQuZW50ZXIoKTtcbn07XG5cbi8vIE5vZGUuanNcbmlmKGlzTm9kZSl7XG4gIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG4vLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbn0gZWxzZSBpZihPYnNlcnZlcil7XG4gIHZhciB0b2dnbGUgPSAxXG4gICAgLCBub2RlICAgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9IC10b2dnbGU7XG4gIH07XG4vLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxufSBlbHNlIGlmKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKXtcbiAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZsdXNoKTtcbiAgfTtcbi8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4vLyAtIHNldEltbWVkaWF0ZVxuLy8gLSBNZXNzYWdlQ2hhbm5lbFxuLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2Vcbi8vIC0gc2V0VGltZW91dFxufSBlbHNlIHtcbiAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXNhcChmbil7XG4gIHZhciB0YXNrID0ge2ZuOiBmbiwgbmV4dDogdW5kZWZpbmVkLCBkb21haW46IGlzTm9kZSAmJiBwcm9jZXNzLmRvbWFpbn07XG4gIGlmKGxhc3QpbGFzdC5uZXh0ID0gdGFzaztcbiAgaWYoIWhlYWQpe1xuICAgIGhlYWQgPSB0YXNrO1xuICAgIG5vdGlmeSgpO1xuICB9IGxhc3QgPSB0YXNrO1xufTsiLCIvLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgJCAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLW9iamVjdCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuLyQuaW9iamVjdCcpO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIGEgPSBPYmplY3QuYXNzaWduXG4gICAgLCBBID0ge31cbiAgICAsIEIgPSB7fVxuICAgICwgUyA9IFN5bWJvbCgpXG4gICAgLCBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oayl7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuIGEoe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoYSh7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgICAgID0gdG9PYmplY3QodGFyZ2V0KVxuICAgICwgJCQgICAgPSBhcmd1bWVudHNcbiAgICAsICQkbGVuID0gJCQubGVuZ3RoXG4gICAgLCBpbmRleCA9IDFcbiAgICAsIGdldEtleXMgICAgPSAkLmdldEtleXNcbiAgICAsIGdldFN5bWJvbHMgPSAkLmdldFN5bWJvbHNcbiAgICAsIGlzRW51bSAgICAgPSAkLmlzRW51bTtcbiAgd2hpbGUoJCRsZW4gPiBpbmRleCl7XG4gICAgdmFyIFMgICAgICA9IElPYmplY3QoJCRbaW5kZXgrK10pXG4gICAgICAsIGtleXMgICA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaiAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gailpZihpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKVRba2V5XSA9IFNba2V5XTtcbiAgfVxuICByZXR1cm4gVDtcbn0gOiBPYmplY3QuYXNzaWduOyIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuLyQuZXhwb3J0JylcbiAgLCBjb3JlICAgID0gcmVxdWlyZSgnLi8kLmNvcmUnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuLyQuZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcbiAgdmFyIGZuICA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuICAgICwgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59OyIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vJC5yZWRlZmluZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIHNyYyl7XG4gIGZvcih2YXIga2V5IGluIHNyYylyZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICByZXR1cm4gdGFyZ2V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5oaWRlJyk7IiwiLy8gNy4yLjkgU2FtZVZhbHVlKHgsIHkpXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KXtcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG59OyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBnZXREZXNjICA9IHJlcXVpcmUoJy4vJCcpLmdldERlc2NcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24oTywgcHJvdG8pe1xuICBhbk9iamVjdChPKTtcbiAgaWYoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCl0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbih0ZXN0LCBidWdneSwgc2V0KXtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vJC5jdHgnKShGdW5jdGlvbi5jYWxsLCBnZXREZXNjKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNvcmUgICAgICAgID0gcmVxdWlyZSgnLi8kLmNvcmUnKVxuICAsICQgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vJC5kZXNjcmlwdG9ycycpXG4gICwgU1BFQ0lFUyAgICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVkpe1xuICB2YXIgQyA9IGNvcmVbS0VZXTtcbiAgaWYoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkkLnNldERlc2MoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTsiLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi8kJykuc2V0RGVzY1xuICAsIGhhcyA9IHJlcXVpcmUoJy4vJC5oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vJC53a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTsiLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCAgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLyQuYS1mdW5jdGlvbicpXG4gICwgU1BFQ0lFUyAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE8sIEQpe1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yLCBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIENvbnN0cnVjdG9yLCBuYW1lKXtcbiAgaWYoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSl0aHJvdyBUeXBlRXJyb3IobmFtZSArIFwiOiB1c2UgdGhlICduZXcnIG9wZXJhdG9yIVwiKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi8kLnRvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vJC5kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59OyIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBpbnZva2UgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaW52b2tlJylcbiAgLCBodG1sICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmRvbS1jcmVhdGUnKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgc2V0VGFzayAgICAgICAgICAgID0gZ2xvYmFsLnNldEltbWVkaWF0ZVxuICAsIGNsZWFyVGFzayAgICAgICAgICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxuICAsIE1lc3NhZ2VDaGFubmVsICAgICA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbFxuICAsIGNvdW50ZXIgICAgICAgICAgICA9IDBcbiAgLCBxdWV1ZSAgICAgICAgICAgICAgPSB7fVxuICAsIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnXG4gICwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIGlmKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSl7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0bmVyID0gZnVuY3Rpb24oZXZlbnQpe1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighc2V0VGFzayB8fCAhY2xlYXJUYXNrKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbil7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCl7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmKHJlcXVpcmUoJy4vJC5jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcycpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmKE1lc3NhZ2VDaGFubmVsKXtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsO1xuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdG5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZihnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTsiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07IiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vJC5pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59OyIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vJC50by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTsiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vJC5kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59OyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59OyIsInZhciBzdG9yZSAgPSByZXF1aXJlKCcuLyQuc2hhcmVkJykoJ3drcycpXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpXG4gICwgU3ltYm9sID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpLlN5bWJvbDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFN5bWJvbCAmJiBTeW1ib2xbbmFtZV0gfHwgKFN5bWJvbCB8fCB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07IiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vJC5jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ICE9IHVuZGVmaW5lZClyZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59OyIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIGdldCAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmNvcmUnKS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGl0ZXJGbiA9IGdldChpdCk7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgcmV0dXJuIGFuT2JqZWN0KGl0ZXJGbi5jYWxsKGl0KSk7XG59OyIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuLyQuY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi8kLml0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuY29yZScpLmlzSXRlcmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPID0gT2JqZWN0KGl0KTtcbiAgcmV0dXJuIE9bSVRFUkFUT1JdICE9PSB1bmRlZmluZWRcbiAgICB8fCAnQEBpdGVyYXRvcicgaW4gT1xuICAgIHx8IEl0ZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKE8pKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuLyQuZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vJC50by1vYmplY3QnKVxuICAsIGNhbGwgICAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuLyQuaXMtYXJyYXktaXRlcicpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuLyQudG8tbGVuZ3RoJylcbiAgLCBnZXRJdGVyRm4gICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuLyQuaXRlci1kZXRlY3QnKShmdW5jdGlvbihpdGVyKXsgQXJyYXkuZnJvbShpdGVyKTsgfSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZS8qLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCovKXtcbiAgICB2YXIgTyAgICAgICA9IHRvT2JqZWN0KGFycmF5TGlrZSlcbiAgICAgICwgQyAgICAgICA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXlcbiAgICAgICwgJCQgICAgICA9IGFyZ3VtZW50c1xuICAgICAgLCAkJGxlbiAgID0gJCQubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSAkJGxlbiA+IDEgPyAkJFsxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpbmRleCAgID0gMFxuICAgICAgLCBpdGVyRm4gID0gZ2V0SXRlckZuKE8pXG4gICAgICAsIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZihtYXBwaW5nKW1hcGZuID0gY3R4KG1hcGZuLCAkJGxlbiA+IDIgPyAkJFsyXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4Kyspe1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvcihyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vJC5hZGQtdG8tdW5zY29wYWJsZXMnKVxuICAsIHN0ZXAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaXRlci1zdGVwJylcbiAgLCBJdGVyYXRvcnMgICAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXJhdG9ycycpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vJC50by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLml0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5yZXF1aXJlKCcuLyQuY29sbGVjdGlvbicpKCdNYXAnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTsiLCIvLyAyMC4yLjIuMjIgTWF0aC5sb2cyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpe1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4yO1xuICB9XG59KTsiLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuLyQuZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0Jywge2Fzc2lnbjogcmVxdWlyZSgnLi8kLm9iamVjdC1hc3NpZ24nKX0pOyIsIi8vIDE5LjEuMi41IE9iamVjdC5mcmVlemUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi8kLm9iamVjdC1zYXAnKSgnZnJlZXplJywgZnVuY3Rpb24oJGZyZWV6ZSl7XG4gIHJldHVybiBmdW5jdGlvbiBmcmVlemUoaXQpe1xuICAgIHJldHVybiAkZnJlZXplICYmIGlzT2JqZWN0KGl0KSA/ICRmcmVlemUoaXQpIDogaXQ7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKTtcblxucmVxdWlyZSgnLi8kLm9iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgZnVuY3Rpb24oJGdldE93blByb3BlcnR5RGVzY3JpcHRvcil7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuLyQub2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24oJGtleXMpe1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuLyQuZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi8kLnNldC1wcm90bycpLnNldH0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBMSUJSQVJZICAgID0gcmVxdWlyZSgnLi8kLmxpYnJhcnknKVxuICAsIGdsb2JhbCAgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBjdHggICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgY2xhc3NvZiAgICA9IHJlcXVpcmUoJy4vJC5jbGFzc29mJylcbiAgLCAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpXG4gICwgaXNPYmplY3QgICA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ICAgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gID0gcmVxdWlyZSgnLi8kLmEtZnVuY3Rpb24nKVxuICAsIHN0cmljdE5ldyAgPSByZXF1aXJlKCcuLyQuc3RyaWN0LW5ldycpXG4gICwgZm9yT2YgICAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsIHNldFByb3RvICAgPSByZXF1aXJlKCcuLyQuc2V0LXByb3RvJykuc2V0XG4gICwgc2FtZSAgICAgICA9IHJlcXVpcmUoJy4vJC5zYW1lLXZhbHVlJylcbiAgLCBTUEVDSUVTICAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdzcGVjaWVzJylcbiAgLCBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLyQuc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgYXNhcCAgICAgICA9IHJlcXVpcmUoJy4vJC5taWNyb3Rhc2snKVxuICAsIFBST01JU0UgICAgPSAnUHJvbWlzZSdcbiAgLCBwcm9jZXNzICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBpc05vZGUgICAgID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2VzcydcbiAgLCBQICAgICAgICAgID0gZ2xvYmFsW1BST01JU0VdXG4gICwgV3JhcHBlcjtcblxudmFyIHRlc3RSZXNvbHZlID0gZnVuY3Rpb24oc3ViKXtcbiAgdmFyIHRlc3QgPSBuZXcgUChmdW5jdGlvbigpe30pO1xuICBpZihzdWIpdGVzdC5jb25zdHJ1Y3RvciA9IE9iamVjdDtcbiAgcmV0dXJuIFAucmVzb2x2ZSh0ZXN0KSA9PT0gdGVzdDtcbn07XG5cbnZhciBVU0VfTkFUSVZFID0gZnVuY3Rpb24oKXtcbiAgdmFyIHdvcmtzID0gZmFsc2U7XG4gIGZ1bmN0aW9uIFAyKHgpe1xuICAgIHZhciBzZWxmID0gbmV3IFAoeCk7XG4gICAgc2V0UHJvdG8oc2VsZiwgUDIucHJvdG90eXBlKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICB0cnkge1xuICAgIHdvcmtzID0gUCAmJiBQLnJlc29sdmUgJiYgdGVzdFJlc29sdmUoKTtcbiAgICBzZXRQcm90byhQMiwgUCk7XG4gICAgUDIucHJvdG90eXBlID0gJC5jcmVhdGUoUC5wcm90b3R5cGUsIHtjb25zdHJ1Y3Rvcjoge3ZhbHVlOiBQMn19KTtcbiAgICAvLyBhY3R1YWwgRmlyZWZveCBoYXMgYnJva2VuIHN1YmNsYXNzIHN1cHBvcnQsIHRlc3QgdGhhdFxuICAgIGlmKCEoUDIucmVzb2x2ZSg1KS50aGVuKGZ1bmN0aW9uKCl7fSkgaW5zdGFuY2VvZiBQMikpe1xuICAgICAgd29ya3MgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gYWN0dWFsIFY4IGJ1ZywgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxNjJcbiAgICBpZih3b3JrcyAmJiByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKSl7XG4gICAgICB2YXIgdGhlbmFibGVUaGVuR290dGVuID0gZmFsc2U7XG4gICAgICBQLnJlc29sdmUoJC5zZXREZXNjKHt9LCAndGhlbicsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpeyB0aGVuYWJsZVRoZW5Hb3R0ZW4gPSB0cnVlOyB9XG4gICAgICB9KSk7XG4gICAgICB3b3JrcyA9IHRoZW5hYmxlVGhlbkdvdHRlbjtcbiAgICB9XG4gIH0gY2F0Y2goZSl7IHdvcmtzID0gZmFsc2U7IH1cbiAgcmV0dXJuIHdvcmtzO1xufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgc2FtZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24oYSwgYil7XG4gIC8vIGxpYnJhcnkgd3JhcHBlciBzcGVjaWFsIGNhc2VcbiAgaWYoTElCUkFSWSAmJiBhID09PSBQICYmIGIgPT09IFdyYXBwZXIpcmV0dXJuIHRydWU7XG4gIHJldHVybiBzYW1lKGEsIGIpO1xufTtcbnZhciBnZXRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKEMpe1xuICB2YXIgUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdO1xuICByZXR1cm4gUyAhPSB1bmRlZmluZWQgPyBTIDogQztcbn07XG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbihDKXtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24oJCRyZXNvbHZlLCAkJHJlamVjdCl7XG4gICAgaWYocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCAgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKSxcbiAgdGhpcy5yZWplY3QgID0gYUZ1bmN0aW9uKHJlamVjdClcbn07XG52YXIgcGVyZm9ybSA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIGV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4ge2Vycm9yOiBlfTtcbiAgfVxufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbihyZWNvcmQsIGlzUmVqZWN0KXtcbiAgaWYocmVjb3JkLm4pcmV0dXJuO1xuICByZWNvcmQubiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHJlY29yZC5jO1xuICBhc2FwKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcmVjb3JkLnZcbiAgICAgICwgb2sgICAgPSByZWNvcmQucyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIHJlc3VsdCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmKGhhbmRsZXIpe1xuICAgICAgICAgIGlmKCFvaylyZWNvcmQuaCA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0ID0gaGFuZGxlciA9PT0gdHJ1ZSA/IHZhbHVlIDogaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgICAgaWYocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKXtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpe1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIGNoYWluLmxlbmd0aCA9IDA7XG4gICAgcmVjb3JkLm4gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdClzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcHJvbWlzZSA9IHJlY29yZC5wXG4gICAgICAgICwgaGFuZGxlciwgY29uc29sZTtcbiAgICAgIGlmKGlzVW5oYW5kbGVkKHByb21pc2UpKXtcbiAgICAgICAgaWYoaXNOb2RlKXtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pe1xuICAgICAgICAgIGhhbmRsZXIoe3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWV9KTtcbiAgICAgICAgfSBlbHNlIGlmKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3Ipe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSByZWNvcmQuYSA9IHVuZGVmaW5lZDtcbiAgICB9LCAxKTtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHZhciByZWNvcmQgPSBwcm9taXNlLl9kXG4gICAgLCBjaGFpbiAgPSByZWNvcmQuYSB8fCByZWNvcmQuY1xuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIGlmKHJlY29yZC5oKXJldHVybiBmYWxzZTtcbiAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSl7XG4gICAgcmVhY3Rpb24gPSBjaGFpbltpKytdO1xuICAgIGlmKHJlYWN0aW9uLmZhaWwgfHwgIWlzVW5oYW5kbGVkKHJlYWN0aW9uLnByb21pc2UpKXJldHVybiBmYWxzZTtcbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHJlY29yZCA9IHRoaXM7XG4gIGlmKHJlY29yZC5kKXJldHVybjtcbiAgcmVjb3JkLmQgPSB0cnVlO1xuICByZWNvcmQgPSByZWNvcmQuciB8fCByZWNvcmQ7IC8vIHVud3JhcFxuICByZWNvcmQudiA9IHZhbHVlO1xuICByZWNvcmQucyA9IDI7XG4gIHJlY29yZC5hID0gcmVjb3JkLmMuc2xpY2UoKTtcbiAgbm90aWZ5KHJlY29yZCwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcmVjb3JkID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocmVjb3JkLmQpcmV0dXJuO1xuICByZWNvcmQuZCA9IHRydWU7XG4gIHJlY29yZCA9IHJlY29yZC5yIHx8IHJlY29yZDsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYocmVjb3JkLnAgPT09IHZhbHVlKXRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSl7XG4gICAgICBhc2FwKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge3I6IHJlY29yZCwgZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29yZC52ID0gdmFsdWU7XG4gICAgICByZWNvcmQucyA9IDE7XG4gICAgICBub3RpZnkocmVjb3JkLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoKGUpe1xuICAgICRyZWplY3QuY2FsbCh7cjogcmVjb3JkLCBkOiBmYWxzZX0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZighVVNFX05BVElWRSl7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gIFAgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIHZhciByZWNvcmQgPSB0aGlzLl9kID0ge1xuICAgICAgcDogc3RyaWN0TmV3KHRoaXMsIFAsIFBST01JU0UpLCAgICAgICAgIC8vIDwtIHByb21pc2VcbiAgICAgIGM6IFtdLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICAgIGE6IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgICAgczogMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgICBkOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gZG9uZVxuICAgICAgdjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICBoOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gaGFuZGxlZCByZWplY3Rpb25cbiAgICAgIG46IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHJlY29yZCwgMSksIGN0eCgkcmVqZWN0LCByZWNvcmQsIDEpKTtcbiAgICB9IGNhdGNoKGVycil7XG4gICAgICAkcmVqZWN0LmNhbGwocmVjb3JkLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgcmVxdWlyZSgnLi8kLnJlZGVmaW5lLWFsbCcpKFAucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKXtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ldyBQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgUCkpXG4gICAgICAgICwgcHJvbWlzZSAgPSByZWFjdGlvbi5wcm9taXNlXG4gICAgICAgICwgcmVjb3JkICAgPSB0aGlzLl9kO1xuICAgICAgcmVhY3Rpb24ub2sgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlY29yZC5jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYocmVjb3JkLmEpcmVjb3JkLmEucHVzaChyZWFjdGlvbik7XG4gICAgICBpZihyZWNvcmQucylub3RpZnkocmVjb3JkLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3RlZCl7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6IFB9KTtcbnJlcXVpcmUoJy4vJC5zZXQtdG8tc3RyaW5nLXRhZycpKFAsIFBST01JU0UpO1xucmVxdWlyZSgnLi8kLnNldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi8kLmNvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKXtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ldyBQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlamVjdCAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCB0ZXN0UmVzb2x2ZSh0cnVlKSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiBQICYmIHNhbWVDb25zdHJ1Y3Rvcih4LmNvbnN0cnVjdG9yLCB0aGlzKSlyZXR1cm4geDtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ldyBQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vJC5pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpe1xuICBQLmFsbChpdGVyKVsnY2F0Y2gnXShmdW5jdGlvbigpe30pO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzKVxuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0XG4gICAgICAsIHZhbHVlcyAgICAgPSBbXTtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCB2YWx1ZXMucHVzaCwgdmFsdWVzKTtcbiAgICAgIHZhciByZW1haW5pbmcgPSB2YWx1ZXMubGVuZ3RoXG4gICAgICAgICwgcmVzdWx0cyAgID0gQXJyYXkocmVtYWluaW5nKTtcbiAgICAgIGlmKHJlbWFpbmluZykkLmVhY2guY2FsbCh2YWx1ZXMsIGZ1bmN0aW9uKHByb21pc2UsIGluZGV4KXtcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgZWxzZSByZXNvbHZlKHJlc3VsdHMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gZ2V0Q29uc3RydWN0b3IodGhpcylcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgLCByZWplY3QgICAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uJykoJ1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi8kLnN0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuLyQuaXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgJCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGFzJylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vJC5kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuLyQuZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vJC5yZWRlZmluZScpXG4gICwgJGZhaWxzICAgICAgICAgPSByZXF1aXJlKCcuLyQuZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi8kLnNoYXJlZCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLyQuc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIHVpZCAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQud2tzJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5rZXlvZicpXG4gICwgJG5hbWVzICAgICAgICAgPSByZXF1aXJlKCcuLyQuZ2V0LW5hbWVzJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vJC5lbnVtLWtleXMnKVxuICAsIGlzQXJyYXkgICAgICAgID0gcmVxdWlyZSgnLi8kLmlzLWFycmF5JylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi8kLnByb3BlcnR5LWRlc2MnKVxuICAsIGdldERlc2MgICAgICAgID0gJC5nZXREZXNjXG4gICwgc2V0RGVzYyAgICAgICAgPSAkLnNldERlc2NcbiAgLCBfY3JlYXRlICAgICAgICA9ICQuY3JlYXRlXG4gICwgZ2V0TmFtZXMgICAgICAgPSAkbmFtZXMuZ2V0XG4gICwgJFN5bWJvbCAgICAgICAgPSBnbG9iYWwuU3ltYm9sXG4gICwgJEpTT04gICAgICAgICAgPSBnbG9iYWwuSlNPTlxuICAsIF9zdHJpbmdpZnkgICAgID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5XG4gICwgc2V0dGVyICAgICAgICAgPSBmYWxzZVxuICAsIEhJRERFTiAgICAgICAgID0gd2tzKCdfaGlkZGVuJylcbiAgLCBpc0VudW0gICAgICAgICA9ICQuaXNFbnVtXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIHVzZU5hdGl2ZSAgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJ1xuICAsIE9iamVjdFByb3RvICAgID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gX2NyZWF0ZShzZXREZXNjKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBzZXREZXNjKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdldERlc2MoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgc2V0RGVzYyhpdCwga2V5LCBEKTtcbiAgaWYocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bylzZXREZXNjKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogc2V0RGVzYztcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sLnByb3RvdHlwZSk7XG4gIHN5bS5fayA9IHRhZztcbiAgREVTQ1JJUFRPUlMgJiYgc2V0dGVyICYmIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIGlmKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSl7XG4gICAgaWYoIUQuZW51bWVyYWJsZSl7XG4gICAgICBpZighaGFzKGl0LCBISURERU4pKXNldERlc2MoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIHNldERlc2MoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKVxuICAgICwgaSAgICA9IDBcbiAgICAsIGwgPSBrZXlzLmxlbmd0aFxuICAgICwga2V5O1xuICB3aGlsZShsID4gaSkkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSk7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV1cbiAgICA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICB2YXIgRCA9IGdldERlc2MoaXQgPSB0b0lPYmplY3QoaXQpLCBrZXkpO1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnZXROYW1lcyh0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4pcmVzdWx0LnB1c2goa2V5KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnZXROYW1lcyh0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkpcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJHN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICB2YXIgYXJncyA9IFtpdF1cbiAgICAsIGkgICAgPSAxXG4gICAgLCAkJCAgID0gYXJndW1lbnRzXG4gICAgLCByZXBsYWNlciwgJHJlcGxhY2VyO1xuICB3aGlsZSgkJC5sZW5ndGggPiBpKWFyZ3MucHVzaCgkJFtpKytdKTtcbiAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICBpZih0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIGlmKCFpc1N5bWJvbCh2YWx1ZSkpcmV0dXJuIHZhbHVlO1xuICB9O1xuICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbn07XG52YXIgYnVnZ3lKU09OID0gJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHthOiBTfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pO1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCF1c2VOYXRpdmUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYoaXNTeW1ib2wodGhpcykpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbiAgICByZXR1cm4gd3JhcCh1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gIGlzU3ltYm9sID0gZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG4gIH07XG5cbiAgJC5jcmVhdGUgICAgID0gJGNyZWF0ZTtcbiAgJC5pc0VudW0gICAgID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICAkLmdldERlc2MgICAgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkLnNldERlc2MgICAgPSAkZGVmaW5lUHJvcGVydHk7XG4gICQuc2V0RGVzY3MgICA9ICRkZWZpbmVQcm9wZXJ0aWVzO1xuICAkLmdldE5hbWVzICAgPSAkbmFtZXMuZ2V0ID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gICQuZ2V0U3ltYm9scyA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vJC5saWJyYXJ5Jykpe1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG59XG5cbnZhciBzeW1ib2xTdGF0aWNzID0ge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xuICAgIHJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7IHNldHRlciA9IGZhbHNlOyB9XG59O1xuLy8gMTkuNC4yLjIgU3ltYm9sLmhhc0luc3RhbmNlXG4vLyAxOS40LjIuMyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlXG4vLyAxOS40LjIuNCBTeW1ib2wuaXRlcmF0b3Jcbi8vIDE5LjQuMi42IFN5bWJvbC5tYXRjaFxuLy8gMTkuNC4yLjggU3ltYm9sLnJlcGxhY2Vcbi8vIDE5LjQuMi45IFN5bWJvbC5zZWFyY2hcbi8vIDE5LjQuMi4xMCBTeW1ib2wuc3BlY2llc1xuLy8gMTkuNC4yLjExIFN5bWJvbC5zcGxpdFxuLy8gMTkuNC4yLjEyIFN5bWJvbC50b1ByaW1pdGl2ZVxuLy8gMTkuNC4yLjEzIFN5bWJvbC50b1N0cmluZ1RhZ1xuLy8gMTkuNC4yLjE0IFN5bWJvbC51bnNjb3BhYmxlc1xuJC5lYWNoLmNhbGwoKFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLCcgK1xuICAnc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgZnVuY3Rpb24oaXQpe1xuICB2YXIgc3ltID0gd2tzKGl0KTtcbiAgc3ltYm9sU3RhdGljc1tpdF0gPSB1c2VOYXRpdmUgPyBzeW0gOiB3cmFwKHN5bSk7XG59KTtcblxuc2V0dGVyID0gdHJ1ZTtcblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcsIHtTeW1ib2w6ICRTeW1ib2x9KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTeW1ib2wnLCBzeW1ib2xTdGF0aWNzKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhdXNlTmF0aXZlLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghdXNlTmF0aXZlIHx8IGJ1Z2d5SlNPTiksICdKU09OJywge3N0cmluZ2lmeTogJHN0cmluZ2lmeX0pO1xuXG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdNYXAnLCB7dG9KU09OOiByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi10by1qc29uJykoJ01hcCcpfSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1NldCcsIHt0b0pTT046IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0Jyl9KTsiLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKTtcbkl0ZXJhdG9ycy5Ob2RlTGlzdCA9IEl0ZXJhdG9ycy5IVE1MQ29sbGVjdGlvbiA9IEl0ZXJhdG9ycy5BcnJheTsiLCIvLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTIuXG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlYW5tL2Nzcy1jb2xvci1wYXJzZXItanNcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xuLy8gSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yL1xudmFyIGtDU1NDb2xvclRhYmxlID0ge1xuICBcInRyYW5zcGFyZW50XCI6IFswLDAsMCwwXSwgXCJhbGljZWJsdWVcIjogWzI0MCwyNDgsMjU1LDFdLFxuICBcImFudGlxdWV3aGl0ZVwiOiBbMjUwLDIzNSwyMTUsMV0sIFwiYXF1YVwiOiBbMCwyNTUsMjU1LDFdLFxuICBcImFxdWFtYXJpbmVcIjogWzEyNywyNTUsMjEyLDFdLCBcImF6dXJlXCI6IFsyNDAsMjU1LDI1NSwxXSxcbiAgXCJiZWlnZVwiOiBbMjQ1LDI0NSwyMjAsMV0sIFwiYmlzcXVlXCI6IFsyNTUsMjI4LDE5NiwxXSxcbiAgXCJibGFja1wiOiBbMCwwLDAsMV0sIFwiYmxhbmNoZWRhbG1vbmRcIjogWzI1NSwyMzUsMjA1LDFdLFxuICBcImJsdWVcIjogWzAsMCwyNTUsMV0sIFwiYmx1ZXZpb2xldFwiOiBbMTM4LDQzLDIyNiwxXSxcbiAgXCJicm93blwiOiBbMTY1LDQyLDQyLDFdLCBcImJ1cmx5d29vZFwiOiBbMjIyLDE4NCwxMzUsMV0sXG4gIFwiY2FkZXRibHVlXCI6IFs5NSwxNTgsMTYwLDFdLCBcImNoYXJ0cmV1c2VcIjogWzEyNywyNTUsMCwxXSxcbiAgXCJjaG9jb2xhdGVcIjogWzIxMCwxMDUsMzAsMV0sIFwiY29yYWxcIjogWzI1NSwxMjcsODAsMV0sXG4gIFwiY29ybmZsb3dlcmJsdWVcIjogWzEwMCwxNDksMjM3LDFdLCBcImNvcm5zaWxrXCI6IFsyNTUsMjQ4LDIyMCwxXSxcbiAgXCJjcmltc29uXCI6IFsyMjAsMjAsNjAsMV0sIFwiY3lhblwiOiBbMCwyNTUsMjU1LDFdLFxuICBcImRhcmtibHVlXCI6IFswLDAsMTM5LDFdLCBcImRhcmtjeWFuXCI6IFswLDEzOSwxMzksMV0sXG4gIFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LDEzNCwxMSwxXSwgXCJkYXJrZ3JheVwiOiBbMTY5LDE2OSwxNjksMV0sXG4gIFwiZGFya2dyZWVuXCI6IFswLDEwMCwwLDFdLCBcImRhcmtncmV5XCI6IFsxNjksMTY5LDE2OSwxXSxcbiAgXCJkYXJra2hha2lcIjogWzE4OSwxODMsMTA3LDFdLCBcImRhcmttYWdlbnRhXCI6IFsxMzksMCwxMzksMV0sXG4gIFwiZGFya29saXZlZ3JlZW5cIjogWzg1LDEwNyw0NywxXSwgXCJkYXJrb3JhbmdlXCI6IFsyNTUsMTQwLDAsMV0sXG4gIFwiZGFya29yY2hpZFwiOiBbMTUzLDUwLDIwNCwxXSwgXCJkYXJrcmVkXCI6IFsxMzksMCwwLDFdLFxuICBcImRhcmtzYWxtb25cIjogWzIzMywxNTAsMTIyLDFdLCBcImRhcmtzZWFncmVlblwiOiBbMTQzLDE4OCwxNDMsMV0sXG4gIFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsNjEsMTM5LDFdLCBcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LDc5LDc5LDFdLFxuICBcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LDc5LDc5LDFdLCBcImRhcmt0dXJxdW9pc2VcIjogWzAsMjA2LDIwOSwxXSxcbiAgXCJkYXJrdmlvbGV0XCI6IFsxNDgsMCwyMTEsMV0sIFwiZGVlcHBpbmtcIjogWzI1NSwyMCwxNDcsMV0sXG4gIFwiZGVlcHNreWJsdWVcIjogWzAsMTkxLDI1NSwxXSwgXCJkaW1ncmF5XCI6IFsxMDUsMTA1LDEwNSwxXSxcbiAgXCJkaW1ncmV5XCI6IFsxMDUsMTA1LDEwNSwxXSwgXCJkb2RnZXJibHVlXCI6IFszMCwxNDQsMjU1LDFdLFxuICBcImZpcmVicmlja1wiOiBbMTc4LDM0LDM0LDFdLCBcImZsb3JhbHdoaXRlXCI6IFsyNTUsMjUwLDI0MCwxXSxcbiAgXCJmb3Jlc3RncmVlblwiOiBbMzQsMTM5LDM0LDFdLCBcImZ1Y2hzaWFcIjogWzI1NSwwLDI1NSwxXSxcbiAgXCJnYWluc2Jvcm9cIjogWzIyMCwyMjAsMjIwLDFdLCBcImdob3N0d2hpdGVcIjogWzI0OCwyNDgsMjU1LDFdLFxuICBcImdvbGRcIjogWzI1NSwyMTUsMCwxXSwgXCJnb2xkZW5yb2RcIjogWzIxOCwxNjUsMzIsMV0sXG4gIFwiZ3JheVwiOiBbMTI4LDEyOCwxMjgsMV0sIFwiZ3JlZW5cIjogWzAsMTI4LDAsMV0sXG4gIFwiZ3JlZW55ZWxsb3dcIjogWzE3MywyNTUsNDcsMV0sIFwiZ3JleVwiOiBbMTI4LDEyOCwxMjgsMV0sXG4gIFwiaG9uZXlkZXdcIjogWzI0MCwyNTUsMjQwLDFdLCBcImhvdHBpbmtcIjogWzI1NSwxMDUsMTgwLDFdLFxuICBcImluZGlhbnJlZFwiOiBbMjA1LDkyLDkyLDFdLCBcImluZGlnb1wiOiBbNzUsMCwxMzAsMV0sXG4gIFwiaXZvcnlcIjogWzI1NSwyNTUsMjQwLDFdLCBcImtoYWtpXCI6IFsyNDAsMjMwLDE0MCwxXSxcbiAgXCJsYXZlbmRlclwiOiBbMjMwLDIzMCwyNTAsMV0sIFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LDI0MCwyNDUsMV0sXG4gIFwibGF3bmdyZWVuXCI6IFsxMjQsMjUyLDAsMV0sIFwibGVtb25jaGlmZm9uXCI6IFsyNTUsMjUwLDIwNSwxXSxcbiAgXCJsaWdodGJsdWVcIjogWzE3MywyMTYsMjMwLDFdLCBcImxpZ2h0Y29yYWxcIjogWzI0MCwxMjgsMTI4LDFdLFxuICBcImxpZ2h0Y3lhblwiOiBbMjI0LDI1NSwyNTUsMV0sIFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwyNTAsMjEwLDFdLFxuICBcImxpZ2h0Z3JheVwiOiBbMjExLDIxMSwyMTEsMV0sIFwibGlnaHRncmVlblwiOiBbMTQ0LDIzOCwxNDQsMV0sXG4gIFwibGlnaHRncmV5XCI6IFsyMTEsMjExLDIxMSwxXSwgXCJsaWdodHBpbmtcIjogWzI1NSwxODIsMTkzLDFdLFxuICBcImxpZ2h0c2FsbW9uXCI6IFsyNTUsMTYwLDEyMiwxXSwgXCJsaWdodHNlYWdyZWVuXCI6IFszMiwxNzgsMTcwLDFdLFxuICBcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1LDIwNiwyNTAsMV0sIFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwxMzYsMTUzLDFdLFxuICBcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksMTM2LDE1MywxXSwgXCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2LDE5NiwyMjIsMV0sXG4gIFwibGlnaHR5ZWxsb3dcIjogWzI1NSwyNTUsMjI0LDFdLCBcImxpbWVcIjogWzAsMjU1LDAsMV0sXG4gIFwibGltZWdyZWVuXCI6IFs1MCwyMDUsNTAsMV0sIFwibGluZW5cIjogWzI1MCwyNDAsMjMwLDFdLFxuICBcIm1hZ2VudGFcIjogWzI1NSwwLDI1NSwxXSwgXCJtYXJvb25cIjogWzEyOCwwLDAsMV0sXG4gIFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLDIwNSwxNzAsMV0sIFwibWVkaXVtYmx1ZVwiOiBbMCwwLDIwNSwxXSxcbiAgXCJtZWRpdW1vcmNoaWRcIjogWzE4Niw4NSwyMTEsMV0sIFwibWVkaXVtcHVycGxlXCI6IFsxNDcsMTEyLDIxOSwxXSxcbiAgXCJtZWRpdW1zZWFncmVlblwiOiBbNjAsMTc5LDExMywxXSwgXCJtZWRpdW1zbGF0ZWJsdWVcIjogWzEyMywxMDQsMjM4LDFdLFxuICBcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLDI1MCwxNTQsMV0sIFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwyMDksMjA0LDFdLFxuICBcIm1lZGl1bXZpb2xldHJlZFwiOiBbMTk5LDIxLDEzMywxXSwgXCJtaWRuaWdodGJsdWVcIjogWzI1LDI1LDExMiwxXSxcbiAgXCJtaW50Y3JlYW1cIjogWzI0NSwyNTUsMjUwLDFdLCBcIm1pc3R5cm9zZVwiOiBbMjU1LDIyOCwyMjUsMV0sXG4gIFwibW9jY2FzaW5cIjogWzI1NSwyMjgsMTgxLDFdLCBcIm5hdmFqb3doaXRlXCI6IFsyNTUsMjIyLDE3MywxXSxcbiAgXCJuYXZ5XCI6IFswLDAsMTI4LDFdLCBcIm9sZGxhY2VcIjogWzI1MywyNDUsMjMwLDFdLFxuICBcIm9saXZlXCI6IFsxMjgsMTI4LDAsMV0sIFwib2xpdmVkcmFiXCI6IFsxMDcsMTQyLDM1LDFdLFxuICBcIm9yYW5nZVwiOiBbMjU1LDE2NSwwLDFdLCBcIm9yYW5nZXJlZFwiOiBbMjU1LDY5LDAsMV0sXG4gIFwib3JjaGlkXCI6IFsyMTgsMTEyLDIxNCwxXSwgXCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsMjMyLDE3MCwxXSxcbiAgXCJwYWxlZ3JlZW5cIjogWzE1MiwyNTEsMTUyLDFdLCBcInBhbGV0dXJxdW9pc2VcIjogWzE3NSwyMzgsMjM4LDFdLFxuICBcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwxMTIsMTQ3LDFdLCBcInBhcGF5YXdoaXBcIjogWzI1NSwyMzksMjEzLDFdLFxuICBcInBlYWNocHVmZlwiOiBbMjU1LDIxOCwxODUsMV0sIFwicGVydVwiOiBbMjA1LDEzMyw2MywxXSxcbiAgXCJwaW5rXCI6IFsyNTUsMTkyLDIwMywxXSwgXCJwbHVtXCI6IFsyMjEsMTYwLDIyMSwxXSxcbiAgXCJwb3dkZXJibHVlXCI6IFsxNzYsMjI0LDIzMCwxXSwgXCJwdXJwbGVcIjogWzEyOCwwLDEyOCwxXSxcbiAgXCJyZWRcIjogWzI1NSwwLDAsMV0sIFwicm9zeWJyb3duXCI6IFsxODgsMTQzLDE0MywxXSxcbiAgXCJyb3lhbGJsdWVcIjogWzY1LDEwNSwyMjUsMV0sIFwic2FkZGxlYnJvd25cIjogWzEzOSw2OSwxOSwxXSxcbiAgXCJzYWxtb25cIjogWzI1MCwxMjgsMTE0LDFdLCBcInNhbmR5YnJvd25cIjogWzI0NCwxNjQsOTYsMV0sXG4gIFwic2VhZ3JlZW5cIjogWzQ2LDEzOSw4NywxXSwgXCJzZWFzaGVsbFwiOiBbMjU1LDI0NSwyMzgsMV0sXG4gIFwic2llbm5hXCI6IFsxNjAsODIsNDUsMV0sIFwic2lsdmVyXCI6IFsxOTIsMTkyLDE5MiwxXSxcbiAgXCJza3libHVlXCI6IFsxMzUsMjA2LDIzNSwxXSwgXCJzbGF0ZWJsdWVcIjogWzEwNiw5MCwyMDUsMV0sXG4gIFwic2xhdGVncmF5XCI6IFsxMTIsMTI4LDE0NCwxXSwgXCJzbGF0ZWdyZXlcIjogWzExMiwxMjgsMTQ0LDFdLFxuICBcInNub3dcIjogWzI1NSwyNTAsMjUwLDFdLCBcInNwcmluZ2dyZWVuXCI6IFswLDI1NSwxMjcsMV0sXG4gIFwic3RlZWxibHVlXCI6IFs3MCwxMzAsMTgwLDFdLCBcInRhblwiOiBbMjEwLDE4MCwxNDAsMV0sXG4gIFwidGVhbFwiOiBbMCwxMjgsMTI4LDFdLCBcInRoaXN0bGVcIjogWzIxNiwxOTEsMjE2LDFdLFxuICBcInRvbWF0b1wiOiBbMjU1LDk5LDcxLDFdLCBcInR1cnF1b2lzZVwiOiBbNjQsMjI0LDIwOCwxXSxcbiAgXCJ2aW9sZXRcIjogWzIzOCwxMzAsMjM4LDFdLCBcIndoZWF0XCI6IFsyNDUsMjIyLDE3OSwxXSxcbiAgXCJ3aGl0ZVwiOiBbMjU1LDI1NSwyNTUsMV0sIFwid2hpdGVzbW9rZVwiOiBbMjQ1LDI0NSwyNDUsMV0sXG4gIFwieWVsbG93XCI6IFsyNTUsMjU1LDAsMV0sIFwieWVsbG93Z3JlZW5cIjogWzE1NCwyMDUsNTAsMV19XG5cbmZ1bmN0aW9uIGNsYW1wX2Nzc19ieXRlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuXG4gIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbn1cblxuZnVuY3Rpb24gY2xhbXBfY3NzX2Zsb2F0KGYpIHsgIC8vIENsYW1wIHRvIGZsb2F0IDAuMCAuLiAxLjAuXG4gIHJldHVybiBmIDwgMCA/IDAgOiBmID4gMSA/IDEgOiBmO1xufVxuXG5mdW5jdGlvbiBwYXJzZV9jc3NfaW50KHN0cikgeyAgLy8gaW50IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpXG4gICAgcmV0dXJuIGNsYW1wX2Nzc19ieXRlKHBhcnNlRmxvYXQoc3RyKSAvIDEwMCAqIDI1NSk7XG4gIHJldHVybiBjbGFtcF9jc3NfYnl0ZShwYXJzZUludChzdHIpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VfY3NzX2Zsb2F0KHN0cikgeyAgLy8gZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICclJylcbiAgICByZXR1cm4gY2xhbXBfY3NzX2Zsb2F0KHBhcnNlRmxvYXQoc3RyKSAvIDEwMCk7XG4gIHJldHVybiBjbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpKTtcbn1cblxuZnVuY3Rpb24gY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKSB7XG4gIGlmIChoIDwgMCkgaCArPSAxO1xuICBlbHNlIGlmIChoID4gMSkgaCAtPSAxO1xuXG4gIGlmIChoICogNiA8IDEpIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggKiA2O1xuICBpZiAoaCAqIDIgPCAxKSByZXR1cm4gbTI7XG4gIGlmIChoICogMyA8IDIpIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyLzMgLSBoKSAqIDY7XG4gIHJldHVybiBtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDU1NDb2xvcihjc3Nfc3RyKSB7XG4gIC8vIFJlbW92ZSBhbGwgd2hpdGVzcGFjZSwgbm90IGNvbXBsaWFudCwgYnV0IHNob3VsZCBqdXN0IGJlIG1vcmUgYWNjZXB0aW5nLlxuICB2YXIgc3RyID0gY3NzX3N0ci5yZXBsYWNlKC8gL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIENvbG9yIGtleXdvcmRzIChhbmQgdHJhbnNwYXJlbnQpIGxvb2t1cC5cbiAgaWYgKHN0ciBpbiBrQ1NTQ29sb3JUYWJsZSkgcmV0dXJuIGtDU1NDb2xvclRhYmxlW3N0cl0uc2xpY2UoKTsgIC8vIGR1cC5cblxuICAvLyAjYWJjIGFuZCAjYWJjMTIzIHN5bnRheC5cbiAgaWYgKHN0clswXSA9PT0gJyMnKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDQpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZikpIHJldHVybiBudWxsOyAgLy8gQ292ZXJzIE5hTi5cbiAgICAgIHJldHVybiBbKChpdiAmIDB4ZjAwKSA+PiA0KSB8ICgoaXYgJiAweGYwMCkgPj4gOCksXG4gICAgICAgICAgICAgIChpdiAmIDB4ZjApIHwgKChpdiAmIDB4ZjApID4+IDQpLFxuICAgICAgICAgICAgICAoaXYgJiAweGYpIHwgKChpdiAmIDB4ZikgPDwgNCksXG4gICAgICAgICAgICAgIDFdO1xuICAgIH0gZWxzZSBpZiAoc3RyLmxlbmd0aCA9PT0gNykge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmZmZmKSkgcmV0dXJuIG51bGw7ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgcmV0dXJuIFsoaXYgJiAweGZmMDAwMCkgPj4gMTYsXG4gICAgICAgICAgICAgIChpdiAmIDB4ZmYwMCkgPj4gOCxcbiAgICAgICAgICAgICAgaXYgJiAweGZmLFxuICAgICAgICAgICAgICAxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBvcCA9IHN0ci5pbmRleE9mKCcoJyksIGVwID0gc3RyLmluZGV4T2YoJyknKTtcbiAgaWYgKG9wICE9PSAtMSAmJiBlcCArIDEgPT09IHN0ci5sZW5ndGgpIHtcbiAgICB2YXIgZm5hbWUgPSBzdHIuc3Vic3RyKDAsIG9wKTtcbiAgICB2YXIgcGFyYW1zID0gc3RyLnN1YnN0cihvcCsxLCBlcC0ob3ArMSkpLnNwbGl0KCcsJyk7XG4gICAgdmFyIGFscGhhID0gMTsgIC8vIFRvIGFsbG93IGNhc2UgZmFsbHRocm91Z2guXG4gICAgc3dpdGNoIChmbmFtZSkge1xuICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgYWxwaGEgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gW3BhcnNlX2Nzc19pbnQocGFyYW1zWzBdKSxcbiAgICAgICAgICAgICAgICBwYXJzZV9jc3NfaW50KHBhcmFtc1sxXSksXG4gICAgICAgICAgICAgICAgcGFyc2VfY3NzX2ludChwYXJhbXNbMl0pLFxuICAgICAgICAgICAgICAgIGFscGhhXTtcbiAgICAgIGNhc2UgJ2hzbGEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGFscGhhID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGggPSAoKChwYXJzZUZsb2F0KHBhcmFtc1swXSkgJSAzNjApICsgMzYwKSAlIDM2MCkgLyAzNjA7ICAvLyAwIC4uIDFcbiAgICAgICAgLy8gTk9URShkZWFubSk6IEFjY29yZGluZyB0byB0aGUgQ1NTIHNwZWMgcy9sIHNob3VsZCBvbmx5IGJlXG4gICAgICAgIC8vIHBlcmNlbnRhZ2VzLCBidXQgd2UgZG9uJ3QgYm90aGVyIGFuZCBsZXQgZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgdmFyIHMgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zWzFdKTtcbiAgICAgICAgdmFyIGwgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zWzJdKTtcbiAgICAgICAgdmFyIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHZhciBtMSA9IGwgKiAyIC0gbTI7XG4gICAgICAgIHJldHVybiBbY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKzEvMykgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGNsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCkgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGNsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaC0xLzMpICogMjU1KSxcbiAgICAgICAgICAgICAgICBhbHBoYV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudHJ5IHsgZXhwb3J0cy5wYXJzZUNTU0NvbG9yID0gcGFyc2VDU1NDb2xvciB9IGNhdGNoKGUpIHsgfVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gZHVwZV9hcnJheShjb3VudCwgdmFsdWUsIGkpIHtcbiAgdmFyIGMgPSBjb3VudFtpXXwwXG4gIGlmKGMgPD0gMCkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYyksIGpcbiAgaWYoaSA9PT0gY291bnQubGVuZ3RoLTEpIHtcbiAgICBmb3Ioaj0wOyBqPGM7ICsraikge1xuICAgICAgcmVzdWx0W2pdID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yKGo9MDsgajxjOyArK2opIHtcbiAgICAgIHJlc3VsdFtqXSA9IGR1cGVfYXJyYXkoY291bnQsIHZhbHVlLCBpKzEpXG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gZHVwZV9udW1iZXIoY291bnQsIHZhbHVlKSB7XG4gIHZhciByZXN1bHQsIGlcbiAgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KVxuICBmb3IoaT0wOyBpPGNvdW50OyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSB2YWx1ZVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gZHVwZShjb3VudCwgdmFsdWUpIHtcbiAgaWYodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFsdWUgPSAwXG4gIH1cbiAgc3dpdGNoKHR5cGVvZiBjb3VudCkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGlmKGNvdW50ID4gMCkge1xuICAgICAgICByZXR1cm4gZHVwZV9udW1iZXIoY291bnR8MCwgdmFsdWUpXG4gICAgICB9XG4gICAgYnJlYWtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZih0eXBlb2YgKGNvdW50Lmxlbmd0aCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIGR1cGVfYXJyYXkoY291bnQsIHZhbHVlLCAwKVxuICAgICAgfVxuICAgIGJyZWFrXG4gIH1cbiAgcmV0dXJuIFtdXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZHVwZSIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBlYXJjdXQ7XG5cbmZ1bmN0aW9uIGVhcmN1dChwb2ludHMpIHtcblxuICAgIHZhciBvdXRlck5vZGUgPSBsaW5rZWRMaXN0KHBvaW50c1swXSwgdHJ1ZSksXG4gICAgICAgIG5vZGUsIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIHNpemUsXG4gICAgICAgIGxlbiA9IDAsXG4gICAgICAgIHRocmVzaG9sZCA9IDgwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGxlbiA8IHRocmVzaG9sZCAmJiBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSBsZW4gKz0gcG9pbnRzW2ldLmxlbmd0aDtcblxuICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxuICAgIGlmIChsZW4gPj0gdGhyZXNob2xkKSB7XG4gICAgICAgIG5vZGUgPSBvdXRlck5vZGUubmV4dDtcbiAgICAgICAgbWluWCA9IG1heFggPSBub2RlLnBbMF07XG4gICAgICAgIG1pblkgPSBtYXhZID0gbm9kZS5wWzFdO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB4ID0gbm9kZS5wWzBdO1xuICAgICAgICAgICAgeSA9IG5vZGUucFsxXTtcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9IHdoaWxlIChub2RlICE9PSBvdXRlck5vZGUpO1xuXG4gICAgICAgIC8vIG1pblgsIG1pblkgYW5kIHNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXG4gICAgICAgIHNpemUgPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgIH1cblxuICAgIGlmIChwb2ludHMubGVuZ3RoID4gMSkgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMocG9pbnRzLCBvdXRlck5vZGUpO1xuXG4gICAgdmFyIHRyaWFuZ2xlcyA9IFtdO1xuICAgIGlmIChvdXRlck5vZGUpIGVhcmN1dExpbmtlZChvdXRlck5vZGUsIHRyaWFuZ2xlcywgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xufVxuXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbmZ1bmN0aW9uIGxpbmtlZExpc3QocG9pbnRzLCBjbG9ja3dpc2UpIHtcbiAgICB2YXIgc3VtID0gMCxcbiAgICAgICAgbGVuID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgaSwgaiwgbGFzdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBvcmlnaW5hbCB3aW5kaW5nIG9yZGVyIG9mIGEgcG9seWdvbiByaW5nXG4gICAgZm9yIChpID0gMCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcbiAgICAgICAgdmFyIHAxID0gcG9pbnRzW2ldLFxuICAgICAgICAgICAgcDIgPSBwb2ludHNbal07XG4gICAgICAgIHN1bSArPSAocDJbMF0gLSBwMVswXSkgKiAocDFbMV0gKyBwMlsxXSk7XG4gICAgfVxuXG4gICAgLy8gbGluayBwb2ludHMgaW50byBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3QgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG4gICAgaWYgKGNsb2Nrd2lzZSA9PT0gKHN1bSA+IDApKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykgbGFzdCA9IGluc2VydE5vZGUocG9pbnRzW2ldLCBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkgbGFzdCA9IGluc2VydE5vZGUocG9pbnRzW2ldLCBsYXN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFzdDtcbn1cblxuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKHN0YXJ0KSB7XG4gICAgLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcbiAgICB2YXIgbm9kZSA9IHN0YXJ0LFxuICAgICAgICBhZ2FpbjtcbiAgICBkbyB7XG4gICAgICAgIGFnYWluID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGVxdWFscyhub2RlLnAsIG5vZGUubmV4dC5wKSB8fCBvcmllbnQobm9kZS5wcmV2LnAsIG5vZGUucCwgbm9kZS5uZXh0LnApID09PSAwKSB7XG5cbiAgICAgICAgICAgIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG5cbiAgICAgICAgICAgIGlmIChub2RlLnByZXZaKSBub2RlLnByZXZaLm5leHRaID0gbm9kZS5uZXh0WjtcbiAgICAgICAgICAgIGlmIChub2RlLm5leHRaKSBub2RlLm5leHRaLnByZXZaID0gbm9kZS5wcmV2WjtcblxuICAgICAgICAgICAgbm9kZSA9IHN0YXJ0ID0gbm9kZS5wcmV2O1xuXG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gbm9kZS5uZXh0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGFnYWluIHx8IG5vZGUgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBzdGFydDtcbn1cblxuZnVuY3Rpb24gZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplLCBzZWNvbmRQYXNzKSB7XG4gICAgZWFyID0gZmlsdGVyUG9pbnRzKGVhcik7XG4gICAgaWYgKCFlYXIpIHJldHVybjtcblxuICAgIGlmICghc2Vjb25kUGFzcyAmJiBtaW5YICE9PSB1bmRlZmluZWQpIGluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBzaXplKTtcblxuICAgIHZhciBzdG9wID0gZWFyLFxuICAgICAgICBwcmV2LCBuZXh0O1xuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG4gICAgd2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xuICAgICAgICBwcmV2ID0gZWFyLnByZXY7XG4gICAgICAgIG5leHQgPSBlYXIubmV4dDtcblxuICAgICAgICBpZiAoaXNFYXIoZWFyLCBtaW5YLCBtaW5ZLCBzaXplKSkge1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocHJldi5wLCBlYXIucCwgbmV4dC5wKTtcblxuICAgICAgICAgICAgbmV4dC5wcmV2ID0gcHJldjtcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG5cbiAgICAgICAgICAgIGlmIChlYXIucHJldlopIGVhci5wcmV2Wi5uZXh0WiA9IGVhci5uZXh0WjtcbiAgICAgICAgICAgIGlmIChlYXIubmV4dFopIGVhci5uZXh0Wi5wcmV2WiA9IGVhci5wcmV2WjtcblxuICAgICAgICAgICAgZWFyID0gbmV4dC5uZXh0O1xuICAgICAgICAgICAgc3RvcCA9IG5leHQubmV4dDtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBlYXIgPSBuZXh0O1xuXG4gICAgICAgIGlmIChlYXIgPT09IHN0b3ApIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGZpbmQgYW55IG1vcmUgZWFycywgdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIGN1dHRpbmcgYWdhaW5cbiAgICAgICAgICAgIGlmICghc2Vjb25kUGFzcykgZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlkbid0IHdvcmssIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG4gICAgICAgICAgICBlbHNlIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0VhcihlYXIsIG1pblgsIG1pblksIHNpemUpIHtcblxuICAgIHZhciBhID0gZWFyLnByZXYucCxcbiAgICAgICAgYiA9IGVhci5wLFxuICAgICAgICBjID0gZWFyLm5leHQucCxcblxuICAgICAgICBheCA9IGFbMF0sIGJ4ID0gYlswXSwgY3ggPSBjWzBdLFxuICAgICAgICBheSA9IGFbMV0sIGJ5ID0gYlsxXSwgY3kgPSBjWzFdLFxuXG4gICAgICAgIGFiZCA9IGF4ICogYnkgLSBheSAqIGJ4LFxuICAgICAgICBhY2QgPSBheCAqIGN5IC0gYXkgKiBjeCxcbiAgICAgICAgY2JkID0gY3ggKiBieSAtIGN5ICogYngsXG4gICAgICAgIEEgPSBhYmQgLSBhY2QgLSBjYmQ7XG5cbiAgICBpZiAoQSA8PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxuXG4gICAgdmFyIGNheSA9IGN5IC0gYXksXG4gICAgICAgIGFjeCA9IGF4IC0gY3gsXG4gICAgICAgIGFieSA9IGF5IC0gYnksXG4gICAgICAgIGJheCA9IGJ4IC0gYXgsXG4gICAgICAgIHAsIHB4LCBweSwgcywgdCwgaywgbm9kZTtcblxuICAgIC8vIGlmIHdlIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2hpbmcsIGl0ZXJhdGUgdGhyb3VnaCB0aGUgY3VydmVcbiAgICBpZiAobWluWCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICAgICAgdmFyIG1pblRYID0gYXggPCBieCA/IChheCA8IGN4ID8gYXggOiBjeCkgOiAoYnggPCBjeCA/IGJ4IDogY3gpLFxuICAgICAgICAgICAgbWluVFkgPSBheSA8IGJ5ID8gKGF5IDwgY3kgPyBheSA6IGN5KSA6IChieSA8IGN5ID8gYnkgOiBjeSksXG4gICAgICAgICAgICBtYXhUWCA9IGF4ID4gYnggPyAoYXggPiBjeCA/IGF4IDogY3gpIDogKGJ4ID4gY3ggPyBieCA6IGN4KSxcbiAgICAgICAgICAgIG1heFRZID0gYXkgPiBieSA/IChheSA+IGN5ID8gYXkgOiBjeSkgOiAoYnkgPiBjeSA/IGJ5IDogY3kpLFxuXG4gICAgICAgICAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuICAgICAgICAgICAgbWluWiA9IHpPcmRlcihtaW5UWCwgbWluVFksIG1pblgsIG1pblksIHNpemUpLFxuICAgICAgICAgICAgbWF4WiA9IHpPcmRlcihtYXhUWCwgbWF4VFksIG1pblgsIG1pblksIHNpemUpO1xuXG4gICAgICAgIC8vIGZpcnN0IGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGluY3JlYXNpbmcgei1vcmRlclxuICAgICAgICBub2RlID0gZWFyLm5leHRaO1xuXG4gICAgICAgIHdoaWxlIChub2RlICYmIG5vZGUueiA8PSBtYXhaKSB7XG4gICAgICAgICAgICBwID0gbm9kZS5wO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFo7XG4gICAgICAgICAgICBpZiAocCA9PT0gYSB8fCBwID09PSBjKSBjb250aW51ZTtcblxuICAgICAgICAgICAgcHggPSBwWzBdO1xuICAgICAgICAgICAgcHkgPSBwWzFdO1xuXG4gICAgICAgICAgICBzID0gY2F5ICogcHggKyBhY3ggKiBweSAtIGFjZDtcbiAgICAgICAgICAgIGlmIChzID49IDApIHtcbiAgICAgICAgICAgICAgICB0ID0gYWJ5ICogcHggKyBiYXggKiBweSArIGFiZDtcbiAgICAgICAgICAgICAgICBpZiAodCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBBIC0gcyAtIHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoayA+PSAwKSAmJiAoKHMgJiYgdCkgfHwgKHMgJiYgaykgfHwgKHQgJiYgaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlbiBsb29rIGZvciBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXG4gICAgICAgIG5vZGUgPSBlYXIucHJldlo7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZS56ID49IG1pblopIHtcbiAgICAgICAgICAgIHAgPSBub2RlLnA7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wcmV2WjtcbiAgICAgICAgICAgIGlmIChwID09PSBhIHx8IHAgPT09IGMpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBweCA9IHBbMF07XG4gICAgICAgICAgICBweSA9IHBbMV07XG5cbiAgICAgICAgICAgIHMgPSBjYXkgKiBweCArIGFjeCAqIHB5IC0gYWNkO1xuICAgICAgICAgICAgaWYgKHMgPj0gMCkge1xuICAgICAgICAgICAgICAgIHQgPSBhYnkgKiBweCArIGJheCAqIHB5ICsgYWJkO1xuICAgICAgICAgICAgICAgIGlmICh0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IEEgLSBzIC0gdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChrID49IDApICYmICgocyAmJiB0KSB8fCAocyAmJiBrKSB8fCAodCAmJiBrKSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIC8vIGlmIHdlIGRvbid0IHVzZSB6LW9yZGVyIGN1cnZlIGhhc2gsIHNpbXBseSBpdGVyYXRlIHRocm91Z2ggYWxsIG90aGVyIHBvaW50c1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBlYXIubmV4dC5uZXh0O1xuXG4gICAgICAgIHdoaWxlIChub2RlICE9PSBlYXIucHJldikge1xuICAgICAgICAgICAgcCA9IG5vZGUucDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG5cbiAgICAgICAgICAgIHB4ID0gcFswXTtcbiAgICAgICAgICAgIHB5ID0gcFsxXTtcblxuICAgICAgICAgICAgcyA9IGNheSAqIHB4ICsgYWN4ICogcHkgLSBhY2Q7XG4gICAgICAgICAgICBpZiAocyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdCA9IGFieSAqIHB4ICsgYmF4ICogcHkgKyBhYmQ7XG4gICAgICAgICAgICAgICAgaWYgKHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBrID0gQSAtIHMgLSB0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGsgPj0gMCkgJiYgKChzICYmIHQpIHx8IChzICYmIGspIHx8ICh0ICYmIGspKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzcGxpdEVhcmN1dChzdGFydCwgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgLy8gZmluZCBhIHZhbGlkIGRpYWdvbmFsIHRoYXQgZGl2aWRlcyB0aGUgcG9seWdvbiBpbnRvIHR3b1xuICAgIHZhciBhID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYiA9IGEubmV4dC5uZXh0O1xuICAgICAgICB3aGlsZSAoYiAhPT0gYS5wcmV2KSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZERpYWdvbmFsKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxuICAgICAgICAgICAgICAgIHZhciBjID0gc3BsaXRQb2x5Z29uKGEsIGIpO1xuXG4gICAgICAgICAgICAgICAgLy8gcnVuIGVhcmN1dCBvbiBlYWNoIGhhbGZcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYSwgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYywgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhLm5leHQ7XG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xufVxuXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhwb2ludHMsIG91dGVyTm9kZSkge1xuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgdmFyIHF1ZXVlID0gW107XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgbGlzdCA9IGZpbHRlclBvaW50cyhsaW5rZWRMaXN0KHBvaW50c1tpXSwgZmFsc2UpKTtcbiAgICAgICAgaWYgKGxpc3QpIHF1ZXVlLnB1c2goZ2V0TGVmdG1vc3QobGlzdCkpO1xuICAgIH1cbiAgICBxdWV1ZS5zb3J0KGNvbXBhcmVYKTtcblxuICAgIC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gICAgZm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsaW1pbmF0ZUhvbGUocXVldWVbaV0sIG91dGVyTm9kZSk7XG4gICAgICAgIG91dGVyTm9kZSA9IGZpbHRlclBvaW50cyhvdXRlck5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59XG5cbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoaG9sZU5vZGUsIG91dGVyTm9kZSkge1xuICAgIG91dGVyTm9kZSA9IGZpbmRIb2xlQnJpZGdlKGhvbGVOb2RlLCBvdXRlck5vZGUpO1xuICAgIGlmIChvdXRlck5vZGUpIHNwbGl0UG9seWdvbihob2xlTm9kZSwgb3V0ZXJOb2RlKTtcbn1cblxuLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoaG9sZU5vZGUsIG91dGVyTm9kZSkge1xuICAgIHZhciBub2RlID0gb3V0ZXJOb2RlLFxuICAgICAgICBwID0gaG9sZU5vZGUucCxcbiAgICAgICAgcHggPSBwWzBdLFxuICAgICAgICBweSA9IHBbMV0sXG4gICAgICAgIHFNYXggPSAtSW5maW5pdHksXG4gICAgICAgIG1Ob2RlLCBhLCBiO1xuXG4gICAgLy8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xuICAgIC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcbiAgICBkbyB7XG4gICAgICAgIGEgPSBub2RlLnA7XG4gICAgICAgIGIgPSBub2RlLm5leHQucDtcblxuICAgICAgICBpZiAocHkgPD0gYVsxXSAmJiBweSA+PSBiWzFdKSB7XG4gICAgICAgICAgICB2YXIgcXggPSBhWzBdICsgKHB5IC0gYVsxXSkgKiAoYlswXSAtIGFbMF0pIC8gKGJbMV0gLSBhWzFdKTtcbiAgICAgICAgICAgIGlmIChxeCA8PSBweCAmJiBxeCA+IHFNYXgpIHtcbiAgICAgICAgICAgICAgICBxTWF4ID0gcXg7XG4gICAgICAgICAgICAgICAgbU5vZGUgPSBhWzBdIDwgYlswXSA/IG5vZGUgOiBub2RlLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9IHdoaWxlIChub2RlICE9PSBvdXRlck5vZGUpO1xuXG4gICAgaWYgKCFtTm9kZSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgc3RyaWN0bHkgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XG4gICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcblxuICAgIHZhciBieCA9IG1Ob2RlLnBbMF0sXG4gICAgICAgIGJ5ID0gbU5vZGUucFsxXSxcbiAgICAgICAgcGJkID0gcHggKiBieSAtIHB5ICogYngsXG4gICAgICAgIHBjZCA9IHB4ICogcHkgLSBweSAqIHFNYXgsXG4gICAgICAgIGNweSA9IHB5IC0gcHksXG4gICAgICAgIHBjeCA9IHB4IC0gcU1heCxcbiAgICAgICAgcGJ5ID0gcHkgLSBieSxcbiAgICAgICAgYnB4ID0gYnggLSBweCxcbiAgICAgICAgQSA9IHBiZCAtIHBjZCAtIChxTWF4ICogYnkgLSBweSAqIGJ4KSxcbiAgICAgICAgc2lnbiA9IEEgPD0gMCA/IC0xIDogMSxcbiAgICAgICAgc3RvcCA9IG1Ob2RlLFxuICAgICAgICB0YW5NaW4gPSBJbmZpbml0eSxcbiAgICAgICAgbXgsIG15LCBhbXgsIHMsIHQsIHRhbjtcblxuICAgIG5vZGUgPSBtTm9kZS5uZXh0O1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IHN0b3ApIHtcblxuICAgICAgICBteCA9IG5vZGUucFswXTtcbiAgICAgICAgbXkgPSBub2RlLnBbMV07XG4gICAgICAgIGFteCA9IHB4IC0gbXg7XG5cbiAgICAgICAgaWYgKGFteCA+PSAwICYmIG14ID49IGJ4KSB7XG4gICAgICAgICAgICBzID0gKGNweSAqIG14ICsgcGN4ICogbXkgLSBwY2QpICogc2lnbjtcbiAgICAgICAgICAgIGlmIChzID49IDApIHtcbiAgICAgICAgICAgICAgICB0ID0gKHBieSAqIG14ICsgYnB4ICogbXkgKyBwYmQpICogc2lnbjtcblxuICAgICAgICAgICAgICAgIGlmICh0ID49IDAgJiYgQSAqIHNpZ24gLSBzIC0gdCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKHB5IC0gbXkpIC8gYW14OyAvLyB0YW5nZW50aWFsXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YW4gPCB0YW5NaW4gJiYgbG9jYWxseUluc2lkZShub2RlLCBob2xlTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1Ob2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhbk1pbiA9IHRhbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1Ob2RlO1xufVxuXG5mdW5jdGlvbiBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydDtcblxuICAgIGRvIHtcbiAgICAgICAgbm9kZS56ID0gbm9kZS56IHx8IHpPcmRlcihub2RlLnBbMF0sIG5vZGUucFsxXSwgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgIG5vZGUucHJldlogPSBub2RlLnByZXY7XG4gICAgICAgIG5vZGUubmV4dFogPSBub2RlLm5leHQ7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfSB3aGlsZSAobm9kZSAhPT0gc3RhcnQpO1xuXG4gICAgbm9kZS5wcmV2Wi5uZXh0WiA9IG51bGw7XG4gICAgbm9kZS5wcmV2WiA9IG51bGw7XG5cbiAgICBzb3J0TGlua2VkKG5vZGUpO1xufVxuXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcbmZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xuICAgIHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcbiAgICAgICAgaW5TaXplID0gMTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHAgPSBsaXN0O1xuICAgICAgICBsaXN0ID0gbnVsbDtcbiAgICAgICAgdGFpbCA9IG51bGw7XG4gICAgICAgIG51bU1lcmdlcyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgIG51bU1lcmdlcysrO1xuICAgICAgICAgICAgcSA9IHA7XG4gICAgICAgICAgICBwU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwU2l6ZSsrO1xuICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgIGlmICghcSkgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHFTaXplID0gaW5TaXplO1xuXG4gICAgICAgICAgICB3aGlsZSAocFNpemUgPiAwIHx8IChxU2l6ZSA+IDAgJiYgcSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlID0gcTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHFTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxU2l6ZSA9PT0gMCB8fCAhcSkge1xuICAgICAgICAgICAgICAgICAgICBlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHBTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwLnogPD0gcS56KSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBwO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcFNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlID0gcTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHFTaXplLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRhaWwpIHRhaWwubmV4dFogPSBlO1xuICAgICAgICAgICAgICAgIGVsc2UgbGlzdCA9IGU7XG5cbiAgICAgICAgICAgICAgICBlLnByZXZaID0gdGFpbDtcbiAgICAgICAgICAgICAgICB0YWlsID0gZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcCA9IHE7XG4gICAgICAgIH1cblxuICAgICAgICB0YWlsLm5leHRaID0gbnVsbDtcblxuICAgICAgICBpZiAobnVtTWVyZ2VzIDw9IDEpIHJldHVybiBsaXN0O1xuXG4gICAgICAgIGluU2l6ZSAqPSAyO1xuICAgIH1cbn1cblxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgYmJveFxuZnVuY3Rpb24gek9yZGVyKHgsIHksIG1pblgsIG1pblksIHNpemUpIHtcbiAgICAvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gKDAuLjEwMDApIGludGVnZXIgcmFuZ2VcbiAgICB4ID0gMTAwMCAqICh4IC0gbWluWCkgLyBzaXplO1xuICAgIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICB5ID0gMTAwMCAqICh5IC0gbWluWSkgLyBzaXplO1xuICAgIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xuICAgIHZhciBub2RlID0gc3RhcnQsXG4gICAgICAgIGxlZnRtb3N0ID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAobm9kZS5wWzBdIDwgbGVmdG1vc3QucFswXSkgbGVmdG1vc3QgPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH0gd2hpbGUgKG5vZGUgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBsZWZ0bW9zdDtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcbiAgICByZXR1cm4gIWludGVyc2VjdHNQb2x5Z29uKGEsIGEucCwgYi5wKSAmJlxuICAgICAgICAgICBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiZcbiAgICAgICAgICAgbWlkZGxlSW5zaWRlKGEsIGEucCwgYi5wKTtcbn1cblxuLy8gd2luZGluZyBvcmRlciBvZiB0cmlhbmdsZSBmb3JtZWQgYnkgMyBnaXZlbiBwb2ludHNcbmZ1bmN0aW9uIG9yaWVudChwLCBxLCByKSB7XG4gICAgdmFyIG8gPSAocVsxXSAtIHBbMV0pICogKHJbMF0gLSBxWzBdKSAtIChxWzBdIC0gcFswXSkgKiAoclsxXSAtIHFbMV0pO1xuICAgIHJldHVybiBvID4gMCA/IDEgOlxuICAgICAgICAgICBvIDwgMCA/IC0xIDogMDtcbn1cblxuZnVuY3Rpb24gZXF1YWxzKHAxLCBwMikge1xuICAgIHJldHVybiBwMVswXSA9PT0gcDJbMF0gJiYgcDFbMV0gPT09IHAyWzFdO1xufVxuXG4vLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gICAgcmV0dXJuIG9yaWVudChwMSwgcTEsIHAyKSAhPT0gb3JpZW50KHAxLCBxMSwgcTIpICYmXG4gICAgICAgICAgIG9yaWVudChwMiwgcTIsIHAxKSAhPT0gb3JpZW50KHAyLCBxMiwgcTEpO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oc3RhcnQsIGEsIGIpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIHAxID0gbm9kZS5wLFxuICAgICAgICAgICAgcDIgPSBub2RlLm5leHQucDtcblxuICAgICAgICBpZiAocDEgIT09IGEgJiYgcDIgIT09IGEgJiYgcDEgIT09IGIgJiYgcDIgIT09IGIgJiYgaW50ZXJzZWN0cyhwMSwgcDIsIGEsIGIpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH0gd2hpbGUgKG5vZGUgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBsb2NhbGx5SW5zaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gb3JpZW50KGEucHJldi5wLCBhLnAsIGEubmV4dC5wKSA9PT0gLTEgP1xuICAgICAgICBvcmllbnQoYS5wLCBiLnAsIGEubmV4dC5wKSAhPT0gLTEgJiYgb3JpZW50KGEucCwgYS5wcmV2LnAsIGIucCkgIT09IC0xIDpcbiAgICAgICAgb3JpZW50KGEucCwgYi5wLCBhLnByZXYucCkgPT09IC0xIHx8IG9yaWVudChhLnAsIGEubmV4dC5wLCBiLnApID09PSAtMTtcbn1cblxuLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoc3RhcnQsIGEsIGIpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0LFxuICAgICAgICBpbnNpZGUgPSBmYWxzZSxcbiAgICAgICAgcHggPSAoYVswXSArIGJbMF0pIC8gMixcbiAgICAgICAgcHkgPSAoYVsxXSArIGJbMV0pIC8gMjtcbiAgICBkbyB7XG4gICAgICAgIHZhciBwMSA9IG5vZGUucCxcbiAgICAgICAgICAgIHAyID0gbm9kZS5uZXh0LnA7XG5cbiAgICAgICAgaWYgKCgocDFbMV0gPiBweSkgIT09IChwMlsxXSA+IHB5KSkgJiZcbiAgICAgICAgICAgIChweCA8IChwMlswXSAtIHAxWzBdKSAqIChweSAtIHAxWzFdKSAvIChwMlsxXSAtIHAxWzFdKSArIHAxWzBdKSkgaW5zaWRlID0gIWluc2lkZTtcblxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH0gd2hpbGUgKG5vZGUgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBpbnNpZGU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYKGEsIGIpIHtcbiAgICByZXR1cm4gYS5wWzBdIC0gYi5wWzBdO1xufVxuXG4vLyBzcGxpdCB0aGUgcG9seWdvbiB2ZXJ0aWNlcyBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpbmtlZCBsaXN0IGludG8gdHdvXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oYSwgYikge1xuICAgIHZhciBhMiA9IG5ldyBOb2RlKGEucCksXG4gICAgICAgIGIyID0gbmV3IE5vZGUoYi5wKSxcbiAgICAgICAgYW4gPSBhLm5leHQsXG4gICAgICAgIGJwID0gYi5wcmV2O1xuXG4gICAgYS5uZXh0ID0gYjtcbiAgICBiLnByZXYgPSBhO1xuXG4gICAgYTIubmV4dCA9IGFuO1xuICAgIGFuLnByZXYgPSBhMjtcblxuICAgIGIyLm5leHQgPSBhMjtcbiAgICBhMi5wcmV2ID0gYjI7XG5cbiAgICBicC5uZXh0ID0gYjI7XG4gICAgYjIucHJldiA9IGJwO1xuXG4gICAgcmV0dXJuIGEyO1xufVxuXG5mdW5jdGlvbiBpbnNlcnROb2RlKHBvaW50LCBsYXN0KSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgTm9kZShwb2ludCk7XG5cbiAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgbm9kZS5wcmV2ID0gbm9kZTtcbiAgICAgICAgbm9kZS5uZXh0ID0gbm9kZTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUubmV4dCA9IGxhc3QubmV4dDtcbiAgICAgICAgbm9kZS5wcmV2ID0gbGFzdDtcbiAgICAgICAgbGFzdC5uZXh0LnByZXYgPSBub2RlO1xuICAgICAgICBsYXN0Lm5leHQgPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gTm9kZShwKSB7XG4gICAgdGhpcy5wID0gcDtcbiAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG5cbiAgICB0aGlzLnogPSBudWxsO1xuICAgIHRoaXMucHJldlogPSBudWxsO1xuICAgIHRoaXMubmV4dFogPSBudWxsO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsaXA7XG5cbi8qIGNsaXAgZmVhdHVyZXMgYmV0d2VlbiB0d28gYXhpcy1wYXJhbGxlbCBsaW5lczpcbiAqICAgICB8ICAgICAgICB8XG4gKiAgX19ffF9fXyAgICAgfCAgICAgL1xuICogLyAgIHwgICBcXF9fX198X19fXy9cbiAqICAgICB8ICAgICAgICB8XG4gKi9cblxuZnVuY3Rpb24gY2xpcChmZWF0dXJlcywgc2NhbGUsIGsxLCBrMiwgYXhpcywgaW50ZXJzZWN0LCBtaW5BbGwsIG1heEFsbCkge1xuXG4gICAgazEgLz0gc2NhbGU7XG4gICAgazIgLz0gc2NhbGU7XG5cbiAgICBpZiAobWluQWxsID49IGsxICYmIG1heEFsbCA8PSBrMikgcmV0dXJuIGZlYXR1cmVzOyAvLyB0cml2aWFsIGFjY2VwdFxuICAgIGVsc2UgaWYgKG1pbkFsbCA+IGsyIHx8IG1heEFsbCA8IGsxKSByZXR1cm4gbnVsbDsgLy8gdHJpdmlhbCByZWplY3RcblxuICAgIHZhciBjbGlwcGVkID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlc1tpXSxcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gZmVhdHVyZS5nZW9tZXRyeSxcbiAgICAgICAgICAgIHR5cGUgPSBmZWF0dXJlLnR5cGUsXG4gICAgICAgICAgICBtaW4sIG1heDtcblxuICAgICAgICBtaW4gPSBmZWF0dXJlLm1pbltheGlzXTtcbiAgICAgICAgbWF4ID0gZmVhdHVyZS5tYXhbYXhpc107XG5cbiAgICAgICAgaWYgKG1pbiA+PSBrMSAmJiBtYXggPD0gazIpIHsgLy8gdHJpdmlhbCBhY2NlcHRcbiAgICAgICAgICAgIGNsaXBwZWQucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbiA+IGsyIHx8IG1heCA8IGsxKSBjb250aW51ZTsgLy8gdHJpdmlhbCByZWplY3RcblxuICAgICAgICB2YXIgc2xpY2VzID0gdHlwZSA9PT0gMSA/XG4gICAgICAgICAgICAgICAgY2xpcFBvaW50cyhnZW9tZXRyeSwgazEsIGsyLCBheGlzKSA6XG4gICAgICAgICAgICAgICAgY2xpcEdlb21ldHJ5KGdlb21ldHJ5LCBrMSwgazIsIGF4aXMsIGludGVyc2VjdCwgdHlwZSA9PT0gMyk7XG5cbiAgICAgICAgaWYgKHNsaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGlmIGEgZmVhdHVyZSBnb3QgY2xpcHBlZCwgaXQgd2lsbCBsaWtlbHkgZ2V0IGNsaXBwZWQgb24gdGhlIG5leHQgem9vbSBsZXZlbCBhcyB3ZWxsLFxuICAgICAgICAgICAgLy8gc28gdGhlcmUncyBubyBuZWVkIHRvIHJlY2FsY3VsYXRlIGJib3hlc1xuICAgICAgICAgICAgY2xpcHBlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogc2xpY2VzLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgdGFnczogZmVhdHVyZXNbaV0udGFncyB8fCBudWxsLFxuICAgICAgICAgICAgICAgIG1pbjogZmVhdHVyZS5taW4sXG4gICAgICAgICAgICAgICAgbWF4OiBmZWF0dXJlLm1heFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xpcHBlZC5sZW5ndGggPyBjbGlwcGVkIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gY2xpcFBvaW50cyhnZW9tZXRyeSwgazEsIGsyLCBheGlzKSB7XG4gICAgdmFyIHNsaWNlID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhID0gZ2VvbWV0cnlbaV0sXG4gICAgICAgICAgICBhayA9IGFbYXhpc107XG5cbiAgICAgICAgaWYgKGFrID49IGsxICYmIGFrIDw9IGsyKSBzbGljZS5wdXNoKGEpO1xuICAgIH1cbiAgICByZXR1cm4gc2xpY2U7XG59XG5cbmZ1bmN0aW9uIGNsaXBHZW9tZXRyeShnZW9tZXRyeSwgazEsIGsyLCBheGlzLCBpbnRlcnNlY3QsIGNsb3NlZCkge1xuXG4gICAgdmFyIHNsaWNlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeS5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIHZhciBhayA9IDAsXG4gICAgICAgICAgICBiayA9IDAsXG4gICAgICAgICAgICBiID0gbnVsbCxcbiAgICAgICAgICAgIHBvaW50cyA9IGdlb21ldHJ5W2ldLFxuICAgICAgICAgICAgYXJlYSA9IHBvaW50cy5hcmVhLFxuICAgICAgICAgICAgZGlzdCA9IHBvaW50cy5kaXN0LFxuICAgICAgICAgICAgbGVuID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGEsIGosIGxhc3Q7XG5cbiAgICAgICAgdmFyIHNsaWNlID0gW107XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbiAtIDE7IGorKykge1xuICAgICAgICAgICAgYSA9IGIgfHwgcG9pbnRzW2pdO1xuICAgICAgICAgICAgYiA9IHBvaW50c1tqICsgMV07XG4gICAgICAgICAgICBhayA9IGJrIHx8IGFbYXhpc107XG4gICAgICAgICAgICBiayA9IGJbYXhpc107XG5cbiAgICAgICAgICAgIGlmIChhayA8IGsxKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoKGJrID4gazIpKSB7IC8vIC0tLXwtLS0tLXwtLT5cbiAgICAgICAgICAgICAgICAgICAgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazEpLCBpbnRlcnNlY3QoYSwgYiwgazIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHNsaWNlID0gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJrID49IGsxKSBzbGljZS5wdXNoKGludGVyc2VjdChhLCBiLCBrMSkpOyAvLyAtLS18LS0+ICB8XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWsgPiBrMikge1xuXG4gICAgICAgICAgICAgICAgaWYgKChiayA8IGsxKSkgeyAvLyA8LS18LS0tLS18LS0tXG4gICAgICAgICAgICAgICAgICAgIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsyKSwgaW50ZXJzZWN0KGEsIGIsIGsxKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSBzbGljZSA9IG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiayA8PSBrMikgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazIpKTsgLy8gfCAgPC0tfC0tLVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgc2xpY2UucHVzaChhKTtcblxuICAgICAgICAgICAgICAgIGlmIChiayA8IGsxKSB7IC8vIDwtLXwtLS0gIHxcbiAgICAgICAgICAgICAgICAgICAgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHNsaWNlID0gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJrID4gazIpIHsgLy8gfCAgLS0tfC0tPlxuICAgICAgICAgICAgICAgICAgICBzbGljZS5wdXNoKGludGVyc2VjdChhLCBiLCBrMikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZCkgc2xpY2UgPSBuZXdTbGljZShzbGljZXMsIHNsaWNlLCBhcmVhLCBkaXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gfCAtLT4gfFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoZSBsYXN0IHBvaW50XG4gICAgICAgIGEgPSBwb2ludHNbbGVuIC0gMV07XG4gICAgICAgIGFrID0gYVtheGlzXTtcbiAgICAgICAgaWYgKGFrID49IGsxICYmIGFrIDw9IGsyKSBzbGljZS5wdXNoKGEpO1xuXG4gICAgICAgIC8vIGNsb3NlIHRoZSBwb2x5Z29uIGlmIGl0cyBlbmRwb2ludHMgYXJlIG5vdCB0aGUgc2FtZSBhZnRlciBjbGlwcGluZ1xuXG4gICAgICAgIGxhc3QgPSBzbGljZVtzbGljZS5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGNsb3NlZCAmJiBsYXN0ICYmIChzbGljZVswXVswXSAhPT0gbGFzdFswXSB8fCBzbGljZVswXVsxXSAhPT0gbGFzdFsxXSkpIHNsaWNlLnB1c2goc2xpY2VbMF0pO1xuXG4gICAgICAgIC8vIGFkZCB0aGUgZmluYWwgc2xpY2VcbiAgICAgICAgbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNsaWNlcztcbn1cblxuZnVuY3Rpb24gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCkge1xuICAgIGlmIChzbGljZS5sZW5ndGgpIHtcbiAgICAgICAgLy8gd2UgZG9uJ3QgcmVjYWxjdWxhdGUgdGhlIGFyZWEvbGVuZ3RoIG9mIHRoZSB1bmNsaXBwZWQgZ2VvbWV0cnkgYmVjYXVzZSB0aGUgY2FzZSB3aGVyZSBpdCBnb2VzXG4gICAgICAgIC8vIGJlbG93IHRoZSB2aXNpYmlsaXR5IHRocmVzaG9sZCBhcyBhIHJlc3VsdCBvZiBjbGlwcGluZyBpcyByYXJlLCBzbyB3ZSBhdm9pZCBkb2luZyB1bm5lY2Vzc2FyeSB3b3JrXG4gICAgICAgIHNsaWNlLmFyZWEgPSBhcmVhO1xuICAgICAgICBzbGljZS5kaXN0ID0gZGlzdDtcblxuICAgICAgICBzbGljZXMucHVzaChzbGljZSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXJ0O1xuXG52YXIgc2ltcGxpZnkgPSByZXF1aXJlKCcuL3NpbXBsaWZ5Jyk7XG5cbi8vIGNvbnZlcnRzIEdlb0pTT04gZmVhdHVyZSBpbnRvIGFuIGludGVybWVkaWF0ZSBwcm9qZWN0ZWQgSlNPTiB2ZWN0b3IgZm9ybWF0IHdpdGggc2ltcGxpZmljYXRpb24gZGF0YVxuXG5mdW5jdGlvbiBjb252ZXJ0KGRhdGEsIHRvbGVyYW5jZSkge1xuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuXG4gICAgaWYgKGRhdGEudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCBkYXRhLmZlYXR1cmVzW2ldLCB0b2xlcmFuY2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdGZWF0dXJlJykge1xuICAgICAgICBjb252ZXJ0RmVhdHVyZShmZWF0dXJlcywgZGF0YSwgdG9sZXJhbmNlKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNpbmdsZSBnZW9tZXRyeSBvciBhIGdlb21ldHJ5IGNvbGxlY3Rpb25cbiAgICAgICAgY29udmVydEZlYXR1cmUoZmVhdHVyZXMsIHtnZW9tZXRyeTogZGF0YX0sIHRvbGVyYW5jZSk7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlcztcbn1cblxuZnVuY3Rpb24gY29udmVydEZlYXR1cmUoZmVhdHVyZXMsIGZlYXR1cmUsIHRvbGVyYW5jZSkge1xuICAgIHZhciBnZW9tID0gZmVhdHVyZS5nZW9tZXRyeSxcbiAgICAgICAgdHlwZSA9IGdlb20udHlwZSxcbiAgICAgICAgY29vcmRzID0gZ2VvbS5jb29yZGluYXRlcyxcbiAgICAgICAgdGFncyA9IGZlYXR1cmUucHJvcGVydGllcyxcbiAgICAgICAgaSwgaiwgcmluZ3M7XG5cbiAgICBpZiAodHlwZSA9PT0gJ1BvaW50Jykge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGNyZWF0ZSh0YWdzLCAxLCBbcHJvamVjdFBvaW50KGNvb3JkcyldKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGNyZWF0ZSh0YWdzLCAxLCBwcm9qZWN0KGNvb3JkcykpKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goY3JlYXRlKHRhZ3MsIDIsIFtwcm9qZWN0KGNvb3JkcywgdG9sZXJhbmNlKV0pKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ011bHRpTGluZVN0cmluZycgfHwgdHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIHJpbmdzID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJpbmdzLnB1c2gocHJvamVjdChjb29yZHNbaV0sIHRvbGVyYW5jZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZlYXR1cmVzLnB1c2goY3JlYXRlKHRhZ3MsIHR5cGUgPT09ICdQb2x5Z29uJyA/IDMgOiAyLCByaW5ncykpO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICByaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29vcmRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcmluZ3MucHVzaChwcm9qZWN0KGNvb3Jkc1tpXVtqXSwgdG9sZXJhbmNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmVhdHVyZXMucHVzaChjcmVhdGUodGFncywgMywgcmluZ3MpKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdlb20uZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29udmVydEZlYXR1cmUoZmVhdHVyZXMsIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogZ2VvbS5nZW9tZXRyaWVzW2ldLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHRhZ3NcbiAgICAgICAgICAgIH0sIHRvbGVyYW5jZSk7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBpcyBub3QgYSB2YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZSh0YWdzLCB0eXBlLCBnZW9tZXRyeSkge1xuICAgIHZhciBmZWF0dXJlID0ge1xuICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHRhZ3M6IHRhZ3MgfHwgbnVsbCxcbiAgICAgICAgbWluOiBbMiwgMV0sIC8vIGluaXRpYWwgYmJveCB2YWx1ZXM7XG4gICAgICAgIG1heDogWy0xLCAwXSAgLy8gbm90ZSB0aGF0IGNvb3JkcyBhcmUgdXN1YWxseSBpbiBbMC4uMV0gcmFuZ2VcbiAgICB9O1xuICAgIGNhbGNCQm94KGZlYXR1cmUpO1xuICAgIHJldHVybiBmZWF0dXJlO1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0KGxvbmxhdHMsIHRvbGVyYW5jZSkge1xuICAgIHZhciBwcm9qZWN0ZWQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvbmxhdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJvamVjdGVkLnB1c2gocHJvamVjdFBvaW50KGxvbmxhdHNbaV0pKTtcbiAgICB9XG4gICAgaWYgKHRvbGVyYW5jZSkge1xuICAgICAgICBzaW1wbGlmeShwcm9qZWN0ZWQsIHRvbGVyYW5jZSk7XG4gICAgICAgIGNhbGNTaXplKHByb2plY3RlZCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9qZWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIHByb2plY3RQb2ludChwKSB7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luKHBbMV0gKiBNYXRoLlBJIC8gMTgwKSxcbiAgICAgICAgeCA9IChwWzBdIC8gMzYwICsgMC41KSxcbiAgICAgICAgeSA9ICgwLjUgLSAwLjI1ICogTWF0aC5sb2coKDEgKyBzaW4pIC8gKDEgLSBzaW4pKSAvIE1hdGguUEkpO1xuXG4gICAgeSA9IHkgPCAtMSA/IC0xIDpcbiAgICAgICAgeSA+IDEgPyAxIDogeTtcblxuICAgIHJldHVybiBbeCwgeSwgMF07XG59XG5cbi8vIGNhbGN1bGF0ZSBhcmVhIGFuZCBsZW5ndGggb2YgdGhlIHBvbHlcbmZ1bmN0aW9uIGNhbGNTaXplKHBvaW50cykge1xuICAgIHZhciBhcmVhID0gMCxcbiAgICAgICAgZGlzdCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgYSwgYjsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgYSA9IGIgfHwgcG9pbnRzW2ldO1xuICAgICAgICBiID0gcG9pbnRzW2kgKyAxXTtcblxuICAgICAgICBhcmVhICs9IGFbMF0gKiBiWzFdIC0gYlswXSAqIGFbMV07XG5cbiAgICAgICAgLy8gdXNlIE1hbmhhdHRhbiBkaXN0YW5jZSBpbnN0ZWFkIG9mIEV1Y2xpZGlhbiBvbmUgdG8gYXZvaWQgZXhwZW5zaXZlIHNxdWFyZSByb290IGNvbXB1dGF0aW9uXG4gICAgICAgIGRpc3QgKz0gTWF0aC5hYnMoYlswXSAtIGFbMF0pICsgTWF0aC5hYnMoYlsxXSAtIGFbMV0pO1xuICAgIH1cbiAgICBwb2ludHMuYXJlYSA9IE1hdGguYWJzKGFyZWEgLyAyKTtcbiAgICBwb2ludHMuZGlzdCA9IGRpc3Q7XG59XG5cbi8vIGNhbGN1bGF0ZSB0aGUgZmVhdHVyZSBib3VuZGluZyBib3ggZm9yIGZhc3RlciBjbGlwcGluZyBsYXRlclxuZnVuY3Rpb24gY2FsY0JCb3goZmVhdHVyZSkge1xuICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgIG1pbiA9IGZlYXR1cmUubWluLFxuICAgICAgICBtYXggPSBmZWF0dXJlLm1heDtcblxuICAgIGlmIChmZWF0dXJlLnR5cGUgPT09IDEpIGNhbGNSaW5nQkJveChtaW4sIG1heCwgZ2VvbWV0cnkpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeS5sZW5ndGg7IGkrKykgY2FsY1JpbmdCQm94KG1pbiwgbWF4LCBnZW9tZXRyeVtpXSk7XG5cbiAgICByZXR1cm4gZmVhdHVyZTtcbn1cblxuZnVuY3Rpb24gY2FsY1JpbmdCQm94KG1pbiwgbWF4LCBwb2ludHMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwID0gcG9pbnRzW2ldO1xuICAgICAgICBtaW5bMF0gPSBNYXRoLm1pbihwWzBdLCBtaW5bMF0pO1xuICAgICAgICBtYXhbMF0gPSBNYXRoLm1heChwWzBdLCBtYXhbMF0pO1xuICAgICAgICBtaW5bMV0gPSBNYXRoLm1pbihwWzFdLCBtaW5bMV0pO1xuICAgICAgICBtYXhbMV0gPSBNYXRoLm1heChwWzFdLCBtYXhbMV0pO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBnZW9qc29udnQ7XG5cbnZhciBjb252ZXJ0ID0gcmVxdWlyZSgnLi9jb252ZXJ0JyksIC8vIEdlb0pTT04gY29udmVyc2lvbiBhbmQgcHJlcHJvY2Vzc2luZ1xuICAgIGNsaXAgPSByZXF1aXJlKCcuL2NsaXAnKSwgICAgICAgLy8gc3RyaXBlIGNsaXBwaW5nIGFsZ29yaXRobVxuICAgIHdyYXAgPSByZXF1aXJlKCcuL3dyYXAnKSwgICAgICAgLy8gZGF0ZSBsaW5lIHByb2Nlc3NpbmdcbiAgICBjcmVhdGVUaWxlID0gcmVxdWlyZSgnLi90aWxlJyk7IC8vIGZpbmFsIHNpbXBsaWZpZWQgdGlsZSBnZW5lcmF0aW9uXG5cblxuZnVuY3Rpb24gZ2VvanNvbnZ0KGRhdGEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEdlb0pTT05WVChkYXRhLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gR2VvSlNPTlZUKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zID0gZXh0ZW5kKE9iamVjdC5jcmVhdGUodGhpcy5vcHRpb25zKSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuXG4gICAgaWYgKGRlYnVnKSBjb25zb2xlLnRpbWUoJ3ByZXByb2Nlc3MgZGF0YScpO1xuXG4gICAgdmFyIHoyID0gMSA8PCBvcHRpb25zLm1heFpvb20sIC8vIDJeelxuICAgICAgICBmZWF0dXJlcyA9IGNvbnZlcnQoZGF0YSwgb3B0aW9ucy50b2xlcmFuY2UgLyAoejIgKiBvcHRpb25zLmV4dGVudCkpO1xuXG4gICAgdGhpcy50aWxlcyA9IHt9O1xuICAgIHRoaXMudGlsZUNvb3JkcyA9IFtdO1xuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUudGltZUVuZCgncHJlcHJvY2VzcyBkYXRhJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdpbmRleDogbWF4Wm9vbTogJWQsIG1heFBvaW50czogJWQnLCBvcHRpb25zLmluZGV4TWF4Wm9vbSwgb3B0aW9ucy5pbmRleE1heFBvaW50cyk7XG4gICAgICAgIGNvbnNvbGUudGltZSgnZ2VuZXJhdGUgdGlsZXMnKTtcbiAgICAgICAgdGhpcy5zdGF0cyA9IHt9O1xuICAgICAgICB0aGlzLnRvdGFsID0gMDtcbiAgICB9XG5cbiAgICBmZWF0dXJlcyA9IHdyYXAoZmVhdHVyZXMsIG9wdGlvbnMuYnVmZmVyIC8gb3B0aW9ucy5leHRlbnQsIGludGVyc2VjdFgpO1xuXG4gICAgLy8gc3RhcnQgc2xpY2luZyBmcm9tIHRoZSB0b3AgdGlsZSBkb3duXG4gICAgaWYgKGZlYXR1cmVzLmxlbmd0aCkgdGhpcy5zcGxpdFRpbGUoZmVhdHVyZXMsIDAsIDAsIDApO1xuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGlmIChmZWF0dXJlcy5sZW5ndGgpIGNvbnNvbGUubG9nKCdmZWF0dXJlczogJWQsIHBvaW50czogJWQnLCB0aGlzLnRpbGVzWzBdLm51bUZlYXR1cmVzLCB0aGlzLnRpbGVzWzBdLm51bVBvaW50cyk7XG4gICAgICAgIGNvbnNvbGUudGltZUVuZCgnZ2VuZXJhdGUgdGlsZXMnKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3RpbGVzIGdlbmVyYXRlZDonLCB0aGlzLnRvdGFsLCBKU09OLnN0cmluZ2lmeSh0aGlzLnN0YXRzKSk7XG4gICAgfVxufVxuXG5HZW9KU09OVlQucHJvdG90eXBlLm9wdGlvbnMgPSB7XG4gICAgbWF4Wm9vbTogMTQsICAgICAgICAgICAgLy8gbWF4IHpvb20gdG8gcHJlc2VydmUgZGV0YWlsIG9uXG4gICAgaW5kZXhNYXhab29tOiA1LCAgICAgICAgLy8gbWF4IHpvb20gaW4gdGhlIHRpbGUgaW5kZXhcbiAgICBpbmRleE1heFBvaW50czogMTAwMDAwLCAvLyBtYXggbnVtYmVyIG9mIHBvaW50cyBwZXIgdGlsZSBpbiB0aGUgdGlsZSBpbmRleFxuICAgIHNvbGlkQ2hpbGRyZW46IGZhbHNlLCAgIC8vIHdoZXRoZXIgdG8gdGlsZSBzb2xpZCBzcXVhcmUgdGlsZXMgZnVydGhlclxuICAgIHRvbGVyYW5jZTogMywgICAgICAgICAgIC8vIHNpbXBsaWZpY2F0aW9uIHRvbGVyYW5jZSAoaGlnaGVyIG1lYW5zIHNpbXBsZXIpXG4gICAgZXh0ZW50OiA0MDk2LCAgICAgICAgICAgLy8gdGlsZSBleHRlbnRcbiAgICBidWZmZXI6IDY0LCAgICAgICAgICAgICAvLyB0aWxlIGJ1ZmZlciBvbiBlYWNoIHNpZGVcbiAgICBkZWJ1ZzogMCAgICAgICAgICAgICAgICAvLyBsb2dnaW5nIGxldmVsICgwLCAxIG9yIDIpXG59O1xuXG5HZW9KU09OVlQucHJvdG90eXBlLnNwbGl0VGlsZSA9IGZ1bmN0aW9uIChmZWF0dXJlcywgeiwgeCwgeSwgY3osIGN4LCBjeSkge1xuXG4gICAgdmFyIHN0YWNrID0gW2ZlYXR1cmVzLCB6LCB4LCB5XSxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuXG4gICAgLy8gYXZvaWQgcmVjdXJzaW9uIGJ5IHVzaW5nIGEgcHJvY2Vzc2luZyBxdWV1ZVxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgeSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB4ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHogPSBzdGFjay5wb3AoKTtcbiAgICAgICAgZmVhdHVyZXMgPSBzdGFjay5wb3AoKTtcblxuICAgICAgICB2YXIgejIgPSAxIDw8IHosXG4gICAgICAgICAgICBpZCA9IHRvSUQoeiwgeCwgeSksXG4gICAgICAgICAgICB0aWxlID0gdGhpcy50aWxlc1tpZF0sXG4gICAgICAgICAgICB0aWxlVG9sZXJhbmNlID0geiA9PT0gb3B0aW9ucy5tYXhab29tID8gMCA6IG9wdGlvbnMudG9sZXJhbmNlIC8gKHoyICogb3B0aW9ucy5leHRlbnQpO1xuXG4gICAgICAgIGlmICghdGlsZSkge1xuICAgICAgICAgICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS50aW1lKCdjcmVhdGlvbicpO1xuXG4gICAgICAgICAgICB0aWxlID0gdGhpcy50aWxlc1tpZF0gPSBjcmVhdGVUaWxlKGZlYXR1cmVzLCB6MiwgeCwgeSwgdGlsZVRvbGVyYW5jZSwgeiA9PT0gb3B0aW9ucy5tYXhab29tKTtcbiAgICAgICAgICAgIHRoaXMudGlsZUNvb3Jkcy5wdXNoKHt6OiB6LCB4OiB4LCB5OiB5fSk7XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgIGlmIChkZWJ1ZyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RpbGUgeiVkLSVkLSVkIChmZWF0dXJlczogJWQsIHBvaW50czogJWQsIHNpbXBsaWZpZWQ6ICVkKScsXG4gICAgICAgICAgICAgICAgICAgICAgICB6LCB4LCB5LCB0aWxlLm51bUZlYXR1cmVzLCB0aWxlLm51bVBvaW50cywgdGlsZS5udW1TaW1wbGlmaWVkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS50aW1lRW5kKCdjcmVhdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gJ3onICsgejtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRzW2tleV0gPSAodGhpcy5zdGF0c1trZXldIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdGFsKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBnZW9tZXRyeSBpbiB0aWxlIHNvIHRoYXQgd2UgY2FuIGRyaWxsIGRvd24gbGF0ZXIgaWYgd2Ugc3RvcCBub3dcbiAgICAgICAgdGlsZS5zb3VyY2UgPSBmZWF0dXJlcztcblxuICAgICAgICAvLyBzdG9wIHRpbGluZyBpZiB0aGUgdGlsZSBpcyBzb2xpZCBjbGlwcGVkIHNxdWFyZVxuICAgICAgICBpZiAoIW9wdGlvbnMuc29saWRDaGlsZHJlbiAmJiBpc0NsaXBwZWRTcXVhcmUodGlsZSwgb3B0aW9ucy5leHRlbnQsIG9wdGlvbnMuYnVmZmVyKSkgY29udGludWU7XG5cbiAgICAgICAgLy8gaWYgaXQncyB0aGUgZmlyc3QtcGFzcyB0aWxpbmdcbiAgICAgICAgaWYgKCFjeikge1xuICAgICAgICAgICAgLy8gc3RvcCB0aWxpbmcgaWYgd2UgcmVhY2hlZCBtYXggem9vbSwgb3IgaWYgdGhlIHRpbGUgaXMgdG9vIHNpbXBsZVxuICAgICAgICAgICAgaWYgKHogPT09IG9wdGlvbnMuaW5kZXhNYXhab29tIHx8IHRpbGUubnVtUG9pbnRzIDw9IG9wdGlvbnMuaW5kZXhNYXhQb2ludHMpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIGlmIGEgZHJpbGxkb3duIHRvIGEgc3BlY2lmaWMgdGlsZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc3RvcCB0aWxpbmcgaWYgd2UgcmVhY2hlZCBiYXNlIHpvb20gb3Igb3VyIHRhcmdldCB0aWxlIHpvb21cbiAgICAgICAgICAgIGlmICh6ID09PSBvcHRpb25zLm1heFpvb20gfHwgeiA9PT0gY3opIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBzdG9wIHRpbGluZyBpZiBpdCdzIG5vdCBhbiBhbmNlc3RvciBvZiB0aGUgdGFyZ2V0IHRpbGVcbiAgICAgICAgICAgIHZhciBtID0gMSA8PCAoY3ogLSB6KTtcbiAgICAgICAgICAgIGlmICh4ICE9PSBNYXRoLmZsb29yKGN4IC8gbSkgfHwgeSAhPT0gTWF0aC5mbG9vcihjeSAvIG0pKSBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIHNsaWNlIGZ1cnRoZXIgZG93biwgbm8gbmVlZCB0byBrZWVwIHNvdXJjZSBnZW9tZXRyeVxuICAgICAgICB0aWxlLnNvdXJjZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS50aW1lKCdjbGlwcGluZycpO1xuXG4gICAgICAgIC8vIHZhbHVlcyB3ZSdsbCB1c2UgZm9yIGNsaXBwaW5nXG4gICAgICAgIHZhciBrMSA9IDAuNSAqIG9wdGlvbnMuYnVmZmVyIC8gb3B0aW9ucy5leHRlbnQsXG4gICAgICAgICAgICBrMiA9IDAuNSAtIGsxLFxuICAgICAgICAgICAgazMgPSAwLjUgKyBrMSxcbiAgICAgICAgICAgIGs0ID0gMSArIGsxLFxuICAgICAgICAgICAgdGwsIGJsLCB0ciwgYnIsIGxlZnQsIHJpZ2h0O1xuXG4gICAgICAgIHRsID0gYmwgPSB0ciA9IGJyID0gbnVsbDtcblxuICAgICAgICBsZWZ0ICA9IGNsaXAoZmVhdHVyZXMsIHoyLCB4IC0gazEsIHggKyBrMywgMCwgaW50ZXJzZWN0WCwgdGlsZS5taW5bMF0sIHRpbGUubWF4WzBdKTtcbiAgICAgICAgcmlnaHQgPSBjbGlwKGZlYXR1cmVzLCB6MiwgeCArIGsyLCB4ICsgazQsIDAsIGludGVyc2VjdFgsIHRpbGUubWluWzBdLCB0aWxlLm1heFswXSk7XG5cbiAgICAgICAgaWYgKGxlZnQpIHtcbiAgICAgICAgICAgIHRsID0gY2xpcChsZWZ0LCB6MiwgeSAtIGsxLCB5ICsgazMsIDEsIGludGVyc2VjdFksIHRpbGUubWluWzFdLCB0aWxlLm1heFsxXSk7XG4gICAgICAgICAgICBibCA9IGNsaXAobGVmdCwgejIsIHkgKyBrMiwgeSArIGs0LCAxLCBpbnRlcnNlY3RZLCB0aWxlLm1pblsxXSwgdGlsZS5tYXhbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICB0ciA9IGNsaXAocmlnaHQsIHoyLCB5IC0gazEsIHkgKyBrMywgMSwgaW50ZXJzZWN0WSwgdGlsZS5taW5bMV0sIHRpbGUubWF4WzFdKTtcbiAgICAgICAgICAgIGJyID0gY2xpcChyaWdodCwgejIsIHkgKyBrMiwgeSArIGs0LCAxLCBpbnRlcnNlY3RZLCB0aWxlLm1pblsxXSwgdGlsZS5tYXhbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS50aW1lRW5kKCdjbGlwcGluZycpO1xuXG4gICAgICAgIGlmICh0bCkgc3RhY2sucHVzaCh0bCwgeiArIDEsIHggKiAyLCAgICAgeSAqIDIpO1xuICAgICAgICBpZiAoYmwpIHN0YWNrLnB1c2goYmwsIHogKyAxLCB4ICogMiwgICAgIHkgKiAyICsgMSk7XG4gICAgICAgIGlmICh0cikgc3RhY2sucHVzaCh0ciwgeiArIDEsIHggKiAyICsgMSwgeSAqIDIpO1xuICAgICAgICBpZiAoYnIpIHN0YWNrLnB1c2goYnIsIHogKyAxLCB4ICogMiArIDEsIHkgKiAyICsgMSk7XG4gICAgfVxufTtcblxuR2VvSlNPTlZULnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24gKHosIHgsIHkpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZXh0ZW50ID0gb3B0aW9ucy5leHRlbnQsXG4gICAgICAgIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcblxuICAgIHZhciB6MiA9IDEgPDwgejtcbiAgICB4ID0gKCh4ICUgejIpICsgejIpICUgejI7IC8vIHdyYXAgdGlsZSB4IGNvb3JkaW5hdGVcblxuICAgIHZhciBpZCA9IHRvSUQoeiwgeCwgeSk7XG4gICAgaWYgKHRoaXMudGlsZXNbaWRdKSByZXR1cm4gdHJhbnNmb3JtVGlsZSh0aGlzLnRpbGVzW2lkXSwgZXh0ZW50KTtcblxuICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUubG9nKCdkcmlsbGluZyBkb3duIHRvIHolZC0lZC0lZCcsIHosIHgsIHkpO1xuXG4gICAgdmFyIHowID0geixcbiAgICAgICAgeDAgPSB4LFxuICAgICAgICB5MCA9IHksXG4gICAgICAgIHBhcmVudDtcblxuICAgIHdoaWxlICghcGFyZW50ICYmIHowID4gMCkge1xuICAgICAgICB6MC0tO1xuICAgICAgICB4MCA9IE1hdGguZmxvb3IoeDAgLyAyKTtcbiAgICAgICAgeTAgPSBNYXRoLmZsb29yKHkwIC8gMik7XG4gICAgICAgIHBhcmVudCA9IHRoaXMudGlsZXNbdG9JRCh6MCwgeDAsIHkwKV07XG4gICAgfVxuXG4gICAgaWYgKCFwYXJlbnQpIHJldHVybiBudWxsO1xuXG4gICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS5sb2coJ2ZvdW5kIHBhcmVudCB0aWxlIHolZC0lZC0lZCcsIHowLCB4MCwgeTApO1xuXG4gICAgLy8gaWYgd2UgZm91bmQgYSBwYXJlbnQgdGlsZSBjb250YWluaW5nIHRoZSBvcmlnaW5hbCBnZW9tZXRyeSwgd2UgY2FuIGRyaWxsIGRvd24gZnJvbSBpdFxuICAgIGlmIChwYXJlbnQuc291cmNlKSB7XG4gICAgICAgIGlmIChpc0NsaXBwZWRTcXVhcmUocGFyZW50LCBleHRlbnQsIG9wdGlvbnMuYnVmZmVyKSkgcmV0dXJuIHRyYW5zZm9ybVRpbGUocGFyZW50LCBleHRlbnQpO1xuXG4gICAgICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUudGltZSgnZHJpbGxpbmcgZG93bicpO1xuICAgICAgICB0aGlzLnNwbGl0VGlsZShwYXJlbnQuc291cmNlLCB6MCwgeDAsIHkwLCB6LCB4LCB5KTtcbiAgICAgICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS50aW1lRW5kKCdkcmlsbGluZyBkb3duJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnRpbGVzW2lkXSkgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gdHJhbnNmb3JtVGlsZSh0aGlzLnRpbGVzW2lkXSwgZXh0ZW50KTtcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVRpbGUodGlsZSwgZXh0ZW50KSB7XG4gICAgaWYgKHRpbGUudHJhbnNmb3JtZWQpIHJldHVybiB0aWxlO1xuXG4gICAgdmFyIHoyID0gdGlsZS56MixcbiAgICAgICAgdHggPSB0aWxlLngsXG4gICAgICAgIHR5ID0gdGlsZS55LFxuICAgICAgICBpLCBqLCBrO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRpbGUuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSB0aWxlLmZlYXR1cmVzW2ldLFxuICAgICAgICAgICAgZ2VvbSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgICAgICB0eXBlID0gZmVhdHVyZS50eXBlO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAxKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2VvbS5sZW5ndGg7IGorKykgZ2VvbVtqXSA9IHRyYW5zZm9ybVBvaW50KGdlb21bal0sIGV4dGVudCwgejIsIHR4LCB0eSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnZW9tLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJpbmcgPSBnZW9tW2pdO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCByaW5nLmxlbmd0aDsgaysrKSByaW5nW2tdID0gdHJhbnNmb3JtUG9pbnQocmluZ1trXSwgZXh0ZW50LCB6MiwgdHgsIHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRpbGUudHJhbnNmb3JtZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRpbGU7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50KHAsIGV4dGVudCwgejIsIHR4LCB0eSkge1xuICAgIHZhciB4ID0gTWF0aC5yb3VuZChleHRlbnQgKiAocFswXSAqIHoyIC0gdHgpKSxcbiAgICAgICAgeSA9IE1hdGgucm91bmQoZXh0ZW50ICogKHBbMV0gKiB6MiAtIHR5KSk7XG4gICAgcmV0dXJuIFt4LCB5XTtcbn1cblxuZnVuY3Rpb24gdG9JRCh6LCB4LCB5KSB7XG4gICAgcmV0dXJuICgoKDEgPDwgeikgKiB5ICsgeCkgKiAzMikgKyB6O1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RYKGEsIGIsIHgpIHtcbiAgICByZXR1cm4gW3gsICh4IC0gYVswXSkgKiAoYlsxXSAtIGFbMV0pIC8gKGJbMF0gLSBhWzBdKSArIGFbMV0sIDFdO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0WShhLCBiLCB5KSB7XG4gICAgcmV0dXJuIFsoeSAtIGFbMV0pICogKGJbMF0gLSBhWzBdKSAvIChiWzFdIC0gYVsxXSkgKyBhWzBdLCB5LCAxXTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYykge1xuICAgIGZvciAodmFyIGkgaW4gc3JjKSBkZXN0W2ldID0gc3JjW2ldO1xuICAgIHJldHVybiBkZXN0O1xufVxuXG4vLyBjaGVja3Mgd2hldGhlciBhIHRpbGUgaXMgYSB3aG9sZS1hcmVhIGZpbGwgYWZ0ZXIgY2xpcHBpbmc7IGlmIGl0IGlzLCB0aGVyZSdzIG5vIHNlbnNlIHNsaWNpbmcgaXQgZnVydGhlclxuZnVuY3Rpb24gaXNDbGlwcGVkU3F1YXJlKHRpbGUsIGV4dGVudCwgYnVmZmVyKSB7XG5cbiAgICB2YXIgZmVhdHVyZXMgPSB0aWxlLnNvdXJjZTtcbiAgICBpZiAoZmVhdHVyZXMubGVuZ3RoICE9PSAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzWzBdO1xuICAgIGlmIChmZWF0dXJlLnR5cGUgIT09IDMgfHwgZmVhdHVyZS5nZW9tZXRyeS5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuID0gZmVhdHVyZS5nZW9tZXRyeVswXS5sZW5ndGg7XG4gICAgaWYgKGxlbiAhPT0gNSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgcCA9IHRyYW5zZm9ybVBvaW50KGZlYXR1cmUuZ2VvbWV0cnlbMF1baV0sIGV4dGVudCwgdGlsZS56MiwgdGlsZS54LCB0aWxlLnkpO1xuICAgICAgICBpZiAoKHBbMF0gIT09IC1idWZmZXIgJiYgcFswXSAhPT0gZXh0ZW50ICsgYnVmZmVyKSB8fFxuICAgICAgICAgICAgKHBbMV0gIT09IC1idWZmZXIgJiYgcFsxXSAhPT0gZXh0ZW50ICsgYnVmZmVyKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNpbXBsaWZ5O1xuXG4vLyBjYWxjdWxhdGUgc2ltcGxpZmljYXRpb24gZGF0YSB1c2luZyBvcHRpbWl6ZWQgRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobVxuXG5mdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xuXG4gICAgdmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlLFxuICAgICAgICBsZW4gPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBmaXJzdCA9IDAsXG4gICAgICAgIGxhc3QgPSBsZW4gLSAxLFxuICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICBpLCBtYXhTcURpc3QsIHNxRGlzdCwgaW5kZXg7XG5cbiAgICAvLyBhbHdheXMgcmV0YWluIHRoZSBlbmRwb2ludHMgKDEgaXMgdGhlIG1heCB2YWx1ZSlcbiAgICBwb2ludHNbZmlyc3RdWzJdID0gMTtcbiAgICBwb2ludHNbbGFzdF1bMl0gPSAxO1xuXG4gICAgLy8gYXZvaWQgcmVjdXJzaW9uIGJ5IHVzaW5nIGEgc3RhY2tcbiAgICB3aGlsZSAobGFzdCkge1xuXG4gICAgICAgIG1heFNxRGlzdCA9IDA7XG5cbiAgICAgICAgZm9yIChpID0gZmlyc3QgKyAxOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgICAgICBzcURpc3QgPSBnZXRTcVNlZ0Rpc3QocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0pO1xuXG4gICAgICAgICAgICBpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIG1heFNxRGlzdCA9IHNxRGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xuICAgICAgICAgICAgcG9pbnRzW2luZGV4XVsyXSA9IG1heFNxRGlzdDsgLy8gc2F2ZSB0aGUgcG9pbnQgaW1wb3J0YW5jZSBpbiBzcXVhcmVkIHBpeGVscyBhcyBhIHogY29vcmRpbmF0ZVxuICAgICAgICAgICAgc3RhY2sucHVzaChmaXJzdCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIGZpcnN0ID0gaW5kZXg7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3QgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGZpcnN0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIHNxdWFyZSBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBzZWdtZW50XG5mdW5jdGlvbiBnZXRTcVNlZ0Rpc3QocCwgYSwgYikge1xuXG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sXG4gICAgICAgIHB4ID0gcFswXSwgcHkgPSBwWzFdLFxuICAgICAgICBkeCA9IGJ4IC0geCxcbiAgICAgICAgZHkgPSBieSAtIHk7XG5cbiAgICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcblxuICAgICAgICB2YXIgdCA9ICgocHggLSB4KSAqIGR4ICsgKHB5IC0geSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgICAgeCA9IGJ4O1xuICAgICAgICAgICAgeSA9IGJ5O1xuXG4gICAgICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgICAgICAgIHggKz0gZHggKiB0O1xuICAgICAgICAgICAgeSArPSBkeSAqIHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkeCA9IHB4IC0geDtcbiAgICBkeSA9IHB5IC0geTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUaWxlO1xuXG5mdW5jdGlvbiBjcmVhdGVUaWxlKGZlYXR1cmVzLCB6MiwgdHgsIHR5LCB0b2xlcmFuY2UsIG5vU2ltcGxpZnkpIHtcbiAgICB2YXIgdGlsZSA9IHtcbiAgICAgICAgZmVhdHVyZXM6IFtdLFxuICAgICAgICBudW1Qb2ludHM6IDAsXG4gICAgICAgIG51bVNpbXBsaWZpZWQ6IDAsXG4gICAgICAgIG51bUZlYXR1cmVzOiAwLFxuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIHg6IHR4LFxuICAgICAgICB5OiB0eSxcbiAgICAgICAgejI6IHoyLFxuICAgICAgICB0cmFuc2Zvcm1lZDogZmFsc2UsXG4gICAgICAgIG1pbjogWzIsIDFdLFxuICAgICAgICBtYXg6IFstMSwgMF1cbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGlsZS5udW1GZWF0dXJlcysrO1xuICAgICAgICBhZGRGZWF0dXJlKHRpbGUsIGZlYXR1cmVzW2ldLCB0b2xlcmFuY2UsIG5vU2ltcGxpZnkpO1xuXG4gICAgICAgIHZhciBtaW4gPSBmZWF0dXJlc1tpXS5taW4sXG4gICAgICAgICAgICBtYXggPSBmZWF0dXJlc1tpXS5tYXg7XG5cbiAgICAgICAgaWYgKG1pblswXSA8IHRpbGUubWluWzBdKSB0aWxlLm1pblswXSA9IG1pblswXTtcbiAgICAgICAgaWYgKG1pblsxXSA8IHRpbGUubWluWzFdKSB0aWxlLm1pblsxXSA9IG1pblsxXTtcbiAgICAgICAgaWYgKG1heFswXSA+IHRpbGUubWF4WzBdKSB0aWxlLm1heFswXSA9IG1heFswXTtcbiAgICAgICAgaWYgKG1heFsxXSA+IHRpbGUubWF4WzFdKSB0aWxlLm1heFsxXSA9IG1heFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbGU7XG59XG5cbmZ1bmN0aW9uIGFkZEZlYXR1cmUodGlsZSwgZmVhdHVyZSwgdG9sZXJhbmNlLCBub1NpbXBsaWZ5KSB7XG5cbiAgICB2YXIgZ2VvbSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgIHR5cGUgPSBmZWF0dXJlLnR5cGUsXG4gICAgICAgIHNpbXBsaWZpZWQgPSBbXSxcbiAgICAgICAgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgKiB0b2xlcmFuY2UsXG4gICAgICAgIGksIGosIHJpbmcsIHA7XG5cbiAgICBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ2VvbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2ltcGxpZmllZC5wdXNoKGdlb21baV0pO1xuICAgICAgICAgICAgdGlsZS5udW1Qb2ludHMrKztcbiAgICAgICAgICAgIHRpbGUubnVtU2ltcGxpZmllZCsrO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIHNpbXBsaWZ5IGFuZCB0cmFuc2Zvcm0gcHJvamVjdGVkIGNvb3JkaW5hdGVzIGZvciB0aWxlIGdlb21ldHJ5XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9tLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByaW5nID0gZ2VvbVtpXTtcblxuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCB0aW55IHBvbHlsaW5lcyAmIHBvbHlnb25zXG4gICAgICAgICAgICBpZiAoIW5vU2ltcGxpZnkgJiYgKCh0eXBlID09PSAyICYmIHJpbmcuZGlzdCA8IHRvbGVyYW5jZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT09IDMgJiYgcmluZy5hcmVhIDwgc3FUb2xlcmFuY2UpKSkge1xuICAgICAgICAgICAgICAgIHRpbGUubnVtUG9pbnRzICs9IHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2ltcGxpZmllZFJpbmcgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHJpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwID0gcmluZ1tqXTtcbiAgICAgICAgICAgICAgICAvLyBrZWVwIHBvaW50cyB3aXRoIGltcG9ydGFuY2UgPiB0b2xlcmFuY2VcbiAgICAgICAgICAgICAgICBpZiAobm9TaW1wbGlmeSB8fCBwWzJdID4gc3FUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2ltcGxpZmllZFJpbmcucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgdGlsZS5udW1TaW1wbGlmaWVkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbGUubnVtUG9pbnRzKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNpbXBsaWZpZWQucHVzaChzaW1wbGlmaWVkUmluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2ltcGxpZmllZC5sZW5ndGgpIHtcbiAgICAgICAgdGlsZS5mZWF0dXJlcy5wdXNoKHtcbiAgICAgICAgICAgIGdlb21ldHJ5OiBzaW1wbGlmaWVkLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHRhZ3M6IGZlYXR1cmUudGFncyB8fCBudWxsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNsaXAgPSByZXF1aXJlKCcuL2NsaXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwO1xuXG5mdW5jdGlvbiB3cmFwKGZlYXR1cmVzLCBidWZmZXIsIGludGVyc2VjdFgpIHtcbiAgICB2YXIgbWVyZ2VkID0gZmVhdHVyZXMsXG4gICAgICAgIGxlZnQgID0gY2xpcChmZWF0dXJlcywgMSwgLTEgLSBidWZmZXIsIGJ1ZmZlciwgICAgIDAsIGludGVyc2VjdFgsIC0xLCAyKSwgLy8gbGVmdCB3b3JsZCBjb3B5XG4gICAgICAgIHJpZ2h0ID0gY2xpcChmZWF0dXJlcywgMSwgIDEgLSBidWZmZXIsIDIgKyBidWZmZXIsIDAsIGludGVyc2VjdFgsIC0xLCAyKTsgLy8gcmlnaHQgd29ybGQgY29weVxuXG4gICAgaWYgKGxlZnQgfHwgcmlnaHQpIHtcbiAgICAgICAgbWVyZ2VkID0gY2xpcChmZWF0dXJlcywgMSwgLWJ1ZmZlciwgMSArIGJ1ZmZlciwgMCwgaW50ZXJzZWN0WCwgLTEsIDIpOyAvLyBjZW50ZXIgd29ybGQgY29weVxuXG4gICAgICAgIGlmIChsZWZ0KSBtZXJnZWQgPSBzaGlmdEZlYXR1cmVDb29yZHMobGVmdCwgMSkuY29uY2F0KG1lcmdlZCk7IC8vIG1lcmdlIGxlZnQgaW50byBjZW50ZXJcbiAgICAgICAgaWYgKHJpZ2h0KSBtZXJnZWQgPSBtZXJnZWQuY29uY2F0KHNoaWZ0RmVhdHVyZUNvb3JkcyhyaWdodCwgLTEpKTsgLy8gbWVyZ2UgcmlnaHQgaW50byBjZW50ZXJcbiAgICB9XG5cbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuXG5mdW5jdGlvbiBzaGlmdEZlYXR1cmVDb29yZHMoZmVhdHVyZXMsIG9mZnNldCkge1xuICAgIHZhciBuZXdGZWF0dXJlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ldLFxuICAgICAgICAgICAgdHlwZSA9IGZlYXR1cmUudHlwZTtcblxuICAgICAgICB2YXIgbmV3R2VvbWV0cnk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIG5ld0dlb21ldHJ5ID0gc2hpZnRDb29yZHMoZmVhdHVyZS5nZW9tZXRyeSwgb2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0dlb21ldHJ5ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZlYXR1cmUuZ2VvbWV0cnkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBuZXdHZW9tZXRyeS5wdXNoKHNoaWZ0Q29vcmRzKGZlYXR1cmUuZ2VvbWV0cnlbal0sIG9mZnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbmV3RmVhdHVyZXMucHVzaCh7XG4gICAgICAgICAgICBnZW9tZXRyeTogbmV3R2VvbWV0cnksXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdGFnczogZmVhdHVyZS50YWdzLFxuICAgICAgICAgICAgbWluOiBbZmVhdHVyZS5taW5bMF0gKyBvZmZzZXQsIGZlYXR1cmUubWluWzFdXSxcbiAgICAgICAgICAgIG1heDogW2ZlYXR1cmUubWF4WzBdICsgb2Zmc2V0LCBmZWF0dXJlLm1heFsxXV1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0ZlYXR1cmVzO1xufVxuXG5mdW5jdGlvbiBzaGlmdENvb3Jkcyhwb2ludHMsIG9mZnNldCkge1xuICAgIHZhciBuZXdQb2ludHMgPSBbXTtcbiAgICBuZXdQb2ludHMuYXJlYSA9IHBvaW50cy5hcmVhO1xuICAgIG5ld1BvaW50cy5kaXN0ID0gcG9pbnRzLmRpc3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdQb2ludHMucHVzaChbcG9pbnRzW2ldWzBdICsgb2Zmc2V0LCBwb2ludHNbaV1bMV0sIHBvaW50c1tpXVsyXV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnRcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0M1xuICpcbiAqIEBhbGlhcyBtYXQzLmludmVydFxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdXG4gIHZhciBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdXG4gIHZhciBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdXG5cbiAgdmFyIGIwMSA9IGEyMiAqIGExMSAtIGExMiAqIGEyMVxuICB2YXIgYjExID0gLWEyMiAqIGExMCArIGExMiAqIGEyMFxuICB2YXIgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwXG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICB2YXIgZGV0ID0gYTAwICogYjAxICsgYTAxICogYjExICsgYTAyICogYjIxXG5cbiAgaWYgKCFkZXQpIHJldHVybiBudWxsXG4gIGRldCA9IDEuMCAvIGRldFxuXG4gIG91dFswXSA9IGIwMSAqIGRldFxuICBvdXRbMV0gPSAoLWEyMiAqIGEwMSArIGEwMiAqIGEyMSkgKiBkZXRcbiAgb3V0WzJdID0gKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXRcbiAgb3V0WzNdID0gYjExICogZGV0XG4gIG91dFs0XSA9IChhMjIgKiBhMDAgLSBhMDIgKiBhMjApICogZGV0XG4gIG91dFs1XSA9ICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldFxuICBvdXRbNl0gPSBiMjEgKiBkZXRcbiAgb3V0WzddID0gKC1hMjEgKiBhMDAgKyBhMDEgKiBhMjApICogZGV0XG4gIG91dFs4XSA9IChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0XG5cbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBub3JtYWxGcm9tTWF0NFxuXG4vKipcbiogQ2FsY3VsYXRlcyBhIDN4MyBub3JtYWwgbWF0cml4ICh0cmFuc3Bvc2UgaW52ZXJzZSkgZnJvbSB0aGUgNHg0IG1hdHJpeFxuKlxuKiBAYWxpYXMgbWF0My5ub3JtYWxGcm9tTWF0NFxuKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4qIEBwYXJhbSB7bWF0NH0gYSBNYXQ0IHRvIGRlcml2ZSB0aGUgbm9ybWFsIG1hdHJpeCBmcm9tXG4qXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcbiovXG5mdW5jdGlvbiBub3JtYWxGcm9tTWF0NChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM11cbiAgdmFyIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN11cbiAgdmFyIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXVxuICB2YXIgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV1cblxuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwXG4gIHZhciBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTBcbiAgdmFyIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMFxuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExXG4gIHZhciBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTFcbiAgdmFyIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMlxuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwXG4gIHZhciBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzBcbiAgdmFyIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMFxuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxXG4gIHZhciBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzFcbiAgdmFyIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMlxuXG4gIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgdmFyIGRldCA9IGIwMCAqIGIxMVxuICAgICAgICAgIC0gYjAxICogYjEwXG4gICAgICAgICAgKyBiMDIgKiBiMDlcbiAgICAgICAgICArIGIwMyAqIGIwOFxuICAgICAgICAgIC0gYjA0ICogYjA3XG4gICAgICAgICAgKyBiMDUgKiBiMDZcblxuICBpZiAoIWRldCkgcmV0dXJuIG51bGxcbiAgZGV0ID0gMS4wIC8gZGV0XG5cbiAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXRcbiAgb3V0WzFdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXRcbiAgb3V0WzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXRcblxuICBvdXRbM10gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldFxuICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldFxuICBvdXRbNV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldFxuXG4gIG91dFs2XSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0XG4gIG91dFs3XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0XG4gIG91dFs4XSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0XG5cbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjb3B5O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQ0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuXG4vKipcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07IiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvb2tBdDtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBsb29rLWF0IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBleWUgcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7dmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7dmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxuICogQHBhcmFtIHt2ZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGxvb2tBdChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICAgIHZhciB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW4sXG4gICAgICAgIGV5ZXggPSBleWVbMF0sXG4gICAgICAgIGV5ZXkgPSBleWVbMV0sXG4gICAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgICB1cHkgPSB1cFsxXSxcbiAgICAgICAgdXB6ID0gdXBbMl0sXG4gICAgICAgIGNlbnRlcnggPSBjZW50ZXJbMF0sXG4gICAgICAgIGNlbnRlcnkgPSBjZW50ZXJbMV0sXG4gICAgICAgIGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgMC4wMDAwMDEgJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgMC4wMDAwMDEgJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleiAtIGNlbnRlcnopIDwgMC4wMDAwMDEpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5KG91dCk7XG4gICAgfVxuXG4gICAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICAgIHoyID0gZXlleiAtIGNlbnRlcno7XG5cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KHowICogejAgKyB6MSAqIHoxICsgejIgKiB6Mik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG5cbiAgICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgICBsZW4gPSBNYXRoLnNxcnQoeDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB4MCA9IDA7XG4gICAgICAgIHgxID0gMDtcbiAgICAgICAgeDIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHgwICo9IGxlbjtcbiAgICAgICAgeDEgKj0gbGVuO1xuICAgICAgICB4MiAqPSBsZW47XG4gICAgfVxuXG4gICAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICAgIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG5cbiAgICBsZW4gPSBNYXRoLnNxcnQoeTAgKiB5MCArIHkxICogeTEgKyB5MiAqIHkyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB5MCA9IDA7XG4gICAgICAgIHkxID0gMDtcbiAgICAgICAgeTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHkwICo9IGxlbjtcbiAgICAgICAgeTEgKj0gbGVuO1xuICAgICAgICB5MiAqPSBsZW47XG4gICAgfVxuXG4gICAgb3V0WzBdID0geDA7XG4gICAgb3V0WzFdID0geTA7XG4gICAgb3V0WzJdID0gejA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4MTtcbiAgICBvdXRbNV0gPSB5MTtcbiAgICBvdXRbNl0gPSB6MTtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHgyO1xuICAgIG91dFs5XSA9IHkyO1xuICAgIG91dFsxMF0gPSB6MjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICAgIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gICAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHk7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NCdzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuICAgIHZhciBiMCAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdOyAgXG4gICAgb3V0WzBdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzNdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzRdOyBiMSA9IGJbNV07IGIyID0gYls2XTsgYjMgPSBiWzddO1xuICAgIG91dFs0XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbNV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzZdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFs3XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls4XTsgYjEgPSBiWzldOyBiMiA9IGJbMTBdOyBiMyA9IGJbMTFdO1xuICAgIG91dFs4XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbOV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzEwXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTFdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzEyXTsgYjEgPSBiWzEzXTsgYjIgPSBiWzE0XTsgYjMgPSBiWzE1XTtcbiAgICBvdXRbMTJdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxM10gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzE0XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTVdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcGVyc3BlY3RpdmU7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcGVyc3BlY3RpdmUob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICAgIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IGY7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoMiAqIGZhciAqIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKiovXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXTtcblxuICAgIG91dFswXSA9IGFbMF0gKiB4O1xuICAgIG91dFsxXSA9IGFbMV0gKiB4O1xuICAgIG91dFsyXSA9IGFbMl0gKiB4O1xuICAgIG91dFszXSA9IGFbM10gKiB4O1xuICAgIG91dFs0XSA9IGFbNF0gKiB5O1xuICAgIG91dFs1XSA9IGFbNV0gKiB5O1xuICAgIG91dFs2XSA9IGFbNl0gKiB5O1xuICAgIG91dFs3XSA9IGFbN10gKiB5O1xuICAgIG91dFs4XSA9IGFbOF0gKiB6O1xuICAgIG91dFs5XSA9IGFbOV0gKiB6O1xuICAgIG91dFsxMF0gPSBhWzEwXSAqIHo7XG4gICAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2xhdGU7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdLFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gICAgaWYgKGEgPT09IG91dCkge1xuICAgICAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgICAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgICAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzBdID0gYTAwOyBvdXRbMV0gPSBhMDE7IG91dFsyXSA9IGEwMjsgb3V0WzNdID0gYTAzO1xuICAgICAgICBvdXRbNF0gPSBhMTA7IG91dFs1XSA9IGExMTsgb3V0WzZdID0gYTEyOyBvdXRbN10gPSBhMTM7XG4gICAgICAgIG91dFs4XSA9IGEyMDsgb3V0WzldID0gYTIxOyBvdXRbMTBdID0gYTIyOyBvdXRbMTFdID0gYTIzO1xuXG4gICAgICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHBhcnNlRXJyb3JzXG5cbmZ1bmN0aW9uIHBhcnNlRXJyb3JzKGxvZykge1xuICBsb2cgPSBTdHJpbmcobG9nKVxuXG4gIHZhciBsb2dzID0gW11cbiAgdmFyIHJlc3VsdFxuXG4gIHdoaWxlIChyZXN1bHQgPSBsb2cubWF0Y2goL0VSUk9SXFw6KFteXFxuXSspLykpIHtcbiAgICBsb2cgPSBsb2cuc2xpY2UocmVzdWx0LmluZGV4ICsgMSlcblxuICAgIHZhciBsaW5lID0gcmVzdWx0WzFdLnRyaW0oKVxuICAgIHZhciBzZXBzID0gbGluZS5zcGxpdCgnOicpXG4gICAgdmFyIGVtc2cgPSBzZXBzLnNsaWNlKDIpLmpvaW4oJzonKS50cmltKClcbiAgICB2YXIgZmlsZSA9IHBhcnNlSW50KHNlcHNbMF0sIDEwKVxuICAgIHZhciBsaW5lID0gcGFyc2VJbnQoc2Vwc1sxXSwgMTApXG5cbiAgICBsb2dzLnB1c2goe1xuICAgICAgICBtZXNzYWdlOiBlbXNnXG4gICAgICAsIGZpbGU6IGZpbGVcbiAgICAgICwgbGluZTogbGluZVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gbG9nc1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJcbi8qKlxuICogaXNBcnJheVxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiB0b1N0cmluZ1xuICovXG5cbnZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBgdmFsYFxuICogaXMgYW4gYXJyYXkuXG4gKlxuICogZXhhbXBsZTpcbiAqXG4gKiAgICAgICAgaXNBcnJheShbXSk7XG4gKiAgICAgICAgLy8gPiB0cnVlXG4gKiAgICAgICAgaXNBcnJheShhcmd1bWVudHMpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqICAgICAgICBpc0FycmF5KCcnKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKlxuICogQHBhcmFtIHttaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiAhISB2YWwgJiYgJ1tvYmplY3QgQXJyYXldJyA9PSBzdHIuY2FsbCh2YWwpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgeWFtbCA9IHJlcXVpcmUoJy4vbGliL2pzLXlhbWwuanMnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHlhbWw7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGxvYWRlciA9IHJlcXVpcmUoJy4vanMteWFtbC9sb2FkZXInKTtcbi8vIHZhciBkdW1wZXIgPSByZXF1aXJlKCcuL2pzLXlhbWwvZHVtcGVyJyk7XG5cblxuZnVuY3Rpb24gZGVwcmVjYXRlZChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiAnICsgbmFtZSArICcgaXMgZGVwcmVjYXRlZCBhbmQgY2Fubm90IGJlIHVzZWQuJyk7XG4gIH07XG59XG5cblxubW9kdWxlLmV4cG9ydHMuVHlwZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC90eXBlJyk7XG5tb2R1bGUuZXhwb3J0cy5TY2hlbWEgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYScpO1xubW9kdWxlLmV4cG9ydHMuRkFJTFNBRkVfU0NIRU1BICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmUnKTtcbm1vZHVsZS5leHBvcnRzLkpTT05fU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2pzb24nKTtcbm1vZHVsZS5leHBvcnRzLkNPUkVfU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5tb2R1bGUuZXhwb3J0cy5sb2FkICAgICAgICAgICAgICAgID0gbG9hZGVyLmxvYWQ7XG5tb2R1bGUuZXhwb3J0cy5sb2FkQWxsICAgICAgICAgICAgID0gbG9hZGVyLmxvYWRBbGw7XG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZCAgICAgICAgICAgID0gbG9hZGVyLnNhZmVMb2FkO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgICAgICAgICA9IGxvYWRlci5zYWZlTG9hZEFsbDtcbi8vIG1vZHVsZS5leHBvcnRzLmR1bXAgICAgICAgICAgICAgICAgPSBkdW1wZXIuZHVtcDtcbi8vIG1vZHVsZS5leHBvcnRzLnNhZmVEdW1wICAgICAgICAgICAgPSBkdW1wZXIuc2FmZUR1bXA7XG5tb2R1bGUuZXhwb3J0cy5ZQU1MRXhjZXB0aW9uICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL2V4Y2VwdGlvbicpO1xuXG4vLyBEZXByZWNhdGVkIHNjaGVtYSBuYW1lcyBmcm9tIEpTLVlBTUwgMi4wLnhcbm1vZHVsZS5leHBvcnRzLk1JTklNQUxfU0NIRU1BID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuU0FGRV9TQ0hFTUEgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xuXG4vLyBEZXByZWNhdGVkIGZ1bmN0aW9ucyBmcm9tIEpTLVlBTUwgMS54Lnhcbm1vZHVsZS5leHBvcnRzLnNjYW4gICAgICAgICAgID0gZGVwcmVjYXRlZCgnc2NhbicpO1xubW9kdWxlLmV4cG9ydHMucGFyc2UgICAgICAgICAgPSBkZXByZWNhdGVkKCdwYXJzZScpO1xubW9kdWxlLmV4cG9ydHMuY29tcG9zZSAgICAgICAgPSBkZXByZWNhdGVkKCdjb21wb3NlJyk7XG5tb2R1bGUuZXhwb3J0cy5hZGRDb25zdHJ1Y3RvciA9IGRlcHJlY2F0ZWQoJ2FkZENvbnN0cnVjdG9yJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gaXNOb3RoaW5nKHN1YmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygc3ViamVjdCA9PT0gJ3VuZGVmaW5lZCcpIHx8IChzdWJqZWN0ID09PSBudWxsKTtcbn1cblxuXG5mdW5jdGlvbiBpc09iamVjdChzdWJqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnKSAmJiAoc3ViamVjdCAhPT0gbnVsbCk7XG59XG5cblxuZnVuY3Rpb24gdG9BcnJheShzZXF1ZW5jZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzZXF1ZW5jZSkpIHJldHVybiBzZXF1ZW5jZTtcbiAgZWxzZSBpZiAoaXNOb3RoaW5nKHNlcXVlbmNlKSkgcmV0dXJuIFtdO1xuXG4gIHJldHVybiBbIHNlcXVlbmNlIF07XG59XG5cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCBrZXksIHNvdXJjZUtleXM7XG5cbiAgaWYgKHNvdXJjZSkge1xuICAgIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpbmRleF07XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cblxuZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgY291bnQpIHtcbiAgdmFyIHJlc3VsdCA9ICcnLCBjeWNsZTtcblxuICBmb3IgKGN5Y2xlID0gMDsgY3ljbGUgPCBjb3VudDsgY3ljbGUgKz0gMSkge1xuICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGlzTmVnYXRpdmVaZXJvKG51bWJlcikge1xuICByZXR1cm4gKG51bWJlciA9PT0gMCkgJiYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gMSAvIG51bWJlcik7XG59XG5cblxubW9kdWxlLmV4cG9ydHMuaXNOb3RoaW5nICAgICAgPSBpc05vdGhpbmc7XG5tb2R1bGUuZXhwb3J0cy5pc09iamVjdCAgICAgICA9IGlzT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMudG9BcnJheSAgICAgICAgPSB0b0FycmF5O1xubW9kdWxlLmV4cG9ydHMucmVwZWF0ICAgICAgICAgPSByZXBlYXQ7XG5tb2R1bGUuZXhwb3J0cy5pc05lZ2F0aXZlWmVybyA9IGlzTmVnYXRpdmVaZXJvO1xubW9kdWxlLmV4cG9ydHMuZXh0ZW5kICAgICAgICAgPSBleHRlbmQ7XG4iLCIvLyBZQU1MIGVycm9yIGNsYXNzLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0NTg5ODRcbi8vXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIFlBTUxFeGNlcHRpb24ocmVhc29uLCBtYXJrKSB7XG4gIC8vIFN1cGVyIGNvbnN0cnVjdG9yXG4gIEVycm9yLmNhbGwodGhpcyk7XG5cbiAgLy8gSW5jbHVkZSBzdGFjayB0cmFjZSBpbiBlcnJvciBvYmplY3RcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgLy8gQ2hyb21lIGFuZCBOb2RlSlNcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGRiwgSUUgMTArIGFuZCBTYWZhcmkgNisuIEZhbGxiYWNrIGZvciBvdGhlcnNcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjayB8fCAnJztcbiAgfVxuXG4gIHRoaXMubmFtZSA9ICdZQU1MRXhjZXB0aW9uJztcbiAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gIHRoaXMubWFyayA9IG1hcms7XG4gIHRoaXMubWVzc2FnZSA9ICh0aGlzLnJlYXNvbiB8fCAnKHVua25vd24gcmVhc29uKScpICsgKHRoaXMubWFyayA/ICcgJyArIHRoaXMubWFyay50b1N0cmluZygpIDogJycpO1xufVxuXG5cbi8vIEluaGVyaXQgZnJvbSBFcnJvclxuWUFNTEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFlBTUxFeGNlcHRpb247XG5cblxuWUFNTEV4Y2VwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhjb21wYWN0KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLm5hbWUgKyAnOiAnO1xuXG4gIHJlc3VsdCArPSB0aGlzLnJlYXNvbiB8fCAnKHVua25vd24gcmVhc29uKSc7XG5cbiAgaWYgKCFjb21wYWN0ICYmIHRoaXMubWFyaykge1xuICAgIHJlc3VsdCArPSAnICcgKyB0aGlzLm1hcmsudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gWUFNTEV4Y2VwdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuLG5vLXVzZS1iZWZvcmUtZGVmaW5lKi9cblxudmFyIGNvbW1vbiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIFlBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIE1hcmsgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL21hcmsnKTtcbnZhciBERUZBVUxUX1NBRkVfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9zYWZlJyk7XG52YXIgREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xuXG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cbnZhciBDT05URVhUX0ZMT1dfSU4gICA9IDE7XG52YXIgQ09OVEVYVF9GTE9XX09VVCAgPSAyO1xudmFyIENPTlRFWFRfQkxPQ0tfSU4gID0gMztcbnZhciBDT05URVhUX0JMT0NLX09VVCA9IDQ7XG5cblxudmFyIENIT01QSU5HX0NMSVAgID0gMTtcbnZhciBDSE9NUElOR19TVFJJUCA9IDI7XG52YXIgQ0hPTVBJTkdfS0VFUCAgPSAzO1xuXG5cbnZhciBQQVRURVJOX05PTl9QUklOVEFCTEUgICAgICAgICA9IC9bXFx4MDAtXFx4MDhcXHgwQlxceDBDXFx4MEUtXFx4MUZcXHg3Ri1cXHg4NFxceDg2LVxceDlGXFx1RkZGRVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdLztcbnZhciBQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUyA9IC9bXFx4ODVcXHUyMDI4XFx1MjAyOV0vO1xudmFyIFBBVFRFUk5fRkxPV19JTkRJQ0FUT1JTICAgICAgID0gL1ssXFxbXFxdXFx7XFx9XS87XG52YXIgUEFUVEVSTl9UQUdfSEFORExFICAgICAgICAgICAgPSAvXig/OiF8ISF8IVthLXpcXC1dKyEpJC9pO1xudmFyIFBBVFRFUk5fVEFHX1VSSSAgICAgICAgICAgICAgID0gL14oPzohfFteLFxcW1xcXVxce1xcfV0pKD86JVswLTlhLWZdezJ9fFswLTlhLXpcXC0jO1xcL1xcPzpAJj1cXCtcXCQsX1xcLiF+XFwqJ1xcKFxcKVxcW1xcXV0pKiQvaTtcblxuXG5mdW5jdGlvbiBpc19FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MEEvKiBMRiAqLykgfHwgKGMgPT09IDB4MEQvKiBDUiAqLyk7XG59XG5cbmZ1bmN0aW9uIGlzX1dISVRFX1NQQUNFKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDA5LyogVGFiICovKSB8fCAoYyA9PT0gMHgyMC8qIFNwYWNlICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV1NfT1JfRU9MKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDA5LyogVGFiICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MjAvKiBTcGFjZSAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBBLyogTEYgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfRkxPV19JTkRJQ0FUT1IoYykge1xuICByZXR1cm4gYyA9PT0gMHgyQy8qICwgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4NUIvKiBbICovIHx8XG4gICAgICAgICBjID09PSAweDVELyogXSAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg3Qi8qIHsgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4N0QvKiB9ICovO1xufVxuXG5mdW5jdGlvbiBmcm9tSGV4Q29kZShjKSB7XG4gIHZhciBsYztcblxuICBpZiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkge1xuICAgIHJldHVybiBjIC0gMHgzMDtcbiAgfVxuXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSovXG4gIGxjID0gYyB8IDB4MjA7XG5cbiAgaWYgKCgweDYxLyogYSAqLyA8PSBsYykgJiYgKGxjIDw9IDB4NjYvKiBmICovKSkge1xuICAgIHJldHVybiBsYyAtIDB4NjEgKyAxMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlZEhleExlbihjKSB7XG4gIGlmIChjID09PSAweDc4LyogeCAqLykgeyByZXR1cm4gMjsgfVxuICBpZiAoYyA9PT0gMHg3NS8qIHUgKi8pIHsgcmV0dXJuIDQ7IH1cbiAgaWYgKGMgPT09IDB4NTUvKiBVICovKSB7IHJldHVybiA4OyB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBmcm9tRGVjaW1hbENvZGUoYykge1xuICBpZiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkge1xuICAgIHJldHVybiBjIC0gMHgzMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRXNjYXBlU2VxdWVuY2UoYykge1xuICByZXR1cm4gKGMgPT09IDB4MzAvKiAwICovKSA/ICdcXHgwMCcgOlxuICAgICAgICAoYyA9PT0gMHg2MS8qIGEgKi8pID8gJ1xceDA3JyA6XG4gICAgICAgIChjID09PSAweDYyLyogYiAqLykgPyAnXFx4MDgnIDpcbiAgICAgICAgKGMgPT09IDB4NzQvKiB0ICovKSA/ICdcXHgwOScgOlxuICAgICAgICAoYyA9PT0gMHgwOS8qIFRhYiAqLykgPyAnXFx4MDknIDpcbiAgICAgICAgKGMgPT09IDB4NkUvKiBuICovKSA/ICdcXHgwQScgOlxuICAgICAgICAoYyA9PT0gMHg3Ni8qIHYgKi8pID8gJ1xceDBCJyA6XG4gICAgICAgIChjID09PSAweDY2LyogZiAqLykgPyAnXFx4MEMnIDpcbiAgICAgICAgKGMgPT09IDB4NzIvKiByICovKSA/ICdcXHgwRCcgOlxuICAgICAgICAoYyA9PT0gMHg2NS8qIGUgKi8pID8gJ1xceDFCJyA6XG4gICAgICAgIChjID09PSAweDIwLyogU3BhY2UgKi8pID8gJyAnIDpcbiAgICAgICAgKGMgPT09IDB4MjIvKiBcIiAqLykgPyAnXFx4MjInIDpcbiAgICAgICAgKGMgPT09IDB4MkYvKiAvICovKSA/ICcvJyA6XG4gICAgICAgIChjID09PSAweDVDLyogXFwgKi8pID8gJ1xceDVDJyA6XG4gICAgICAgIChjID09PSAweDRFLyogTiAqLykgPyAnXFx4ODUnIDpcbiAgICAgICAgKGMgPT09IDB4NUYvKiBfICovKSA/ICdcXHhBMCcgOlxuICAgICAgICAoYyA9PT0gMHg0Qy8qIEwgKi8pID8gJ1xcdTIwMjgnIDpcbiAgICAgICAgKGMgPT09IDB4NTAvKiBQICovKSA/ICdcXHUyMDI5JyA6ICcnO1xufVxuXG5mdW5jdGlvbiBjaGFyRnJvbUNvZGVwb2ludChjKSB7XG4gIGlmIChjIDw9IDB4RkZGRikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICB9XG4gIC8vIEVuY29kZSBVVEYtMTYgc3Vycm9nYXRlIHBhaXJcbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTE2I0NvZGVfcG9pbnRzX1UuMkIwMTAwMDBfdG9fVS4yQjEwRkZGRlxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgLSAweDAxMDAwMCkgPj4gMTApICsgMHhEODAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGMgLSAweDAxMDAwMCkgJiAweDAzRkYpICsgMHhEQzAwKTtcbn1cblxudmFyIHNpbXBsZUVzY2FwZUNoZWNrID0gbmV3IEFycmF5KDI1Nik7IC8vIGludGVnZXIsIGZvciBmYXN0IGFjY2Vzc1xudmFyIHNpbXBsZUVzY2FwZU1hcCA9IG5ldyBBcnJheSgyNTYpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICBzaW1wbGVFc2NhcGVDaGVja1tpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpID8gMSA6IDA7XG4gIHNpbXBsZUVzY2FwZU1hcFtpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpO1xufVxuXG5cbmZ1bmN0aW9uIFN0YXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHRoaXMuaW5wdXQgPSBpbnB1dDtcblxuICB0aGlzLmZpbGVuYW1lICA9IG9wdGlvbnNbJ2ZpbGVuYW1lJ10gIHx8IG51bGw7XG4gIHRoaXMuc2NoZW1hICAgID0gb3B0aW9uc1snc2NoZW1hJ10gICAgfHwgREVGQVVMVF9GVUxMX1NDSEVNQTtcbiAgdGhpcy5vbldhcm5pbmcgPSBvcHRpb25zWydvbldhcm5pbmcnXSB8fCBudWxsO1xuICB0aGlzLmxlZ2FjeSAgICA9IG9wdGlvbnNbJ2xlZ2FjeSddICAgIHx8IGZhbHNlO1xuICB0aGlzLmpzb24gICAgICA9IG9wdGlvbnNbJ2pzb24nXSAgICAgIHx8IGZhbHNlO1xuICB0aGlzLmxpc3RlbmVyICA9IG9wdGlvbnNbJ2xpc3RlbmVyJ10gIHx8IG51bGw7XG5cbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy50eXBlTWFwICAgICAgID0gdGhpcy5zY2hlbWEuY29tcGlsZWRUeXBlTWFwO1xuXG4gIHRoaXMubGVuZ3RoICAgICA9IGlucHV0Lmxlbmd0aDtcbiAgdGhpcy5wb3NpdGlvbiAgID0gMDtcbiAgdGhpcy5saW5lICAgICAgID0gMDtcbiAgdGhpcy5saW5lU3RhcnQgID0gMDtcbiAgdGhpcy5saW5lSW5kZW50ID0gMDtcblxuICB0aGlzLmRvY3VtZW50cyA9IFtdO1xuXG4gIC8qXG4gIHRoaXMudmVyc2lvbjtcbiAgdGhpcy5jaGVja0xpbmVCcmVha3M7XG4gIHRoaXMudGFnTWFwO1xuICB0aGlzLmFuY2hvck1hcDtcbiAgdGhpcy50YWc7XG4gIHRoaXMuYW5jaG9yO1xuICB0aGlzLmtpbmQ7XG4gIHRoaXMucmVzdWx0OyovXG5cbn1cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgWUFNTEV4Y2VwdGlvbihcbiAgICBtZXNzYWdlLFxuICAgIG5ldyBNYXJrKHN0YXRlLmZpbGVuYW1lLCBzdGF0ZS5pbnB1dCwgc3RhdGUucG9zaXRpb24sIHN0YXRlLmxpbmUsIChzdGF0ZS5wb3NpdGlvbiAtIHN0YXRlLmxpbmVTdGFydCkpKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB0aHJvdyBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dXYXJuaW5nKHN0YXRlLCBtZXNzYWdlKSB7XG4gIGlmIChzdGF0ZS5vbldhcm5pbmcpIHtcbiAgICBzdGF0ZS5vbldhcm5pbmcuY2FsbChudWxsLCBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSk7XG4gIH1cbn1cblxuXG52YXIgZGlyZWN0aXZlSGFuZGxlcnMgPSB7XG5cbiAgWUFNTDogZnVuY3Rpb24gaGFuZGxlWWFtbERpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgdmFyIG1hdGNoLCBtYWpvciwgbWlub3I7XG5cbiAgICBpZiAoc3RhdGUudmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mICVZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1lBTUwgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSBvbmUgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBtYXRjaCA9IC9eKFswLTldKylcXC4oWzAtOV0rKSQvLmV4ZWMoYXJnc1swXSk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIGFyZ3VtZW50IG9mIHRoZSBZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIG1ham9yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICBtaW5vciA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG5cbiAgICBpZiAobWFqb3IgIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cblxuICAgIHN0YXRlLnZlcnNpb24gPSBhcmdzWzBdO1xuICAgIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IChtaW5vciA8IDIpO1xuXG4gICAgaWYgKG1pbm9yICE9PSAxICYmIG1pbm9yICE9PSAyKSB7XG4gICAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICd1bnN1cHBvcnRlZCBZQU1MIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50Jyk7XG4gICAgfVxuICB9LFxuXG4gIFRBRzogZnVuY3Rpb24gaGFuZGxlVGFnRGlyZWN0aXZlKHN0YXRlLCBuYW1lLCBhcmdzKSB7XG5cbiAgICB2YXIgaGFuZGxlLCBwcmVmaXg7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdUQUcgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSB0d28gYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgaGFuZGxlID0gYXJnc1swXTtcbiAgICBwcmVmaXggPSBhcmdzWzFdO1xuXG4gICAgaWYgKCFQQVRURVJOX1RBR19IQU5ETEUudGVzdChoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUudGFnTWFwLCBoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlcmUgaXMgYSBwcmV2aW91c2x5IGRlY2xhcmVkIHN1ZmZpeCBmb3IgXCInICsgaGFuZGxlICsgJ1wiIHRhZyBoYW5kbGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIVBBVFRFUk5fVEFHX1VSSS50ZXN0KHByZWZpeCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIHRhZyBwcmVmaXggKHNlY29uZCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS50YWdNYXBbaGFuZGxlXSA9IHByZWZpeDtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBjYXB0dXJlU2VnbWVudChzdGF0ZSwgc3RhcnQsIGVuZCwgY2hlY2tKc29uKSB7XG4gIHZhciBfcG9zaXRpb24sIF9sZW5ndGgsIF9jaGFyYWN0ZXIsIF9yZXN1bHQ7XG5cbiAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgX3Jlc3VsdCA9IHN0YXRlLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgaWYgKGNoZWNrSnNvbikge1xuICAgICAgZm9yIChfcG9zaXRpb24gPSAwLCBfbGVuZ3RoID0gX3Jlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgIF9wb3NpdGlvbiA8IF9sZW5ndGg7XG4gICAgICAgICAgIF9wb3NpdGlvbiArPSAxKSB7XG4gICAgICAgIF9jaGFyYWN0ZXIgPSBfcmVzdWx0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcbiAgICAgICAgaWYgKCEoX2NoYXJhY3RlciA9PT0gMHgwOSB8fFxuICAgICAgICAgICAgICAoMHgyMCA8PSBfY2hhcmFjdGVyICYmIF9jaGFyYWN0ZXIgPD0gMHgxMEZGRkYpKSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdleHBlY3RlZCB2YWxpZCBKU09OIGNoYXJhY3RlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChQQVRURVJOX05PTl9QUklOVEFCTEUudGVzdChfcmVzdWx0KSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RoZSBzdHJlYW0gY29udGFpbnMgbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuXG4gICAgc3RhdGUucmVzdWx0ICs9IF9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgZGVzdGluYXRpb24sIHNvdXJjZSwgb3ZlcnJpZGFibGVLZXlzKSB7XG4gIHZhciBzb3VyY2VLZXlzLCBrZXksIGluZGV4LCBxdWFudGl0eTtcblxuICBpZiAoIWNvbW1vbi5pc09iamVjdChzb3VyY2UpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Nhbm5vdCBtZXJnZSBtYXBwaW5nczsgdGhlIHByb3ZpZGVkIHNvdXJjZSBvYmplY3QgaXMgdW5hY2NlcHRhYmxlJyk7XG4gIH1cblxuICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBxdWFudGl0eTsgaW5kZXggKz0gMSkge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuXG4gICAgaWYgKCFfaGFzT3duUHJvcGVydHkuY2FsbChkZXN0aW5hdGlvbiwga2V5KSkge1xuICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgb3ZlcnJpZGFibGVLZXlzW2tleV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKSB7XG4gIHZhciBpbmRleCwgcXVhbnRpdHk7XG5cbiAga2V5Tm9kZSA9IFN0cmluZyhrZXlOb2RlKTtcblxuICBpZiAoX3Jlc3VsdCA9PT0gbnVsbCkge1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfVxuXG4gIGlmIChrZXlUYWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZU5vZGUpKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSB2YWx1ZU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZVtpbmRleF0sIG92ZXJyaWRhYmxlS2V5cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZSwgb3ZlcnJpZGFibGVLZXlzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFzdGF0ZS5qc29uICYmXG4gICAgICAgICFfaGFzT3duUHJvcGVydHkuY2FsbChvdmVycmlkYWJsZUtleXMsIGtleU5vZGUpICYmXG4gICAgICAgIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKF9yZXN1bHQsIGtleU5vZGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRlZCBtYXBwaW5nIGtleScpO1xuICAgIH1cbiAgICBfcmVzdWx0W2tleU5vZGVdID0gdmFsdWVOb2RlO1xuICAgIGRlbGV0ZSBvdmVycmlkYWJsZUtleXNba2V5Tm9kZV07XG4gIH1cblxuICByZXR1cm4gX3Jlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVhZExpbmVCcmVhayhzdGF0ZSkge1xuICB2YXIgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4MEEvKiBMRiAqLykge1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4MEQvKiBDUiAqLykge1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgaWYgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDBBLyogTEYgKi8pIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdhIGxpbmUgYnJlYWsgaXMgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIHN0YXRlLmxpbmUgKz0gMTtcbiAgc3RhdGUubGluZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG59XG5cbmZ1bmN0aW9uIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGFsbG93Q29tbWVudHMsIGNoZWNrSW5kZW50KSB7XG4gIHZhciBsaW5lQnJlYWtzID0gMCxcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmIChhbGxvd0NvbW1lbnRzICYmIGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgZG8ge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9IHdoaWxlIChjaCAhPT0gMHgwQS8qIExGICovICYmIGNoICE9PSAweDBELyogQ1IgKi8gJiYgY2ggIT09IDApO1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICByZWFkTGluZUJyZWFrKHN0YXRlKTtcblxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgIGxpbmVCcmVha3MrKztcbiAgICAgIHN0YXRlLmxpbmVJbmRlbnQgPSAwO1xuXG4gICAgICB3aGlsZSAoY2ggPT09IDB4MjAvKiBTcGFjZSAqLykge1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50Kys7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNoZWNrSW5kZW50ICE9PSAtMSAmJiBsaW5lQnJlYWtzICE9PSAwICYmIHN0YXRlLmxpbmVJbmRlbnQgPCBjaGVja0luZGVudCkge1xuICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ2RlZmljaWVudCBpbmRlbnRhdGlvbicpO1xuICB9XG5cbiAgcmV0dXJuIGxpbmVCcmVha3M7XG59XG5cbmZ1bmN0aW9uIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb24sXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcblxuICAvLyBDb25kaXRpb24gc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCBpcyB0ZXN0ZWRcbiAgLy8gaW4gcGFyZW50IG9uIGVhY2ggY2FsbCwgZm9yIGVmZmljaWVuY3kuIE5vIG5lZWRzIHRvIHRlc3QgaGVyZSBhZ2Fpbi5cbiAgaWYgKChjaCA9PT0gMHgyRC8qIC0gKi8gfHwgY2ggPT09IDB4MkUvKiAuICovKSAmJlxuICAgICAgY2ggPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMSkgJiZcbiAgICAgIGNoID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbiArIDIpKSB7XG5cbiAgICBfcG9zaXRpb24gKz0gMztcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAwIHx8IGlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgY291bnQpIHtcbiAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgc3RhdGUucmVzdWx0ICs9ICcgJztcbiAgfSBlbHNlIGlmIChjb3VudCA+IDEpIHtcbiAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgY291bnQgLSAxKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHJlYWRQbGFpblNjYWxhcihzdGF0ZSwgbm9kZUluZGVudCwgd2l0aGluRmxvd0NvbGxlY3Rpb24pIHtcbiAgdmFyIHByZWNlZGluZyxcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIGNhcHR1cmVTdGFydCxcbiAgICAgIGNhcHR1cmVFbmQsXG4gICAgICBoYXNQZW5kaW5nQ29udGVudCxcbiAgICAgIF9saW5lLFxuICAgICAgX2xpbmVTdGFydCxcbiAgICAgIF9saW5lSW5kZW50LFxuICAgICAgX2tpbmQgPSBzdGF0ZS5raW5kLFxuICAgICAgX3Jlc3VsdCA9IHN0YXRlLnJlc3VsdCxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGlzX1dTX09SX0VPTChjaCkgICAgICB8fFxuICAgICAgaXNfRkxPV19JTkRJQ0FUT1IoY2gpIHx8XG4gICAgICBjaCA9PT0gMHgyMy8qICMgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDI2LyogJiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MkEvKiAqICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyMS8qICEgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDdDLyogfCAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4M0UvKiA+ICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyNy8qICcgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDIyLyogXCIgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDI1LyogJSAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4NDAvKiBAICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg2MC8qIGAgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoY2ggPT09IDB4M0YvKiA/ICovIHx8IGNoID09PSAweDJELyogLSAqLykge1xuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgIGlmIChpc19XU19PUl9FT0woZm9sbG93aW5nKSB8fFxuICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICBoYXNQZW5kaW5nQ29udGVudCA9IGZhbHNlO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8XG4gICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoZm9sbG93aW5nKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICBwcmVjZWRpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uIC0gMSk7XG5cbiAgICAgIGlmIChpc19XU19PUl9FT0wocHJlY2VkaW5nKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkgfHxcbiAgICAgICAgICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgICAgYnJlYWs7XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIF9saW5lID0gc3RhdGUubGluZTtcbiAgICAgIF9saW5lU3RhcnQgPSBzdGF0ZS5saW5lU3RhcnQ7XG4gICAgICBfbGluZUluZGVudCA9IHN0YXRlLmxpbmVJbmRlbnQ7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgLTEpO1xuXG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA+PSBub2RlSW5kZW50KSB7XG4gICAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbiA9IGNhcHR1cmVFbmQ7XG4gICAgICAgIHN0YXRlLmxpbmUgPSBfbGluZTtcbiAgICAgICAgc3RhdGUubGluZVN0YXJ0ID0gX2xpbmVTdGFydDtcbiAgICAgICAgc3RhdGUubGluZUluZGVudCA9IF9saW5lSW5kZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzUGVuZGluZ0NvbnRlbnQpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIGZhbHNlKTtcbiAgICAgIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIHN0YXRlLmxpbmUgLSBfbGluZSk7XG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgICBoYXNQZW5kaW5nQ29udGVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb24gKyAxO1xuICAgIH1cblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIGZhbHNlKTtcblxuICBpZiAoc3RhdGUucmVzdWx0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gX2tpbmQ7XG4gIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZFNpbmdsZVF1b3RlZFNjYWxhcihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgY2gsXG4gICAgICBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQ7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjcvKiAnICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgc3RhdGUucG9zaXRpb24rKztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkgIT09IDApIHtcbiAgICBpZiAoY2ggPT09IDB4MjcvKiAnICovKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgyNy8qICcgKi8pIHtcbiAgICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGV4TGVuZ3RoLFxuICAgICAgaGV4UmVzdWx0LFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjIvKiBcIiAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIHN0YXRlLnBvc2l0aW9uKys7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDIyLyogXCIgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUMvKiBcXCAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCk7XG5cbiAgICAgICAgLy8gVE9ETzogcmV3b3JrIHRvIGlubGluZSBmbiB3aXRoIG5vIHR5cGUgY2FzdD9cbiAgICAgIH0gZWxzZSBpZiAoY2ggPCAyNTYgJiYgc2ltcGxlRXNjYXBlQ2hlY2tbY2hdKSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBzaW1wbGVFc2NhcGVNYXBbY2hdO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2UgaWYgKCh0bXAgPSBlc2NhcGVkSGV4TGVuKGNoKSkgPiAwKSB7XG4gICAgICAgIGhleExlbmd0aCA9IHRtcDtcbiAgICAgICAgaGV4UmVzdWx0ID0gMDtcblxuICAgICAgICBmb3IgKDsgaGV4TGVuZ3RoID4gMDsgaGV4TGVuZ3RoLS0pIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoKHRtcCA9IGZyb21IZXhDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgICAgICAgaGV4UmVzdWx0ID0gKGhleFJlc3VsdCA8PCA0KSArIHRtcDtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgaGV4YWRlY2ltYWwgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNoYXJGcm9tQ29kZXBvaW50KGhleFJlc3VsdCk7XG5cbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3Vua25vd24gZXNjYXBlIHNlcXVlbmNlJyk7XG4gICAgICB9XG5cbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgcmVhZE5leHQgPSB0cnVlLFxuICAgICAgX2xpbmUsXG4gICAgICBfdGFnICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9yZXN1bHQsXG4gICAgICBfYW5jaG9yICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIHRlcm1pbmF0b3IsXG4gICAgICBpc1BhaXIsXG4gICAgICBpc0V4cGxpY2l0UGFpcixcbiAgICAgIGlzTWFwcGluZyxcbiAgICAgIG92ZXJyaWRhYmxlS2V5cyA9IHt9LFxuICAgICAga2V5Tm9kZSxcbiAgICAgIGtleVRhZyxcbiAgICAgIHZhbHVlTm9kZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDVCLyogWyAqLykge1xuICAgIHRlcm1pbmF0b3IgPSAweDVEOy8qIF0gKi9cbiAgICBpc01hcHBpbmcgPSBmYWxzZTtcbiAgICBfcmVzdWx0ID0gW107XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4N0IvKiB7ICovKSB7XG4gICAgdGVybWluYXRvciA9IDB4N0Q7LyogfSAqL1xuICAgIGlzTWFwcGluZyA9IHRydWU7XG4gICAgX3Jlc3VsdCA9IHt9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSB0ZXJtaW5hdG9yKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICBzdGF0ZS5raW5kID0gaXNNYXBwaW5nID8gJ21hcHBpbmcnIDogJ3NlcXVlbmNlJztcbiAgICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFyZWFkTmV4dCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ21pc3NlZCBjb21tYSBiZXR3ZWVuIGZsb3cgY29sbGVjdGlvbiBlbnRyaWVzJyk7XG4gICAgfVxuXG4gICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSBmYWxzZTtcblxuICAgIGlmIChjaCA9PT0gMHgzRi8qID8gKi8pIHtcbiAgICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICAgIGlzUGFpciA9IGlzRXhwbGljaXRQYWlyID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICBrZXlUYWcgPSBzdGF0ZS50YWc7XG4gICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKGlzRXhwbGljaXRQYWlyIHx8IHN0YXRlLmxpbmUgPT09IF9saW5lKSAmJiBjaCA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGlzUGFpciA9IHRydWU7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoaXNNYXBwaW5nKSB7XG4gICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzUGFpcikge1xuICAgICAgX3Jlc3VsdC5wdXNoKHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIG51bGwsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Jlc3VsdC5wdXNoKGtleU5vZGUpO1xuICAgIH1cblxuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMHgyQy8qICwgKi8pIHtcbiAgICAgIHJlYWROZXh0ID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVhZE5leHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBmbG93IGNvbGxlY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBmb2xkaW5nLFxuICAgICAgY2hvbXBpbmcgICAgICAgPSBDSE9NUElOR19DTElQLFxuICAgICAgZGV0ZWN0ZWRJbmRlbnQgPSBmYWxzZSxcbiAgICAgIHRleHRJbmRlbnQgICAgID0gbm9kZUluZGVudCxcbiAgICAgIGVtcHR5TGluZXMgICAgID0gMCxcbiAgICAgIGF0TW9yZUluZGVudGVkID0gZmFsc2UsXG4gICAgICB0bXAsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHg3Qy8qIHwgKi8pIHtcbiAgICBmb2xkaW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4M0UvKiA+ICovKSB7XG4gICAgZm9sZGluZyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDB4MkIvKiArICovIHx8IGNoID09PSAweDJELyogLSAqLykge1xuICAgICAgaWYgKENIT01QSU5HX0NMSVAgPT09IGNob21waW5nKSB7XG4gICAgICAgIGNob21waW5nID0gKGNoID09PSAweDJCLyogKyAqLykgPyBDSE9NUElOR19LRUVQIDogQ0hPTVBJTkdfU1RSSVA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGEgY2hvbXBpbmcgbW9kZSBpZGVudGlmaWVyJyk7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCh0bXAgPSBmcm9tRGVjaW1hbENvZGUoY2gpKSA+PSAwKSB7XG4gICAgICBpZiAodG1wID09PSAwKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgZXhwbGljaXQgaW5kZW50YXRpb24gd2lkdGggb2YgYSBibG9jayBzY2FsYXI7IGl0IGNhbm5vdCBiZSBsZXNzIHRoYW4gb25lJyk7XG4gICAgICB9IGVsc2UgaWYgKCFkZXRlY3RlZEluZGVudCkge1xuICAgICAgICB0ZXh0SW5kZW50ID0gbm9kZUluZGVudCArIHRtcCAtIDE7XG4gICAgICAgIGRldGVjdGVkSW5kZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdyZXBlYXQgb2YgYW4gaW5kZW50YXRpb24gd2lkdGggaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpO1xuXG4gICAgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICAgIHdoaWxlICghaXNfRU9MKGNoKSAmJiAoY2ggIT09IDApKTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICByZWFkTGluZUJyZWFrKHN0YXRlKTtcbiAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICB3aGlsZSAoKCFkZXRlY3RlZEluZGVudCB8fCBzdGF0ZS5saW5lSW5kZW50IDwgdGV4dEluZGVudCkgJiZcbiAgICAgICAgICAgKGNoID09PSAweDIwLyogU3BhY2UgKi8pKSB7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50Kys7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKCFkZXRlY3RlZEluZGVudCAmJiBzdGF0ZS5saW5lSW5kZW50ID4gdGV4dEluZGVudCkge1xuICAgICAgdGV4dEluZGVudCA9IHN0YXRlLmxpbmVJbmRlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGVtcHR5TGluZXMrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEVuZCBvZiB0aGUgc2NhbGFyLlxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgdGV4dEluZGVudCkge1xuXG4gICAgICAvLyBQZXJmb3JtIHRoZSBjaG9tcGluZy5cbiAgICAgIGlmIChjaG9tcGluZyA9PT0gQ0hPTVBJTkdfS0VFUCkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyk7XG4gICAgICB9IGVsc2UgaWYgKGNob21waW5nID09PSBDSE9NUElOR19DTElQKSB7XG4gICAgICAgIGlmIChkZXRlY3RlZEluZGVudCkgeyAvLyBpLmUuIG9ubHkgaWYgdGhlIHNjYWxhciBpcyBub3QgZW1wdHkuXG4gICAgICAgICAgc3RhdGUucmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEJyZWFrIHRoaXMgYHdoaWxlYCBjeWNsZSBhbmQgZ28gdG8gdGhlIGZ1bmNpdG9uJ3MgZXBpbG9ndWUuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBGb2xkZWQgc3R5bGU6IHVzZSBmYW5jeSBydWxlcyB0byBoYW5kbGUgbGluZSBicmVha3MuXG4gICAgaWYgKGZvbGRpbmcpIHtcblxuICAgICAgLy8gTGluZXMgc3RhcnRpbmcgd2l0aCB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzIChtb3JlLWluZGVudGVkIGxpbmVzKSBhcmUgbm90IGZvbGRlZC5cbiAgICAgIGlmIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgYXRNb3JlSW5kZW50ZWQgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyArIDEpO1xuXG4gICAgICAvLyBFbmQgb2YgbW9yZS1pbmRlbnRlZCBibG9jay5cbiAgICAgIH0gZWxzZSBpZiAoYXRNb3JlSW5kZW50ZWQpIHtcbiAgICAgICAgYXRNb3JlSW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcblxuICAgICAgLy8gSnVzdCBvbmUgbGluZSBicmVhayAtIHBlcmNlaXZlIGFzIHRoZSBzYW1lIGxpbmUuXG4gICAgICB9IGVsc2UgaWYgKGVtcHR5TGluZXMgPT09IDApIHtcbiAgICAgICAgaWYgKGRldGVjdGVkSW5kZW50KSB7IC8vIGkuZS4gb25seSBpZiB3ZSBoYXZlIGFscmVhZHkgcmVhZCBzb21lIHNjYWxhciBjb250ZW50LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gICAgICAgIH1cblxuICAgICAgLy8gU2V2ZXJhbCBsaW5lIGJyZWFrcyAtIHBlcmNlaXZlIGFzIGRpZmZlcmVudCBsaW5lcy5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzKTtcbiAgICAgIH1cblxuICAgIC8vIExpdGVyYWwgc3R5bGU6IGp1c3QgYWRkIGV4YWN0IG51bWJlciBvZiBsaW5lIGJyZWFrcyBiZXR3ZWVuIGNvbnRlbnQgbGluZXMuXG4gICAgfSBlbHNlIGlmIChkZXRlY3RlZEluZGVudCkge1xuICAgICAgLy8gSWYgY3VycmVudCBsaW5lIGlzbid0IHRoZSBmaXJzdCBvbmUgLSBjb3VudCBsaW5lIGJyZWFrIGZyb20gdGhlIGxhc3QgY29udGVudCBsaW5lLlxuICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW4gY2FzZSBvZiB0aGUgZmlyc3QgY29udGVudCBsaW5lIC0gY291bnQgb25seSBlbXB0eSBsaW5lcy5cbiAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzKTtcbiAgICB9XG5cbiAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgZW1wdHlMaW5lcyA9IDA7XG4gICAgY2FwdHVyZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIF9saW5lLFxuICAgICAgX3RhZyAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgX3Jlc3VsdCAgID0gW10sXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBkZXRlY3RlZCAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuXG4gICAgaWYgKGNoICE9PSAweDJELyogLSAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKCFpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA8PSBub2RlSW5kZW50KSB7XG4gICAgICAgIF9yZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgX3Jlc3VsdC5wdXNoKHN0YXRlLnJlc3VsdCk7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpICYmIChjaCAhPT0gMCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgaW5kZW50YXRpb24gb2YgYSBzZXF1ZW5jZSBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ3NlcXVlbmNlJztcbiAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgbm9kZUluZGVudCwgZmxvd0luZGVudCkge1xuICB2YXIgZm9sbG93aW5nLFxuICAgICAgYWxsb3dDb21wYWN0LFxuICAgICAgX2xpbmUsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgICAgICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIF9yZXN1bHQgICAgICAgPSB7fSxcbiAgICAgIG92ZXJyaWRhYmxlS2V5cyA9IHt9LFxuICAgICAga2V5VGFnICAgICAgICA9IG51bGwsXG4gICAgICBrZXlOb2RlICAgICAgID0gbnVsbCxcbiAgICAgIHZhbHVlTm9kZSAgICAgPSBudWxsLFxuICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlLFxuICAgICAgZGV0ZWN0ZWQgICAgICA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuICAgIF9saW5lID0gc3RhdGUubGluZTsgLy8gU2F2ZSB0aGUgY3VycmVudCBsaW5lLlxuXG4gICAgLy9cbiAgICAvLyBFeHBsaWNpdCBub3RhdGlvbiBjYXNlLiBUaGVyZSBhcmUgdHdvIHNlcGFyYXRlIGJsb2NrczpcbiAgICAvLyBmaXJzdCBmb3IgdGhlIGtleSAoZGVub3RlZCBieSBcIj9cIikgYW5kIHNlY29uZCBmb3IgdGhlIHZhbHVlIChkZW5vdGVkIGJ5IFwiOlwiKVxuICAgIC8vXG4gICAgaWYgKChjaCA9PT0gMHgzRi8qID8gKi8gfHwgY2ggPT09IDB4M0EvKiA6ICovKSAmJiBpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuXG4gICAgICBpZiAoY2ggPT09IDB4M0YvKiA/ICovKSB7XG4gICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xuICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIC8vIGkuZS4gMHgzQS8qIDogKi8gPT09IGNoYXJhY3RlciBhZnRlciB0aGUgZXhwbGljaXQga2V5LlxuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgIGFsbG93Q29tcGFjdCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbmNvbXBsZXRlIGV4cGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBrZXkgbm9kZSBpcyBtaXNzZWQnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgICAgIGNoID0gZm9sbG93aW5nO1xuXG4gICAgLy9cbiAgICAvLyBJbXBsaWNpdCBub3RhdGlvbiBjYXNlLiBGbG93LXN0eWxlIG5vZGUgYXMgdGhlIGtleSBmaXJzdCwgdGhlbiBcIjpcIiwgYW5kIHRoZSB2YWx1ZS5cbiAgICAvL1xuICAgIH0gZWxzZSBpZiAoY29tcG9zZU5vZGUoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19PVVQsIGZhbHNlLCB0cnVlKSkge1xuXG4gICAgICBpZiAoc3RhdGUubGluZSA9PT0gX2xpbmUpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmICghaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Egd2hpdGVzcGFjZSBjaGFyYWN0ZXIgaXMgZXhwZWN0ZWQgYWZ0ZXIgdGhlIGtleS12YWx1ZSBzZXBhcmF0b3Igd2l0aGluIGEgYmxvY2sgbWFwcGluZycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCk7XG4gICAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICAgIGFsbG93Q29tcGFjdCA9IGZhbHNlO1xuICAgICAgICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGFuIGltcGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBjb2xvbiBpcyBtaXNzZWQnKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGEgYmxvY2sgbWFwcGluZyBlbnRyeTsgYSBtdWx0aWxpbmUga2V5IG1heSBub3QgYmUgYW4gaW1wbGljaXQga2V5Jyk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhazsgLy8gUmVhZGluZyBpcyBkb25lLiBHbyB0byB0aGUgZXBpbG9ndWUuXG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBDb21tb24gcmVhZGluZyBjb2RlIGZvciBib3RoIGV4cGxpY2l0IGFuZCBpbXBsaWNpdCBub3RhdGlvbnMuXG4gICAgLy9cbiAgICBpZiAoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpIHtcbiAgICAgIGlmIChjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19PVVQsIHRydWUsIGFsbG93Q29tcGFjdCkpIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSk7XG4gICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCAmJiAoY2ggIT09IDApKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgbWFwcGluZyBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIEVwaWxvZ3VlLlxuICAvL1xuXG4gIC8vIFNwZWNpYWwgY2FzZTogbGFzdCBtYXBwaW5nJ3Mgbm9kZSBjb250YWlucyBvbmx5IHRoZSBrZXkgaW4gZXhwbGljaXQgbm90YXRpb24uXG4gIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xuICB9XG5cbiAgLy8gRXhwb3NlIHRoZSByZXN1bHRpbmcgbWFwcGluZy5cbiAgaWYgKGRldGVjdGVkKSB7XG4gICAgc3RhdGUudGFnID0gX3RhZztcbiAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgIHN0YXRlLmtpbmQgPSAnbWFwcGluZyc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBkZXRlY3RlZDtcbn1cblxuZnVuY3Rpb24gcmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBpc1ZlcmJhdGltID0gZmFsc2UsXG4gICAgICBpc05hbWVkICAgID0gZmFsc2UsXG4gICAgICB0YWdIYW5kbGUsXG4gICAgICB0YWdOYW1lLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjEvKiAhICovKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiBhIHRhZyBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHgzQy8qIDwgKi8pIHtcbiAgICBpc1ZlcmJhdGltID0gdHJ1ZTtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMS8qICEgKi8pIHtcbiAgICBpc05hbWVkID0gdHJ1ZTtcbiAgICB0YWdIYW5kbGUgPSAnISEnO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB9IGVsc2Uge1xuICAgIHRhZ0hhbmRsZSA9ICchJztcbiAgfVxuXG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIGlmIChpc1ZlcmJhdGltKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoY2ggIT09IDAgJiYgY2ggIT09IDB4M0UvKiA+ICovKTtcblxuICAgIGlmIChzdGF0ZS5wb3NpdGlvbiA8IHN0YXRlLmxlbmd0aCkge1xuICAgICAgdGFnTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSB2ZXJiYXRpbSB0YWcnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgyMS8qICEgKi8pIHtcbiAgICAgICAgaWYgKCFpc05hbWVkKSB7XG4gICAgICAgICAgdGFnSGFuZGxlID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uIC0gMSwgc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QodGFnSGFuZGxlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWVkIHRhZyBoYW5kbGUgY2Fubm90IGNvbnRhaW4gc3VjaCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXNOYW1lZCA9IHRydWU7XG4gICAgICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb24gKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGV4Y2xhbWF0aW9uIG1hcmtzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUy50ZXN0KHRhZ05hbWUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBmbG93IGluZGljYXRvciBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRhZ05hbWUgJiYgIVBBVFRFUk5fVEFHX1VSSS50ZXN0KHRhZ05hbWUpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBuYW1lIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVyczogJyArIHRhZ05hbWUpO1xuICB9XG5cbiAgaWYgKGlzVmVyYmF0aW0pIHtcbiAgICBzdGF0ZS50YWcgPSB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUudGFnTWFwLCB0YWdIYW5kbGUpKSB7XG4gICAgc3RhdGUudGFnID0gc3RhdGUudGFnTWFwW3RhZ0hhbmRsZV0gKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAodGFnSGFuZGxlID09PSAnIScpIHtcbiAgICBzdGF0ZS50YWcgPSAnIScgKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAodGFnSGFuZGxlID09PSAnISEnKSB7XG4gICAgc3RhdGUudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOicgKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZGVjbGFyZWQgdGFnIGhhbmRsZSBcIicgKyB0YWdIYW5kbGUgKyAnXCInKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbixcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDI2LyogJiAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgYW4gYW5jaG9yIHByb3BlcnR5Jyk7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSAmJiAhaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBfcG9zaXRpb24pIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmFtZSBvZiBhbiBhbmNob3Igbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgc3RhdGUuYW5jaG9yID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQWxpYXMoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbiwgYWxpYXMsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyQS8qICogKi8pIHJldHVybiBmYWxzZTtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSAmJiAhaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBfcG9zaXRpb24pIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmFtZSBvZiBhbiBhbGlhcyBub2RlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyJyk7XG4gIH1cblxuICBhbGlhcyA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmICghc3RhdGUuYW5jaG9yTWFwLmhhc093blByb3BlcnR5KGFsaWFzKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmlkZW50aWZpZWQgYWxpYXMgXCInICsgYWxpYXMgKyAnXCInKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VsdCA9IHN0YXRlLmFuY2hvck1hcFthbGlhc107XG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbXBvc2VOb2RlKHN0YXRlLCBwYXJlbnRJbmRlbnQsIG5vZGVDb250ZXh0LCBhbGxvd1RvU2VlaywgYWxsb3dDb21wYWN0KSB7XG4gIHZhciBhbGxvd0Jsb2NrU3R5bGVzLFxuICAgICAgYWxsb3dCbG9ja1NjYWxhcnMsXG4gICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMsXG4gICAgICBpbmRlbnRTdGF0dXMgPSAxLCAvLyAxOiB0aGlzPnBhcmVudCwgMDogdGhpcz1wYXJlbnQsIC0xOiB0aGlzPHBhcmVudFxuICAgICAgYXROZXdMaW5lICA9IGZhbHNlLFxuICAgICAgaGFzQ29udGVudCA9IGZhbHNlLFxuICAgICAgdHlwZUluZGV4LFxuICAgICAgdHlwZVF1YW50aXR5LFxuICAgICAgdHlwZSxcbiAgICAgIGZsb3dJbmRlbnQsXG4gICAgICBibG9ja0luZGVudDtcblxuICBpZiAoc3RhdGUubGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5saXN0ZW5lcignb3BlbicsIHN0YXRlKTtcbiAgfVxuXG4gIHN0YXRlLnRhZyAgICA9IG51bGw7XG4gIHN0YXRlLmFuY2hvciA9IG51bGw7XG4gIHN0YXRlLmtpbmQgICA9IG51bGw7XG4gIHN0YXRlLnJlc3VsdCA9IG51bGw7XG5cbiAgYWxsb3dCbG9ja1N0eWxlcyA9IGFsbG93QmxvY2tTY2FsYXJzID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zID1cbiAgICBDT05URVhUX0JMT0NLX09VVCA9PT0gbm9kZUNvbnRleHQgfHxcbiAgICBDT05URVhUX0JMT0NLX0lOICA9PT0gbm9kZUNvbnRleHQ7XG5cbiAgaWYgKGFsbG93VG9TZWVrKSB7XG4gICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgYXROZXdMaW5lID0gdHJ1ZTtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGluZGVudFN0YXR1cyA9PT0gMSkge1xuICAgIHdoaWxlIChyZWFkVGFnUHJvcGVydHkoc3RhdGUpIHx8IHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkpIHtcbiAgICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgICAgYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYWxsb3dCbG9ja1N0eWxlcztcblxuICAgICAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbGxvd0Jsb2NrQ29sbGVjdGlvbnMpIHtcbiAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBhdE5ld0xpbmUgfHwgYWxsb3dDb21wYWN0O1xuICB9XG5cbiAgaWYgKGluZGVudFN0YXR1cyA9PT0gMSB8fCBDT05URVhUX0JMT0NLX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICBpZiAoQ09OVEVYVF9GTE9XX0lOID09PSBub2RlQ29udGV4dCB8fCBDT05URVhUX0ZMT1dfT1VUID09PSBub2RlQ29udGV4dCkge1xuICAgICAgZmxvd0luZGVudCA9IHBhcmVudEluZGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxvd0luZGVudCA9IHBhcmVudEluZGVudCArIDE7XG4gICAgfVxuXG4gICAgYmxvY2tJbmRlbnQgPSBzdGF0ZS5wb3NpdGlvbiAtIHN0YXRlLmxpbmVTdGFydDtcblxuICAgIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICAgIGlmIChhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiZcbiAgICAgICAgICAocmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIGJsb2NrSW5kZW50KSB8fFxuICAgICAgICAgICByZWFkQmxvY2tNYXBwaW5nKHN0YXRlLCBibG9ja0luZGVudCwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgcmVhZEZsb3dDb2xsZWN0aW9uKHN0YXRlLCBmbG93SW5kZW50KSkge1xuICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgoYWxsb3dCbG9ja1NjYWxhcnMgJiYgcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSkgfHxcbiAgICAgICAgICAgIHJlYWRTaW5nbGVRdW90ZWRTY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQpIHx8XG4gICAgICAgICAgICByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVhZEFsaWFzKHN0YXRlKSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCB8fCBzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdhbGlhcyBub2RlIHNob3VsZCBub3QgaGF2ZSBhbnkgcHJvcGVydGllcycpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRQbGFpblNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCwgQ09OVEVYVF9GTE9XX0lOID09PSBub2RlQ29udGV4dCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzdGF0ZS50YWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlLnRhZyA9ICc/JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGluZGVudFN0YXR1cyA9PT0gMCkge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlOiBibG9jayBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgdG8gaGF2ZSBzYW1lIGluZGVudGF0aW9uIGxldmVsIGFzIHRoZSBwYXJlbnQuXG4gICAgICAvLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI3OTk3ODRcbiAgICAgIGhhc0NvbnRlbnQgPSBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiYgcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIGJsb2NrSW5kZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJyEnKSB7XG4gICAgaWYgKHN0YXRlLnRhZyA9PT0gJz8nKSB7XG4gICAgICBmb3IgKHR5cGVJbmRleCA9IDAsIHR5cGVRdWFudGl0eSA9IHN0YXRlLmltcGxpY2l0VHlwZXMubGVuZ3RoO1xuICAgICAgICAgICB0eXBlSW5kZXggPCB0eXBlUXVhbnRpdHk7XG4gICAgICAgICAgIHR5cGVJbmRleCArPSAxKSB7XG4gICAgICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW3R5cGVJbmRleF07XG5cbiAgICAgICAgLy8gSW1wbGljaXQgcmVzb2x2aW5nIGlzIG5vdCBhbGxvd2VkIGZvciBub24tc2NhbGFyIHR5cGVzLCBhbmQgJz8nXG4gICAgICAgIC8vIG5vbi1zcGVjaWZpYyB0YWcgaXMgb25seSBhc3NpZ25lZCB0byBwbGFpbiBzY2FsYXJzLiBTbywgaXQgaXNuJ3RcbiAgICAgICAgLy8gbmVlZGVkIHRvIGNoZWNrIGZvciAna2luZCcgY29uZm9ybWl0eS5cblxuICAgICAgICBpZiAodHlwZS5yZXNvbHZlKHN0YXRlLnJlc3VsdCkpIHsgLy8gYHN0YXRlLnJlc3VsdGAgdXBkYXRlZCBpbiByZXNvbHZlciBpZiBtYXRjaGVkXG4gICAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcbiAgICAgICAgICBzdGF0ZS50YWcgPSB0eXBlLnRhZztcbiAgICAgICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnR5cGVNYXAsIHN0YXRlLnRhZykpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS50eXBlTWFwW3N0YXRlLnRhZ107XG5cbiAgICAgIGlmIChzdGF0ZS5yZXN1bHQgIT09IG51bGwgJiYgdHlwZS5raW5kICE9PSBzdGF0ZS5raW5kKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgbm9kZSBraW5kIGZvciAhPCcgKyBzdGF0ZS50YWcgKyAnPiB0YWc7IGl0IHNob3VsZCBiZSBcIicgKyB0eXBlLmtpbmQgKyAnXCIsIG5vdCBcIicgKyBzdGF0ZS5raW5kICsgJ1wiJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHlwZS5yZXNvbHZlKHN0YXRlLnJlc3VsdCkpIHsgLy8gYHN0YXRlLnJlc3VsdGAgdXBkYXRlZCBpbiByZXNvbHZlciBpZiBtYXRjaGVkXG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgcmVzb2x2ZSBhIG5vZGUgd2l0aCAhPCcgKyBzdGF0ZS50YWcgKyAnPiBleHBsaWNpdCB0YWcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCk7XG4gICAgICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5rbm93biB0YWcgITwnICsgc3RhdGUudGFnICsgJz4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUubGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5saXN0ZW5lcignY2xvc2UnLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnRhZyAhPT0gbnVsbCB8fCAgc3RhdGUuYW5jaG9yICE9PSBudWxsIHx8IGhhc0NvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIHJlYWREb2N1bWVudChzdGF0ZSkge1xuICB2YXIgZG9jdW1lbnRTdGFydCA9IHN0YXRlLnBvc2l0aW9uLFxuICAgICAgX3Bvc2l0aW9uLFxuICAgICAgZGlyZWN0aXZlTmFtZSxcbiAgICAgIGRpcmVjdGl2ZUFyZ3MsXG4gICAgICBoYXNEaXJlY3RpdmVzID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBzdGF0ZS52ZXJzaW9uID0gbnVsbDtcbiAgc3RhdGUuY2hlY2tMaW5lQnJlYWtzID0gc3RhdGUubGVnYWN5O1xuICBzdGF0ZS50YWdNYXAgPSB7fTtcbiAgc3RhdGUuYW5jaG9yTWFwID0ge307XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IDAgfHwgY2ggIT09IDB4MjUvKiAlICovKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBoYXNEaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBkaXJlY3RpdmVOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gICAgZGlyZWN0aXZlQXJncyA9IFtdO1xuXG4gICAgaWYgKGRpcmVjdGl2ZU5hbWUubGVuZ3RoIDwgMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2RpcmVjdGl2ZSBuYW1lIG11c3Qgbm90IGJlIGxlc3MgdGhhbiBvbmUgY2hhcmFjdGVyIGluIGxlbmd0aCcpO1xuICAgIH1cblxuICAgIHdoaWxlIChjaCAhPT0gMCkge1xuICAgICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICAgICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19FT0woY2gpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc19FT0woY2gpKSBicmVhaztcblxuICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGRpcmVjdGl2ZUFyZ3MucHVzaChzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKSk7XG4gICAgfVxuXG4gICAgaWYgKGNoICE9PSAwKSByZWFkTGluZUJyZWFrKHN0YXRlKTtcblxuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChkaXJlY3RpdmVIYW5kbGVycywgZGlyZWN0aXZlTmFtZSkpIHtcbiAgICAgIGRpcmVjdGl2ZUhhbmRsZXJzW2RpcmVjdGl2ZU5hbWVdKHN0YXRlLCBkaXJlY3RpdmVOYW1lLCBkaXJlY3RpdmVBcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5rbm93biBkb2N1bWVudCBkaXJlY3RpdmUgXCInICsgZGlyZWN0aXZlTmFtZSArICdcIicpO1xuICAgIH1cbiAgfVxuXG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gMCAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgICAgID09PSAweDJELyogLSAqLyAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpID09PSAweDJELyogLSAqLyAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDIpID09PSAweDJELyogLSAqLykge1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIH0gZWxzZSBpZiAoaGFzRGlyZWN0aXZlcykge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmVzIGVuZCBtYXJrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBjb21wb3NlTm9kZShzdGF0ZSwgc3RhdGUubGluZUluZGVudCAtIDEsIENPTlRFWFRfQkxPQ0tfT1VULCBmYWxzZSwgdHJ1ZSk7XG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICBpZiAoc3RhdGUuY2hlY2tMaW5lQnJlYWtzICYmXG4gICAgICBQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUy50ZXN0KHN0YXRlLmlucHV0LnNsaWNlKGRvY3VtZW50U3RhcnQsIHN0YXRlLnBvc2l0aW9uKSkpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdub24tQVNDSUkgbGluZSBicmVha3MgYXJlIGludGVycHJldGVkIGFzIGNvbnRlbnQnKTtcbiAgfVxuXG4gIHN0YXRlLmRvY3VtZW50cy5wdXNoKHN0YXRlLnJlc3VsdCk7XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuXG4gICAgaWYgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDJFLyogLiAqLykge1xuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMztcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uIDwgKHN0YXRlLmxlbmd0aCAtIDEpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2VuZCBvZiB0aGUgc3RyZWFtIG9yIGEgZG9jdW1lbnQgc2VwYXJhdG9yIGlzIGV4cGVjdGVkJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5cblxuZnVuY3Rpb24gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucykge1xuICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbnB1dC5sZW5ndGggIT09IDApIHtcblxuICAgIC8vIEFkZCB0YWlsaW5nIGBcXG5gIGlmIG5vdCBleGlzdHNcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChpbnB1dC5sZW5ndGggLSAxKSAhPT0gMHgwQS8qIExGICovICYmXG4gICAgICAgIGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT09IDB4MEQvKiBDUiAqLykge1xuICAgICAgaW5wdXQgKz0gJ1xcbic7XG4gICAgfVxuXG4gICAgLy8gU3RyaXAgQk9NXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgxKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIC8vIFVzZSAwIGFzIHN0cmluZyB0ZXJtaW5hdG9yLiBUaGF0IHNpZ25pZmljYW50bHkgc2ltcGxpZmllcyBib3VuZHMgY2hlY2suXG4gIHN0YXRlLmlucHV0ICs9ICdcXDAnO1xuXG4gIHdoaWxlIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgyMC8qIFNwYWNlICovKSB7XG4gICAgc3RhdGUubGluZUluZGVudCArPSAxO1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gIH1cblxuICB3aGlsZSAoc3RhdGUucG9zaXRpb24gPCAoc3RhdGUubGVuZ3RoIC0gMSkpIHtcbiAgICByZWFkRG9jdW1lbnQoc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmRvY3VtZW50cztcbn1cblxuXG5mdW5jdGlvbiBsb2FkQWxsKGlucHV0LCBpdGVyYXRvciwgb3B0aW9ucykge1xuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyksIGluZGV4LCBsZW5ndGg7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGRvY3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgaXRlcmF0b3IoZG9jdW1lbnRzW2luZGV4XSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBsb2FkKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBkb2N1bWVudHMgPSBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKTtcblxuICBpZiAoZG9jdW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8qZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkKi9cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKGRvY3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZG9jdW1lbnRzWzBdO1xuICB9XG4gIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdleHBlY3RlZCBhIHNpbmdsZSBkb2N1bWVudCBpbiB0aGUgc3RyZWFtLCBidXQgZm91bmQgbW9yZScpO1xufVxuXG5cbmZ1bmN0aW9uIHNhZmVMb2FkQWxsKGlucHV0LCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgbG9hZEFsbChpbnB1dCwgb3V0cHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbn1cblxuXG5mdW5jdGlvbiBzYWZlTG9hZChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbG9hZChpbnB1dCwgY29tbW9uLmV4dGVuZCh7IHNjaGVtYTogREVGQVVMVF9TQUZFX1NDSEVNQSB9LCBvcHRpb25zKSk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMubG9hZEFsbCAgICAgPSBsb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMubG9hZCAgICAgICAgPSBsb2FkO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgPSBzYWZlTG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkICAgID0gc2FmZUxvYWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuZnVuY3Rpb24gTWFyayhuYW1lLCBidWZmZXIsIHBvc2l0aW9uLCBsaW5lLCBjb2x1bW4pIHtcbiAgdGhpcy5uYW1lICAgICA9IG5hbWU7XG4gIHRoaXMuYnVmZmVyICAgPSBidWZmZXI7XG4gIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgdGhpcy5saW5lICAgICA9IGxpbmU7XG4gIHRoaXMuY29sdW1uICAgPSBjb2x1bW47XG59XG5cblxuTWFyay5wcm90b3R5cGUuZ2V0U25pcHBldCA9IGZ1bmN0aW9uIGdldFNuaXBwZXQoaW5kZW50LCBtYXhMZW5ndGgpIHtcbiAgdmFyIGhlYWQsIHN0YXJ0LCB0YWlsLCBlbmQsIHNuaXBwZXQ7XG5cbiAgaWYgKCF0aGlzLmJ1ZmZlcikgcmV0dXJuIG51bGw7XG5cbiAgaW5kZW50ID0gaW5kZW50IHx8IDQ7XG4gIG1heExlbmd0aCA9IG1heExlbmd0aCB8fCA3NTtcblxuICBoZWFkID0gJyc7XG4gIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoc3RhcnQgPiAwICYmICdcXHgwMFxcclxcblxceDg1XFx1MjAyOFxcdTIwMjknLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KHN0YXJ0IC0gMSkpID09PSAtMSkge1xuICAgIHN0YXJ0IC09IDE7XG4gICAgaWYgKHRoaXMucG9zaXRpb24gLSBzdGFydCA+IChtYXhMZW5ndGggLyAyIC0gMSkpIHtcbiAgICAgIGhlYWQgPSAnIC4uLiAnO1xuICAgICAgc3RhcnQgKz0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRhaWwgPSAnJztcbiAgZW5kID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoZW5kIDwgdGhpcy5idWZmZXIubGVuZ3RoICYmICdcXHgwMFxcclxcblxceDg1XFx1MjAyOFxcdTIwMjknLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KGVuZCkpID09PSAtMSkge1xuICAgIGVuZCArPSAxO1xuICAgIGlmIChlbmQgLSB0aGlzLnBvc2l0aW9uID4gKG1heExlbmd0aCAvIDIgLSAxKSkge1xuICAgICAgdGFpbCA9ICcgLi4uICc7XG4gICAgICBlbmQgLT0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHNuaXBwZXQgPSB0aGlzLmJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTtcblxuICByZXR1cm4gY29tbW9uLnJlcGVhdCgnICcsIGluZGVudCkgKyBoZWFkICsgc25pcHBldCArIHRhaWwgKyAnXFxuJyArXG4gICAgICAgICBjb21tb24ucmVwZWF0KCcgJywgaW5kZW50ICsgdGhpcy5wb3NpdGlvbiAtIHN0YXJ0ICsgaGVhZC5sZW5ndGgpICsgJ14nO1xufTtcblxuXG5NYXJrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgdmFyIHNuaXBwZXQsIHdoZXJlID0gJyc7XG5cbiAgaWYgKHRoaXMubmFtZSkge1xuICAgIHdoZXJlICs9ICdpbiBcIicgKyB0aGlzLm5hbWUgKyAnXCIgJztcbiAgfVxuXG4gIHdoZXJlICs9ICdhdCBsaW5lICcgKyAodGhpcy5saW5lICsgMSkgKyAnLCBjb2x1bW4gJyArICh0aGlzLmNvbHVtbiArIDEpO1xuXG4gIGlmICghY29tcGFjdCkge1xuICAgIHNuaXBwZXQgPSB0aGlzLmdldFNuaXBwZXQoKTtcblxuICAgIGlmIChzbmlwcGV0KSB7XG4gICAgICB3aGVyZSArPSAnOlxcbicgKyBzbmlwcGV0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3aGVyZTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBNYXJrO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG52YXIgY29tbW9uICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgVHlwZSAgICAgICAgICA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG5cbmZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjaGVtYSwgbmFtZSwgcmVzdWx0KSB7XG4gIHZhciBleGNsdWRlID0gW107XG5cbiAgc2NoZW1hLmluY2x1ZGUuZm9yRWFjaChmdW5jdGlvbiAoaW5jbHVkZWRTY2hlbWEpIHtcbiAgICByZXN1bHQgPSBjb21waWxlTGlzdChpbmNsdWRlZFNjaGVtYSwgbmFtZSwgcmVzdWx0KTtcbiAgfSk7XG5cbiAgc2NoZW1hW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRUeXBlKSB7XG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHByZXZpb3VzVHlwZSwgcHJldmlvdXNJbmRleCkge1xuICAgICAgaWYgKHByZXZpb3VzVHlwZS50YWcgPT09IGN1cnJlbnRUeXBlLnRhZykge1xuICAgICAgICBleGNsdWRlLnB1c2gocHJldmlvdXNJbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXN1bHQucHVzaChjdXJyZW50VHlwZSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuICAgIHJldHVybiBleGNsdWRlLmluZGV4T2YoaW5kZXgpID09PSAtMTtcbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gY29tcGlsZU1hcCgvKiBsaXN0cy4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge30sIGluZGV4LCBsZW5ndGg7XG5cbiAgZnVuY3Rpb24gY29sbGVjdFR5cGUodHlwZSkge1xuICAgIHJlc3VsdFt0eXBlLnRhZ10gPSB0eXBlO1xuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgYXJndW1lbnRzW2luZGV4XS5mb3JFYWNoKGNvbGxlY3RUeXBlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gU2NoZW1hKGRlZmluaXRpb24pIHtcbiAgdGhpcy5pbmNsdWRlICA9IGRlZmluaXRpb24uaW5jbHVkZSAgfHwgW107XG4gIHRoaXMuaW1wbGljaXQgPSBkZWZpbml0aW9uLmltcGxpY2l0IHx8IFtdO1xuICB0aGlzLmV4cGxpY2l0ID0gZGVmaW5pdGlvbi5leHBsaWNpdCB8fCBbXTtcblxuICB0aGlzLmltcGxpY2l0LmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodHlwZS5sb2FkS2luZCAmJiB0eXBlLmxvYWRLaW5kICE9PSAnc2NhbGFyJykge1xuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1RoZXJlIGlzIGEgbm9uLXNjYWxhciB0eXBlIGluIHRoZSBpbXBsaWNpdCBsaXN0IG9mIGEgc2NoZW1hLiBJbXBsaWNpdCByZXNvbHZpbmcgb2Ygc3VjaCB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5jb21waWxlZEltcGxpY2l0ID0gY29tcGlsZUxpc3QodGhpcywgJ2ltcGxpY2l0JywgW10pO1xuICB0aGlzLmNvbXBpbGVkRXhwbGljaXQgPSBjb21waWxlTGlzdCh0aGlzLCAnZXhwbGljaXQnLCBbXSk7XG4gIHRoaXMuY29tcGlsZWRUeXBlTWFwICA9IGNvbXBpbGVNYXAodGhpcy5jb21waWxlZEltcGxpY2l0LCB0aGlzLmNvbXBpbGVkRXhwbGljaXQpO1xufVxuXG5cblNjaGVtYS5ERUZBVUxUID0gbnVsbDtcblxuXG5TY2hlbWEuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlU2NoZW1hKCkge1xuICB2YXIgc2NoZW1hcywgdHlwZXM7XG5cbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgICAgc2NoZW1hcyA9IFNjaGVtYS5ERUZBVUxUO1xuICAgICAgdHlwZXMgPSBhcmd1bWVudHNbMF07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMjpcbiAgICAgIHNjaGVtYXMgPSBhcmd1bWVudHNbMF07XG4gICAgICB0eXBlcyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBTY2hlbWEuY3JlYXRlIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBzY2hlbWFzID0gY29tbW9uLnRvQXJyYXkoc2NoZW1hcyk7XG4gIHR5cGVzID0gY29tbW9uLnRvQXJyYXkodHlwZXMpO1xuXG4gIGlmICghc2NoZW1hcy5ldmVyeShmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEgaW5zdGFuY2VvZiBTY2hlbWE7IH0pKSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIHN1cGVyIHNjaGVtYXMgKG9yIGEgc2luZ2xlIFNjaGVtYSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVNjaGVtYSBvYmplY3QuJyk7XG4gIH1cblxuICBpZiAoIXR5cGVzLmV2ZXJ5KGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlIGluc3RhbmNlb2YgVHlwZTsgfSkpIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignU3BlY2lmaWVkIGxpc3Qgb2YgWUFNTCB0eXBlcyAob3IgYSBzaW5nbGUgVHlwZSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVR5cGUgb2JqZWN0LicpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTY2hlbWEoe1xuICAgIGluY2x1ZGU6IHNjaGVtYXMsXG4gICAgZXhwbGljaXQ6IHR5cGVzXG4gIH0pO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYTtcbiIsIi8vIFN0YW5kYXJkIFlBTUwncyBDb3JlIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwNDkyM1xuLy9cbi8vIE5PVEU6IEpTLVlBTUwgZG9lcyBub3Qgc3VwcG9ydCBzY2hlbWEtc3BlY2lmaWMgdGFnIHJlc29sdXRpb24gcmVzdHJpY3Rpb25zLlxuLy8gU28sIENvcmUgc2NoZW1hIGhhcyBubyBkaXN0aW5jdGlvbnMgZnJvbSBKU09OIHNjaGVtYSBpcyBKUy1ZQU1MLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vanNvbicpXG4gIF1cbn0pO1xuIiwiLy8gSlMtWUFNTCdzIGRlZmF1bHQgc2NoZW1hIGZvciBgbG9hZGAgZnVuY3Rpb24uXG4vLyBJdCBpcyBub3QgZGVzY3JpYmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXG4vL1xuLy8gVGhpcyBzY2hlbWEgaXMgYmFzZWQgb24gSlMtWUFNTCdzIGRlZmF1bHQgc2FmZSBzY2hlbWEgYW5kIGluY2x1ZGVzXG4vLyBKYXZhU2NyaXB0LXNwZWNpZmljIHR5cGVzOiAhIWpzL3VuZGVmaW5lZCwgISFqcy9yZWdleHAgYW5kICEhanMvZnVuY3Rpb24uXG4vL1xuLy8gQWxzbyB0aGlzIHNjaGVtYSBpcyB1c2VkIGFzIGRlZmF1bHQgYmFzZSBzY2hlbWEgYXQgYFNjaGVtYS5jcmVhdGVgIGZ1bmN0aW9uLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWEuREVGQVVMVCA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9kZWZhdWx0X3NhZmUnKVxuICBdLFxuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvanMvdW5kZWZpbmVkJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9qcy9yZWdleHAnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2pzL2Z1bmN0aW9uJylcbiAgXVxufSk7XG4iLCIvLyBKUy1ZQU1MJ3MgZGVmYXVsdCBzY2hlbWEgZm9yIGBzYWZlTG9hZGAgZnVuY3Rpb24uXG4vLyBJdCBpcyBub3QgZGVzY3JpYmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXG4vL1xuLy8gVGhpcyBzY2hlbWEgaXMgYmFzZWQgb24gc3RhbmRhcmQgWUFNTCdzIENvcmUgc2NoZW1hIGFuZCBpbmNsdWRlcyBtb3N0IG9mXG4vLyBleHRyYSB0eXBlcyBkZXNjcmliZWQgYXQgWUFNTCB0YWcgcmVwb3NpdG9yeS4gKGh0dHA6Ly95YW1sLm9yZy90eXBlLylcblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGluY2x1ZGU6IFtcbiAgICByZXF1aXJlKCcuL2NvcmUnKVxuICBdLFxuICBpbXBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvdGltZXN0YW1wJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9tZXJnZScpXG4gIF0sXG4gIGV4cGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9iaW5hcnknKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL29tYXAnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL3BhaXJzJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zZXQnKVxuICBdXG59KTtcbiIsIi8vIFN0YW5kYXJkIFlBTUwncyBGYWlsc2FmZSBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDIzNDZcblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGV4cGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zdHInKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL3NlcScpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvbWFwJylcbiAgXVxufSk7XG4iLCIvLyBTdGFuZGFyZCBZQU1MJ3MgSlNPTiBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDMyMzFcbi8vXG4vLyBOT1RFOiBKUy1ZQU1MIGRvZXMgbm90IHN1cHBvcnQgc2NoZW1hLXNwZWNpZmljIHRhZyByZXNvbHV0aW9uIHJlc3RyaWN0aW9ucy5cbi8vIFNvLCB0aGlzIHNjaGVtYSBpcyBub3Qgc3VjaCBzdHJpY3QgYXMgZGVmaW5lZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy8gSXQgYWxsb3dzIG51bWJlcnMgaW4gYmluYXJ5IG5vdGFpb24sIHVzZSBgTnVsbGAgYW5kIGBOVUxMYCBhcyBgbnVsbGAsIGV0Yy5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGluY2x1ZGU6IFtcbiAgICByZXF1aXJlKCcuL2ZhaWxzYWZlJylcbiAgXSxcbiAgaW1wbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL251bGwnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2Jvb2wnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2ludCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvZmxvYXQnKVxuICBdXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFlBTUxFeGNlcHRpb24gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xuXG52YXIgVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TID0gW1xuICAna2luZCcsXG4gICdyZXNvbHZlJyxcbiAgJ2NvbnN0cnVjdCcsXG4gICdpbnN0YW5jZU9mJyxcbiAgJ3ByZWRpY2F0ZScsXG4gICdyZXByZXNlbnQnLFxuICAnZGVmYXVsdFN0eWxlJyxcbiAgJ3N0eWxlQWxpYXNlcydcbl07XG5cbnZhciBZQU1MX05PREVfS0lORFMgPSBbXG4gICdzY2FsYXInLFxuICAnc2VxdWVuY2UnLFxuICAnbWFwcGluZydcbl07XG5cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZUFsaWFzZXMobWFwKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgbWFwW3N0eWxlXS5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICByZXN1bHRbU3RyaW5nKGFsaWFzKV0gPSBzdHlsZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gVHlwZSh0YWcsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChUWVBFX0NPTlNUUlVDVE9SX09QVElPTlMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdVbmtub3duIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiIGlzIG1ldCBpbiBkZWZpbml0aW9uIG9mIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBUT0RPOiBBZGQgdGFnIGZvcm1hdCBjaGVjay5cbiAgdGhpcy50YWcgICAgICAgICAgPSB0YWc7XG4gIHRoaXMua2luZCAgICAgICAgID0gb3B0aW9uc1sna2luZCddICAgICAgICAgfHwgbnVsbDtcbiAgdGhpcy5yZXNvbHZlICAgICAgPSBvcHRpb25zWydyZXNvbHZlJ10gICAgICB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICB0aGlzLmNvbnN0cnVjdCAgICA9IG9wdGlvbnNbJ2NvbnN0cnVjdCddICAgIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhOyB9O1xuICB0aGlzLmluc3RhbmNlT2YgICA9IG9wdGlvbnNbJ2luc3RhbmNlT2YnXSAgIHx8IG51bGw7XG4gIHRoaXMucHJlZGljYXRlICAgID0gb3B0aW9uc1sncHJlZGljYXRlJ10gICAgfHwgbnVsbDtcbiAgdGhpcy5yZXByZXNlbnQgICAgPSBvcHRpb25zWydyZXByZXNlbnQnXSAgICB8fCBudWxsO1xuICB0aGlzLmRlZmF1bHRTdHlsZSA9IG9wdGlvbnNbJ2RlZmF1bHRTdHlsZSddIHx8IG51bGw7XG4gIHRoaXMuc3R5bGVBbGlhc2VzID0gY29tcGlsZVN0eWxlQWxpYXNlcyhvcHRpb25zWydzdHlsZUFsaWFzZXMnXSB8fCBudWxsKTtcblxuICBpZiAoWUFNTF9OT0RFX0tJTkRTLmluZGV4T2YodGhpcy5raW5kKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVW5rbm93biBraW5kIFwiJyArIHRoaXMua2luZCArICdcIiBpcyBzcGVjaWZpZWQgZm9yIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UqL1xuXG4vLyBBIHRyaWNrIGZvciBicm93c2VyaWZpZWQgdmVyc2lvbi5cbi8vIFNpbmNlIHdlIG1ha2UgYnJvd3NlcmlmaWVyIHRvIGlnbm9yZSBgYnVmZmVyYCBtb2R1bGUsIE5vZGVCdWZmZXIgd2lsbCBiZSB1bmRlZmluZWRcbnZhciBOb2RlQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIFR5cGUgICAgICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cblxuLy8gWyA2NCwgNjUsIDY2IF0gLT4gWyBwYWRkaW5nLCBDUiwgTEYgXVxudmFyIEJBU0U2NF9NQVAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cXG5cXHInO1xuXG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sQmluYXJ5KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgY29kZSwgaWR4LCBiaXRsZW4gPSAwLCBtYXggPSBkYXRhLmxlbmd0aCwgbWFwID0gQkFTRTY0X01BUDtcblxuICAvLyBDb252ZXJ0IG9uZSBieSBvbmUuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGNvZGUgPSBtYXAuaW5kZXhPZihkYXRhLmNoYXJBdChpZHgpKTtcblxuICAgIC8vIFNraXAgQ1IvTEZcbiAgICBpZiAoY29kZSA+IDY0KSBjb250aW51ZTtcblxuICAgIC8vIEZhaWwgb24gaWxsZWdhbCBjaGFyYWN0ZXJzXG4gICAgaWYgKGNvZGUgPCAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICBiaXRsZW4gKz0gNjtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBhbnkgYml0cyBsZWZ0LCBzb3VyY2Ugd2FzIGNvcnJ1cHRlZFxuICByZXR1cm4gKGJpdGxlbiAlIDgpID09PSAwO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQmluYXJ5KGRhdGEpIHtcbiAgdmFyIGlkeCwgdGFpbGJpdHMsXG4gICAgICBpbnB1dCA9IGRhdGEucmVwbGFjZSgvW1xcclxcbj1dL2csICcnKSwgLy8gcmVtb3ZlIENSL0xGICYgcGFkZGluZyB0byBzaW1wbGlmeSBzY2FuXG4gICAgICBtYXggPSBpbnB1dC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQLFxuICAgICAgYml0cyA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICAvLyBDb2xsZWN0IGJ5IDYqNCBiaXRzICgzIGJ5dGVzKVxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgNCA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxNikgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDYpIHwgbWFwLmluZGV4T2YoaW5wdXQuY2hhckF0KGlkeCkpO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbGJpdHMgPSAobWF4ICUgNCkgKiA2O1xuXG4gIGlmICh0YWlsYml0cyA9PT0gMCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxOCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDEwKSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDIpICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDEyKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gNCkgJiAweEZGKTtcbiAgfVxuXG4gIC8vIFdyYXAgaW50byBCdWZmZXIgZm9yIE5vZGVKUyBhbmQgbGVhdmUgQXJyYXkgZm9yIGJyb3dzZXJcbiAgaWYgKE5vZGVCdWZmZXIpIHJldHVybiBuZXcgTm9kZUJ1ZmZlcihyZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxCaW5hcnkob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHZhciByZXN1bHQgPSAnJywgYml0cyA9IDAsIGlkeCwgdGFpbCxcbiAgICAgIG1heCA9IG9iamVjdC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgZXZlcnkgdGhyZWUgYnl0ZXMgdG8gNCBBU0NJSSBjaGFyYWN0ZXJzLlxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgMyA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA4KSArIG9iamVjdFtpZHhdO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbCA9IG1heCAlIDM7XG5cbiAgaWYgKHRhaWwgPT09IDApIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDIpIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEwKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMSkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDQpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0JpbmFyeShvYmplY3QpIHtcbiAgcmV0dXJuIE5vZGVCdWZmZXIgJiYgTm9kZUJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJpbmFyeSxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sQmluYXJ5LFxuICBwcmVkaWNhdGU6IGlzQmluYXJ5LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxCaW5hcnlcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCb29sZWFuKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG5cbiAgcmV0dXJuIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICd0cnVlJyB8fCBkYXRhID09PSAnVHJ1ZScgfHwgZGF0YSA9PT0gJ1RSVUUnKSkgfHxcbiAgICAgICAgIChtYXggPT09IDUgJiYgKGRhdGEgPT09ICdmYWxzZScgfHwgZGF0YSA9PT0gJ0ZhbHNlJyB8fCBkYXRhID09PSAnRkFMU0UnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCb29sZWFuKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09ICd0cnVlJyB8fFxuICAgICAgICAgZGF0YSA9PT0gJ1RydWUnIHx8XG4gICAgICAgICBkYXRhID09PSAnVFJVRSc7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBCb29sZWFuXSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJvb2xlYW4sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJvb2xlYW4sXG4gIHByZWRpY2F0ZTogaXNCb29sZWFuLFxuICByZXByZXNlbnQ6IHtcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICd0cnVlJyA6ICdmYWxzZSc7IH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAnVFJVRScgOiAnRkFMU0UnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RydWUnIDogJ0ZhbHNlJzsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIFR5cGUgICA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIFlBTUxfRkxPQVRfUEFUVEVSTiA9IG5ldyBSZWdFeHAoXG4gICdeKD86Wy0rXT8oPzpbMC05XVswLTlfXSopXFxcXC5bMC05X10qKD86W2VFXVstK11bMC05XSspPycgK1xuICAnfFxcXFwuWzAtOV9dKyg/OltlRV1bLStdWzAtOV0rKT8nICtcbiAgJ3xbLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFxcXC5bMC05X10qJyArXG4gICd8Wy0rXT9cXFxcLig/OmluZnxJbmZ8SU5GKScgK1xuICAnfFxcXFwuKD86bmFufE5hTnxOQU4pKSQnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxGbG9hdChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKCFZQU1MX0ZMT0FUX1BBVFRFUk4udGVzdChkYXRhKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sRmxvYXQoZGF0YSkge1xuICB2YXIgdmFsdWUsIHNpZ24sIGJhc2UsIGRpZ2l0cztcblxuICB2YWx1ZSAgPSBkYXRhLnJlcGxhY2UoL18vZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gIHNpZ24gICA9IHZhbHVlWzBdID09PSAnLScgPyAtMSA6IDE7XG4gIGRpZ2l0cyA9IFtdO1xuXG4gIGlmICgnKy0nLmluZGV4T2YodmFsdWVbMF0pID49IDApIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnLmluZicpIHtcbiAgICByZXR1cm4gKHNpZ24gPT09IDEpID8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICcubmFuJykge1xuICAgIHJldHVybiBOYU47XG5cbiAgfSBlbHNlIGlmICh2YWx1ZS5pbmRleE9mKCc6JykgPj0gMCkge1xuICAgIHZhbHVlLnNwbGl0KCc6JykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgZGlnaXRzLnVuc2hpZnQocGFyc2VGbG9hdCh2LCAxMCkpO1xuICAgIH0pO1xuXG4gICAgdmFsdWUgPSAwLjA7XG4gICAgYmFzZSA9IDE7XG5cbiAgICBkaWdpdHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgdmFsdWUgKz0gZCAqIGJhc2U7XG4gICAgICBiYXNlICo9IDYwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNpZ24gKiB2YWx1ZTtcblxuICB9XG4gIHJldHVybiBzaWduICogcGFyc2VGbG9hdCh2YWx1ZSwgMTApO1xufVxuXG5cbnZhciBTQ0lFTlRJRklDX1dJVEhPVVRfRE9UID0gL15bLStdP1swLTldK2UvO1xuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sRmxvYXQob2JqZWN0LCBzdHlsZSkge1xuICB2YXIgcmVzO1xuXG4gIGlmIChpc05hTihvYmplY3QpKSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICcubmFuJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLk5BTic7XG4gICAgICBjYXNlICdjYW1lbGNhc2UnOiByZXR1cm4gJy5OYU4nO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLmluZic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy5JTkYnO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICcuSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy0uaW5mJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLS5JTkYnO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICctLkluZic7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKSB7XG4gICAgcmV0dXJuICctMC4wJztcbiAgfVxuXG4gIHJlcyA9IG9iamVjdC50b1N0cmluZygxMCk7XG5cbiAgLy8gSlMgc3RyaW5naWZpZXIgY2FuIGJ1aWxkIHNjaWVudGlmaWMgZm9ybWF0IHdpdGhvdXQgZG90czogNWUtMTAwLFxuICAvLyB3aGlsZSBZQU1MIHJlcXVyZXMgZG90OiA1LmUtMTAwLiBGaXggaXQgd2l0aCBzaW1wbGUgaGFja1xuXG4gIHJldHVybiBTQ0lFTlRJRklDX1dJVEhPVVRfRE9ULnRlc3QocmVzKSA/IHJlcy5yZXBsYWNlKCdlJywgJy5lJykgOiByZXM7XG59XG5cbmZ1bmN0aW9uIGlzRmxvYXQob2JqZWN0KSB7XG4gIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IE51bWJlcl0nKSAmJlxuICAgICAgICAgKG9iamVjdCAlIDEgIT09IDAgfHwgY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sRmxvYXQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEZsb2F0LFxuICBwcmVkaWNhdGU6IGlzRmxvYXQsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEZsb2F0LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIFR5cGUgICA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gaXNIZXhDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB8fFxuICAgICAgICAgKCgweDQxLyogQSAqLyA8PSBjKSAmJiAoYyA8PSAweDQ2LyogRiAqLykpIHx8XG4gICAgICAgICAoKDB4NjEvKiBhICovIDw9IGMpICYmIChjIDw9IDB4NjYvKiBmICovKSk7XG59XG5cbmZ1bmN0aW9uIGlzT2N0Q29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzcvKiA3ICovKSk7XG59XG5cbmZ1bmN0aW9uIGlzRGVjQ29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sSW50ZWdlcihkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgaGFzRGlnaXRzID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBpZiAoIW1heCkgcmV0dXJuIGZhbHNlO1xuXG4gIGNoID0gZGF0YVtpbmRleF07XG5cbiAgLy8gc2lnblxuICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgY2ggPSBkYXRhWysraW5kZXhdO1xuICB9XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICAvLyAwXG4gICAgaWYgKGluZGV4ICsgMSA9PT0gbWF4KSByZXR1cm4gdHJ1ZTtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG5cbiAgICAvLyBiYXNlIDIsIGJhc2UgOCwgYmFzZSAxNlxuXG4gICAgaWYgKGNoID09PSAnYicpIHtcbiAgICAgIC8vIGJhc2UgMlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGNoICE9PSAnMCcgJiYgY2ggIT09ICcxJykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cztcbiAgICB9XG5cblxuICAgIGlmIChjaCA9PT0gJ3gnKSB7XG4gICAgICAvLyBiYXNlIDE2XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWlzSGV4Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cztcbiAgICB9XG5cbiAgICAvLyBiYXNlIDhcbiAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICBpZiAoIWlzT2N0Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0RpZ2l0cztcbiAgfVxuXG4gIC8vIGJhc2UgMTAgKGV4Y2VwdCAwKSBvciBiYXNlIDYwXG5cbiAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgaWYgKGNoID09PSAnOicpIGJyZWFrO1xuICAgIGlmICghaXNEZWNDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gIH1cblxuICBpZiAoIWhhc0RpZ2l0cykgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIGlmICFiYXNlNjAgLSBkb25lO1xuICBpZiAoY2ggIT09ICc6JykgcmV0dXJuIHRydWU7XG5cbiAgLy8gYmFzZTYwIGFsbW9zdCBub3QgdXNlZCwgbm8gbmVlZHMgdG8gb3B0aW1pemVcbiAgcmV0dXJuIC9eKDpbMC01XT9bMC05XSkrJC8udGVzdChkYXRhLnNsaWNlKGluZGV4KSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgdmFyIHZhbHVlID0gZGF0YSwgc2lnbiA9IDEsIGNoLCBiYXNlLCBkaWdpdHMgPSBbXTtcblxuICBpZiAodmFsdWUuaW5kZXhPZignXycpICE9PSAtMSkge1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXy9nLCAnJyk7XG4gIH1cblxuICBjaCA9IHZhbHVlWzBdO1xuXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBpZiAoY2ggPT09ICctJykgc2lnbiA9IC0xO1xuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgY2ggPSB2YWx1ZVswXTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJzAnKSByZXR1cm4gMDtcblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ2InKSByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAyKTtcbiAgICBpZiAodmFsdWVbMV0gPT09ICd4JykgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgMTYpO1xuICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDgpO1xuICB9XG5cbiAgaWYgKHZhbHVlLmluZGV4T2YoJzonKSAhPT0gLTEpIHtcbiAgICB2YWx1ZS5zcGxpdCgnOicpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIGRpZ2l0cy51bnNoaWZ0KHBhcnNlSW50KHYsIDEwKSk7XG4gICAgfSk7XG5cbiAgICB2YWx1ZSA9IDA7XG4gICAgYmFzZSA9IDE7XG5cbiAgICBkaWdpdHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgdmFsdWUgKz0gKGQgKiBiYXNlKTtcbiAgICAgIGJhc2UgKj0gNjA7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2lnbiAqIHZhbHVlO1xuXG4gIH1cblxuICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCAxMCk7XG59XG5cbmZ1bmN0aW9uIGlzSW50ZWdlcihvYmplY3QpIHtcbiAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmXG4gICAgICAgICAob2JqZWN0ICUgMSA9PT0gMCAmJiAhY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEludGVnZXIsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEludGVnZXIsXG4gIHByZWRpY2F0ZTogaXNJbnRlZ2VyLFxuICByZXByZXNlbnQ6IHtcbiAgICBiaW5hcnk6ICAgICAgZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gJzBiJyArIG9iamVjdC50b1N0cmluZygyKTsgfSxcbiAgICBvY3RhbDogICAgICAgZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gJzAnICArIG9iamVjdC50b1N0cmluZyg4KTsgfSxcbiAgICBkZWNpbWFsOiAgICAgZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gICAgICAgIG9iamVjdC50b1N0cmluZygxMCk7IH0sXG4gICAgaGV4YWRlY2ltYWw6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuICcweCcgKyBvYmplY3QudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnZGVjaW1hbCcsXG4gIHN0eWxlQWxpYXNlczoge1xuICAgIGJpbmFyeTogICAgICBbIDIsICAnYmluJyBdLFxuICAgIG9jdGFsOiAgICAgICBbIDgsICAnb2N0JyBdLFxuICAgIGRlY2ltYWw6ICAgICBbIDEwLCAnZGVjJyBdLFxuICAgIGhleGFkZWNpbWFsOiBbIDE2LCAnaGV4JyBdXG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXNwcmltYTtcblxuLy8gQnJvd3NlcmlmaWVkIHZlcnNpb24gZG9lcyBub3QgaGF2ZSBlc3ByaW1hXG4vL1xuLy8gMS4gRm9yIG5vZGUuanMganVzdCByZXF1aXJlIG1vZHVsZSBhcyBkZXBzXG4vLyAyLiBGb3IgYnJvd3NlciB0cnkgdG8gcmVxdWlyZSBtdWR1bGUgdmlhIGV4dGVybmFsIEFNRCBzeXN0ZW0uXG4vLyAgICBJZiBub3QgZm91bmQgLSB0cnkgdG8gZmFsbGJhY2sgdG8gd2luZG93LmVzcHJpbWEuIElmIG5vdFxuLy8gICAgZm91bmQgdG9vIC0gdGhlbiBmYWlsIHRvIHBhcnNlLlxuLy9cbnRyeSB7XG4gIC8vIHdvcmthcm91bmQgdG8gZXhjbHVkZSBwYWNrYWdlIGZyb20gYnJvd3NlcmlmeSBsaXN0LlxuICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlO1xuICBlc3ByaW1hID0gX3JlcXVpcmUoJ2VzcHJpbWEnKTtcbn0gY2F0Y2ggKF8pIHtcbiAgLypnbG9iYWwgd2luZG93ICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgZXNwcmltYSA9IHdpbmRvdy5lc3ByaW1hO1xufVxuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZUphdmFzY3JpcHRGdW5jdGlvbihkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgc291cmNlID0gJygnICsgZGF0YSArICcpJyxcbiAgICAgICAgYXN0ICAgID0gZXNwcmltYS5wYXJzZShzb3VyY2UsIHsgcmFuZ2U6IHRydWUgfSk7XG5cbiAgICBpZiAoYXN0LnR5cGUgICAgICAgICAgICAgICAgICAgICE9PSAnUHJvZ3JhbScgICAgICAgICAgICAgfHxcbiAgICAgICAgYXN0LmJvZHkubGVuZ3RoICAgICAgICAgICAgICE9PSAxICAgICAgICAgICAgICAgICAgICAgfHxcbiAgICAgICAgYXN0LmJvZHlbMF0udHlwZSAgICAgICAgICAgICE9PSAnRXhwcmVzc2lvblN0YXRlbWVudCcgfHxcbiAgICAgICAgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlICE9PSAnRnVuY3Rpb25FeHByZXNzaW9uJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uKGRhdGEpIHtcbiAgLypqc2xpbnQgZXZpbDp0cnVlKi9cblxuICB2YXIgc291cmNlID0gJygnICsgZGF0YSArICcpJyxcbiAgICAgIGFzdCAgICA9IGVzcHJpbWEucGFyc2Uoc291cmNlLCB7IHJhbmdlOiB0cnVlIH0pLFxuICAgICAgcGFyYW1zID0gW10sXG4gICAgICBib2R5O1xuXG4gIGlmIChhc3QudHlwZSAgICAgICAgICAgICAgICAgICAgIT09ICdQcm9ncmFtJyAgICAgICAgICAgICB8fFxuICAgICAgYXN0LmJvZHkubGVuZ3RoICAgICAgICAgICAgICE9PSAxICAgICAgICAgICAgICAgICAgICAgfHxcbiAgICAgIGFzdC5ib2R5WzBdLnR5cGUgICAgICAgICAgICAhPT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnIHx8XG4gICAgICBhc3QuYm9keVswXS5leHByZXNzaW9uLnR5cGUgIT09ICdGdW5jdGlvbkV4cHJlc3Npb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVzb2x2ZSBmdW5jdGlvbicpO1xuICB9XG5cbiAgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi5wYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICBwYXJhbXMucHVzaChwYXJhbS5uYW1lKTtcbiAgfSk7XG5cbiAgYm9keSA9IGFzdC5ib2R5WzBdLmV4cHJlc3Npb24uYm9keS5yYW5nZTtcblxuICAvLyBFc3ByaW1hJ3MgcmFuZ2VzIGluY2x1ZGUgdGhlIGZpcnN0ICd7JyBhbmQgdGhlIGxhc3QgJ30nIGNoYXJhY3RlcnMgb25cbiAgLy8gZnVuY3Rpb24gZXhwcmVzc2lvbnMuIFNvIGN1dCB0aGVtIG91dC5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYyovXG4gIHJldHVybiBuZXcgRnVuY3Rpb24ocGFyYW1zLCBzb3VyY2Uuc2xpY2UoYm9keVswXSArIDEsIGJvZHlbMV0gLSAxKSk7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudEphdmFzY3JpcHRGdW5jdGlvbihvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgcmV0dXJuIG9iamVjdC50b1N0cmluZygpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL2Z1bmN0aW9uJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZUphdmFzY3JpcHRGdW5jdGlvbixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0RnVuY3Rpb24sXG4gIHByZWRpY2F0ZTogaXNGdW5jdGlvbixcbiAgcmVwcmVzZW50OiByZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb25cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZUphdmFzY3JpcHRSZWdFeHAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICB2YXIgcmVnZXhwID0gZGF0YSxcbiAgICAgIHRhaWwgICA9IC9cXC8oW2dpbV0qKSQvLmV4ZWMoZGF0YSksXG4gICAgICBtb2RpZmllcnMgPSAnJztcblxuICAvLyBpZiByZWdleHAgc3RhcnRzIHdpdGggJy8nIGl0IGNhbiBoYXZlIG1vZGlmaWVycyBhbmQgbXVzdCBiZSBwcm9wZXJseSBjbG9zZWRcbiAgLy8gYC9mb28vZ2ltYCAtIG1vZGlmaWVycyB0YWlsIGNhbiBiZSBtYXhpbXVtIDMgY2hhcnNcbiAgaWYgKHJlZ2V4cFswXSA9PT0gJy8nKSB7XG4gICAgaWYgKHRhaWwpIG1vZGlmaWVycyA9IHRhaWxbMV07XG5cbiAgICBpZiAobW9kaWZpZXJzLmxlbmd0aCA+IDMpIHJldHVybiBmYWxzZTtcbiAgICAvLyBpZiBleHByZXNzaW9uIHN0YXJ0cyB3aXRoIC8sIGlzIHNob3VsZCBiZSBwcm9wZXJseSB0ZXJtaW5hdGVkXG4gICAgaWYgKHJlZ2V4cFtyZWdleHAubGVuZ3RoIC0gbW9kaWZpZXJzLmxlbmd0aCAtIDFdICE9PSAnLycpIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RKYXZhc2NyaXB0UmVnRXhwKGRhdGEpIHtcbiAgdmFyIHJlZ2V4cCA9IGRhdGEsXG4gICAgICB0YWlsICAgPSAvXFwvKFtnaW1dKikkLy5leGVjKGRhdGEpLFxuICAgICAgbW9kaWZpZXJzID0gJyc7XG5cbiAgLy8gYC9mb28vZ2ltYCAtIHRhaWwgY2FuIGJlIG1heGltdW0gNCBjaGFyc1xuICBpZiAocmVnZXhwWzBdID09PSAnLycpIHtcbiAgICBpZiAodGFpbCkgbW9kaWZpZXJzID0gdGFpbFsxXTtcbiAgICByZWdleHAgPSByZWdleHAuc2xpY2UoMSwgcmVnZXhwLmxlbmd0aCAtIG1vZGlmaWVycy5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4cCwgbW9kaWZpZXJzKTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cChvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgdmFyIHJlc3VsdCA9ICcvJyArIG9iamVjdC5zb3VyY2UgKyAnLyc7XG5cbiAgaWYgKG9iamVjdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmIChvYmplY3QubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAob2JqZWN0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL3JlZ2V4cCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdEphdmFzY3JpcHRSZWdFeHAsXG4gIHByZWRpY2F0ZTogaXNSZWdFeHAsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cFxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdEphdmFzY3JpcHRVbmRlZmluZWQoKSB7XG4gIC8qZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkKi9cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy91bmRlZmluZWQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0VW5kZWZpbmVkLFxuICBwcmVkaWNhdGU6IGlzVW5kZWZpbmVkLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudEphdmFzY3JpcHRVbmRlZmluZWRcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywge1xuICBraW5kOiAnbWFwcGluZycsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDoge307IH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxNZXJnZShkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSAnPDwnIHx8IGRhdGEgPT09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxNZXJnZVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE51bGwoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuXG4gIHJldHVybiAobWF4ID09PSAxICYmIGRhdGEgPT09ICd+JykgfHxcbiAgICAgICAgIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICdudWxsJyB8fCBkYXRhID09PSAnTnVsbCcgfHwgZGF0YSA9PT0gJ05VTEwnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09PSBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxOdWxsLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxOdWxsLFxuICBwcmVkaWNhdGU6IGlzTnVsbCxcbiAgcmVwcmVzZW50OiB7XG4gICAgY2Fub25pY2FsOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnfic7ICAgIH0sXG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnbnVsbCc7IH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnTlVMTCc7IH0sXG4gICAgY2FtZWxjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnTnVsbCc7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfdG9TdHJpbmcgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE9tYXAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIG9iamVjdEtleXMgPSBbXSwgaW5kZXgsIGxlbmd0aCwgcGFpciwgcGFpcktleSwgcGFpckhhc0tleSxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG4gICAgcGFpckhhc0tleSA9IGZhbHNlO1xuXG4gICAgaWYgKF90b1N0cmluZy5jYWxsKHBhaXIpICE9PSAnW29iamVjdCBPYmplY3RdJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChwYWlyS2V5IGluIHBhaXIpIHtcbiAgICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChwYWlyLCBwYWlyS2V5KSkge1xuICAgICAgICBpZiAoIXBhaXJIYXNLZXkpIHBhaXJIYXNLZXkgPSB0cnVlO1xuICAgICAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhaXJIYXNLZXkpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChvYmplY3RLZXlzLmluZGV4T2YocGFpcktleSkgPT09IC0xKSBvYmplY3RLZXlzLnB1c2gocGFpcktleSk7XG4gICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbE9tYXAoZGF0YSkge1xuICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6b21hcCcsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxPbWFwLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxPbWFwXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFBhaXJzKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBpbmRleCwgbGVuZ3RoLCBwYWlyLCBrZXlzLCByZXN1bHQsXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGlmIChfdG9TdHJpbmcuY2FsbChwYWlyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHJldHVybiBmYWxzZTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcblxuICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmVzdWx0W2luZGV4XSA9IFsga2V5c1swXSwgcGFpcltrZXlzWzBdXSBdO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxQYWlycyhkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gW107XG5cbiAgdmFyIGluZGV4LCBsZW5ndGgsIHBhaXIsIGtleXMsIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHBhaXIpO1xuXG4gICAgcmVzdWx0W2luZGV4XSA9IFsga2V5c1swXSwgcGFpcltrZXlzWzBdXSBdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sUGFpcnMsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFBhaXJzXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNlcScsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiBbXTsgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxTZXQoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIGtleSwgb2JqZWN0ID0gZGF0YTtcblxuICBmb3IgKGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICBpZiAob2JqZWN0W2tleV0gIT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFNldChkYXRhKSB7XG4gIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxTZXQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFNldFxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6ICcnOyB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBZQU1MX1RJTUVTVEFNUF9SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICAnXihbMC05XVswLTldWzAtOV1bMC05XSknICAgICAgICAgICsgLy8gWzFdIHllYXJcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFsyXSBtb250aFxuICAnLShbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICsgLy8gWzNdIGRheVxuICAnKD86KD86W1R0XXxbIFxcXFx0XSspJyAgICAgICAgICAgICAgKyAvLyAuLi5cbiAgJyhbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICArIC8vIFs0XSBob3VyXG4gICc6KFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNV0gbWludXRlXG4gICc6KFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNl0gc2Vjb25kXG4gICcoPzpcXFxcLihbMC05XSopKT8nICAgICAgICAgICAgICAgICArIC8vIFs3XSBmcmFjdGlvblxuICAnKD86WyBcXFxcdF0qKFp8KFstK10pKFswLTldWzAtOV0/KScgKyAvLyBbOF0gdHogWzldIHR6X3NpZ24gWzEwXSB0el9ob3VyXG4gICcoPzo6KFswLTldWzAtOV0pKT8pKT8pPyQnKTsgICAgICAgICAvLyBbMTFdIHR6X21pbnV0ZVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmIChZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIHZhciBtYXRjaCwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uID0gMCxcbiAgICAgIGRlbHRhID0gbnVsbCwgdHpfaG91ciwgdHpfbWludXRlLCBkYXRlO1xuXG4gIG1hdGNoID0gWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSk7XG5cbiAgaWYgKG1hdGNoID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGUgcmVzb2x2ZSBlcnJvcicpO1xuXG4gIC8vIG1hdGNoOiBbMV0geWVhciBbMl0gbW9udGggWzNdIGRheVxuXG4gIHllYXIgPSArKG1hdGNoWzFdKTtcbiAgbW9udGggPSArKG1hdGNoWzJdKSAtIDE7IC8vIEpTIG1vbnRoIHN0YXJ0cyB3aXRoIDBcbiAgZGF5ID0gKyhtYXRjaFszXSk7XG5cbiAgaWYgKCFtYXRjaFs0XSkgeyAvLyBubyBob3VyXG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXkpKTtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbNF0gaG91ciBbNV0gbWludXRlIFs2XSBzZWNvbmQgWzddIGZyYWN0aW9uXG5cbiAgaG91ciA9ICsobWF0Y2hbNF0pO1xuICBtaW51dGUgPSArKG1hdGNoWzVdKTtcbiAgc2Vjb25kID0gKyhtYXRjaFs2XSk7XG5cbiAgaWYgKG1hdGNoWzddKSB7XG4gICAgZnJhY3Rpb24gPSBtYXRjaFs3XS5zbGljZSgwLCAzKTtcbiAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgMykgeyAvLyBtaWxsaS1zZWNvbmRzXG4gICAgICBmcmFjdGlvbiArPSAnMCc7XG4gICAgfVxuICAgIGZyYWN0aW9uID0gK2ZyYWN0aW9uO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs4XSB0eiBbOV0gdHpfc2lnbiBbMTBdIHR6X2hvdXIgWzExXSB0el9taW51dGVcblxuICBpZiAobWF0Y2hbOV0pIHtcbiAgICB0el9ob3VyID0gKyhtYXRjaFsxMF0pO1xuICAgIHR6X21pbnV0ZSA9ICsobWF0Y2hbMTFdIHx8IDApO1xuICAgIGRlbHRhID0gKHR6X2hvdXIgKiA2MCArIHR6X21pbnV0ZSkgKiA2MDAwMDsgLy8gZGVsdGEgaW4gbWlsaS1zZWNvbmRzXG4gICAgaWYgKG1hdGNoWzldID09PSAnLScpIGRlbHRhID0gLWRlbHRhO1xuICB9XG5cbiAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbikpO1xuXG4gIGlmIChkZWx0YSkgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpIC0gZGVsdGEpO1xuXG4gIHJldHVybiBkYXRlO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sVGltZXN0YW1wKG9iamVjdCAvKiwgc3R5bGUqLykge1xuICByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sVGltZXN0YW1wLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxUaW1lc3RhbXAsXG4gIGluc3RhbmNlT2Y6IERhdGUsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbFRpbWVzdGFtcFxufSk7XG4iLCIvKlxyXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXHJcbipcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XHJcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG4qL1xyXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XHJcbiAgICB9XHJcbn0odGhpcywgZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNlbGYgPSB7fTtcclxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcclxuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcclxuXHJcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBXZSBjYW4ndCBidWlsZCBhIHJlYWwgbWV0aG9kIHdpdGhvdXQgYSBjb25zb2xlIHRvIGxvZyB0b1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcclxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmW21ldGhvZE5hbWVdLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsb2dNZXRob2RzID0gW1xyXG4gICAgICAgIFwidHJhY2VcIixcclxuICAgICAgICBcImRlYnVnXCIsXHJcbiAgICAgICAgXCJpbmZvXCIsXHJcbiAgICAgICAgXCJ3YXJuXCIsXHJcbiAgICAgICAgXCJlcnJvclwiXHJcbiAgICBdO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XHJcbiAgICAgICAgICAgIHNlbGZbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/IG5vb3AgOiBzZWxmLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XHJcbiAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcclxuXHJcbiAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlWydsb2dsZXZlbCddID0gbGV2ZWxOYW1lO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG5cclxuICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID0gXCJsb2dsZXZlbD1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xyXG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2FkUGVyc2lzdGVkTGV2ZWwoKSB7XHJcbiAgICAgICAgdmFyIHN0b3JlZExldmVsO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2VbJ2xvZ2xldmVsJ107XHJcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9sb2dsZXZlbD0oW147XSspLy5leGVjKHdpbmRvdy5kb2N1bWVudC5jb29raWUpWzFdO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzdG9yZWRMZXZlbCA9IFwiV0FSTlwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAgKlxyXG4gICAgICogUHVibGljIEFQSVxyXG4gICAgICpcclxuICAgICAqL1xyXG5cclxuICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxyXG4gICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XHJcblxyXG4gICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGxldmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcclxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xyXG4gICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcclxuICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgc2VsZi5sZXZlbHMuU0lMRU5UKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcclxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcclxuICAgIHNlbGYubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXHJcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IHNlbGYpIHtcclxuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgIH07XHJcblxyXG4gICAgbG9hZFBlcnNpc3RlZExldmVsKCk7XHJcbiAgICByZXR1cm4gc2VsZjtcclxufSkpO1xyXG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG5vdE51bGwoeCkgIHsgcmV0dXJuIHggIT0gbnVsbDsgfVxuZnVuY3Rpb24gd3JhcCh4KSAgICAgeyByZXR1cm4gJygnICsgeCArICcpJzt9XG5cbmZ1bmN0aW9uIG1heWJlUXVvdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gJ1wiJyArIHZhbHVlICsgJ1wiJztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBsb29rVXAoa2V5KSB7XG4gICAgaWYgKGtleVswXSA9PT0gJyQnKSB7XG4gICAgICAgIHJldHVybiAnY29udGV4dC4nICsga2V5LnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgcmV0dXJuICdjb250ZXh0LmZlYXR1cmUucHJvcGVydGllcy4nICsga2V5O1xufVxuXG5mdW5jdGlvbiBudWxsVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiAnIHRydWUgJztcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlFcXVhbChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHdyYXAobWF5YmVRdW90ZSh2YWx1ZSkgKyAnID09PSAnICsgbG9va1VwKGtleSkpO1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eU9yKGtleSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHdyYXAodmFsdWVzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gcHJvcGVydHlFcXVhbChrZXksIHgpOyB9KS5qb2luKCcgfHwgJykpO1xufVxuXG5mdW5jdGlvbiBub3Qoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiAnIScgKyB3cmFwKHBhcnNlRmlsdGVyKHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIG5vbmUoa2V5LCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gJyEnICsgd3JhcChhbnkobnVsbCwgdmFsdWVzKSk7XG59XG5cbmZ1bmN0aW9uIHByaW50TmVzdGVkKHZhbHVlcywgam9pbmVyKSB7XG4gICAgcmV0dXJuIHdyYXAodmFsdWVzLmZpbHRlcihub3ROdWxsKS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAoeC5qb2luKCcgJiYgJykpO1xuICAgIH0pLmpvaW4oJyAnICsgam9pbmVyICsgJyAnKSk7XG59XG5cbmZ1bmN0aW9uIGFueShfLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gcHJpbnROZXN0ZWQodmFsdWVzLm1hcChwYXJzZUZpbHRlciksICd8fCcpO1xufVxuXG5mdW5jdGlvbiBhbGwoXywgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHByaW50TmVzdGVkKHZhbHVlcy5maWx0ZXIobm90TnVsbCkubWFwKHBhcnNlRmlsdGVyKSwgJyYmJyk7XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5TWF0Y2hlc0Jvb2xlYW4oa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB3cmFwKGxvb2tVcChrZXkpICsgKHZhbHVlID8gJyAhPSAnIDogJyA9PSAnKSAgKyAnbnVsbCcpO1xufVxuXG5mdW5jdGlvbiByYW5nZU1hdGNoKGtleSwgdmFsdWVzKSB7XG4gICAgdmFyIGV4cHJlc3Npb25zID0gW107XG5cbiAgICBpZiAodmFsdWVzLm1heCkge1xuICAgICAgICBleHByZXNzaW9ucy5wdXNoKCcnICsgbG9va1VwKGtleSkgKyAnIDwgJyArIHZhbHVlcy5tYXgpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMubWluKSB7XG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2goJycgKyBsb29rVXAoa2V5KSArICcgPj0gJyArIHZhbHVlcy5taW4pO1xuICAgIH1cblxuICAgIHJldHVybiB3cmFwKGV4cHJlc3Npb25zLmpvaW4oJyAmJiAnKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVyKGZpbHRlcikge1xuICAgIHZhciBmaWx0ZXJBU1QgPSBbXTtcblxuICAgIC8vIEZ1bmN0aW9uIGZpbHRlclxuICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZpbHRlckFTVC5wdXNoKHdyYXAoZmlsdGVyLnRvU3RyaW5nKCkgKyAnKGNvbnRleHQpJykpO1xuICAgICAgICByZXR1cm4gZmlsdGVyQVNUO1xuICAgIH1cbiAgICAvLyBBcnJheSBmaWx0ZXIsIGltcGxpY2l0ICdhbnknXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlckFTVC5wdXNoKGFueShudWxsLCBmaWx0ZXIpKTtcbiAgICAgICAgcmV0dXJuIGZpbHRlckFTVDtcbiAgICB9XG5cbiAgICAvLyBPYmplY3QgZmlsdGVyLCBlLmcuIGltcGxpY2l0ICdhbGwnXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmaWx0ZXIpO1xuICAgIGZvciAodmFyIGs9MDsgayA8IGtleXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNba107XG5cbiAgICAgICAgdmFyIHZhbHVlID0gZmlsdGVyW2tleV0sXG4gICAgICAgICAgICB0eXBlICA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChwcm9wZXJ0eUVxdWFsKGtleSwgdmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKHByb3BlcnR5TWF0Y2hlc0Jvb2xlYW4oa2V5LCB2YWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKG51bGxWYWx1ZShrZXksIHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnbm90Jykge1xuICAgICAgICAgICAgZmlsdGVyQVNULnB1c2gobm90KGtleSwgdmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdhbnknKSB7XG4gICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChhbnkoa2V5LCB2YWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKGFsbChrZXksIHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKG5vbmUoa2V5LCB2YWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChwcm9wZXJ0eU9yKGtleSwgdmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubWF4IHx8IHZhbHVlLm1pbikge1xuICAgICAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKHJhbmdlTWF0Y2goa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIFF1ZXJ5IHN5dG5heDogJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrZXlzLmxlbmd0aCA9PT0gMCA/IFsndHJ1ZSddIDogZmlsdGVyQVNUO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJUb1N0cmluZyhmaWx0ZXJBU1QpIHtcbiAgICByZXR1cm4gd3JhcChmaWx0ZXJBU1Quam9pbignICYmICcpKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2goZmlsdGVyKSB7XG4gICAgaWYgKGZpbHRlciA9PSBudWxsKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9OyB9XG4gICAgLy8ganNoaW50IGV2aWw6IHRydWVcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdjb250ZXh0JywgJ3JldHVybiAnICsgZmlsdGVyVG9TdHJpbmcocGFyc2VGaWx0ZXIoZmlsdGVyKSkgKyAnOycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgZmlsdGVyVG9TdHJpbmc6IGZpbHRlclRvU3RyaW5nLFxuICAgIHBhcnNlRmlsdGVyOiBwYXJzZUZpbHRlclxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gbGlnaHR3ZWlnaHQgQnVmZmVyIHNoaW0gZm9yIHBiZiBicm93c2VyIGJ1aWxkXG4vLyBiYXNlZCBvbiBjb2RlIGZyb20gZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyIChNSVQtbGljZW5zZWQpXG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyO1xuXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKTtcblxudmFyIEJ1ZmZlck1ldGhvZHM7XG5cbmZ1bmN0aW9uIEJ1ZmZlcihsZW5ndGgpIHtcbiAgICB2YXIgYXJyO1xuICAgIGlmIChsZW5ndGggJiYgbGVuZ3RoLmxlbmd0aCkge1xuICAgICAgICBhcnIgPSBsZW5ndGg7XG4gICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgfVxuICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGggfHwgMCk7XG4gICAgaWYgKGFycikgYnVmLnNldChhcnIpO1xuXG4gICAgYnVmLnJlYWRVSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZFVJbnQzMkxFO1xuICAgIGJ1Zi53cml0ZVVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy53cml0ZVVJbnQzMkxFO1xuICAgIGJ1Zi5yZWFkSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZEludDMyTEU7XG4gICAgYnVmLndyaXRlSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVJbnQzMkxFO1xuICAgIGJ1Zi5yZWFkRmxvYXRMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZEZsb2F0TEU7XG4gICAgYnVmLndyaXRlRmxvYXRMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVGbG9hdExFO1xuICAgIGJ1Zi5yZWFkRG91YmxlTEUgPSBCdWZmZXJNZXRob2RzLnJlYWREb3VibGVMRTtcbiAgICBidWYud3JpdGVEb3VibGVMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVEb3VibGVMRTtcbiAgICBidWYudG9TdHJpbmcgPSBCdWZmZXJNZXRob2RzLnRvU3RyaW5nO1xuICAgIGJ1Zi53cml0ZSA9IEJ1ZmZlck1ldGhvZHMud3JpdGU7XG4gICAgYnVmLnNsaWNlID0gQnVmZmVyTWV0aG9kcy5zbGljZTtcbiAgICBidWYuY29weSA9IEJ1ZmZlck1ldGhvZHMuY29weTtcblxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlO1xuICAgIHJldHVybiBidWY7XG59XG5cbnZhciBsYXN0U3RyLCBsYXN0U3RyRW5jb2RlZDtcblxuQnVmZmVyTWV0aG9kcyA9IHtcbiAgICByZWFkVUludDMyTEU6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICByZXR1cm4gKCh0aGlzW3Bvc10pIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDFdIDw8IDgpIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDJdIDw8IDE2KSkgK1xuICAgICAgICAgICAgKHRoaXNbcG9zICsgM10gKiAweDEwMDAwMDApO1xuICAgIH0sXG5cbiAgICB3cml0ZVVJbnQzMkxFOiBmdW5jdGlvbih2YWwsIHBvcykge1xuICAgICAgICB0aGlzW3Bvc10gPSB2YWw7XG4gICAgICAgIHRoaXNbcG9zICsgMV0gPSAodmFsID4+PiA4KTtcbiAgICAgICAgdGhpc1twb3MgKyAyXSA9ICh2YWwgPj4+IDE2KTtcbiAgICAgICAgdGhpc1twb3MgKyAzXSA9ICh2YWwgPj4+IDI0KTtcbiAgICB9LFxuXG4gICAgcmVhZEludDMyTEU6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICByZXR1cm4gKCh0aGlzW3Bvc10pIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDFdIDw8IDgpIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDJdIDw8IDE2KSkgK1xuICAgICAgICAgICAgKHRoaXNbcG9zICsgM10gPDwgMjQpO1xuICAgIH0sXG5cbiAgICByZWFkRmxvYXRMRTogIGZ1bmN0aW9uKHBvcykgeyByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIHBvcywgdHJ1ZSwgMjMsIDQpOyB9LFxuICAgIHJlYWREb3VibGVMRTogZnVuY3Rpb24ocG9zKSB7IHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgcG9zLCB0cnVlLCA1MiwgOCk7IH0sXG5cbiAgICB3cml0ZUZsb2F0TEU6ICBmdW5jdGlvbih2YWwsIHBvcykgeyByZXR1cm4gaWVlZTc1NC53cml0ZSh0aGlzLCB2YWwsIHBvcywgdHJ1ZSwgMjMsIDQpOyB9LFxuICAgIHdyaXRlRG91YmxlTEU6IGZ1bmN0aW9uKHZhbCwgcG9zKSB7IHJldHVybiBpZWVlNzU0LndyaXRlKHRoaXMsIHZhbCwgcG9zLCB0cnVlLCA1MiwgOCk7IH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnLFxuICAgICAgICAgICAgdG1wID0gJyc7XG5cbiAgICAgICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbih0aGlzLmxlbmd0aCwgZW5kIHx8IHRoaXMubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChjaCA8PSAweDdGKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IGRlY29kZVVSSUNvbXBvbmVudCh0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgICAgICAgdG1wID0gJyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRtcCArPSAnJScgKyBjaC50b1N0cmluZygxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgKz0gZGVjb2RlVVJJQ29tcG9uZW50KHRtcCk7XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG4gICAgd3JpdGU6IGZ1bmN0aW9uKHN0ciwgcG9zKSB7XG4gICAgICAgIHZhciBieXRlcyA9IHN0ciA9PT0gbGFzdFN0ciA/IGxhc3RTdHJFbmNvZGVkIDogZW5jb2RlU3RyaW5nKHN0cik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXNbcG9zICsgaV0gPSBieXRlc1tpXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzbGljZTogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTtcbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oYnVmLCBwb3MpIHtcbiAgICAgICAgcG9zID0gcG9zIHx8IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnVmW3BvcyArIGldID0gdGhpc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkJ1ZmZlck1ldGhvZHMud3JpdGVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy53cml0ZVVJbnQzMkxFO1xuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGxhc3RTdHIgPSBzdHI7XG4gICAgbGFzdFN0ckVuY29kZWQgPSBlbmNvZGVTdHJpbmcoc3RyKTtcbiAgICByZXR1cm4gbGFzdFN0ckVuY29kZWQubGVuZ3RoO1xufTtcblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24oYnVmKSB7XG4gICAgcmV0dXJuICEhKGJ1ZiAmJiBidWYuX2lzQnVmZmVyKTtcbn07XG5cbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhzdHIpIHtcbiAgICB2YXIgbGVuZ3RoID0gc3RyLmxlbmd0aCxcbiAgICAgICAgYnl0ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBjLCBsZWFkOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBjb2RlIHBvaW50XG5cbiAgICAgICAgaWYgKGMgPiAweEQ3RkYgJiYgYyA8IDB4RTAwMCkge1xuXG4gICAgICAgICAgICBpZiAobGVhZCkge1xuICAgICAgICAgICAgICAgIGlmIChjIDwgMHhEQzAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBsZWFkIC0gMHhEODAwIDw8IDEwIHwgYyAtIDB4REMwMCB8IDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA+IDB4REJGRiB8fCAoaSArIDEgPT09IGxlbmd0aCkpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgICAgICAgZWxzZSBsZWFkID0gYztcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobGVhZCkge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgIGxlYWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwKSBieXRlcy5wdXNoKGMpO1xuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIGJ5dGVzLnB1c2goYyA+PiAweDYgfCAweEMwLCBjICYgMHgzRiB8IDB4ODApO1xuICAgICAgICBlbHNlIGlmIChjIDwgMHgxMDAwMCkgYnl0ZXMucHVzaChjID4+IDB4QyB8IDB4RTAsIGMgPj4gMHg2ICYgMHgzRiB8IDB4ODAsIGMgJiAweDNGIHwgMHg4MCk7XG4gICAgICAgIGVsc2UgYnl0ZXMucHVzaChjID4+IDB4MTIgfCAweEYwLCBjID4+IDB4QyAmIDB4M0YgfCAweDgwLCBjID4+IDB4NiAmIDB4M0YgfCAweDgwLCBjICYgMHgzRiB8IDB4ODApO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGJmO1xuXG52YXIgQnVmZmVyID0gZ2xvYmFsLkJ1ZmZlciB8fCByZXF1aXJlKCcuL2J1ZmZlcicpO1xuXG5mdW5jdGlvbiBQYmYoYnVmKSB7XG4gICAgdGhpcy5idWYgPSAhQnVmZmVyLmlzQnVmZmVyKGJ1ZikgPyBuZXcgQnVmZmVyKGJ1ZiB8fCAwKSA6IGJ1ZjtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmJ1Zi5sZW5ndGg7XG59XG5cblBiZi5WYXJpbnQgID0gMDsgLy8gdmFyaW50OiBpbnQzMiwgaW50NjQsIHVpbnQzMiwgdWludDY0LCBzaW50MzIsIHNpbnQ2NCwgYm9vbCwgZW51bVxuUGJmLkZpeGVkNjQgPSAxOyAvLyA2NC1iaXQ6IGRvdWJsZSwgZml4ZWQ2NCwgc2ZpeGVkNjRcblBiZi5CeXRlcyAgID0gMjsgLy8gbGVuZ3RoLWRlbGltaXRlZDogc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHNcblBiZi5GaXhlZDMyID0gNTsgLy8gMzItYml0OiBmbG9hdCwgZml4ZWQzMiwgc2ZpeGVkMzJcblxudmFyIFNISUZUX0xFRlRfMzIgPSAoMSA8PCAxNikgKiAoMSA8PCAxNiksXG4gICAgU0hJRlRfUklHSFRfMzIgPSAxIC8gU0hJRlRfTEVGVF8zMixcbiAgICBQT1dfMl82MyA9IE1hdGgucG93KDIsIDYzKTtcblxuUGJmLnByb3RvdHlwZSA9IHtcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJ1ZiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8vID09PSBSRUFESU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICByZWFkRmllbGRzOiBmdW5jdGlvbihyZWFkRmllbGQsIHJlc3VsdCwgZW5kKSB7XG4gICAgICAgIGVuZCA9IGVuZCB8fCB0aGlzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLnJlYWRWYXJpbnQoKSxcbiAgICAgICAgICAgICAgICB0YWcgPSB2YWwgPj4gMyxcbiAgICAgICAgICAgICAgICBzdGFydFBvcyA9IHRoaXMucG9zO1xuXG4gICAgICAgICAgICByZWFkRmllbGQodGFnLCByZXN1bHQsIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0UG9zKSB0aGlzLnNraXAodmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICByZWFkTWVzc2FnZTogZnVuY3Rpb24ocmVhZEZpZWxkLCByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZpZWxkcyhyZWFkRmllbGQsIHJlc3VsdCwgdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcyk7XG4gICAgfSxcblxuICAgIHJlYWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRTRml4ZWQzMjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIC8vIDY0LWJpdCBpbnQgaGFuZGxpbmcgaXMgYmFzZWQgb24gZ2l0aHViLmNvbS9kcHcvbm9kZS1idWZmZXItbW9yZS1pbnRzIChNSVQtbGljZW5zZWQpXG5cbiAgICByZWFkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpICsgdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkU0ZpeGVkNjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zKSArIHRoaXMuYnVmLnJlYWRJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZEZsb2F0TEUodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWREb3VibGVMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYnVmID0gdGhpcy5idWYsXG4gICAgICAgICAgICB2YWwsIGIsIGIwLCBiMSwgYjIsIGIzO1xuXG4gICAgICAgIGIwID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjAgPCAweDgwKSByZXR1cm4gYjA7ICAgICAgICAgICAgICAgICBiMCA9IGIwICYgMHg3ZjtcbiAgICAgICAgYjEgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMSA8IDB4ODApIHJldHVybiBiMCB8IGIxIDw8IDc7ICAgICAgIGIxID0gKGIxICYgMHg3ZikgPDwgNztcbiAgICAgICAgYjIgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMiA8IDB4ODApIHJldHVybiBiMCB8IGIxIHwgYjIgPDwgMTQ7IGIyID0gKGIyICYgMHg3ZikgPDwgMTQ7XG4gICAgICAgIGIzID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjMgPCAweDgwKSByZXR1cm4gYjAgfCBiMSB8IGIyIHwgYjMgPDwgMjE7XG5cbiAgICAgICAgdmFsID0gYjAgfCBiMSB8IGIyIHwgKGIzICYgMHg3ZikgPDwgMjE7XG5cbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwOyAgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDsgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDQwMDAwMDAwMDAwOyAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDIwMDAwMDAwMDAwMDA7ICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwMDAwMDAwMDsgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDAwMDAwMDA7IGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhcmludCBub3QgbW9yZSB0aGFuIDEwIGJ5dGVzJyk7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zLFxuICAgICAgICAgICAgdmFsID0gdGhpcy5yZWFkVmFyaW50KCk7XG5cbiAgICAgICAgaWYgKHZhbCA8IFBPV18yXzYzKSByZXR1cm4gdmFsO1xuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcyAtIDI7XG4gICAgICAgIHdoaWxlICh0aGlzLmJ1Zltwb3NdID09PSAweGZmKSBwb3MtLTtcbiAgICAgICAgaWYgKHBvcyA8IHN0YXJ0UG9zKSBwb3MgPSBzdGFydFBvcztcblxuICAgICAgICB2YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvcyAtIHN0YXJ0UG9zICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYiA9IH50aGlzLmJ1ZltzdGFydFBvcyArIGldICYgMHg3ZjtcbiAgICAgICAgICAgIHZhbCArPSBpIDwgNCA/IGIgPDwgaSAqIDcgOiBiICogTWF0aC5wb3coMiwgaSAqIDcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC12YWwgLSAxO1xuICAgIH0sXG5cbiAgICByZWFkU1ZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBudW0gPSB0aGlzLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgcmV0dXJuIG51bSAlIDIgPT09IDEgPyAobnVtICsgMSkgLyAtMiA6IG51bSAvIDI7IC8vIHppZ3phZyBlbmNvZGluZ1xuICAgIH0sXG5cbiAgICByZWFkQm9vbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMucmVhZFZhcmludCgpKTtcbiAgICB9LFxuXG4gICAgcmVhZFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgc3RyID0gdGhpcy5idWYudG9TdHJpbmcoJ3V0ZjgnLCB0aGlzLnBvcywgZW5kKTtcbiAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIHJlYWRCeXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgYnVmZmVyID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIGVuZCk7XG4gICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH0sXG5cbiAgICAvLyB2ZXJib3NlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOyBkb2Vzbid0IGFmZmVjdCBnemlwcGVkIHNpemVcblxuICAgIHJlYWRQYWNrZWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkVmFyaW50KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU1ZhcmludCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRCb29sZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEJvb2xlYW4oKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRmxvYXQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU0ZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZFNGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG5cbiAgICBza2lwOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB2YWwgJiAweDc7XG4gICAgICAgIGlmICh0eXBlID09PSBQYmYuVmFyaW50KSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gPiAweDdmKSB7fVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuQnl0ZXMpIHRoaXMucG9zID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcztcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gUGJmLkZpeGVkMzIpIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBiZi5GaXhlZDY0KSB0aGlzLnBvcyArPSA4O1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCB0eXBlOiAnICsgdHlwZSk7XG4gICAgfSxcblxuICAgIC8vID09PSBXUklUSU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICB3cml0ZVRhZzogZnVuY3Rpb24odGFnLCB0eXBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoKHRhZyA8PCAzKSB8IHR5cGUpO1xuICAgIH0sXG5cbiAgICByZWFsbG9jOiBmdW5jdGlvbihtaW4pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDE2O1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGggPCB0aGlzLnBvcyArIG1pbikgbGVuZ3RoICo9IDI7XG5cbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5jb3B5KGJ1Zik7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgd3JpdGVGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQzMkxFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZVNGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgfSxcblxuICAgIHdyaXRlRml4ZWQ2NDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlU0ZpeGVkNjQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFsID0gK3ZhbDtcblxuICAgICAgICBpZiAodmFsIDw9IDB4N2YpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gdmFsO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4M2ZmZikge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDIpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMCkgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiA3KSAmIDB4N2YpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4MWZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMyk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMTQpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPD0gMHhmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMTQpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMjEpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHdoaWxlICh2YWwgPj0gMHg4MCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICh2YWwgJiAweGZmKSB8IDB4ODA7XG4gICAgICAgICAgICAgICAgdmFsIC89IDB4ODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMSk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IHZhbCB8IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgLSBwb3MgPiAxMCkgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiB2YXJpbnQgZG9lc25cXCd0IGZpdCBpbnRvIDEwIGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd3JpdGVTVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwgPCAwID8gLXZhbCAqIDIgLSAxIDogdmFsICogMik7XG4gICAgfSxcblxuICAgIHdyaXRlQm9vbGVhbjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoQm9vbGVhbih2YWwpKTtcbiAgICB9LFxuXG4gICAgd3JpdGVTdHJpbmc6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgdmFyIGJ5dGVzID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyKTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChieXRlcyk7XG4gICAgICAgIHRoaXMucmVhbGxvYyhieXRlcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlKHN0ciwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSBieXRlcztcbiAgICB9LFxuXG4gICAgd3JpdGVGbG9hdDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVGbG9hdExFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZURvdWJsZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVEb3VibGVMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICB9LFxuXG4gICAgd3JpdGVCeXRlczogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucmVhbGxvYyhsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IGJ1ZmZlcltpXTtcbiAgICB9LFxuXG4gICAgd3JpdGVNZXNzYWdlOiBmdW5jdGlvbih0YWcsIGZuLCBvYmopIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5CeXRlcyk7XG5cbiAgICAgICAgdGhpcy5wb3MrKzsgLy8gcmVzZXJ2ZSAxIGJ5dGUgZm9yIHNob3J0IG1lc3NhZ2UgbGVuZ3RoXG5cbiAgICAgICAgLy8gd3JpdGUgdGhlIG1lc3NhZ2UgZGlyZWN0bHkgdG8gdGhlIGJ1ZmZlciBhbmQgc2VlIGhvdyBtdWNoIHdhcyB3cml0dGVuXG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zO1xuICAgICAgICBmbihvYmosIHRoaXMpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5wb3MgLSBzdGFydFBvcztcblxuICAgICAgICB2YXIgdmFyaW50TGVuID1cbiAgICAgICAgICAgIGxlbiA8PSAweDdmID8gMSA6XG4gICAgICAgICAgICBsZW4gPD0gMHgzZmZmID8gMiA6XG4gICAgICAgICAgICBsZW4gPD0gMHgxZmZmZmYgPyAzIDpcbiAgICAgICAgICAgIGxlbiA8PSAweGZmZmZmZmYgPyA0IDogTWF0aC5jZWlsKE1hdGgubG9nKGxlbikgLyAoTWF0aC5MTjIgKiA3KSk7XG5cbiAgICAgICAgLy8gaWYgMSBieXRlIGlzbid0IGVub3VnaCBmb3IgZW5jb2RpbmcgbWVzc2FnZSBsZW5ndGgsIHNoaWZ0IHRoZSBkYXRhIHRvIHRoZSByaWdodFxuICAgICAgICBpZiAodmFyaW50TGVuID4gMSkge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKHZhcmludExlbiAtIDEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucG9zIC0gMTsgaSA+PSBzdGFydFBvczsgaS0tKSB0aGlzLmJ1ZltpICsgdmFyaW50TGVuIC0gMV0gPSB0aGlzLmJ1ZltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsbHksIHdyaXRlIHRoZSBtZXNzYWdlIGxlbmd0aCBpbiB0aGUgcmVzZXJ2ZWQgcGxhY2UgYW5kIHJlc3RvcmUgdGhlIHBvc2l0aW9uXG4gICAgICAgIHRoaXMucG9zID0gc3RhcnRQb3MgLSAxO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICB9LFxuXG4gICAgd3JpdGVQYWNrZWRWYXJpbnQ6ICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFZhcmludCwgYXJyKTsgICB9LFxuICAgIHdyaXRlUGFja2VkU1ZhcmludDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRTVmFyaW50LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZEJvb2xlYW46ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkQm9vbGVhbiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRGbG9hdDogICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZsb2F0LCBhcnIpOyAgICB9LFxuICAgIHdyaXRlUGFja2VkRG91YmxlOiAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWREb3VibGUsIGFycik7ICAgfSxcbiAgICB3cml0ZVBhY2tlZEZpeGVkMzI6ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRml4ZWQzMiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRTRml4ZWQzMjogZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNGaXhlZDMyLCBhcnIpOyB9LFxuICAgIHdyaXRlUGFja2VkRml4ZWQ2NDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRGaXhlZDY0LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU0ZpeGVkNjQsIGFycik7IH0sXG5cbiAgICB3cml0ZUJ5dGVzRmllbGQ6IGZ1bmN0aW9uKHRhZywgYnVmZmVyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlQnl0ZXMoYnVmZmVyKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQzMih2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkMzIodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQ2NCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkNjQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVNWYXJpbnQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU3RyaW5nRmllbGQ6IGZ1bmN0aW9uKHRhZywgc3RyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlU3RyaW5nKHN0cik7XG4gICAgfSxcbiAgICB3cml0ZUZsb2F0RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQzMik7XG4gICAgICAgIHRoaXMud3JpdGVGbG9hdCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVEb3VibGVGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcbiAgICAgICAgdGhpcy53cml0ZURvdWJsZSh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVCb29sZWFuRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnRGaWVsZCh0YWcsIEJvb2xlYW4odmFsKSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVQYWNrZWRWYXJpbnQoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlVmFyaW50KGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTVmFyaW50KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU1ZhcmludChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGbG9hdChhcnIsIHBiZikgICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRmxvYXQoYXJyW2ldKTsgICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWREb3VibGUoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRG91YmxlKGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRCb29sZWFuKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlQm9vbGVhbihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDMyKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQzMihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQzMihhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkMzIoYXJyW2ldKTsgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDY0KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQ2NChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQ2NChhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkNjQoYXJyW2ldKTsgfVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTl3WW1ZdmFXNWtaWGd1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJJaXdpWm1sc1pTSTZJbWRsYm1WeVlYUmxaQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lJbmRYTmxJSE4wY21samRDYzdYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnVUdKbU8xeHVYRzUyWVhJZ1FuVm1abVZ5SUQwZ1oyeHZZbUZzTGtKMVptWmxjaUI4ZkNCeVpYRjFhWEpsS0NjdUwySjFabVpsY2ljcE8xeHVYRzVtZFc1amRHbHZiaUJRWW1Zb1luVm1LU0I3WEc0Z0lDQWdkR2hwY3k1aWRXWWdQU0FoUW5WbVptVnlMbWx6UW5WbVptVnlLR0oxWmlrZ1B5QnVaWGNnUW5WbVptVnlLR0oxWmlCOGZDQXdLU0E2SUdKMVpqdGNiaUFnSUNCMGFHbHpMbkJ2Y3lBOUlEQTdYRzRnSUNBZ2RHaHBjeTVzWlc1bmRHZ2dQU0IwYUdsekxtSjFaaTVzWlc1bmRHZzdYRzU5WEc1Y2JsQmlaaTVXWVhKcGJuUWdJRDBnTURzZ0x5OGdkbUZ5YVc1ME9pQnBiblF6TWl3Z2FXNTBOalFzSUhWcGJuUXpNaXdnZFdsdWREWTBMQ0J6YVc1ME16SXNJSE5wYm5RMk5Dd2dZbTl2YkN3Z1pXNTFiVnh1VUdKbUxrWnBlR1ZrTmpRZ1BTQXhPeUF2THlBMk5DMWlhWFE2SUdSdmRXSnNaU3dnWm1sNFpXUTJOQ3dnYzJacGVHVmtOalJjYmxCaVppNUNlWFJsY3lBZ0lEMGdNanNnTHk4Z2JHVnVaM1JvTFdSbGJHbHRhWFJsWkRvZ2MzUnlhVzVuTENCaWVYUmxjeXdnWlcxaVpXUmtaV1FnYldWemMyRm5aWE1zSUhCaFkydGxaQ0J5WlhCbFlYUmxaQ0JtYVdWc1pITmNibEJpWmk1R2FYaGxaRE15SUQwZ05Uc2dMeThnTXpJdFltbDBPaUJtYkc5aGRDd2dabWw0WldRek1pd2djMlpwZUdWa016SmNibHh1ZG1GeUlGTklTVVpVWDB4RlJsUmZNeklnUFNBb01TQThQQ0F4TmlrZ0tpQW9NU0E4UENBeE5pa3NYRzRnSUNBZ1UwaEpSbFJmVWtsSFNGUmZNeklnUFNBeElDOGdVMGhKUmxSZlRFVkdWRjh6TWl4Y2JpQWdJQ0JRVDFkZk1sODJNeUE5SUUxaGRHZ3VjRzkzS0RJc0lEWXpLVHRjYmx4dVVHSm1MbkJ5YjNSdmRIbHdaU0E5SUh0Y2JseHVJQ0FnSUdSbGMzUnliM2s2SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TG1KMVppQTlJRzUxYkd3N1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUM4dklEMDlQU0JTUlVGRVNVNUhJRDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5WEc1Y2JpQWdJQ0J5WldGa1JtbGxiR1J6T2lCbWRXNWpkR2x2YmloeVpXRmtSbWxsYkdRc0lISmxjM1ZzZEN3Z1pXNWtLU0I3WEc0Z0lDQWdJQ0FnSUdWdVpDQTlJR1Z1WkNCOGZDQjBhR2x6TG14bGJtZDBhRHRjYmx4dUlDQWdJQ0FnSUNCM2FHbHNaU0FvZEdocGN5NXdiM01nUENCbGJtUXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIWmhjaUIyWVd3Z1BTQjBhR2x6TG5KbFlXUldZWEpwYm5Rb0tTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjBZV2NnUFNCMllXd2dQajRnTXl4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCemRHRnlkRkJ2Y3lBOUlIUm9hWE11Y0c5ek8xeHVYRzRnSUNBZ0lDQWdJQ0FnSUNCeVpXRmtSbWxsYkdRb2RHRm5MQ0J5WlhOMWJIUXNJSFJvYVhNcE8xeHVYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9kR2hwY3k1d2IzTWdQVDA5SUhOMFlYSjBVRzl6S1NCMGFHbHpMbk5yYVhBb2RtRnNLVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnY21WemRXeDBPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQnlaV0ZrVFdWemMyRm5aVG9nWm5WdVkzUnBiMjRvY21WaFpFWnBaV3hrTENCeVpYTjFiSFFwSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVjbVZoWkVacFpXeGtjeWh5WldGa1JtbGxiR1FzSUhKbGMzVnNkQ3dnZEdocGN5NXlaV0ZrVm1GeWFXNTBLQ2tnS3lCMGFHbHpMbkJ2Y3lrN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUhKbFlXUkdhWGhsWkRNeU9pQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlIWmhiQ0E5SUhSb2FYTXVZblZtTG5KbFlXUlZTVzUwTXpKTVJTaDBhR2x6TG5CdmN5azdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNHOXpJQ3M5SURRN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMllXdzdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lISmxZV1JUUm1sNFpXUXpNam9nWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNBZ0lIWmhjaUIyWVd3Z1BTQjBhR2x6TG1KMVppNXlaV0ZrU1c1ME16Sk1SU2gwYUdsekxuQnZjeWs3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjRzl6SUNzOUlEUTdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjJZV3c3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJQzh2SURZMExXSnBkQ0JwYm5RZ2FHRnVaR3hwYm1jZ2FYTWdZbUZ6WldRZ2IyNGdaMmwwYUhWaUxtTnZiUzlrY0hjdmJtOWtaUzFpZFdabVpYSXRiVzl5WlMxcGJuUnpJQ2hOU1ZRdGJHbGpaVzV6WldRcFhHNWNiaUFnSUNCeVpXRmtSbWw0WldRMk5Eb2dablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUhaaGNpQjJZV3dnUFNCMGFHbHpMbUoxWmk1eVpXRmtWVWx1ZERNeVRFVW9kR2hwY3k1d2IzTXBJQ3NnZEdocGN5NWlkV1l1Y21WaFpGVkpiblF6TWt4RktIUm9hWE11Y0c5eklDc2dOQ2tnS2lCVFNFbEdWRjlNUlVaVVh6TXlPMXh1SUNBZ0lDQWdJQ0IwYUdsekxuQnZjeUFyUFNBNE8xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RtRnNPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQnlaV0ZrVTBacGVHVmtOalE2SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ0lDQjJZWElnZG1Gc0lEMGdkR2hwY3k1aWRXWXVjbVZoWkZWSmJuUXpNa3hGS0hSb2FYTXVjRzl6S1NBcklIUm9hWE11WW5WbUxuSmxZV1JKYm5Rek1reEZLSFJvYVhNdWNHOXpJQ3NnTkNrZ0tpQlRTRWxHVkY5TVJVWlVYek15TzF4dUlDQWdJQ0FnSUNCMGFHbHpMbkJ2Y3lBclBTQTRPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkbUZzTzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0J5WldGa1JteHZZWFE2SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ0lDQjJZWElnZG1Gc0lEMGdkR2hwY3k1aWRXWXVjbVZoWkVac2IyRjBURVVvZEdocGN5NXdiM01wTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbkJ2Y3lBclBTQTBPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkbUZzTzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0J5WldGa1JHOTFZbXhsT2lCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lDQWdkbUZ5SUhaaGJDQTlJSFJvYVhNdVluVm1MbkpsWVdSRWIzVmliR1ZNUlNoMGFHbHpMbkJ2Y3lrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11Y0c5eklDczlJRGc3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIyWVd3N1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUhKbFlXUldZWEpwYm5RNklHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lDQWdJQ0IyWVhJZ1luVm1JRDBnZEdocGN5NWlkV1lzWEc0Z0lDQWdJQ0FnSUNBZ0lDQjJZV3dzSUdJc0lHSXdMQ0JpTVN3Z1lqSXNJR0l6TzF4dVhHNGdJQ0FnSUNBZ0lHSXdJRDBnWW5WbVczUm9hWE11Y0c5ekt5dGRPeUJwWmlBb1lqQWdQQ0F3ZURnd0tTQnlaWFIxY200Z1lqQTdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmlNQ0E5SUdJd0lDWWdNSGczWmp0Y2JpQWdJQ0FnSUNBZ1lqRWdQU0JpZFdaYmRHaHBjeTV3YjNNcksxMDdJR2xtSUNoaU1TQThJREI0T0RBcElISmxkSFZ5YmlCaU1DQjhJR0l4SUR3OElEYzdJQ0FnSUNBZ0lHSXhJRDBnS0dJeElDWWdNSGczWmlrZ1BEd2dOenRjYmlBZ0lDQWdJQ0FnWWpJZ1BTQmlkV1piZEdocGN5NXdiM01ySzEwN0lHbG1JQ2hpTWlBOElEQjRPREFwSUhKbGRIVnliaUJpTUNCOElHSXhJSHdnWWpJZ1BEd2dNVFE3SUdJeUlEMGdLR0l5SUNZZ01IZzNaaWtnUER3Z01UUTdYRzRnSUNBZ0lDQWdJR0l6SUQwZ1luVm1XM1JvYVhNdWNHOXpLeXRkT3lCcFppQW9Zak1nUENBd2VEZ3dLU0J5WlhSMWNtNGdZakFnZkNCaU1TQjhJR0l5SUh3Z1lqTWdQRHdnTWpFN1hHNWNiaUFnSUNBZ0lDQWdkbUZzSUQwZ1lqQWdmQ0JpTVNCOElHSXlJSHdnS0dJeklDWWdNSGczWmlrZ1BEd2dNakU3WEc1Y2JpQWdJQ0FnSUNBZ1lpQTlJR0oxWmx0MGFHbHpMbkJ2Y3lzclhUc2dkbUZzSUNzOUlDaGlJQ1lnTUhnM1ppa2dLaUF3ZURFd01EQXdNREF3T3lBZ0lDQWdJQ0FnSUdsbUlDaGlJRHdnTUhnNE1Da2djbVYwZFhKdUlIWmhiRHRjYmlBZ0lDQWdJQ0FnWWlBOUlHSjFabHQwYUdsekxuQnZjeXNyWFRzZ2RtRnNJQ3M5SUNoaUlDWWdNSGczWmlrZ0tpQXdlRGd3TURBd01EQXdNRHNnSUNBZ0lDQWdJR2xtSUNoaUlEd2dNSGc0TUNrZ2NtVjBkWEp1SUhaaGJEdGNiaUFnSUNBZ0lDQWdZaUE5SUdKMVpsdDBhR2x6TG5CdmN5c3JYVHNnZG1Gc0lDczlJQ2hpSUNZZ01IZzNaaWtnS2lBd2VEUXdNREF3TURBd01EQXdPeUFnSUNBZ0lHbG1JQ2hpSUR3Z01IZzRNQ2tnY21WMGRYSnVJSFpoYkR0Y2JpQWdJQ0FnSUNBZ1lpQTlJR0oxWmx0MGFHbHpMbkJ2Y3lzclhUc2dkbUZzSUNzOUlDaGlJQ1lnTUhnM1ppa2dLaUF3ZURJd01EQXdNREF3TURBd01EQTdJQ0FnSUdsbUlDaGlJRHdnTUhnNE1Da2djbVYwZFhKdUlIWmhiRHRjYmlBZ0lDQWdJQ0FnWWlBOUlHSjFabHQwYUdsekxuQnZjeXNyWFRzZ2RtRnNJQ3M5SUNoaUlDWWdNSGczWmlrZ0tpQXdlREV3TURBd01EQXdNREF3TURBd01Ec2dJR2xtSUNoaUlEd2dNSGc0TUNrZ2NtVjBkWEp1SUhaaGJEdGNiaUFnSUNBZ0lDQWdZaUE5SUdKMVpsdDBhR2x6TG5CdmN5c3JYVHNnZG1Gc0lDczlJQ2hpSUNZZ01IZzNaaWtnS2lBd2VEZ3dNREF3TURBd01EQXdNREF3TURBN0lHbG1JQ2hpSUR3Z01IZzRNQ2tnY21WMGRYSnVJSFpoYkR0Y2JseHVJQ0FnSUNBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb0owVjRjR1ZqZEdWa0lIWmhjbWx1ZENCdWIzUWdiVzl5WlNCMGFHRnVJREV3SUdKNWRHVnpKeWs3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJSEpsWVdSV1lYSnBiblEyTkRvZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCemRHRnlkRkJ2Y3lBOUlIUm9hWE11Y0c5ekxGeHVJQ0FnSUNBZ0lDQWdJQ0FnZG1Gc0lEMGdkR2hwY3k1eVpXRmtWbUZ5YVc1MEtDazdYRzVjYmlBZ0lDQWdJQ0FnYVdZZ0tIWmhiQ0E4SUZCUFYxOHlYell6S1NCeVpYUjFjbTRnZG1Gc08xeHVYRzRnSUNBZ0lDQWdJSFpoY2lCd2IzTWdQU0IwYUdsekxuQnZjeUF0SURJN1hHNGdJQ0FnSUNBZ0lIZG9hV3hsSUNoMGFHbHpMbUoxWmx0d2IzTmRJRDA5UFNBd2VHWm1LU0J3YjNNdExUdGNiaUFnSUNBZ0lDQWdhV1lnS0hCdmN5QThJSE4wWVhKMFVHOXpLU0J3YjNNZ1BTQnpkR0Z5ZEZCdmN6dGNibHh1SUNBZ0lDQWdJQ0IyWVd3Z1BTQXdPMXh1SUNBZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUhCdmN5QXRJSE4wWVhKMFVHOXpJQ3NnTVRzZ2FTc3JLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjJZWElnWWlBOUlINTBhR2x6TG1KMVpsdHpkR0Z5ZEZCdmN5QXJJR2xkSUNZZ01IZzNaanRjYmlBZ0lDQWdJQ0FnSUNBZ0lIWmhiQ0FyUFNCcElEd2dOQ0EvSUdJZ1BEd2dhU0FxSURjZ09pQmlJQ29nVFdGMGFDNXdiM2NvTWl3Z2FTQXFJRGNwTzF4dUlDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlDMTJZV3dnTFNBeE8xeHVJQ0FnSUgwc1hHNWNiaUFnSUNCeVpXRmtVMVpoY21sdWREb2dablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUhaaGNpQnVkVzBnUFNCMGFHbHpMbkpsWVdSV1lYSnBiblFvS1R0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUc1MWJTQWxJRElnUFQwOUlERWdQeUFvYm5WdElDc2dNU2tnTHlBdE1pQTZJRzUxYlNBdklESTdJQzh2SUhwcFozcGhaeUJsYm1OdlpHbHVaMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQnlaV0ZrUW05dmJHVmhiam9nWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCQ2IyOXNaV0Z1S0hSb2FYTXVjbVZoWkZaaGNtbHVkQ2dwS1R0Y2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnY21WaFpGTjBjbWx1WnpvZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCbGJtUWdQU0IwYUdsekxuSmxZV1JXWVhKcGJuUW9LU0FySUhSb2FYTXVjRzl6TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdjM1J5SUQwZ2RHaHBjeTVpZFdZdWRHOVRkSEpwYm1jb0ozVjBaamduTENCMGFHbHpMbkJ2Y3l3Z1pXNWtLVHRjYmlBZ0lDQWdJQ0FnZEdocGN5NXdiM01nUFNCbGJtUTdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnpkSEk3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJSEpsWVdSQ2VYUmxjem9nWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNBZ0lIWmhjaUJsYm1RZ1BTQjBhR2x6TG5KbFlXUldZWEpwYm5Rb0tTQXJJSFJvYVhNdWNHOXpMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1luVm1abVZ5SUQwZ2RHaHBjeTVpZFdZdWMyeHBZMlVvZEdocGN5NXdiM01zSUdWdVpDazdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNHOXpJRDBnWlc1a08xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1luVm1abVZ5TzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0F2THlCMlpYSmliM05sSUdadmNpQndaWEptYjNKdFlXNWpaU0J5WldGemIyNXpPeUJrYjJWemJpZDBJR0ZtWm1WamRDQm5lbWx3Y0dWa0lITnBlbVZjYmx4dUlDQWdJSEpsWVdSUVlXTnJaV1JXWVhKcGJuUTZJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnSUNCMllYSWdaVzVrSUQwZ2RHaHBjeTV5WldGa1ZtRnlhVzUwS0NrZ0t5QjBhR2x6TG5CdmN5d2dZWEp5SUQwZ1cxMDdYRzRnSUNBZ0lDQWdJSGRvYVd4bElDaDBhR2x6TG5CdmN5QThJR1Z1WkNrZ1lYSnlMbkIxYzJnb2RHaHBjeTV5WldGa1ZtRnlhVzUwS0NrcE8xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1lYSnlPMXh1SUNBZ0lIMHNYRzRnSUNBZ2NtVmhaRkJoWTJ0bFpGTldZWEpwYm5RNklHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lDQWdJQ0IyWVhJZ1pXNWtJRDBnZEdocGN5NXlaV0ZrVm1GeWFXNTBLQ2tnS3lCMGFHbHpMbkJ2Y3l3Z1lYSnlJRDBnVzEwN1hHNGdJQ0FnSUNBZ0lIZG9hV3hsSUNoMGFHbHpMbkJ2Y3lBOElHVnVaQ2tnWVhKeUxuQjFjMmdvZEdocGN5NXlaV0ZrVTFaaGNtbHVkQ2dwS1R0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUdGeWNqdGNiaUFnSUNCOUxGeHVJQ0FnSUhKbFlXUlFZV05yWldSQ2IyOXNaV0Z1T2lCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lDQWdkbUZ5SUdWdVpDQTlJSFJvYVhNdWNtVmhaRlpoY21sdWRDZ3BJQ3NnZEdocGN5NXdiM01zSUdGeWNpQTlJRnRkTzF4dUlDQWdJQ0FnSUNCM2FHbHNaU0FvZEdocGN5NXdiM01nUENCbGJtUXBJR0Z5Y2k1d2RYTm9LSFJvYVhNdWNtVmhaRUp2YjJ4bFlXNG9LU2s3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJoY25JN1hHNGdJQ0FnZlN4Y2JpQWdJQ0J5WldGa1VHRmphMlZrUm14dllYUTZJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnSUNCMllYSWdaVzVrSUQwZ2RHaHBjeTV5WldGa1ZtRnlhVzUwS0NrZ0t5QjBhR2x6TG5CdmN5d2dZWEp5SUQwZ1cxMDdYRzRnSUNBZ0lDQWdJSGRvYVd4bElDaDBhR2x6TG5CdmN5QThJR1Z1WkNrZ1lYSnlMbkIxYzJnb2RHaHBjeTV5WldGa1JteHZZWFFvS1NrN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCaGNuSTdYRzRnSUNBZ2ZTeGNiaUFnSUNCeVpXRmtVR0ZqYTJWa1JHOTFZbXhsT2lCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lDQWdkbUZ5SUdWdVpDQTlJSFJvYVhNdWNtVmhaRlpoY21sdWRDZ3BJQ3NnZEdocGN5NXdiM01zSUdGeWNpQTlJRnRkTzF4dUlDQWdJQ0FnSUNCM2FHbHNaU0FvZEdocGN5NXdiM01nUENCbGJtUXBJR0Z5Y2k1d2RYTm9LSFJvYVhNdWNtVmhaRVJ2ZFdKc1pTZ3BLVHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJR0Z5Y2p0Y2JpQWdJQ0I5TEZ4dUlDQWdJSEpsWVdSUVlXTnJaV1JHYVhobFpETXlPaUJtZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0FnSUNBZ2RtRnlJR1Z1WkNBOUlIUm9hWE11Y21WaFpGWmhjbWx1ZENncElDc2dkR2hwY3k1d2IzTXNJR0Z5Y2lBOUlGdGRPMXh1SUNBZ0lDQWdJQ0IzYUdsc1pTQW9kR2hwY3k1d2IzTWdQQ0JsYm1RcElHRnljaTV3ZFhOb0tIUm9hWE11Y21WaFpFWnBlR1ZrTXpJb0tTazdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmhjbkk3WEc0Z0lDQWdmU3hjYmlBZ0lDQnlaV0ZrVUdGamEyVmtVMFpwZUdWa016STZJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnSUNCMllYSWdaVzVrSUQwZ2RHaHBjeTV5WldGa1ZtRnlhVzUwS0NrZ0t5QjBhR2x6TG5CdmN5d2dZWEp5SUQwZ1cxMDdYRzRnSUNBZ0lDQWdJSGRvYVd4bElDaDBhR2x6TG5CdmN5QThJR1Z1WkNrZ1lYSnlMbkIxYzJnb2RHaHBjeTV5WldGa1UwWnBlR1ZrTXpJb0tTazdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmhjbkk3WEc0Z0lDQWdmU3hjYmlBZ0lDQnlaV0ZrVUdGamEyVmtSbWw0WldRMk5Eb2dablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUhaaGNpQmxibVFnUFNCMGFHbHpMbkpsWVdSV1lYSnBiblFvS1NBcklIUm9hWE11Y0c5ekxDQmhjbklnUFNCYlhUdGNiaUFnSUNBZ0lDQWdkMmhwYkdVZ0tIUm9hWE11Y0c5eklEd2daVzVrS1NCaGNuSXVjSFZ6YUNoMGFHbHpMbkpsWVdSR2FYaGxaRFkwS0NrcE8xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1lYSnlPMXh1SUNBZ0lIMHNYRzRnSUNBZ2NtVmhaRkJoWTJ0bFpGTkdhWGhsWkRZME9pQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlHVnVaQ0E5SUhSb2FYTXVjbVZoWkZaaGNtbHVkQ2dwSUNzZ2RHaHBjeTV3YjNNc0lHRnljaUE5SUZ0ZE8xeHVJQ0FnSUNBZ0lDQjNhR2xzWlNBb2RHaHBjeTV3YjNNZ1BDQmxibVFwSUdGeWNpNXdkWE5vS0hSb2FYTXVjbVZoWkZOR2FYaGxaRFkwS0NrcE8xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1lYSnlPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQnphMmx3T2lCbWRXNWpkR2x2YmloMllXd3BJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlIUjVjR1VnUFNCMllXd2dKaUF3ZURjN1hHNGdJQ0FnSUNBZ0lHbG1JQ2gwZVhCbElEMDlQU0JRWW1ZdVZtRnlhVzUwS1NCM2FHbHNaU0FvZEdocGN5NWlkV1piZEdocGN5NXdiM01ySzEwZ1BpQXdlRGRtS1NCN2ZWeHVJQ0FnSUNBZ0lDQmxiSE5sSUdsbUlDaDBlWEJsSUQwOVBTQlFZbVl1UW5sMFpYTXBJSFJvYVhNdWNHOXpJRDBnZEdocGN5NXlaV0ZrVm1GeWFXNTBLQ2tnS3lCMGFHbHpMbkJ2Y3p0Y2JpQWdJQ0FnSUNBZ1pXeHpaU0JwWmlBb2RIbHdaU0E5UFQwZ1VHSm1Ma1pwZUdWa016SXBJSFJvYVhNdWNHOXpJQ3M5SURRN1hHNGdJQ0FnSUNBZ0lHVnNjMlVnYVdZZ0tIUjVjR1VnUFQwOUlGQmlaaTVHYVhobFpEWTBLU0IwYUdsekxuQnZjeUFyUFNBNE8xeHVJQ0FnSUNBZ0lDQmxiSE5sSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduVlc1cGJYQnNaVzFsYm5SbFpDQjBlWEJsT2lBbklDc2dkSGx3WlNrN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUM4dklEMDlQU0JYVWtsVVNVNUhJRDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5WEc1Y2JpQWdJQ0IzY21sMFpWUmhaem9nWm5WdVkzUnBiMjRvZEdGbkxDQjBlWEJsS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11ZDNKcGRHVldZWEpwYm5Rb0tIUmhaeUE4UENBektTQjhJSFI1Y0dVcE8xeHVJQ0FnSUgwc1hHNWNiaUFnSUNCeVpXRnNiRzlqT2lCbWRXNWpkR2x2YmlodGFXNHBJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlHeGxibWQwYUNBOUlIUm9hWE11YkdWdVozUm9JSHg4SURFMk8xeHVYRzRnSUNBZ0lDQWdJSGRvYVd4bElDaHNaVzVuZEdnZ1BDQjBhR2x6TG5CdmN5QXJJRzFwYmlrZ2JHVnVaM1JvSUNvOUlESTdYRzVjYmlBZ0lDQWdJQ0FnYVdZZ0tHeGxibWQwYUNBaFBUMGdkR2hwY3k1c1pXNW5kR2dwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFpoY2lCaWRXWWdQU0J1WlhjZ1FuVm1abVZ5S0d4bGJtZDBhQ2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TG1KMVppNWpiM0I1S0dKMVppazdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbUoxWmlBOUlHSjFaanRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11YkdWdVozUm9JRDBnYkdWdVozUm9PMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdmU3hjYmx4dUlDQWdJR1pwYm1semFEb2dablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUhSb2FYTXViR1Z1WjNSb0lEMGdkR2hwY3k1d2IzTTdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNHOXpJRDBnTUR0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVZblZtTG5Oc2FXTmxLREFzSUhSb2FYTXViR1Z1WjNSb0tUdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ2QzSnBkR1ZHYVhobFpETXlPaUJtZFc1amRHbHZiaWgyWVd3cElIdGNiaUFnSUNBZ0lDQWdkR2hwY3k1eVpXRnNiRzlqS0RRcE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG1KMVppNTNjbWwwWlZWSmJuUXpNa3hGS0haaGJDd2dkR2hwY3k1d2IzTXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxuQnZjeUFyUFNBME8xeHVJQ0FnSUgwc1hHNWNiaUFnSUNCM2NtbDBaVk5HYVhobFpETXlPaUJtZFc1amRHbHZiaWgyWVd3cElIdGNiaUFnSUNBZ0lDQWdkR2hwY3k1eVpXRnNiRzlqS0RRcE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG1KMVppNTNjbWwwWlVsdWRETXlURVVvZG1Gc0xDQjBhR2x6TG5CdmN5azdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNHOXpJQ3M5SURRN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUhkeWFYUmxSbWw0WldRMk5Eb2dablZ1WTNScGIyNG9kbUZzS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11Y21WaGJHeHZZeWc0S1R0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTVpZFdZdWQzSnBkR1ZKYm5Rek1reEZLSFpoYkNBbUlDMHhMQ0IwYUdsekxuQnZjeWs3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVZblZtTG5keWFYUmxWVWx1ZERNeVRFVW9UV0YwYUM1bWJHOXZjaWgyWVd3Z0tpQlRTRWxHVkY5U1NVZElWRjh6TWlrc0lIUm9hWE11Y0c5eklDc2dOQ2s3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjRzl6SUNzOUlEZzdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lIZHlhWFJsVTBacGVHVmtOalE2SUdaMWJtTjBhVzl1S0haaGJDa2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekxuSmxZV3hzYjJNb09DazdYRzRnSUNBZ0lDQWdJSFJvYVhNdVluVm1MbmR5YVhSbFNXNTBNekpNUlNoMllXd2dKaUF0TVN3Z2RHaHBjeTV3YjNNcE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG1KMVppNTNjbWwwWlVsdWRETXlURVVvVFdGMGFDNW1iRzl2Y2loMllXd2dLaUJUU0VsR1ZGOVNTVWRJVkY4ek1pa3NJSFJvYVhNdWNHOXpJQ3NnTkNrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11Y0c5eklDczlJRGc3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJSGR5YVhSbFZtRnlhVzUwT2lCbWRXNWpkR2x2YmloMllXd3BJSHRjYmlBZ0lDQWdJQ0FnZG1Gc0lEMGdLM1poYkR0Y2JseHVJQ0FnSUNBZ0lDQnBaaUFvZG1Gc0lEdzlJREI0TjJZcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVjbVZoYkd4dll5Z3hLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WW5WbVczUm9hWE11Y0c5ekt5dGRJRDBnZG1Gc08xeHVYRzRnSUNBZ0lDQWdJSDBnWld4elpTQnBaaUFvZG1Gc0lEdzlJREI0TTJabVppa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2RHaHBjeTV5WldGc2JHOWpLRElwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1aWRXWmJkR2hwY3k1d2IzTXJLMTBnUFNBb0tIWmhiQ0ErUGo0Z01Da2dKaUF3ZURkbUtTQjhJREI0T0RBN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxtSjFabHQwYUdsekxuQnZjeXNyWFNBOUlDZ29kbUZzSUQ0K1BpQTNLU0FtSURCNE4yWXBPMXh1WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2RtRnNJRHc5SURCNE1XWm1abVptS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxuSmxZV3hzYjJNb015azdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbUoxWmx0MGFHbHpMbkJ2Y3lzclhTQTlJQ2dvZG1Gc0lENCtQaUF3S1NBbUlEQjROMllwSUh3Z01IZzRNRHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WW5WbVczUm9hWE11Y0c5ekt5dGRJRDBnS0NoMllXd2dQajQrSURjcElDWWdNSGczWmlrZ2ZDQXdlRGd3TzF4dUlDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1aWRXWmJkR2hwY3k1d2IzTXJLMTBnUFNBb0tIWmhiQ0ErUGo0Z01UUXBJQ1lnTUhnM1ppazdYRzVjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNoMllXd2dQRDBnTUhobVptWm1abVptS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxuSmxZV3hzYjJNb05DazdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbUoxWmx0MGFHbHpMbkJ2Y3lzclhTQTlJQ2dvZG1Gc0lENCtQaUF3S1NBbUlEQjROMllwSUh3Z01IZzRNRHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WW5WbVczUm9hWE11Y0c5ekt5dGRJRDBnS0NoMllXd2dQajQrSURjcElDWWdNSGczWmlrZ2ZDQXdlRGd3TzF4dUlDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1aWRXWmJkR2hwY3k1d2IzTXJLMTBnUFNBb0tIWmhiQ0ErUGo0Z01UUXBJQ1lnTUhnM1ppa2dmQ0F3ZURnd08xeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NWlkV1piZEdocGN5NXdiM01ySzEwZ1BTQW9LSFpoYkNBK1BqNGdNakVwSUNZZ01IZzNaaWs3WEc1Y2JpQWdJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFpoY2lCd2IzTWdQU0IwYUdsekxuQnZjenRjYmlBZ0lDQWdJQ0FnSUNBZ0lIZG9hV3hsSUNoMllXd2dQajBnTUhnNE1Da2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdWNtVmhiR3h2WXlneEtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TG1KMVpsdDBhR2x6TG5CdmN5c3JYU0E5SUNoMllXd2dKaUF3ZUdabUtTQjhJREI0T0RBN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2RtRnNJQzg5SURCNE9EQTdYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxuSmxZV3hzYjJNb01TazdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbUoxWmx0MGFHbHpMbkJ2Y3lzclhTQTlJSFpoYkNCOElEQTdYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9kR2hwY3k1d2IzTWdMU0J3YjNNZ1BpQXhNQ2tnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2RIYVhabGJpQjJZWEpwYm5RZ1pHOWxjMjVjWENkMElHWnBkQ0JwYm5SdklERXdJR0o1ZEdWekp5azdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdkM0pwZEdWVFZtRnlhVzUwT2lCbWRXNWpkR2x2YmloMllXd3BJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NTNjbWwwWlZaaGNtbHVkQ2gyWVd3Z1BDQXdJRDhnTFhaaGJDQXFJRElnTFNBeElEb2dkbUZzSUNvZ01pazdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lIZHlhWFJsUW05dmJHVmhiam9nWm5WdVkzUnBiMjRvZG1Gc0tTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdWQzSnBkR1ZXWVhKcGJuUW9RbTl2YkdWaGJpaDJZV3dwS1R0Y2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnZDNKcGRHVlRkSEpwYm1jNklHWjFibU4wYVc5dUtITjBjaWtnZTF4dUlDQWdJQ0FnSUNCemRISWdQU0JUZEhKcGJtY29jM1J5S1R0Y2JpQWdJQ0FnSUNBZ2RtRnlJR0o1ZEdWeklEMGdRblZtWm1WeUxtSjVkR1ZNWlc1bmRHZ29jM1J5S1R0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTUzY21sMFpWWmhjbWx1ZENoaWVYUmxjeWs3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjbVZoYkd4dll5aGllWFJsY3lrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WW5WbUxuZHlhWFJsS0hOMGNpd2dkR2hwY3k1d2IzTXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxuQnZjeUFyUFNCaWVYUmxjenRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdkM0pwZEdWR2JHOWhkRG9nWm5WdVkzUnBiMjRvZG1Gc0tTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNtVmhiR3h2WXlnMEtUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1aWRXWXVkM0pwZEdWR2JHOWhkRXhGS0haaGJDd2dkR2hwY3k1d2IzTXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxuQnZjeUFyUFNBME8xeHVJQ0FnSUgwc1hHNWNiaUFnSUNCM2NtbDBaVVJ2ZFdKc1pUb2dablZ1WTNScGIyNG9kbUZzS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11Y21WaGJHeHZZeWc0S1R0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTVpZFdZdWQzSnBkR1ZFYjNWaWJHVk1SU2gyWVd3c0lIUm9hWE11Y0c5ektUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1d2IzTWdLejBnT0R0Y2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnZDNKcGRHVkNlWFJsY3pvZ1puVnVZM1JwYjI0b1luVm1abVZ5S1NCN1hHNGdJQ0FnSUNBZ0lIWmhjaUJzWlc0Z1BTQmlkV1ptWlhJdWJHVnVaM1JvTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbmR5YVhSbFZtRnlhVzUwS0d4bGJpazdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNtVmhiR3h2WXloc1pXNHBPMXh1SUNBZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUd4bGJqc2dhU3NyS1NCMGFHbHpMbUoxWmx0MGFHbHpMbkJ2Y3lzclhTQTlJR0oxWm1abGNsdHBYVHRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdkM0pwZEdWTlpYTnpZV2RsT2lCbWRXNWpkR2x2YmloMFlXY3NJR1p1TENCdlltb3BJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NTNjbWwwWlZSaFp5aDBZV2NzSUZCaVppNUNlWFJsY3lrN1hHNWNiaUFnSUNBZ0lDQWdkR2hwY3k1d2IzTXJLenNnTHk4Z2NtVnpaWEoyWlNBeElHSjVkR1VnWm05eUlITm9iM0owSUcxbGMzTmhaMlVnYkdWdVozUm9YRzVjYmlBZ0lDQWdJQ0FnTHk4Z2QzSnBkR1VnZEdobElHMWxjM05oWjJVZ1pHbHlaV04wYkhrZ2RHOGdkR2hsSUdKMVptWmxjaUJoYm1RZ2MyVmxJR2h2ZHlCdGRXTm9JSGRoY3lCM2NtbDBkR1Z1WEc0Z0lDQWdJQ0FnSUhaaGNpQnpkR0Z5ZEZCdmN5QTlJSFJvYVhNdWNHOXpPMXh1SUNBZ0lDQWdJQ0JtYmlodlltb3NJSFJvYVhNcE8xeHVJQ0FnSUNBZ0lDQjJZWElnYkdWdUlEMGdkR2hwY3k1d2IzTWdMU0J6ZEdGeWRGQnZjenRjYmx4dUlDQWdJQ0FnSUNCMllYSWdkbUZ5YVc1MFRHVnVJRDFjYmlBZ0lDQWdJQ0FnSUNBZ0lHeGxiaUE4UFNBd2VEZG1JRDhnTVNBNlhHNGdJQ0FnSUNBZ0lDQWdJQ0JzWlc0Z1BEMGdNSGd6Wm1abUlEOGdNaUE2WEc0Z0lDQWdJQ0FnSUNBZ0lDQnNaVzRnUEQwZ01IZ3habVptWm1ZZ1B5QXpJRHBjYmlBZ0lDQWdJQ0FnSUNBZ0lHeGxiaUE4UFNBd2VHWm1abVptWm1ZZ1B5QTBJRG9nVFdGMGFDNWpaV2xzS0UxaGRHZ3ViRzluS0d4bGJpa2dMeUFvVFdGMGFDNU1UaklnS2lBM0tTazdYRzVjYmlBZ0lDQWdJQ0FnTHk4Z2FXWWdNU0JpZVhSbElHbHpiaWQwSUdWdWIzVm5hQ0JtYjNJZ1pXNWpiMlJwYm1jZ2JXVnpjMkZuWlNCc1pXNW5kR2dzSUhOb2FXWjBJSFJvWlNCa1lYUmhJSFJ2SUhSb1pTQnlhV2RvZEZ4dUlDQWdJQ0FnSUNCcFppQW9kbUZ5YVc1MFRHVnVJRDRnTVNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NXlaV0ZzYkc5aktIWmhjbWx1ZEV4bGJpQXRJREVwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdabTl5SUNoMllYSWdhU0E5SUhSb2FYTXVjRzl6SUMwZ01Uc2dhU0ErUFNCemRHRnlkRkJ2Y3pzZ2FTMHRLU0IwYUdsekxtSjFabHRwSUNzZ2RtRnlhVzUwVEdWdUlDMGdNVjBnUFNCMGFHbHpMbUoxWmx0cFhUdGNiaUFnSUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0FnSUM4dklHWnBibUZzYkhrc0lIZHlhWFJsSUhSb1pTQnRaWE56WVdkbElHeGxibWQwYUNCcGJpQjBhR1VnY21WelpYSjJaV1FnY0d4aFkyVWdZVzVrSUhKbGMzUnZjbVVnZEdobElIQnZjMmwwYVc5dVhHNGdJQ0FnSUNBZ0lIUm9hWE11Y0c5eklEMGdjM1JoY25SUWIzTWdMU0F4TzF4dUlDQWdJQ0FnSUNCMGFHbHpMbmR5YVhSbFZtRnlhVzUwS0d4bGJpazdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNHOXpJQ3M5SUd4bGJqdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ2QzSnBkR1ZRWVdOclpXUldZWEpwYm5RNklDQWdablZ1WTNScGIyNG9kR0ZuTENCaGNuSXBJSHNnZEdocGN5NTNjbWwwWlUxbGMzTmhaMlVvZEdGbkxDQjNjbWwwWlZCaFkydGxaRlpoY21sdWRDd2dZWEp5S1RzZ0lDQjlMRnh1SUNBZ0lIZHlhWFJsVUdGamEyVmtVMVpoY21sdWREb2dJR1oxYm1OMGFXOXVLSFJoWnl3Z1lYSnlLU0I3SUhSb2FYTXVkM0pwZEdWTlpYTnpZV2RsS0hSaFp5d2dkM0pwZEdWUVlXTnJaV1JUVm1GeWFXNTBMQ0JoY25JcE95QWdmU3hjYmlBZ0lDQjNjbWwwWlZCaFkydGxaRUp2YjJ4bFlXNDZJQ0JtZFc1amRHbHZiaWgwWVdjc0lHRnljaWtnZXlCMGFHbHpMbmR5YVhSbFRXVnpjMkZuWlNoMFlXY3NJSGR5YVhSbFVHRmphMlZrUW05dmJHVmhiaXdnWVhKeUtUc2dJSDBzWEc0Z0lDQWdkM0pwZEdWUVlXTnJaV1JHYkc5aGREb2dJQ0FnWm5WdVkzUnBiMjRvZEdGbkxDQmhjbklwSUhzZ2RHaHBjeTUzY21sMFpVMWxjM05oWjJVb2RHRm5MQ0IzY21sMFpWQmhZMnRsWkVac2IyRjBMQ0JoY25JcE95QWdJQ0I5TEZ4dUlDQWdJSGR5YVhSbFVHRmphMlZrUkc5MVlteGxPaUFnSUdaMWJtTjBhVzl1S0hSaFp5d2dZWEp5S1NCN0lIUm9hWE11ZDNKcGRHVk5aWE56WVdkbEtIUmhaeXdnZDNKcGRHVlFZV05yWldSRWIzVmliR1VzSUdGeWNpazdJQ0FnZlN4Y2JpQWdJQ0IzY21sMFpWQmhZMnRsWkVacGVHVmtNekk2SUNCbWRXNWpkR2x2YmloMFlXY3NJR0Z5Y2lrZ2V5QjBhR2x6TG5keWFYUmxUV1Z6YzJGblpTaDBZV2NzSUhkeWFYUmxVR0ZqYTJWa1JtbDRaV1F6TWl3Z1lYSnlLVHNnSUgwc1hHNGdJQ0FnZDNKcGRHVlFZV05yWldSVFJtbDRaV1F6TWpvZ1puVnVZM1JwYjI0b2RHRm5MQ0JoY25JcElIc2dkR2hwY3k1M2NtbDBaVTFsYzNOaFoyVW9kR0ZuTENCM2NtbDBaVkJoWTJ0bFpGTkdhWGhsWkRNeUxDQmhjbklwT3lCOUxGeHVJQ0FnSUhkeWFYUmxVR0ZqYTJWa1JtbDRaV1EyTkRvZ0lHWjFibU4wYVc5dUtIUmhaeXdnWVhKeUtTQjdJSFJvYVhNdWQzSnBkR1ZOWlhOellXZGxLSFJoWnl3Z2QzSnBkR1ZRWVdOclpXUkdhWGhsWkRZMExDQmhjbklwT3lBZ2ZTeGNiaUFnSUNCM2NtbDBaVkJoWTJ0bFpGTkdhWGhsWkRZME9pQm1kVzVqZEdsdmJpaDBZV2NzSUdGeWNpa2dleUIwYUdsekxuZHlhWFJsVFdWemMyRm5aU2gwWVdjc0lIZHlhWFJsVUdGamEyVmtVMFpwZUdWa05qUXNJR0Z5Y2lrN0lIMHNYRzVjYmlBZ0lDQjNjbWwwWlVKNWRHVnpSbWxsYkdRNklHWjFibU4wYVc5dUtIUmhaeXdnWW5WbVptVnlLU0I3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVkM0pwZEdWVVlXY29kR0ZuTENCUVltWXVRbmwwWlhNcE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG5keWFYUmxRbmwwWlhNb1luVm1abVZ5S1R0Y2JpQWdJQ0I5TEZ4dUlDQWdJSGR5YVhSbFJtbDRaV1F6TWtacFpXeGtPaUJtZFc1amRHbHZiaWgwWVdjc0lIWmhiQ2tnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbmR5YVhSbFZHRm5LSFJoWnl3Z1VHSm1Ma1pwZUdWa016SXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxuZHlhWFJsUm1sNFpXUXpNaWgyWVd3cE8xeHVJQ0FnSUgwc1hHNGdJQ0FnZDNKcGRHVlRSbWw0WldRek1rWnBaV3hrT2lCbWRXNWpkR2x2YmloMFlXY3NJSFpoYkNrZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TG5keWFYUmxWR0ZuS0hSaFp5d2dVR0ptTGtacGVHVmtNeklwTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbmR5YVhSbFUwWnBlR1ZrTXpJb2RtRnNLVHRjYmlBZ0lDQjlMRnh1SUNBZ0lIZHlhWFJsUm1sNFpXUTJORVpwWld4a09pQm1kVzVqZEdsdmJpaDBZV2NzSUhaaGJDa2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekxuZHlhWFJsVkdGbktIUmhaeXdnVUdKbUxrWnBlR1ZrTmpRcE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG5keWFYUmxSbWw0WldRMk5DaDJZV3dwTzF4dUlDQWdJSDBzWEc0Z0lDQWdkM0pwZEdWVFJtbDRaV1EyTkVacFpXeGtPaUJtZFc1amRHbHZiaWgwWVdjc0lIWmhiQ2tnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbmR5YVhSbFZHRm5LSFJoWnl3Z1VHSm1Ma1pwZUdWa05qUXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxuZHlhWFJsVTBacGVHVmtOalFvZG1Gc0tUdGNiaUFnSUNCOUxGeHVJQ0FnSUhkeWFYUmxWbUZ5YVc1MFJtbGxiR1E2SUdaMWJtTjBhVzl1S0hSaFp5d2dkbUZzS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11ZDNKcGRHVlVZV2NvZEdGbkxDQlFZbVl1Vm1GeWFXNTBLVHRjYmlBZ0lDQWdJQ0FnZEdocGN5NTNjbWwwWlZaaGNtbHVkQ2gyWVd3cE8xeHVJQ0FnSUgwc1hHNGdJQ0FnZDNKcGRHVlRWbUZ5YVc1MFJtbGxiR1E2SUdaMWJtTjBhVzl1S0hSaFp5d2dkbUZzS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11ZDNKcGRHVlVZV2NvZEdGbkxDQlFZbVl1Vm1GeWFXNTBLVHRjYmlBZ0lDQWdJQ0FnZEdocGN5NTNjbWwwWlZOV1lYSnBiblFvZG1Gc0tUdGNiaUFnSUNCOUxGeHVJQ0FnSUhkeWFYUmxVM1J5YVc1blJtbGxiR1E2SUdaMWJtTjBhVzl1S0hSaFp5d2djM1J5S1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11ZDNKcGRHVlVZV2NvZEdGbkxDQlFZbVl1UW5sMFpYTXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxuZHlhWFJsVTNSeWFXNW5LSE4wY2lrN1hHNGdJQ0FnZlN4Y2JpQWdJQ0IzY21sMFpVWnNiMkYwUm1sbGJHUTZJR1oxYm1OMGFXOXVLSFJoWnl3Z2RtRnNLU0I3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVkM0pwZEdWVVlXY29kR0ZuTENCUVltWXVSbWw0WldRek1pazdYRzRnSUNBZ0lDQWdJSFJvYVhNdWQzSnBkR1ZHYkc5aGRDaDJZV3dwTzF4dUlDQWdJSDBzWEc0Z0lDQWdkM0pwZEdWRWIzVmliR1ZHYVdWc1pEb2dablZ1WTNScGIyNG9kR0ZuTENCMllXd3BJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NTNjbWwwWlZSaFp5aDBZV2NzSUZCaVppNUdhWGhsWkRZMEtUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1M2NtbDBaVVJ2ZFdKc1pTaDJZV3dwTzF4dUlDQWdJSDBzWEc0Z0lDQWdkM0pwZEdWQ2IyOXNaV0Z1Um1sbGJHUTZJR1oxYm1OMGFXOXVLSFJoWnl3Z2RtRnNLU0I3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVkM0pwZEdWV1lYSnBiblJHYVdWc1pDaDBZV2NzSUVKdmIyeGxZVzRvZG1Gc0tTazdYRzRnSUNBZ2ZWeHVmVHRjYmx4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUldZWEpwYm5Rb1lYSnlMQ0J3WW1ZcElDQWdleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsVm1GeWFXNTBLR0Z5Y2x0cFhTazdJQ0FnZlZ4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUlRWbUZ5YVc1MEtHRnljaXdnY0dKbUtTQWdleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsVTFaaGNtbHVkQ2hoY25KYmFWMHBPeUFnZlZ4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUkdiRzloZENoaGNuSXNJSEJpWmlrZ0lDQWdleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsUm14dllYUW9ZWEp5VzJsZEtUc2dJQ0FnZlZ4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUkViM1ZpYkdVb1lYSnlMQ0J3WW1ZcElDQWdleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsUkc5MVlteGxLR0Z5Y2x0cFhTazdJQ0FnZlZ4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUkNiMjlzWldGdUtHRnljaXdnY0dKbUtTQWdleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsUW05dmJHVmhiaWhoY25KYmFWMHBPeUFnZlZ4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUkdhWGhsWkRNeUtHRnljaXdnY0dKbUtTQWdleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsUm1sNFpXUXpNaWhoY25KYmFWMHBPeUFnZlZ4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUlRSbWw0WldRek1paGhjbklzSUhCaVppa2dleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsVTBacGVHVmtNeklvWVhKeVcybGRLVHNnZlZ4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUkdhWGhsWkRZMEtHRnljaXdnY0dKbUtTQWdleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsUm1sNFpXUTJOQ2hoY25KYmFWMHBPeUFnZlZ4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUlRSbWw0WldRMk5DaGhjbklzSUhCaVppa2dleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsVTBacGVHVmtOalFvWVhKeVcybGRLVHNnZlZ4dUlsMTkiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG5cbmZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG59XG5cblBvaW50LnByb3RvdHlwZSA9IHtcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpOyB9LFxuXG4gICAgYWRkOiAgICAgZnVuY3Rpb24ocCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQocCk7ICAgICB9LFxuICAgIHN1YjogICAgIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fc3ViKHApOyAgICAgfSxcbiAgICBtdWx0OiAgICBmdW5jdGlvbihrKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX211bHQoayk7ICAgIH0sXG4gICAgZGl2OiAgICAgZnVuY3Rpb24oaykgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXYoayk7ICAgICB9LFxuICAgIHJvdGF0ZTogIGZ1bmN0aW9uKGEpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm90YXRlKGEpOyAgfSxcbiAgICBtYXRNdWx0OiBmdW5jdGlvbihtKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX21hdE11bHQobSk7IH0sXG4gICAgdW5pdDogICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3VuaXQoKTsgfSxcbiAgICBwZXJwOiAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcGVycCgpOyB9LFxuICAgIHJvdW5kOiAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpOyB9LFxuXG4gICAgbWFnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gcC54ICYmXG4gICAgICAgICAgICAgICB0aGlzLnkgPT09IHAueTtcbiAgICB9LFxuXG4gICAgZGlzdDogZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdFNxcihwKSk7XG4gICAgfSxcblxuICAgIGRpc3RTcXI6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdmFyIGR4ID0gcC54IC0gdGhpcy54LFxuICAgICAgICAgICAgZHkgPSBwLnkgLSB0aGlzLnk7XG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9LFxuXG4gICAgYW5nbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XG4gICAgfSxcblxuICAgIGFuZ2xlVG86IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55IC0gYi55LCB0aGlzLnggLSBiLngpO1xuICAgIH0sXG5cbiAgICBhbmdsZVdpdGg6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5nbGVXaXRoU2VwKGIueCwgYi55KTtcbiAgICB9LFxuXG4gICAgLy8gRmluZCB0aGUgYW5nbGUgb2YgdGhlIHR3byB2ZWN0b3JzLCBzb2x2aW5nIHRoZSBmb3JtdWxhIGZvciB0aGUgY3Jvc3MgcHJvZHVjdCBhIHggYiA9IHxhfHxifHNpbijOuCkgZm9yIM64LlxuICAgIGFuZ2xlV2l0aFNlcDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMihcbiAgICAgICAgICAgIHRoaXMueCAqIHkgLSB0aGlzLnkgKiB4LFxuICAgICAgICAgICAgdGhpcy54ICogeCArIHRoaXMueSAqIHkpO1xuICAgIH0sXG5cbiAgICBfbWF0TXVsdDogZnVuY3Rpb24obSkge1xuICAgICAgICB2YXIgeCA9IG1bMF0gKiB0aGlzLnggKyBtWzFdICogdGhpcy55LFxuICAgICAgICAgICAgeSA9IG1bMl0gKiB0aGlzLnggKyBtWzNdICogdGhpcy55O1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2FkZDogZnVuY3Rpb24ocCkge1xuICAgICAgICB0aGlzLnggKz0gcC54O1xuICAgICAgICB0aGlzLnkgKz0gcC55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3N1YjogZnVuY3Rpb24ocCkge1xuICAgICAgICB0aGlzLnggLT0gcC54O1xuICAgICAgICB0aGlzLnkgLT0gcC55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX211bHQ6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdGhpcy54ICo9IGs7XG4gICAgICAgIHRoaXMueSAqPSBrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2RpdjogZnVuY3Rpb24oaykge1xuICAgICAgICB0aGlzLnggLz0gaztcbiAgICAgICAgdGhpcy55IC89IGs7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfdW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2Rpdih0aGlzLm1hZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9wZXJwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgICAgIHRoaXMueSA9IHRoaXMueDtcbiAgICAgICAgdGhpcy54ID0gLXk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcm90YXRlOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgeCA9IGNvcyAqIHRoaXMueCAtIHNpbiAqIHRoaXMueSxcbiAgICAgICAgICAgIHkgPSBzaW4gKiB0aGlzLnggKyBjb3MgKiB0aGlzLnk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcm91bmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XG4gICAgICAgIHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuLy8gY29uc3RydWN0cyBQb2ludCBmcm9tIGFuIGFycmF5IGlmIG5lY2Vzc2FyeVxuUG9pbnQuY29udmVydCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChhWzBdLCBhWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuTXV0YXRpb25PYnNlcnZlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgdmFyIHF1ZXVlID0gW107XG5cbiAgICBpZiAoY2FuTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgICB2YXIgaGlkZGVuRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHF1ZXVlTGlzdCA9IHF1ZXVlLnNsaWNlKCk7XG4gICAgICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcXVldWVMaXN0LmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGhpZGRlbkRpdiwgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgaWYgKCFxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBoaWRkZW5EaXYuc2V0QXR0cmlidXRlKCd5ZXMnLCAnbm8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsIi8qIVxuICogc3RyaXAtY29tbWVudHMgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3N0cmlwLWNvbW1lbnRzPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBKb24gU2NobGlua2VydCwgY29udHJpYnV0b3JzLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWMnO1xuXG52YXIgcmVCbG9jayA9ICdcXFxcL1xcXFwqJztcbnZhciByZUJsb2NrSWdub3JlID0gJ1xcXFwvXFxcXCooPyFcXFxcKj9cXFxcISknO1xudmFyIHJlQmxvY2tFbmQgPSAnKC58W1xcXFxyXFxcXG5dfFxcXFxuKSo/XFxcXCpcXFxcL1xcXFxuP1xcXFxuPyc7XG52YXIgcmVMaW5lID0gLyhefFteXFxTXFxuXSkoPzpcXC9cXC8pKFtcXHNcXFNdKz8pJC9nbTtcbnZhciByZUxpbmVJZ25vcmUgPSAvKF58W15cXFNcXG5dKSg/OlxcL1xcL1teIV0pKFtcXHNcXFNdKz8pJC9nbTtcblxuXG4vKipcbiAqIFN0cmlwIGFsbCBjb21tZW50c1xuICpcbiAqIHslPSBkb2NzKFwic3RyaXBcIikgJX1cbiAqXG4gKiBAcGFyYW0gICB7U3RyaW5nfSBgc3RyYCAgZmlsZSBjb250ZW50cyBvciBzdHJpbmcgdG8gc3RyaXAuXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBgb3B0c2AgIG9wdGlvbnMgYXJlIHBhc3NlZCB0byBgLmJsb2NrYCwgYW5kIGAubGluZWBcbiAqIEByZXR1cm4gIHtTdHJpbmd9IFN0cmluZyB3aXRob3V0IGNvbW1lbnRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgc3RyaXAgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0ciwgb3B0cykge1xuICByZXR1cm4gc3RyID8gc3RyaXAuYmxvY2soc3RyaXAubGluZShzdHIsIG9wdHMpLCBvcHRzKSA6ICcnO1xufTtcblxuXG4vKipcbiAqIFN0cmlwIG9ubHkgYmxvY2sgY29tbWVudHMsIG9wdGlvbmFsbHkgbGVhdmluZyBwcm90ZWN0ZWQgY29tbWVudHNcbiAqIChlLmcuIGAvKiFgKSBpbnRhY3QuXG4gKlxuICogeyU9IGRvY3MoXCJibG9ja1wiKSAlfVxuICpcbiAqIEBwYXJhbSAgIHtTdHJpbmd9IGBzdHJgICBmaWxlIGNvbnRlbnQgb3Igc3RyaW5nIHRvIHN0cmlwIHRvXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBgb3B0c2AgIGlmIGBzYWZlOnRydWVgLCBzdHJpcCBvbmx5IGNvbW1lbnRzIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGggYC8qIWAgb3IgYC8qKiFgXG4gKiBAcmV0dXJuICB7U3RyaW5nfSBTdHJpbmcgd2l0aG91dCBibG9jayBjb21tZW50cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuc3RyaXAuYmxvY2sgPSBmdW5jdGlvbihzdHIsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHZhciByZSA9IG5ldyBSZWdFeHAocmVCbG9jayArIHJlQmxvY2tFbmQsICdnbScpO1xuICBpZihvcHRzLnNhZmUpIHtcbiAgICByZSA9IG5ldyBSZWdFeHAocmVCbG9ja0lnbm9yZSArIHJlQmxvY2tFbmQsICdnbScpO1xuICB9XG4gIHJldHVybiBzdHIgPyBzdHIucmVwbGFjZShyZSwgJycpIDogJyc7XG59O1xuXG5cbi8qKlxuICogU3RyaXAgb25seSBsaW5lIGNvbW1lbnRzXG4gKlxuICogeyU9IGRvY3MoXCJsaW5lXCIpICV9XG4gKlxuICogQHBhcmFtICAge1N0cmluZ30gYHN0cmAgIGZpbGUgY29udGVudCBvciBzdHJpbmcgdG8gc3RyaXAgdG9cbiAqIEBwYXJhbSAgIHtPYmplY3R9IGBvcHRzYCAgaWYgYHNhZmU6dHJ1ZWAsIHN0cmlwIGFsbCB0aGF0IG5vdCBzdGFydHMgd2l0aCBgLy8hYFxuICogQHJldHVybiAge1N0cmluZ30gU3RyaW5nIHdpdGhvdXQgbGluZSBjb21tZW50cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuc3RyaXAubGluZSA9IGZ1bmN0aW9uKHN0ciwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIHJlID0gcmVMaW5lO1xuICBpZihvcHRzLnNhZmUpIHtcbiAgICByZSA9IHJlTGluZUlnbm9yZTtcbiAgfVxuICByZXR1cm4gc3RyID8gc3RyLnJlcGxhY2UocmUsICcnKSA6ICcnO1xufTtcbiIsIiFmdW5jdGlvbigpIHtcbiAgdmFyIHRvcG9qc29uID0ge1xuICAgIHZlcnNpb246IFwiMS42LjE5XCIsXG4gICAgbWVzaDogZnVuY3Rpb24odG9wb2xvZ3kpIHsgcmV0dXJuIG9iamVjdCh0b3BvbG9neSwgbWVzaEFyY3MuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7IH0sXG4gICAgbWVzaEFyY3M6IG1lc2hBcmNzLFxuICAgIG1lcmdlOiBmdW5jdGlvbih0b3BvbG9neSkgeyByZXR1cm4gb2JqZWN0KHRvcG9sb2d5LCBtZXJnZUFyY3MuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7IH0sXG4gICAgbWVyZ2VBcmNzOiBtZXJnZUFyY3MsXG4gICAgZmVhdHVyZTogZmVhdHVyZU9yQ29sbGVjdGlvbixcbiAgICBuZWlnaGJvcnM6IG5laWdoYm9ycyxcbiAgICBwcmVzaW1wbGlmeTogcHJlc2ltcGxpZnlcbiAgfTtcblxuICBmdW5jdGlvbiBzdGl0Y2hBcmNzKHRvcG9sb2d5LCBhcmNzKSB7XG4gICAgdmFyIHN0aXRjaGVkQXJjcyA9IHt9LFxuICAgICAgICBmcmFnbWVudEJ5U3RhcnQgPSB7fSxcbiAgICAgICAgZnJhZ21lbnRCeUVuZCA9IHt9LFxuICAgICAgICBmcmFnbWVudHMgPSBbXSxcbiAgICAgICAgZW1wdHlJbmRleCA9IC0xO1xuXG4gICAgLy8gU3RpdGNoIGVtcHR5IGFyY3MgZmlyc3QsIHNpbmNlIHRoZXkgbWF5IGJlIHN1YnN1bWVkIGJ5IG90aGVyIGFyY3MuXG4gICAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGksIGopIHtcbiAgICAgIHZhciBhcmMgPSB0b3BvbG9neS5hcmNzW2kgPCAwID8gfmkgOiBpXSwgdDtcbiAgICAgIGlmIChhcmMubGVuZ3RoIDwgMyAmJiAhYXJjWzFdWzBdICYmICFhcmNbMV1bMV0pIHtcbiAgICAgICAgdCA9IGFyY3NbKytlbXB0eUluZGV4XSwgYXJjc1tlbXB0eUluZGV4XSA9IGksIGFyY3Nbal0gPSB0O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciBlID0gZW5kcyhpKSxcbiAgICAgICAgICBzdGFydCA9IGVbMF0sXG4gICAgICAgICAgZW5kID0gZVsxXSxcbiAgICAgICAgICBmLCBnO1xuXG4gICAgICBpZiAoZiA9IGZyYWdtZW50QnlFbmRbc3RhcnRdKSB7XG4gICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2YuZW5kXTtcbiAgICAgICAgZi5wdXNoKGkpO1xuICAgICAgICBmLmVuZCA9IGVuZDtcbiAgICAgICAgaWYgKGcgPSBmcmFnbWVudEJ5U3RhcnRbZW5kXSkge1xuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZy5zdGFydF07XG4gICAgICAgICAgdmFyIGZnID0gZyA9PT0gZiA/IGYgOiBmLmNvbmNhdChnKTtcbiAgICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZmcuc3RhcnQgPSBmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZmcuZW5kID0gZy5lbmRdID0gZmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmLmVuZF0gPSBmO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGYgPSBmcmFnbWVudEJ5U3RhcnRbZW5kXSkge1xuICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdO1xuICAgICAgICBmLnVuc2hpZnQoaSk7XG4gICAgICAgIGYuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgaWYgKGcgPSBmcmFnbWVudEJ5RW5kW3N0YXJ0XSkge1xuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2cuZW5kXTtcbiAgICAgICAgICB2YXIgZ2YgPSBnID09PSBmID8gZiA6IGcuY29uY2F0KGYpO1xuICAgICAgICAgIGZyYWdtZW50QnlTdGFydFtnZi5zdGFydCA9IGcuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtnZi5lbmQgPSBmLmVuZF0gPSBnZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kXSA9IGY7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGYgPSBbaV07XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0ID0gc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmLmVuZCA9IGVuZF0gPSBmO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZW5kcyhpKSB7XG4gICAgICB2YXIgYXJjID0gdG9wb2xvZ3kuYXJjc1tpIDwgMCA/IH5pIDogaV0sIHAwID0gYXJjWzBdLCBwMTtcbiAgICAgIGlmICh0b3BvbG9neS50cmFuc2Zvcm0pIHAxID0gWzAsIDBdLCBhcmMuZm9yRWFjaChmdW5jdGlvbihkcCkgeyBwMVswXSArPSBkcFswXSwgcDFbMV0gKz0gZHBbMV07IH0pO1xuICAgICAgZWxzZSBwMSA9IGFyY1thcmMubGVuZ3RoIC0gMV07XG4gICAgICByZXR1cm4gaSA8IDAgPyBbcDEsIHAwXSA6IFtwMCwgcDFdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZsdXNoKGZyYWdtZW50QnlFbmQsIGZyYWdtZW50QnlTdGFydCkge1xuICAgICAgZm9yICh2YXIgayBpbiBmcmFnbWVudEJ5RW5kKSB7XG4gICAgICAgIHZhciBmID0gZnJhZ21lbnRCeUVuZFtrXTtcbiAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XTtcbiAgICAgICAgZGVsZXRlIGYuc3RhcnQ7XG4gICAgICAgIGRlbGV0ZSBmLmVuZDtcbiAgICAgICAgZi5mb3JFYWNoKGZ1bmN0aW9uKGkpIHsgc3RpdGNoZWRBcmNzW2kgPCAwID8gfmkgOiBpXSA9IDE7IH0pO1xuICAgICAgICBmcmFnbWVudHMucHVzaChmKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmbHVzaChmcmFnbWVudEJ5RW5kLCBmcmFnbWVudEJ5U3RhcnQpO1xuICAgIGZsdXNoKGZyYWdtZW50QnlTdGFydCwgZnJhZ21lbnRCeUVuZCk7XG4gICAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHsgaWYgKCFzdGl0Y2hlZEFyY3NbaSA8IDAgPyB+aSA6IGldKSBmcmFnbWVudHMucHVzaChbaV0pOyB9KTtcblxuICAgIHJldHVybiBmcmFnbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBtZXNoQXJjcyh0b3BvbG9neSwgbywgZmlsdGVyKSB7XG4gICAgdmFyIGFyY3MgPSBbXTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGdlb21zQnlBcmMgPSBbXSxcbiAgICAgICAgICBnZW9tO1xuXG4gICAgICBmdW5jdGlvbiBhcmMoaSkge1xuICAgICAgICB2YXIgaiA9IGkgPCAwID8gfmkgOiBpO1xuICAgICAgICAoZ2VvbXNCeUFyY1tqXSB8fCAoZ2VvbXNCeUFyY1tqXSA9IFtdKSkucHVzaCh7aTogaSwgZzogZ2VvbX0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsaW5lKGFyY3MpIHtcbiAgICAgICAgYXJjcy5mb3JFYWNoKGFyYyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBvbHlnb24oYXJjcykge1xuICAgICAgICBhcmNzLmZvckVhY2gobGluZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICAgICAgaWYgKG8udHlwZSA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIikgby5nZW9tZXRyaWVzLmZvckVhY2goZ2VvbWV0cnkpO1xuICAgICAgICBlbHNlIGlmIChvLnR5cGUgaW4gZ2VvbWV0cnlUeXBlKSBnZW9tID0gbywgZ2VvbWV0cnlUeXBlW28udHlwZV0oby5hcmNzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGdlb21ldHJ5VHlwZSA9IHtcbiAgICAgICAgTGluZVN0cmluZzogbGluZSxcbiAgICAgICAgTXVsdGlMaW5lU3RyaW5nOiBwb2x5Z29uLFxuICAgICAgICBQb2x5Z29uOiBwb2x5Z29uLFxuICAgICAgICBNdWx0aVBvbHlnb246IGZ1bmN0aW9uKGFyY3MpIHsgYXJjcy5mb3JFYWNoKHBvbHlnb24pOyB9XG4gICAgICB9O1xuXG4gICAgICBnZW9tZXRyeShvKTtcblxuICAgICAgZ2VvbXNCeUFyYy5mb3JFYWNoKGFyZ3VtZW50cy5sZW5ndGggPCAzXG4gICAgICAgICAgPyBmdW5jdGlvbihnZW9tcykgeyBhcmNzLnB1c2goZ2VvbXNbMF0uaSk7IH1cbiAgICAgICAgICA6IGZ1bmN0aW9uKGdlb21zKSB7IGlmIChmaWx0ZXIoZ2VvbXNbMF0uZywgZ2VvbXNbZ2VvbXMubGVuZ3RoIC0gMV0uZykpIGFyY3MucHVzaChnZW9tc1swXS5pKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdG9wb2xvZ3kuYXJjcy5sZW5ndGg7IGkgPCBuOyArK2kpIGFyY3MucHVzaChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge3R5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsIGFyY3M6IHN0aXRjaEFyY3ModG9wb2xvZ3ksIGFyY3MpfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlQXJjcyh0b3BvbG9neSwgb2JqZWN0cykge1xuICAgIHZhciBwb2x5Z29uc0J5QXJjID0ge30sXG4gICAgICAgIHBvbHlnb25zID0gW10sXG4gICAgICAgIGNvbXBvbmVudHMgPSBbXTtcblxuICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgICBpZiAoby50eXBlID09PSBcIlBvbHlnb25cIikgcmVnaXN0ZXIoby5hcmNzKTtcbiAgICAgIGVsc2UgaWYgKG8udHlwZSA9PT0gXCJNdWx0aVBvbHlnb25cIikgby5hcmNzLmZvckVhY2gocmVnaXN0ZXIpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXIocG9seWdvbikge1xuICAgICAgcG9seWdvbi5mb3JFYWNoKGZ1bmN0aW9uKHJpbmcpIHtcbiAgICAgICAgcmluZy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgICAgIChwb2x5Z29uc0J5QXJjW2FyYyA9IGFyYyA8IDAgPyB+YXJjIDogYXJjXSB8fCAocG9seWdvbnNCeUFyY1thcmNdID0gW10pKS5wdXNoKHBvbHlnb24pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcG9seWdvbnMucHVzaChwb2x5Z29uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlcmlvcihyaW5nKSB7XG4gICAgICByZXR1cm4gY2FydGVzaWFuUmluZ0FyZWEob2JqZWN0KHRvcG9sb2d5LCB7dHlwZTogXCJQb2x5Z29uXCIsIGFyY3M6IFtyaW5nXX0pLmNvb3JkaW5hdGVzWzBdKSA+IDA7IC8vIFRPRE8gYWxsb3cgc3BoZXJpY2FsP1xuICAgIH1cblxuICAgIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgICAgaWYgKCFwb2x5Z29uLl8pIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IFtdLFxuICAgICAgICAgICAgbmVpZ2hib3JzID0gW3BvbHlnb25dO1xuICAgICAgICBwb2x5Z29uLl8gPSAxO1xuICAgICAgICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgd2hpbGUgKHBvbHlnb24gPSBuZWlnaGJvcnMucG9wKCkpIHtcbiAgICAgICAgICBjb21wb25lbnQucHVzaChwb2x5Z29uKTtcbiAgICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgICAgICAgcmluZy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgICAgICAgICBwb2x5Z29uc0J5QXJjW2FyYyA8IDAgPyB+YXJjIDogYXJjXS5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBvbHlnb24uXykge1xuICAgICAgICAgICAgICAgICAgcG9seWdvbi5fID0gMTtcbiAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKHBvbHlnb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgICBkZWxldGUgcG9seWdvbi5fO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTXVsdGlQb2x5Z29uXCIsXG4gICAgICBhcmNzOiBjb21wb25lbnRzLm1hcChmdW5jdGlvbihwb2x5Z29ucykge1xuICAgICAgICB2YXIgYXJjcyA9IFtdO1xuXG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIGV4dGVyaW9yICh1bmlxdWUpIGFyY3MuXG4gICAgICAgIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgICAgICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nKSB7XG4gICAgICAgICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgICAgICAgIGlmIChwb2x5Z29uc0J5QXJjW2FyYyA8IDAgPyB+YXJjIDogYXJjXS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgYXJjcy5wdXNoKGFyYyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTdGl0Y2ggdGhlIGFyY3MgaW50byBvbmUgb3IgbW9yZSByaW5ncy5cbiAgICAgICAgYXJjcyA9IHN0aXRjaEFyY3ModG9wb2xvZ3ksIGFyY3MpO1xuXG4gICAgICAgIC8vIElmIG1vcmUgdGhhbiBvbmUgcmluZyBpcyByZXR1cm5lZCxcbiAgICAgICAgLy8gYXQgbW9zdCBvbmUgb2YgdGhlc2UgcmluZ3MgY2FuIGJlIHRoZSBleHRlcmlvcjtcbiAgICAgICAgLy8gdGhpcyBleHRlcmlvciByaW5nIGhhcyB0aGUgc2FtZSB3aW5kaW5nIG9yZGVyXG4gICAgICAgIC8vIGFzIGFueSBleHRlcmlvciByaW5nIGluIHRoZSBvcmlnaW5hbCBwb2x5Z29ucy5cbiAgICAgICAgaWYgKChuID0gYXJjcy5sZW5ndGgpID4gMSkge1xuICAgICAgICAgIHZhciBzZ24gPSBleHRlcmlvcihwb2x5Z29uc1swXVswXSk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHQ7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChzZ24gPT09IGV4dGVyaW9yKGFyY3NbaV0pKSB7XG4gICAgICAgICAgICAgIHQgPSBhcmNzWzBdLCBhcmNzWzBdID0gYXJjc1tpXSwgYXJjc1tpXSA9IHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcmNzO1xuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmVhdHVyZU9yQ29sbGVjdGlvbih0b3BvbG9neSwgbykge1xuICAgIHJldHVybiBvLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIgPyB7XG4gICAgICB0eXBlOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gICAgICBmZWF0dXJlczogby5nZW9tZXRyaWVzLm1hcChmdW5jdGlvbihvKSB7IHJldHVybiBmZWF0dXJlKHRvcG9sb2d5LCBvKTsgfSlcbiAgICB9IDogZmVhdHVyZSh0b3BvbG9neSwgbyk7XG4gIH1cblxuICBmdW5jdGlvbiBmZWF0dXJlKHRvcG9sb2d5LCBvKSB7XG4gICAgdmFyIGYgPSB7XG4gICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgIGlkOiBvLmlkLFxuICAgICAgcHJvcGVydGllczogby5wcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgZ2VvbWV0cnk6IG9iamVjdCh0b3BvbG9neSwgbylcbiAgICB9O1xuICAgIGlmIChvLmlkID09IG51bGwpIGRlbGV0ZSBmLmlkO1xuICAgIHJldHVybiBmO1xuICB9XG5cbiAgZnVuY3Rpb24gb2JqZWN0KHRvcG9sb2d5LCBvKSB7XG4gICAgdmFyIGFic29sdXRlID0gdHJhbnNmb3JtQWJzb2x1dGUodG9wb2xvZ3kudHJhbnNmb3JtKSxcbiAgICAgICAgYXJjcyA9IHRvcG9sb2d5LmFyY3M7XG5cbiAgICBmdW5jdGlvbiBhcmMoaSwgcG9pbnRzKSB7XG4gICAgICBpZiAocG9pbnRzLmxlbmd0aCkgcG9pbnRzLnBvcCgpO1xuICAgICAgZm9yICh2YXIgYSA9IGFyY3NbaSA8IDAgPyB+aSA6IGldLCBrID0gMCwgbiA9IGEubGVuZ3RoLCBwOyBrIDwgbjsgKytrKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKHAgPSBhW2tdLnNsaWNlKCkpO1xuICAgICAgICBhYnNvbHV0ZShwLCBrKTtcbiAgICAgIH1cbiAgICAgIGlmIChpIDwgMCkgcmV2ZXJzZShwb2ludHMsIG4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50KHApIHtcbiAgICAgIHAgPSBwLnNsaWNlKCk7XG4gICAgICBhYnNvbHV0ZShwLCAwKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmUoYXJjcykge1xuICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBhcmNzLmxlbmd0aDsgaSA8IG47ICsraSkgYXJjKGFyY3NbaV0sIHBvaW50cyk7XG4gICAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDIpIHBvaW50cy5wdXNoKHBvaW50c1swXS5zbGljZSgpKTtcbiAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZyhhcmNzKSB7XG4gICAgICB2YXIgcG9pbnRzID0gbGluZShhcmNzKTtcbiAgICAgIHdoaWxlIChwb2ludHMubGVuZ3RoIDwgNCkgcG9pbnRzLnB1c2gocG9pbnRzWzBdLnNsaWNlKCkpO1xuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2x5Z29uKGFyY3MpIHtcbiAgICAgIHJldHVybiBhcmNzLm1hcChyaW5nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW9tZXRyeShvKSB7XG4gICAgICB2YXIgdCA9IG8udHlwZTtcbiAgICAgIHJldHVybiB0ID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiID8ge3R5cGU6IHQsIGdlb21ldHJpZXM6IG8uZ2VvbWV0cmllcy5tYXAoZ2VvbWV0cnkpfVxuICAgICAgICAgIDogdCBpbiBnZW9tZXRyeVR5cGUgPyB7dHlwZTogdCwgY29vcmRpbmF0ZXM6IGdlb21ldHJ5VHlwZVt0XShvKX1cbiAgICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGdlb21ldHJ5VHlwZSA9IHtcbiAgICAgIFBvaW50OiBmdW5jdGlvbihvKSB7IHJldHVybiBwb2ludChvLmNvb3JkaW5hdGVzKTsgfSxcbiAgICAgIE11bHRpUG9pbnQ6IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uY29vcmRpbmF0ZXMubWFwKHBvaW50KTsgfSxcbiAgICAgIExpbmVTdHJpbmc6IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIGxpbmUoby5hcmNzKTsgfSxcbiAgICAgIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24obykgeyByZXR1cm4gby5hcmNzLm1hcChsaW5lKTsgfSxcbiAgICAgIFBvbHlnb246IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIHBvbHlnb24oby5hcmNzKTsgfSxcbiAgICAgIE11bHRpUG9seWdvbjogZnVuY3Rpb24obykgeyByZXR1cm4gby5hcmNzLm1hcChwb2x5Z29uKTsgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZ2VvbWV0cnkobyk7XG4gIH1cblxuICBmdW5jdGlvbiByZXZlcnNlKGFycmF5LCBuKSB7XG4gICAgdmFyIHQsIGogPSBhcnJheS5sZW5ndGgsIGkgPSBqIC0gbjsgd2hpbGUgKGkgPCAtLWopIHQgPSBhcnJheVtpXSwgYXJyYXlbaSsrXSA9IGFycmF5W2pdLCBhcnJheVtqXSA9IHQ7XG4gIH1cblxuICBmdW5jdGlvbiBiaXNlY3QoYSwgeCkge1xuICAgIHZhciBsbyA9IDAsIGhpID0gYS5sZW5ndGg7XG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgaWYgKGFbbWlkXSA8IHgpIGxvID0gbWlkICsgMTtcbiAgICAgIGVsc2UgaGkgPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsbztcbiAgfVxuXG4gIGZ1bmN0aW9uIG5laWdoYm9ycyhvYmplY3RzKSB7XG4gICAgdmFyIGluZGV4ZXNCeUFyYyA9IHt9LCAvLyBhcmMgaW5kZXggLT4gYXJyYXkgb2Ygb2JqZWN0IGluZGV4ZXNcbiAgICAgICAgbmVpZ2hib3JzID0gb2JqZWN0cy5tYXAoZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfSk7XG5cbiAgICBmdW5jdGlvbiBsaW5lKGFyY3MsIGkpIHtcbiAgICAgIGFyY3MuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICAgIGlmIChhIDwgMCkgYSA9IH5hO1xuICAgICAgICB2YXIgbyA9IGluZGV4ZXNCeUFyY1thXTtcbiAgICAgICAgaWYgKG8pIG8ucHVzaChpKTtcbiAgICAgICAgZWxzZSBpbmRleGVzQnlBcmNbYV0gPSBbaV07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2x5Z29uKGFyY3MsIGkpIHtcbiAgICAgIGFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHsgbGluZShhcmMsIGkpOyB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW9tZXRyeShvLCBpKSB7XG4gICAgICBpZiAoby50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiKSBvLmdlb21ldHJpZXMuZm9yRWFjaChmdW5jdGlvbihvKSB7IGdlb21ldHJ5KG8sIGkpOyB9KTtcbiAgICAgIGVsc2UgaWYgKG8udHlwZSBpbiBnZW9tZXRyeVR5cGUpIGdlb21ldHJ5VHlwZVtvLnR5cGVdKG8uYXJjcywgaSk7XG4gICAgfVxuXG4gICAgdmFyIGdlb21ldHJ5VHlwZSA9IHtcbiAgICAgIExpbmVTdHJpbmc6IGxpbmUsXG4gICAgICBNdWx0aUxpbmVTdHJpbmc6IHBvbHlnb24sXG4gICAgICBQb2x5Z29uOiBwb2x5Z29uLFxuICAgICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihhcmNzLCBpKSB7IGFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHsgcG9seWdvbihhcmMsIGkpOyB9KTsgfVxuICAgIH07XG5cbiAgICBvYmplY3RzLmZvckVhY2goZ2VvbWV0cnkpO1xuXG4gICAgZm9yICh2YXIgaSBpbiBpbmRleGVzQnlBcmMpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ZXMgPSBpbmRleGVzQnlBcmNbaV0sIG0gPSBpbmRleGVzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgbTsgKytrKSB7XG4gICAgICAgICAgdmFyIGlqID0gaW5kZXhlc1tqXSwgaWsgPSBpbmRleGVzW2tdLCBuO1xuICAgICAgICAgIGlmICgobiA9IG5laWdoYm9yc1tpal0pW2kgPSBiaXNlY3QobiwgaWspXSAhPT0gaWspIG4uc3BsaWNlKGksIDAsIGlrKTtcbiAgICAgICAgICBpZiAoKG4gPSBuZWlnaGJvcnNbaWtdKVtpID0gYmlzZWN0KG4sIGlqKV0gIT09IGlqKSBuLnNwbGljZShpLCAwLCBpaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmVpZ2hib3JzO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlc2ltcGxpZnkodG9wb2xvZ3ksIHRyaWFuZ2xlQXJlYSkge1xuICAgIHZhciBhYnNvbHV0ZSA9IHRyYW5zZm9ybUFic29sdXRlKHRvcG9sb2d5LnRyYW5zZm9ybSksXG4gICAgICAgIHJlbGF0aXZlID0gdHJhbnNmb3JtUmVsYXRpdmUodG9wb2xvZ3kudHJhbnNmb3JtKSxcbiAgICAgICAgaGVhcCA9IG1pbkFyZWFIZWFwKCk7XG5cbiAgICBpZiAoIXRyaWFuZ2xlQXJlYSkgdHJpYW5nbGVBcmVhID0gY2FydGVzaWFuVHJpYW5nbGVBcmVhO1xuXG4gICAgdG9wb2xvZ3kuYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgdmFyIHRyaWFuZ2xlcyA9IFtdLFxuICAgICAgICAgIG1heEFyZWEgPSAwLFxuICAgICAgICAgIHRyaWFuZ2xlO1xuXG4gICAgICAvLyBUbyBzdG9yZSBlYWNoIHBvaW504oCZcyBlZmZlY3RpdmUgYXJlYSwgd2UgY3JlYXRlIGEgbmV3IGFycmF5IHJhdGhlciB0aGFuXG4gICAgICAvLyBleHRlbmRpbmcgdGhlIHBhc3NlZC1pbiBwb2ludCB0byB3b3JrYXJvdW5kIGEgQ2hyb21lL1Y4IGJ1ZyAoZ2V0dGluZ1xuICAgICAgLy8gc3R1Y2sgaW4gc21pIG1vZGUpLiBGb3IgbWlkcG9pbnRzLCB0aGUgaW5pdGlhbCBlZmZlY3RpdmUgYXJlYSBvZlxuICAgICAgLy8gSW5maW5pdHkgd2lsbCBiZSBjb21wdXRlZCBpbiB0aGUgbmV4dCBzdGVwLlxuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBhcmMubGVuZ3RoLCBwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHAgPSBhcmNbaV07XG4gICAgICAgIGFic29sdXRlKGFyY1tpXSA9IFtwWzBdLCBwWzFdLCBJbmZpbml0eV0sIGkpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbiA9IGFyYy5sZW5ndGggLSAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHRyaWFuZ2xlID0gYXJjLnNsaWNlKGkgLSAxLCBpICsgMik7XG4gICAgICAgIHRyaWFuZ2xlWzFdWzJdID0gdHJpYW5nbGVBcmVhKHRyaWFuZ2xlKTtcbiAgICAgICAgdHJpYW5nbGVzLnB1c2godHJpYW5nbGUpO1xuICAgICAgICBoZWFwLnB1c2godHJpYW5nbGUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRyaWFuZ2xlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdHJpYW5nbGUgPSB0cmlhbmdsZXNbaV07XG4gICAgICAgIHRyaWFuZ2xlLnByZXZpb3VzID0gdHJpYW5nbGVzW2kgLSAxXTtcbiAgICAgICAgdHJpYW5nbGUubmV4dCA9IHRyaWFuZ2xlc1tpICsgMV07XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cmlhbmdsZSA9IGhlYXAucG9wKCkpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzID0gdHJpYW5nbGUucHJldmlvdXMsXG4gICAgICAgICAgICBuZXh0ID0gdHJpYW5nbGUubmV4dDtcblxuICAgICAgICAvLyBJZiB0aGUgYXJlYSBvZiB0aGUgY3VycmVudCBwb2ludCBpcyBsZXNzIHRoYW4gdGhhdCBvZiB0aGUgcHJldmlvdXMgcG9pbnRcbiAgICAgICAgLy8gdG8gYmUgZWxpbWluYXRlZCwgdXNlIHRoZSBsYXR0ZXIncyBhcmVhIGluc3RlYWQuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZVxuICAgICAgICAvLyBjdXJyZW50IHBvaW50IGNhbm5vdCBiZSBlbGltaW5hdGVkIHdpdGhvdXQgZWxpbWluYXRpbmcgcHJldmlvdXNseS1cbiAgICAgICAgLy8gZWxpbWluYXRlZCBwb2ludHMuXG4gICAgICAgIGlmICh0cmlhbmdsZVsxXVsyXSA8IG1heEFyZWEpIHRyaWFuZ2xlWzFdWzJdID0gbWF4QXJlYTtcbiAgICAgICAgZWxzZSBtYXhBcmVhID0gdHJpYW5nbGVbMV1bMl07XG5cbiAgICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgICAgcHJldmlvdXMubmV4dCA9IG5leHQ7XG4gICAgICAgICAgcHJldmlvdXNbMl0gPSB0cmlhbmdsZVsyXTtcbiAgICAgICAgICB1cGRhdGUocHJldmlvdXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgICAgbmV4dFswXSA9IHRyaWFuZ2xlWzBdO1xuICAgICAgICAgIHVwZGF0ZShuZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhcmMuZm9yRWFjaChyZWxhdGl2ZSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGUodHJpYW5nbGUpIHtcbiAgICAgIGhlYXAucmVtb3ZlKHRyaWFuZ2xlKTtcbiAgICAgIHRyaWFuZ2xlWzFdWzJdID0gdHJpYW5nbGVBcmVhKHRyaWFuZ2xlKTtcbiAgICAgIGhlYXAucHVzaCh0cmlhbmdsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvcG9sb2d5O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNhcnRlc2lhblJpbmdBcmVhKHJpbmcpIHtcbiAgICB2YXIgaSA9IC0xLFxuICAgICAgICBuID0gcmluZy5sZW5ndGgsXG4gICAgICAgIGEsXG4gICAgICAgIGIgPSByaW5nW24gLSAxXSxcbiAgICAgICAgYXJlYSA9IDA7XG5cbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgYSA9IGI7XG4gICAgICBiID0gcmluZ1tpXTtcbiAgICAgIGFyZWEgKz0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJlYSAqIC41O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FydGVzaWFuVHJpYW5nbGVBcmVhKHRyaWFuZ2xlKSB7XG4gICAgdmFyIGEgPSB0cmlhbmdsZVswXSwgYiA9IHRyaWFuZ2xlWzFdLCBjID0gdHJpYW5nbGVbMl07XG4gICAgcmV0dXJuIE1hdGguYWJzKChhWzBdIC0gY1swXSkgKiAoYlsxXSAtIGFbMV0pIC0gKGFbMF0gLSBiWzBdKSAqIChjWzFdIC0gYVsxXSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyZUFyZWEoYSwgYikge1xuICAgIHJldHVybiBhWzFdWzJdIC0gYlsxXVsyXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1pbkFyZWFIZWFwKCkge1xuICAgIHZhciBoZWFwID0ge30sXG4gICAgICAgIGFycmF5ID0gW10sXG4gICAgICAgIHNpemUgPSAwO1xuXG4gICAgaGVhcC5wdXNoID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB1cChhcnJheVtvYmplY3QuXyA9IHNpemVdID0gb2JqZWN0LCBzaXplKyspO1xuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfTtcblxuICAgIGhlYXAucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc2l6ZSA8PSAwKSByZXR1cm47XG4gICAgICB2YXIgcmVtb3ZlZCA9IGFycmF5WzBdLCBvYmplY3Q7XG4gICAgICBpZiAoLS1zaXplID4gMCkgb2JqZWN0ID0gYXJyYXlbc2l6ZV0sIGRvd24oYXJyYXlbb2JqZWN0Ll8gPSAwXSA9IG9iamVjdCwgMCk7XG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9O1xuXG4gICAgaGVhcC5yZW1vdmUgPSBmdW5jdGlvbihyZW1vdmVkKSB7XG4gICAgICB2YXIgaSA9IHJlbW92ZWQuXywgb2JqZWN0O1xuICAgICAgaWYgKGFycmF5W2ldICE9PSByZW1vdmVkKSByZXR1cm47IC8vIGludmFsaWQgcmVxdWVzdFxuICAgICAgaWYgKGkgIT09IC0tc2l6ZSkgb2JqZWN0ID0gYXJyYXlbc2l6ZV0sIChjb21wYXJlQXJlYShvYmplY3QsIHJlbW92ZWQpIDwgMCA/IHVwIDogZG93bikoYXJyYXlbb2JqZWN0Ll8gPSBpXSA9IG9iamVjdCwgaSk7XG4gICAgICByZXR1cm4gaTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdXAob2JqZWN0LCBpKSB7XG4gICAgICB3aGlsZSAoaSA+IDApIHtcbiAgICAgICAgdmFyIGogPSAoKGkgKyAxKSA+PiAxKSAtIDEsXG4gICAgICAgICAgICBwYXJlbnQgPSBhcnJheVtqXTtcbiAgICAgICAgaWYgKGNvbXBhcmVBcmVhKG9iamVjdCwgcGFyZW50KSA+PSAwKSBicmVhaztcbiAgICAgICAgYXJyYXlbcGFyZW50Ll8gPSBpXSA9IHBhcmVudDtcbiAgICAgICAgYXJyYXlbb2JqZWN0Ll8gPSBpID0gal0gPSBvYmplY3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG93bihvYmplY3QsIGkpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciByID0gKGkgKyAxKSA8PCAxLFxuICAgICAgICAgICAgbCA9IHIgLSAxLFxuICAgICAgICAgICAgaiA9IGksXG4gICAgICAgICAgICBjaGlsZCA9IGFycmF5W2pdO1xuICAgICAgICBpZiAobCA8IHNpemUgJiYgY29tcGFyZUFyZWEoYXJyYXlbbF0sIGNoaWxkKSA8IDApIGNoaWxkID0gYXJyYXlbaiA9IGxdO1xuICAgICAgICBpZiAociA8IHNpemUgJiYgY29tcGFyZUFyZWEoYXJyYXlbcl0sIGNoaWxkKSA8IDApIGNoaWxkID0gYXJyYXlbaiA9IHJdO1xuICAgICAgICBpZiAoaiA9PT0gaSkgYnJlYWs7XG4gICAgICAgIGFycmF5W2NoaWxkLl8gPSBpXSA9IGNoaWxkO1xuICAgICAgICBhcnJheVtvYmplY3QuXyA9IGkgPSBqXSA9IG9iamVjdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGVhcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUFic29sdXRlKHRyYW5zZm9ybSkge1xuICAgIGlmICghdHJhbnNmb3JtKSByZXR1cm4gbm9vcDtcbiAgICB2YXIgeDAsXG4gICAgICAgIHkwLFxuICAgICAgICBreCA9IHRyYW5zZm9ybS5zY2FsZVswXSxcbiAgICAgICAga3kgPSB0cmFuc2Zvcm0uc2NhbGVbMV0sXG4gICAgICAgIGR4ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVswXSxcbiAgICAgICAgZHkgPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzFdO1xuICAgIHJldHVybiBmdW5jdGlvbihwb2ludCwgaSkge1xuICAgICAgaWYgKCFpKSB4MCA9IHkwID0gMDtcbiAgICAgIHBvaW50WzBdID0gKHgwICs9IHBvaW50WzBdKSAqIGt4ICsgZHg7XG4gICAgICBwb2ludFsxXSA9ICh5MCArPSBwb2ludFsxXSkgKiBreSArIGR5O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1SZWxhdGl2ZSh0cmFuc2Zvcm0pIHtcbiAgICBpZiAoIXRyYW5zZm9ybSkgcmV0dXJuIG5vb3A7XG4gICAgdmFyIHgwLFxuICAgICAgICB5MCxcbiAgICAgICAga3ggPSB0cmFuc2Zvcm0uc2NhbGVbMF0sXG4gICAgICAgIGt5ID0gdHJhbnNmb3JtLnNjYWxlWzFdLFxuICAgICAgICBkeCA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMF0sXG4gICAgICAgIGR5ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVsxXTtcbiAgICByZXR1cm4gZnVuY3Rpb24ocG9pbnQsIGkpIHtcbiAgICAgIGlmICghaSkgeDAgPSB5MCA9IDA7XG4gICAgICB2YXIgeDEgPSAocG9pbnRbMF0gLSBkeCkgLyBreCB8IDAsXG4gICAgICAgICAgeTEgPSAocG9pbnRbMV0gLSBkeSkgLyBreSB8IDA7XG4gICAgICBwb2ludFswXSA9IHgxIC0geDA7XG4gICAgICBwb2ludFsxXSA9IHkxIC0geTA7XG4gICAgICB4MCA9IHgxO1xuICAgICAgeTAgPSB5MTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSBkZWZpbmUodG9wb2pzb24pO1xuICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0cyA9IHRvcG9qc29uO1xuICBlbHNlIHRoaXMudG9wb2pzb24gPSB0b3BvanNvbjtcbn0oKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLEJ1ZmZlcil7XG4ndXNlIHN0cmljdCdcblxudmFyIGJpdHMgPSByZXF1aXJlKCdiaXQtdHdpZGRsZScpXG52YXIgZHVwID0gcmVxdWlyZSgnZHVwJylcblxuLy9MZWdhY3kgcG9vbCBzdXBwb3J0XG5pZighZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MKSB7XG4gIGdsb2JhbC5fX1RZUEVEQVJSQVlfUE9PTCA9IHtcbiAgICAgIFVJTlQ4ICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQxNiAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQzMiAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDggICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDE2ICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDMyICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIEZMT0FUICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIERPVUJMRSAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIERBVEEgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQ4QyAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIEJVRkZFUiAgOiBkdXAoWzMyLCAwXSlcbiAgfVxufVxuXG52YXIgaGFzVWludDhDID0gKHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSkgIT09ICd1bmRlZmluZWQnXG52YXIgUE9PTCA9IGdsb2JhbC5fX1RZUEVEQVJSQVlfUE9PTFxuXG4vL1VwZ3JhZGUgcG9vbFxuaWYoIVBPT0wuVUlOVDhDKSB7XG4gIFBPT0wuVUlOVDhDID0gZHVwKFszMiwgMF0pXG59XG5pZighUE9PTC5CVUZGRVIpIHtcbiAgUE9PTC5CVUZGRVIgPSBkdXAoWzMyLCAwXSlcbn1cblxuLy9OZXcgdGVjaG5pcXVlOiBPbmx5IGFsbG9jYXRlIGZyb20gQXJyYXlCdWZmZXJWaWV3IGFuZCBCdWZmZXJcbnZhciBEQVRBICAgID0gUE9PTC5EQVRBXG4gICwgQlVGRkVSICA9IFBPT0wuQlVGRkVSXG5cbmV4cG9ydHMuZnJlZSA9IGZ1bmN0aW9uIGZyZWUoYXJyYXkpIHtcbiAgaWYoQnVmZmVyLmlzQnVmZmVyKGFycmF5KSkge1xuICAgIEJVRkZFUltiaXRzLmxvZzIoYXJyYXkubGVuZ3RoKV0ucHVzaChhcnJheSlcbiAgfSBlbHNlIHtcbiAgICBpZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyYXkpICE9PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBhcnJheSA9IGFycmF5LmJ1ZmZlclxuICAgIH1cbiAgICBpZighYXJyYXkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aCB8fCBhcnJheS5ieXRlTGVuZ3RoXG4gICAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pfDBcbiAgICBEQVRBW2xvZ19uXS5wdXNoKGFycmF5KVxuICB9XG59XG5cbmZ1bmN0aW9uIGZyZWVBcnJheUJ1ZmZlcihidWZmZXIpIHtcbiAgaWYoIWJ1ZmZlcikge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBuID0gYnVmZmVyLmxlbmd0aCB8fCBidWZmZXIuYnl0ZUxlbmd0aFxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgREFUQVtsb2dfbl0ucHVzaChidWZmZXIpXG59XG5cbmZ1bmN0aW9uIGZyZWVUeXBlZEFycmF5KGFycmF5KSB7XG4gIGZyZWVBcnJheUJ1ZmZlcihhcnJheS5idWZmZXIpXG59XG5cbmV4cG9ydHMuZnJlZVVpbnQ4ID1cbmV4cG9ydHMuZnJlZVVpbnQxNiA9XG5leHBvcnRzLmZyZWVVaW50MzIgPVxuZXhwb3J0cy5mcmVlSW50OCA9XG5leHBvcnRzLmZyZWVJbnQxNiA9XG5leHBvcnRzLmZyZWVJbnQzMiA9XG5leHBvcnRzLmZyZWVGbG9hdDMyID0gXG5leHBvcnRzLmZyZWVGbG9hdCA9XG5leHBvcnRzLmZyZWVGbG9hdDY0ID0gXG5leHBvcnRzLmZyZWVEb3VibGUgPSBcbmV4cG9ydHMuZnJlZVVpbnQ4Q2xhbXBlZCA9IFxuZXhwb3J0cy5mcmVlRGF0YVZpZXcgPSBmcmVlVHlwZWRBcnJheVxuXG5leHBvcnRzLmZyZWVBcnJheUJ1ZmZlciA9IGZyZWVBcnJheUJ1ZmZlclxuXG5leHBvcnRzLmZyZWVCdWZmZXIgPSBmdW5jdGlvbiBmcmVlQnVmZmVyKGFycmF5KSB7XG4gIEJVRkZFUltiaXRzLmxvZzIoYXJyYXkubGVuZ3RoKV0ucHVzaChhcnJheSlcbn1cblxuZXhwb3J0cy5tYWxsb2MgPSBmdW5jdGlvbiBtYWxsb2MobiwgZHR5cGUpIHtcbiAgaWYoZHR5cGUgPT09IHVuZGVmaW5lZCB8fCBkdHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgIHJldHVybiBtYWxsb2NBcnJheUJ1ZmZlcihuKVxuICB9IGVsc2Uge1xuICAgIHN3aXRjaChkdHlwZSkge1xuICAgICAgY2FzZSAndWludDgnOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDgobilcbiAgICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50MTYobilcbiAgICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50MzIobilcbiAgICAgIGNhc2UgJ2ludDgnOlxuICAgICAgICByZXR1cm4gbWFsbG9jSW50OChuKVxuICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgICByZXR1cm4gbWFsbG9jSW50MTYobilcbiAgICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDMyKG4pXG4gICAgICBjYXNlICdmbG9hdCc6XG4gICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0Zsb2F0KG4pXG4gICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NEb3VibGUobilcbiAgICAgIGNhc2UgJ3VpbnQ4X2NsYW1wZWQnOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDhDbGFtcGVkKG4pXG4gICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICByZXR1cm4gbWFsbG9jQnVmZmVyKG4pXG4gICAgICBjYXNlICdkYXRhJzpcbiAgICAgIGNhc2UgJ2RhdGF2aWV3JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0RhdGFWaWV3KG4pXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIG1hbGxvY0FycmF5QnVmZmVyKG4pIHtcbiAgdmFyIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICB2YXIgZCA9IERBVEFbbG9nX25dXG4gIGlmKGQubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkLnBvcCgpXG4gIH1cbiAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcihuKVxufVxuZXhwb3J0cy5tYWxsb2NBcnJheUJ1ZmZlciA9IG1hbGxvY0FycmF5QnVmZmVyXG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQ4KG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50OCA9IG1hbGxvY1VpbnQ4XG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQxNihuKSB7XG4gIHJldHVybiBuZXcgVWludDE2QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoMipuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDE2ID0gbWFsbG9jVWludDE2XG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQzMihuKSB7XG4gIHJldHVybiBuZXcgVWludDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDMyID0gbWFsbG9jVWludDMyXG5cbmZ1bmN0aW9uIG1hbGxvY0ludDgobikge1xuICByZXR1cm4gbmV3IEludDhBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50OCA9IG1hbGxvY0ludDhcblxuZnVuY3Rpb24gbWFsbG9jSW50MTYobikge1xuICByZXR1cm4gbmV3IEludDE2QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoMipuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50MTYgPSBtYWxsb2NJbnQxNlxuXG5mdW5jdGlvbiBtYWxsb2NJbnQzMihuKSB7XG4gIHJldHVybiBuZXcgSW50MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQzMiA9IG1hbGxvY0ludDMyXG5cbmZ1bmN0aW9uIG1hbGxvY0Zsb2F0KG4pIHtcbiAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jRmxvYXQzMiA9IGV4cG9ydHMubWFsbG9jRmxvYXQgPSBtYWxsb2NGbG9hdFxuXG5mdW5jdGlvbiBtYWxsb2NEb3VibGUobikge1xuICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig4Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NGbG9hdDY0ID0gZXhwb3J0cy5tYWxsb2NEb3VibGUgPSBtYWxsb2NEb3VibGVcblxuZnVuY3Rpb24gbWFsbG9jVWludDhDbGFtcGVkKG4pIHtcbiAgaWYoaGFzVWludDhDKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWFsbG9jVWludDgobilcbiAgfVxufVxuZXhwb3J0cy5tYWxsb2NVaW50OENsYW1wZWQgPSBtYWxsb2NVaW50OENsYW1wZWRcblxuZnVuY3Rpb24gbWFsbG9jRGF0YVZpZXcobikge1xuICByZXR1cm4gbmV3IERhdGFWaWV3KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NEYXRhVmlldyA9IG1hbGxvY0RhdGFWaWV3XG5cbmZ1bmN0aW9uIG1hbGxvY0J1ZmZlcihuKSB7XG4gIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICB2YXIgY2FjaGUgPSBCVUZGRVJbbG9nX25dXG4gIGlmKGNhY2hlLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gY2FjaGUucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEJ1ZmZlcihuKVxufVxuZXhwb3J0cy5tYWxsb2NCdWZmZXIgPSBtYWxsb2NCdWZmZXJcblxuZXhwb3J0cy5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgZm9yKHZhciBpPTA7IGk8MzI7ICsraSkge1xuICAgIFBPT0wuVUlOVDhbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDE2W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQzMltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5JTlQ4W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDE2W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDMyW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLkZMT0FUW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLkRPVUJMRVtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UOENbaV0ubGVuZ3RoID0gMFxuICAgIERBVEFbaV0ubGVuZ3RoID0gMFxuICAgIEJVRkZFUltpXS5sZW5ndGggPSAwXG4gIH1cbn1cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OTBlWEJsWkdGeWNtRjVMWEJ2YjJ3dmNHOXZiQzVxY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVpTENKbWFXeGxJam9pWjJWdVpYSmhkR1ZrTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklpZDFjMlVnYzNSeWFXTjBKMXh1WEc1MllYSWdZbWwwY3lBOUlISmxjWFZwY21Vb0oySnBkQzEwZDJsa1pHeGxKeWxjYm5aaGNpQmtkWEFnUFNCeVpYRjFhWEpsS0Nka2RYQW5LVnh1WEc0dkwweGxaMkZqZVNCd2IyOXNJSE4xY0hCdmNuUmNibWxtS0NGbmJHOWlZV3d1WDE5VVdWQkZSRUZTVWtGWlgxQlBUMHdwSUh0Y2JpQWdaMnh2WW1Gc0xsOWZWRmxRUlVSQlVsSkJXVjlRVDA5TUlEMGdlMXh1SUNBZ0lDQWdWVWxPVkRnZ0lDQTZJR1IxY0NoYk16SXNJREJkS1Z4dUlDQWdJQ3dnVlVsT1ZERTJJQ0E2SUdSMWNDaGJNeklzSURCZEtWeHVJQ0FnSUN3Z1ZVbE9WRE15SUNBNklHUjFjQ2hiTXpJc0lEQmRLVnh1SUNBZ0lDd2dTVTVVT0NBZ0lDQTZJR1IxY0NoYk16SXNJREJkS1Z4dUlDQWdJQ3dnU1U1VU1UWWdJQ0E2SUdSMWNDaGJNeklzSURCZEtWeHVJQ0FnSUN3Z1NVNVVNeklnSUNBNklHUjFjQ2hiTXpJc0lEQmRLVnh1SUNBZ0lDd2dSa3hQUVZRZ0lDQTZJR1IxY0NoYk16SXNJREJkS1Z4dUlDQWdJQ3dnUkU5VlFreEZJQ0E2SUdSMWNDaGJNeklzSURCZEtWeHVJQ0FnSUN3Z1JFRlVRU0FnSUNBNklHUjFjQ2hiTXpJc0lEQmRLVnh1SUNBZ0lDd2dWVWxPVkRoRElDQTZJR1IxY0NoYk16SXNJREJkS1Z4dUlDQWdJQ3dnUWxWR1JrVlNJQ0E2SUdSMWNDaGJNeklzSURCZEtWeHVJQ0I5WEc1OVhHNWNiblpoY2lCb1lYTlZhVzUwT0VNZ1BTQW9kSGx3Wlc5bUlGVnBiblE0UTJ4aGJYQmxaRUZ5Y21GNUtTQWhQVDBnSjNWdVpHVm1hVzVsWkNkY2JuWmhjaUJRVDA5TUlEMGdaMnh2WW1Gc0xsOWZWRmxRUlVSQlVsSkJXVjlRVDA5TVhHNWNiaTh2VlhCbmNtRmtaU0J3YjI5c1hHNXBaaWdoVUU5UFRDNVZTVTVVT0VNcElIdGNiaUFnVUU5UFRDNVZTVTVVT0VNZ1BTQmtkWEFvV3pNeUxDQXdYU2xjYm4xY2JtbG1LQ0ZRVDA5TUxrSlZSa1pGVWlrZ2UxeHVJQ0JRVDA5TUxrSlZSa1pGVWlBOUlHUjFjQ2hiTXpJc0lEQmRLVnh1ZlZ4dVhHNHZMMDVsZHlCMFpXTm9ibWx4ZFdVNklFOXViSGtnWVd4c2IyTmhkR1VnWm5KdmJTQkJjbkpoZVVKMVptWmxjbFpwWlhjZ1lXNWtJRUoxWm1abGNseHVkbUZ5SUVSQlZFRWdJQ0FnUFNCUVQwOU1Ma1JCVkVGY2JpQWdMQ0JDVlVaR1JWSWdJRDBnVUU5UFRDNUNWVVpHUlZKY2JseHVaWGh3YjNKMGN5NW1jbVZsSUQwZ1puVnVZM1JwYjI0Z1puSmxaU2hoY25KaGVTa2dlMXh1SUNCcFppaENkV1ptWlhJdWFYTkNkV1ptWlhJb1lYSnlZWGtwS1NCN1hHNGdJQ0FnUWxWR1JrVlNXMkpwZEhNdWJHOW5NaWhoY25KaGVTNXNaVzVuZEdncFhTNXdkWE5vS0dGeWNtRjVLVnh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJR2xtS0U5aWFtVmpkQzV3Y205MGIzUjVjR1V1ZEc5VGRISnBibWN1WTJGc2JDaGhjbkpoZVNrZ0lUMDlJQ2RiYjJKcVpXTjBJRUZ5Y21GNVFuVm1abVZ5WFNjcElIdGNiaUFnSUNBZ0lHRnljbUY1SUQwZ1lYSnlZWGt1WW5WbVptVnlYRzRnSUNBZ2ZWeHVJQ0FnSUdsbUtDRmhjbkpoZVNrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1WEc0Z0lDQWdmVnh1SUNBZ0lIWmhjaUJ1SUQwZ1lYSnlZWGt1YkdWdVozUm9JSHg4SUdGeWNtRjVMbUo1ZEdWTVpXNW5kR2hjYmlBZ0lDQjJZWElnYkc5blgyNGdQU0JpYVhSekxteHZaeklvYmlsOE1GeHVJQ0FnSUVSQlZFRmJiRzluWDI1ZExuQjFjMmdvWVhKeVlYa3BYRzRnSUgxY2JuMWNibHh1Wm5WdVkzUnBiMjRnWm5KbFpVRnljbUY1UW5WbVptVnlLR0oxWm1abGNpa2dlMXh1SUNCcFppZ2hZblZtWm1WeUtTQjdYRzRnSUNBZ2NtVjBkWEp1WEc0Z0lIMWNiaUFnZG1GeUlHNGdQU0JpZFdabVpYSXViR1Z1WjNSb0lIeDhJR0oxWm1abGNpNWllWFJsVEdWdVozUm9YRzRnSUhaaGNpQnNiMmRmYmlBOUlHSnBkSE11Ykc5bk1paHVLVnh1SUNCRVFWUkJXMnh2WjE5dVhTNXdkWE5vS0dKMVptWmxjaWxjYm4xY2JseHVablZ1WTNScGIyNGdabkpsWlZSNWNHVmtRWEp5WVhrb1lYSnlZWGtwSUh0Y2JpQWdabkpsWlVGeWNtRjVRblZtWm1WeUtHRnljbUY1TG1KMVptWmxjaWxjYm4xY2JseHVaWGh3YjNKMGN5NW1jbVZsVldsdWREZ2dQVnh1Wlhod2IzSjBjeTVtY21WbFZXbHVkREUySUQxY2JtVjRjRzl5ZEhNdVpuSmxaVlZwYm5Rek1pQTlYRzVsZUhCdmNuUnpMbVp5WldWSmJuUTRJRDFjYm1WNGNHOXlkSE11Wm5KbFpVbHVkREUySUQxY2JtVjRjRzl5ZEhNdVpuSmxaVWx1ZERNeUlEMWNibVY0Y0c5eWRITXVabkpsWlVac2IyRjBNeklnUFNCY2JtVjRjRzl5ZEhNdVpuSmxaVVpzYjJGMElEMWNibVY0Y0c5eWRITXVabkpsWlVac2IyRjBOalFnUFNCY2JtVjRjRzl5ZEhNdVpuSmxaVVJ2ZFdKc1pTQTlJRnh1Wlhod2IzSjBjeTVtY21WbFZXbHVkRGhEYkdGdGNHVmtJRDBnWEc1bGVIQnZjblJ6TG1aeVpXVkVZWFJoVm1sbGR5QTlJR1p5WldWVWVYQmxaRUZ5Y21GNVhHNWNibVY0Y0c5eWRITXVabkpsWlVGeWNtRjVRblZtWm1WeUlEMGdabkpsWlVGeWNtRjVRblZtWm1WeVhHNWNibVY0Y0c5eWRITXVabkpsWlVKMVptWmxjaUE5SUdaMWJtTjBhVzl1SUdaeVpXVkNkV1ptWlhJb1lYSnlZWGtwSUh0Y2JpQWdRbFZHUmtWU1cySnBkSE11Ykc5bk1paGhjbkpoZVM1c1pXNW5kR2dwWFM1d2RYTm9LR0Z5Y21GNUtWeHVmVnh1WEc1bGVIQnZjblJ6TG0xaGJHeHZZeUE5SUdaMWJtTjBhVzl1SUcxaGJHeHZZeWh1TENCa2RIbHdaU2tnZTF4dUlDQnBaaWhrZEhsd1pTQTlQVDBnZFc1a1pXWnBibVZrSUh4OElHUjBlWEJsSUQwOVBTQW5ZWEp5WVhsaWRXWm1aWEluS1NCN1hHNGdJQ0FnY21WMGRYSnVJRzFoYkd4dlkwRnljbUY1UW5WbVptVnlLRzRwWEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnYzNkcGRHTm9LR1IwZVhCbEtTQjdYRzRnSUNBZ0lDQmpZWE5sSUNkMWFXNTBPQ2M2WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJ0WVd4c2IyTlZhVzUwT0NodUtWeHVJQ0FnSUNBZ1kyRnpaU0FuZFdsdWRERTJKenBjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJRzFoYkd4dlkxVnBiblF4TmlodUtWeHVJQ0FnSUNBZ1kyRnpaU0FuZFdsdWRETXlKenBjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJRzFoYkd4dlkxVnBiblF6TWlodUtWeHVJQ0FnSUNBZ1kyRnpaU0FuYVc1ME9DYzZYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnRZV3hzYjJOSmJuUTRLRzRwWEc0Z0lDQWdJQ0JqWVhObElDZHBiblF4TmljNlhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCdFlXeHNiMk5KYm5ReE5paHVLVnh1SUNBZ0lDQWdZMkZ6WlNBbmFXNTBNekluT2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnYldGc2JHOWpTVzUwTXpJb2JpbGNiaUFnSUNBZ0lHTmhjMlVnSjJac2IyRjBKenBjYmlBZ0lDQWdJR05oYzJVZ0oyWnNiMkYwTXpJbk9seHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2JXRnNiRzlqUm14dllYUW9iaWxjYmlBZ0lDQWdJR05oYzJVZ0oyUnZkV0pzWlNjNlhHNGdJQ0FnSUNCallYTmxJQ2RtYkc5aGREWTBKenBjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJRzFoYkd4dlkwUnZkV0pzWlNodUtWeHVJQ0FnSUNBZ1kyRnpaU0FuZFdsdWREaGZZMnhoYlhCbFpDYzZYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnRZV3hzYjJOVmFXNTBPRU5zWVcxd1pXUW9iaWxjYmlBZ0lDQWdJR05oYzJVZ0oySjFabVpsY2ljNlhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCdFlXeHNiMk5DZFdabVpYSW9iaWxjYmlBZ0lDQWdJR05oYzJVZ0oyUmhkR0VuT2x4dUlDQWdJQ0FnWTJGelpTQW5aR0YwWVhacFpYY25PbHh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdiV0ZzYkc5alJHRjBZVlpwWlhjb2JpbGNibHh1SUNBZ0lDQWdaR1ZtWVhWc2REcGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHNTFiR3hjYmlBZ0lDQjlYRzRnSUgxY2JpQWdjbVYwZFhKdUlHNTFiR3hjYm4xY2JseHVablZ1WTNScGIyNGdiV0ZzYkc5alFYSnlZWGxDZFdabVpYSW9iaWtnZTF4dUlDQjJZWElnYmlBOUlHSnBkSE11Ym1WNGRGQnZkeklvYmlsY2JpQWdkbUZ5SUd4dloxOXVJRDBnWW1sMGN5NXNiMmN5S0c0cFhHNGdJSFpoY2lCa0lEMGdSRUZVUVZ0c2IyZGZibDFjYmlBZ2FXWW9aQzVzWlc1bmRHZ2dQaUF3S1NCN1hHNGdJQ0FnY21WMGRYSnVJR1F1Y0c5d0tDbGNiaUFnZlZ4dUlDQnlaWFIxY200Z2JtVjNJRUZ5Y21GNVFuVm1abVZ5S0c0cFhHNTlYRzVsZUhCdmNuUnpMbTFoYkd4dlkwRnljbUY1UW5WbVptVnlJRDBnYldGc2JHOWpRWEp5WVhsQ2RXWm1aWEpjYmx4dVpuVnVZM1JwYjI0Z2JXRnNiRzlqVldsdWREZ29iaWtnZTF4dUlDQnlaWFIxY200Z2JtVjNJRlZwYm5RNFFYSnlZWGtvYldGc2JHOWpRWEp5WVhsQ2RXWm1aWElvYmlrc0lEQXNJRzRwWEc1OVhHNWxlSEJ2Y25SekxtMWhiR3h2WTFWcGJuUTRJRDBnYldGc2JHOWpWV2x1ZERoY2JseHVablZ1WTNScGIyNGdiV0ZzYkc5alZXbHVkREUyS0c0cElIdGNiaUFnY21WMGRYSnVJRzVsZHlCVmFXNTBNVFpCY25KaGVTaHRZV3hzYjJOQmNuSmhlVUoxWm1abGNpZ3lLbTRwTENBd0xDQnVLVnh1ZlZ4dVpYaHdiM0owY3k1dFlXeHNiMk5WYVc1ME1UWWdQU0J0WVd4c2IyTlZhVzUwTVRaY2JseHVablZ1WTNScGIyNGdiV0ZzYkc5alZXbHVkRE15S0c0cElIdGNiaUFnY21WMGRYSnVJRzVsZHlCVmFXNTBNekpCY25KaGVTaHRZV3hzYjJOQmNuSmhlVUoxWm1abGNpZzBLbTRwTENBd0xDQnVLVnh1ZlZ4dVpYaHdiM0owY3k1dFlXeHNiMk5WYVc1ME16SWdQU0J0WVd4c2IyTlZhVzUwTXpKY2JseHVablZ1WTNScGIyNGdiV0ZzYkc5alNXNTBPQ2h1S1NCN1hHNGdJSEpsZEhWeWJpQnVaWGNnU1c1ME9FRnljbUY1S0cxaGJHeHZZMEZ5Y21GNVFuVm1abVZ5S0c0cExDQXdMQ0J1S1Z4dWZWeHVaWGh3YjNKMGN5NXRZV3hzYjJOSmJuUTRJRDBnYldGc2JHOWpTVzUwT0Z4dVhHNW1kVzVqZEdsdmJpQnRZV3hzYjJOSmJuUXhOaWh1S1NCN1hHNGdJSEpsZEhWeWJpQnVaWGNnU1c1ME1UWkJjbkpoZVNodFlXeHNiMk5CY25KaGVVSjFabVpsY2lneUttNHBMQ0F3TENCdUtWeHVmVnh1Wlhod2IzSjBjeTV0WVd4c2IyTkpiblF4TmlBOUlHMWhiR3h2WTBsdWRERTJYRzVjYm1aMWJtTjBhVzl1SUcxaGJHeHZZMGx1ZERNeUtHNHBJSHRjYmlBZ2NtVjBkWEp1SUc1bGR5QkpiblF6TWtGeWNtRjVLRzFoYkd4dlkwRnljbUY1UW5WbVptVnlLRFFxYmlrc0lEQXNJRzRwWEc1OVhHNWxlSEJ2Y25SekxtMWhiR3h2WTBsdWRETXlJRDBnYldGc2JHOWpTVzUwTXpKY2JseHVablZ1WTNScGIyNGdiV0ZzYkc5alJteHZZWFFvYmlrZ2UxeHVJQ0J5WlhSMWNtNGdibVYzSUVac2IyRjBNekpCY25KaGVTaHRZV3hzYjJOQmNuSmhlVUoxWm1abGNpZzBLbTRwTENBd0xDQnVLVnh1ZlZ4dVpYaHdiM0owY3k1dFlXeHNiMk5HYkc5aGRETXlJRDBnWlhod2IzSjBjeTV0WVd4c2IyTkdiRzloZENBOUlHMWhiR3h2WTBac2IyRjBYRzVjYm1aMWJtTjBhVzl1SUcxaGJHeHZZMFJ2ZFdKc1pTaHVLU0I3WEc0Z0lISmxkSFZ5YmlCdVpYY2dSbXh2WVhRMk5FRnljbUY1S0cxaGJHeHZZMEZ5Y21GNVFuVm1abVZ5S0RncWJpa3NJREFzSUc0cFhHNTlYRzVsZUhCdmNuUnpMbTFoYkd4dlkwWnNiMkYwTmpRZ1BTQmxlSEJ2Y25SekxtMWhiR3h2WTBSdmRXSnNaU0E5SUcxaGJHeHZZMFJ2ZFdKc1pWeHVYRzVtZFc1amRHbHZiaUJ0WVd4c2IyTlZhVzUwT0VOc1lXMXdaV1FvYmlrZ2UxeHVJQ0JwWmlob1lYTlZhVzUwT0VNcElIdGNiaUFnSUNCeVpYUjFjbTRnYm1WM0lGVnBiblE0UTJ4aGJYQmxaRUZ5Y21GNUtHMWhiR3h2WTBGeWNtRjVRblZtWm1WeUtHNHBMQ0F3TENCdUtWeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lISmxkSFZ5YmlCdFlXeHNiMk5WYVc1ME9DaHVLVnh1SUNCOVhHNTlYRzVsZUhCdmNuUnpMbTFoYkd4dlkxVnBiblE0UTJ4aGJYQmxaQ0E5SUcxaGJHeHZZMVZwYm5RNFEyeGhiWEJsWkZ4dVhHNW1kVzVqZEdsdmJpQnRZV3hzYjJORVlYUmhWbWxsZHlodUtTQjdYRzRnSUhKbGRIVnliaUJ1WlhjZ1JHRjBZVlpwWlhjb2JXRnNiRzlqUVhKeVlYbENkV1ptWlhJb2Jpa3NJREFzSUc0cFhHNTlYRzVsZUhCdmNuUnpMbTFoYkd4dlkwUmhkR0ZXYVdWM0lEMGdiV0ZzYkc5alJHRjBZVlpwWlhkY2JseHVablZ1WTNScGIyNGdiV0ZzYkc5alFuVm1abVZ5S0c0cElIdGNiaUFnYmlBOUlHSnBkSE11Ym1WNGRGQnZkeklvYmlsY2JpQWdkbUZ5SUd4dloxOXVJRDBnWW1sMGN5NXNiMmN5S0c0cFhHNGdJSFpoY2lCallXTm9aU0E5SUVKVlJrWkZVbHRzYjJkZmJsMWNiaUFnYVdZb1kyRmphR1V1YkdWdVozUm9JRDRnTUNrZ2UxeHVJQ0FnSUhKbGRIVnliaUJqWVdOb1pTNXdiM0FvS1Z4dUlDQjlYRzRnSUhKbGRIVnliaUJ1WlhjZ1FuVm1abVZ5S0c0cFhHNTlYRzVsZUhCdmNuUnpMbTFoYkd4dlkwSjFabVpsY2lBOUlHMWhiR3h2WTBKMVptWmxjbHh1WEc1bGVIQnZjblJ6TG1Oc1pXRnlRMkZqYUdVZ1BTQm1kVzVqZEdsdmJpQmpiR1ZoY2tOaFkyaGxLQ2tnZTF4dUlDQm1iM0lvZG1GeUlHazlNRHNnYVR3ek1qc2dLeXRwS1NCN1hHNGdJQ0FnVUU5UFRDNVZTVTVVT0Z0cFhTNXNaVzVuZEdnZ1BTQXdYRzRnSUNBZ1VFOVBUQzVWU1U1VU1UWmJhVjB1YkdWdVozUm9JRDBnTUZ4dUlDQWdJRkJQVDB3dVZVbE9WRE15VzJsZExteGxibWQwYUNBOUlEQmNiaUFnSUNCUVQwOU1Ma2xPVkRoYmFWMHViR1Z1WjNSb0lEMGdNRnh1SUNBZ0lGQlBUMHd1U1U1VU1UWmJhVjB1YkdWdVozUm9JRDBnTUZ4dUlDQWdJRkJQVDB3dVNVNVVNekpiYVYwdWJHVnVaM1JvSUQwZ01GeHVJQ0FnSUZCUFQwd3VSa3hQUVZSYmFWMHViR1Z1WjNSb0lEMGdNRnh1SUNBZ0lGQlBUMHd1UkU5VlFreEZXMmxkTG14bGJtZDBhQ0E5SURCY2JpQWdJQ0JRVDA5TUxsVkpUbFE0UTF0cFhTNXNaVzVuZEdnZ1BTQXdYRzRnSUNBZ1JFRlVRVnRwWFM1c1pXNW5kR2dnUFNBd1hHNGdJQ0FnUWxWR1JrVlNXMmxkTG14bGJtZDBhQ0E5SURCY2JpQWdmVnh1ZlNKZGZRPT0iLCJtb2R1bGUuZXhwb3J0cy5WZWN0b3JUaWxlID0gcmVxdWlyZSgnLi9saWIvdmVjdG9ydGlsZS5qcycpO1xubW9kdWxlLmV4cG9ydHMuVmVjdG9yVGlsZUZlYXR1cmUgPSByZXF1aXJlKCcuL2xpYi92ZWN0b3J0aWxlZmVhdHVyZS5qcycpO1xubW9kdWxlLmV4cG9ydHMuVmVjdG9yVGlsZUxheWVyID0gcmVxdWlyZSgnLi9saWIvdmVjdG9ydGlsZWxheWVyLmpzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWN0b3JUaWxlTGF5ZXIgPSByZXF1aXJlKCcuL3ZlY3RvcnRpbGVsYXllcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGU7XG5cbmZ1bmN0aW9uIFZlY3RvclRpbGUocGJmLCBlbmQpIHtcbiAgICB0aGlzLmxheWVycyA9IHBiZi5yZWFkRmllbGRzKHJlYWRUaWxlLCB7fSwgZW5kKTtcbn1cblxuZnVuY3Rpb24gcmVhZFRpbGUodGFnLCBsYXllcnMsIHBiZikge1xuICAgIGlmICh0YWcgPT09IDMpIHtcbiAgICAgICAgdmFyIGxheWVyID0gbmV3IFZlY3RvclRpbGVMYXllcihwYmYsIHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zKTtcbiAgICAgICAgaWYgKGxheWVyLmxlbmd0aCkgbGF5ZXJzW2xheWVyLm5hbWVdID0gbGF5ZXI7XG4gICAgfVxufVxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yVGlsZUZlYXR1cmU7XG5cbmZ1bmN0aW9uIFZlY3RvclRpbGVGZWF0dXJlKHBiZiwgZW5kLCBleHRlbnQsIGtleXMsIHZhbHVlcykge1xuICAgIC8vIFB1YmxpY1xuICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xuICAgIHRoaXMuZXh0ZW50ID0gZXh0ZW50O1xuICAgIHRoaXMudHlwZSA9IDA7XG5cbiAgICAvLyBQcml2YXRlXG4gICAgdGhpcy5fcGJmID0gcGJmO1xuICAgIHRoaXMuX2dlb21ldHJ5ID0gLTE7XG4gICAgdGhpcy5fa2V5cyA9IGtleXM7XG4gICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuXG4gICAgcGJmLnJlYWRGaWVsZHMocmVhZEZlYXR1cmUsIHRoaXMsIGVuZCk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGZWF0dXJlKHRhZywgZmVhdHVyZSwgcGJmKSB7XG4gICAgaWYgKHRhZyA9PSAxKSBmZWF0dXJlLl9pZCA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09IDIpIHJlYWRUYWcocGJmLCBmZWF0dXJlKTtcbiAgICBlbHNlIGlmICh0YWcgPT0gMykgZmVhdHVyZS50eXBlID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT0gNCkgZmVhdHVyZS5fZ2VvbWV0cnkgPSBwYmYucG9zO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnKHBiZiwgZmVhdHVyZSkge1xuICAgIHZhciBlbmQgPSBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcztcblxuICAgIHdoaWxlIChwYmYucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciBrZXkgPSBmZWF0dXJlLl9rZXlzW3BiZi5yZWFkVmFyaW50KCldLFxuICAgICAgICAgICAgdmFsdWUgPSBmZWF0dXJlLl92YWx1ZXNbcGJmLnJlYWRWYXJpbnQoKV07XG4gICAgICAgIGZlYXR1cmUucHJvcGVydGllc1trZXldID0gdmFsdWU7XG4gICAgfVxufVxuXG5WZWN0b3JUaWxlRmVhdHVyZS50eXBlcyA9IFsnVW5rbm93bicsICdQb2ludCcsICdMaW5lU3RyaW5nJywgJ1BvbHlnb24nXTtcblxuVmVjdG9yVGlsZUZlYXR1cmUucHJvdG90eXBlLmxvYWRHZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYmYgPSB0aGlzLl9wYmY7XG4gICAgcGJmLnBvcyA9IHRoaXMuX2dlb21ldHJ5O1xuXG4gICAgdmFyIGVuZCA9IHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zLFxuICAgICAgICBjbWQgPSAxLFxuICAgICAgICBsZW5ndGggPSAwLFxuICAgICAgICB4ID0gMCxcbiAgICAgICAgeSA9IDAsXG4gICAgICAgIGxpbmVzID0gW10sXG4gICAgICAgIGxpbmU7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNtZExlbiA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgICAgICAgICBjbWQgPSBjbWRMZW4gJiAweDc7XG4gICAgICAgICAgICBsZW5ndGggPSBjbWRMZW4gPj4gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aC0tO1xuXG4gICAgICAgIGlmIChjbWQgPT09IDEgfHwgY21kID09PSAyKSB7XG4gICAgICAgICAgICB4ICs9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgICAgICAgICAgeSArPSBwYmYucmVhZFNWYXJpbnQoKTtcblxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gMSkgeyAvLyBtb3ZlVG9cbiAgICAgICAgICAgICAgICBpZiAobGluZSkgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmUucHVzaChuZXcgUG9pbnQoeCwgeSkpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY21kID09PSA3KSB7XG4gICAgICAgICAgICBsaW5lLnB1c2gobGluZVswXS5jbG9uZSgpKTsgLy8gY2xvc2VQb2x5Z29uXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjb21tYW5kICcgKyBjbWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxpbmUpIGxpbmVzLnB1c2gobGluZSk7XG5cbiAgICByZXR1cm4gbGluZXM7XG59O1xuXG5WZWN0b3JUaWxlRmVhdHVyZS5wcm90b3R5cGUuYmJveCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYmYgPSB0aGlzLl9wYmY7XG4gICAgcGJmLnBvcyA9IHRoaXMuX2dlb21ldHJ5O1xuXG4gICAgdmFyIGVuZCA9IHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zLFxuICAgICAgICBjbWQgPSAxLFxuICAgICAgICBsZW5ndGggPSAwLFxuICAgICAgICB4ID0gMCxcbiAgICAgICAgeSA9IDAsXG4gICAgICAgIHgxID0gSW5maW5pdHksXG4gICAgICAgIHgyID0gLUluZmluaXR5LFxuICAgICAgICB5MSA9IEluZmluaXR5LFxuICAgICAgICB5MiA9IC1JbmZpbml0eTtcblxuICAgIHdoaWxlIChwYmYucG9zIDwgZW5kKSB7XG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY21kTGVuID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgICAgIGNtZCA9IGNtZExlbiAmIDB4NztcbiAgICAgICAgICAgIGxlbmd0aCA9IGNtZExlbiA+PiAzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoLS07XG5cbiAgICAgICAgaWYgKGNtZCA9PT0gMSB8fCBjbWQgPT09IDIpIHtcbiAgICAgICAgICAgIHggKz0gcGJmLnJlYWRTVmFyaW50KCk7XG4gICAgICAgICAgICB5ICs9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgICAgICAgICAgaWYgKHggPCB4MSkgeDEgPSB4O1xuICAgICAgICAgICAgaWYgKHggPiB4MikgeDIgPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCB5MSkgeTEgPSB5O1xuICAgICAgICAgICAgaWYgKHkgPiB5MikgeTIgPSB5O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY21kICE9PSA3KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY29tbWFuZCAnICsgY21kKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbeDEsIHkxLCB4MiwgeTJdO1xufTtcblxuVmVjdG9yVGlsZUZlYXR1cmUucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuZXh0ZW50ICogTWF0aC5wb3coMiwgeiksXG4gICAgICAgIHgwID0gdGhpcy5leHRlbnQgKiB4LFxuICAgICAgICB5MCA9IHRoaXMuZXh0ZW50ICogeSxcbiAgICAgICAgY29vcmRzID0gdGhpcy5sb2FkR2VvbWV0cnkoKSxcbiAgICAgICAgdHlwZSA9IFZlY3RvclRpbGVGZWF0dXJlLnR5cGVzW3RoaXMudHlwZV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IGNvb3Jkc1tpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGxpbmVbal0sIHkyID0gMTgwIC0gKHAueSArIHkwKSAqIDM2MCAvIHNpemU7XG4gICAgICAgICAgICBsaW5lW2pdID0gW1xuICAgICAgICAgICAgICAgIChwLnggKyB4MCkgKiAzNjAgLyBzaXplIC0gMTgwLFxuICAgICAgICAgICAgICAgIDM2MCAvIE1hdGguUEkgKiBNYXRoLmF0YW4oTWF0aC5leHAoeTIgKiBNYXRoLlBJIC8gMTgwKSkgLSA5MFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnUG9pbnQnICYmIGNvb3Jkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29vcmRzID0gY29vcmRzWzBdWzBdO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1BvaW50Jykge1xuICAgICAgICBjb29yZHMgPSBjb29yZHNbMF07XG4gICAgICAgIHR5cGUgPSAnTXVsdGlQb2ludCc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTGluZVN0cmluZycgJiYgY29vcmRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb29yZHMgPSBjb29yZHNbMF07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTGluZVN0cmluZycpIHtcbiAgICAgICAgdHlwZSA9ICdNdWx0aUxpbmVTdHJpbmcnO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZHNcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcGVydGllczogdGhpcy5wcm9wZXJ0aWVzXG4gICAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWN0b3JUaWxlRmVhdHVyZSA9IHJlcXVpcmUoJy4vdmVjdG9ydGlsZWZlYXR1cmUuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlTGF5ZXI7XG5cbmZ1bmN0aW9uIFZlY3RvclRpbGVMYXllcihwYmYsIGVuZCkge1xuICAgIC8vIFB1YmxpY1xuICAgIHRoaXMudmVyc2lvbiA9IDE7XG4gICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICB0aGlzLmV4dGVudCA9IDQwOTY7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUHJpdmF0ZVxuICAgIHRoaXMuX3BiZiA9IHBiZjtcbiAgICB0aGlzLl9rZXlzID0gW107XG4gICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgdGhpcy5fZmVhdHVyZXMgPSBbXTtcblxuICAgIHBiZi5yZWFkRmllbGRzKHJlYWRMYXllciwgdGhpcywgZW5kKTtcblxuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5fZmVhdHVyZXMubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiByZWFkTGF5ZXIodGFnLCBsYXllciwgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMTUpIGxheWVyLnZlcnNpb24gPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMSkgbGF5ZXIubmFtZSA9IHBiZi5yZWFkU3RyaW5nKCk7XG4gICAgZWxzZSBpZiAodGFnID09PSA1KSBsYXllci5leHRlbnQgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMikgbGF5ZXIuX2ZlYXR1cmVzLnB1c2gocGJmLnBvcyk7XG4gICAgZWxzZSBpZiAodGFnID09PSAzKSBsYXllci5fa2V5cy5wdXNoKHBiZi5yZWFkU3RyaW5nKCkpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNCkgbGF5ZXIuX3ZhbHVlcy5wdXNoKHJlYWRWYWx1ZU1lc3NhZ2UocGJmKSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRWYWx1ZU1lc3NhZ2UocGJmKSB7XG4gICAgdmFyIHZhbHVlID0gbnVsbCxcbiAgICAgICAgZW5kID0gcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3M7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIgdGFnID0gcGJmLnJlYWRWYXJpbnQoKSA+PiAzO1xuXG4gICAgICAgIHZhbHVlID0gdGFnID09PSAxID8gcGJmLnJlYWRTdHJpbmcoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDIgPyBwYmYucmVhZEZsb2F0KCkgOlxuICAgICAgICAgICAgdGFnID09PSAzID8gcGJmLnJlYWREb3VibGUoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDQgPyBwYmYucmVhZFZhcmludDY0KCkgOlxuICAgICAgICAgICAgdGFnID09PSA1ID8gcGJmLnJlYWRWYXJpbnQoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDYgPyBwYmYucmVhZFNWYXJpbnQoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDcgPyBwYmYucmVhZEJvb2xlYW4oKSA6IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyByZXR1cm4gZmVhdHVyZSBgaWAgZnJvbSB0aGlzIGxheWVyIGFzIGEgYFZlY3RvclRpbGVGZWF0dXJlYFxuVmVjdG9yVGlsZUxheWVyLnByb3RvdHlwZS5mZWF0dXJlID0gZnVuY3Rpb24oaSkge1xuICAgIGlmIChpIDwgMCB8fCBpID49IHRoaXMuX2ZlYXR1cmVzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdmZWF0dXJlIGluZGV4IG91dCBvZiBib3VuZHMnKTtcblxuICAgIHRoaXMuX3BiZi5wb3MgPSB0aGlzLl9mZWF0dXJlc1tpXTtcblxuICAgIHZhciBlbmQgPSB0aGlzLl9wYmYucmVhZFZhcmludCgpICsgdGhpcy5fcGJmLnBvcztcbiAgICByZXR1cm4gbmV3IFZlY3RvclRpbGVGZWF0dXJlKHRoaXMuX3BiZiwgZW5kLCB0aGlzLmV4dGVudCwgdGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzKTtcbn07XG4iLCJpbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy91dGlscyc7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tICcuL2dsL3NoYWRlcl9wcm9ncmFtJztcbmltcG9ydCB7bWF0NCwgbWF0MywgdmVjM30gZnJvbSAnLi91dGlscy9nbC1tYXRyaXgnO1xuXG4vLyBBYnN0cmFjdCBiYXNlIGNsYXNzXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYW1lcmEge1xuXG4gICAgY29uc3RydWN0b3IobmFtZSwgdmlldywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLnpvb20gPSBvcHRpb25zLnpvb207XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgY2FtZXJhIGJ5IHR5cGUgbmFtZSwgZmFjdG9yeS1zdHlsZVxuICAgIHN0YXRpYyBjcmVhdGUobmFtZSwgdmlldywgY29uZmlnKSB7XG4gICAgICAgIHN3aXRjaCAoY29uZmlnLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2lzb21ldHJpYyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJc29tZXRyaWNDYW1lcmEobmFtZSwgdmlldywgY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ2ZsYXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxhdENhbWVyYShuYW1lLCB2aWV3LCBjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAncGVyc3BlY3RpdmUnOlxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKG5hbWUsIHZpZXcsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgbWV0aG9kIGNhbGxlZCBvbmNlIHBlciBmcmFtZVxuICAgIHVwZGF0ZSgpIHtcbiAgICB9XG5cbiAgICAvLyBDYWxsZWQgb25jZSBwZXIgZnJhbWUgcGVyIHByb2dyYW0gKGUuZy4gZm9yIG1haW4gcmVuZGVyIHBhc3MsIHRoZW4gZm9yIGVhY2ggYWRkaXRpb25hbCBwYXNzIGZvciBmZWF0dXJlIHNlbGVjdGlvbiwgZXRjLilcbiAgICBzZXR1cFByb2dyYW0ocHJvZ3JhbSkge1xuICAgIH1cblxuICAgIC8vIFN5bmMgY2FtZXJhIHBvc2l0aW9uL3pvb20gdG8gc2NlbmUgdmlld1xuICAgIHVwZGF0ZVZpZXcgKCkge1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiB8fCB0aGlzLnpvb20pIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHZpZXcgPSB7IGxuZzogdGhpcy5wb3NpdGlvblswXSwgbGF0OiB0aGlzLnBvc2l0aW9uWzFdLCB6b29tOiB0aGlzLnBvc2l0aW9uWzJdIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy56b29tKSB7XG4gICAgICAgICAgICAgICAgdmlldy56b29tID0gdGhpcy56b29tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWV3LnNldFZpZXcodmlldyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgbW9kZWwtdmlldyBhbmQgbm9ybWFsIG1hdHJpY2VzXG4gICAgc2V0dXBNYXRyaWNlcyAobWF0cmljZXMsIHByb2dyYW0pIHtcbiAgICAgICAgLy8gTW9kZWwgdmlldyBtYXRyaXggLSB0cmFuc2Zvcm0gdGlsZSBzcGFjZSBpbnRvIHZpZXcgc3BhY2UgKG1ldGVycywgcmVsYXRpdmUgdG8gY2FtZXJhKVxuICAgICAgICBtYXQ0Lm11bHRpcGx5KG1hdHJpY2VzLm1vZGVsX3ZpZXczMiwgdGhpcy52aWV3X21hdHJpeCwgbWF0cmljZXMubW9kZWwpO1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJ01hdHJpeDRmdicsICd1X21vZGVsVmlldycsIGZhbHNlLCBtYXRyaWNlcy5tb2RlbF92aWV3MzIpO1xuXG4gICAgICAgIC8vIE5vcm1hbCBtYXRyaWNlcyAtIHRyYW5zZm9ybXMgc3VyZmFjZSBub3JtYWxzIGludG8gdmlldyBzcGFjZVxuICAgICAgICBtYXQzLm5vcm1hbEZyb21NYXQ0KG1hdHJpY2VzLm5vcm1hbDMyLCBtYXRyaWNlcy5tb2RlbF92aWV3MzIpO1xuICAgICAgICBtYXQzLmludmVydChtYXRyaWNlcy5pbnZlcnNlX25vcm1hbDMyLCBtYXRyaWNlcy5ub3JtYWwzMik7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnTWF0cml4M2Z2JywgJ3Vfbm9ybWFsTWF0cml4JywgZmFsc2UsIG1hdHJpY2VzLm5vcm1hbDMyKTtcbiAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCdNYXRyaXgzZnYnLCAndV9pbnZlcnNlTm9ybWFsTWF0cml4JywgZmFsc2UsIG1hdHJpY2VzLmludmVyc2Vfbm9ybWFsMzIpO1xuICAgIH1cblxufVxuXG4vKipcbiAgICBQZXJzcGVjdGl2ZSBtYXRyaXggcHJvamVjdGlvblxuXG4gICAgVGhpcyBpcyBhIHNwZWNpYWxpemVkIHBlcnNwZWN0aXZlIGNhbWVyYSB0aGF0LCBnaXZlbiBhIGRlc2lyZWQgY2FtZXJhIGZvY2FsIGxlbmd0aCAod2hpY2ggY2FuIGFsc28gdmFyeSBieSB6b29tIGxldmVsKSxcbiAgICBjb25zdHJhaW5zIHRoZSBjYW1lcmEgaGVpZ2h0IGFib3ZlIHRoZSBncm91bmQgcGxhbmUgc3VjaCB0aGF0IHRoZSBkaXNwbGF5ZWQgZ3JvdW5kIGFyZWEgb2YgdGhlIG1hcCBtYXRjaGVzIHRoYXQgb2ZcbiAgICBhIHRyYWRpdGlvbmFsIHdlYiBtZXJjYXRvciBtYXAuIFRoaXMgbWVhbnMgeW91IGNhbiBzZXQgdGhlIGNhbWVyYSBsb2NhdGlvbiBieSBbbGF0LCBsbmcsIHpvb21dIGFzIHlvdSB3b3VsZCBhIHR5cGljYWxcbiAgICB3ZWIgbWVyY2F0b3IgbWFwLCB0aGVuIGFkanVzdCB0aGUgZm9jYWwgbGVuZ3RoIGFzIG5lZWRlZC5cblxuICAgIFZhbmlzaGluZyBwb2ludCBjYW4gYWxzbyBiZSBhZGp1c3RlZCB0byBhY2hpZXZlIGRpZmZlcmVudCBcInZpZXdpbmcgYW5nbGVzXCIsIGUuZy4gaW5zdGVhZCBvZiBsb29raW5nIHN0cmFpZ2h0IGRvd24gaW50b1xuICAgIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0LCB0aGUgY2FtZXJhIGFwcGVhcnMgdG8gYmUgdGlsdGVkIGF0IGFuIGFuZ2xlLiBGb3IgZXhhbXBsZTpcblxuICAgIFswLCAwXSA9IGxvb2tpbmcgdG93YXJkcyBjZW50ZXIgb2Ygdmlld3BvcnRcbiAgICBbLTI1MCwgLTI1MF0gPSBsb29raW5nIDI1MCBwaXhlbHMgZnJvbSB0aGUgdmlld3BvcnQgY2VudGVyIHRvIHRoZSBsb3dlci1sZWZ0IGNvcm5lclxuICAgIFs0MDAsIDBdID0gbG9va2luZyA0MDAgcGl4ZWxzIHRvIHRoZSByaWdodCBvZiB0aGUgdmlld3BvcnQgY2VudGVyXG4qL1xuY2xhc3MgUGVyc3BlY3RpdmVDYW1lcmEgZXh0ZW5kcyBDYW1lcmEge1xuXG4gICAgY29uc3RydWN0b3IobmFtZSwgdmlldywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIHZpZXcsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAncGVyc3BlY3RpdmUnO1xuXG4gICAgICAgIC8vIGEgc2luZ2xlIHNjYWxhciwgb3IgcGFpcnMgb2Ygc3RvcHMgbWFwcGluZyB6b29tIGxldmVscywgZS5nLiBbem9vbSwgZm9jYWwgbGVuZ3RoXVxuICAgICAgICB0aGlzLmZvY2FsX2xlbmd0aCA9IG9wdGlvbnMuZm9jYWxfbGVuZ3RoO1xuICAgICAgICB0aGlzLmZvdiA9IG9wdGlvbnMuZm92O1xuICAgICAgICBpZiAoIXRoaXMuZm9jYWxfbGVuZ3RoICYmICF0aGlzLmZvdikge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBmb2NhbCBsZW5ndGggcmFuZ2VzIGJ5IHpvb21cbiAgICAgICAgICAgIHRoaXMuZm9jYWxfbGVuZ3RoID0gW1sxNiwgMl0sIFsxNywgMi41XSwgWzE4LCAzXSwgWzE5LCA0XSwgWzIwLCA2XV07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZhbmlzaGluZ19wb2ludCA9IG9wdGlvbnMudmFuaXNoaW5nX3BvaW50IHx8IFswLCAwXTsgLy8gW3gsIHldXG4gICAgICAgIHRoaXMudmFuaXNoaW5nX3BvaW50ID0gdGhpcy52YW5pc2hpbmdfcG9pbnQubWFwKHBhcnNlRmxvYXQpOyAvLyB3ZSBpbXBsaWNpdGx5IG9ubHkgc3VwcG9ydCBweCB1bml0cyBoZXJlXG4gICAgICAgIHRoaXMudmFuaXNoaW5nX3BvaW50X3NrZXcgPSBbXTtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uX21ldGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMudmlld19tYXRyaXggPSBuZXcgRmxvYXQ2NEFycmF5KDE2KTtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uX21hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuXG4gICAgICAgIC8vICdjYW1lcmEnIGlzIHRoZSBuYW1lIG9mIHRoZSBzaGFkZXIgYmxvY2ssIGUuZy4gZGV0ZXJtaW5lcyB3aGVyZSBpbiB0aGUgc2hhZGVyIHRoaXMgY29kZSBpcyBpbmplY3RlZFxuICAgICAgICBTaGFkZXJQcm9ncmFtLnJlcGxhY2VCbG9jaygnY2FtZXJhJywgYFxuICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcHJvamVjdGlvbjtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMyB1X2V5ZTtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMiB1X3ZhbmlzaGluZ19wb2ludDtcblxuICAgICAgICAgICAgdm9pZCBjYW1lcmFQcm9qZWN0aW9uIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSB1X3Byb2plY3Rpb24gKiBwb3NpdGlvbjtcbiAgICAgICAgICAgIH1gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQ29uc3RyYWlucyB0aGUgY2FtZXJhIHNvIHRoYXQgdGhlIHZpZXdhYmxlIGFyZWEgbWF0Y2hlcyBnaXZlbiB0aGUgdmlld3BvcnQgaGVpZ2h0XG4gICAgLy8gKGluIHdvcmxkIHNwYWNlLCBlLmcuIG1ldGVycyksIGdpdmVuIGVpdGhlciBhIGNhbWVyYSBmb2NhbCBsZW5ndGggb3IgZmllbGQtb2Ytdmlld1xuICAgIC8vIChmb2NhbCBsZW5ndGggaXMgdXNlZCBpZiBib3RoIGFyZSBwYXNzZWQpLlxuICAgIGNvbnN0cmFpbkNhbWVyYSh7IHZpZXdfaGVpZ2h0LCBoZWlnaHQsIGZvY2FsX2xlbmd0aCwgZm92IH0pIHtcbiAgICAgICAgLy8gU29sdmUgZm9yIGNhbWVyYSBoZWlnaHRcbiAgICAgICAgaWYgKCFoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgZm9jYWwgbGVuZ3RoLCBjYWxjdWxhdGUgRk9WXG4gICAgICAgICAgICBpZiAoZm9jYWxfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm92ID0gTWF0aC5hdGFuKDEgLyBmb2NhbF9sZW5ndGgpICogMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGhhdmUgRk9WLCBjYWxjdWxhdGUgZm9jYWwgbGVuZ3RoXG4gICAgICAgICAgICBlbHNlIGlmIChmb3YpIHtcbiAgICAgICAgICAgICAgICBmb3YgPSBmb3YgKiBNYXRoLlBJIC8gMTgwOyAvLyBjb252ZXJ0IEZPViBkZWdyZWVzIHRvIHJhZGlhbnNcbiAgICAgICAgICAgICAgICBmb2NhbF9sZW5ndGggPSAxIC8gTWF0aC50YW4oZm92IC8gMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc3RhbmNlIHRoYXQgY2FtZXJhIHNob3VsZCBiZSBmcm9tIGdyb3VuZCBzdWNoIHRoYXQgaXQgZml0cyB0aGUgZmllbGQgb2YgdmlldyBleHBlY3RlZFxuICAgICAgICAgICAgLy8gZm9yIGEgY29udmVudGlvbmFsIHdlYiBtZXJjYXRvciBtYXAgYXQgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBhbmQgY2FtZXJhIGZvY2FsIGxlbmd0aFxuICAgICAgICAgICAgaGVpZ2h0ID0gdmlld19oZWlnaHQgLyAyICogZm9jYWxfbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbHZlIGZvciBjYW1lcmEgZm9jYWwgbGVuZ3RoIC8gZmllbGQtb2Ytdmlld1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvY2FsX2xlbmd0aCA9IDIgKiBoZWlnaHQgLyB2aWV3X2hlaWdodDtcbiAgICAgICAgICAgIGZvdiA9IE1hdGguYXRhbigxIC8gZm9jYWxfbGVuZ3RoKSAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB2aWV3X2hlaWdodCwgaGVpZ2h0LCBmb2NhbF9sZW5ndGgsIGZvdiB9O1xuICAgIH1cblxuICAgIHVwZGF0ZU1hdHJpY2VzKCkge1xuICAgICAgICAvLyBUT0RPOiBvbmx5IHJlLWNhbGN1bGF0ZSB0aGVzZSB2YXJzIHdoZW4gbmVjZXNzYXJ5XG5cbiAgICAgICAgLy8gSGVpZ2h0IG9mIHRoZSB2aWV3cG9ydCBpbiBtZXRlcnMgYXQgY3VycmVudCB6b29tXG4gICAgICAgIHZhciB2aWV3cG9ydF9oZWlnaHQgPSB0aGlzLnZpZXcuc2l6ZS5jc3MuaGVpZ2h0ICogdGhpcy52aWV3Lm1ldGVyc19wZXJfcGl4ZWw7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBjYW1lcmEgcHJvcGVydGllcyB0byBmaXQgZGVzaXJlZCB2aWV3XG4gICAgICAgIHZhciB7IGhlaWdodCwgZm92IH0gPSB0aGlzLmNvbnN0cmFpbkNhbWVyYSh7XG4gICAgICAgICAgICB2aWV3X2hlaWdodDogdmlld3BvcnRfaGVpZ2h0LFxuICAgICAgICAgICAgZm9jYWxfbGVuZ3RoOiBVdGlscy5pbnRlcnBvbGF0ZSh0aGlzLnZpZXcuem9vbSwgdGhpcy5mb2NhbF9sZW5ndGgpLFxuICAgICAgICAgICAgZm92OiBVdGlscy5pbnRlcnBvbGF0ZSh0aGlzLnZpZXcuem9vbSwgdGhpcy5mb3YpXG4gICAgICAgICB9KTtcblxuICAgICAgICAvLyBWaWV3IG1hdHJpeFxuICAgICAgICB2YXIgcG9zaXRpb24gPSBbdGhpcy52aWV3LmNlbnRlci5tZXRlcnMueCwgdGhpcy52aWV3LmNlbnRlci5tZXRlcnMueSwgaGVpZ2h0XTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbl9tZXRlcnMgPSBwb3NpdGlvbjtcblxuICAgICAgICAvLyBtYXQ0Lmxvb2tBdCh0aGlzLnZpZXdfbWF0cml4LFxuICAgICAgICAvLyAgICAgdmVjMy5mcm9tVmFsdWVzKC4uLnBvc2l0aW9uKSxcbiAgICAgICAgLy8gICAgIHZlYzMuZnJvbVZhbHVlcyhwb3NpdGlvblswXSwgcG9zaXRpb25bMV0sIGhlaWdodCAtIDEpLFxuICAgICAgICAvLyAgICAgdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApKTtcbiAgICAgICAgLy8gRXhjbHVkZSBjYW1lcmEgaGVpZ2h0IGZyb20gdmlldyBtYXRyaXhcbiAgICAgICAgbWF0NC5sb29rQXQodGhpcy52aWV3X21hdHJpeCxcbiAgICAgICAgICAgIHZlYzMuZnJvbVZhbHVlcyhwb3NpdGlvblswXSwgcG9zaXRpb25bMV0sIDApLFxuICAgICAgICAgICAgdmVjMy5mcm9tVmFsdWVzKHBvc2l0aW9uWzBdLCBwb3NpdGlvblsxXSwgLTEpLFxuICAgICAgICAgICAgdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApKTtcblxuICAgICAgICAvLyBQcm9qZWN0aW9uIG1hdHJpeFxuICAgICAgICBtYXQ0LnBlcnNwZWN0aXZlKHRoaXMucHJvamVjdGlvbl9tYXRyaXgsIGZvdiwgdGhpcy52aWV3LmFzcGVjdCwgMSwgaGVpZ2h0ICogMik7XG5cbiAgICAgICAgLy8gQ29udmVydCB2YW5pc2hpbmcgcG9pbnQgZnJvbSBwaXhlbHMgdG8gdmlld3BvcnQgc3BhY2VcbiAgICAgICAgdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tld1swXSA9IHRoaXMudmFuaXNoaW5nX3BvaW50WzBdIC8gdGhpcy52aWV3LnNpemUuY3NzLndpZHRoO1xuICAgICAgICB0aGlzLnZhbmlzaGluZ19wb2ludF9za2V3WzFdID0gdGhpcy52YW5pc2hpbmdfcG9pbnRbMV0gLyB0aGlzLnZpZXcuc2l6ZS5jc3MuaGVpZ2h0O1xuXG4gICAgICAgIC8vIEFkanVzdCBwcm9qZWN0aW9uIG1hdHJpeCB0byBpbmNsdWRlIHZhbmlzaGluZyBwb2ludCBza2V3XG4gICAgICAgIHRoaXMucHJvamVjdGlvbl9tYXRyaXhbOF0gPSAtdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tld1swXTsgLy8geiBjb2x1bW4gb2YgeCByb3csIGUuZy4gYW1vdW50IHogc2tld3MgeFxuICAgICAgICB0aGlzLnByb2plY3Rpb25fbWF0cml4WzldID0gLXRoaXMudmFuaXNoaW5nX3BvaW50X3NrZXdbMV07IC8vIHogY29sdW1uIG9mIHkgcm93LCBlLmcuIGFtb3VudCB6IHNrZXdzIHlcblxuICAgICAgICAvLyBUcmFuc2xhdGUgZ2VvbWV0cnkgaW50byB0aGUgZGlzdGFuY2Ugc28gdGhhdCBjYW1lcmEgaXMgYXBwcm9wcmlhdGUgaGVpZ2h0IGFib3ZlIGdyb3VuZFxuICAgICAgICAvLyBBZGRpdGlvbmFsbHksIGFkanVzdCB4eSB0byBjb21wZW5zYXRlIGZvciBhbnkgdmFuaXNoaW5nIHBvaW50IHNrZXcsIGUuZy4gbW92ZSBnZW9tZXRyeSBzbyB0aGF0IHRoZSBkaXNwbGF5ZWQgZ1xuICAgICAgICAvLyBwbGFuZSBvZiB0aGUgbWFwIG1hdGNoZXMgdGhhdCBleHBlY3RlZCBieSBhIHRyYWRpdGlvbmFsIHdlYiBtZXJjYXRvciBtYXAgYXQgdGhpcyBbbGF0LCBsbmcsIHpvb21dLlxuICAgICAgICBtYXQ0LnRyYW5zbGF0ZSh0aGlzLnByb2plY3Rpb25fbWF0cml4LCB0aGlzLnByb2plY3Rpb25fbWF0cml4LFxuICAgICAgICAgICAgdmVjMy5mcm9tVmFsdWVzKFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0X2hlaWdodC8yICogdGhpcy52aWV3LmFzcGVjdCAqIC10aGlzLnZhbmlzaGluZ19wb2ludF9za2V3WzBdLFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0X2hlaWdodC8yICogLXRoaXMudmFuaXNoaW5nX3BvaW50X3NrZXdbMV0sXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEluY2x1ZGUgY2FtZXJhIGhlaWdodCBpbiBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAgICBtYXQ0LnRyYW5zbGF0ZSh0aGlzLnByb2plY3Rpb25fbWF0cml4LCB0aGlzLnByb2plY3Rpb25fbWF0cml4LCB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgLWhlaWdodCkpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTWF0cmljZXMoKTtcbiAgICB9XG5cbiAgICBzZXR1cFByb2dyYW0ocHJvZ3JhbSkge1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJ01hdHJpeDRmdicsICd1X3Byb2plY3Rpb24nLCBmYWxzZSwgdGhpcy5wcm9qZWN0aW9uX21hdHJpeCk7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnM2YnLCAndV9leWUnLCAwLCAwLCB0aGlzLnBvc2l0aW9uX21ldGVyc1syXSk7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnMmZ2JywgJ3VfdmFuaXNoaW5nX3BvaW50JywgdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tldyk7XG4gICAgfVxuXG59XG5cbi8vIElzb21ldHJpYy1zdHlsZSBwcm9qZWN0aW9uXG4vLyBOb3RlOiB0aGlzIGlzIGFjdHVhbGx5IGFuIFwiYXhvbm9tZXRyaWNcIiBwcm9qZWN0aW9uLCBidXQgSSdtIHVzaW5nIHRoZSBjb2xsb3F1aWFsIHRlcm0gaXNvbWV0cmljIGJlY2F1c2UgaXQgaXMgbW9yZSByZWNvZ25pemFibGUuXG4vLyBBbiBpc29tZXRyaWMgcHJvamVjdGlvbiBpcyBhIHNwZWNpZmljIHN1YnNldCBvZiBheG9ub21ldHJpYyBwcm9qZWN0aW9ucy5cbi8vICdheGlzJyBkZXRlcm1pbmVzIHRoZSB4eSBza2V3IGFwcGxpZWQgdG8gYSB2ZXJ0ZXggYmFzZWQgb24gaXRzIHogY29vcmRpbmF0ZSwgZS5nLiBbMCwgMV0gYXhpcyBjYXVzZXMgYnVpbGRpbmdzIHRvIGJlIGRyYXduXG4vLyBzdHJhaWdodCB1cHdhcmRzIG9uIHNjcmVlbiBhdCB0aGVpciB0cnVlIGhlaWdodCwgWzAsIC41XSB3b3VsZCBkcmF3IHRoZW0gdXAgYXQgaGFsZi1oZWlnaHQsIFsxLCAwXSB3b3VsZCBiZSBzaWRld2F5cywgZXRjLlxuY2xhc3MgSXNvbWV0cmljQ2FtZXJhIGV4dGVuZHMgQ2FtZXJhIHtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHZpZXcsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcihuYW1lLCB2aWV3LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2lzb21ldHJpYyc7XG4gICAgICAgIHRoaXMuYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCB7IHg6IDAsIHk6IDEgfTtcbiAgICAgICAgaWYgKHRoaXMuYXhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMuYXhpcyA9IHsgeDogdGhpcy5heGlzWzBdLCB5OiB0aGlzLmF4aXNbMV0gfTsgLy8gYWxsb3cgYXhpcyB0byBhbHNvIGJlIHBhc3NlZCBhcyAyLWVsZW0gYXJyYXlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucG9zaXRpb25fbWV0ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy52aWV3cG9ydF9oZWlnaHQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMudmlld19tYXRyaXggPSBuZXcgRmxvYXQ2NEFycmF5KDE2KTtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uX21hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuXG4gICAgICAgIC8vICdjYW1lcmEnIGlzIHRoZSBuYW1lIG9mIHRoZSBzaGFkZXIgYmxvY2ssIGUuZy4gZGV0ZXJtaW5lcyB3aGVyZSBpbiB0aGUgc2hhZGVyIHRoaXMgY29kZSBpcyBpbmplY3RlZFxuICAgICAgICBTaGFkZXJQcm9ncmFtLnJlcGxhY2VCbG9jaygnY2FtZXJhJywgYFxuICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcHJvamVjdGlvbjtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMyB1X2V5ZTtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMiB1X3ZhbmlzaGluZ19wb2ludDtcblxuICAgICAgICAgICAgdm9pZCBjYW1lcmFQcm9qZWN0aW9uIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSB1X3Byb2plY3Rpb24gKiBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbi54eSArPSBwb3NpdGlvbi56ICogdV9pc29tZXRyaWNfYXhpcztcblxuICAgICAgICAgICAgICAgIC8vIFJldmVyc2UgeiBmb3IgZGVwdGggYnVmZmVyIHNvIHVwIGlzIG5lZ2F0aXZlLFxuICAgICAgICAgICAgICAgIC8vIGFuZCBzY2FsZSBkb3duIHZhbHVlcyBzbyBvYmplY3RzIGhpZ2hlciB0aGFuIG9uZSBzY3JlZW4gaGVpZ2h0IHdpbGwgbm90IGdldCBjbGlwcGVkXG4gICAgICAgICAgICAgICAgLy8gcHVsbCBmb3J3YXJkIHNsaWdodGx5IHRvIGF2b2lkIGdvaW5nIHBhc3QgZmFyIGNsaXBwaW5nIHBsYW5lXG4gICAgICAgICAgICAgICAgcG9zaXRpb24ueiA9IC1wb3NpdGlvbi56IC8gMTAwLiArIDEuIC0gMC4wMDE7XG4gICAgICAgICAgICB9YFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKCk7XG5cbiAgICAgICAgdGhpcy52aWV3cG9ydF9oZWlnaHQgPSB0aGlzLnZpZXcuc2l6ZS5jc3MuaGVpZ2h0ICogdGhpcy52aWV3Lm1ldGVyc19wZXJfcGl4ZWw7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IFt0aGlzLnZpZXcuY2VudGVyLm1ldGVycy54LCB0aGlzLnZpZXcuY2VudGVyLm1ldGVycy55LCB0aGlzLnZpZXdwb3J0X2hlaWdodF07XG4gICAgICAgIHRoaXMucG9zaXRpb25fbWV0ZXJzID0gcG9zaXRpb247XG5cbiAgICAgICAgLy8gVmlld1xuICAgICAgICBtYXQ0LmlkZW50aXR5KHRoaXMudmlld19tYXRyaXgpO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZSh0aGlzLnZpZXdfbWF0cml4LCB0aGlzLnZpZXdfbWF0cml4LCB2ZWMzLmZyb21WYWx1ZXMoLXBvc2l0aW9uWzBdLCAtcG9zaXRpb25bMV0sIDApKTtcblxuICAgICAgICAvLyBQcm9qZWN0aW9uXG4gICAgICAgIG1hdDQuaWRlbnRpdHkodGhpcy5wcm9qZWN0aW9uX21hdHJpeCk7XG5cbiAgICAgICAgLy8gYXBwbHkgaXNvbWV0cmljIHNrZXdcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uX21hdHJpeFs4XSA9IHRoaXMuYXhpcy54IC8gdGhpcy52aWV3LmFzcGVjdDsgLy8geiBjb2x1bW4gb2YgeCByb3csIGUuZy4gYW1vdW50IHogc2tld3MgeFxuICAgICAgICB0aGlzLnByb2plY3Rpb25fbWF0cml4WzldID0gdGhpcy5heGlzLnk7ICAgICAgICAgICAgICAgICAgICAvLyB6IGNvbHVtbiBvZiB4IHJvdywgZS5nLiBhbW91bnQgeiBza2V3cyB5XG5cbiAgICAgICAgLy8gY29udmVydCBtZXRlcnMgdG8gdmlld3BvcnRcbiAgICAgICAgbWF0NC5zY2FsZSh0aGlzLnByb2plY3Rpb25fbWF0cml4LCB0aGlzLnByb2plY3Rpb25fbWF0cml4LFxuICAgICAgICAgICAgdmVjMy5mcm9tVmFsdWVzKFxuICAgICAgICAgICAgICAgIDIgLyB0aGlzLnZpZXcuc2l6ZS5tZXRlcnMueCxcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy52aWV3LnNpemUubWV0ZXJzLnksXG4gICAgICAgICAgICAgICAgMiAvIHRoaXMudmlldy5zaXplLm1ldGVycy55XG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9ncmFtKHByb2dyYW0pIHtcbiAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCdNYXRyaXg0ZnYnLCAndV9wcm9qZWN0aW9uJywgZmFsc2UsIHRoaXMucHJvamVjdGlvbl9tYXRyaXgpO1xuXG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnM2YnLCAndV9leWUnLCAwLCAwLCB0aGlzLnZpZXdwb3J0X2hlaWdodCk7XG4gICAgICAgIC8vIHByb2dyYW0udW5pZm9ybSgnM2YnLCAndV9leWUnLCB0aGlzLnZpZXdwb3J0X2hlaWdodCAqIHRoaXMuYXhpcy54LCB0aGlzLnZpZXdwb3J0X2hlaWdodCAqIHRoaXMuYXhpcy55LCB0aGlzLnZpZXdwb3J0X2hlaWdodCk7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnMmYnLCAndV92YW5pc2hpbmdfcG9pbnQnLCAwLCAwKTtcbiAgICB9XG5cbn1cblxuLy8gRmxhdCBwcm9qZWN0aW9uIChlLmcuIGp1c3QgdG9wLWRvd24sIG5vIHBlcnNwZWN0aXZlKSAtIGEgZGVnZW5lcmF0ZSBpc29tZXRyaWMgY2FtZXJhXG5jbGFzcyBGbGF0Q2FtZXJhIGV4dGVuZHMgSXNvbWV0cmljQ2FtZXJhIHtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHZpZXcsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcihuYW1lLCB2aWV3LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2ZsYXQnO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgLy8gQXhpcyBpcyBmaXhlZCB0byAoMCwgMCkgZm9yIGZsYXQgY2FtZXJhXG4gICAgICAgIHRoaXMuYXhpcy54ID0gMDtcbiAgICAgICAgdGhpcy5heGlzLnkgPSAwO1xuXG4gICAgICAgIHN1cGVyLnVwZGF0ZSgpO1xuICAgIH1cblxufVxuIiwiLy8gTWlzY2VsbGFuZW91cyBnZW8gZnVuY3Rpb25zXG5cbnZhciBHZW87XG5leHBvcnQgZGVmYXVsdCBHZW8gPSB7fTtcblxuLy8gUHJvamVjdGlvbiBjb25zdGFudHNcbkdlby5kZWZhdWx0X3NvdXJjZV9tYXhfem9vbSA9IDE4O1xuR2VvLmRlZmF1bHRfdmlld19tYXhfem9vbSA9IDIwO1xuR2VvLnRpbGVfc2l6ZSA9IDI1Njtcbkdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzID0gMjAwMzc1MDguMzQyNzg5MjQ0O1xuR2VvLmNpcmN1bWZlcmVuY2VfbWV0ZXJzID0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMgKiAyO1xuR2VvLm1pbl96b29tX21ldGVyc19wZXJfcGl4ZWwgPSBHZW8uY2lyY3VtZmVyZW5jZV9tZXRlcnMgLyBHZW8udGlsZV9zaXplOyAvLyBtaW4gem9vbSBkcmF3cyB3b3JsZCBhcyAyIHRpbGVzIHdpZGVcblxubGV0IG1ldGVyc19wZXJfcGl4ZWwgPSBbXTtcbkdlby5tZXRlcnNQZXJQaXhlbCA9IGZ1bmN0aW9uICh6KSB7XG4gICAgbWV0ZXJzX3Blcl9waXhlbFt6XSA9IG1ldGVyc19wZXJfcGl4ZWxbel0gfHwgR2VvLm1pbl96b29tX21ldGVyc19wZXJfcGl4ZWwgLyBNYXRoLnBvdygyLCB6KTtcbiAgICByZXR1cm4gbWV0ZXJzX3Blcl9waXhlbFt6XTtcbn07XG5cbmxldCBtZXRlcnNfcGVyX3RpbGUgPSBbXTtcbkdlby5tZXRlcnNQZXJUaWxlID0gZnVuY3Rpb24gKHopIHtcbiAgICBtZXRlcnNfcGVyX3RpbGVbel0gPSBtZXRlcnNfcGVyX3RpbGVbel0gfHwgR2VvLmNpcmN1bWZlcmVuY2VfbWV0ZXJzIC8gTWF0aC5wb3coMiwgeik7XG4gICAgcmV0dXJuIG1ldGVyc19wZXJfdGlsZVt6XTtcbn07XG5cbi8vIENvbnZlcnNpb24gZnVuY3Rpb25zIGJhc2VkIG9uIGFuIGRlZmluZWQgdGlsZSBzY2FsZVxuR2VvLnRpbGVfc2NhbGUgPSA0MDk2OyAvLyBjb29yZGluYXRlcyBhcmUgbG9jYWxseSBzY2FsZWQgdG8gdGhlIHJhbmdlIFswLCB0aWxlX3NjYWxlXVxuR2VvLnVuaXRzX3Blcl9waXhlbCA9IEdlby50aWxlX3NjYWxlIC8gR2VvLnRpbGVfc2l6ZTtcblxubGV0IHVuaXRzX3Blcl9tZXRlciA9IFtdO1xuR2VvLnVuaXRzUGVyTWV0ZXIgPSBmdW5jdGlvbiAoeikge1xuICAgIHVuaXRzX3Blcl9tZXRlclt6XSA9IHVuaXRzX3Blcl9tZXRlclt6XSB8fCBHZW8udGlsZV9zY2FsZSAvIChHZW8udGlsZV9zaXplICogR2VvLm1ldGVyc1BlclBpeGVsKHopKTtcbiAgICByZXR1cm4gdW5pdHNfcGVyX21ldGVyW3pdO1xufTtcblxuLy8gQ29udmVydCB0aWxlIGxvY2F0aW9uIHRvIG1lcmNhdG9yIG1ldGVycyAtIG11bHRpcGx5IGJ5IHBpeGVscyBwZXIgdGlsZSwgdGhlbiBieSBtZXRlcnMgcGVyIHBpeGVsLCBhZGp1c3QgZm9yIG1hcCBvcmlnaW5cbkdlby5tZXRlcnNGb3JUaWxlID0gZnVuY3Rpb24gKHRpbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB0aWxlLnggKiBHZW8uY2lyY3VtZmVyZW5jZV9tZXRlcnMgLyBNYXRoLnBvdygyLCB0aWxlLnopIC0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMsXG4gICAgICAgIHk6IC0odGlsZS55ICogR2VvLmNpcmN1bWZlcmVuY2VfbWV0ZXJzIC8gTWF0aC5wb3coMiwgdGlsZS56KSAtIEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzKVxuICAgIH07XG59O1xuXG4vKipcbiAgIEdpdmVuIGEgcG9pbnQgaW4gbWVyY2F0b3IgbWV0ZXJzIGFuZCBhIHpvb20gbGV2ZWwsIHJldHVybiB0aGUgdGlsZSBYL1kvWiB0aGF0IHRoZSBwb2ludCBsaWVzIGluXG4qL1xuR2VvLnRpbGVGb3JNZXRlcnMgPSBmdW5jdGlvbiAoW3gsIHldLCB6b29tKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogTWF0aC5mbG9vcigoeCArIEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzKSAvIChHZW8uY2lyY3VtZmVyZW5jZV9tZXRlcnMgLyBNYXRoLnBvdygyLCB6b29tKSkpLFxuICAgICAgICB5OiBNYXRoLmZsb29yKCgteSArIEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzKSAvIChHZW8uY2lyY3VtZmVyZW5jZV9tZXRlcnMgLyBNYXRoLnBvdygyLCB6b29tKSkpLFxuICAgICAgICB6OiB6b29tXG4gICAgfTtcbn07XG5cbi8vIFdyYXAgYSB0aWxlIHRvIHBvc2l0aXZlICNzIGZvciB6b29tXG4vLyBPcHRpb25hbGx5IHNwZWNpZnkgdGhlIGF4ZXMgdG8gd3JhcFxuR2VvLndyYXBUaWxlID0gZnVuY3Rpb24oeyB4LCB5LCB6IH0sIG1hc2sgPSB7IHg6IHRydWUsIHk6IGZhbHNlIH0pIHtcbiAgICB2YXIgbSA9ICgxIDw8IHopIC0gMTtcbiAgICBpZiAobWFzay54KSB7XG4gICAgICAgIHggPSB4ICYgbTtcbiAgICB9XG4gICAgaWYgKG1hc2sueSkge1xuICAgICAgICB5ID0geSAmIG07XG4gICAgfVxuICAgIHJldHVybiB7IHgsIHksIHogfTtcbn07XG5cbi8qKlxuICAgQ29udmVydCBtZXJjYXRvciBtZXRlcnMgdG8gbGF0LWxuZ1xuKi9cbkdlby5tZXRlcnNUb0xhdExuZyA9IGZ1bmN0aW9uIChbeCwgeV0pIHtcblxuICAgIHggLz0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnM7XG4gICAgeSAvPSBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycztcblxuICAgIHkgPSAoMiAqIE1hdGguYXRhbihNYXRoLmV4cCh5ICogTWF0aC5QSSkpIC0gKE1hdGguUEkgLyAyKSkgLyBNYXRoLlBJO1xuXG4gICAgeCAqPSAxODA7XG4gICAgeSAqPSAxODA7XG5cbiAgICByZXR1cm4gW3gsIHldO1xufTtcblxuLyoqXG4gIENvbnZlcnQgbGF0LWxuZyB0byBtZXJjYXRvciBtZXRlcnNcbiovXG5HZW8ubGF0TG5nVG9NZXRlcnMgPSBmdW5jdGlvbihbeCwgeV0pIHtcblxuICAgIC8vIExhdGl0dWRlXG4gICAgeSA9IE1hdGgubG9nKE1hdGgudGFuKHkqTWF0aC5QSS8zNjAgKyBNYXRoLlBJLzQpKSAvIE1hdGguUEk7XG4gICAgeSAqPSBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycztcblxuICAgIC8vIExvbmdpdHVkZVxuICAgIHggKj0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMgLyAxODA7XG5cbiAgICByZXR1cm4gW3gsIHldO1xufTtcblxuR2VvLndyYXBMbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPiAxODAgfHwgeCA8IC0xODApIHtcbiAgICAgICAgeCA9ICgoeCArIDE4MCkgJSAzNjAgKyAzNjApICUgMzYwIC0gMTgwO1xuICAgIH1cbiAgICByZXR1cm4geDtcbn07XG5cbi8vIFJ1biBhbiBpbi1wbGFjZSB0cmFuc2Zvcm0gZnVuY3Rpb24gb24gZWFjaCBjb29vcmRpbmF0ZSBpbiBhIEdlb0pTT04gZ2VvbWV0cnlcbkdlby50cmFuc2Zvcm1HZW9tZXRyeSA9IGZ1bmN0aW9uIChnZW9tZXRyeSwgdHJhbnNmb3JtKSB7XG4gICAgaWYgKGdlb21ldHJ5ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBza2lwIGlmIG1pc3NpbmcgZ2VvbWV0cnkgKHZhbGlkIEdlb0pTT04pXG4gICAgfVxuXG4gICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2ludCcpIHtcbiAgICAgICAgdHJhbnNmb3JtKGdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnIHx8IGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xuICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlcy5mb3JFYWNoKHRyYW5zZm9ybSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyB8fCBnZW9tZXRyeS50eXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJykge1xuICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlcy5mb3JFYWNoKGNvb3JkaW5hdGVzID0+IGNvb3JkaW5hdGVzLmZvckVhY2godHJhbnNmb3JtKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzLmZvckVhY2gocG9seWdvbiA9PiB7XG4gICAgICAgICAgICBwb2x5Z29uLmZvckVhY2goY29vcmRpbmF0ZXMgPT4gY29vcmRpbmF0ZXMuZm9yRWFjaCh0cmFuc2Zvcm0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRPRE86IHN1cHBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uXG59O1xuXG5HZW8uYm94SW50ZXJzZWN0ID0gZnVuY3Rpb24gKGIxLCBiMikge1xuICAgIHJldHVybiAhKFxuICAgICAgICBiMi5zdy54ID4gYjEubmUueCB8fFxuICAgICAgICBiMi5uZS54IDwgYjEuc3cueCB8fFxuICAgICAgICBiMi5zdy55ID4gYjEubmUueSB8fFxuICAgICAgICBiMi5uZS55IDwgYjEuc3cueVxuICAgICk7XG59O1xuXG4vLyBGaW5kcyB0aGUgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgYSBwb2x5Z29uXG5HZW8uZmluZEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICB2YXIgbWluX3ggPSBJbmZpbml0eSxcbiAgICAgICAgbWF4X3ggPSAtSW5maW5pdHksXG4gICAgICAgIG1pbl95ID0gSW5maW5pdHksXG4gICAgICAgIG1heF95ID0gLUluZmluaXR5O1xuXG4gICAgLy8gT25seSBuZWVkIHRvIGV4YW1pbmUgb3V0ZXIgcmluZyAocG9seWdvblswXSlcbiAgICB2YXIgbnVtX2Nvb3JkcyA9IHBvbHlnb25bMF0ubGVuZ3RoO1xuICAgIGZvciAodmFyIGM9MDsgYyA8IG51bV9jb29yZHM7IGMrKykge1xuICAgICAgICB2YXIgY29vcmQgPSBwb2x5Z29uWzBdW2NdO1xuXG4gICAgICAgIGlmIChjb29yZFswXSA8IG1pbl94KSB7XG4gICAgICAgICAgICBtaW5feCA9IGNvb3JkWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb29yZFsxXSA8IG1pbl95KSB7XG4gICAgICAgICAgICBtaW5feSA9IGNvb3JkWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb29yZFswXSA+IG1heF94KSB7XG4gICAgICAgICAgICBtYXhfeCA9IGNvb3JkWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb29yZFsxXSA+IG1heF95KSB7XG4gICAgICAgICAgICBtYXhfeSA9IGNvb3JkWzFdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFttaW5feCwgbWluX3ksIG1heF94LCBtYXhfeV07XG59O1xuXG4vLyBDb252ZXJ0IGdlb21ldHJ5IHR5cGUgdG8gb25lIG9mOiAncG9pbnQnLCAnbGluZScsICdwb2x5Z29uJ1xuR2VvLmdlb21ldHJ5VHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gJ1BvbHlnb24nIHx8IHR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIHJldHVybiAncG9seWdvbic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdMaW5lU3RyaW5nJyB8fCB0eXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJykge1xuICAgICAgICByZXR1cm4gJ2xpbmUnO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ1BvaW50JyB8fCB0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcbiAgICAgICAgcmV0dXJuICdwb2ludCc7XG4gICAgfVxufTtcblxuR2VvLmNlbnRyb2lkID0gZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICBsZXQgbiA9IHBvbHlnb24ubGVuZ3RoO1xuICAgIGxldCBjZW50cm9pZCA9IFswLCAwXTtcblxuICAgIGZvciAobGV0IHA9MDsgcCA8IHBvbHlnb24ubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgY2VudHJvaWRbMF0gKz0gcG9seWdvbltwXVswXTtcbiAgICAgICAgY2VudHJvaWRbMV0gKz0gcG9seWdvbltwXVsxXTtcbiAgICB9XG5cbiAgICBjZW50cm9pZFswXSAvPSBuO1xuICAgIGNlbnRyb2lkWzFdIC89IG47XG5cbiAgICByZXR1cm4gY2VudHJvaWQ7XG59O1xuXG5HZW8ubXVsdGlDZW50cm9pZCA9IGZ1bmN0aW9uIChwb2x5Z29ucykge1xuICAgIGxldCBuID0gcG9seWdvbnMubGVuZ3RoO1xuICAgIGxldCBjZW50cm9pZCA9IFswLCAwXTtcblxuICAgIGZvciAobGV0IHA9MDsgcCA8IHBvbHlnb25zLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgIGxldCBwb2x5Z29uID0gcG9seWdvbnNbcF1bMF07XG4gICAgICAgIGxldCBjID0gR2VvLmNlbnRyb2lkKHBvbHlnb24pO1xuICAgICAgICBjZW50cm9pZFswXSArPSBjWzBdO1xuICAgICAgICBjZW50cm9pZFsxXSArPSBjWzFdO1xuICAgIH1cblxuICAgIGNlbnRyb2lkWzBdIC89IG47XG4gICAgY2VudHJvaWRbMV0gLz0gbjtcblxuICAgIHJldHVybiBjZW50cm9pZDtcbn07XG5cbkdlby5zaWduZWRQb2x5Z29uQXJlYVN1bSA9IGZ1bmN0aW9uIChwb2x5Z29uKSB7XG4gICAgbGV0IGFyZWEgPSAwO1xuICAgIGxldCBuID0gcG9seWdvbi5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgICAgbGV0IHAwID0gcG9seWdvbltpXTtcbiAgICAgICAgbGV0IHAxID0gcG9seWdvbltpKzFdO1xuXG4gICAgICAgIGFyZWEgKz0gcDBbMF0gKiBwMVsxXSAtIHAxWzBdICogcDBbMV07XG4gICAgfVxuXG4gICAgYXJlYSArPSBwb2x5Z29uW24gLSAxXVswXSAqIHBvbHlnb25bMF1bMV0gLSBwb2x5Z29uWzBdWzBdICogcG9seWdvbltuIC0gMV1bMV07XG4gICAgcmV0dXJuIGFyZWE7XG59O1xuXG4vLyBUT0RPOiBzdWJ0cmFjdCBpbm5lciByaW5nIGFyZWFzXG5HZW8ucG9seWdvbkFyZWEgPSBmdW5jdGlvbiAocG9seWdvbikge1xuICAgIHJldHVybiBNYXRoLmFicyhHZW8uc2lnbmVkUG9seWdvbkFyZWFTdW0ocG9seWdvbikpIC8gMjtcbn07XG5cbkdlby5tdWx0aVBvbHlnb25BcmVhID0gZnVuY3Rpb24gKHBvbHlnb25zKSB7XG4gICAgbGV0IGFyZWEgPSAwO1xuXG4gICAgZm9yIChsZXQgcD0wOyBwIDwgcG9seWdvbnMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgbGV0IHBvbHlnb24gPSBwb2x5Z29uc1twXVswXTtcbiAgICAgICAgYXJlYSArPSBHZW8ucG9seWdvbkFyZWEocG9seWdvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZWE7XG59O1xuXG5HZW8ucmluZ1dpbmRpbmcgPSBmdW5jdGlvbiAocmluZykge1xuICAgIGxldCBhcmVhID0gR2VvLnNpZ25lZFBvbHlnb25BcmVhU3VtKHJpbmcpO1xuICAgIGlmIChhcmVhID4gMCkge1xuICAgICAgICByZXR1cm4gJ0NXJztcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJlYSA8IDApIHtcbiAgICAgICAgcmV0dXJuICdDQ1cnO1xuICAgIH1cbiAgICAvLyByZXR1cm4gdW5kZWZpbmVkIG9uIHplcm8gYXJlYSBwb2x5Z29uXG59O1xuXG4vLyBFbmZvcmNlIHdpbmRpbmcgb3JkZXIgb24gb3V0ZXIvaW5uZXIgcmluZ3Ncbi8vIHdpbmRpbmc6ICdDVycgb3IgJ0NDVydcbkdlby5lbmZvcmNlV2luZGluZyA9IGZ1bmN0aW9uIChnZW9tLCB3aW5kaW5nKSB7XG4gICAgbGV0IHBvbHlzO1xuICAgIGlmIChnZW9tLnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICBwb2x5cyA9IFtnZW9tLmNvb3JkaW5hdGVzXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2VvbS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICBwb2x5cyA9IGdlb20uY29vcmRpbmF0ZXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2VvbTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBwPTA7IHAgPCBwb2x5cy5sZW5ndGg7IHArKykge1xuICAgICAgICBsZXQgcG9seSA9IHBvbHlzW3BdO1xuXG4gICAgICAgIC8vIElmIGZpcnN0IHJpbmcgd2luZGluZyBkb2Vzbid0IG1hdGNoLCByZXZlcnNlIGFsbCByaW5nc1xuICAgICAgICAvLyBOT1RFOiBhc3N1bWVzIHJpbmcgd2luZGluZyBvcmRlcnMgYWxyZWFkeSBhbHRlcm5hdGUgYXMgZXhwZWN0ZWRcbiAgICAgICAgaWYgKEdlby5yaW5nV2luZGluZyhwb2x5WzBdKSAhPT0gd2luZGluZykge1xuICAgICAgICAgICAgZm9yIChsZXQgcmluZyBvZiBwb2x5KSB7XG4gICAgICAgICAgICAgICAgcmluZy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdlb207XG59O1xuIiwiLy8gV2ViR0wgY29uc3RhbnRzIC0gbmVlZCB0byBpbXBvcnQgdGhlc2Ugc2VwYXJhdGVseSB0byBtYWtlIHRoZW0gYXZhaWxhYmxlIGluIHRoZSB3ZWIgd29ya2VyXG5cbnZhciBnbDtcbmV4cG9ydCBkZWZhdWx0IGdsID0ge307XG5cbi8qIERhdGFUeXBlICovXG5nbC5CWVRFICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE0MDA7XG5nbC5VTlNJR05FRF9CWVRFICAgICAgICAgICAgICAgICAgPSAweDE0MDE7XG5nbC5TSE9SVCAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE0MDI7XG5nbC5VTlNJR05FRF9TSE9SVCAgICAgICAgICAgICAgICAgPSAweDE0MDM7XG5nbC5JTlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE0MDQ7XG5nbC5VTlNJR05FRF9JTlQgICAgICAgICAgICAgICAgICAgPSAweDE0MDU7XG5nbC5GTE9BVCAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE0MDY7XG4iLCIvLyBXZWJHTCBjb250ZXh0IHdyYXBwZXJcblxudmFyIENvbnRleHQ7XG5leHBvcnQgZGVmYXVsdCBDb250ZXh0ID0ge307XG5cbi8vIFNldHVwIGEgV2ViR0wgY29udGV4dFxuLy8gSWYgbm8gY2FudmFzIGVsZW1lbnQgaXMgcHJvdmlkZWQsIG9uZSBpcyBjcmVhdGVkIGFuZCBhZGRlZCB0byB0aGUgZG9jdW1lbnQgYm9keVxuQ29udGV4dC5nZXRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q29udGV4dCAoY2FudmFzLCBvcHRpb25zKVxue1xuICAgIHZhciBmdWxsc2NyZWVuID0gZmFsc2U7XG4gICAgaWYgKGNhbnZhcyA9PSBudWxsKSB7XG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBjYW52YXMuc3R5bGUudG9wID0gMDtcbiAgICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gLTE7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgZnVsbHNjcmVlbiA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgb3B0aW9ucykgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIG9wdGlvbnMpO1xuICAgIGlmICghZ2wpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgY3JlYXRlIFdlYkdMIGNvbnRleHQuXCIpO1xuICAgIH1cblxuICAgIENvbnRleHQucmVzaXplKGdsLCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0LCBvcHRpb25zLmRldmljZV9waXhlbF9yYXRpbyk7XG4gICAgaWYgKGZ1bGxzY3JlZW4gPT09IHRydWUpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIENvbnRleHQucmVzaXplKGdsLCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdsO1xufTtcblxuQ29udGV4dC5yZXNpemUgPSBmdW5jdGlvbiAoZ2wsIHdpZHRoLCBoZWlnaHQsIGRldmljZV9waXhlbF9yYXRpbylcbntcbiAgICBkZXZpY2VfcGl4ZWxfcmF0aW8gPSBkZXZpY2VfcGl4ZWxfcmF0aW8gfHwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICBnbC5jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgZ2wuY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgZ2wuY2FudmFzLndpZHRoID0gTWF0aC5yb3VuZChnbC5jYW52YXMuc3R5bGUud2lkdGggKiBkZXZpY2VfcGl4ZWxfcmF0aW8pO1xuICAgIGdsLmNhbnZhcy5oZWlnaHQgPSBNYXRoLnJvdW5kKGdsLmNhbnZhcy5zdHlsZS53aWR0aCAqIGRldmljZV9waXhlbF9yYXRpbyk7XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcbn07XG4iLCIvLyBXZWJHTCBleHRlbnNpb24gd3JhcHBlclxuLy8gU3RvcmVzIGV4dGVuc2lvbnMgYnkgbmFtZSBhbmQgR0wgY29udGV4dFxuXG5sZXQgZXh0ZW5zaW9ucyA9IG5ldyBNYXAoKTsgLy8gbWFwIG9mIGV4dGVuc2lvbnMgYnkgR0wgY29udGV4dFxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRFeHRlbnNpb24gKGdsLCBuYW1lKSB7XG4gICAgbGV0IGV4dHMgPSBleHRlbnNpb25zLmdldChnbCk7XG4gICAgaWYgKCFleHRzKSB7XG4gICAgICAgIGV4dGVuc2lvbnMuc2V0KGdsLCBuZXcgTWFwKCkpO1xuICAgICAgICBleHRzID0gZXh0ZW5zaW9ucy5nZXQoZ2wpO1xuICAgIH1cblxuICAgIGlmICghZXh0cy5nZXQobmFtZSkpIHtcbiAgICAgICAgZXh0cy5zZXQobmFtZSwgZ2wuZ2V0RXh0ZW5zaW9uKG5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dHMuZ2V0KG5hbWUpO1xufVxuIiwidmFyIEdMU0wgPSB7fTtcbmV4cG9ydCBkZWZhdWx0IEdMU0w7XG5cbi8qKlxuICAgIFBhcnNlIHVuaWZvcm1zIGZyb20gYSBKUyBvYmplY3QsIGluZmVycyB0eXBlcyBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggdGhlXG4gICAgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIHRvIHNldCB1bmlmb3JtIHZhbHVlcyBvbiBhIEdMIHByb2dyYW0uIEVhY2ggb2JqZWN0IGluIHRoZSByZXR1cm5lZFxuICAgIGFycmF5IGhhcyB0aGUgZm9ybTpcbiAgICB7IHR5cGUsIG1ldGhvZCwgbmFtZSwgdmFsdWUgfVxuXG4gICAgdHlwZTogdGhlIEdMIHVuaWZvcm0gdHlwZSwgc3VjaCBhcyAndmVjMycsICdmbG9hdCcsIGV0Yy5cbiAgICBtZXRob2Q6IHRoZSBHTCB1bmlmb3JtIHNldHRlciBtZXRob2QgdG8gdXNlLCBzdWNoIGFzICcxZicsICczZnYnLCBldGMuXG4gICAgbmFtZTogdGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9mIHRoZSBHTCB1bmlmb3JtIGxvY2F0aW9uLCBlLmcuICdhcnJheVswXS5maWVsZCcsIGV0Yy5cbiAgICB2YWx1ZTogdGhlIHZhbHVlIHRvIGJlIHBhc3NlZCB0byB0aGUgR0wgdW5pZm9ybSBzZXR0ZXIgZm9yIHRoYXQgdHlwZSwgZS5nLiBbMSwgMiwgM10gZm9yIGEgdmVjM1xuXG4gICAgVGV4dHVyZXMgaGF2ZSBzcGVjaWFsIGJlaGF2aW9yOiB1bmlmb3JtcyB3aXRoIHN0cmluZyB2YWx1ZXMgYXJlIHRyZWF0ZWQgYXMgdGV4dHVyZXMsIGFuZFxuICAgIHRoZSBzdHJpbmcgaXMgdXNlZCBhcyBhIHVuaXF1ZSB0ZXh0dXJlICdrZXknIHRvIGJlIGludGVycHJldGVkIGJ5IHRoZSBjYWxsZXIgKHdoaWNoIGlzIHJlc3BvbnNpYmxlXG4gICAgZm9yIGFjdHVhbGx5IHNldHRpbmcgdGhlIHVuaWZvcm1zKS4gRm9yIGV4YW1wbGUsIHRoaXMgY291bGQgYmUgdXNlZCBhcyBhIGtleSBpbnRvIGEgZGljdGlvbmFyeSBvZlxuICAgIGtub3duIHRleHR1cmUgbmFtZXMsIG9yIGl0IGNvdWxkIHNpbXBseSBiZSB1c2VkIGFzIGEgVVJMIHRvIGR5bmFtaWNhbGx5IGxvYWQgdGhlIHRleHR1cmUgZnJvbS5cbiovXG5HTFNMLnBhcnNlVW5pZm9ybXMgPSBmdW5jdGlvbiAodW5pZm9ybXMsIHByZWZpeCA9IG51bGwpIHtcbiAgICB2YXIgcGFyc2VkID0gW107XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHVuaWZvcm1zKSB7XG4gICAgICAgIHZhciBrZXkgPSBuYW1lOyAvLyBzYXZlIHRoZSBvcmlnaW5hbCBuYW1lXG4gICAgICAgIHZhciB1bmlmb3JtID0gdW5pZm9ybXNbbmFtZV07XG4gICAgICAgIHZhciB1O1xuXG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIG5hbWUgPSBwcmVmaXggKyAnLicgKyBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2luZ2xlIGZsb2F0XG4gICAgICAgIGlmICh0eXBlb2YgdW5pZm9ybSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJzFmJyxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmlmb3JtLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB1bmlmb3Jtc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXk6IHZlY3RvciwgYXJyYXkgb2YgZmxvYXRzLCBhcnJheSBvZiB0ZXh0dXJlcywgb3IgYXJyYXkgb2Ygc3RydWN0c1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHVuaWZvcm0pKSB7XG4gICAgICAgICAgICAvLyBOdW1lcmljIHZhbHVlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1bmlmb3JtWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIGZsb2F0IHZlY3RvcnMgKHZlYzIsIHZlYzMsIHZlYzQpXG4gICAgICAgICAgICAgICAgaWYgKHVuaWZvcm0ubGVuZ3RoID49IDIgJiYgdW5pZm9ybS5sZW5ndGggPD0gNCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndmVjJyArIHVuaWZvcm0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiB1bmlmb3JtLmxlbmd0aCArICdmdicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuaWZvcm0sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3Jtc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZmxvYXQgYXJyYXlcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh1bmlmb3JtLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Zsb2F0W10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnMWZ2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgKyAnWzBdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmlmb3JtLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGFzc3VtZSBtYXRyaXggZm9yICh0eXBlb2YgPT0gRmxvYXQzMkFycmF5ICYmIGxlbmd0aCA9PSAxNik/XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcnJheSBvZiB0ZXh0dXJlc1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHVuaWZvcm1bMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZm9yICh1PTA7IHUgPCB1bmlmb3JtLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzYW1wbGVyMkQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnMWknLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSArICdbJyArIHUgKyAnXScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5pZm9ybVt1XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogdSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zOiB1bmlmb3JtXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFycmF5IG9mIGFycmF5cyAtIGJ1dCBvbmx5IGFycmF5cyBvZiB2ZWN0b3JzIGFyZSBhbGxvd2VkIGluIHRoaXMgY2FzZVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh1bmlmb3JtWzBdKSAmJiB0eXBlb2YgdW5pZm9ybVswXVswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAvLyBmbG9hdCB2ZWN0b3JzICh2ZWMyLCB2ZWMzLCB2ZWM0KVxuICAgICAgICAgICAgICAgIGlmICh1bmlmb3JtWzBdLmxlbmd0aCA+PSAyICYmIHVuaWZvcm1bMF0ubGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHU9MDsgdSA8IHVuaWZvcm0ubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndmVjJyArIHVuaWZvcm1bMF0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogdW5pZm9ybVt1XS5sZW5ndGggKyAnZnYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgKyAnWycgKyB1ICsgJ10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmlmb3JtW3VdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogdSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtczogdW5pZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZWxzZSBlcnJvcj9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFycmF5IG9mIHN0cnVjdHVyZXNcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB1bmlmb3JtWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGZvciAodT0wOyB1IDwgdW5pZm9ybS5sZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgZWFjaCBzdHJ1Y3QgaW4gdGhlIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wdXNoKC4uLkdMU0wucGFyc2VVbmlmb3Jtcyh1bmlmb3JtW3VdLCBuYW1lICsgJ1snICsgdSArICddJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBCb29sZWFuXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB1bmlmb3JtID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnMWknLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuaWZvcm0sXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHVuaWZvcm1zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXh0dXJlXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB1bmlmb3JtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzYW1wbGVyMkQnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJzFpJyxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmlmb3JtLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB1bmlmb3Jtc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0dXJlXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB1bmlmb3JtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gU2V0IGVhY2ggZmllbGQgaW4gdGhlIHN0cnVjdFxuICAgICAgICAgICAgcGFyc2VkLnB1c2goLi4uR0xTTC5wYXJzZVVuaWZvcm1zKHVuaWZvcm0sIG5hbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgb3RoZXIgbm9uLWZsb2F0IHR5cGVzPyAoaW50LCBldGMuKVxuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vKipcbiAgICBHZW5lcmF0ZSBhIEdMU0wgdmFyaWFibGUgZGVmaW5pdGlvbiBmcm9tIGEgSlMgb2JqZWN0XG4qL1xuR0xTTC5kZWZpbmVWYXJpYWJsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcHJlZml4ID0gbnVsbCkge1xuICAgIHZhciB0eXBlLCBhcnJheTtcbiAgICB2YXIgc3RydWN0cyA9ICcnO1xuICAgIHByZWZpeCA9IHByZWZpeCA/IHByZWZpeCArICdfJyArIG5hbWUgOiBuYW1lO1xuXG4gICAgLy8gU2luZ2xlIGZsb2F0XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdHlwZSA9ICdmbG9hdCc7XG4gICAgfVxuICAgIC8vIE11bHRpcGxlIGZsb2F0cyAtIHZlY3RvciBvciBhcnJheVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIC8vIE51bWVyaWMgdmFsdWVzXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBmbG9hdCB2ZWN0b3JzICh2ZWMyLCB2ZWMzLCB2ZWM0KVxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+PSAyICYmIHZhbHVlLmxlbmd0aCA8PSA0KSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICd2ZWMnICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmxvYXQgYXJyYXlcbiAgICAgICAgICAgIGVsc2UgeyAvL2lmICh2YWx1ZS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdmbG9hdCc7XG4gICAgICAgICAgICAgICAgYXJyYXkgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBhc3N1bWUgbWF0cml4IGZvciAodHlwZW9mID09IEZsb2F0MzJBcnJheSAmJiBsZW5ndGggPT0gMTYpP1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IG9mIHRleHR1cmVzXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZVswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnc2FtcGxlcjJEJztcbiAgICAgICAgICAgIGFycmF5ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IG9mIGFycmF5cyAtIGJ1dCBvbmx5IGFycmF5cyBvZiB2ZWN0b3JzIGFyZSBhbGxvd2VkIGluIHRoaXMgY2FzZVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlWzBdKSAmJiB0eXBlb2YgdmFsdWVbMF1bMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBmbG9hdCB2ZWN0b3JzICh2ZWMyLCB2ZWMzLCB2ZWM0KVxuICAgICAgICAgICAgaWYgKHZhbHVlWzBdLmxlbmd0aCA+PSAyICYmIHZhbHVlWzBdLmxlbmd0aCA8PSA0KSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICd2ZWMnICsgdmFsdWVbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSBlcnJvcj9cbiAgICAgICAgICAgIGFycmF5ID0gdmFsdWVbMF0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IG9mIHN0cnVjdHVyZXNcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdHlwZSA9ICdfdHlwZV8nICsgcHJlZml4OyAvLyBjdXN0b20gc3RydWN0IG5hbWVcbiAgICAgICAgICAgIGFycmF5ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgc3RydWN0cyArPSBHTFNMLmRlZmluZVN0cnVjdCh0eXBlLCB2YWx1ZVswXSwgcHJlZml4KSArICdcXG4nOyAvLyBidWlsZCAmIGFkZCB0byBsaXN0IG9mIGRlcGVuZGVudCBzdHJ1Y3RzXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQm9vbGVhblxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHR5cGUgPSAnYm9vbCc7XG4gICAgfVxuICAgIC8vIFRleHR1cmVcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHR5cGUgPSAnc2FtcGxlcjJEJztcbiAgICB9XG4gICAgLy8gU3RydWN0dXJlXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0eXBlID0gJ190eXBlXycgKyBwcmVmaXg7IC8vIGN1c3RvbSBzdHJ1Y3QgbmFtZVxuICAgICAgICBzdHJ1Y3RzICs9IEdMU0wuZGVmaW5lU3RydWN0KHR5cGUsIHZhbHVlLCBwcmVmaXgpICsgJ1xcbic7IC8vIGJ1aWxkICYgYWRkIHRvIGxpc3Qgb2YgZGVwZW5kZW50IHN0cnVjdHNcbiAgICB9XG5cbiAgICAvLyBDb25zdHJ1Y3QgdmFyaWFibGUgZGVmaW5pdGlvblxuICAgIHZhciB2YXJpYWJsZSA9ICcnO1xuICAgIHZhcmlhYmxlICs9IGAke3R5cGV9ICR7bmFtZX1gO1xuICAgIGlmIChhcnJheSkge1xuICAgICAgICB2YXJpYWJsZSArPSBgWyR7YXJyYXl9XWA7XG4gICAgfVxuICAgIHZhcmlhYmxlICs9ICc7XFxuJztcblxuICAgIC8vIFJldHVybiB0aGUgdmFyaWFibGUgZGVmaW5pdGlvbiBpdHNlbGYsIGFuZCBhbnkgZGVwZW5kZW50IHN0cnVjdCBkZWZpbml0aW9uc1xuICAgIHJldHVybiB7IHZhcmlhYmxlLCBzdHJ1Y3RzIH07XG59O1xuXG4vKipcbiAgICBHZW5lcmF0ZSBhIEdMU0wgc3RydWN0dXJlIGRlZmluaXRpb24gZnJvbSBhIEpTIG9iamVjdFxuKi9cbkdMU0wuZGVmaW5lU3RydWN0ID0gZnVuY3Rpb24gKHR5cGUsIHZhbHVlLCBwcmVmaXggPSBudWxsKSB7XG4gICAgdmFyIHN0cnVjdCA9IGBzdHJ1Y3QgJHt0eXBlfSB7XFxuYDtcbiAgICB2YXIgZGVwZW5kZW50cyA9ICcnO1xuICAgIGZvciAodmFyIGZpZWxkIGluIHZhbHVlKSB7XG4gICAgICAgIHZhciBzdWJ2YXIgPSBHTFNMLmRlZmluZVZhcmlhYmxlKGZpZWxkLCB2YWx1ZVtmaWVsZF0sIHByZWZpeCk7XG4gICAgICAgIHN0cnVjdCArPSAnICAgICcgKyBzdWJ2YXIudmFyaWFibGU7XG4gICAgICAgIGRlcGVuZGVudHMgKz0gc3VidmFyLnN0cnVjdHM7XG4gICAgfVxuICAgIHN0cnVjdCArPSAnfTtcXG4nO1xuICAgIHN0cnVjdCA9IGRlcGVuZGVudHMgKyBzdHJ1Y3Q7XG4gICAgcmV0dXJuIHN0cnVjdDtcbn07XG5cbi8qKlxuICAgIEdlbmVyYXRlIGEgR0xTTCB1bmlmb3JtIGRlZmluaXRpb24gZnJvbSBhIEpTIG9iamVjdFxuKi9cbkdMU0wuZGVmaW5lVW5pZm9ybSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBkZWYgPSBHTFNMLmRlZmluZVZhcmlhYmxlKG5hbWUsIHZhbHVlKTtcbiAgICBkZWYgPSBkZWYuc3RydWN0cyArICd1bmlmb3JtICcgKyBkZWYudmFyaWFibGU7XG4gICAgcmV0dXJuIGRlZjtcbn07XG5cbi8qKlxuICAgIENoZWNrIGZvciBhIHVuaWZvcm0gZGVmaW5pdGlvbiBvZiAnbmFtZScgaW4gdGhlIHByb3ZpZGVkIEdMU0wgc291cmNlXG4gICAgU2ltcGxlIHJlZ2V4IGNoZWNrIGZvciAndW5pZm9ybScga2V5d29yZCBhbmQgdmFyIG5hbWUsIGRvZXMgbm90IGF0dGVtcHQgdG8gcGFyc2UvZXh0cmFjdCBHTFNMXG4gICAgTk9URTogYXNzdW1lcyBjb21tZW50cyBoYXZlIGJlZW4gc3RyaXBwZWQgZnJvbSBzb3VyY2VcbiovXG5HTFNMLmlzVW5pZm9ybURlZmluZWQgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlKSB7XG4gICAgLy8gTWF0Y2gsIGluIG9yZGVyOlxuICAgIC8vIC0gdGhlIGtleXdvcmQgJ3VuaWZvcm0nXG4gICAgLy8gLSBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIHRoYXQgaXMgYW55dGhpbmcgZXhjZXB0IGEgc2VtaWNvbG9uLCA7XG4gICAgLy8gLSBvcHRpb25hbGx5LCBhbnl0aGluZyBlbmNsb3NlZCBpbiBjdXJseSBicmFjZXMsIHsgLi4uIH0gKGFuIGlubGluZSBzdHJ1Y3R1cmUgZGVmaW5pdGlvbiBjYW4gZ28gaGVyZSlcbiAgICAvLyAtIG9wdGlvbmFsbHksIGFueSAjIG9mIGNoYXJhY3RlcnMgdGhhdCBpcyBub3QgYSBzZW1pY29sb24sIDtcbiAgICAvLyAtIHRoZSBuYW1lIG9mIHRoZSB1bmlmb3JtXG5cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKCd1bmlmb3JtW147XSsoPzp7W1xcXFxzXFxcXFNdKn0pP1teO10qXFxcXGInICsgbmFtZSArICdcXFxcYicsICdnJyk7XG4gICAgaWYgKHNvdXJjZS5tYXRjaChyZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICAgIENoZWNrIHRoYXQgYSBzeW1ib2wgaXMgcmVmZXJlbmNlZCBpbiB0aGUgR0xTTCBzb3VyY2VcbiAgICBOT1RFOiBhc3N1bWVzIGNvbW1lbnRzIGhhdmUgYmVlbiBzdHJpcHBlZCBmcm9tIHNvdXJjZVxuKi9cbkdMU0wuaXNTeW1ib2xSZWZlcmVuY2VkID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSkge1xuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIG5hbWUgKyAnXFxcXGInLCAnZycpO1xuICAgIGlmIChzb3VyY2Uuc2VhcmNoKHJlKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAgICBFeHBhbmQgYSBzaW5nbGUgdmFsdWUgb3IgMi1lbGVtZW50IGFycmF5IGludG8gYSAzLWVsZW1lbnQgYXJyYXksIHdpdGggdGhlIGxhc3QgKCB6IClcbiAgICBjb29yZGluYXRlIGRlZmF1bHRpbmcgdG8gMSAod2l0aCBvcHRpb24gdG8gc3BlY2lmeSkuIEFsc28gcnVucyBwYXJzZUZsb2F0IHRvIHRyeSB0byBtYWludGFpblxuICAgIGRhdGEgaW50ZWdyaXR5LiBSZXR1cm5zIG51bGwgaWYgaW5wdXQgY291bGRuJ3QgYmUgcGFyc2VkLlxuKi9cbkdMU0wuZXhwYW5kVmVjMyA9IGZ1bmN0aW9uICh2LCB6ID0gMSkge1xuICAgIGxldCB4O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHYpICYmIHYubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHggPSBbLi4udiwgel0ubWFwKHBhcnNlRmxvYXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgeCA9IFt2LCB2LCB2XS5tYXAocGFyc2VGbG9hdCk7XG4gICAgfVxuXG4gICAgaWYgKHggJiYgeC5ldmVyeShuID0+IHR5cGVvZiBuID09PSAnbnVtYmVyJyAmJiAhaXNOYU4obikpKSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbn07XG5cbi8qKlxuICAgIEV4cGFuZCBhIHNpbmdsZSB2YWx1ZSBvciAzLWVsZW1lbnQgYXJyYXkgaW50byBhIDQtZWxlbWVudCBhcnJheSwgd2l0aCB0aGUgbGFzdCAoZS5nLiB3IG9yIGEpXG4gICAgY29vcmRpbmF0ZSBkZWZhdWx0aW5nIHRvIDEgKHdpdGggb3B0aW9uIHRvIHNwZWNpZnkpLiBBbHNvIHJ1bnMgcGFyc2VGbG9hdCB0byB0cnkgdG8gbWFpbnRhaW5cbiAgICBkYXRhIGludGVncml0eS4gUmV0dXJucyBudWxsIGlmIGlucHV0IGNvdWxkbid0IGJlIHBhcnNlZC5cbiovXG5HTFNMLmV4cGFuZFZlYzQgPSBmdW5jdGlvbiAodiwgdyA9IDEpIHtcbiAgICBsZXQgeDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSAmJiB2Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICB4ID0gWy4uLnYsIHddLm1hcChwYXJzZUZsb2F0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHggPSBbdiwgdiwgdiwgd10ubWFwKHBhcnNlRmxvYXQpO1xuICAgIH1cblxuICAgIGlmICh4ICYmIHguZXZlcnkobiA9PiB0eXBlb2YgbiA9PT0gJ251bWJlcicgJiYgIWlzTmFOKG4pKSkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG59O1xuXG5cbiIsIlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyU3RhdGUge1xuXHRjb25zdHJ1Y3RvciAodmFsdWUsIHNldHVwKSB7XG4gICAgICAgIHNldHVwKHZhbHVlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNldHVwID0gc2V0dXA7XG4gICAgfVxuXG4gICAgc2V0ICh2YWx1ZSkge1xuICAgIFx0Ly8gaWYgdGhlIHN0YXRlcyBhcmUgZGlmZmVyZW50LCBjYWxsIHRoZSBHTCBjb250ZXh0IGZvciBhIHN0YXRlIGNoYW5nZVxuICAgIFx0aWYgKEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpICE9PSBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpIHtcbiAgICBcdFx0dGhpcy5zZXR1cCh2YWx1ZSk7XG4gICAgXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICBcdH1cbiAgICB9XG5cbiAgICBzdGF0aWMgaW5pdGlhbGl6ZSAoZ2wpIHtcbiAgICBcdC8vIEN1bGxpbmdcbiAgICBcdFJlbmRlclN0YXRlLmN1bGxpbmcgPSBuZXcgUmVuZGVyU3RhdGUoXG4gICAgXHRcdHsgY3VsbDogdHJ1ZSwgZmFjZTogZ2wuQkFDSyB9LFxuICAgIFx0XHQodmFsdWUpID0+IHtcbiAgICBcdFx0XHRpZiAodmFsdWUuY3VsbCkge1xuICAgIFx0XHRcdFx0Z2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7XG4gICAgICAgICAgICBcdFx0Z2wuY3VsbEZhY2UodmFsdWUuZmFjZSk7XG4gICAgXHRcdFx0fSBlbHNlIHtcbiAgICBcdFx0XHRcdGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICBcdFx0XHR9XG4gICAgXHRcdH1cbiAgICBcdCk7XG5cbiAgICBcdC8vIEJsZW5kaW5nIG1vZGVcbiAgICBcdFJlbmRlclN0YXRlLmJsZW5kaW5nID0gbmV3IFJlbmRlclN0YXRlKFxuICAgICAgICAgICAgeyBibGVuZDogZmFsc2UsIHNyYzogZ2wuU1JDX0FMUEhBLCBkc3Q6IGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIHNyY19hbHBoYTogZ2wuT05FLCBkc3RfYWxwaGE6IGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgfSxcbiAgICAgICAgICAgICh2YWx1ZSkgPT4ge1xuICAgIFx0XHRcdGlmICh2YWx1ZS5ibGVuZCkge1xuICAgICAgICAgICAgXHRcdGdsLmVuYWJsZShnbC5CTEVORCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnNyY19hbHBoYSAmJiB2YWx1ZS5kc3RfYWxwaGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKHZhbHVlLnNyYywgdmFsdWUuZHN0LCB2YWx1ZS5zcmNfYWxwaGEsIHZhbHVlLmRzdF9hbHBoYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmModmFsdWUuc3JjLCB2YWx1ZS5kc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXHRcdFx0fSBlbHNlIHtcbiAgICBcdFx0XHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuICAgIFx0KTtcblxuICAgIFx0Ly8gRGVwdGggd3JpdGVcbiAgICBcdFJlbmRlclN0YXRlLmRlcHRoX3dyaXRlID0gbmV3IFJlbmRlclN0YXRlKFxuICAgIFx0XHR7IGRlcHRoX3dyaXRlOiB0cnVlIH0sXG4gICAgXHRcdCh2YWx1ZSkgPT4ge1xuICAgICAgICBcdFx0Z2wuZGVwdGhNYXNrKHZhbHVlLmRlcHRoX3dyaXRlKTtcbiAgICBcdFx0fVxuICAgIFx0KTtcblxuICAgIFx0Ly8gRGVwdGggdGVzdFxuICAgIFx0UmVuZGVyU3RhdGUuZGVwdGhfdGVzdCA9IG5ldyBSZW5kZXJTdGF0ZShcbiAgICBcdFx0eyBkZXB0aF90ZXN0OiB0cnVlLCBkZXB0aF9mdW5jOiBnbC5MRVFVQUwgfSxcbiAgICBcdFx0KHZhbHVlKSA9PiB7XG4gICAgXHRcdFx0aWYgKHZhbHVlLmRlcHRoX3Rlc3QpIHtcbiAgICAgICAgICAgIFx0XHRnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgIFx0XHRcdGdsLmRlcHRoRnVuYyh2YWx1ZS5kZXB0aF9mdW5jKTtcbiAgICBcdFx0XHR9IGVsc2Uge1xuICAgICAgICAgICAgXHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9XG4gICAgXHQpO1xuICAgIH1cbn1cbiIsIi8vIEdMIHByb2dyYW0gd3JhcHBlciB0byBjYWNoZSB1bmlmb3JtIGxvY2F0aW9ucy92YWx1ZXMsIGRvIGNvbXBpbGUtdGltZSBwcmUtcHJvY2Vzc2luZ1xuLy8gKGluamVjdGluZyAjZGVmaW5lcyBhbmQgI3ByYWdtYSBibG9ja3MgaW50byBzaGFkZXJzKSwgZXRjLlxuXG5pbXBvcnQgR0xTTCBmcm9tICcuL2dsc2wnO1xuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi90ZXh0dXJlJztcbmltcG9ydCBnZXRFeHRlbnNpb24gZnJvbSAnLi9leHRlbnNpb25zJztcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgc3RyaXAgZnJvbSAnc3RyaXAtY29tbWVudHMnO1xuaW1wb3J0IHsgZGVmYXVsdCBhcyBwYXJzZVNoYWRlckVycm9ycyB9IGZyb20gJ2dsLXNoYWRlci1lcnJvcnMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJQcm9ncmFtIHtcblxuICAgIGNvbnN0cnVjdG9yKGdsLCB2ZXJ0ZXhfc291cmNlLCBmcmFnbWVudF9zb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLmNvbXBpbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcGlsaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuXG4gICAgICAgIC8vIGtleS92YWx1ZXMgaW5zZXJ0ZWQgYXMgI2RlZmluZXMgaW50byBzaGFkZXJzIGF0IGNvbXBpbGUtdGltZVxuICAgICAgICB0aGlzLmRlZmluZXMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmRlZmluZXN8fHt9KTtcblxuICAgICAgICAvLyBrZXkvdmFsdWVzIGZvciBibG9ja3MgdGhhdCBjYW4gYmUgaW5qZWN0ZWQgaW50byBzaGFkZXJzIGF0IGNvbXBpbGUtdGltZVxuICAgICAgICB0aGlzLmJsb2NrcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuYmxvY2tzfHx7fSk7XG4gICAgICAgIHRoaXMuYmxvY2tfc2NvcGVzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5ibG9ja19zY29wZXN8fHt9KTtcblxuICAgICAgICAvLyBsaXN0IG9mIGV4dGVuc2lvbnMgdG8gYWN0aXZhdGVcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zIHx8IFtdO1xuXG4gICAgICAgIC8vIEpTLW9iamVjdCB1bmlmb3JtcyB0aGF0IGFyZSBleHBlY3RlZCBieSB0aGlzIHByb2dyYW1cbiAgICAgICAgLy8gSWYgdGhleSBhcmUgbm90IGZvdW5kIGluIHRoZSBleGlzdGluZyBzaGFkZXIgc291cmNlLCB0aGVpciB0eXBlcyB3aWxsIGJlIGluZmVycmVkIGFuZCBkZWZpbml0aW9uc1xuICAgICAgICAvLyBmb3IgZWFjaCB3aWxsIGJlIGluamVjdGVkLlxuICAgICAgICB0aGlzLmRlcGVuZGVudF91bmlmb3JtcyA9IG9wdGlvbnMudW5pZm9ybXM7XG5cbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IHt9OyAvLyBwcm9ncmFtIGxvY2F0aW9ucyBvZiB1bmlmb3JtcywgbGF6aWx5IGFkZGVkIGFzIGVhY2ggdW5pZm9ybSBpcyBzZXRcbiAgICAgICAgdGhpcy5hdHRyaWJzID0ge307IC8vIHByb2dyYW0gbG9jYXRpb25zIG9mIHZlcnRleCBhdHRyaWJ1dGVzLCBsYXppbHkgYWRkZWQgYXMgZWFjaCBhdHRyaWJ1dGUgaXMgYWNjZXNzZWRcblxuICAgICAgICB0aGlzLnZlcnRleF9zb3VyY2UgPSB2ZXJ0ZXhfc291cmNlO1xuICAgICAgICB0aGlzLmZyYWdtZW50X3NvdXJjZSA9IGZyYWdtZW50X3NvdXJjZTtcblxuICAgICAgICB0aGlzLmlkID0gU2hhZGVyUHJvZ3JhbS5pZCsrO1xuICAgICAgICBTaGFkZXJQcm9ncmFtLnByb2dyYW1zW3RoaXMuaWRdID0gdGhpcztcbiAgICAgICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lOyAvLyBjYW4gcHJvdmlkZSBhIHByb2dyYW0gbmFtZSAodXNlZnVsIGZvciBkZWJ1Z2dpbmcpXG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKG51bGwpO1xuICAgICAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IHt9O1xuICAgICAgICB0aGlzLmF0dHJpYnMgPSB7fTtcbiAgICAgICAgZGVsZXRlIFNoYWRlclByb2dyYW0ucHJvZ3JhbXNbdGhpcy5pZF07XG4gICAgICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBVc2UgcHJvZ3JhbSB3cmFwcGVyIHdpdGggc2ltcGxlIHN0YXRlIGNhY2hlXG4gICAgdXNlKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29tcGlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChTaGFkZXJQcm9ncmFtLmN1cnJlbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIFNoYWRlclByb2dyYW0uY3VycmVudCA9IHRoaXM7XG4gICAgfVxuXG4gICAgY29tcGlsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGlsaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyhuZXcgRXJyb3IoYFNoYWRlclByb2dyYW0uY29tcGlsZSgpOiBza2lwcGluZyBmb3IgJHt0aGlzLmlkfSAoJHt0aGlzLm5hbWV9KSBiZWNhdXNlIGFscmVhZHkgY29tcGlsaW5nYCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcGlsaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb21waWxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcblxuICAgICAgICAvLyBDb3B5IHNvdXJjZXMgZnJvbSBwcmUtbW9kaWZpZWQgdGVtcGxhdGVcbiAgICAgICAgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlID0gdGhpcy52ZXJ0ZXhfc291cmNlO1xuICAgICAgICB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZSA9IHRoaXMuZnJhZ21lbnRfc291cmNlO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBleHRlbnNpb24gYXZhaWxhYmlsaXR5XG4gICAgICAgIGxldCBleHRlbnNpb25zID0gdGhpcy5jaGVja0V4dGVuc2lvbnMoKTtcblxuICAgICAgICAvLyBNYWtlIGxpc3Qgb2YgZGVmaW5lcyB0byBiZSBpbmplY3RlZCBsYXRlclxuICAgICAgICB2YXIgZGVmaW5lcyA9IHRoaXMuYnVpbGREZWZpbmVMaXN0KCk7XG5cbiAgICAgICAgLy8gSW5qZWN0IHVzZXItZGVmaW5lZCBibG9ja3MgKGFyYml0cmFyeSBjb2RlIHBvaW50cyBtYXRjaGluZyBuYW1lZCAjcHJhZ21hcylcbiAgICAgICAgLy8gUmVwbGFjZSBhY2NvcmRpbmcgdG8gdGhpcyBwYXR0ZXJuOlxuICAgICAgICAvLyAjcHJhZ21hIHRhbmdyYW06IFtrZXldXG4gICAgICAgIC8vIGUuZy4gI3ByYWdtYSB0YW5ncmFtOiBnbG9iYWxcblxuICAgICAgICAvLyBHYXRoZXIgYWxsIGJsb2NrIGNvZGUgc25pcHBldHNcbiAgICAgICAgdmFyIGJsb2NrcyA9IHRoaXMuYnVpbGRTaGFkZXJCbG9ja0xpc3QoKTtcbiAgICAgICAgdmFyIHJlZ2V4cDtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYmxvY2tzKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBibG9ja3Nba2V5XTtcbiAgICAgICAgICAgIGlmICghYmxvY2sgfHwgKEFycmF5LmlzQXJyYXkoYmxvY2spICYmIGJsb2NrLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlyc3QgZmluZCBjb2RlIHJlcGxhY2UgcG9pbnRzIGluIHNoYWRlcnNcbiAgICAgICAgICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJ15cXFxccyojcHJhZ21hXFxcXHMrdGFuZ3JhbTpcXFxccysnICsga2V5ICsgJ1xcXFxzKiQnLCAnbScpO1xuICAgICAgICAgICAgdmFyIGluamVjdF92ZXJ0ZXggPSB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2UubWF0Y2gocmVnZXhwKTtcbiAgICAgICAgICAgIHZhciBpbmplY3RfZnJhZ21lbnQgPSB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZS5tYXRjaChyZWdleHApO1xuXG4gICAgICAgICAgICAvLyBBdm9pZCBuZXR3b3JrIHJlcXVlc3QgaWYgbm90aGluZyB0byByZXBsYWNlXG4gICAgICAgICAgICBpZiAoaW5qZWN0X3ZlcnRleCA9PSBudWxsICYmIGluamVjdF9mcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbWJpbmUgYWxsIGJsb2NrcyBpbnRvIG9uZSBzdHJpbmdcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSAnJztcbiAgICAgICAgICAgIGJsb2NrLmZvckVhY2godmFsID0+IHtcbiAgICAgICAgICAgICAgICAvLyBNYXJrIHN0YXJ0IGFuZCBlbmQgb2YgZWFjaCBibG9jayB3aXRoIG1ldGFkYXRhICh3aGljaCBjYW4gYmUgZXh0cmFjdGVkIGZyb21cbiAgICAgICAgICAgICAgICAvLyBmaW5hbCBzb3VyY2UgZm9yIGVycm9yIGhhbmRsaW5nLCBkZWJ1Z2dpbmcsIGV0Yy4pXG4gICAgICAgICAgICAgICAgbGV0IG1hcmsgPSBgJHt2YWwuc2NvcGV9LCAke3ZhbC5rZXl9LCAke3ZhbC5udW19YDtcbiAgICAgICAgICAgICAgICBzb3VyY2UgKz0gYFxcbi8vIHRhbmdyYW0tYmxvY2stc3RhcnQ6ICR7bWFya31cXG5gO1xuICAgICAgICAgICAgICAgIHNvdXJjZSArPSB2YWwuc291cmNlO1xuICAgICAgICAgICAgICAgIHNvdXJjZSArPSBgXFxuLy8gdGFuZ3JhbS1ibG9jay1lbmQ6ICR7bWFya31cXG5gO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEluamVjdFxuICAgICAgICAgICAgaWYgKGluamVjdF92ZXJ0ZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZSA9IHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZS5yZXBsYWNlKHJlZ2V4cCwgc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmplY3RfZnJhZ21lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlID0gdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UucmVwbGFjZShyZWdleHAsIHNvdXJjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBhICNkZWZpbmUgZm9yIHRoaXMgaW5qZWN0aW9uIHBvaW50XG4gICAgICAgICAgICBkZWZpbmVzWydUQU5HUkFNX0JMT0NLXycgKyBrZXkucmVwbGFjZSgvW1xccy1dKy9nLCAnXycpLnRvVXBwZXJDYXNlKCldID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsZWFuLXVwIGFueSAjcHJhZ21hcyB0aGF0IHdlcmVuJ3QgcmVwbGFjZWQgKHRvIHByZXZlbnQgY29tcGlsZXIgd2FybmluZ3MpXG4gICAgICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJ15cXFxccyojcHJhZ21hLiokJywgJ2dtJyk7XG4gICAgICAgIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZSA9IHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZS5yZXBsYWNlKHJlZ2V4cCwgJycpO1xuICAgICAgICB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZSA9IHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlLnJlcGxhY2UocmVnZXhwLCAnJyk7XG5cbiAgICAgICAgLy8gRGV0ZWN0IHVuaWZvcm0gZGVmaW5pdGlvbnMsIGluamVjdCBhbnkgbWlzc2luZyBvbmVzXG4gICAgICAgIHRoaXMuZW5zdXJlVW5pZm9ybXModGhpcy5kZXBlbmRlbnRfdW5pZm9ybXMpO1xuXG4gICAgICAgIC8vIEJ1aWxkICYgaW5qZWN0IGV4dGVuc2lvbnMgJiBkZWZpbmVzXG4gICAgICAgIC8vIFRoaXMgaXMgZG9uZSAqYWZ0ZXIqIGNvZGUgaW5qZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCBkZWZpbmVzIGZvciB3aGljaCBjb2RlIHBvaW50cyB3ZXJlIGluamVjdGVkXG4gICAgICAgIGxldCBpbmZvID0gKHRoaXMubmFtZSA/ICh0aGlzLm5hbWUgKyAnIC8gaWQgJyArIHRoaXMuaWQpIDogKCdpZCAnICsgdGhpcy5pZCkpO1xuICAgICAgICBsZXQgaGVhZGVyID0gYC8vIFByb2dyYW06ICR7aW5mb31cXG5gO1xuICAgICAgICBsZXQgcHJlY2lzaW9uID0gJyc7XG4gICAgICAgIGxldCBoaWdoID0gdGhpcy5nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQodGhpcy5nbC5GUkFHTUVOVF9TSEFERVIsIHRoaXMuZ2wuSElHSF9GTE9BVCk7XG4gICAgICAgIGlmIChoaWdoICYmIGhpZ2gucHJlY2lzaW9uID4gMCkge1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbic7XG4gICAgICAgIH1cblxuICAgICAgICBkZWZpbmVzWydUQU5HUkFNX1ZFUlRFWF9TSEFERVInXSA9IHRydWU7XG4gICAgICAgIGRlZmluZXNbJ1RBTkdSQU1fRlJBR01FTlRfU0hBREVSJ10gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlID1cbiAgICAgICAgICAgIGhlYWRlciArXG4gICAgICAgICAgICBwcmVjaXNpb24gK1xuICAgICAgICAgICAgU2hhZGVyUHJvZ3JhbS5idWlsZERlZmluZVN0cmluZyhkZWZpbmVzKSArXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2U7XG5cbiAgICAgICAgLy8gUHJlY2lzaW9uIHF1YWxpZmllciBvbmx5IHZhbGlkIGluIGZyYWdtZW50IHNoYWRlclxuICAgICAgICAvLyBOQjogJyNleHRlbnNpb24nIHN0YXRlbWVudHMgYWRkZWQgdG8gZnJhZ21lbnQgc2hhZGVyIG9ubHksIGFzIElFMTEgdGhyb3dzIGVycm9yIHdoZW4gdGhleSBhcHBlYXIgaW5cbiAgICAgICAgLy8gdmVydGV4IHNoYWRlciAoZXZlbiB3aGVuIGd1YXJkZWQgYnkgI2lmZGVmKSwgYW5kIG5vIFdlYkdMIGV4dGVuc2lvbnMgcmVxdWlyZSAnI2V4dGVuc2lvbicgaW4gdmVydGV4IHNoYWRlcnNcbiAgICAgICAgZGVmaW5lc1snVEFOR1JBTV9WRVJURVhfU0hBREVSJ10gPSBmYWxzZTtcbiAgICAgICAgZGVmaW5lc1snVEFOR1JBTV9GUkFHTUVOVF9TSEFERVInXSA9IHRydWU7XG4gICAgICAgIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlID1cbiAgICAgICAgICAgIFNoYWRlclByb2dyYW0uYnVpbGRFeHRlbnNpb25TdHJpbmcoZXh0ZW5zaW9ucykgK1xuICAgICAgICAgICAgaGVhZGVyICtcbiAgICAgICAgICAgIHByZWNpc2lvbiArXG4gICAgICAgICAgICBTaGFkZXJQcm9ncmFtLmJ1aWxkRGVmaW5lU3RyaW5nKGRlZmluZXMpICtcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlO1xuXG4gICAgICAgIC8vIENvbXBpbGUgJiBzZXQgdW5pZm9ybXMgdG8gY2FjaGVkIHZhbHVlc1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtID0gU2hhZGVyUHJvZ3JhbS51cGRhdGVQcm9ncmFtKHRoaXMuZ2wsIHRoaXMucHJvZ3JhbSwgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlLCB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLmNvbXBpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY29tcGlsaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbXBpbGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNvbXBpbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuXG4gICAgICAgICAgICAvLyBzaGFkZXIgZXJyb3IgaW5mb1xuICAgICAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09ICd2ZXJ0ZXgnIHx8IGVycm9yLnR5cGUgPT09ICdmcmFnbWVudCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRlcl9lcnJvcnMgPSBlcnJvci5lcnJvcnM7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZSBvZiB0aGlzLnNoYWRlcl9lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZS50eXBlID0gZXJyb3IudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgZS5ibG9jayA9IHRoaXMuYmxvY2soZXJyb3IudHlwZSwgZS5saW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcihgU2hhZGVyUHJvZ3JhbS5jb21waWxlKCk6IHByb2dyYW0gJHt0aGlzLmlkfSAoJHt0aGlzLm5hbWV9KSBlcnJvcjpgLCBlcnJvcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51c2UoKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoVW5pZm9ybXMoKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoQXR0cmlidXRlcygpO1xuICAgIH1cblxuICAgIC8vIE1ha2UgbGlzdCBvZiBkZWZpbmVzIChnbG9iYWwsIHRoZW4gcHJvZ3JhbS1zcGVjaWZpYylcbiAgICBidWlsZERlZmluZUxpc3QoKSB7XG4gICAgICAgIHZhciBkLCBkZWZpbmVzID0ge307XG4gICAgICAgIGZvciAoZCBpbiBTaGFkZXJQcm9ncmFtLmRlZmluZXMpIHtcbiAgICAgICAgICAgIGRlZmluZXNbZF0gPSBTaGFkZXJQcm9ncmFtLmRlZmluZXNbZF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChkIGluIHRoaXMuZGVmaW5lcykge1xuICAgICAgICAgICAgZGVmaW5lc1tkXSA9IHRoaXMuZGVmaW5lc1tkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmaW5lcztcbiAgICB9XG5cbiAgICAvLyBNYWtlIGxpc3Qgb2Ygc2hhZGVyIGJsb2NrcyAoZ2xvYmFsLCB0aGVuIHByb2dyYW0tc3BlY2lmaWMpXG4gICAgYnVpbGRTaGFkZXJCbG9ja0xpc3QoKSB7XG4gICAgICAgIGxldCBrZXksIGJsb2NrcyA9IHt9O1xuXG4gICAgICAgIC8vIEdsb2JhbCBibG9ja3NcbiAgICAgICAgZm9yIChrZXkgaW4gU2hhZGVyUHJvZ3JhbS5ibG9ja3MpIHtcbiAgICAgICAgICAgIGJsb2Nrc1trZXldID0gW107XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KFNoYWRlclByb2dyYW0uYmxvY2tzW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tzW2tleV0ucHVzaChcbiAgICAgICAgICAgICAgICAgICAgLi4uU2hhZGVyUHJvZ3JhbS5ibG9ja3Nba2V5XS5tYXAoKHNvdXJjZSwgbnVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBrZXksIHNvdXJjZSwgbnVtLCBzY29wZTogJ1NoYWRlclByb2dyYW0nIH07XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJsb2Nrc1trZXldID0gW3sga2V5LCBzb3VyY2U6IFNoYWRlclByb2dyYW0uYmxvY2tzW2tleV0sIG51bTogMCwgc2NvcGU6ICdTaGFkZXJQcm9ncmFtJyB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByb2dyYW0tc3BlY2lmaWMgYmxvY2tzXG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMuYmxvY2tzKSB7XG4gICAgICAgICAgICBibG9ja3Nba2V5XSA9IGJsb2Nrc1trZXldIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmJsb2Nrc1trZXldKSkge1xuICAgICAgICAgICAgICAgIGxldCBzY29wZXMgPSAodGhpcy5ibG9ja19zY29wZXMgJiYgdGhpcy5ibG9ja19zY29wZXNba2V5XSkgfHwgW107XG4gICAgICAgICAgICAgICAgbGV0IGN1cl9zY29wZSA9IG51bGwsIG51bSA9IDA7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiPTA7IGIgPCB0aGlzLmJsb2Nrc1trZXldLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvdW50IGJsb2NrcyByZWxhdGl2ZSB0byBjdXJyZW50IHNjb3BlXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29wZXNbYl0gIT09IGN1cl9zY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyX3Njb3BlID0gc2NvcGVzW2JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1trZXldLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLmJsb2Nrc1trZXldW2JdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6IGN1cl9zY29wZSB8fCB0aGlzLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbnVtKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYWRkcmVzcyBkaXNjcmVwYW5jeSBpbiBhcnJheSB2cy4gc2luZ2xlLXZhbHVlIGJsb2Nrc1xuICAgICAgICAgICAgICAgIC8vIHN0eWxlcyBhc3N1bWUgYXJyYXkgd2hlbiB0cmFja2luZyBibG9jayBzY29wZXNcbiAgICAgICAgICAgICAgICBibG9ja3Nba2V5XS5wdXNoKHsga2V5LCBzb3VyY2U6IHRoaXMuYmxvY2tzW2tleV0sIG51bTogMCwgc2NvcGU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2tzO1xuICAgIH1cblxuICAgIC8vIERldGVjdCB1bmlmb3JtIGRlZmluaXRpb25zLCBpbmplY3QgYW55IG1pc3Npbmcgb25lc1xuICAgIGVuc3VyZVVuaWZvcm1zKHVuaWZvcm1zKSB7XG4gICAgICAgIGlmICghdW5pZm9ybXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2cyA9IHN0cmlwKHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZSk7XG4gICAgICAgIHZhciBmcyA9IHN0cmlwKHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlKTtcbiAgICAgICAgdmFyIGluamVjdCwgdnNfaW5qZWN0aW9ucyA9IFtdLCBmc19pbmplY3Rpb25zID0gW107XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG1pc3NpbmcgdW5pZm9ybSBkZWZpbml0aW9uc1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHVuaWZvcm1zKSB7XG4gICAgICAgICAgICBpbmplY3QgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBDaGVjayB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgICAgICBpZiAoIUdMU0wuaXNVbmlmb3JtRGVmaW5lZChuYW1lLCB2cykgJiYgR0xTTC5pc1N5bWJvbFJlZmVyZW5jZWQobmFtZSwgdnMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0ID0gR0xTTC5kZWZpbmVVbmlmb3JtKG5hbWUsIHVuaWZvcm1zW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nLnRyYWNlKGBQcm9ncmFtICR7dGhpcy5uYW1lfTogJHtuYW1lfSBub3QgZGVmaW5lZCBpbiB2ZXJ0ZXggc2hhZGVyLCBpbmplY3Rpbmc6ICcke2luamVjdH0nYCk7XG4gICAgICAgICAgICAgICAgdnNfaW5qZWN0aW9ucy5wdXNoKGluamVjdCk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGZyYWdtZW50IHNoYWRlclxuICAgICAgICAgICAgaWYgKCFHTFNMLmlzVW5pZm9ybURlZmluZWQobmFtZSwgZnMpICYmIEdMU0wuaXNTeW1ib2xSZWZlcmVuY2VkKG5hbWUsIGZzKSkge1xuICAgICAgICAgICAgICAgIGlmICghaW5qZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGluamVjdCA9IEdMU0wuZGVmaW5lVW5pZm9ybShuYW1lLCB1bmlmb3Jtc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZy50cmFjZShgUHJvZ3JhbSAke3RoaXMubmFtZX06ICR7bmFtZX0gbm90IGRlZmluZWQgaW4gZnJhZ21lbnQgc2hhZGVyLCBpbmplY3Rpbmc6ICcke2luamVjdH0nYCk7XG4gICAgICAgICAgICAgICAgZnNfaW5qZWN0aW9ucy5wdXNoKGluamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbmplY3QgbWlzc2luZyB1bmlmb3Jtc1xuICAgICAgICAvLyBOT1RFOiB0aGVzZSBhcmUgaW5qZWN0ZWQgYXQgdGhlIHZlcnkgdG9wIG9mIHRoZSBzaGFkZXJzLCBldmVuIGJlZm9yZSBhbnkgI2RlZmluZXMgb3IgI3ByYWdtYXMgYXJlIGFkZGVkXG4gICAgICAgIC8vIHRoaXMgY291bGQgY2F1c2Ugc29tZSBpc3N1ZXMgd2l0aCBjZXJ0YWluICNwcmFnbWFzLCBvciBvdGhlciBmdW5jdGlvbnMgdGhhdCBtaWdodCBleHBlY3QgI2RlZmluZXNcbiAgICAgICAgaWYgKHZzX2luamVjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlID0gdnNfaW5qZWN0aW9ucy5qb2luKCdcXG4nKSArIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmc19pbmplY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlID0gZnNfaW5qZWN0aW9ucy5qb2luKCdcXG4nKSArIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IHVuaWZvcm1zIGZyb20gYSBKUyBvYmplY3QsIHdpdGggaW5mZXJyZWQgdHlwZXNcbiAgICBzZXRVbmlmb3Jtcyh1bmlmb3JtcywgcmVzZXRfdGV4dHVyZV91bml0ID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29tcGlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IG9ubHkgdXBkYXRlIHVuaWZvcm1zIHdoZW4gY2hhbmdlZFxuXG4gICAgICAgIC8vIFRleHR1cmUgdW5pdHMgbXVzdCBiZSB0cmFja2VkIGFuZCBpbmNyZW1lbnRlZCBlYWNoIHRpbWUgYSB0ZXh0dXJlIHNhbXBsZXIgdW5pZm9ybSBpcyBzZXQuXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHRoZSB0ZXh0dXJlIHVuaXQgaXMgcmVzZXQgdG8gMCBlYWNoIHRpbWUgc2V0VW5pZm9ybXMgaXMgY2FsbGVkLCBidXQgdGhleSBjYW5cbiAgICAgICAgLy8gYWxzbyBiZSBwcmVzZXJ2ZWQsIGZvciBleGFtcGxlIGluIGNhc2VzIHdoZXJlIG11bHRpcGxlIGNhbGxzIHRvIHNldFVuaWZvcm1zIGFyZSBleHBlY3RlZFxuICAgICAgICAvLyAoZS5nLiBwcm9ncmFtLXNwZWNpZmljIHVuaWZvcm1zIGZvbGxvd2VkIGJ5IG1lc2gtc3BlY2lmaWMgb25lcykuXG4gICAgICAgIGlmIChyZXNldF90ZXh0dXJlX3VuaXQpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZV91bml0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhcnNlIHVuaWZvcm0gdHlwZXMgYW5kIHZhbHVlcyBmcm9tIHRoZSBKUyBvYmplY3RcbiAgICAgICAgdmFyIHBhcnNlZCA9IEdMU0wucGFyc2VVbmlmb3Jtcyh1bmlmb3Jtcyk7XG5cbiAgICAgICAgLy8gU2V0IGVhY2ggdW5pZm9ybVxuICAgICAgICBmb3IgKHZhciB1bmlmb3JtIG9mIHBhcnNlZCkge1xuICAgICAgICAgICAgaWYgKHVuaWZvcm0udHlwZSA9PT0gJ3NhbXBsZXIyRCcpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgdGV4dHVyZXMsIHdlIG5lZWQgdG8gdHJhY2sgdGV4dHVyZSB1bml0cywgc28gd2UgaGF2ZSBhIHNwZWNpYWwgc2V0dGVyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUZXh0dXJlVW5pZm9ybSh1bmlmb3JtLm5hbWUsIHVuaWZvcm0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmlmb3JtKHVuaWZvcm0ubWV0aG9kLCB1bmlmb3JtLm5hbWUsIHVuaWZvcm0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FjaGUgc29tZSBvciBhbGwgdW5pZm9ybSB2YWx1ZXMgc28gdGhleSBjYW4gYmUgcmVzdG9yZWRcbiAgICBzYXZlVW5pZm9ybXMoc3Vic2V0KSB7XG4gICAgICAgIGxldCB1bmlmb3JtcyA9IHN1YnNldCB8fCB0aGlzLnVuaWZvcm1zO1xuICAgICAgICBmb3IgKGxldCB1IGluIHVuaWZvcm1zKSB7XG4gICAgICAgICAgICBsZXQgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbdV07XG4gICAgICAgICAgICBpZiAodW5pZm9ybSkge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uc2F2ZWRfdmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2F2ZWRfdGV4dHVyZV91bml0ID0gdGhpcy50ZXh0dXJlX3VuaXQgfHwgMDtcbiAgICB9XG5cbiAgICAvLyBSZXN0b3JlIHNvbWUgb3IgYWxsIHVuaWZvcm1zIHRvIHNhdmVkIHZhbHVlc1xuICAgIHJlc3RvcmVVbmlmb3JtcyhzdWJzZXQpIHtcbiAgICAgICAgbGV0IHVuaWZvcm1zID0gc3Vic2V0IHx8IHRoaXMudW5pZm9ybXM7XG4gICAgICAgIGZvciAobGV0IHUgaW4gdW5pZm9ybXMpIHtcbiAgICAgICAgICAgIGxldCB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1t1XTtcbiAgICAgICAgICAgIGlmICh1bmlmb3JtICYmIHVuaWZvcm0uc2F2ZWRfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLnZhbHVlID0gdW5pZm9ybS5zYXZlZF92YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVVuaWZvcm0odSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXh0dXJlX3VuaXQgPSB0aGlzLnNhdmVkX3RleHR1cmVfdW5pdCB8fCAwO1xuICAgIH1cblxuICAgIC8vIFNldCBhIHRleHR1cmUgdW5pZm9ybSwgZmluZHMgdGV4dHVyZSBieSBuYW1lIG9yIGNyZWF0ZXMgYSBuZXcgb25lXG4gICAgc2V0VGV4dHVyZVVuaWZvcm0odW5pZm9ybV9uYW1lLCB0ZXh0dXJlX25hbWUpIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSBUZXh0dXJlLnRleHR1cmVzW3RleHR1cmVfbmFtZV07XG4gICAgICAgIGlmICh0ZXh0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRleHR1cmUgPSBUZXh0dXJlLmNyZWF0ZSh0aGlzLmdsLCB0ZXh0dXJlX25hbWUsIHsgdXJsOiB0ZXh0dXJlX25hbWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0dXJlLmJpbmQodGhpcy50ZXh0dXJlX3VuaXQpO1xuICAgICAgICB0aGlzLnVuaWZvcm0oJzFpJywgdW5pZm9ybV9uYW1lLCB0aGlzLnRleHR1cmVfdW5pdCk7XG4gICAgICAgIHRoaXMudGV4dHVyZV91bml0Kys7IC8vIFRPRE86IHRyYWNrIG1heCB0ZXh0dXJlIHVuaXRzIGFuZCBsb2cvdGhyb3cgZXJyb3JzXG4gICAgfVxuXG4gICAgLy8gZXg6IHByb2dyYW0udW5pZm9ybSgnM2YnLCAncG9zaXRpb24nLCB4LCB5LCB6KTtcbiAgICAvLyBUT0RPOiBvbmx5IHVwZGF0ZSB1bmlmb3JtcyB3aGVuIGNoYW5nZWRcbiAgICB1bmlmb3JtKG1ldGhvZCwgbmFtZSwgLi4udmFsdWUpIHsgLy8gJ3ZhbHVlJyBpcyBhIG1ldGhvZC1hcHByb3ByaWF0ZSBhcmd1bWVudHMgbGlzdFxuICAgICAgICBpZiAoIXRoaXMuY29tcGlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudW5pZm9ybXNbbmFtZV0gPSB0aGlzLnVuaWZvcm1zW25hbWVdIHx8IHt9O1xuICAgICAgICBsZXQgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbbmFtZV07XG4gICAgICAgIHVuaWZvcm0ubmFtZSA9IG5hbWU7XG4gICAgICAgIGlmICh1bmlmb3JtLmxvY2F0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHVuaWZvcm0ubG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHVuaWZvcm0ubWV0aG9kID0gJ3VuaWZvcm0nICsgbWV0aG9kO1xuICAgICAgICB1bmlmb3JtLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlVW5pZm9ybShuYW1lKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgYSBzaW5nbGUgdW5pZm9ybVxuICAgIHVwZGF0ZVVuaWZvcm0obmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29tcGlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1tuYW1lXTtcbiAgICAgICAgaWYgKCF1bmlmb3JtIHx8IHVuaWZvcm0ubG9jYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51c2UoKTtcbiAgICAgICAgdGhpcy5nbFt1bmlmb3JtLm1ldGhvZF0uYXBwbHkodGhpcy5nbCwgW3VuaWZvcm0ubG9jYXRpb25dLmNvbmNhdCh1bmlmb3JtLnZhbHVlKSk7IC8vIGNhbGwgYXBwcm9wcmlhdGUgR0wgdW5pZm9ybSBtZXRob2QgYW5kIHBhc3MgdGhyb3VnaCBhcmd1bWVudHNcbiAgICB9XG5cbiAgICAvLyBSZWZyZXNoIHVuaWZvcm0gbG9jYXRpb25zIGFuZCBzZXQgdG8gbGFzdCBjYWNoZWQgdmFsdWVzXG4gICAgcmVmcmVzaFVuaWZvcm1zKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29tcGlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHUgaW4gdGhpcy51bmlmb3Jtcykge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtc1t1XS5sb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgdSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVVuaWZvcm0odSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWZyZXNoQXR0cmlidXRlcygpIHtcbiAgICAgICAgLy8gdmFyIGxlbiA9IHRoaXMuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLnByb2dyYW0sIHRoaXMuZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuICAgICAgICAvLyBmb3IgKHZhciBpPTA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyAgICAgdmFyIGEgPSB0aGlzLmdsLmdldEFjdGl2ZUF0dHJpYih0aGlzLnByb2dyYW0sIGkpO1xuICAgICAgICAvLyB9XG4gICAgICAgIHRoaXMuYXR0cmlicyA9IHt9O1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgbG9jYXRpb24gb2YgYSB2ZXJ0ZXggYXR0cmlidXRlXG4gICAgYXR0cmlidXRlKG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXR0cmliID0gKHRoaXMuYXR0cmlic1tuYW1lXSA9IHRoaXMuYXR0cmlic1tuYW1lXSB8fCB7fSk7XG4gICAgICAgIGlmIChhdHRyaWIubG9jYXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGF0dHJpYjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYi5uYW1lID0gbmFtZTtcbiAgICAgICAgYXR0cmliLmxvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpO1xuXG4gICAgICAgIC8vIHZhciBpbmZvID0gdGhpcy5nbC5nZXRBY3RpdmVBdHRyaWIodGhpcy5wcm9ncmFtLCBhdHRyaWIubG9jYXRpb24pO1xuICAgICAgICAvLyBhdHRyaWIudHlwZSA9IGluZm8udHlwZTtcbiAgICAgICAgLy8gYXR0cmliLnNpemUgPSBpbmZvLnNpemU7XG5cbiAgICAgICAgcmV0dXJuIGF0dHJpYjtcbiAgICB9XG5cbiAgICAvLyBHZXQgc2hhZGVyIHNvdXJjZSBhcyBzdHJpbmdcbiAgICBzb3VyY2UodHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3ZlcnRleCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2ZyYWdtZW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IHNoYWRlciBzb3VyY2UgYXMgYXJyYXkgb2YgbGluZSBzdHJpbmdzXG4gICAgbGluZXModHlwZSkge1xuICAgICAgICBsZXQgc291cmNlID0gdGhpcy5zb3VyY2UodHlwZSk7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyBHZXQgYSBzcGVjaWZpYyBsaW5lIGZyb20gc2hhZGVyIHNvdXJjZVxuICAgIGxpbmUodHlwZSwgbnVtKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSB0aGlzLmxpbmVzKHR5cGUpO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlW251bV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXQgaW5mbyBvbiB3aGljaCBzaGFkZXIgYmxvY2sgKGlmIGFueSkgYSBwYXJ0aWN1bGFyIGxpbmUgbnVtYmVyIGluIGEgc2hhZGVyIGlzIGluXG4gICAgLy8gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGluZm8gaWYgYSBibG9jayBpcyBmb3VuZDogeyBuYW1lLCBsaW5lLCBzb3VyY2UgfVxuICAgIC8vICBzY29wZTogd2hlcmUgdGhlIHNoYWRlciBibG9jayBvcmlnaW5hdGVkLCBlaXRoZXIgYSBzdHlsZSBuYW1lLCBvciBnbG9iYWwgc3VjaCBhcyBTaGFkZXJQcm9ncmFtXG4gICAgLy8gIG5hbWU6IHNoYWRlciBibG9jayBuYW1lIChlLmcuICdjb2xvcicsICdwb3NpdGlvbicsICdnbG9iYWwnKVxuICAgIC8vICBudW06IHRoZSBibG9jayBudW1iZXIgKndpdGhpbiogbG9jYWwgc2NvcGUgKGUuZy4gaWYgYSBzdHlsZSBoYXMgbXVsdGlwbGUgJ2NvbG9yJyBibG9ja3MpXG4gICAgLy8gIGxpbmU6IGxpbmUgbnVtYmVyICp3aXRoaW4qIHRoZSBzaGFkZXIgYmxvY2sgKG5vdCB0aGUgd2hvbGUgc2hhZGVyIHByb2dyYW0pLCB1c2VmdWwgZm9yIGVycm9yIGhpZ2hsaWdodGluZ1xuICAgIC8vICBzb3VyY2U6IHRoZSBjb2RlIGZvciB0aGUgbGluZVxuICAgIC8vIE5PVEU6IHRoaXMgZG9lcyBhIGJydXRlZm9yY2UgbG9vcCBvdmVyIHRoZSBzaGFkZXIgc291cmNlIGFuZCBsb29rcyBmb3Igc2hhZGVyIGJsb2NrIHN0YXJ0L2VuZCBtYXJrZXJzXG4gICAgLy8gV2UgY291bGQgdHJhY2sgbGluZSByYW5nZXMgZm9yIHNoYWRlciBibG9ja3MgYXMgdGhleSBhcmUgaW5zZXJ0ZWQsIGJ1dCBhcyB0aGlzIGNvZGUgaXMgb25seSB1c2VkIGZvclxuICAgIC8vIGVycm9yIGhhbmRsaW5nIG9uIGNvbXBpbGF0aW9uIGZhaWx1cmUsIGl0IHdhcyBzaW1wbGVyIHRvIGtlZXAgaXQgc2VwYXJhdGUgdGhhbiB0byBidXJkZW4gdGhlIGNvcmVcbiAgICAvLyBjb21waWxhdGlvbiBwYXRoLlxuICAgIGJsb2NrKHR5cGUsIG51bSkge1xuICAgICAgICBsZXQgbGluZXMgPSB0aGlzLmxpbmVzKHR5cGUpO1xuICAgICAgICBsZXQgYmxvY2s7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IG51bSAmJiBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gbGluZXNbaV07XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBsaW5lLm1hdGNoKC9cXC9cXC8gdGFuZ3JhbS1ibG9jay1zdGFydDogKFtBLVphLXowLTlfLV0rKSwgKFtBLVphLXowLTlfLV0rKSwgKFxcZCspLyk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIG1hcmsgY3VycmVudCBibG9ja1xuICAgICAgICAgICAgICAgIGJsb2NrID0ge1xuICAgICAgICAgICAgICAgICAgICBzY29wZTogbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG1hdGNoWzJdLFxuICAgICAgICAgICAgICAgICAgICBudW06IG1hdGNoWzNdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gbGluZS5tYXRjaCgvXFwvXFwvIHRhbmdyYW0tYmxvY2stZW5kOiAoW0EtWmEtejAtOV8tXSspLCAoW0EtWmEtejAtOV8tXSspLCAoXFxkKykvKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBibG9jayA9IG51bGw7IC8vIGNsZWFyIGN1cnJlbnQgYmxvY2tcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBsaW5lICMgYW5kIGNvbnRlbnRcbiAgICAgICAgICAgIGlmIChibG9jaykge1xuICAgICAgICAgICAgICAgIC8vIGluaXQgdG8gLTEgc28gdGhhdCBsaW5lIDAgaXMgZmlyc3QgYWN0dWFsIGxpbmUgb2YgYmxvY2sgY29kZSwgYWZ0ZXIgY29tbWVudCBtYXJrZXJcbiAgICAgICAgICAgICAgICBibG9jay5saW5lID0gKGJsb2NrLmxpbmUgPT0gbnVsbCkgPyAtMSA6IGJsb2NrLmxpbmUgKyAxO1xuICAgICAgICAgICAgICAgIGJsb2NrLnNvdXJjZSA9IGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgbGlzdCBvZiBhdmFpbGFibGUgZXh0ZW5zaW9ucyBmcm9tIHRob3NlIHJlcXVlc3RlZFxuICAgIC8vIFNldHMgaW50ZXJuYWwgI2RlZmluZXMgaW5kaWNhdGluZyBhdmFpbGFiaWxpdHkgb2YgZWFjaCByZXF1ZXN0ZWQgZXh0ZW5zaW9uXG4gICAgY2hlY2tFeHRlbnNpb25zKCkge1xuICAgICAgICBsZXQgZXh0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHRoaXMuZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgbGV0IGV4dCA9IGdldEV4dGVuc2lvbih0aGlzLmdsLCBuYW1lKTtcbiAgICAgICAgICAgIGxldCBkZWYgPSBgVEFOR1JBTV9FWFRFTlNJT05fJHtuYW1lfWA7XG5cbiAgICAgICAgICAgIHRoaXMuZGVmaW5lc1tkZWZdID0gKGV4dCAhPSBudWxsKTtcblxuICAgICAgICAgICAgaWYgKGV4dCkge1xuICAgICAgICAgICAgICAgIGV4dHMucHVzaChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhgQ291bGQgbm90IGVuYWJsZSBleHRlbnNpb24gJyR7bmFtZX0nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dHM7XG4gICAgfVxuXG59XG5cblxuLy8gU3RhdGljIG1ldGhvZHMgYW5kIHN0YXRlXG5cblNoYWRlclByb2dyYW0uaWQgPSAwOyAgICAgICAgICAgLy8gYXNzaWduIGVhY2ggcHJvZ3JhbSBhIHVuaXF1ZSBpZFxuU2hhZGVyUHJvZ3JhbS5wcm9ncmFtcyA9IHt9OyAgICAvLyBwcm9ncmFtcywgYnkgaWRcblNoYWRlclByb2dyYW0uY3VycmVudCA9IG51bGw7ICAgLy8gY3VycmVudGx5IGJvdW5kIHByb2dyYW1cblxuLy8gR2xvYmFsIGNvbmZpZyBhcHBsaWVkIHRvIGFsbCBwcm9ncmFtcyAoZHVwbGljYXRlIHByb3BlcnRpZXMgZm9yIGEgc3BlY2lmaWMgcHJvZ3JhbSB3aWxsIHRha2UgcHJlY2VkZW5jZSlcblNoYWRlclByb2dyYW0uZGVmaW5lcyA9IHt9O1xuU2hhZGVyUHJvZ3JhbS5ibG9ja3MgPSB7fTtcblxuLy8gVHVybiBhbiBvYmplY3Qgb2Yga2V5L3ZhbHVlIHBhaXJzIGludG8gc2luZ2xlIHN0cmluZyBvZiAjZGVmaW5lIHN0YXRlbWVudHNcblNoYWRlclByb2dyYW0uYnVpbGREZWZpbmVTdHJpbmcgPSBmdW5jdGlvbiAoZGVmaW5lcykge1xuICAgIHZhciBkZWZpbmVfc3RyID0gXCJcIjtcbiAgICBmb3IgKHZhciBkIGluIGRlZmluZXMpIHtcbiAgICAgICAgaWYgKGRlZmluZXNbZF0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lc1tkXSA9PT0gJ2Jvb2xlYW4nICYmIGRlZmluZXNbZF0gPT09IHRydWUpIHsgLy8gYm9vbGVhbnMgYXJlIHNpbXBsZSBkZWZpbmVzIHdpdGggbm8gdmFsdWVcbiAgICAgICAgICAgIGRlZmluZV9zdHIgKz0gXCIjZGVmaW5lIFwiICsgZCArIFwiXFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZXNbZF0gPT09ICdudW1iZXInICYmIE1hdGguZmxvb3IoZGVmaW5lc1tkXSkgPT09IGRlZmluZXNbZF0pIHsgLy8gaW50IHRvIGZsb2F0IGNvbnZlcnNpb24gdG8gc2F0aXNmeSBHTFNMIGZsb2F0c1xuICAgICAgICAgICAgZGVmaW5lX3N0ciArPSBcIiNkZWZpbmUgXCIgKyBkICsgXCIgXCIgKyBkZWZpbmVzW2RdLnRvRml4ZWQoMSkgKyBcIlxcblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBhbnkgb3RoZXIgZmxvYXQgb3Igc3RyaW5nIHZhbHVlXG4gICAgICAgICAgICBkZWZpbmVfc3RyICs9IFwiI2RlZmluZSBcIiArIGQgKyBcIiBcIiArIGRlZmluZXNbZF0gKyBcIlxcblwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZpbmVfc3RyO1xufTtcblxuLy8gVHVybiBhIGxpc3Qgb2YgZXh0ZW5zaW9uIG5hbWVzIGludG8gc2luZ2xlIHN0cmluZyBvZiAjZXh0ZW5zaW9uIHN0YXRlbWVudHNcblNoYWRlclByb2dyYW0uYnVpbGRFeHRlbnNpb25TdHJpbmcgPSBmdW5jdGlvbiAoZXh0ZW5zaW9ucykge1xuICAgIGV4dGVuc2lvbnMgPSBleHRlbnNpb25zIHx8IFtdO1xuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIGZvciAobGV0IGV4dCBvZiBleHRlbnNpb25zKSB7XG4gICAgICAgIHN0ciArPSBgI2lmZGVmIEdMXyR7ZXh0fVxcbiNleHRlbnNpb24gR0xfJHtleHR9IDogZW5hYmxlXFxuI2VuZGlmXFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG5cblNoYWRlclByb2dyYW0uYWRkQmxvY2sgPSBmdW5jdGlvbiAoa2V5LCAuLi5ibG9ja3MpIHtcbiAgICBTaGFkZXJQcm9ncmFtLmJsb2Nrc1trZXldID0gU2hhZGVyUHJvZ3JhbS5ibG9ja3Nba2V5XSB8fCBbXTtcbiAgICBTaGFkZXJQcm9ncmFtLmJsb2Nrc1trZXldLnB1c2goLi4uYmxvY2tzKTtcbn07XG5cbi8vIFJlbW92ZSBhbGwgZ2xvYmFsIHNoYWRlciBibG9ja3MgZm9yIGEgZ2l2ZW4ga2V5XG5TaGFkZXJQcm9ncmFtLnJlbW92ZUJsb2NrID0gZnVuY3Rpb24gKGtleSkge1xuICAgIFNoYWRlclByb2dyYW0uYmxvY2tzW2tleV0gPSBbXTtcbn07XG5cblNoYWRlclByb2dyYW0ucmVwbGFjZUJsb2NrID0gZnVuY3Rpb24gKGtleSwgLi4uYmxvY2tzKSB7XG4gICAgU2hhZGVyUHJvZ3JhbS5yZW1vdmVCbG9jayhrZXkpO1xuICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soa2V5LCAuLi5ibG9ja3MpO1xufTtcblxuLy8gQ29tcGlsZSAmIGxpbmsgYSBXZWJHTCBwcm9ncmFtIGZyb20gcHJvdmlkZWQgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXIgc291cmNlc1xuLy8gdXBkYXRlIGEgcHJvZ3JhbSBpZiBvbmUgaXMgcGFzc2VkIGluLiBDcmVhdGUgb25lIGlmIG5vdC4gQWxlcnQgYW5kIGRvbid0IHVwZGF0ZSBhbnl0aGluZyBpZiB0aGUgc2hhZGVycyBkb24ndCBjb21waWxlLlxuU2hhZGVyUHJvZ3JhbS51cGRhdGVQcm9ncmFtID0gZnVuY3Rpb24gKGdsLCBwcm9ncmFtLCB2ZXJ0ZXhfc2hhZGVyX3NvdXJjZSwgZnJhZ21lbnRfc2hhZGVyX3NvdXJjZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciB2ZXJ0ZXhfc2hhZGVyID0gU2hhZGVyUHJvZ3JhbS5jcmVhdGVTaGFkZXIoZ2wsIHZlcnRleF9zaGFkZXJfc291cmNlLCBnbC5WRVJURVhfU0hBREVSKTtcbiAgICAgICAgdmFyIGZyYWdtZW50X3NoYWRlciA9IFNoYWRlclByb2dyYW0uY3JlYXRlU2hhZGVyKGdsLCBmcmFnbWVudF9zaGFkZXJfc291cmNlLCBnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgIH1cbiAgICBjYXRjaChlcnIpIHtcbiAgICAgICAgbG9nLmVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIGdsLnVzZVByb2dyYW0obnVsbCk7XG4gICAgaWYgKHByb2dyYW0gIT0gbnVsbCkge1xuICAgICAgICB2YXIgb2xkX3NoYWRlcnMgPSBnbC5nZXRBdHRhY2hlZFNoYWRlcnMocHJvZ3JhbSk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvbGRfc2hhZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZ2wuZGV0YWNoU2hhZGVyKHByb2dyYW0sIG9sZF9zaGFkZXJzW2ldKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgfVxuXG4gICAgaWYgKHZlcnRleF9zaGFkZXIgPT0gbnVsbCB8fCBmcmFnbWVudF9zaGFkZXIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG5cbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4X3NoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50X3NoYWRlcik7XG5cbiAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4X3NoYWRlcik7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50X3NoYWRlcik7XG5cbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgV2ViR0wgcHJvZ3JhbSBlcnJvcjpcbiAgICAgICAgICAgIFZBTElEQVRFX1NUQVRVUzogJHtnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUyl9XG4gICAgICAgICAgICBFUlJPUjogJHtnbC5nZXRFcnJvcigpfVxuICAgICAgICAgICAgLS0tIFZlcnRleCBTaGFkZXIgLS0tXG4gICAgICAgICAgICAke3ZlcnRleF9zaGFkZXJfc291cmNlfVxuICAgICAgICAgICAgLS0tIEZyYWdtZW50IFNoYWRlciAtLS1cbiAgICAgICAgICAgICR7ZnJhZ21lbnRfc2hhZGVyX3NvdXJjZX1gKTtcblxuICAgICAgICBsZXQgZXJyb3IgPSB7IHR5cGU6ICdwcm9ncmFtJywgbWVzc2FnZSB9O1xuICAgICAgICBsb2cuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9ncmFtO1xufTtcblxuLy8gQ29tcGlsZSBhIHZlcnRleCBvciBmcmFnbWVudCBzaGFkZXIgZnJvbSBwcm92aWRlZCBzb3VyY2VcblNoYWRlclByb2dyYW0uY3JlYXRlU2hhZGVyID0gZnVuY3Rpb24gKGdsLCBzb3VyY2UsIHN0eXBlKSB7XG4gICAgbGV0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihzdHlwZSk7XG5cbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgIGxldCB0eXBlID0gKHN0eXBlID09PSBnbC5WRVJURVhfU0hBREVSID8gJ3ZlcnRleCcgOiAnZnJhZ21lbnQnKTtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgICAgIGxldCBlcnJvcnMgPSBwYXJzZVNoYWRlckVycm9ycyhtZXNzYWdlKTtcbiAgICAgICAgdGhyb3cgeyB0eXBlLCBtZXNzYWdlLCBlcnJvcnMgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyO1xufTtcbiIsIi8vIEdlbmVyYXRlZCBmcm9tIEdMU0wgZmlsZXMsIGRvbid0IGVkaXQhXG52YXIgc2hhZGVyU291cmNlcyA9IHt9O1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL2FjY2Vzc29ycyddID1cblwiI2lmZGVmIFRBTkdSQU1fVkVSVEVYX1NIQURFUlxcblwiICtcblwiXFxuXCIgK1xuXCIvLyBWZXJ0ZXggcG9zaXRpb24gaW4gbW9kZWwgc3BhY2U6IFswLCAxXSByYW5nZSBvdmVyIHRoZSBsb2NhbCB0aWxlXFxuXCIgK1xuXCIvLyBOb3RlIHBvc2l0aW9ucyBjYW4gYmUgb3V0c2lkZSB0aGF0IHJhbmdlIGR1ZSB0byB1bmNsaXBwZWQgZ2VvbWV0cnksIGdlb21ldHJ5IGhpZ2hlciB0aGFuIGEgdW5pdCBjdWJlLCBldGMuXFxuXCIgK1xuXCJ2ZWM0IG1vZGVsUG9zaXRpb24oKSB7XFxuXCIgK1xuXCIgICAgcmV0dXJuXFxuXCIgK1xuXCIgICAgICAgIHZlYzQoXFxuXCIgK1xuXCIgICAgICAgICAgICBTSE9SVChhX3Bvc2l0aW9uLnh5eikgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjYWxlIG5vcm1hbGl6ZWQgc2hvcnQgdG8gZnVsbCByYW5nZVxcblwiICtcblwiICAgICAgICAgICAgLyBUQU5HUkFNX1RJTEVfU0NBTEUgICAgICAgICAgICAgICAgICAgICAgICAvLyBzY2FsZSBjb29yZHMgdG8gfjAtMSByYW5nZVxcblwiICtcblwiICAgICAgICAgICAgKiBleHAyKHVfdGlsZV9vcmlnaW4ueiAtIHVfdGlsZV9vcmlnaW4udyksICAvLyBhZGp1c3QgZm9yIHRpbGUgb3Zlcnpvb21pbmdcXG5cIiArXG5cIiAgICAgICAgMS4pXFxuXCIgK1xuXCIgICAgICAgICsgdmVjNCgwLiwgMS4sIDAuLCAwLik7XFxuXCIgK1xuXCIgICAgICAgIC8vIE5COiBhZGRpdGlvbmFsIG9mZnNldCB0byBhY2NvdW50IGZvciB1bnVzdWFsIFRhbmdyYW0gSlMgeSBjb29yZHMsXFxuXCIgK1xuXCIgICAgICAgIC8vIHNob3VsZCBiZSByZWZhY3RvcmVkIHRvIHJlbW92ZVxcblwiICtcblwifVxcblwiICtcblwiXFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiLy8gVmVydGV4IHBvc2l0aW9uIGluIHdvcmxkIGNvb3JkaW5hdGVzLCB1c2VmdWwgZm9yIDNkIHByb2NlZHVyYWwgdGV4dHVyZXMsIGV0Yy5cXG5cIiArXG5cInZlYzQgd29ybGRQb3NpdGlvbigpIHtcXG5cIiArXG5cIiAgICByZXR1cm4gdl93b3JsZF9wb3NpdGlvbjtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlxcblwiICtcblwiLy8gT3B0aW9uYWxseSB3cmFwIHdvcmxkIGNvb3JkaW5hdGVzIChhbGxvd3MgbW9yZSBwcmVjaXNpb24gYXQgaGlnaGVyIHpvb21zKVxcblwiICtcblwiLy8gZS5nLiBhdCB3cmFwIDEwMDAsIHRoZSB3b3JsZCBzcGFjZSB3aWxsIHdyYXAgZXZlcnkgMTAwMCBtZXRlcnNcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX1ZFUlRFWF9TSEFERVJcXG5cIiArXG5cIlxcblwiICtcblwidmVjNCB3cmFwV29ybGRQb3NpdGlvbih2ZWM0IHdvcmxkX3Bvc2l0aW9uKSB7XFxuXCIgK1xuXCIgICAgI2lmIGRlZmluZWQoVEFOR1JBTV9XT1JMRF9QT1NJVElPTl9XUkFQKVxcblwiICtcblwiICAgIHZlYzIgYW5jaG9yID0gdV90aWxlX29yaWdpbi54eSAtIG1vZCh1X3RpbGVfb3JpZ2luLnh5LCBUQU5HUkFNX1dPUkxEX1BPU0lUSU9OX1dSQVApO1xcblwiICtcblwiICAgICAgICB3b3JsZF9wb3NpdGlvbi54eSAtPSBhbmNob3I7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgcmV0dXJuIHdvcmxkX3Bvc2l0aW9uO1xcblwiICtcblwifVxcblwiICtcblwiXFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiLy8gTm9ybWFsIGluIHdvcmxkIHNwYWNlXFxuXCIgK1xuXCIjaWYgZGVmaW5lZChUQU5HUkFNX1ZFUlRFWF9TSEFERVIpXFxuXCIgK1xuXCJcXG5cIiArXG5cInZlYzMgd29ybGROb3JtYWwoKSB7XFxuXCIgK1xuXCIgICAgcmV0dXJuIFRBTkdSQU1fTk9STUFMO1xcblwiICtcblwifVxcblwiICtcblwiXFxuXCIgK1xuXCIjZWxpZiBkZWZpbmVkKFRBTkdSQU1fRlJBR01FTlRfU0hBREVSKVxcblwiICtcblwiXFxuXCIgK1xuXCJ2ZWMzIHdvcmxkTm9ybWFsKCkge1xcblwiICtcblwiICAgIHJldHVybiB1X2ludmVyc2VOb3JtYWxNYXRyaXggKiBUQU5HUkFNX05PUk1BTDtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlxcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9hbWJpZW50TGlnaHQnXSA9XG5cIi8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIkV4cGVjdGVkIGdsb2JhbHM6XFxuXCIgK1xuXCJsaWdodF9hY2N1bXVsYXRvcl8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIiovXFxuXCIgK1xuXCJcXG5cIiArXG5cInN0cnVjdCBBbWJpZW50TGlnaHQge1xcblwiICtcblwiICAgIHZlYzQgYW1iaWVudDtcXG5cIiArXG5cIn07XFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgY2FsY3VsYXRlTGlnaHQoaW4gQW1iaWVudExpZ2h0IF9saWdodCwgaW4gdmVjMyBfZXllVG9Qb2ludCwgaW4gdmVjMyBfbm9ybWFsKSB7XFxuXCIgK1xuXCIgICAgbGlnaHRfYWNjdW11bGF0b3JfYW1iaWVudCArPSBfbGlnaHQuYW1iaWVudDtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL2RpcmVjdGlvbmFsTGlnaHQnXSA9XG5cIi8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIkV4cGVjdGVkIGdsb2JhbHM6XFxuXCIgK1xuXCJtYXRlcmlhbFxcblwiICtcblwibGlnaHRfYWNjdW11bGF0b3JfKlxcblwiICtcblwiXFxuXCIgK1xuXCIqL1xcblwiICtcblwiXFxuXCIgK1xuXCJzdHJ1Y3QgRGlyZWN0aW9uYWxMaWdodCB7XFxuXCIgK1xuXCIgICAgdmVjNCBhbWJpZW50O1xcblwiICtcblwiICAgIHZlYzQgZGlmZnVzZTtcXG5cIiArXG5cIiAgICB2ZWM0IHNwZWN1bGFyO1xcblwiICtcblwiICAgIHZlYzMgZGlyZWN0aW9uO1xcblwiICtcblwifTtcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBjYWxjdWxhdGVMaWdodChpbiBEaXJlY3Rpb25hbExpZ2h0IF9saWdodCwgaW4gdmVjMyBfZXllVG9Qb2ludCwgaW4gdmVjMyBfbm9ybWFsKSB7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBsaWdodF9hY2N1bXVsYXRvcl9hbWJpZW50ICs9IF9saWdodC5hbWJpZW50O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgZmxvYXQgbkRvdFZQID0gY2xhbXAoZG90KF9ub3JtYWwsIC1ub3JtYWxpemUoX2xpZ2h0LmRpcmVjdGlvbikpLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFXFxuXCIgK1xuXCIgICAgICAgIGxpZ2h0X2FjY3VtdWxhdG9yX2RpZmZ1c2UgKz0gX2xpZ2h0LmRpZmZ1c2UgKiBuRG90VlA7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUlxcblwiICtcblwiICAgICAgICBmbG9hdCBwZiA9IDAuMDtcXG5cIiArXG5cIiAgICAgICAgaWYgKG5Eb3RWUCA+IDAuMCkge1xcblwiICtcblwiICAgICAgICAgICAgdmVjMyByZWZsZWN0VmVjdG9yID0gcmVmbGVjdChub3JtYWxpemUoX2xpZ2h0LmRpcmVjdGlvbiksIF9ub3JtYWwpO1xcblwiICtcblwiICAgICAgICAgICAgZmxvYXQgZXllRG90UiA9IG1heChkb3Qobm9ybWFsaXplKF9leWVUb1BvaW50KSwgcmVmbGVjdFZlY3RvciksIDAuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICBwZiA9IHBvdyhleWVEb3RSLCBtYXRlcmlhbC5zaGluaW5lc3MpO1xcblwiICtcblwiICAgICAgICB9XFxuXCIgK1xuXCIgICAgICAgIGxpZ2h0X2FjY3VtdWxhdG9yX3NwZWN1bGFyICs9IF9saWdodC5zcGVjdWxhciAqIHBmO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvbGF5ZXJfb3JkZXInXSA9XG5cIi8vIEFwcGx5IGxheWVyIG9yZGVyaW5nIHRvIGF2b2lkIHotZmlnaHRpbmdcXG5cIiArXG5cInZvaWQgYXBwbHlMYXllck9yZGVyIChmbG9hdCBsYXllciwgaW5vdXQgdmVjNCBwb3NpdGlvbikge1xcblwiICtcblwiICAgIHBvc2l0aW9uLnogLT0gbGF5ZXIgKiBUQU5HUkFNX0xBWUVSX0RFTFRBICogcG9zaXRpb24udztcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL21hdGVyaWFsJ10gPVxuXCIvKlxcblwiICtcblwiXFxuXCIgK1xuXCJEZWZpbmVzIGdsb2JhbHM6XFxuXCIgK1xuXCJtYXRlcmlhbFxcblwiICtcblwibGlnaHRfYWNjdW11bGF0b3JfKlxcblwiICtcblwiXFxuXCIgK1xuXCIqL1xcblwiICtcblwiXFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vIE1BVEVSSUFMU1xcblwiICtcblwiLy9cXG5cIiArXG5cInN0cnVjdCBNYXRlcmlhbCB7XFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRU1JU1NJT05cXG5cIiArXG5cIiAgICAgICAgdmVjNCBlbWlzc2lvbjtcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRU1JU1NJT05fVEVYVFVSRVxcblwiICtcblwiICAgICAgICAgICAgdmVjMyBlbWlzc2lvblNjYWxlO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRcXG5cIiArXG5cIiAgICAgICAgdmVjNCBhbWJpZW50O1xcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9BTUJJRU5UX1RFWFRVUkVcXG5cIiArXG5cIiAgICAgICAgICAgIHZlYzMgYW1iaWVudFNjYWxlO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VcXG5cIiArXG5cIiAgICAgICAgdmVjNCBkaWZmdXNlO1xcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFX1RFWFRVUkVcXG5cIiArXG5cIiAgICAgICAgICAgIHZlYzMgZGlmZnVzZVNjYWxlO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSXFxuXCIgK1xuXCIgICAgICAgIHZlYzQgc3BlY3VsYXI7XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IHNoaW5pbmVzcztcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJfVEVYVFVSRVxcblwiICtcblwiICAgICAgICAgICAgdmVjMyBzcGVjdWxhclNjYWxlO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkVcXG5cIiArXG5cIiAgICAgICAgdmVjMyBub3JtYWxTY2FsZTtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgbm9ybWFsQW1vdW50O1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwifTtcXG5cIiArXG5cIlxcblwiICtcblwiLy8gTm90ZTogdW5pZm9ybSBpcyBjb3BpZWQgdG8gYSBnbG9iYWwgaW5zdGFuY2UgdG8gYWxsb3cgbW9kaWZpY2F0aW9uXFxuXCIgK1xuXCJ1bmlmb3JtIE1hdGVyaWFsIHVfbWF0ZXJpYWw7XFxuXCIgK1xuXCJNYXRlcmlhbCBtYXRlcmlhbDtcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRU1JU1NJT05fVEVYVFVSRVxcblwiICtcblwidW5pZm9ybSBzYW1wbGVyMkQgdV9tYXRlcmlhbF9lbWlzc2lvbl90ZXh0dXJlO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRfVEVYVFVSRVxcblwiICtcblwidW5pZm9ybSBzYW1wbGVyMkQgdV9tYXRlcmlhbF9hbWJpZW50X3RleHR1cmU7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRV9URVhUVVJFXFxuXCIgK1xuXCJ1bmlmb3JtIHNhbXBsZXIyRCB1X21hdGVyaWFsX2RpZmZ1c2VfdGV4dHVyZTtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUl9URVhUVVJFXFxuXCIgK1xuXCJ1bmlmb3JtIHNhbXBsZXIyRCB1X21hdGVyaWFsX3NwZWN1bGFyX3RleHR1cmU7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkVcXG5cIiArXG5cInVuaWZvcm0gc2FtcGxlcjJEIHVfbWF0ZXJpYWxfbm9ybWFsX3RleHR1cmU7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiLy8gR2xvYmFsIGxpZ2h0IGFjY3VtdWxhdG9ycyBmb3IgZWFjaCBwcm9wZXJ0eVxcblwiICtcblwidmVjNCBsaWdodF9hY2N1bXVsYXRvcl9hbWJpZW50ID0gdmVjNCgwLjApO1xcblwiICtcblwidmVjNCBsaWdodF9hY2N1bXVsYXRvcl9kaWZmdXNlID0gdmVjNCgwLjApO1xcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJcXG5cIiArXG5cIiAgICB2ZWM0IGxpZ2h0X2FjY3VtdWxhdG9yX3NwZWN1bGFyID0gdmVjNCgwLjApO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfVEVYVFVSRV9TUEhFUkVNQVBcXG5cIiArXG5cInZlYzQgZ2V0U3BoZXJlTWFwIChpbiBzYW1wbGVyMkQgX3RleCwgaW4gdmVjMyBfZXllVG9Qb2ludCwgaW4gdmVjMyBfbm9ybWFsLCBpbiB2ZWMyIF9za2V3KSB7XFxuXCIgK1xuXCIgICAgdmVjMyBleWUgPSBub3JtYWxpemUoX2V5ZVRvUG9pbnQpO1xcblwiICtcblwiICAgIGV5ZS54eSAtPSBfc2tldztcXG5cIiArXG5cIiAgICBleWUgPSBub3JtYWxpemUoZXllKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIHZlYzMgciA9IHJlZmxlY3QoZXllLCBfbm9ybWFsKTtcXG5cIiArXG5cIiAgICByLnogKz0gMS4wO1xcblwiICtcblwiICAgIGZsb2F0IG0gPSAyLiAqIGxlbmd0aChyKTtcXG5cIiArXG5cIiAgICB2ZWMyIHV2ID0gci54eSAvIG0gKyAuNTtcXG5cIiArXG5cIiAgICByZXR1cm4gdGV4dHVyZTJEKF90ZXgsIHV2KTtcXG5cIiArXG5cIn1cXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1RFWFRVUkVfVFJJUExBTkFSXFxuXCIgK1xuXCJ2ZWMzIGdldFRyaVBsYW5hckJsZW5kIChpbiB2ZWMzIF9ub3JtYWwpIHtcXG5cIiArXG5cIiAgICB2ZWMzIGJsZW5kaW5nID0gYWJzKF9ub3JtYWwpO1xcblwiICtcblwiICAgIGJsZW5kaW5nID0gbm9ybWFsaXplKG1heChibGVuZGluZywgMC4wMDAwMSkpO1xcblwiICtcblwiICAgIGZsb2F0IGIgPSAoYmxlbmRpbmcueCArIGJsZW5kaW5nLnkgKyBibGVuZGluZy56KTtcXG5cIiArXG5cIiAgICByZXR1cm4gYmxlbmRpbmcgLyBiO1xcblwiICtcblwifVxcblwiICtcblwiXFxuXCIgK1xuXCJ2ZWM0IGdldFRyaVBsYW5hciAoaW4gc2FtcGxlcjJEIF90ZXgsIGluIHZlYzMgX3BvcywgaW4gdmVjMyBfbm9ybWFsLCBpbiB2ZWMzIF9zY2FsZSkge1xcblwiICtcblwiICAgIHZlYzMgYmxlbmRpbmcgPSBnZXRUcmlQbGFuYXJCbGVuZChfbm9ybWFsKTtcXG5cIiArXG5cIiAgICB2ZWM0IHhheGlzID0gdGV4dHVyZTJEKF90ZXgsIGZyYWN0KF9wb3MueXogKiBfc2NhbGUueCkpO1xcblwiICtcblwiICAgIHZlYzQgeWF4aXMgPSB0ZXh0dXJlMkQoX3RleCwgZnJhY3QoX3Bvcy54eiAqIF9zY2FsZS55KSk7XFxuXCIgK1xuXCIgICAgdmVjNCB6YXhpcyA9IHRleHR1cmUyRChfdGV4LCBmcmFjdChfcG9zLnh5ICogX3NjYWxlLnopKTtcXG5cIiArXG5cIiAgICByZXR1cm4gIHhheGlzICogYmxlbmRpbmcueCArIHlheGlzICogYmxlbmRpbmcueSArIHpheGlzICogYmxlbmRpbmcuejtcXG5cIiArXG5cIn1cXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1RFWFRVUkVfUExBTkFSXFxuXCIgK1xuXCJ2ZWM0IGdldFBsYW5hciAoaW4gc2FtcGxlcjJEIF90ZXgsIGluIHZlYzMgX3BvcywgaW4gdmVjMiBfc2NhbGUpIHtcXG5cIiArXG5cIiAgICByZXR1cm4gdGV4dHVyZTJEKCBfdGV4LCBmcmFjdChfcG9zLnh5ICogX3NjYWxlLngpICk7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9OT1JNQUxfVEVYVFVSRVxcblwiICtcblwidm9pZCBjYWxjdWxhdGVOb3JtYWwgKGlub3V0IHZlYzMgX25vcm1hbCkge1xcblwiICtcblwiICAgIC8vIEdldCBOT1JNQUxNQVBcXG5cIiArXG5cIiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX05PUk1BTF9URVhUVVJFX1VWXFxuXCIgK1xuXCIgICAgX25vcm1hbCArPSB0ZXh0dXJlMkQodV9tYXRlcmlhbF9ub3JtYWxfdGV4dHVyZSwgZnJhY3Qodl90ZXhjb29yZCptYXRlcmlhbC5ub3JtYWxTY2FsZS54eSkpLnJnYioyLjAtMS4wO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkVfUExBTkFSXFxuXCIgK1xuXCIgICAgdmVjMyBub3JtYWxUZXggPSBnZXRQbGFuYXIodV9tYXRlcmlhbF9ub3JtYWxfdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIG1hdGVyaWFsLm5vcm1hbFNjYWxlLnh5KS5yZ2IqMi4wLTEuMDtcXG5cIiArXG5cIiAgICBfbm9ybWFsICs9IG5vcm1hbFRleDtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX05PUk1BTF9URVhUVVJFX1RSSVBMQU5BUlxcblwiICtcblwiICAgIHZlYzMgbm9ybWFsVGV4ID0gZ2V0VHJpUGxhbmFyKHVfbWF0ZXJpYWxfbm9ybWFsX3RleHR1cmUsIHZfd29ybGRfcG9zaXRpb24ueHl6LCBfbm9ybWFsLCBtYXRlcmlhbC5ub3JtYWxTY2FsZSkucmdiKjIuMC0xLjA7XFxuXCIgK1xuXCIgICAgX25vcm1hbCArPSBub3JtYWxUZXg7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBfbm9ybWFsID0gbm9ybWFsaXplKF9ub3JtYWwpO1xcblwiICtcblwifVxcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgY2FsY3VsYXRlTWF0ZXJpYWwgKGluIHZlYzMgX2V5ZVRvUG9pbnQsIGlub3V0IHZlYzMgX25vcm1hbCkge1xcblwiICtcblwiICAgIC8vIGdldCBFTUlTU0lPTiBURVhUVVJFTUFQXFxuXCIgK1xuXCIgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9FTUlTU0lPTl9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0VNSVNTSU9OX1RFWFRVUkVfVVZcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuZW1pc3Npb24gKj0gdGV4dHVyZTJEKHVfbWF0ZXJpYWxfZW1pc3Npb25fdGV4dHVyZSx2X3RleGNvb3JkKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRU1JU1NJT05fVEVYVFVSRV9QTEFOQVJcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuZW1pc3Npb24gKj0gZ2V0UGxhbmFyKHVfbWF0ZXJpYWxfZW1pc3Npb25fdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIG1hdGVyaWFsLmVtaXNzaW9uU2NhbGUueHkpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9FTUlTU0lPTl9URVhUVVJFX1RSSVBMQU5BUlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5lbWlzc2lvbiAqPSBnZXRUcmlQbGFuYXIodV9tYXRlcmlhbF9lbWlzc2lvbl90ZXh0dXJlLCB2X3dvcmxkX3Bvc2l0aW9uLnh5eiwgX25vcm1hbCwgbWF0ZXJpYWwuZW1pc3Npb25TY2FsZSk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0VNSVNTSU9OX1RFWFRVUkVfU1BIRVJFTUFQXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmVtaXNzaW9uICo9IGdldFNwaGVyZU1hcCh1X21hdGVyaWFsX2VtaXNzaW9uX3RleHR1cmUsIF9leWVUb1BvaW50LCBfbm9ybWFsLCB1X3ZhbmlzaGluZ19wb2ludCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gZ2V0IEFNQklFTlQgVEVYVFVSRU1BUFxcblwiICtcblwiICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfQU1CSUVOVF9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRfVEVYVFVSRV9VVlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5hbWJpZW50ICo9IHRleHR1cmUyRCh1X21hdGVyaWFsX2FtYmllbnRfdGV4dHVyZSx2X3RleGNvb3JkKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfQU1CSUVOVF9URVhUVVJFX1BMQU5BUlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5hbWJpZW50ICo9IGdldFBsYW5hcih1X21hdGVyaWFsX2FtYmllbnRfdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIG1hdGVyaWFsLmFtYmllbnRTY2FsZS54eSk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRfVEVYVFVSRV9UUklQTEFOQVJcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuYW1iaWVudCAqPSBnZXRUcmlQbGFuYXIodV9tYXRlcmlhbF9hbWJpZW50X3RleHR1cmUsIHZfd29ybGRfcG9zaXRpb24ueHl6LCBfbm9ybWFsLCBtYXRlcmlhbC5hbWJpZW50U2NhbGUpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9BTUJJRU5UX1RFWFRVUkVfU1BIRVJFTUFQXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmFtYmllbnQgKj0gZ2V0U3BoZXJlTWFwKHVfbWF0ZXJpYWxfYW1iaWVudF90ZXh0dXJlLCBfZXllVG9Qb2ludCwgX25vcm1hbCwgdV92YW5pc2hpbmdfcG9pbnQpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIGdldCBESUZGVVNFIFRFWFRVUkVNQVBcXG5cIiArXG5cIiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VfVEVYVFVSRVxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFX1RFWFRVUkVfVVZcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuZGlmZnVzZSAqPSB0ZXh0dXJlMkQodV9tYXRlcmlhbF9kaWZmdXNlX3RleHR1cmUsdl90ZXhjb29yZCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VfVEVYVFVSRV9QTEFOQVJcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuZGlmZnVzZSAqPSBnZXRQbGFuYXIodV9tYXRlcmlhbF9kaWZmdXNlX3RleHR1cmUsIHZfd29ybGRfcG9zaXRpb24ueHl6LCBtYXRlcmlhbC5kaWZmdXNlU2NhbGUueHkpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFX1RFWFRVUkVfVFJJUExBTkFSXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmRpZmZ1c2UgKj0gZ2V0VHJpUGxhbmFyKHVfbWF0ZXJpYWxfZGlmZnVzZV90ZXh0dXJlLCB2X3dvcmxkX3Bvc2l0aW9uLnh5eiwgX25vcm1hbCwgbWF0ZXJpYWwuZGlmZnVzZVNjYWxlKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRV9URVhUVVJFX1NQSEVSRU1BUFxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5kaWZmdXNlICo9IGdldFNwaGVyZU1hcCh1X21hdGVyaWFsX2RpZmZ1c2VfdGV4dHVyZSwgX2V5ZVRvUG9pbnQsIF9ub3JtYWwsIHVfdmFuaXNoaW5nX3BvaW50KTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBnZXQgU1BFQ1VMQVIgVEVYVFVSRU1BUFxcblwiICtcblwiICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJfVEVYVFVSRVxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUl9URVhUVVJFX1VWXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLnNwZWN1bGFyICo9IHRleHR1cmUyRCh1X21hdGVyaWFsX3NwZWN1bGFyX3RleHR1cmUsdl90ZXhjb29yZCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSX1RFWFRVUkVfUExBTkFSXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLnNwZWN1bGFyICo9IGdldFBsYW5hcih1X21hdGVyaWFsX3NwZWN1bGFyX3RleHR1cmUsIHZfd29ybGRfcG9zaXRpb24ueHl6LCBtYXRlcmlhbC5zcGVjdWxhclNjYWxlLnh5KTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJfVEVYVFVSRV9UUklQTEFOQVJcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuc3BlY3VsYXIgKj0gZ2V0VHJpUGxhbmFyKHVfbWF0ZXJpYWxfc3BlY3VsYXJfdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIF9ub3JtYWwsIG1hdGVyaWFsLnNwZWN1bGFyU2NhbGUpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUl9URVhUVVJFX1NQSEVSRU1BUFxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5zcGVjdWxhciAqPSBnZXRTcGhlcmVNYXAodV9tYXRlcmlhbF9zcGVjdWxhcl90ZXh0dXJlLCBfZXllVG9Qb2ludCwgX25vcm1hbCwgdV92YW5pc2hpbmdfcG9pbnQpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3BvaW50TGlnaHQnXSA9XG5cIi8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIkV4cGVjdGVkIGdsb2JhbHM6XFxuXCIgK1xuXCJtYXRlcmlhbFxcblwiICtcblwibGlnaHRfYWNjdW11bGF0b3JfKlxcblwiICtcblwiXFxuXCIgK1xuXCIqL1xcblwiICtcblwiXFxuXCIgK1xuXCJzdHJ1Y3QgUG9pbnRMaWdodCB7XFxuXCIgK1xuXCIgICAgdmVjNCBhbWJpZW50O1xcblwiICtcblwiICAgIHZlYzQgZGlmZnVzZTtcXG5cIiArXG5cIiAgICB2ZWM0IHNwZWN1bGFyO1xcblwiICtcblwiICAgIHZlYzQgcG9zaXRpb247XFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fRVhQT05FTlRcXG5cIiArXG5cIiAgICBmbG9hdCBhdHRlbnVhdGlvbkV4cG9uZW50O1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTXFxuXCIgK1xuXCIgICAgZmxvYXQgaW5uZXJSYWRpdXM7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICBmbG9hdCBvdXRlclJhZGl1cztcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwifTtcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBjYWxjdWxhdGVMaWdodChpbiBQb2ludExpZ2h0IF9saWdodCwgaW4gdmVjMyBfZXllVG9Qb2ludCwgaW4gdmVjMyBfbm9ybWFsKSB7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKF9saWdodC5wb3NpdGlvbi54eXogLSBfZXllVG9Qb2ludCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBDb21wdXRlIHZlY3RvciBmcm9tIHN1cmZhY2UgdG8gbGlnaHQgcG9zaXRpb25cXG5cIiArXG5cIiAgICB2ZWMzIFZQID0gKF9saWdodC5wb3NpdGlvbi54eXogLSBfZXllVG9Qb2ludCkgLyBkaXN0O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gTm9ybWFsaXplIHRoZSB2ZWN0b3IgZnJvbSBzdXJmYWNlIHRvIGxpZ2h0IHBvc2l0aW9uXFxuXCIgK1xuXCIgICAgZmxvYXQgbkRvdFZQID0gY2xhbXAoZG90KFZQLCBfbm9ybWFsKSwgMC4wLCAxLjApO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQXR0ZW51YXRpb24gZGVmYXVsdHNcXG5cIiArXG5cIiAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IDEuMDtcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0VYUE9ORU5UXFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IFJpbiA9IDEuMDtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgZSA9IF9saWdodC5hdHRlbnVhdGlvbkV4cG9uZW50O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICBSaW4gPSBfbGlnaHQuaW5uZXJSYWRpdXM7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fT1VURVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBSZGlmZiA9IF9saWdodC5vdXRlclJhZGl1cy1SaW47XFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBkID0gY2xhbXAobWF4KDAuMCxkaXN0LVJpbikvUmRpZmYsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgIGF0dGVudWF0aW9uID0gMS4wLShwb3coZCxlKSk7XFxuXCIgK1xuXCIgICAgICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgICAgICAvLyBJZiBubyBvdXRlciBpcyBwcm92aWRlIGJlaGF2ZXMgbGlrZTpcXG5cIiArXG5cIiAgICAgICAgICAgIC8vIGh0dHBzOi8vaW1kb2luZ2l0d3Jvbmcud29yZHByZXNzLmNvbS8yMDExLzAxLzMxL2xpZ2h0LWF0dGVudWF0aW9uL1xcblwiICtcblwiICAgICAgICAgICAgZmxvYXQgZCA9IG1heCgwLjAsZGlzdC1SaW4pL1JpbisxLjA7XFxuXCIgK1xuXCIgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IGNsYW1wKDEuMC8ocG93KGQsZSkpLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IFJpbiA9IDAuMDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0lOTkVSX1JBRElVU1xcblwiICtcblwiICAgICAgICAgICAgUmluID0gX2xpZ2h0LmlubmVyUmFkaXVzO1xcblwiICtcblwiICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBSZGlmZiA9IF9saWdodC5vdXRlclJhZGl1cy1SaW47XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgZmxvYXQgZCA9IGNsYW1wKG1heCgwLjAsZGlzdC1SaW4pL1JkaWZmLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgYXR0ZW51YXRpb24gPSAxLjAtZCpkO1xcblwiICtcblwiICAgICAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgICAgICAvLyBJZiBubyBvdXRlciBpcyBwcm92aWRlIGJlaGF2ZXMgbGlrZTpcXG5cIiArXG5cIiAgICAgICAgICAgICAgICAvLyBodHRwczovL2ltZG9pbmdpdHdyb25nLndvcmRwcmVzcy5jb20vMjAxMS8wMS8zMS9saWdodC1hdHRlbnVhdGlvbi9cXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBkID0gbWF4KDAuMCxkaXN0LVJpbikvUmluKzEuMDtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IGNsYW1wKDEuMC9kLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fT1VURVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgZmxvYXQgZCA9IGNsYW1wKGRpc3QvX2xpZ2h0Lm91dGVyUmFkaXVzLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgYXR0ZW51YXRpb24gPSAxLjAtZCpkO1xcblwiICtcblwiICAgICAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IDEuMDtcXG5cIiArXG5cIiAgICAgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIENvbXB1dGVyIGFjY3VtdWxhdG9yc1xcblwiICtcblwiICAgIGxpZ2h0X2FjY3VtdWxhdG9yX2FtYmllbnQgKz0gX2xpZ2h0LmFtYmllbnQgKiBhdHRlbnVhdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VcXG5cIiArXG5cIiAgICAgICAgbGlnaHRfYWNjdW11bGF0b3JfZGlmZnVzZSArPSBfbGlnaHQuZGlmZnVzZSAqIG5Eb3RWUCAqIGF0dGVudWF0aW9uO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgcGYgPSAwLjA7IC8vIHBvd2VyIGZhY3RvciBmb3Igc2hpbnkgc3BlY3VsYXJzXFxuXCIgK1xuXCIgICAgICAgIGlmIChuRG90VlAgPiAwLjApIHtcXG5cIiArXG5cIiAgICAgICAgICAgIHZlYzMgcmVmbGVjdFZlY3RvciA9IHJlZmxlY3QoLVZQLCBfbm9ybWFsKTtcXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IGV5ZURvdFIgPSBtYXgoMC4wLCBkb3QoLW5vcm1hbGl6ZShfZXllVG9Qb2ludCksIHJlZmxlY3RWZWN0b3IpKTtcXG5cIiArXG5cIiAgICAgICAgICAgIHBmID0gcG93KGV5ZURvdFIsIG1hdGVyaWFsLnNoaW5pbmVzcyk7XFxuXCIgK1xuXCIgICAgICAgIH1cXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICBsaWdodF9hY2N1bXVsYXRvcl9zcGVjdWxhciArPSBfbGlnaHQuc3BlY3VsYXIgKiBwZiAqIGF0dGVudWF0aW9uO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvc2VsZWN0aW9uX2ZyYWdtZW50J10gPVxuXCIvLyBGcmFnbWVudCBzaGFkZXIgZm9yIGZlYXR1cmUgc2VsZWN0aW9uIHBhc3Nlc1xcblwiICtcblwiLy8gUmVuZGVycyBpbiBzaWxob3VldHRlIGFjY29yZGluZyB0byBzZWxlY3Rpb24gKHBpY2tpbmcpIGNvbG9yLCBvciBibGFjayBpZiBub25lIGRlZmluZWRcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fRkVBVFVSRV9TRUxFQ1RJT05cXG5cIiArXG5cIiAgICB2YXJ5aW5nIHZlYzQgdl9zZWxlY3Rpb25fY29sb3I7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBtYWluICh2b2lkKSB7XFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fRkVBVFVSRV9TRUxFQ1RJT05cXG5cIiArXG5cIiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdl9zZWxlY3Rpb25fY29sb3I7XFxuXCIgK1xuXCIgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLiwgMC4sIDAuLCAxLik7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9zZWxlY3Rpb25fZ2xvYmFscyddID1cblwiLy8gVmVydGV4IGF0dHJpYnV0ZSArIHZhcnlpbmcgZm9yIGZlYXR1cmUgc2VsZWN0aW9uXFxuXCIgK1xuXCIjaWYgZGVmaW5lZChUQU5HUkFNX0ZFQVRVUkVfU0VMRUNUSU9OKSAmJiBkZWZpbmVkKFRBTkdSQU1fVkVSVEVYX1NIQURFUilcXG5cIiArXG5cIiAgICBhdHRyaWJ1dGUgdmVjNCBhX3NlbGVjdGlvbl9jb2xvcjtcXG5cIiArXG5cIiAgICB2YXJ5aW5nIHZlYzQgdl9zZWxlY3Rpb25fY29sb3I7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3NlbGVjdGlvbl92ZXJ0ZXgnXSA9XG5cIi8vIFNlbGVjdGlvbiBwYXNzLXNwZWNpZmljIHJlbmRlcmluZ1xcblwiICtcblwiI2lmIGRlZmluZWQoVEFOR1JBTV9GRUFUVVJFX1NFTEVDVElPTikgJiYgZGVmaW5lZChUQU5HUkFNX1ZFUlRFWF9TSEFERVIpXFxuXCIgK1xuXCIgICAgaWYgKGFfc2VsZWN0aW9uX2NvbG9yLnJnYiA9PSB2ZWMzKDAuKSkge1xcblwiICtcblwiICAgICAgICAvLyBEaXNjYXJkIGJ5IGZvcmNpbmcgaW52YWxpZCB0cmlhbmdsZSBpZiB3ZVxcJ3JlIGluIHRoZSBmZWF0dXJlXFxuXCIgK1xuXCIgICAgICAgIC8vIHNlbGVjdGlvbiBwYXNzIGJ1dCBoYXZlIG5vIHNlbGVjdGlvbiBpbmZvXFxuXCIgK1xuXCIgICAgICAgIC8vIFRPRE86IGluIHNvbWUgY2FzZXMgd2UgbWF5IGFjdHVhbGx5IHdhbnQgbm9uLXNlbGVjdGFibGUgZmVhdHVyZXMgdG8gb2NjbHVkZSBzZWxlY3RhYmxlIG9uZXM/XFxuXCIgK1xuXCIgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgwLiwgMC4sIDAuLCAxLik7XFxuXCIgK1xuXCIgICAgICAgIHJldHVybjtcXG5cIiArXG5cIiAgICB9XFxuXCIgK1xuXCIgICAgdl9zZWxlY3Rpb25fY29sb3IgPSBhX3NlbGVjdGlvbl9jb2xvcjtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvc3BoZXJpY2FsX2Vudmlyb25tZW50X21hcCddID1cblwiLy8gU3BoZXJpY2FsIGVudmlyb25tZW50IG1hcFxcblwiICtcblwiLy8gQmFzZWQgb246IGh0dHA6Ly93d3cuY2xpY2t0b3JlbGVhc2UuY29tL2Jsb2cvY3JlYXRpbmctc3BoZXJpY2FsLWVudmlyb25tZW50LW1hcHBpbmctc2hhZGVyXFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vIHZpZXc6IGxvY2F0aW9uIG9mIGNhbWVyYVxcblwiICtcblwiLy8gcG9zaXRpb246IGxvY2F0aW9uIG9mIGN1cnJlbnQgcG9pbnQgb24gc3VyZmFjZVxcblwiICtcblwiLy8gbm9ybWFsOiBub3JtYWwgb2YgY3VycmVudCBwb2ludCBvbiBzdXJmYWNlXFxuXCIgK1xuXCIvLyBza2V3OiBza2V3aW5nIGZhY3RvciAodXNlZCB0byBjb21wZW5zYXRlIGZvciBhbHRlcmVkIHZhbmlzaGluZyBwb2ludClcXG5cIiArXG5cIi8vIGVudm1hcDogc3BoZXJpY2FsIGVudmlyb25tZW50IG1hcCB0ZXh0dXJlXFxuXCIgK1xuXCJcXG5cIiArXG5cInZlYzQgc3BoZXJpY2FsRW52aXJvbm1lbnRNYXAodmVjMyB2aWV3LCB2ZWMzIHBvc2l0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMiBza2V3LCBzYW1wbGVyMkQgZW52bWFwKSB7XFxuXCIgK1xuXCIgICAgLy8gTm9ybWFsaXplZCB2ZWN0b3IgZnJvbSBjYW1lcmEgdG8gc3VyZmFjZVxcblwiICtcblwiICAgIHZlYzMgZXllID0gbm9ybWFsaXplKHBvc2l0aW9uLnh5eiAtIHZpZXcueHl6KTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFNrZXdcXG5cIiArXG5cIiAgICBleWUueHkgLT0gc2tldztcXG5cIiArXG5cIiAgICBleWUgPSBub3JtYWxpemUoZXllKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFJlZmxlY3Rpb24gb2YgZXllIG9mZiBvZiBzdXJmYWNlIG5vcm1hbFxcblwiICtcblwiICAgIHZlYzMgciA9IHJlZmxlY3QoZXllLCBub3JtYWwpO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gTWFwIHJlZmxlY3RlZCB2ZWN0b3Igb250byB0aGUgc3VyZmFjZSBvZiBhIHNwaGVyZVxcblwiICtcblwiICAgIHIueiArPSAxLjtcXG5cIiArXG5cIiAgICBmbG9hdCBtID0gMi4gKiBsZW5ndGgocik7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBBZGp1c3QgeHkgdG8gYWNjb3VudCBmb3Igc3BoZXJpY2FsIHNoYXBlLCBhbmQgY2VudGVyIGluIG1pZGRsZSBvZiB0ZXh0dXJlXFxuXCIgK1xuXCIgICAgdmVjMiB1diA9IHIueHkgLyBtICsgLjU7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBTYW1wbGUgdGhlIGVudmlyb25tZW50IG1hcFxcblwiICtcblwiICAgIHJldHVybiB0ZXh0dXJlMkQoZW52bWFwLCB1dik7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9zcG90TGlnaHQnXSA9XG5cIi8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIkV4cGVjdGVkIGdsb2JhbHM6XFxuXCIgK1xuXCJtYXRlcmlhbFxcblwiICtcblwibGlnaHRfYWNjdW11bGF0b3JfKlxcblwiICtcblwiXFxuXCIgK1xuXCIqL1xcblwiICtcblwiXFxuXCIgK1xuXCJzdHJ1Y3QgU3BvdExpZ2h0IHtcXG5cIiArXG5cIiAgICB2ZWM0IGFtYmllbnQ7XFxuXCIgK1xuXCIgICAgdmVjNCBkaWZmdXNlO1xcblwiICtcblwiICAgIHZlYzQgc3BlY3VsYXI7XFxuXCIgK1xuXCIgICAgdmVjNCBwb3NpdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9FWFBPTkVOVFxcblwiICtcblwiICAgIGZsb2F0IGF0dGVudWF0aW9uRXhwb25lbnQ7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9JTk5FUl9SQURJVVNcXG5cIiArXG5cIiAgICBmbG9hdCBpbm5lclJhZGl1cztcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVU1xcblwiICtcblwiICAgIGZsb2F0IG91dGVyUmFkaXVzO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICB2ZWMzIGRpcmVjdGlvbjtcXG5cIiArXG5cIiAgICBmbG9hdCBzcG90Q29zQ3V0b2ZmO1xcblwiICtcblwiICAgIGZsb2F0IHNwb3RFeHBvbmVudDtcXG5cIiArXG5cIn07XFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgY2FsY3VsYXRlTGlnaHQoaW4gU3BvdExpZ2h0IF9saWdodCwgaW4gdmVjMyBfZXllVG9Qb2ludCwgaW4gdmVjMyBfbm9ybWFsKSB7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKF9saWdodC5wb3NpdGlvbi54eXogLSBfZXllVG9Qb2ludCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBDb21wdXRlIHZlY3RvciBmcm9tIHN1cmZhY2UgdG8gbGlnaHQgcG9zaXRpb25cXG5cIiArXG5cIiAgICB2ZWMzIFZQID0gKF9saWdodC5wb3NpdGlvbi54eXogLSBfZXllVG9Qb2ludCkgLyBkaXN0O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gbm9ybWFsIC4gbGlnaHQgZGlyZWN0aW9uXFxuXCIgK1xuXCIgICAgZmxvYXQgbkRvdFZQID0gY2xhbXAoZG90KF9ub3JtYWwsIFZQKSwgMC4wLCAxLjApO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQXR0ZW51YXRpb24gZGVmYXVsdHNcXG5cIiArXG5cIiAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IDEuMDtcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0VYUE9ORU5UXFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IFJpbiA9IDEuMDtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgZSA9IF9saWdodC5hdHRlbnVhdGlvbkV4cG9uZW50O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICBSaW4gPSBfbGlnaHQuaW5uZXJSYWRpdXM7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fT1VURVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBSZGlmZiA9IF9saWdodC5vdXRlclJhZGl1cy1SaW47XFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBkID0gY2xhbXAobWF4KDAuMCxkaXN0LVJpbikvUmRpZmYsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgIGF0dGVudWF0aW9uID0gMS4wLShwb3coZCxlKSk7XFxuXCIgK1xuXCIgICAgICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgICAgICAvLyBJZiBubyBvdXRlciBpcyBwcm92aWRlIGJlaGF2ZXMgbGlrZTpcXG5cIiArXG5cIiAgICAgICAgICAgIC8vIGh0dHBzOi8vaW1kb2luZ2l0d3Jvbmcud29yZHByZXNzLmNvbS8yMDExLzAxLzMxL2xpZ2h0LWF0dGVudWF0aW9uL1xcblwiICtcblwiICAgICAgICAgICAgZmxvYXQgZCA9IG1heCgwLjAsZGlzdC1SaW4pL1JpbisxLjA7XFxuXCIgK1xuXCIgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IGNsYW1wKDEuMC8ocG93KGQsZSkpLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IFJpbiA9IDAuMDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0lOTkVSX1JBRElVU1xcblwiICtcblwiICAgICAgICAgICAgUmluID0gX2xpZ2h0LmlubmVyUmFkaXVzO1xcblwiICtcblwiICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBSZGlmZiA9IF9saWdodC5vdXRlclJhZGl1cy1SaW47XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgZmxvYXQgZCA9IGNsYW1wKG1heCgwLjAsZGlzdC1SaW4pL1JkaWZmLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgYXR0ZW51YXRpb24gPSAxLjAtZCpkO1xcblwiICtcblwiICAgICAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgICAgICAvLyBJZiBubyBvdXRlciBpcyBwcm92aWRlIGJlaGF2ZXMgbGlrZTpcXG5cIiArXG5cIiAgICAgICAgICAgICAgICAvLyBodHRwczovL2ltZG9pbmdpdHdyb25nLndvcmRwcmVzcy5jb20vMjAxMS8wMS8zMS9saWdodC1hdHRlbnVhdGlvbi9cXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBkID0gbWF4KDAuMCxkaXN0LVJpbikvUmluKzEuMDtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IGNsYW1wKDEuMC9kLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fT1VURVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgZmxvYXQgZCA9IGNsYW1wKGRpc3QvX2xpZ2h0Lm91dGVyUmFkaXVzLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgYXR0ZW51YXRpb24gPSAxLjAtZCpkO1xcblwiICtcblwiICAgICAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IDEuMDtcXG5cIiArXG5cIiAgICAgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIHNwb3RsaWdodCBhdHRlbnVhdGlvbiBmYWN0b3JcXG5cIiArXG5cIiAgICBmbG9hdCBzcG90QXR0ZW51YXRpb24gPSAwLjA7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBTZWUgaWYgcG9pbnQgb24gc3VyZmFjZSBpcyBpbnNpZGUgY29uZSBvZiBpbGx1bWluYXRpb25cXG5cIiArXG5cIiAgICBmbG9hdCBzcG90RG90ID0gY2xhbXAoZG90KC1WUCwgbm9ybWFsaXplKF9saWdodC5kaXJlY3Rpb24pKSwgMC4wLCAxLjApO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgaWYgKHNwb3REb3QgPj0gX2xpZ2h0LnNwb3RDb3NDdXRvZmYpIHtcXG5cIiArXG5cIiAgICAgICAgc3BvdEF0dGVudWF0aW9uID0gcG93KHNwb3REb3QsIF9saWdodC5zcG90RXhwb25lbnQpO1xcblwiICtcblwiICAgIH1cXG5cIiArXG5cIlxcblwiICtcblwiICAgIGxpZ2h0X2FjY3VtdWxhdG9yX2FtYmllbnQgKz0gX2xpZ2h0LmFtYmllbnQgKiBhdHRlbnVhdGlvbiAqIHNwb3RBdHRlbnVhdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VcXG5cIiArXG5cIiAgICAgICAgbGlnaHRfYWNjdW11bGF0b3JfZGlmZnVzZSArPSBfbGlnaHQuZGlmZnVzZSAqIG5Eb3RWUCAqIGF0dGVudWF0aW9uICogc3BvdEF0dGVudWF0aW9uO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJcXG5cIiArXG5cIiAgICAgICAgLy8gUG93ZXIgZmFjdG9yIGZvciBzaGlueSBzcGVjdWxhcnNcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgcGYgPSAwLjA7XFxuXCIgK1xuXCIgICAgICAgIGlmIChuRG90VlAgPiAwLjApIHtcXG5cIiArXG5cIiAgICAgICAgICAgIHZlYzMgcmVmbGVjdFZlY3RvciA9IHJlZmxlY3QoLVZQLCBfbm9ybWFsKTtcXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IGV5ZURvdFIgPSBtYXgoZG90KC1ub3JtYWxpemUoX2V5ZVRvUG9pbnQpLCByZWZsZWN0VmVjdG9yKSwgMC4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgIHBmID0gcG93KGV5ZURvdFIsIG1hdGVyaWFsLnNoaW5pbmVzcyk7XFxuXCIgK1xuXCIgICAgICAgIH1cXG5cIiArXG5cIiAgICAgICAgbGlnaHRfYWNjdW11bGF0b3Jfc3BlY3VsYXIgKz0gX2xpZ2h0LnNwZWN1bGFyICogcGYgKiBhdHRlbnVhdGlvbiAqIHNwb3RBdHRlbnVhdGlvbjtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3VucGFjayddID1cblwiXFxuXCIgK1xuXCIvLyBVbnBhY2sgbm9ybWFsaXplZCBzaG9ydHMgYmFjayB0byB0aGVpciBvcmlnaW5hbCBpbnRlZ2VyIHZhbHVlc1xcblwiICtcblwiI2RlZmluZSBTSE9SVCh4KSAoeCAqIDMyNzY3LilcXG5cIiArXG5cIiNkZWZpbmUgVU5TSUdORURfU0hPUlQoeCkgKHggKiA2NTUzNS4pXFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vIFVzZWQgZm9yIGNhc2VzIHdoZXJlIGFuIGF0dHJpYnV0ZSBpcyBzdG9yZWQgYXMgYSBub3JtYWxpemVkIGludCB0eXBlLFxcblwiICtcblwiLy8gYnV0IGlzIGEgZmxvYXRpbmcgcG9pbnQgdmFsdWUgdGhhdCBuZWVkcyBhIHJhbmdlIGdyZWF0ZXIgdGhhbiBbMCwgMV0gb3IgWy0xLCAxXS5cXG5cIiArXG5cIi8vIFRoZSBpbnRlZ2VyIHZhbHVlIGlzIFxcXCJzY2FsZWRcXFwiIHRvIGFuIDguOCBmaXhlZCBwb2ludCBzdHlsZSBpbnRlZ2VyIGJlZm9yZSBpdCBpc1xcblwiICtcblwiLy8gbm9ybWFsaXplZCBpbiB0aGUgVkJPLiBVc2VkIGZvciBjYXNlcyB3aGVyZSBsb3cgcHJlY2lzaW9uIGlzIHN1aXRhYmxlIGZvciBib3RoXFxuXCIgK1xuXCIvLyB0aGUgaW50ZWdlciBhbmQgZnJhY3Rpb25hbCBwb3J0aW9ucyBvZiB0aGUgbnVtYmVyLlxcblwiICtcblwiLy8gRXhhbXBsZXMgYXJlIGV4dHJ1c2lvbiB2ZWN0b3JzIGZvciBkeW5hbWljIGxpbmVzLCBhbmQgc2NyZWVuLXNwYWNlIHNpemUgZm9yIHBvaW50IHNwcml0ZXMuXFxuXCIgK1xuXCIjZGVmaW5lIFNDQUxFXzgoeCkgKHggKiAyNTYuKVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ3N0eWxlcy9wb2ludHMvcG9pbnRzX2ZyYWdtZW50J10gPVxuXCJ1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X3RpbWU7XFxuXCIgK1xuXCJ1bmlmb3JtIHZlYzMgdV9tYXBfcG9zaXRpb247XFxuXCIgK1xuXCJ1bmlmb3JtIHZlYzQgdV90aWxlX29yaWdpbjtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV9tZXRlcnNfcGVyX3BpeGVsO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X2RldmljZV9waXhlbF9yYXRpbztcXG5cIiArXG5cIlxcblwiICtcblwidW5pZm9ybSBtYXQzIHVfbm9ybWFsTWF0cml4O1xcblwiICtcblwidW5pZm9ybSBtYXQzIHVfaW52ZXJzZU5vcm1hbE1hdHJpeDtcXG5cIiArXG5cIlxcblwiICtcblwidW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblwiICtcblwiXFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cIiArXG5cInZhcnlpbmcgdmVjMiB2X3RleGNvb3JkO1xcblwiICtcblwidmFyeWluZyB2ZWM0IHZfd29ybGRfcG9zaXRpb247XFxuXCIgK1xuXCJcXG5cIiArXG5cIiNkZWZpbmUgVEFOR1JBTV9OT1JNQUwgdmVjMygwLiwgMC4sIDEuKVxcblwiICtcblwiXFxuXCIgK1xuXCIvLyBBbHBoYSBkaXNjYXJkIHRocmVzaG9sZCAoc3Vic3RpdHV0ZSBmb3IgYWxwaGEgYmxlbmRpbmcpXFxuXCIgK1xuXCIjaWZuZGVmIFRBTkdSQU1fQUxQSEFfRElTQ0FSRFxcblwiICtcblwiI2RlZmluZSBUQU5HUkFNX0FMUEhBX0RJU0NBUkQgMC41XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiLy8gQWxwaGEgZmFkZSByYW5nZSBmb3IgZWRnZXMgb2YgcG9pbnRzXFxuXCIgK1xuXCIjaWZuZGVmIFRBTkdSQU1fRkFERV9SQU5HRVxcblwiICtcblwiI2RlZmluZSBUQU5HUkFNX0ZBREVfUkFOR0UgLjE1XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIiNkZWZpbmUgVEFOR1JBTV9GQURFX1NUQVJUICgxLiAtIFRBTkdSQU1fRkFERV9SQU5HRSlcXG5cIiArXG5cIlxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBjYW1lcmFcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogbWF0ZXJpYWxcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogbGlnaHRpbmdcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogZ2xvYmFsXFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgbWFpbiAodm9pZCkge1xcblwiICtcblwiICAgIC8vIEluaXRpYWxpemUgZ2xvYmFsc1xcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogc2V0dXBcXG5cIiArXG5cIlxcblwiICtcblwiICAgIHZlYzQgY29sb3IgPSB2X2NvbG9yO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQXBwbHkgYSB0ZXh0dXJlXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRfVEVYVFVSRVxcblwiICtcblwiICAgICAgICBjb2xvciAqPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X3RleGNvb3JkKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAvLyBNYW51YWxseSB1bi1tdWx0aXBseSBhbHBoYSwgZm9yIGNhc2VzIHdoZXJlIHRleHR1cmUgaGFzIHByZS1tdWx0aXBsaWVkIGFscGhhXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX1VOTVVMVElQTFlfQUxQSEFcXG5cIiArXG5cIiAgICAgICAgICAgIGNvbG9yLnJnYiAvPSBtYXgoY29sb3IuYSwgMC4wMDEpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAvLyBEcmF3IGEgcG9pbnRcXG5cIiArXG5cIiAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAvLyBGYWRlIGFscGhhIG5lYXIgY2lyY2xlIGVkZ2VcXG5cIiArXG5cIiAgICAgICAgdmVjMiB1diA9IHZfdGV4Y29vcmQgKiAyLiAtIDEuO1xcblwiICtcblwiICAgICAgICBmbG9hdCBwb2ludF9kaXN0ID0gbGVuZ3RoKHV2KTtcXG5cIiArXG5cIiAgICAgICAgY29sb3IuYSA9IGNsYW1wKGNvbG9yLmEgLSAoc21vb3Roc3RlcCgwLiwgVEFOR1JBTV9GQURFX1JBTkdFLCAocG9pbnRfZGlzdCAtIFRBTkdSQU1fRkFERV9TVEFSVCkpIC8gVEFOR1JBTV9GQURFX1JBTkdFKSwgMC4sIGNvbG9yLmEpO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gSWYgYmxlbmRpbmcgaXMgb2ZmLCB1c2UgYWxwaGEgZGlzY2FyZCBhcyBhIGxvd2VyLXF1YWxpdHkgc3Vic3RpdHV0ZVxcblwiICtcblwiICAgICNpZiAhZGVmaW5lZChUQU5HUkFNX0JMRU5EX09WRVJMQVkpICYmICFkZWZpbmVkKFRBTkdSQU1fQkxFTkRfSU5MQVkpXFxuXCIgK1xuXCIgICAgICAgIGlmIChjb2xvci5hIDwgVEFOR1JBTV9BTFBIQV9ESVNDQVJEKSB7XFxuXCIgK1xuXCIgICAgICAgICAgICBkaXNjYXJkO1xcblwiICtcblwiICAgICAgICB9XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IGNvbG9yXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBGYWRlIG91dCB3aGVuIHRpbGUgaXMgem9vbWluZyBvdXQsIGUuZy4gYWN0aW5nIGFzIHByb3h5IHRpbGVzXFxuXCIgK1xuXCIgICAgLy8gTkI6IHRoaXMgaXMgbW9zdGx5IGRvbmUgdG8gY29tcGVuc2F0ZSBmb3IgdGV4dCBsYWJlbCBjb2xsaXNpb24gaGFwcGVuaW5nIGF0IHRoZSBsYWJlbFxcJ3MgMXggem9vbS4gQXMgbGFiZWxzXFxuXCIgK1xuXCIgICAgLy8gaW4gcHJveHkgdGlsZXMgYXJlIHNjYWxlZCBkb3duLCB0aGV5IGJlZ2luIHRvIG92ZXJsYXAsIGFuZCB0aGUgZmFkZSBpcyBhIHNpbXBsZSB3YXkgdG8gZWFzZSB0aGUgdHJhbnNpdGlvbi5cXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9GQURFX09OX1pPT01fT1VUXFxuXCIgK1xuXCIgICAgICAgIGNvbG9yLmEgKj0gY2xhbXAoMS4gLSBUQU5HUkFNX0ZBREVfT05fWk9PTV9PVVRfUkFURSAqICh1X3RpbGVfb3JpZ2luLnogLSB1X21hcF9wb3NpdGlvbi56KSwgMC4sIDEuKTtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogZmlsdGVyXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydzdHlsZXMvcG9pbnRzL3BvaW50c192ZXJ0ZXgnXSA9XG5cInVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfdGltZTtcXG5cIiArXG5cInVuaWZvcm0gdmVjMyB1X21hcF9wb3NpdGlvbjtcXG5cIiArXG5cInVuaWZvcm0gdmVjNCB1X3RpbGVfb3JpZ2luO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X3RpbGVfcHJveHlfZGVwdGg7XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfbWV0ZXJzX3Blcl9waXhlbDtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87XFxuXCIgK1xuXCJcXG5cIiArXG5cInVuaWZvcm0gbWF0NCB1X21vZGVsO1xcblwiICtcblwidW5pZm9ybSBtYXQ0IHVfbW9kZWxWaWV3O1xcblwiICtcblwidW5pZm9ybSBtYXQzIHVfbm9ybWFsTWF0cml4O1xcblwiICtcblwidW5pZm9ybSBtYXQzIHVfaW52ZXJzZU5vcm1hbE1hdHJpeDtcXG5cIiArXG5cIlxcblwiICtcblwiYXR0cmlidXRlIHZlYzQgYV9wb3NpdGlvbjtcXG5cIiArXG5cImF0dHJpYnV0ZSB2ZWM0IGFfc2hhcGU7XFxuXCIgK1xuXCJhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcblwiICtcblwiYXR0cmlidXRlIHZlYzIgYV90ZXhjb29yZDtcXG5cIiArXG5cImF0dHJpYnV0ZSB2ZWMyIGFfb2Zmc2V0O1xcblwiICtcblwiXFxuXCIgK1xuXCIjZGVmaW5lIFRBTkdSQU1fTk9STUFMIHZlYzMoMC4sIDAuLCAxLilcXG5cIiArXG5cIlxcblwiICtcblwidmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzIgdl90ZXhjb29yZDtcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X3dvcmxkX3Bvc2l0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGNhbWVyYVxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBtYXRlcmlhbFxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBsaWdodGluZ1xcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBnbG9iYWxcXG5cIiArXG5cIlxcblwiICtcblwidmVjMiByb3RhdGUyRCh2ZWMyIF9zdCwgZmxvYXQgX2FuZ2xlKSB7XFxuXCIgK1xuXCIgICAgcmV0dXJuIG1hdDIoY29zKF9hbmdsZSksLXNpbihfYW5nbGUpLFxcblwiICtcblwiICAgICAgICAgICAgICAgIHNpbihfYW5nbGUpLGNvcyhfYW5nbGUpKSAqIF9zdDtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBtYWluKCkge1xcblwiICtcblwiICAgIC8vIEluaXRpYWxpemUgZ2xvYmFsc1xcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogc2V0dXBcXG5cIiArXG5cIlxcblwiICtcblwiICAgIHZfY29sb3IgPSBhX2NvbG9yO1xcblwiICtcblwiICAgIHZfdGV4Y29vcmQgPSBhX3RleGNvb3JkO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gUG9zaXRpb25cXG5cIiArXG5cIiAgICB2ZWM0IHBvc2l0aW9uID0gdV9tb2RlbFZpZXcgKiB2ZWM0KFNIT1JUKGFfcG9zaXRpb24ueHl6KSwgMS4pO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQXBwbHkgcG9zaXRpb25pbmcgYW5kIHNjYWxpbmcgaW4gc2NyZWVuIHNwYWNlXFxuXCIgK1xuXCIgICAgZmxvYXQgenNjYWxlID0gZnJhY3QodV9tYXBfcG9zaXRpb24ueikgKiAoU0NBTEVfOChhX3NoYXBlLncpIC0gMS4pICsgMS47XFxuXCIgK1xuXCIgICAgLy8gZmxvYXQgenNjYWxlID0gbG9nKGZyYWN0KHVfbWFwX3Bvc2l0aW9uLnopICsgMS4pIC8gbG9nKDIuKSAqIChhX3NoYXBlLncgLSAxLikgKyAxLjtcXG5cIiArXG5cIiAgICB2ZWMyIHNoYXBlID0gU0NBTEVfOChhX3NoYXBlLnh5KSAqIHpzY2FsZTsgICAgIC8vXFxuXCIgK1xuXCIgICAgdmVjMiBvZmZzZXQgPSB2ZWMyKGFfb2Zmc2V0LngsIC1hX29mZnNldC55KTsgLy8gZmxpcCB5IHRvIG1ha2UgaXQgcG9pbnQgZG93blxcblwiICtcblwiICAgIGZsb2F0IHRoZXRhID0gcmFkaWFucyhhX3NoYXBlLnogKiAzNjAuKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIHNoYXBlID0gcm90YXRlMkQoc2hhcGUsIHRoZXRhKTsgICAgICAgICAgICAgLy8gYXBwbHkgcm90YXRpb24gdG8gdmVydGV4XFxuXCIgK1xuXCIgICAgc2hhcGUgKz0gcm90YXRlMkQoU0hPUlQob2Zmc2V0KSwgdGhldGEpOyAgLy8gYXBwbHkgb2Zmc2V0IG9uIHJvdGF0ZWQgYXhpcyAoZS5nLiBzbyBsaW5lIGxhYmVscyBmb2xsb3cgdGV4dCBheGlzKVxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gV29ybGQgY29vcmRpbmF0ZXMgZm9yIDNkIHByb2NlZHVyYWwgdGV4dHVyZXNcXG5cIiArXG5cIiAgICB2X3dvcmxkX3Bvc2l0aW9uID0gdV9tb2RlbCAqIHBvc2l0aW9uO1xcblwiICtcblwiICAgIHZfd29ybGRfcG9zaXRpb24ueHkgKz0gc2hhcGUgKiB1X21ldGVyc19wZXJfcGl4ZWw7XFxuXCIgK1xuXCIgICAgdl93b3JsZF9wb3NpdGlvbiA9IHdyYXBXb3JsZFBvc2l0aW9uKHZfd29ybGRfcG9zaXRpb24pO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gTW9kaWZ5IHBvc2l0aW9uIGJlZm9yZSBjYW1lcmEgcHJvamVjdGlvblxcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogcG9zaXRpb25cXG5cIiArXG5cIlxcblwiICtcblwiICAgIGNhbWVyYVByb2plY3Rpb24ocG9zaXRpb24pO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTEFZRVJfT1JERVJcXG5cIiArXG5cIiAgICAgICAgLy8gKzEgaXMgdG8ga2VlcCBhbGwgbGF5ZXJzIGluY2x1ZGluZyBwcm94aWVzID4gMFxcblwiICtcblwiICAgICAgICBhcHBseUxheWVyT3JkZXIoU0hPUlQoYV9wb3NpdGlvbi53KSArIHVfdGlsZV9wcm94eV9kZXB0aCArIDEuLCBwb3NpdGlvbik7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBBcHBseSBwaXhlbCBvZmZzZXQgaW4gc2NyZWVuLXNwYWNlXFxuXCIgK1xuXCIgICAgLy8gTXVsdGlwbHkgYnkgMiBpcyBiZWNhdXNlIHNjcmVlbiBpcyAyIHVuaXRzIHdpZGUgTm9ybWFsaXplZCBEZXZpY2UgQ29vcmRzIChhbmQgdV9yZXNvbHV0aW9uIGRldmljZSBwaXhlbHMgd2lkZSlcXG5cIiArXG5cIiAgICAvLyBEZXZpY2UgcGl4ZWwgcmF0aW8gYWRqdXN0bWVudCBpcyBiZWNhdXNlIHNoYXBlIGlzIGluIGxvZ2ljYWwgcGl4ZWxzXFxuXCIgK1xuXCIgICAgcG9zaXRpb24ueHkgKz0gc2hhcGUgKiBwb3NpdGlvbi53ICogMi4gKiB1X2RldmljZV9waXhlbF9yYXRpbyAvIHVfcmVzb2x1dGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGdsX1Bvc2l0aW9uID0gcG9zaXRpb247XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snc3R5bGVzL3BvbHlnb25zL3BvbHlnb25zX2ZyYWdtZW50J10gPVxuXCJ1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X3RpbWU7XFxuXCIgK1xuXCJ1bmlmb3JtIHZlYzMgdV9tYXBfcG9zaXRpb247XFxuXCIgK1xuXCJ1bmlmb3JtIHZlYzQgdV90aWxlX29yaWdpbjtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV9tZXRlcnNfcGVyX3BpeGVsO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X2RldmljZV9waXhlbF9yYXRpbztcXG5cIiArXG5cIlxcblwiICtcblwidW5pZm9ybSBtYXQzIHVfbm9ybWFsTWF0cml4O1xcblwiICtcblwidW5pZm9ybSBtYXQzIHVfaW52ZXJzZU5vcm1hbE1hdHJpeDtcXG5cIiArXG5cIlxcblwiICtcblwidmFyeWluZyB2ZWM0IHZfcG9zaXRpb247XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzMgdl9ub3JtYWw7XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X3dvcmxkX3Bvc2l0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIjZGVmaW5lIFRBTkdSQU1fTk9STUFMIHZfbm9ybWFsXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX1RFWFRVUkVfQ09PUkRTXFxuXCIgK1xuXCIgICAgdmFyeWluZyB2ZWMyIHZfdGV4Y29vcmQ7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmIGRlZmluZWQoVEFOR1JBTV9MSUdIVElOR19WRVJURVgpXFxuXCIgK1xuXCIgICAgdmFyeWluZyB2ZWM0IHZfbGlnaHRpbmc7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBjYW1lcmFcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogbWF0ZXJpYWxcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogbGlnaHRpbmdcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogZ2xvYmFsXFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgbWFpbiAodm9pZCkge1xcblwiICtcblwiICAgIC8vIEluaXRpYWxpemUgZ2xvYmFsc1xcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogc2V0dXBcXG5cIiArXG5cIlxcblwiICtcblwiICAgIHZlYzQgY29sb3IgPSB2X2NvbG9yO1xcblwiICtcblwiICAgIHZlYzMgbm9ybWFsID0gVEFOR1JBTV9OT1JNQUw7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBOb3JtYWwgbWF0ZXJpYWwgdGV4dHVyZSAoZnJhZ21lbnQgbGlnaHRpbmcgb25seSlcXG5cIiArXG5cIiAgICAjaWYgZGVmaW5lZChUQU5HUkFNX0xJR0hUSU5HX0ZSQUdNRU5UKSAmJiBkZWZpbmVkKFRBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkUpXFxuXCIgK1xuXCIgICAgICAgIGNhbGN1bGF0ZU5vcm1hbChub3JtYWwpO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gTm9ybWFsIG1vZGlmaWNhdGlvbiBhcHBsaWVkIGhlcmUgZm9yIGZyYWdtZW50IGxpZ2h0aW5nIG9yIG5vIGxpZ2h0aW5nLFxcblwiICtcblwiICAgIC8vIGFuZCBpbiB2ZXJ0ZXggc2hhZGVyIGZvciB2ZXJ0ZXggbGlnaHRpbmdcXG5cIiArXG5cIiAgICAjaWYgIWRlZmluZWQoVEFOR1JBTV9MSUdIVElOR19WRVJURVgpXFxuXCIgK1xuXCIgICAgICAgICNwcmFnbWEgdGFuZ3JhbTogbm9ybWFsXFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBDb2xvciBtb2RpZmljYXRpb24gYmVmb3JlIGxpZ2h0aW5nIGlzIGFwcGxpZWRcXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IGNvbG9yXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWYgZGVmaW5lZChUQU5HUkFNX0xJR0hUSU5HX0ZSQUdNRU5UKVxcblwiICtcblwiICAgICAgICAvLyBDYWxjdWxhdGUgcGVyLWZyYWdtZW50IGxpZ2h0aW5nXFxuXCIgK1xuXCIgICAgICAgIGNvbG9yID0gY2FsY3VsYXRlTGlnaHRpbmcodl9wb3NpdGlvbi54eXogLSB1X2V5ZSwgbm9ybWFsLCBjb2xvcik7XFxuXCIgK1xuXCIgICAgI2VsaWYgZGVmaW5lZChUQU5HUkFNX0xJR0hUSU5HX1ZFUlRFWClcXG5cIiArXG5cIiAgICAgICAgLy8gQXBwbHkgbGlnaHRpbmcgaW50ZW5zaXR5IGludGVycG9sYXRlZCBmcm9tIHZlcnRleCBzaGFkZXJcXG5cIiArXG5cIiAgICAgICAgY29sb3IgKj0gdl9saWdodGluZztcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFBvc3QtcHJvY2Vzc2luZyBlZmZlY3RzIChtb2RpZnkgY29sb3IgYWZ0ZXIgbGlnaHRpbmcpXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBmaWx0ZXJcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29uc192ZXJ0ZXgnXSA9XG5cInVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfdGltZTtcXG5cIiArXG5cInVuaWZvcm0gdmVjMyB1X21hcF9wb3NpdGlvbjtcXG5cIiArXG5cInVuaWZvcm0gdmVjNCB1X3RpbGVfb3JpZ2luO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X3RpbGVfcHJveHlfZGVwdGg7XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfbWV0ZXJzX3Blcl9waXhlbDtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87XFxuXCIgK1xuXCJcXG5cIiArXG5cInVuaWZvcm0gbWF0NCB1X21vZGVsO1xcblwiICtcblwidW5pZm9ybSBtYXQ0IHVfbW9kZWxWaWV3O1xcblwiICtcblwidW5pZm9ybSBtYXQzIHVfbm9ybWFsTWF0cml4O1xcblwiICtcblwidW5pZm9ybSBtYXQzIHVfaW52ZXJzZU5vcm1hbE1hdHJpeDtcXG5cIiArXG5cIlxcblwiICtcblwiYXR0cmlidXRlIHZlYzQgYV9wb3NpdGlvbjtcXG5cIiArXG5cImF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vIE9wdGlvbmFsIG5vcm1hbCBhdHRyaWJ1dGUsIG90aGVyd2lzZSBkZWZhdWx0IHRvIHVwXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9OT1JNQUxfQVRUUklCVVRFXFxuXCIgK1xuXCIgICAgYXR0cmlidXRlIHZlYzMgYV9ub3JtYWw7XFxuXCIgK1xuXCIgICAgI2RlZmluZSBUQU5HUkFNX05PUk1BTCBhX25vcm1hbFxcblwiICtcblwiI2Vsc2VcXG5cIiArXG5cIiAgICAjZGVmaW5lIFRBTkdSQU1fTk9STUFMIHZlYzMoMC4sIDAuLCAxLilcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIvLyBPcHRpb25hbCBkeW5hbWljIGxpbmUgZXh0cnVzaW9uXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9FWFRSVURFX0xJTkVTXFxuXCIgK1xuXCIgICAgLy8geHk6IGV4dHJ1c2lvbiBkaXJlY3Rpb24gaW4geHkgcGxhbmVcXG5cIiArXG5cIiAgICAvLyB6OiAgaGFsZi13aWR0aCBvZiBsaW5lIChhbW91bnQgdG8gZXh0cnVkZSlcXG5cIiArXG5cIiAgICAvLyB3OiAgc2NhbGluZyBmYWN0b3IgZm9yIGludGVycG9sYXRpbmcgd2lkdGggYmV0d2VlbiB6b29tc1xcblwiICtcblwiICAgIGF0dHJpYnV0ZSB2ZWM0IGFfZXh0cnVkZTtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzQgdl9wb3NpdGlvbjtcXG5cIiArXG5cInZhcnlpbmcgdmVjMyB2X25vcm1hbDtcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblwiICtcblwidmFyeWluZyB2ZWM0IHZfd29ybGRfcG9zaXRpb247XFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vIE9wdGlvbmFsIHRleHR1cmUgVVZzXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9URVhUVVJFX0NPT1JEU1xcblwiICtcblwiICAgIGF0dHJpYnV0ZSB2ZWMyIGFfdGV4Y29vcmQ7XFxuXCIgK1xuXCIgICAgdmFyeWluZyB2ZWMyIHZfdGV4Y29vcmQ7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmIGRlZmluZWQoVEFOR1JBTV9MSUdIVElOR19WRVJURVgpXFxuXCIgK1xuXCIgICAgdmFyeWluZyB2ZWM0IHZfbGlnaHRpbmc7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBjYW1lcmFcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogbWF0ZXJpYWxcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogbGlnaHRpbmdcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogZ2xvYmFsXFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgbWFpbigpIHtcXG5cIiArXG5cIiAgICAvLyBJbml0aWFsaXplIGdsb2JhbHNcXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IHNldHVwXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBUZXh0dXJlIFVWc1xcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX1RFWFRVUkVfQ09PUkRTXFxuXCIgK1xuXCIgICAgICAgIHZfdGV4Y29vcmQgPSBhX3RleGNvb3JkO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gUG9zaXRpb25cXG5cIiArXG5cIiAgICB2ZWM0IHBvc2l0aW9uID0gdmVjNChTSE9SVChhX3Bvc2l0aW9uLnh5eiksIDEuKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX0VYVFJVREVfTElORVNcXG5cIiArXG5cIiAgICAgICAgdmVjMiBleHRydWRlID0gU0NBTEVfOChhX2V4dHJ1ZGUueHkpO1xcblwiICtcblwiICAgICAgICBmbG9hdCB3aWR0aCA9IFNIT1JUKGFfZXh0cnVkZS56KTtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgZHdkeiA9IFNIT1JUKGFfZXh0cnVkZS53KTtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgZHogPSBjbGFtcCh1X21hcF9wb3NpdGlvbi56IC0gdV90aWxlX29yaWdpbi56LCAwLiwgMS4pO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIC8vIEludGVycG9sYXRlIGJldHdlZW4gem9vbSBsZXZlbHNcXG5cIiArXG5cIiAgICAgICAgd2lkdGggKz0gZHdkeiAqIGR6O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIC8vIFNjYWxlIHBpeGVsIGRpbWVuc2lvbnMgdG8gYmUgY29uc2lzdGVudCBpbiBzY3JlZW4gc3BhY2VcXG5cIiArXG5cIiAgICAgICAgd2lkdGggKj0gZXhwMigtZHopO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIC8vIE1vZGlmeSBsaW5lIHdpZHRoIGJlZm9yZSBleHRydXNpb25cXG5cIiArXG5cIiAgICAgICAgI3ByYWdtYSB0YW5ncmFtOiB3aWR0aFxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIHBvc2l0aW9uLnh5ICs9IGV4dHJ1ZGUgKiB3aWR0aDtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFdvcmxkIGNvb3JkaW5hdGVzIGZvciAzZCBwcm9jZWR1cmFsIHRleHR1cmVzXFxuXCIgK1xuXCIgICAgdl93b3JsZF9wb3NpdGlvbiA9IHdyYXBXb3JsZFBvc2l0aW9uKHVfbW9kZWwgKiBwb3NpdGlvbik7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBBZGp1c3QgZm9yIHRpbGUgYW5kIHZpZXcgcG9zaXRpb25cXG5cIiArXG5cIiAgICBwb3NpdGlvbiA9IHVfbW9kZWxWaWV3ICogcG9zaXRpb247XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBNb2RpZnkgcG9zaXRpb24gYmVmb3JlIGNhbWVyYSBwcm9qZWN0aW9uXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBwb3NpdGlvblxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gU2V0dXAgdmFyeWluZ3NcXG5cIiArXG5cIiAgICB2X3Bvc2l0aW9uID0gcG9zaXRpb247XFxuXCIgK1xuXCIgICAgdl9ub3JtYWwgPSBub3JtYWxpemUodV9ub3JtYWxNYXRyaXggKiBUQU5HUkFNX05PUk1BTCk7XFxuXCIgK1xuXCIgICAgdl9jb2xvciA9IGFfY29sb3I7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWYgZGVmaW5lZChUQU5HUkFNX0xJR0hUSU5HX1ZFUlRFWClcXG5cIiArXG5cIiAgICAgICAgLy8gVmVydGV4IGxpZ2h0aW5nXFxuXCIgK1xuXCIgICAgICAgIHZlYzMgbm9ybWFsID0gdl9ub3JtYWw7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgLy8gTW9kaWZ5IG5vcm1hbCBiZWZvcmUgbGlnaHRpbmdcXG5cIiArXG5cIiAgICAgICAgI3ByYWdtYSB0YW5ncmFtOiBub3JtYWxcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAvLyBQYXNzIGxpZ2h0aW5nIGludGVuc2l0eSB0byBmcmFnbWVudCBzaGFkZXJcXG5cIiArXG5cIiAgICAgICAgdl9saWdodGluZyA9IGNhbGN1bGF0ZUxpZ2h0aW5nKHBvc2l0aW9uLnh5eiAtIHVfZXllLCBub3JtYWwsIHZlYzQoMS4pKTtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIENhbWVyYVxcblwiICtcblwiICAgIGNhbWVyYVByb2plY3Rpb24ocG9zaXRpb24pO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gKzEgaXMgdG8ga2VlcCBhbGwgbGF5ZXJzIGluY2x1ZGluZyBwcm94aWVzID4gMFxcblwiICtcblwiICAgIGFwcGx5TGF5ZXJPcmRlcihTSE9SVChhX3Bvc2l0aW9uLncpICsgdV90aWxlX3Byb3h5X2RlcHRoICsgMS4sIHBvc2l0aW9uKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGdsX1Bvc2l0aW9uID0gcG9zaXRpb247XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuZXhwb3J0IGRlZmF1bHQgc2hhZGVyU291cmNlcztcbiIsIi8vIFRleHR1cmUgbWFuYWdlbWVudFxuaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBzdWJzY3JpYmVNaXhpbiBmcm9tICcuLi91dGlscy9zdWJzY3JpYmUnO1xuaW1wb3J0IFdvcmtlckJyb2tlciBmcm9tICcuLi91dGlscy93b3JrZXJfYnJva2VyJztcbmltcG9ydCBCdWlsZGVycyBmcm9tICcuLi9zdHlsZXMvYnVpbGRlcnMnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbi8vIEdMIHRleHR1cmUgd3JhcHBlciBvYmplY3QgZm9yIGtlZXBpbmcgdHJhY2sgb2YgYSBnbG9iYWwgc2V0IG9mIHRleHR1cmVzLCBrZXllZCBieSBhIHVuaXF1ZSB1c2VyLWRlZmluZWQgbmFtZVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihnbCwgbmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJpbmQoKTtcblxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlX3R5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbmZpZ190eXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gbnVsbDsgICAgLy8gYSBQcm9taXNlIG9iamVjdCB0byB0cmFjayB0aGUgbG9hZGluZyBzdGF0ZSBvZiB0aGlzIHRleHR1cmVcbiAgICAgICAgdGhpcy5maWx0ZXJpbmcgPSBvcHRpb25zLmZpbHRlcmluZztcbiAgICAgICAgdGhpcy5zcHJpdGVzID0gb3B0aW9ucy5zcHJpdGVzO1xuICAgICAgICB0aGlzLnRleGNvb3JkcyA9IHt9OyAgICAvLyBzcHJpdGUgVVZzIChbMCwgMV0gcmFuZ2UpXG4gICAgICAgIHRoaXMuc2l6ZXMgPSB7fTsgICAgICAgIC8vIHNwcml0ZSBzaXplcyAocGl4ZWwgc2l6ZSlcblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGEgMS1waXhlbCBibGFjayB0ZXh0dXJlIHNvIHdlIGNhbiBzYWZlbHkgcmVuZGVyIHdoaWxlIHdlIHdhaXQgZm9yIGFuIGltYWdlIHRvIGxvYWRcbiAgICAgICAgLy8gU2VlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE5NzIyMjQ3L3dlYmdsLXdhaXQtZm9yLXRleHR1cmUtdG8tbG9hZFxuICAgICAgICB0aGlzLnNldERhdGEoMSwgMSwgbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDI1NV0pLCB7IGZpbHRlcmluZzogJ25lYXJlc3QnIH0pO1xuXG4gICAgICAgIC8vIERlc3Ryb3kgcHJldmlvdXMgdGV4dHVyZSBpZiBwcmVzZW50XG4gICAgICAgIGlmIChUZXh0dXJlLnRleHR1cmVzW3RoaXMubmFtZV0pIHtcbiAgICAgICAgICAgIFRleHR1cmUudGV4dHVyZXNbdGhpcy5uYW1lXS5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWNoZSB0ZXh0dXJlIGluc3RhbmNlIGFuZCBkZWZpbml0aW9uXG4gICAgICAgIFRleHR1cmUudGV4dHVyZXNbdGhpcy5uYW1lXSA9IHRoaXM7XG4gICAgICAgIFRleHR1cmUudGV4dHVyZV9jb25maWdzW3RoaXMubmFtZV0gPSBPYmplY3QuYXNzaWduKHsgbmFtZSB9LCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLmxvYWQob3B0aW9ucyk7XG4gICAgICAgIGxvZy50cmFjZShgY3JlYXRpbmcgVGV4dHVyZSAke3RoaXMubmFtZX1gKTtcbiAgICB9XG5cbiAgICAvLyBEZXN0cm95IGEgc2luZ2xlIHRleHR1cmUgaW5zdGFuY2VcbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAoIXRoaXMudmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGF0YTtcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIFRleHR1cmUudGV4dHVyZXNbdGhpcy5uYW1lXTtcbiAgICAgICAgdGhpcy52YWxpZCA9IGZhbHNlO1xuICAgICAgICBsb2cudHJhY2UoYGRlc3Ryb3lpbmcgVGV4dHVyZSAke3RoaXMubmFtZX1gKTtcbiAgICB9XG5cbiAgICBiaW5kKHVuaXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB1bml0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKFRleHR1cmUuYWN0aXZlVW5pdCAhPT0gdW5pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwICsgdW5pdCk7XG4gICAgICAgICAgICAgICAgVGV4dHVyZS5hY3RpdmVVbml0ID0gdW5pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoVGV4dHVyZS5hY3RpdmVUZXh0dXJlICE9PSB0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgICAgICAgICAgVGV4dHVyZS5hY3RpdmVUZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9hZChvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZyB8fCBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudXJsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5jb25maWdfdHlwZSA9ICd1cmwnO1xuICAgICAgICAgICAgdGhpcy5zZXRVcmwob3B0aW9ucy51cmwsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5jb25maWdfdHlwZSA9ICdlbGVtZW50JztcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudChvcHRpb25zLmVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLndpZHRoICYmIG9wdGlvbnMuaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ190eXBlID0gJ2RhdGEnO1xuICAgICAgICAgICAgdGhpcy5zZXREYXRhKG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0LCBvcHRpb25zLmRhdGEsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2FkaW5nID1cbiAgICAgICAgICAgICh0aGlzLmxvYWRpbmcgJiYgdGhpcy5sb2FkaW5nLnRoZW4oKCkgPT4geyB0aGlzLmNhbGN1bGF0ZVNwcml0ZXMoKTsgcmV0dXJuIHRoaXM7IH0pKSB8fFxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkaW5nO1xuICAgIH1cblxuICAgIC8vIFNldHMgdGV4dHVyZSBmcm9tIGFuIHVybFxuICAgIHNldFVybCh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoIXRoaXMudmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChUZXh0dXJlLmJhc2VfdXJsKSB7XG4gICAgICAgICAgICB1cmwgPSBVdGlscy5hZGRCYXNlVVJMKHVybCwgVGV4dHVyZS5iYXNlX3VybCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVybCA9IFV0aWxzLmNhY2hlQnVzdGVyRm9yVXJsKHVybCk7IC8vIHNhdmUgVVJMIHJlZmVyZW5jZSAod2lsbCBiZSBvdmVyd3JpdHRlbiB3aGVuIGVsZW1lbnQgaXMgbG9hZGVkIGJlbG93KVxuICAgICAgICB0aGlzLnNvdXJjZSA9IHRoaXMudXJsO1xuICAgICAgICB0aGlzLnNvdXJjZV90eXBlID0gJ3VybCc7XG5cbiAgICAgICAgdGhpcy5sb2FkaW5nID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50KGltYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oYFRleHR1cmUgJyR7dGhpcy5uYW1lfSc6IGZhaWxlZCB0byBsb2FkIHVybDogJyR7dGhpcy5zb3VyY2V9J2AsIGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBUZXh0dXJlLnRyaWdnZXIoJ3dhcm5pbmcnLCB7IG1lc3NhZ2U6IGBGYWlsZWQgdG8gbG9hZCB0ZXh0dXJlIGZyb20gJHt0aGlzLnNvdXJjZX1gLCBlcnJvcjogZSwgdGV4dHVyZTogb3B0aW9ucyB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltYWdlLm9uZXJyb3IgPSBlID0+IHtcbiAgICAgICAgICAgICAgICAvLyBXYXJuIGFuZCByZXNvbHZlIG9uIGVycm9yXG4gICAgICAgICAgICAgICAgbG9nLndhcm4oYFRleHR1cmUgJyR7dGhpcy5uYW1lfSc6IGZhaWxlZCB0byBsb2FkIHVybDogJyR7dGhpcy5zb3VyY2V9J2AsIGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIFRleHR1cmUudHJpZ2dlcignd2FybmluZycsIHsgbWVzc2FnZTogYEZhaWxlZCB0byBsb2FkIHRleHR1cmUgZnJvbSAke3RoaXMuc291cmNlfWAsIGVycm9yOiBlLCB0ZXh0dXJlOiBvcHRpb25zIH0pO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICAgICAgICAgIGltYWdlLnNyYyA9IHRoaXMuc291cmNlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZztcbiAgICB9XG5cbiAgICAvLyBTZXRzIHRleHR1cmUgdG8gYSByYXcgaW1hZ2UgYnVmZmVyXG4gICAgc2V0RGF0YSh3aWR0aCwgaGVpZ2h0LCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICB0aGlzLnNvdXJjZSA9IGRhdGE7XG4gICAgICAgIHRoaXMuc291cmNlX3R5cGUgPSAnZGF0YSc7XG5cbiAgICAgICAgdGhpcy51cGRhdGUob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2V0RmlsdGVyaW5nKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMubG9hZGluZyA9IFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZztcbiAgICB9XG5cbiAgICAvLyBTZXRzIHRoZSB0ZXh0dXJlIHRvIHRyYWNrIGEgZWxlbWVudCAoY2FudmFzL2ltYWdlKVxuICAgIHNldEVsZW1lbnQoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICBsZXQgZWwgPSBlbGVtZW50O1xuXG4gICAgICAgIC8vIGEgc3RyaW5nIGVsZW1lbnQgaXMgaW50ZXJwZXRlZCBhcyBhIENTUyBzZWxlY3RvclxuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgfHxcbiAgICAgICAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50IHx8XG4gICAgICAgICAgICBlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBlbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VfdHlwZSA9ICdlbGVtZW50JztcblxuICAgICAgICAgICAgdGhpcy51cGRhdGUob3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNldEZpbHRlcmluZyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtc2cgPSBgdGhlICdlbGVtZW50JyBwYXJhbWV0ZXIgKFxcYGVsZW1lbnQ6ICR7SlNPTi5zdHJpbmdpZnkoZWwpfVxcYCkgbXVzdCBiZSBhIENTUyBgO1xuICAgICAgICAgICAgbXNnICs9IGBzZWxlY3RvciBzdHJpbmcsIG9yIGEgPGNhbnZhcz4sIDxpbWFnZT4gb3IgPHZpZGVvPiBvYmplY3RgO1xuICAgICAgICAgICAgbG9nLndhcm4oYFRleHR1cmUgJyR7dGhpcy5uYW1lfSc6ICR7bXNnfWAsIG9wdGlvbnMpO1xuICAgICAgICAgICAgVGV4dHVyZS50cmlnZ2VyKCd3YXJuaW5nJywgeyBtZXNzYWdlOiBgRmFpbGVkIHRvIGxvYWQgdGV4dHVyZSBiZWNhdXNlICR7bXNnfWAsIHRleHR1cmU6IG9wdGlvbnMgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRpbmc7XG4gICAgfVxuXG4gICAgLy8gVXBsb2FkcyBjdXJyZW50IGltYWdlIG9yIGJ1ZmZlciB0byB0aGUgR1BVIChjYW4gYmUgdXNlZCB0byB1cGRhdGUgYW5pbWF0ZWQgdGV4dHVyZXMgb24gdGhlIGZseSlcbiAgICB1cGRhdGUob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5iaW5kKCk7XG4gICAgICAgIHRoaXMuZ2wucGl4ZWxTdG9yZWkodGhpcy5nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCAob3B0aW9ucy5VTlBBQ0tfRkxJUF9ZX1dFQkdMID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZSkpO1xuICAgICAgICB0aGlzLmdsLnBpeGVsU3RvcmVpKHRoaXMuZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBvcHRpb25zLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCB8fCBmYWxzZSk7XG5cbiAgICAgICAgLy8gSW1hZ2Ugb3IgQ2FudmFzIGVsZW1lbnRcbiAgICAgICAgaWYgKHRoaXMuc291cmNlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgfHwgdGhpcy5zb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50IHx8XG4gICAgICAgICAgICAodGhpcy5zb3VyY2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ICYmIHRoaXMuc291cmNlLmNvbXBsZXRlKSkge1xuXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5zb3VyY2Uud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuc291cmNlLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSYXcgaW1hZ2UgYnVmZmVyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc291cmNlX3R5cGUgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFRleHR1cmUudHJpZ2dlcigndXBkYXRlJywgdGhpcyk7XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lcyBhcHByb3ByaWF0ZSBmaWx0ZXJpbmcgbW9kZVxuICAgIHNldEZpbHRlcmluZyhvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLmZpbHRlcmluZyA9IG9wdGlvbnMuZmlsdGVyaW5nIHx8ICdsaW5lYXInO1xuXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHRoaXMuYmluZCgpO1xuXG4gICAgICAgIC8vIEZvciBwb3dlci1vZi0yIHRleHR1cmVzLCB0aGUgZm9sbG93aW5nIHByZXNldHMgYXJlIGF2YWlsYWJsZTpcbiAgICAgICAgLy8gbWlwbWFwOiBsaW5lYXIgYmxlbmQgZnJvbSBuZWFyZXN0IG1pcFxuICAgICAgICAvLyBsaW5lYXI6IGxpbmVhciBibGVuZCBmcm9tIG9yaWdpbmFsIGltYWdlIChubyBtaXBzKVxuICAgICAgICAvLyBuZWFyZXN0OiBuZWFyZXN0IHBpeGVsIGZyb20gb3JpZ2luYWwgaW1hZ2UgKG5vIG1pcHMsICdibG9ja3knIGxvb2spXG4gICAgICAgIGlmIChVdGlscy5pc1Bvd2VyT2YyKHRoaXMud2lkdGgpICYmIFV0aWxzLmlzUG93ZXJPZjIodGhpcy5oZWlnaHQpKSB7XG4gICAgICAgICAgICB0aGlzLnBvd2VyX29mXzIgPSB0cnVlO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgb3B0aW9ucy5URVhUVVJFX1dSQVBfUyB8fCAob3B0aW9ucy5yZXBlYXQgJiYgZ2wuUkVQRUFUKSB8fCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIG9wdGlvbnMuVEVYVFVSRV9XUkFQX1QgfHwgKG9wdGlvbnMucmVwZWF0ICYmIGdsLlJFUEVBVCkgfHwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbHRlcmluZyA9PT0gJ21pcG1hcCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmluZyA9ICdtaXBtYXAnO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUik7IC8vIFRPRE86IHVzZSB0cmlsaW5lYXIgZmlsdGVyaW5nIGJ5IGRlZnVhbHQgaW5zdGVhZD9cbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZmlsdGVyaW5nID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyaW5nID0gJ2xpbmVhcic7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmZpbHRlcmluZyA9PT0gJ25lYXJlc3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJpbmcgPSAnbmVhcmVzdCc7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlYkdMIGhhcyBzdHJpY3QgcmVxdWlyZW1lbnRzIG9uIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzOlxuICAgICAgICAgICAgLy8gTm8gbWlwbWFwcyBhbmQgbXVzdCBjbGFtcCB0byBlZGdlXG4gICAgICAgICAgICB0aGlzLnBvd2VyX29mXzIgPSBmYWxzZTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbHRlcmluZyA9PT0gJ25lYXJlc3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJpbmcgPSAnbmVhcmVzdCc7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBkZWZhdWx0IHRvIGxpbmVhciBmb3Igbm9uLXBvd2VyLW9mLTIgdGV4dHVyZXNcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmluZyA9ICdsaW5lYXInO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgVGV4dHVyZS50cmlnZ2VyKCd1cGRhdGUnLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBQcmUtY2FsYyBzcHJpdGUgcmVnaW9ucyBmb3IgYSB0ZXh0dXJlIHNwcml0ZSBpbiBVViBbMCwgMV0gc3BhY2VcbiAgICBjYWxjdWxhdGVTcHJpdGVzKCkge1xuICAgICAgICBpZiAodGhpcy5zcHJpdGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzIGluIHRoaXMuc3ByaXRlcykge1xuICAgICAgICAgICAgICAgIGxldCBzcHJpdGUgPSB0aGlzLnNwcml0ZXNbc107XG5cbiAgICAgICAgICAgICAgICAvLyBNYXAgWzAsIDBdIHRvIFsxLCAxXSBjb29yZHMgdG8gdGhlIGFwcHJvcHJpYXRlIHNwcml0ZSBzdWItYXJlYSBvZiB0aGUgdGV4dHVyZVxuICAgICAgICAgICAgICAgIHRoaXMudGV4Y29vcmRzW3NdID0gQnVpbGRlcnMuZ2V0VGV4Y29vcmRzRm9yU3ByaXRlKFxuICAgICAgICAgICAgICAgICAgICBbc3ByaXRlWzBdLCBzcHJpdGVbMV1dLFxuICAgICAgICAgICAgICAgICAgICBbc3ByaXRlWzJdLCBzcHJpdGVbM11dLFxuICAgICAgICAgICAgICAgICAgICBbdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIFBpeGVsIHNpemUgb2Ygc3ByaXRlXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplc1tzXSA9IFtzcHJpdGVbMl0sIHNwcml0ZVszXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuXG4vLyBTdGF0aWMvY2xhc3MgbWV0aG9kcyBhbmQgc3RhdGVcblxuVGV4dHVyZS5jcmVhdGUgPSBmdW5jdGlvbiBjb25zdHJ1Y3RvcihnbCwgbmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVGV4dHVyZShnbCwgbmFtZSwgb3B0aW9ucyk7XG59O1xuXG4vLyBEZXN0cm95IGFsbCB0ZXh0dXJlIGluc3RhbmNlcyBmb3IgYSBnaXZlbiBHTCBjb250ZXh0XG5UZXh0dXJlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZ2wpIHtcbiAgICB2YXIgdGV4dHVyZXMgPSBPYmplY3Qua2V5cyhUZXh0dXJlLnRleHR1cmVzKTtcbiAgICBmb3IgKHZhciB0IG9mIHRleHR1cmVzKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gVGV4dHVyZS50ZXh0dXJlc1t0XTtcbiAgICAgICAgaWYgKHRleHR1cmUuZ2wgPT09IGdsKSB7XG4gICAgICAgICAgICB0ZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIEdldCBzcHJpdGUgcGl4ZWwgc2l6ZSBhbmQgVVZzXG5UZXh0dXJlLmdldFNwcml0ZUluZm8gPSBmdW5jdGlvbiAodGV4bmFtZSwgc3ByaXRlKSB7XG4gICAgbGV0IHRleHR1cmUgPSBUZXh0dXJlLnRleHR1cmVzW3RleG5hbWVdO1xuICAgIHJldHVybiB0ZXh0dXJlICYmIHsgc2l6ZTogdGV4dHVyZS5zaXplc1tzcHJpdGVdLCB0ZXhjb29yZHM6IHRleHR1cmUudGV4Y29vcmRzW3Nwcml0ZV0gfTtcbn07XG5cbi8vIENyZWF0ZSBhIHNldCBvZiB0ZXh0dXJlcyBrZXllZCBpbiBhbiBvYmplY3Rcbi8vIE9wdGlvbmFsbHkgbG9hZCBlYWNoIGlmIGl0IGhhcyBhIFVSTCBzcGVjaWZpZWRcblRleHR1cmUuY3JlYXRlRnJvbU9iamVjdCA9IGZ1bmN0aW9uIChnbCwgdGV4dHVyZXMpIHtcbiAgICBsZXQgbG9hZGluZyA9IFtdO1xuICAgIGlmICh0ZXh0dXJlcykge1xuICAgICAgICBmb3IgKGxldCB0ZXhuYW1lIGluIHRleHR1cmVzKSB7XG4gICAgICAgICAgICBsZXQgY29uZmlnID0gdGV4dHVyZXNbdGV4bmFtZV07XG5cbiAgICAgICAgICAgIC8vIElmIHRleHR1cmUgYWxyZWFkeSBleGlzdHMgYW5kIGRlZmluaXRpb24gaGFzbid0IGNoYW5nZWQsIG5vIG5lZWQgdG8gcmUtY3JlYXRlXG4gICAgICAgICAgICAvLyBOb3RlOiB0byBhdm9pZCBmbGlja2VyIHdoZW4gb3RoZXIgdGV4dHVyZXMvc2NlbmUgaXRlbXMgY2hhbmdlXG4gICAgICAgICAgICBpZiAoIVRleHR1cmUuY2hhbmdlZCh0ZXhuYW1lLCBjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB0ZXh0dXJlID0gVGV4dHVyZS5jcmVhdGUoZ2wsIHRleG5hbWUsIGNvbmZpZyk7XG4gICAgICAgICAgICBsb2FkaW5nLnB1c2godGV4dHVyZS5sb2FkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwobG9hZGluZyk7XG59O1xuXG4vLyBJbmRpY2F0ZSBpZiBhIHRleHR1cmUgZGVmaW5pdGlvbiB3b3VsZCBiZSBhIGNoYW5nZSBmcm9tIHRoZSBjdXJyZW50IGNhY2hlXG5UZXh0dXJlLmNoYW5nZWQgPSBmdW5jdGlvbiAobmFtZSwgY29uZmlnKSB7XG4gICAgbGV0IHRleHR1cmUgPSBUZXh0dXJlLnRleHR1cmVzW25hbWVdO1xuICAgIGlmICh0ZXh0dXJlKSB7IC8vIGNhY2hlZCB0ZXh0dXJlXG4gICAgICAgIC8vIGNhbnZhcy9pbWFnZS1iYXNlZCB0ZXh0dXJlcyBhcmUgY29uc2lkZXJlZCBkeW5hbWljIGFuZCBhbHdheXMgcmVmcmVzaFxuICAgICAgICBpZiAodGV4dHVyZS5jb25maWdfdHlwZSA9PT0gJ2VsZW1lbnQnIHx8IGNvbmZpZy5lbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29tcGFyZSBkZWZpbml0aW9uc1xuICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoVGV4dHVyZS50ZXh0dXJlX2NvbmZpZ3NbbmFtZV0pID09PVxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbih7IG5hbWUgfSwgY29uZmlnKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEdldCBtZXRhZGF0YSBmb3IgYSB0ZXh0dXJlIGJ5IG5hbWVcbi8vIFJldHVybnMgdmlhIHByb21pc2UsIGluIGNhc2UgdGV4dHVyZSBpcyBzdGlsbCBsb2FkaW5nXG4vLyBDYW4gYmUgY2FsbGVkIG9uIG1haW4gdGhyZWFkIGZyb20gd29ya2VyLCB0byBzeW5jIHRleHR1cmUgaW5mbyB0byB3b3JrZXJcblRleHR1cmUuZ2V0SW5mbyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgLy8gR2V0IGluZm8gZm9yIGFsbCB0ZXh0dXJlcyBieSBkZWZhdWx0XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBPYmplY3Qua2V5cyhUZXh0dXJlLnRleHR1cmVzKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgbXVsdGlwbGUgdGV4dHVyZXNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobmFtZS5tYXAobiA9PiBUZXh0dXJlLmdldEluZm8obikpKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgc2luZ2xlIHRleHR1cmVcbiAgICB2YXIgdGV4ID0gVGV4dHVyZS50ZXh0dXJlc1tuYW1lXTtcbiAgICBpZiAodGV4KSB7XG4gICAgICAgIC8vIFdhaXQgZm9yIHRoaXMgdGV4dHVyZSB0byBmaW5pc2ggbG9hZGluZywgb3IgcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgICAgIHZhciBsb2FkaW5nID0gdGV4LmxvYWRpbmcgfHwgUHJvbWlzZS5yZXNvbHZlKHRleCk7XG4gICAgICAgIHJldHVybiBsb2FkaW5nLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGEgc3Vic2V0IG9mIHRleHR1cmUgaW5mb1xuICAgICAgICAgICAgLy8gKGNvbXBhdGlibGUgdy9zdHJ1Y3R1cmVkIGNsb25pbmcsIHN1aXRhYmxlIGZvciBwYXNzaW5nIHRvIGEgd29ya2VyKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0ZXgubmFtZSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGV4LndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGV4LmhlaWdodCxcbiAgICAgICAgICAgICAgICBzcHJpdGVzOiB0ZXguc3ByaXRlcyxcbiAgICAgICAgICAgICAgICB0ZXhjb29yZHM6IHRleC50ZXhjb29yZHMsXG4gICAgICAgICAgICAgICAgc2l6ZXM6IHRleC5zaXplcyxcbiAgICAgICAgICAgICAgICBmaWx0ZXJpbmc6IHRleC5maWx0ZXJpbmcsXG4gICAgICAgICAgICAgICAgcG93ZXJfb2ZfMjogdGV4LnBvd2VyX29mXzIsXG4gICAgICAgICAgICAgICAgdmFsaWQ6IHRleC52YWxpZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBObyB0ZXh0dXJlIGZvdW5kXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgfVxufTtcblxuLy8gU3luYyB0ZXh0dXJlIGluZm8gdG8gd29ya2VyXG4vLyBDYWxsZWQgZnJvbSB3b3JrZXIsIGdldHMgaW5mbyBvbiBvbmUgb3IgbW9yZSB0ZXh0dXJlcyBpbmZvIGZyb20gbWFpbiB0aHJlYWQgdmlhIHJlbW90ZSBjYWxsLCB0aGVuIHN0b3JlcyBpdFxuLy8gbG9jYWxseSBpbiB3b3JrZXIuICd0ZXh0dXJlcycgY2FuIGJlIGFuIGFycmF5IG9mIHRleHR1cmUgbmFtZXMgdG8gc3luYywgb3IgaWYgbnVsbCwgYWxsIHRleHR1cmVzIGFyZSBzeW5jZWQuXG5UZXh0dXJlLnN5bmNUZXh0dXJlc1RvV29ya2VyID0gZnVuY3Rpb24gKG5hbWVzKSB7XG4gICAgcmV0dXJuIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSgnVGV4dHVyZS5nZXRJbmZvJywgbmFtZXMpLlxuICAgICAgICB0aGVuKHRleHR1cmVzID0+IHtcbiAgICAgICAgICAgIGZvciAodmFyIHRleCBvZiB0ZXh0dXJlcykge1xuICAgICAgICAgICAgICAgIFRleHR1cmUudGV4dHVyZXNbdGV4Lm5hbWVdID0gdGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUudGV4dHVyZXM7XG4gICAgICAgIH0pO1xufTtcblxuLy8gUmVwb3J0IG1heCB0ZXh0dXJlIHNpemUgZm9yIGEgR0wgY29udGV4dFxuVGV4dHVyZS5nZXRNYXhUZXh0dXJlU2l6ZSA9IGZ1bmN0aW9uIChnbCkge1xuICAgIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSk7XG59O1xuXG4vLyBHbG9iYWwgc2V0IG9mIHRleHR1cmVzLCBieSBuYW1lXG5UZXh0dXJlLnRleHR1cmVzID0ge307XG5UZXh0dXJlLnRleHR1cmVfY29uZmlncyA9IHt9O1xuVGV4dHVyZS5ib3VuZFRleHR1cmUgPSAtMTtcblRleHR1cmUuYWN0aXZlVW5pdCA9IC0xO1xuXG5UZXh0dXJlLmJhc2VfdXJsID0gbnVsbDsgLy8gb3B0aW9uYWwgYmFzZSBVUkwgdG8gYWRkIHRvIHRleHR1cmVzXG5cbldvcmtlckJyb2tlci5hZGRUYXJnZXQoJ1RleHR1cmUnLCBUZXh0dXJlKTtcbnN1YnNjcmliZU1peGluKFRleHR1cmUpO1xuIiwiLy8gQ3JlYXRlcyBhIFZlcnRleCBBcnJheSBPYmplY3QgaWYgdGhlIGV4dGVuc2lvbiBpcyBhdmFpbGFibGUsIG9yIGZhbGxzIGJhY2sgb24gc3RhbmRhcmQgYXR0cmlidXRlIGNhbGxzXG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG52YXIgVmVydGV4QXJyYXlPYmplY3Q7XG5leHBvcnQgZGVmYXVsdCBWZXJ0ZXhBcnJheU9iamVjdCA9IHt9O1xuXG5WZXJ0ZXhBcnJheU9iamVjdC5kaXNhYmxlZCA9IGZhbHNlOyAvLyBzZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIFZBT3MgZXZlbiBpZiBleHRlbnNpb24gaXMgYXZhaWxhYmxlXG5WZXJ0ZXhBcnJheU9iamVjdC5ib3VuZF92YW8gPSBudWxsOyAvLyBjdXJyZW50bHkgYm91bmQgVkFPXG5cblZlcnRleEFycmF5T2JqZWN0LmluaXQgPSBmdW5jdGlvbiAoZ2wpIHtcbiAgICBpZiAoVmVydGV4QXJyYXlPYmplY3QuZXh0ID09IG51bGwpIHtcbiAgICAgICAgaWYgKFZlcnRleEFycmF5T2JqZWN0LmRpc2FibGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBWZXJ0ZXhBcnJheU9iamVjdC5leHQgPSBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdmVydGV4X2FycmF5X29iamVjdFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChWZXJ0ZXhBcnJheU9iamVjdC5leHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nLmluZm8oJ1ZlcnRleCBBcnJheSBPYmplY3QgZXh0ZW5zaW9uIGF2YWlsYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFZlcnRleEFycmF5T2JqZWN0LmRpc2FibGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBsb2cud2FybignVmVydGV4IEFycmF5IE9iamVjdCBleHRlbnNpb24gTk9UIGF2YWlsYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nLndhcm4oJ1ZlcnRleCBBcnJheSBPYmplY3QgZXh0ZW5zaW9uIGZvcmNlIGRpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5WZXJ0ZXhBcnJheU9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoc2V0dXAsIHRlYXJkb3duKSB7XG4gICAgbGV0IHZhbyA9IHt9O1xuICAgIHZhby5zZXR1cCA9IHNldHVwO1xuICAgIHZhby50ZWFyZG93biA9IHRlYXJkb3duO1xuXG4gICAgbGV0IGV4dCA9IFZlcnRleEFycmF5T2JqZWN0LmV4dDtcbiAgICBpZiAoZXh0ICE9IG51bGwpIHtcbiAgICAgICAgdmFvLl92YW8gPSBleHQuY3JlYXRlVmVydGV4QXJyYXlPRVMoKTtcbiAgICAgICAgZXh0LmJpbmRWZXJ0ZXhBcnJheU9FUyh2YW8uX3Zhbyk7XG4gICAgfVxuXG4gICAgdmFvLnNldHVwKHRydWUpO1xuXG4gICAgcmV0dXJuIHZhbztcbn07XG5cblZlcnRleEFycmF5T2JqZWN0LmJpbmQgPSBmdW5jdGlvbiAodmFvKSB7XG4gICAgbGV0IGV4dCA9IFZlcnRleEFycmF5T2JqZWN0LmV4dDtcbiAgICBpZiAodmFvICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGV4dCAhPSBudWxsICYmIHZhby5fdmFvICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dC5iaW5kVmVydGV4QXJyYXlPRVModmFvLl92YW8pO1xuICAgICAgICAgICAgVmVydGV4QXJyYXlPYmplY3QuYm91bmRfdmFvID0gdmFvO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFvLnNldHVwKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHQuYmluZFZlcnRleEFycmF5T0VTKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFZlcnRleEFycmF5T2JqZWN0LmJvdW5kX3ZhbyAhPSBudWxsICYmIHR5cGVvZiBWZXJ0ZXhBcnJheU9iamVjdC5ib3VuZF92YW8udGVhcmRvd24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIFZlcnRleEFycmF5T2JqZWN0LmJvdW5kX3Zhby50ZWFyZG93bigpO1xuICAgICAgICB9XG4gICAgICAgIFZlcnRleEFycmF5T2JqZWN0LmJvdW5kX3ZhbyA9IG51bGw7XG4gICAgfVxufTtcbiIsIi8vIE1hbmFnZSByZW5kZXJpbmcgZm9yIHByaW1pdGl2ZXNcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gJy4vc2hhZGVyX3Byb2dyYW0nO1xuaW1wb3J0IFZlcnRleEFycmF5T2JqZWN0IGZyb20gJy4vdmFvJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG4vLyBBIHNpbmdsZSBtZXNoL1ZCTywgZGVzY3JpYmVkIGJ5IGEgdmVydGV4IGxheW91dCwgdGhhdCBjYW4gYmUgZHJhd24gd2l0aCBvbmUgb3IgbW9yZSBwcm9ncmFtc1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVkJPTWVzaCAge1xuXG4gICAgY29uc3RydWN0b3IoZ2wsIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfbGF5b3V0LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfZGF0YSA9IHZlcnRleF9kYXRhOyAvLyB0eXBlZCBhcnJheVxuICAgICAgICB0aGlzLnZlcnRleF9sYXlvdXQgPSB2ZXJ0ZXhfbGF5b3V0O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIHRoaXMuZHJhd19tb2RlID0gb3B0aW9ucy5kcmF3X21vZGUgfHwgdGhpcy5nbC5UUklBTkdMRVM7XG4gICAgICAgIHRoaXMuZGF0YV91c2FnZSA9IG9wdGlvbnMuZGF0YV91c2FnZSB8fCB0aGlzLmdsLlNUQVRJQ19EUkFXO1xuICAgICAgICB0aGlzLnZlcnRpY2VzX3Blcl9nZW9tZXRyeSA9IDM7IC8vIFRPRE86IHN1cHBvcnQgbGluZXMsIHN0cmlwLCBmYW4sIGV0Yy5cbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IG9wdGlvbnMudW5pZm9ybXM7XG4gICAgICAgIHRoaXMucmV0YWluID0gb3B0aW9ucy5yZXRhaW4gfHwgZmFsc2U7IC8vIHdoZXRoZXIgdG8gcmV0YWluIG1lc2ggZGF0YSBpbiBDUFUgYWZ0ZXIgdXBsb2FkaW5nIHRvIEdQVVxuXG4gICAgICAgIHRoaXMudmVydGV4X2NvdW50ID0gdGhpcy52ZXJ0ZXhfZGF0YS5ieXRlTGVuZ3RoIC8gdGhpcy52ZXJ0ZXhfbGF5b3V0LnN0cmlkZTtcbiAgICAgICAgdGhpcy5nZW9tZXRyeV9jb3VudCA9IHRoaXMudmVydGV4X2NvdW50IC8gdGhpcy52ZXJ0aWNlc19wZXJfZ2VvbWV0cnk7XG4gICAgICAgIHRoaXMudmFvcyA9IG5ldyBNYXAoKTsgLy8gbWFwIG9mIFZlcnRleEFycmF5T2JqZWN0cywga2V5ZWQgYnkgcHJvZ3JhbVxuXG4gICAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuICAgICAgICB0aGlzLmdsLmJ1ZmZlckRhdGEodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4X2RhdGEsIHRoaXMuZGF0YV91c2FnZSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnJldGFpbikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMudmVydGV4X2RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gUmVuZGVyLCBieSBkZWZhdWx0IHdpdGggY3VycmVudGx5IGJvdW5kIHByb2dyYW0sIG9yIG90aGVyd2lzZSB3aXRoIG9wdGlvbmFsbHkgcHJvdmlkZWQgb25lXG4gICAgcmVuZGVyKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoIXRoaXMudmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fcmVuZGVyX3NldHVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJfc2V0dXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9ncmFtID0gb3B0aW9ucy5wcm9ncmFtIHx8IFNoYWRlclByb2dyYW0uY3VycmVudDtcbiAgICAgICAgcHJvZ3JhbS51c2UoKTtcblxuICAgICAgICBpZiAodGhpcy51bmlmb3Jtcykge1xuICAgICAgICAgICAgcHJvZ3JhbS5zYXZlVW5pZm9ybXModGhpcy51bmlmb3Jtcyk7XG4gICAgICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm1zKHRoaXMudW5pZm9ybXMsIGZhbHNlKTsgLy8gZG9uJ3QgcmVzZXQgdGV4dHVyZSB1bml0XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJpbmQocHJvZ3JhbSk7XG5cbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBlbGVtZW50IGFycmF5IG1vZGVcbiAgICAgICAgdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZHJhd19tb2RlLCAwLCB0aGlzLnZlcnRleF9jb3VudCk7XG4gICAgICAgIFZlcnRleEFycmF5T2JqZWN0LmJpbmQobnVsbCk7XG5cbiAgICAgICAgaWYgKHRoaXMudW5pZm9ybXMpIHtcbiAgICAgICAgICAgIHByb2dyYW0ucmVzdG9yZVVuaWZvcm1zKHRoaXMudW5pZm9ybXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQmluZCBidWZmZXJzIGFuZCB2ZXJ0ZXggYXR0cmlidXRlcyB0byBwcmVwYXJlIGZvciByZW5kZXJpbmdcbiAgICBiaW5kKHByb2dyYW0pIHtcbiAgICAgICAgLy8gQmluZCBWQU8gZm9yIHRoaXMgcHJvZ2FtLCBvciBjcmVhdGUgb25lXG4gICAgICAgIGxldCB2YW8gPSB0aGlzLnZhb3MuZ2V0KHByb2dyYW0pO1xuICAgICAgICBpZiAodmFvKSB7XG4gICAgICAgICAgICBWZXJ0ZXhBcnJheU9iamVjdC5iaW5kKHZhbyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhb3Muc2V0KHByb2dyYW0sIFZlcnRleEFycmF5T2JqZWN0LmNyZWF0ZSgoZm9yY2UpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRleF9sYXlvdXQuZW5hYmxlKHRoaXMuZ2wsIHByb2dyYW0sIGZvcmNlKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcblxuICAgICAgICBsb2cudHJhY2UoJ1ZCT01lc2guZGVzdHJveTogZGVsZXRlIGJ1ZmZlcicgKyAodGhpcy52ZXJ0ZXhfZGF0YSA/IGAgb2Ygc2l6ZSAke3RoaXMudmVydGV4X2RhdGEuYnl0ZUxlbmd0aH1gIDogJycpKTtcblxuICAgICAgICB0aGlzLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIHRoaXMudmVydGV4X2RhdGE7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgZ2wgZnJvbSAnLi9jb25zdGFudHMnOyAvLyB3ZWIgd29ya2VycyBkb24ndCBoYXZlIGFjY2VzcyB0byBHTCBjb250ZXh0LCBzbyBpbXBvcnQgYWxsIEdMIGNvbnN0YW50c1xuaW1wb3J0IHtsb2d9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcblxuLy8gTWFwcyBHTCB0eXBlcyB0byBKUyBhcnJheSB0eXBlc1xubGV0IGFycmF5X3R5cGVzID0ge1xuICAgIFtnbC5GTE9BVF06IEZsb2F0MzJBcnJheSxcbiAgICBbZ2wuQllURV06IEludDhBcnJheSxcbiAgICBbZ2wuVU5TSUdORURfQllURV06IFVpbnQ4QXJyYXksXG4gICAgW2dsLklOVF06IEludDMyQXJyYXksXG4gICAgW2dsLlVOU0lHTkVEX0lOVF06IFVpbnQzMkFycmF5LFxuICAgIFtnbC5TSE9SVF06IEludDE2QXJyYXksXG4gICAgW2dsLlVOU0lHTkVEX1NIT1JUXTogVWludDE2QXJyYXlcbn07XG5cbi8vIEFuIGludGVybWVkaWFyeSBvYmplY3QgdGhhdCBob2xkcyB2ZXJ0ZXggZGF0YSBpbiB0eXBlZCBhcnJheXMsIGFjY29yZGluZyB0byBhIGdpdmVuIHZlcnRleCBsYXlvdXRcbi8vIFVzZWQgdG8gY29uc3RydWN0IGEgbWVzaC9WQk8gZm9yIHJlbmRlcmluZ1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVydGV4RGF0YSB7XG5cbiAgICBjb25zdHJ1Y3RvciAodmVydGV4X2xheW91dCwgeyBwcmVhbGxvYyB9ID0ge30pIHtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0ID0gdmVydGV4X2xheW91dDtcblxuICAgICAgICBpZiAoVmVydGV4RGF0YS5hcnJheV9wb29sLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gVmVydGV4RGF0YS5hcnJheV9wb29sLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJfbGVuZ3RoID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyX3NpemUgPSBNYXRoLmZsb29yKHRoaXMuYnVmZmVyX2xlbmd0aCAvIHRoaXMudmVydGV4X2xheW91dC5zdHJpZGUpO1xuICAgICAgICAgICAgbG9nKCd0cmFjZScsIGBWZXJ0ZXhEYXRhOiByZXVzZWQgYnVmZmVyIG9mIGJ5dGVzICR7dGhpcy5idWZmZXJfbGVuZ3RofSwgJHt0aGlzLmJ1ZmZlcl9zaXplfSB2ZXJ0aWNlc2ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJfc2l6ZSA9IHByZWFsbG9jIHx8IDUwMDsgLy8gIyBvZiB2ZXJ0aWNlcyB0byBhbGxvY2F0ZVxuICAgICAgICAgICAgdGhpcy5idWZmZXJfbGVuZ3RoID0gdGhpcy52ZXJ0ZXhfbGF5b3V0LnN0cmlkZSAqIHRoaXMuYnVmZmVyX3NpemU7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyX2xlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXJfb2Zmc2V0ID0gMDsgICAgICAgICAgICAgLy8gYnl0ZSBvZmZzZXQgaW50byBjdXJyZW50bHkgYWxsb2NhdGVkIGJ1ZmZlclxuXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBjb21wb25lbnQgb2YgdGhpcy52ZXJ0ZXhfbGF5b3V0LmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKFsuLi5jb21wb25lbnRdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnRleF9jb3VudCA9IDA7XG4gICAgICAgIHRoaXMucmVhbGxvY19jb3VudCA9IDA7XG4gICAgICAgIHRoaXMuc2V0QnVmZmVyVmlld3MoKTtcbiAgICB9XG5cbiAgICAvLyAoUmUtKWFsbG9jYXRlIHR5cGVkIHZpZXdzIGludG8gdGhlIG1haW4gYnVmZmVyIC0gb25seSBjcmVhdGUgdGhlIHR5cGVzIHdlIG5lZWQgZm9yIHRoaXMgbGF5b3V0XG4gICAgc2V0QnVmZmVyVmlld3MgKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlcl92aWV3cyA9IHt9O1xuICAgICAgICB0aGlzLmJ1ZmZlcl92aWV3c1tnbC5VTlNJR05FRF9CWVRFXSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBmb3IgKHZhciBhdHRyaWIgb2YgdGhpcy52ZXJ0ZXhfbGF5b3V0LmF0dHJpYnMpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdmlldyBmb3IgdGhpcyB0eXBlP1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmZmVyX3ZpZXdzW2F0dHJpYi50eXBlXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFycmF5X3R5cGUgPSBhcnJheV90eXBlc1thdHRyaWIudHlwZV07XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJfdmlld3NbYXR0cmliLnR5cGVdID0gbmV3IGFycmF5X3R5cGUodGhpcy5idWZmZXIuYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBjb21wb25lbnQgYnVmZmVyIHBvaW50ZXJzXG4gICAgICAgIGZvciAodmFyIGNvbXBvbmVudCBvZiB0aGlzLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFsxXSA9IHRoaXMuYnVmZmVyX3ZpZXdzW2NvbXBvbmVudFswXV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBhbGxvY2F0ZWQgYnVmZmVyIHNpemUsIGV4cGFuZC9yZWFsbG9jIGJ1ZmZlciBpZiBuZWVkZWRcbiAgICBjaGVja0J1ZmZlclNpemUgKCkge1xuICAgICAgICBpZiAoKHRoaXMuYnVmZmVyX29mZnNldCArIHRoaXMudmVydGV4X2xheW91dC5zdHJpZGUpID4gdGhpcy5idWZmZXJfbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcl9zaXplID0gTWF0aC5mbG9vcih0aGlzLmJ1ZmZlcl9zaXplICogMS41KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyX3NpemUgLT0gdGhpcy5idWZmZXJfc2l6ZSAlIDQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcl9sZW5ndGggPSB0aGlzLnZlcnRleF9sYXlvdXQuc3RyaWRlICogdGhpcy5idWZmZXJfc2l6ZTtcbiAgICAgICAgICAgIHZhciBuZXdfdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyX2xlbmd0aCk7XG4gICAgICAgICAgICBuZXdfdmlldy5zZXQodGhpcy5idWZmZXIpOyAvLyBjb3B5IGV4aXN0aW5nIGRhdGEgdG8gbmV3IGJ1ZmZlclxuICAgICAgICAgICAgVmVydGV4RGF0YS5hcnJheV9wb29sLnB1c2godGhpcy5idWZmZXIpOyAvLyBzYXZlIHByZXZpb3VzIGJ1ZmZlciBmb3IgdXNlIGJ5IG5leHQgdGlsZVxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdfdmlldztcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyVmlld3MoKTtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvY19jb3VudCsrO1xuICAgICAgICAgICAgLy8gbG9nLmluZm8oYFZlcnRleERhdGE6IGV4cGFuZGVkIHZlcnRleCBibG9jayB0byAke3RoaXMuYnVmZmVyX3NpemV9IHZlcnRpY2VzYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgYSB2ZXJ0ZXgsIGNvcGllZCBmcm9tIGEgcGxhaW4gSlMgYXJyYXkgb2YgZWxlbWVudHMgbWF0Y2hpbmcgdGhlIG9yZGVyIG9mIHRoZSB2ZXJ0ZXggbGF5b3V0LlxuICAgIC8vIE5vdGU6IHVzZXMgcHJlLWNhbGN1bGF0ZWQgaW5mbyBhYm91dCBlYWNoIGF0dHJpYnV0ZSwgaW5jbHVkaW5nIHBvaW50ZXIgdG8gYXBwcm9wcmlhdGUgdHlwZWQgYXJyYXlcbiAgICAvLyB2aWV3IGFuZCBvZmZzZXQgaW50byBpdC4gVGhpcyB3YXMgdGhlIGZhc3Rlc3QgbWV0aG9kIHByb2ZpbGVkIHNvIGZhciBmb3IgZmlsbGluZyBhIG1peGVkLXR5cGVcbiAgICAvLyB2ZXJ0ZXggbGF5b3V0ICh0aG91Z2ggc3RpbGwgc2xvd2VyIHRoYW4gdGhlIHByZXZpb3VzIG1ldGhvZCB0aGF0IG9ubHkgc3VwcG9ydGVkIEZsb2F0MzJBcnJheSBhdHRyaWJ1dGVzKS5cbiAgICBhZGRWZXJ0ZXggKHZlcnRleCkge1xuICAgICAgICB0aGlzLmNoZWNrQnVmZmVyU2l6ZSgpO1xuICAgICAgICB2YXIgaT0wO1xuXG4gICAgICAgIHZhciBjbGVuID0gdGhpcy5jb21wb25lbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgYz0wOyBjIDwgY2xlbjsgYysrKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzW2NdO1xuICAgICAgICAgICAgY29tcG9uZW50WzFdWyh0aGlzLmJ1ZmZlcl9vZmZzZXQgPj4gY29tcG9uZW50WzJdKSArIGNvbXBvbmVudFszXV0gPSB2ZXJ0ZXhbaSsrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYnVmZmVyX29mZnNldCArPSB0aGlzLnZlcnRleF9sYXlvdXQuc3RyaWRlO1xuICAgICAgICB0aGlzLnZlcnRleF9jb3VudCsrO1xuICAgIH1cblxuICAgIC8vIEZpbmFsaXplIHZlcnRleCBidWZmZXIgZm9yIHVzZSBpbiBjb25zdHJ1Y3RpbmcgYSBtZXNoXG4gICAgZW5kICgpIHtcbiAgICAgICAgLy8gQ2xpcCB0aGUgYnVmZmVyIHRvIHNpemUgdXNlZCBmb3IgdGhpcyBWQk9cbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLmJ1ZmZlcl9vZmZzZXQpO1xuICAgICAgICBsb2coJ3RyYWNlJywgYFZlcnRleERhdGE6ICR7dGhpcy5idWZmZXJfc2l6ZX0gdmVydGljZXMgdG90YWwsIHJlYWxsb2MgY291bnQgJHt0aGlzLnJlYWxsb2NfY291bnR9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxufVxuXG5WZXJ0ZXhEYXRhLmFycmF5X3Bvb2wgPSBbXTsgLy8gcG9vbCBvZiBjdXJyZW50bHkgYXZhaWxhYmxlIChwcmV2aW91c2x5IHVzZWQpIGJ1ZmZlcnMgKHVpbnQ4KVxuIiwiaW1wb3J0IGdsIGZyb20gJy4vY29uc3RhbnRzJzsgLy8gd2ViIHdvcmtlcnMgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gR0wgY29udGV4dCwgc28gaW1wb3J0IGFsbCBHTCBjb25zdGFudHNcbmltcG9ydCBWZXJ0ZXhEYXRhIGZyb20gJy4vdmVydGV4X2RhdGEnO1xuXG4vLyBEZXNjcmliZXMgYSB2ZXJ0ZXggbGF5b3V0IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBtYW55IGRpZmZlcmVudCBHTCBwcm9ncmFtcy5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcnRleExheW91dCB7XG4gICAgLy8gQXR0cmlicyBhcmUgYW4gYXJyYXksIGluIGxheW91dCBvcmRlciwgb2Y6IG5hbWUsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWRcbiAgICAvLyBleDogeyBuYW1lOiAncG9zaXRpb24nLCBzaXplOiAzLCB0eXBlOiBnbC5GTE9BVCwgbm9ybWFsaXplZDogZmFsc2UgfVxuICAgIGNvbnN0cnVjdG9yIChhdHRyaWJzKSB7XG4gICAgICAgIHRoaXMuYXR0cmlicyA9IGF0dHJpYnM7IC8vIGRpY3Rpb25hcnkgb2YgYXR0cmlidXRlcywgc3BlY2lmaWVkIGFzIHN0YW5kYXJkIEdMIGF0dHJpYiBvcHRpb25zXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IFtdOyAgIC8vIGxpc3Qgb2YgdHlwZSBhbmQgb2Zmc2V0IGluZm8gYWJvdXQgZWFjaCBhdHRyaWJ1dGUgY29tcG9uZW50XG4gICAgICAgIHRoaXMuaW5kZXggPSB7fTsgICAgICAgIC8vIGxpbmVhciBidWZmZXIgaW5kZXggb2YgZWFjaCBhdHRyaWJ1dGUgY29tcG9uZW50LCBlLmcuIHRoaXMuaW5kZXgucG9zaXRpb24ueFxuXG4gICAgICAgIC8vIENhbGMgdmVydGV4IHN0cmlkZVxuICAgICAgICB0aGlzLnN0cmlkZSA9IDA7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgYXR0cmliIG9mIHRoaXMuYXR0cmlicykge1xuICAgICAgICAgICAgYXR0cmliLm9mZnNldCA9IHRoaXMuc3RyaWRlO1xuICAgICAgICAgICAgYXR0cmliLmJ5dGVfc2l6ZSA9IGF0dHJpYi5zaXplO1xuICAgICAgICAgICAgdmFyIHNoaWZ0ID0gMDtcblxuICAgICAgICAgICAgc3dpdGNoIChhdHRyaWIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgZ2wuRkxPQVQ6XG4gICAgICAgICAgICAgICAgY2FzZSBnbC5JTlQ6XG4gICAgICAgICAgICAgICAgY2FzZSBnbC5VTlNJR05FRF9JTlQ6XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYi5ieXRlX3NpemUgKj0gNDtcbiAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGdsLlNIT1JUOlxuICAgICAgICAgICAgICAgIGNhc2UgZ2wuVU5TSUdORURfU0hPUlQ6XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYi5ieXRlX3NpemUgKj0gMjtcbiAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRm9yY2UgNC1ieXRlIGFsaWdubWVudCBvbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICB0aGlzLnN0cmlkZSArPSBhdHRyaWIuYnl0ZV9zaXplO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RyaWRlICYgMykgeyAvLyBwYWQgdG8gbXVsdGlwbGUgb2YgNCBieXRlc1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyaWRlICs9IDQgLSAodGhpcy5zdHJpZGUgJiAzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIGluZm8gdG8gbGlzdCBvZiBhdHRyaWJ1dGUgY29tcG9uZW50c1xuICAgICAgICAgICAgLy8gVXNlZCB0byBidWlsZCB0aGUgdmVydGV4IGRhdGEsIHByb3ZpZGVzIHBvaW50ZXJzIGFuZCBvZmZzZXRzIGludG8gZWFjaCB0eXBlZCBhcnJheSB2aWV3XG4gICAgICAgICAgICAvLyBFYWNoIGNvbXBvbmVudCBpcyBhbiBhcnJheSBvZjpcbiAgICAgICAgICAgIC8vIFtHTCBhdHRyaWIgdHlwZSwgcG9pbnRlciB0byB0eXBlZCBhcnJheSB2aWV3LCBiaXRzIHRvIHNoaWZ0IHJpZ2h0IHRvIGRldGVybWluZSBidWZmZXIgb2Zmc2V0LCBhZGRpdGlvbmFsIGJ1ZmZlciBvZmZzZXQgZm9yIHRoZSBjb21wb25lbnRdXG4gICAgICAgICAgICB2YXIgb2Zmc2V0X3R5cGVkID0gYXR0cmliLm9mZnNldCA+PiBzaGlmdDtcbiAgICAgICAgICAgIGlmIChhdHRyaWIuc2l6ZSA+IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhPTA7IGEgPCBhdHRyaWIuc2l6ZTsgYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKFthdHRyaWIudHlwZSwgbnVsbCwgc2hpZnQsIG9mZnNldF90eXBlZCsrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLnB1c2goW2F0dHJpYi50eXBlLCBudWxsLCBzaGlmdCwgb2Zmc2V0X3R5cGVkXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByb3ZpZGUgYW4gaW5kZXggaW50byB0aGUgdmVydGV4IGRhdGEgYnVmZmVyIGZvciBlYWNoIGF0dHJpYnV0ZSBjb21wb25lbnRcbiAgICAgICAgICAgIHRoaXMuaW5kZXhbYXR0cmliLm5hbWVdID0gY291bnQ7XG4gICAgICAgICAgICBjb3VudCArPSBhdHRyaWIuc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldHVwIGEgdmVydGV4IGxheW91dCBmb3IgYSBzcGVjaWZpYyBHTCBwcm9ncmFtXG4gICAgLy8gQXNzdW1lcyB0aGF0IHRoZSBkZXNpcmVkIHZlcnRleCBidWZmZXIgKFZCTykgaXMgYWxyZWFkeSBib3VuZFxuICAgIC8vIElmIGEgZ2l2ZW4gcHJvZ3JhbSBkb2Vzbid0IGluY2x1ZGUgYWxsIGF0dHJpYnV0ZXMsIGl0IGNhbiBzdGlsbCB1c2UgdGhlIHZlcnRleCBsYXlvdXRcbiAgICAvLyB0byByZWFkIHRob3NlIGF0dHJpYnMgdGhhdCBpdCBkb2VzIHJlY29nbml6ZSwgdXNpbmcgdGhlIGF0dHJpYiBvZmZzZXRzIHRvIHNraXAgb3RoZXJzLlxuICAgIGVuYWJsZSAoZ2wsIHByb2dyYW0sIGZvcmNlKVxuICAgIHtcbiAgICAgICAgdmFyIGF0dHJpYiwgbG9jYXRpb247XG5cbiAgICAgICAgLy8gRW5hYmxlIGFsbCBhdHRyaWJ1dGVzIGZvciB0aGlzIGxheW91dFxuICAgICAgICBmb3IgKHZhciBhPTA7IGEgPCB0aGlzLmF0dHJpYnMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgIGF0dHJpYiA9IHRoaXMuYXR0cmlic1thXTtcbiAgICAgICAgICAgIGxvY2F0aW9uID0gcHJvZ3JhbS5hdHRyaWJ1dGUoYXR0cmliLm5hbWUpLmxvY2F0aW9uO1xuXG4gICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFWZXJ0ZXhMYXlvdXQuZW5hYmxlZF9hdHRyaWJzW2xvY2F0aW9uXSB8fCBmb3JjZSkge1xuICAgICAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jYXRpb24sIGF0dHJpYi5zaXplLCBhdHRyaWIudHlwZSwgYXR0cmliLm5vcm1hbGl6ZWQsIHRoaXMuc3RyaWRlLCBhdHRyaWIub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBWZXJ0ZXhMYXlvdXQuZW5hYmxlZF9hdHRyaWJzW2xvY2F0aW9uXSA9IHByb2dyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEaXNhYmxlIGFueSBwcmV2aW91c2x5IGJvdW5kIGF0dHJpYnV0ZXMgdGhhdCBhcmVuJ3QgZm9yIHRoaXMgbGF5b3V0XG4gICAgICAgIGZvciAobG9jYXRpb24gaW4gVmVydGV4TGF5b3V0LmVuYWJsZWRfYXR0cmlicykge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlVW51c2VkQXR0cmlidXRlKGdsLCBsb2NhdGlvbiwgcHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXNhYmxlIGFuIGF0dHJpYnV0ZSBpZiBpdCB3YXMgbm90IGVuYWJsZWQgZm9yIHRoZSBzcGVjaWZpZWQgcHJvZ3JhbVxuICAgIC8vIE5PVEU6IHRoaXMgd2FzIG1vdmVkIG91dCBvZiB0aGUgaW5uZXIgbG9vcCBpbiBlbmFibGUoKSB0byBhc3Npc3Qgdy9WTSBvcHRpbWl6YXRpb25cbiAgICBkaXNhYmxlVW51c2VkQXR0cmlidXRlIChnbCwgbG9jYXRpb24sIHByb2dyYW0pIHtcbiAgICAgICAgaWYgKFZlcnRleExheW91dC5lbmFibGVkX2F0dHJpYnNbbG9jYXRpb25dICE9PSBwcm9ncmFtKSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xuICAgICAgICAgICAgZGVsZXRlIFZlcnRleExheW91dC5lbmFibGVkX2F0dHJpYnNbbG9jYXRpb25dO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlVmVydGV4RGF0YSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVydGV4RGF0YSh0aGlzKTtcbiAgICB9XG5cbn1cblxuLy8gVHJhY2sgY3VycmVudGx5IGVuYWJsZWQgYXR0cmlicywgYnkgdGhlIHByb2dyYW0gdGhleSBhcmUgYm91bmQgdG9cbi8vIFN0YXRpYyBjbGFzcyBwcm9wZXJ0eSB0byByZWZsZWN0IGdsb2JhbCBHTCBzdGF0ZVxuVmVydGV4TGF5b3V0LmVuYWJsZWRfYXR0cmlicyA9IHt9O1xuIiwiaW1wb3J0IFJlcGVhdEdyb3VwIGZyb20gJy4vcmVwZWF0X2dyb3VwJztcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbnZhciBDb2xsaXNpb247XG5cbmV4cG9ydCBkZWZhdWx0IENvbGxpc2lvbiA9IHtcblxuICAgIHRpbGVzOiB7fSxcblxuICAgIHN0YXJ0VGlsZSAodGlsZSkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnRpbGVzW3RpbGVdID0ge1xuICAgICAgICAgICAgYmJveGVzOiB7ICAgICAgICAgICAvLyBjdXJyZW50IHNldCBvZiBwbGFjZWQgYm91bmRpbmcgYm94ZXNcbiAgICAgICAgICAgICAgICBhYWJiOiBbXSxcbiAgICAgICAgICAgICAgICBvYmI6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb2JqZWN0czoge30sICAgICAgICAvLyBvYmplY3RzIHRvIGNvbGxpZGUsIGdyb3VwZWQgYnkgcHJpb3JpdHksIHRoZW4gYnkgc3R5bGVcbiAgICAgICAgICAgIGtlZXA6IHt9LCAgICAgICAgICAgLy8gb2JqZWN0cyB0aGF0IHdlcmUga2VwdCBhZnRlciBjb2xsaXNpb24sIGdyb3VwZWQgYnkgc3R5bGVcbiAgICAgICAgICAgIHN0eWxlczogbmV3IFNldCgpICAgLy8gc3R5bGVzIGNvbnRyaWJ1dGluZyBjb2xsaXNpb24gb2JqZWN0c1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBhbGwgcmVnaXN0ZXJlZCBzdHlsZXMgaGF2ZSBhZGRlZCBvYmplY3RzXG4gICAgICAgIHN0YXRlLmNvbXBsZXRlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc3RhdGUucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBzdGF0ZS5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZXNldFRpbGUgKHRpbGUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudGlsZXNbdGlsZV07XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIHN0eWxlIHRvIHRoZSBwZW5kaW5nIHNldCwgY29sbGlzaW9uIHdpbGwgYmxvY2sgb24gYWxsIHN0eWxlcyBzdWJtaXR0aW5nIHRvIGNvbGxpc2lvbiBzZXRcbiAgICBhZGRTdHlsZSAoc3R5bGUsIHRpbGUpIHtcbiAgICAgICAgdGhpcy50aWxlc1t0aWxlXS5zdHlsZXMuYWRkKHN0eWxlKTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGNvbGxpc2lvbiBvYmplY3RzIGZvciBhIHN0eWxlXG4gICAgY29sbGlkZSAob2JqZWN0cywgc3R5bGUsIHRpbGUpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy50aWxlc1t0aWxlXTtcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgbG9nLnRyYWNlKCdDb2xsaXNpb24uY29sbGlkZSgpIGNhbGxlZCB3aXRoIG51bGwgdGlsZScsIHRpbGUsIHRoaXMudGlsZXMsIHN0eWxlLCBvYmplY3RzKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChFcnJvcignQ29sbGlzaW9uLmNvbGxpZGUoKSBjYWxsZWQgd2l0aCBudWxsIHRpbGUnLCB0aWxlLCB0aGlzLnRpbGVzLCBzdHlsZSwgb2JqZWN0cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR3JvdXAgYnkgcHJpb3JpdHkgYW5kIHN0eWxlXG4gICAgICAgIGxldCB0aWxlX29iamVjdHMgPSBzdGF0ZS5vYmplY3RzO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgb2JqID0gb2JqZWN0c1tpXTtcbiAgICAgICAgICAgIGxldCBwcmlvcml0eSA9IG9iai5sYXlvdXQucHJpb3JpdHk7XG4gICAgICAgICAgICB0aWxlX29iamVjdHNbcHJpb3JpdHldID0gdGlsZV9vYmplY3RzW3ByaW9yaXR5XSB8fCB7fTtcbiAgICAgICAgICAgIHRpbGVfb2JqZWN0c1twcmlvcml0eV1bc3R5bGVdID0gdGlsZV9vYmplY3RzW3ByaW9yaXR5XVtzdHlsZV0gfHwgW107XG4gICAgICAgICAgICB0aWxlX29iamVjdHNbcHJpb3JpdHldW3N0eWxlXS5wdXNoKG9iaik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgZnJvbSBwZW5kaW5nIHN0eWxlIHNldCwgaWYgbm8gbW9yZSBzdHlsZXMsIGRvIGNvbGxpc2lvbiAmIGZpbmlzaCB0aWxlXG4gICAgICAgIHN0YXRlLnN0eWxlcy5kZWxldGUoc3R5bGUpO1xuICAgICAgICBpZiAoc3RhdGUuc3R5bGVzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW5kVGlsZSh0aWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdhaXQgZm9yIG9iamVjdHMgdG8gYmUgYWRkZWQgZnJvbSBhbGwgc3R5bGVzXG4gICAgICAgIHJldHVybiBzdGF0ZS5jb21wbGV0ZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5rZWVwW3N0eWxlXSB8fCBbXTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFRlc3QgbGFiZWxzIGZvciBjb2xsaXNpb25zLCBoaWdoZXIgdG8gbG93ZXIgcHJpb3JpdHlcbiAgICAvLyBXaGVuIHR3byBjb2xsaWRlLCBkaXNjYXJkIHRoZSBsb3dlci1wcmlvcml0eSBsYWJlbFxuICAgIGVuZFRpbGUgKHRpbGUpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy50aWxlc1t0aWxlXTtcbiAgICAgICAgbGV0IGJib3hlcyA9IHN0YXRlLmJib3hlcztcbiAgICAgICAgbGV0IGtlZXAgPSBzdGF0ZS5rZWVwO1xuXG4gICAgICAgIFJlcGVhdEdyb3VwLmNsZWFyKHRpbGUpO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgbGFiZWxzIGJ5IHByaW9yaXR5LCB0aGVuIGJ5IHN0eWxlXG4gICAgICAgIGxldCBwcmlvcml0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUub2JqZWN0cykuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICBmb3IgKGxldCBwcmlvcml0eSBvZiBwcmlvcml0aWVzKSB7XG4gICAgICAgICAgICBsZXQgc3R5bGVfb2JqZWN0cyA9IHN0YXRlLm9iamVjdHNbcHJpb3JpdHldO1xuICAgICAgICAgICAgaWYgKCFzdHlsZV9vYmplY3RzKSB7IC8vIG5vIGxhYmVscyBhdCB0aGlzIHByaW9yaXR5LCBza2lwIHRvIG5leHRcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRm9yIGVhY2ggc3R5bGVcbiAgICAgICAgICAgIGZvciAobGV0IHN0eWxlIGluIHN0eWxlX29iamVjdHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgb2JqZWN0cyA9IHN0eWxlX29iamVjdHNbc3R5bGVdO1xuICAgICAgICAgICAgICAgIGtlZXBbc3R5bGVdID0ga2VlcFtzdHlsZV0gfHwgW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgbGFiZWwsIGxheW91dCB9ID0gb2JqZWN0c1tpXTsgLy8gVE9ETzogYGxhYmVsYCBzaG91bGQgYmUgZ2VuZXJpY1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRlc3QgdGhlIGxhYmVsIGZvciBpbnRlcnNlY3Rpb25zIHdpdGggb3RoZXIgbGFiZWxzIGluIHRoZSB0aWxlXG4gICAgICAgICAgICAgICAgICAgIGlmICghbGF5b3V0LmNvbGxpZGUgfHwgIWxhYmVsLmRpc2NhcmQoYmJveGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHJlcGVhdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaGVjayA9IFJlcGVhdEdyb3VwLmNoZWNrKGxhYmVsLCBsYXlvdXQsIHRpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9nLnRyYWNlKGBkaXNjYXJkIGxhYmVsICcke2xhYmVsLnRleHR9JywgKG9uZV9wZXJfZ3JvdXA6ICR7Y2hlY2sub25lX3Blcl9ncm91cH0pLCBkaXN0ICR7TWF0aC5zcXJ0KGNoZWNrLmRpc3Rfc3EpL2xheW91dC51bml0c19wZXJfcGl4ZWx9IDwgJHtNYXRoLnNxcnQoY2hlY2sucmVwZWF0X2Rpc3Rfc3EpL2xheW91dC51bml0c19wZXJfcGl4ZWx9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWdpc3RlciBhcyBwbGFjZWQgZm9yIGZ1dHVyZSByZXBlYXQgY3VsbGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVwZWF0R3JvdXAuYWRkKGxhYmVsLCBsYXlvdXQsIHRpbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbC5hZGQoYmJveGVzKTsgLy8gYWRkIGxhYmVsIHRvIGN1cnJlbnRseSB2aXNpYmxlIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAga2VlcFtzdHlsZV0ucHVzaChvYmplY3RzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGlmIChsYXlvdXQuY29sbGlkZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgbG9nLnRyYWNlKGBkaXNjYXJkIGxhYmVsICcke2xhYmVsLnRleHR9JyBkdWUgdG8gY29sbGlzaW9uYCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgdGhpcy50aWxlc1t0aWxlXTtcbiAgICAgICAgc3RhdGUucmVzb2x2ZSgpO1xuICAgIH1cblxufTtcbiIsImltcG9ydCBib3hJbnRlcnNlY3QgZnJvbSAnYm94LWludGVyc2VjdCc7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWtvbGFseXNlbmtvL2JveC1pbnRlcnNlY3RcbmltcG9ydCBVdGlscyBmcm9tICcuLi91dGlscy91dGlscyc7XG5pbXBvcnQgT0JCIGZyb20gJy4uL3V0aWxzL29iYic7XG5cbi8vIGltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbCB7XG5cbiAgICBjb25zdHJ1Y3RvciAoc2l6ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmFhYmIgPSBudWxsO1xuICAgICAgICB0aGlzLm9iYiA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIG92ZXJsYXBzIHdpdGggb3RoZXIgbGFiZWxzIGluIHRoZSB0aWxlXG4gICAgb2NjbHVkZWQgKGJib3hlcykge1xuICAgICAgICBsZXQgaW50ZXJzZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBhYWJicyA9IGJib3hlcy5hYWJiO1xuICAgICAgICBsZXQgb2JicyA9IGJib3hlcy5vYmI7XG5cbiAgICAgICAgLy8gQnJvYWQgcGhhc2VcbiAgICAgICAgaWYgKGFhYmJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGJveEludGVyc2VjdChbdGhpcy5hYWJiXSwgYWFiYnMsIChpLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gbG9nLnRyYWNlKCdjb2xsaXNpb246IGJyb2FkIHBoYXNlIGNvbGxpZGUnLCB0aGlzLm9wdGlvbnMuaWQsIHRoaXMsIHRoaXMuYWFiYiwgYWFiYnNbal0pO1xuXG4gICAgICAgICAgICAgICAgLy8gU2tpcCBuYXJyb3cgcGhhc2UgY29sbGlzaW9uIGlmIG5vIHJvdGF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JiLmFuZ2xlID09PSAwICYmIG9iYnNbal0uYW5nbGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nLnRyYWNlKCdjb2xsaXNpb246IHNraXAgbmFycm93IHBoYXNlIGNvbGxpZGUgYmVjYXVzZSBuZWl0aGVyIGlzIHJvdGF0ZWQnLCB0aGlzLm9wdGlvbnMuaWQsIHRoaXMsIHRoaXMub2JiLCBvYmJzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTmFycm93IHBoYXNlXG4gICAgICAgICAgICAgICAgaWYgKE9CQi5pbnRlcnNlY3QodGhpcy5vYmIsIG9iYnNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvZy50cmFjZSgnY29sbGlzaW9uOiBuYXJyb3cgcGhhc2UgY29sbGlkZScsIHRoaXMub3B0aW9ucy5pZCwgdGhpcywgdGhpcy5vYmIsIG9iYnNbal0pO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJzZWN0O1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGlzIGxhYmVsJ3MgYm91bmRpbmcgYm94IHRvIHRoZSBwcm92aWRlZCBzZXRcbiAgICBhZGQgKGJib3hlcykge1xuICAgICAgICBiYm94ZXMuYWFiYi5wdXNoKHRoaXMuYWFiYik7XG4gICAgICAgIGJib3hlcy5vYmIucHVzaCh0aGlzLm9iYik7XG4gICAgfVxuXG4gICAgLy8gY2hlY2tzIHdoZXRoZXIgdGhlIGxhYmVsIGlzIHdpdGhpbiB0aGUgdGlsZSBib3VuZGFyaWVzXG4gICAgaW5UaWxlQm91bmRzICgpIHtcbiAgICAgICAgbGV0IG1pbiA9IFsgdGhpcy5hYWJiWzBdLCB0aGlzLmFhYmJbMV0gXTtcbiAgICAgICAgbGV0IG1heCA9IFsgdGhpcy5hYWJiWzJdLCB0aGlzLmFhYmJbM10gXTtcblxuICAgICAgICBpZiAoIVV0aWxzLnBvaW50SW5UaWxlKG1pbikgfHwgIVV0aWxzLnBvaW50SW5UaWxlKG1heCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdoZXRoZXIgdGhlIGxhYmVsIHNob3VsZCBiZSBkaXNjYXJkZWRcbiAgICAvLyBEZXBlbmRzIG9uIHdoZXRoZXIgbGFiZWwgbXVzdCBmaXQgaW4gdGhlIHRpbGUgYm91bmRzLCBhbmQgaWYgc28sIGNhbiBpdCBiZSBtb3ZlZCB0byBmaXQgdGhlcmVcbiAgICBkaXNjYXJkIChiYm94ZXMpIHtcbiAgICAgICAgLy8gU2hvdWxkIHRoZSBsYWJlbCBiZSBjdWxsZWQgaWYgaXQgY2FuJ3QgZml0IGluc2lkZSB0aGUgdGlsZSBib3VuZHM/XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3VsbF9mcm9tX3RpbGUpIHtcbiAgICAgICAgICAgIGxldCBpbl90aWxlID0gdGhpcy5pblRpbGVCb3VuZHMoKTtcblxuICAgICAgICAgICAgLy8gSWYgaXQgZG9lc24ndCBmaXQsIHNob3VsZCB3ZSB0cnkgdG8gbW92ZSBpdCBpbnRvIHRoZSB0aWxlIGJvdW5kcz9cbiAgICAgICAgICAgIGlmICghaW5fdGlsZSAmJiB0aGlzLm9wdGlvbnMubW92ZV9pbnRvX3RpbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW4gd2UgZml0IHRoZSBsYWJlbCBpbnRvIHRoZSB0aWxlP1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tb3ZlSW50b1RpbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gY2FuJ3QgZml0IGluIHRpbGUsIGRpc2NhcmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpbl90aWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIG91dCBvZiB0aWxlIGJvdW5kcywgZGlzY2FyZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGxhYmVsIGhhc24ndCBiZWVuIGRpc2NhcmRlZCB5ZXQsIGNoZWNrIHRvIHNlZSBpZiBpdCdzIG9jY2x1ZGVkIGJ5IG90aGVyIGxhYmVsc1xuICAgICAgICByZXR1cm4gdGhpcy5vY2NsdWRlZChiYm94ZXMpO1xuICAgIH1cbn1cblxuTGFiZWwuZXBzaWxvbiA9IDAuOTk5OTsgLy8gdG9sZXJhbmNlIGFyb3VuZCBjb2xsaXNpb24gYm94ZXMsIHByZXZlbnQgcGVyZmVjdGx5IGFkamFjZW50IG9iamVjdHMgZnJvbSBjb2xsaWRpbmdcbiIsImltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCBMYWJlbCBmcm9tICcuL2xhYmVsJztcbmltcG9ydCBPQkIgZnJvbSAnLi4vdXRpbHMvb2JiJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGFiZWxMaW5lIGV4dGVuZHMgTGFiZWwge1xuXG4gICAgY29uc3RydWN0b3IgKHNpemUsIGxpbmVzLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHNpemUsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuc2VnbWVudF9pbmRleCA9IDA7XG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICB1cGRhdGUgKCkge1xuICAgICAgICBsZXQgc2VnbWVudCA9IHRoaXMuY3VycmVudFNlZ21lbnQoKTtcbiAgICAgICAgdGhpcy5hbmdsZSA9IHRoaXMuY29tcHV0ZUFuZ2xlKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBbKHNlZ21lbnRbMF1bMF0gKyBzZWdtZW50WzFdWzBdKSAvIDIsIChzZWdtZW50WzBdWzFdICsgc2VnbWVudFsxXVsxXSkgLyAyXTtcbiAgICAgICAgdGhpcy51cGRhdGVCQm94ZXMoKTtcbiAgICB9XG5cbiAgICBtb3ZlTmV4dFNlZ21lbnQgKCkge1xuICAgICAgICBpZiAodGhpcy5zZWdtZW50X2luZGV4ICsgMSA+PSB0aGlzLmxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VnbWVudF9pbmRleCsrO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbXB1dGVBbmdsZSAoKSB7XG4gICAgICAgIGxldCBzZWdtZW50ID0gdGhpcy5jdXJyZW50U2VnbWVudCgpO1xuICAgICAgICBsZXQgcDBwMSA9IFZlY3Rvci5zdWIoc2VnbWVudFswXSwgc2VnbWVudFsxXSk7XG5cbiAgICAgICAgcDBwMSA9IFZlY3Rvci5ub3JtYWxpemUocDBwMSk7XG5cbiAgICAgICAgbGV0IFBJXzIgPSBNYXRoLlBJIC8gMjtcbiAgICAgICAgbGV0IHRoZXRhID0gTWF0aC5hdGFuMihwMHAxWzBdLCBwMHAxWzFdKSArIFBJXzI7XG5cbiAgICAgICAgaWYgKHRoZXRhID4gUElfMiB8fCB0aGV0YSA8IC1QSV8yKSB7XG4gICAgICAgICAgICB0aGV0YSArPSBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIHRoZXRhICU9IE1hdGguUEkgKiAyO1xuXG4gICAgICAgIHJldHVybiB0aGV0YTtcbiAgICB9XG5cbiAgICBmaXRUb1NlZ21lbnQgKCkge1xuICAgICAgICBsZXQgc2VnbWVudCA9IHRoaXMuY3VycmVudFNlZ21lbnQoKTtcbiAgICAgICAgbGV0IHAwcDEgPSBWZWN0b3Iuc3ViKHNlZ21lbnRbMF0sIHNlZ21lbnRbMV0pO1xuICAgICAgICBsZXQgbGVuZ3RoID0gVmVjdG9yLmxlbmd0aChwMHAxKTtcblxuICAgICAgICBsZXQgbGFiZWxfbGVuZ3RoID0gdGhpcy5zaXplWzBdICogdGhpcy5vcHRpb25zLnVuaXRzX3Blcl9waXhlbDtcblxuICAgICAgICBpZiAobGFiZWxfbGVuZ3RoID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBhbiBleGNlZWQgaGV1cmVzdGljIG9mIDEwMCUgd291bGQgbGV0IHRoZSBsYWJlbCBmaXQgaW4gYW55IGNhc2VzXG4gICAgICAgICAgICBsZXQgZXhjZWVkID0gKDEgLSAobGVuZ3RoIC8gbGFiZWxfbGVuZ3RoKSkgKiAxMDA7XG4gICAgICAgICAgICByZXR1cm4gZXhjZWVkIDwgdGhpcy5vcHRpb25zLmxpbmVfZXhjZWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsX2xlbmd0aCA8PSBsZW5ndGg7XG4gICAgfVxuXG4gICAgY3VycmVudFNlZ21lbnQgKCkge1xuICAgICAgICBsZXQgcDEgPSB0aGlzLmxpbmVzW3RoaXMuc2VnbWVudF9pbmRleF07XG4gICAgICAgIGxldCBwMiA9IHRoaXMubGluZXNbdGhpcy5zZWdtZW50X2luZGV4ICsgMV07XG5cbiAgICAgICAgcmV0dXJuIFsgcDEsIHAyIF07XG4gICAgfVxuXG4gICAgdXBkYXRlQkJveGVzICgpIHtcbiAgICAgICAgbGV0IHVwcCA9IHRoaXMub3B0aW9ucy51bml0c19wZXJfcGl4ZWw7XG4gICAgICAgIGxldCB3aWR0aCA9ICh0aGlzLnNpemVbMF0gKyB0aGlzLm9wdGlvbnMuYnVmZmVyWzBdICogMikgKiB1cHAgKiBMYWJlbC5lcHNpbG9uO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gKHRoaXMuc2l6ZVsxXSArIHRoaXMub3B0aW9ucy5idWZmZXJbMV0gKiAyKSAqIHVwcCAqIExhYmVsLmVwc2lsb247XG5cbiAgICAgICAgLy8gYXBwbHkgb2Zmc2V0LCB4IHBvc2l0aXZlLCB5IHBvaW50aW5nIGRvd25cbiAgICAgICAgbGV0IG9mZnNldCA9IFZlY3Rvci5yb3QodGhpcy5vcHRpb25zLm9mZnNldCwgdGhpcy5hbmdsZSk7XG4gICAgICAgIGxldCBwID0gW1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvblswXSArIChvZmZzZXRbMF0gKiB1cHApLFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSAtIChvZmZzZXRbMV0gKiB1cHApXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gdGhlIGFuZ2xlIG9mIHRoZSBvYmIgaXMgbmVnYXRpdmUgc2luY2UgaXQncyB0aGUgdGlsZSBzeXN0ZW0geSBheGlzIGlzIHBvaW50aW5nIGRvd25cbiAgICAgICAgdGhpcy5vYmIgPSBuZXcgT0JCKHBbMF0sIHBbMV0sIC10aGlzLmFuZ2xlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5hYWJiID0gdGhpcy5vYmIuZ2V0RXh0ZW50KCk7XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIG1vdmUgdGhlIGxhYmVsIGludG8gdGhlIHRpbGUgYm91bmRzXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmIGxhYmVsIHdhcyBtb3ZlZCBpbnRvIHRpbGUsIGZhbHNlIGlmIGl0IGNvdWxkbid0IGJlIG1vdmVkXG4gICAgbW92ZUludG9UaWxlICgpIHtcbiAgICAgICAgbGV0IGluX3RpbGUgPSBmYWxzZTtcbiAgICAgICAgbGV0IGZpdHNfdG9fc2VnbWVudCA9IHRoaXMuZml0VG9TZWdtZW50KCk7XG5cbiAgICAgICAgLy8gVHJ5IGxpbmUgc2VnbWVudHMgdW50aWwgd2UgZmluZCBvbmUgdGhhdCBmaXRzIHRoZSBsYWJlbCAoYW5kIGlzIGluc2lkZSB0aGUgdGlsZSlcbiAgICAgICAgd2hpbGUgKCFpbl90aWxlIHx8ICFmaXRzX3RvX3NlZ21lbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5tb3ZlTmV4dFNlZ21lbnQoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyB3ZSBjYW4ndCBtb3ZlIGZ1cnRoZXIgaW4gdGhpcyBsaW5lXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluX3RpbGUgPSB0aGlzLmluVGlsZUJvdW5kcygpO1xuICAgICAgICAgICAgZml0c190b19zZWdtZW50ID0gdGhpcy5maXRUb1NlZ21lbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbl90aWxlICYmIGZpdHNfdG9fc2VnbWVudDtcbiAgICB9XG5cbiAgICBkaXNjYXJkIChiYm94ZXMpIHtcbiAgICAgICAgLy8gRmlyc3QgZmluZCBhIGxpbmUgc2VnbWVudCB0aGF0IGZpdHMgdGhlIGxhYmVsXG4gICAgICAgIGlmICh0aGlzLmxpbmVzICYmICF0aGlzLmZpdFRvU2VnbWVudCgpKSB7XG4gICAgICAgICAgICB3aGlsZSAoIXRoaXMuZml0VG9TZWdtZW50KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubW92ZU5leHRTZWdtZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbGFiZWwgZml0cyBpbiBsaW5lLCBydW4gc3RhbmRhcmQgZGlzY2FyZCB0ZXN0c1xuICAgICAgICByZXR1cm4gc3VwZXIuZGlzY2FyZChiYm94ZXMpO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IExhYmVsIGZyb20gJy4vbGFiZWwnO1xuaW1wb3J0IEdlbyBmcm9tICcuLi9nZW8nO1xuaW1wb3J0IE9CQiBmcm9tICcuLi91dGlscy9vYmInO1xuaW1wb3J0IFBvaW50QW5jaG9yIGZyb20gJy4uL3N0eWxlcy9wb2ludHMvcG9pbnRfYW5jaG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGFiZWxQb2ludCBleHRlbmRzIExhYmVsIHtcblxuICAgIGNvbnN0cnVjdG9yIChwb3NpdGlvbiwgc2l6ZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihzaXplLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFtwb3NpdGlvblswXSwgcG9zaXRpb25bMV1dO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9mZnNldCA9IHRoaXMuY29tcHV0ZU9mZnNldCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUJCb3hlcygpO1xuICAgIH1cblxuICAgIGNvbXB1dGVPZmZzZXQgKCkge1xuICAgICAgICByZXR1cm4gUG9pbnRBbmNob3IuY29tcHV0ZU9mZnNldCh0aGlzLm9wdGlvbnMub2Zmc2V0LCB0aGlzLnNpemUsIHRoaXMub3B0aW9ucy5hbmNob3IpO1xuICAgIH1cblxuICAgIHVwZGF0ZUJCb3hlcyAoKSB7XG4gICAgICAgIGxldCB3aWR0aCA9ICh0aGlzLnNpemVbMF0gKyB0aGlzLm9wdGlvbnMuYnVmZmVyWzBdICogMikgKiB0aGlzLm9wdGlvbnMudW5pdHNfcGVyX3BpeGVsICogTGFiZWwuZXBzaWxvbjtcbiAgICAgICAgbGV0IGhlaWdodCA9ICh0aGlzLnNpemVbMV0gKyB0aGlzLm9wdGlvbnMuYnVmZmVyWzFdICogMikgKiB0aGlzLm9wdGlvbnMudW5pdHNfcGVyX3BpeGVsICogTGFiZWwuZXBzaWxvbjtcblxuICAgICAgICBsZXQgcCA9IFtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMF0gKyAodGhpcy5vcHRpb25zLm9mZnNldFswXSAqIHRoaXMub3B0aW9ucy51bml0c19wZXJfcGl4ZWwpLFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSAtICh0aGlzLm9wdGlvbnMub2Zmc2V0WzFdICogdGhpcy5vcHRpb25zLnVuaXRzX3Blcl9waXhlbClcbiAgICAgICAgXTtcblxuICAgICAgICB0aGlzLm9iYiA9IG5ldyBPQkIocFswXSwgcFsxXSwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuYWFiYiA9IHRoaXMub2JiLmdldEV4dGVudCgpO1xuICAgIH1cblxuICAgIC8vIFRyeSB0byBtb3ZlIHRoZSBsYWJlbCBpbnRvIHRoZSB0aWxlIGJvdW5kc1xuICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBsYWJlbCB3YXMgbW92ZWQgaW50byB0aWxlLCBmYWxzZSBpZiBpdCBjb3VsZG4ndCBiZSBtb3ZlZFxuICAgIG1vdmVJbnRvVGlsZSAoKSB7XG4gICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuYWFiYlswXSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMF0gKz0gLXRoaXMuYWFiYlswXTtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYWFiYlsyXSA+PSBHZW8udGlsZV9zY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvblswXSAtPSB0aGlzLmFhYmJbMl0gLSBHZW8udGlsZV9zY2FsZSArIDE7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFhYmJbM10gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzFdIC09IHRoaXMuYWFiYlszXTtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYWFiYlsxXSA8PSAtR2VvLnRpbGVfc2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMV0gLT0gdGhpcy5hYWJiWzFdICsgR2VvLnRpbGVfc2NhbGUgLSAxO1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCQm94ZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmluVGlsZUJvdW5kcygpO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IEdlbyBmcm9tICcuLi9nZW8nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXBlYXRHcm91cCB7XG5cbiAgICBjb25zdHJ1Y3RvciAoa2V5LCByZXBlYXRfZGlzdCwgbWF4X3JlcGVhdF9kaXN0KSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnJlcGVhdF9kaXN0ID0gcmVwZWF0X2Rpc3Q7XG4gICAgICAgIHRoaXMucmVwZWF0X2Rpc3Rfc3EgPSB0aGlzLnJlcGVhdF9kaXN0ICogdGhpcy5yZXBlYXRfZGlzdDtcbiAgICAgICAgdGhpcy5tYXhfcmVwZWF0X2Rpc3Rfc3EgPSBtYXhfcmVwZWF0X2Rpc3QgKiBtYXhfcmVwZWF0X2Rpc3Q7XG4gICAgICAgIHRoaXMub25lX3Blcl9ncm91cCA9ICh0aGlzLnJlcGVhdF9kaXN0X3NxID49IHRoaXMubWF4X3JlcGVhdF9kaXN0X3NxKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBhbiBvYmplY3QgdG8gc2VlIGlmIGl0J3MgYSByZXBlYXQgaW4gdGhpcyBncm91cFxuICAgIGNoZWNrIChvYmopIHtcbiAgICAgICAgLy8gSWYgb25seSBvbmUgb2JqZWN0IGFsbG93ZWQgcGVyIGdyb3VwLCBzaG9ydGN1dCBkaXN0YW5jZSBsb2dpY1xuICAgICAgICBpZiAodGhpcy5vbmVfcGVyX2dyb3VwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIHJlcG9ydGVkIGRpc3RhbmNlIG1heGVzIG91dCBhdCB0aHJlc2hvbGQgaW4gdGhpcyBjYXNlXG4gICAgICAgICAgICAgICAgLy8gKG5vdCB0cnVlIGRpc3QgdmFsdWUgc2luY2Ugd2Ugc2tpcHBlZCBjYWxjdWxhdGluZyBpdClcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkaXN0X3NxOiB0aGlzLm1heF9yZXBlYXRfZGlzdF9zcSxcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0X2Rpc3Rfc3E6IHRoaXMucmVwZWF0X2Rpc3Rfc3EsXG4gICAgICAgICAgICAgICAgICAgIG9uZV9wZXJfZ3JvdXA6IHRoaXMub25lX3Blcl9ncm91cFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47IC8vIG5vIG9iamVjdCBmb3IgdGhpcyBncm91cCB5ZXRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGRpc3RhbmNlIGZyb20gbmV3IG9iamVjdCB0byBvYmplY3RzIGFscmVhZHkgaW4gZ3JvdXBcbiAgICAgICAgbGV0IHAxID0gb2JqLnBvc2l0aW9uO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCB0aGlzLnBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHAyID0gdGhpcy5wb3NpdGlvbnNbaV07XG4gICAgICAgICAgICBsZXQgZHggPSBwMVswXSAtIHAyWzBdO1xuICAgICAgICAgICAgbGV0IGR5ID0gcDFbMV0gLSBwMlsxXTtcbiAgICAgICAgICAgIGxldCBkaXN0X3NxID0gZHggKiBkeCArIGR5ICogZHk7XG5cbiAgICAgICAgICAgIC8vIEZvdW5kIGFuIGV4aXN0aW5nIG9iamVjdCB3aXRoaW4gYWxsb3dlZCBkaXN0YW5jZVxuICAgICAgICAgICAgaWYgKGRpc3Rfc3EgPCB0aGlzLnJlcGVhdF9kaXN0X3NxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdF9zcSxcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0X2Rpc3Rfc3E6IHRoaXMucmVwZWF0X2Rpc3Rfc3FcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIG9iamVjdCB0byB0aGlzIGdyb3VwXG4gICAgYWRkIChvYmopIHtcbiAgICAgICAgLy8gb25seSBzdG9yZSBvYmplY3QncyBwb3NpdGlvbiwgdG8gc2F2ZSBzcGFjZSAvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmVmZXJlbmNlc1xuICAgICAgICBpZiAob2JqICYmIG9iai5wb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbnMucHVzaChvYmoucG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RhdGljIG1ldGhvZHMgYXJlIHVzZWQgdG8gbWFuYWdlIHJlcGVhdCBncm91cHMsIHdpdGhpbiBhbmQgYWNyb3NzIHRpbGVzXG5cbiAgICAvLyBSZXNldCBhbGwgZ3JvdXBzIGZvciB0aGlzIHRpbGVcbiAgICBzdGF0aWMgY2xlYXIgKHRpbGUpIHtcbiAgICAgICAgdGhpcy5ncm91cHNbdGlsZV0gPSB7fTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBhbiBvYmplY3QgdG8gc2VlIGlmIGl0J3MgYSByZXBlYXQgd2l0aGluIGl0cyBkZXNpZ25hdGVkIGdyb3VwXG4gICAgc3RhdGljIGNoZWNrIChvYmosIGxheW91dCwgdGlsZSkge1xuICAgICAgICBpZiAobGF5b3V0LnJlcGVhdF9kaXN0YW5jZSAmJiB0aGlzLmdyb3Vwc1t0aWxlXVtsYXlvdXQucmVwZWF0X2dyb3VwXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzW3RpbGVdW2xheW91dC5yZXBlYXRfZ3JvdXBdLmNoZWNrKG9iaik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgYW4gb2JqZWN0IHRvIGl0cyBkZXNpZ25hdGVkIGdyb3VwXG4gICAgc3RhdGljIGFkZCAob2JqLCBsYXlvdXQsIHRpbGUpIHtcbiAgICAgICAgaWYgKGxheW91dC5yZXBlYXRfZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3Vwc1t0aWxlXVtsYXlvdXQucmVwZWF0X2dyb3VwXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbdGlsZV1bbGF5b3V0LnJlcGVhdF9ncm91cF0gPSBuZXcgUmVwZWF0R3JvdXAoXG4gICAgICAgICAgICAgICAgICAgIGxheW91dC5yZXBlYXRfZ3JvdXAsXG4gICAgICAgICAgICAgICAgICAgIGxheW91dC5yZXBlYXRfZGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIFJlcGVhdEdyb3VwLm1heF9yZXBlYXRfZGlzdFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1t0aWxlXVtsYXlvdXQucmVwZWF0X2dyb3VwXS5hZGQob2JqKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG4vLyBDdXJyZW50IHNldCBvZiByZXBlYXQgZ3JvdXBzLCBncm91cGVkIGFuZCBrZXllZCBieSB0aWxlXG5SZXBlYXRHcm91cC5ncm91cHMgPSB7fTtcblxuLy8gTWF4IHJlcGVhdCBkaXN0OiBmb3IgZ3JvdXBzIHdpdGggYSByZXBlYXQgZGlzdCBiZXlvbmQgdGhpcyB0aHJlc2hvbGQsIG9ubHkgb25lIGxhYmVsXG4vLyB3aWxsIGJlIGFsbG93ZWQgcGVyIGdyb3VwLCBlLmcuIHNldCB0byB0aWxlIHNpemUgZm9yIG9uZS1sYWJlbC1wZXItdGlsZVxuUmVwZWF0R3JvdXAubWF4X3JlcGVhdF9kaXN0ID0gR2VvLnRpbGVfc2NhbGU7XG4iLCJpbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy91dGlscyc7XG5pbXBvcnQgU2NlbmUgZnJvbSAnLi9zY2VuZSc7XG5pbXBvcnQgR2VvIGZyb20gJy4vZ2VvJztcblxuLy8gRXhwb3J0cyBtdXN0IGFwcGVhciBvdXRzaWRlIGEgZnVuY3Rpb24sIGJ1dCB3aWxsIG9ubHkgYmUgZGVmaW5lZCBpbiBtYWluIHRocmVhZCAoYmVsb3cpXG5leHBvcnQgdmFyIExlYWZsZXRMYXllcjtcbmV4cG9ydCBmdW5jdGlvbiBsZWFmbGV0TGF5ZXIob3B0aW9ucykge1xuICAgIHJldHVybiBleHRlbmRMZWFmbGV0KG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBleHRlbmRMZWFmbGV0KG9wdGlvbnMpIHtcblxuICAgIC8vIElmIExlYWZsZXRMYXllciBpcyBhbHJlYWR5IGRlZmluZWQgd2hlbiB0aGlzIGlzIGNhbGxlZCBqdXN0IHJldHVybiB0aGF0IGltbWVkaWF0ZWx5XG4gICAgLy8gZS5nLiBpZiB5b3UgY2FsbCBsZWFmbGV0TGF5ZXIgbXVsdGlwbGUgdGltZXMgKHdoaWNoIGlzIHZhbGlkKVxuICAgIGlmICh0eXBlb2YgTGVhZmxldExheWVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmV3IExlYWZsZXRMYXllcihvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBMZWFmbGV0IGxheWVyIGZ1bmN0aW9uYWxpdHkgaXMgb25seSBkZWZpbmVkIGluIG1haW4gdGhyZWFkXG4gICAgaWYgKFV0aWxzLmlzTWFpblRocmVhZCkge1xuXG4gICAgICAgIGxldCBMID0gb3B0aW9ucy5sZWFmbGV0IHx8IHdpbmRvdy5MO1xuXG4gICAgICAgIC8vIERldGVybWluZSBpZiB3ZSBhcmUgZXh0ZW5kaW5nIHRoZSBsZWFmbGV0IDAuNy54IFRpbGVMYXllciBjbGFzcywgb3IgdGhlIG5ld2VyXG4gICAgICAgIC8vIGxlYWZsZXQgMS54IEdyaWRMYXllciBjbGFzcy5cbiAgICAgICAgbGV0IGxheWVyQmFzZUNsYXNzID0gTC5HcmlkTGF5ZXIgPyBMLkdyaWRMYXllciA6IEwuVGlsZUxheWVyO1xuICAgICAgICBsZXQgbGVhZmxldFZlcnNpb24gPSBsYXllckJhc2VDbGFzcyA9PT0gTC5HcmlkTGF5ZXIgPyAnMS54JyA6ICcwLjcueCc7XG4gICAgICAgIGxldCBsYXllckNsYXNzQ29uZmlnID0ge307XG5cbiAgICAgICAgLy8gSWYgZXh0ZW5kaW5nIGxlYWZsZXQgMC43LnggVGlsZUxheWVyLCBtYWtlIGFkZC9yZW1vdmUgdGlsZSBubyBvcHNcbiAgICAgICAgaWYgKGxheWVyQmFzZUNsYXNzID09PSBMLlRpbGVMYXllcikge1xuICAgICAgICAgICAgbGF5ZXJDbGFzc0NvbmZpZy5fYWRkVGlsZSA9IGZ1bmN0aW9uKCl7fTtcbiAgICAgICAgICAgIGxheWVyQ2xhc3NDb25maWcuX3JlbW92ZVRpbGUgPSBmdW5jdGlvbigpe307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgY3VzdG9tIGxheWVyIG1ldGhvZHNcbiAgICAgICAgT2JqZWN0LmFzc2lnbihsYXllckNsYXNzQ29uZmlnLCB7XG5cbiAgICAgICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdHNcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNob3dEZWJ1ZyA9ICghb3B0aW9ucy5zaG93RGVidWcgPyBmYWxzZSA6IHRydWUpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMud2hlZWxEZWJvdW5jZVRpbWUgPSBvcHRpb25zLndoZWVsRGVib3VuY2VUaW1lIHx8IDQwO1xuXG4gICAgICAgICAgICAgICAgTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlU2NlbmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhvb2tzID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgbGVhZmxldCB6b29tIGFuaW1hdGlvbnMgb2ZmXG4gICAgICAgICAgICAgICAgdGhpcy5fem9vbUFuaW1hdGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRlYm91bmNlVmlld1Jlc2V0ID0gVXRpbHMuZGVib3VuY2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAuZmlyZSgnem9vbWVuZCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAuZmlyZSgnbW92ZWVuZCcpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy53aGVlbERlYm91bmNlVGltZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjcmVhdGVTY2VuZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUgPSBTY2VuZS5jcmVhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zY2VuZSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtV29ya2VyczogdGhpcy5vcHRpb25zLm51bVdvcmtlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVVcGRhdGU6IHRoaXMub3B0aW9ucy5wcmVVcGRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0VXBkYXRlOiB0aGlzLm9wdGlvbnMucG9zdFVwZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNab29tOiAoTGVhZmxldExheWVyLmxlYWZsZXRWZXJzaW9uID09PSAnMS54JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWdoRGVuc2l0eURpc3BsYXk6IHRoaXMub3B0aW9ucy5oaWdoRGVuc2l0eURpc3BsYXksXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dMZXZlbDogdGhpcy5vcHRpb25zLmxvZ0xldmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWR2YW5jZWQgb3B0aW9uLCBhcHAgd2lsbCBoYXZlIHRvIG1hbnVhbGx5IGNhbGxlZCBzY2VuZS51cGRhdGUoKSBwZXIgZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVSZW5kZXJMb29wOiB0aGlzLm9wdGlvbnMuZGlzYWJsZVJlbmRlckxvb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZHZhbmNlZCBvcHRpb24sIHdpbGwgcmVxdWlyZSBsaWJyYXJ5IHRvIGJlIHNlcnZlZCBhcyBzYW1lIGhvc3QgYXMgcGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDcm9zc0RvbWFpbldvcmtlcnM6IHRoaXMub3B0aW9ucy5hbGxvd0Nyb3NzRG9tYWluV29ya2Vyc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEZpbmlzaCBpbml0aWFsaXppbmcgc2NlbmUgYW5kIHNldHVwIGV2ZW50cyB3aGVuIGxheWVyIGlzIGFkZGVkIHRvIG1hcFxuICAgICAgICAgICAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2NlbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVTY2VuZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxheWVyQmFzZUNsYXNzLnByb3RvdHlwZS5vbkFkZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ob29rcy5yZXNpemUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWFwLm9uKCdyZXNpemUnLCB0aGlzLmhvb2tzLnJlc2l6ZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmhvb2tzLm1vdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91cGRhdGluZ190YW5ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXcgPSBtYXAuZ2V0Q2VudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuem9vbSA9IE1hdGgubWluKG1hcC5nZXRab29tKCksIG1hcC5nZXRNYXhab29tKCkgfHwgR2VvLmRlZmF1bHRfdmlld19tYXhfem9vbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS52aWV3LnNldFZpZXcodmlldyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuaW1tZWRpYXRlUmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV2ZXJzZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtYXAub24oJ21vdmUnLCB0aGlzLmhvb2tzLm1vdmUpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ob29rcy56b29tc3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91cGRhdGluZ190YW5ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS52aWV3LnN0YXJ0Wm9vbSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtYXAub24oJ3pvb21zdGFydCcsIHRoaXMuaG9va3Muem9vbXN0YXJ0KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuaG9va3MuZHJhZ3N0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnZpZXcucGFubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtYXAub24oJ2RyYWdzdGFydCcsIHRoaXMuaG9va3MuZHJhZ3N0YXJ0KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuaG9va3MuZHJhZ2VuZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS52aWV3LnBhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1hcC5vbignZHJhZ2VuZCcsIHRoaXMuaG9va3MuZHJhZ2VuZCk7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBsZWFmbGV0IHpvb20gYW5pbWF0aW9ucyBvZmZcbiAgICAgICAgICAgICAgICBtYXAuX3pvb21BbmltYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gTW9kaWZ5IGRlZmF1bHQgbGVhZmxldCBzY3JvbGwgd2hlZWwgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVNjcm9sbFdoZWVsQmVoYXZpb3IobWFwKTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBHTCBjYW52YXMgdG8gbGF5ZXIgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5jb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lcigpO1xuXG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbCB2aWV3XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGFuZ3JhbSBldmVudHNcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vdmU6IHRoaXMub25UYW5ncmFtVmlld1VwZGF0ZS5iaW5kKHRoaXMpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgbGVhZmxldCdzIGV4aXN0aW5nIGV2ZW50IHN5c3RlbSBhcyB0aGUgY2FsbGJhY2sgbWVjaGFuaXNtXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5sb2FkKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXZlcnNlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnaW5pdCcpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJCYXNlQ2xhc3MucHJvdG90eXBlLm9uUmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICBtYXAub2ZmKCdyZXNpemUnLCB0aGlzLmhvb2tzLnJlc2l6ZSk7XG4gICAgICAgICAgICAgICAgbWFwLm9mZignbW92ZScsIHRoaXMuaG9va3MubW92ZSk7XG4gICAgICAgICAgICAgICAgbWFwLm9mZignem9vbXN0YXJ0JywgdGhpcy5ob29rcy56b29tc3RhcnQpO1xuICAgICAgICAgICAgICAgIG1hcC5vZmYoJ2RyYWdzdGFydCcsIHRoaXMuaG9va3MuZHJhZ3N0YXJ0KTtcbiAgICAgICAgICAgICAgICBtYXAub2ZmKCdkcmFnZW5kJywgdGhpcy5ob29rcy5kcmFnZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhvb2tzID0ge307XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2VuZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBjb29yZHMueCArICcvJyArIGNvb3Jkcy55ICsgJy8nICsgY29vcmRzLno7XG4gICAgICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGlsZS1rZXknLCBrZXkpO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS53aWR0aCA9ICcyNTZweCc7XG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9ICcyNTZweCc7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNob3dEZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVidWdfb3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z19vdmVybGF5LnRleHRDb250ZW50ID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z19vdmVybGF5LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS50b3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z19vdmVybGF5LnN0eWxlLmNvbG9yID0gJ3doaXRlJztcbiAgICAgICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS5mb250U2l6ZSA9ICcxNnB4JztcbiAgICAgICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS50ZXh0T3V0bGluZSA9ICcxcHggIzAwMDAwMCc7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnX292ZXJsYXkuc3R5bGUucGFkZGluZyA9ICc4cHgnO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChkZWJ1Z19vdmVybGF5KTtcbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLmJvcmRlclN0eWxlID0gJ3NvbGlkJztcbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLmJvcmRlckNvbG9yID0gJ3doaXRlJztcbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLmJvcmRlcldpZHRoID0gJzFweCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIE1vZGlmeSBsZWFmbGV0J3MgZGVmYXVsdCBzY3JvbGwgd2hlZWwgYmVoYXZpb3IgdG8gaGF2ZSBhIG11Y2ggbW9yZSBzZW5zaXR2ZS9jb250aW51b3VzIHpvb21cbiAgICAgICAgICAgIC8vIE5vdGU6IHRoaXMgc2hvdWxkIGJlIGRlcHJlY2F0ZWQgb25jZSBsZWFmbGV0IGNvbnRpbnVvdXMgem9vbSBpcyBtb3JlIHdpZGVseSB1c2VkIGFuZCB0aGVcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgYmVoYXZpb3IgaXMgcHJlc3VtYWJseSBpbXByb3ZlZFxuICAgICAgICAgICAgbW9kaWZ5U2Nyb2xsV2hlZWxCZWhhdmlvcjogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lLnZpZXcuY29udGludW91c196b29tICYmIG1hcC5zY3JvbGxXaGVlbFpvb20gJiYgdGhpcy5vcHRpb25zLm1vZGlmeVNjcm9sbFdoZWVsICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGF5ZXIgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5hYmxlZCA9IG1hcC5zY3JvbGxXaGVlbFpvb20uZW5hYmxlZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLnNjcm9sbFdoZWVsWm9vbS5kaXNhYmxlKCk7IC8vIGRpc2FibGUgYmVmb3JlIG1vZGlmeWluZ1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbW9kaWZ5IHByb3RvdHlwZSBhbmQgY3VycmVudCBpbnN0YW5jZSwgc28gYWRkL3JlbW92ZSBob29rcyB3b3JrIG9uIGV4aXN0aW5nIHJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgTC5NYXAuU2Nyb2xsV2hlZWxab29tLl9vbldoZWVsU2Nyb2xsID0gbWFwLnNjcm9sbFdoZWVsWm9vbS5fb25XaGVlbFNjcm9sbCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vZGlmeSB0byBza2lwIGRlYm91bmNlLCBhcyBpdCBzZWVtcyB0byBjYXVzZSBhbmltYXRpb24tc3luYyBpc3N1ZXMgaW4gQ2hyb21lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIFRhbmdyYW0gY29udGludW91cyByZW5kZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlbHRhICs9IEwuRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RNb3VzZVBvcyA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1ab29tKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBMLkRvbUV2ZW50LnN0b3AoZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgTC5NYXAuU2Nyb2xsV2hlZWxab29tLl9wZXJmb3JtWm9vbSA9IG1hcC5zY3JvbGxXaGVlbFpvb20uX3BlcmZvcm1ab29tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IHRoaXMuX2RlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuc3RvcCgpOyAvLyBzdG9wIHBhbm5pbmcgYW5kIGZseSBhbmltYXRpb25zIGlmIGFueVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB0aGlzIGlzIHRoZSBvbmx5IHJlYWwgbW9kaWZpY2F0aW9uIHRvIGRlZmF1bHQgbGVhZmxldCBiZWhhdmlvclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgLz0gNDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhID0gTWF0aC5tYXgoTWF0aC5taW4oZGVsdGEsIDQpLCAtNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IG1hcC5fbGltaXRab29tKHpvb20gKyBkZWx0YSkgLSB6b29tO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWx0YSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRlbHRhKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwLm9wdGlvbnMuc2Nyb2xsV2hlZWxab29tID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5zZXRab29tKHpvb20gKyBkZWx0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcywgem9vbSArIGRlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZGVib3VuY2VWaWV3UmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLnNjcm9sbFdoZWVsWm9vbS5lbmFibGUoKTsgLy8gcmUtZW5hYmxlIGFmdGVyIG1vZGlmeWluZ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdXBkYXRlVmlldzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuICAgICAgICAgICAgICAgIHZpZXcuem9vbSA9IE1hdGgubWluKHRoaXMuX21hcC5nZXRab29tKCksIHRoaXMuX21hcC5nZXRNYXhab29tKCkgfHwgR2VvLmRlZmF1bHRfdmlld19tYXhfem9vbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS52aWV3LnNldFZpZXcodmlldyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB1cGRhdGVTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUucmVzaXplTWFwKHNpemUueCwgc2l6ZS55KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uVGFuZ3JhbVZpZXdVcGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl91cGRhdGluZ190YW5ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwLnNldFZpZXcoW3RoaXMuc2NlbmUudmlldy5jZW50ZXIubGF0LCB0aGlzLnNjZW5lLnZpZXcuY2VudGVyLmxuZ10sIHRoaXMuc2NlbmUudmlldy56b29tLCB7IGFuaW1hdGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucmV2ZXJzZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zY2VuZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUudXBkYXRlKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBSZXZlcnNlIHRoZSBDU1MgcG9zaXRpb25pbmcgTGVhZmxldCBhcHBsaWVzIHRvIHRoZSBsYXllciwgc2luY2UgVGFuZ3JhbSdzIFdlYkdMIGNhbnZhc1xuICAgICAgICAgICAgLy8gaXMgZXhwZWN0ZWQgdG8gYmUgJ2Fic29sdXRlbHknIHBvc2l0aW9uZWQuXG4gICAgICAgICAgICByZXZlcnNlVHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9tYXAgfHwgIXRoaXMuc2NlbmUgfHwgIXRoaXMuc2NlbmUuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdG9wX2xlZnQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoWzAsIDBdKTtcbiAgICAgICAgICAgICAgICBMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5zY2VuZS5jb250YWluZXIsIHRvcF9sZWZ0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIGxheWVyIGNsYXNzXG4gICAgICAgIExlYWZsZXRMYXllciA9IGxheWVyQmFzZUNsYXNzLmV4dGVuZChsYXllckNsYXNzQ29uZmlnKTtcblxuICAgICAgICAvLyBQb2x5ZmlsbCBzb21lIDEuMCBtZXRob2RzXG4gICAgICAgIGlmICh0eXBlb2YgTGVhZmxldExheWVyLnJlbW92ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgTGVhZmxldExheWVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdyZW1vdmUnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBMZWFmbGV0TGF5ZXIubGF5ZXJCYXNlQ2xhc3MgPSBsYXllckJhc2VDbGFzcztcbiAgICAgICAgTGVhZmxldExheWVyLmxlYWZsZXRWZXJzaW9uID0gbGVhZmxldFZlcnNpb247XG5cbiAgICAgICAgcmV0dXJuIG5ldyBMZWFmbGV0TGF5ZXIob3B0aW9ucyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IFNoYWRlclByb2dyYW0gZnJvbSAnLi9nbC9zaGFkZXJfcHJvZ3JhbSc7XG5pbXBvcnQgc2hhZGVyU291cmNlcyBmcm9tICcuL2dsL3NoYWRlcl9zb3VyY2VzJzsgLy8gYnVpbHQtaW4gc2hhZGVyc1xuaW1wb3J0IEdMU0wgZnJvbSAnLi9nbC9nbHNsJztcbmltcG9ydCBHZW8gZnJvbSAnLi9nZW8nO1xuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfcGFyc2VyJztcblxuLy8gQWJzdHJhY3QgbGlnaHRcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpZ2h0IHtcblxuICAgIGNvbnN0cnVjdG9yICh2aWV3LCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5hbWJpZW50ID09IG51bGwgfHwgdHlwZW9mIGNvbmZpZy5hbWJpZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5hbWJpZW50ID0gR0xTTC5leHBhbmRWZWM0KGNvbmZpZy5hbWJpZW50IHx8IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hbWJpZW50ID0gU3R5bGVQYXJzZXIucGFyc2VDb2xvcihjb25maWcuYW1iaWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLmRpZmZ1c2UgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLmRpZmZ1c2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmRpZmZ1c2UgPSBHTFNMLmV4cGFuZFZlYzQoY29uZmlnLmRpZmZ1c2UgIT0gbnVsbCA/IGNvbmZpZy5kaWZmdXNlIDogMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpZmZ1c2UgPSBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKGNvbmZpZy5kaWZmdXNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuc3BlY3VsYXIgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLnNwZWN1bGFyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5zcGVjdWxhciA9IEdMU0wuZXhwYW5kVmVjNChjb25maWcuc3BlY3VsYXIgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNwZWN1bGFyID0gU3R5bGVQYXJzZXIucGFyc2VDb2xvcihjb25maWcuc3BlY3VsYXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgbGlnaHQgYnkgdHlwZSBuYW1lLCBmYWN0b3J5LXN0eWxlXG4gICAgLy8gJ2NvbmZpZycgbXVzdCBpbmNsdWRlICduYW1lJyBhbmQgJ3R5cGUnLCBhbG9uZyB3aXRoIGFueSBvdGhlciB0eXBlLXNwZWNpZmljIHByb3BlcnRpZXNcbiAgICBzdGF0aWMgY3JlYXRlICh2aWV3LCBjb25maWcpIHtcbiAgICAgICAgaWYgKExpZ2h0LnR5cGVzW2NvbmZpZy50eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaWdodC50eXBlc1tjb25maWcudHlwZV0odmlldywgY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBsaWdodCBmb3IgYSBzdHlsZTogZnJhZ21lbnQgbGlnaHRpbmcsIHZlcnRleCBsaWdodGluZywgb3Igbm9uZVxuICAgIHN0YXRpYyBzZXRNb2RlIChtb2RlLCBzdHlsZSkge1xuICAgICAgICBpZiAobW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbW9kZSA9ICdmcmFnbWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZSA9IExpZ2h0LmVuYWJsZWQgJiYgKChtb2RlICE9IG51bGwpID8gbW9kZSA6ICdmcmFnbWVudCcpOyAvLyBkZWZhdWx0IHRvIGZyYWdtZW50IGxpZ2h0aW5nXG4gICAgICAgIHN0eWxlLmRlZmluZXNbJ1RBTkdSQU1fTElHSFRJTkdfRlJBR01FTlQnXSA9IChtb2RlID09PSAnZnJhZ21lbnQnKTtcbiAgICAgICAgc3R5bGUuZGVmaW5lc1snVEFOR1JBTV9MSUdIVElOR19WRVJURVgnXSA9IChtb2RlID09PSAndmVydGV4Jyk7XG4gICAgfVxuXG4gICAgLy8gSW5qZWN0IGFsbCBwcm92aWRlZCBsaWdodCBkZWZpbml0aW9ucywgYW5kIGNhbGN1bGF0ZSBjdW11bGF0aXZlIGxpZ2h0IGZ1bmN0aW9uXG4gICAgc3RhdGljIGluamVjdCAobGlnaHRzKSB7XG4gICAgICAgIC8vIENsZWFyIHByZXZpb3VzIGluamVjdGlvbnNcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5yZW1vdmVCbG9jayhMaWdodC5ibG9jayk7XG5cbiAgICAgICAgLy8gSWYgbGlnaHRpbmcgaXMgZ2xvYmFsbHkgZGlzYWJsZWQsIG5vdGhpbmcgaXMgaW5qZWN0ZWQgKG1vc3RseSBmb3IgZGVidWdnaW5nIG9yIGxpdmUgZWRpdGluZylcbiAgICAgICAgaWYgKCFMaWdodC5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25zdHJ1Y3QgY29kZSB0byBjYWxjdWxhdGUgZWFjaCBsaWdodCBpbnN0YW5jZVxuICAgICAgICBsZXQgY2FsY3VsYXRlTGlnaHRzID0gXCJcIjtcbiAgICAgICAgaWYgKGxpZ2h0cyAmJiBPYmplY3Qua2V5cyhsaWdodHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIENvbGxlY3QgdW5pcXVlcyB0eXBlcyBvZiBsaWdodHNcbiAgICAgICAgICAgIGxldCB0eXBlcyA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgbGlnaHRfbmFtZSBpbiBsaWdodHMpIHtcbiAgICAgICAgICAgICAgICB0eXBlc1tsaWdodHNbbGlnaHRfbmFtZV0udHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbmplY3QgZWFjaCB0eXBlIG9mIGxpZ2h0XG4gICAgICAgICAgICBmb3IgKGxldCB0eXBlIGluIHR5cGVzKSB7XG4gICAgICAgICAgICAgICAgTGlnaHQudHlwZXNbdHlwZV0uaW5qZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluamVjdCBwZXItaW5zdGFuY2UgYmxvY2tzIGFuZCBjb25zdHJ1Y3QgdGhlIGxpc3Qgb2YgZnVuY3Rpb25zIHRvIGNhbGN1bGF0ZSBlYWNoIGxpZ2h0XG4gICAgICAgICAgICBmb3IgKGxldCBsaWdodF9uYW1lIGluIGxpZ2h0cykge1xuICAgICAgICAgICAgICAgIC8vIERlZmluZSBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIGxpZ2h0c1tsaWdodF9uYW1lXS5pbmplY3QoKTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY2FsY3VsYXRpb24gZnVuY3Rpb24gdG8gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVMaWdodHMgKz0gYGNhbGN1bGF0ZUxpZ2h0KCR7bGlnaHRfbmFtZX0sIF9leWVUb1BvaW50LCBfbm9ybWFsKTtcXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gbGlnaHQgaXMgZGVmaW5lZCwgdXNlIDEwMCUgb21uaWRpcmVjdGlvbmFsIGRpZmZ1c2UgbGlnaHRcbiAgICAgICAgICAgIGNhbGN1bGF0ZUxpZ2h0cyA9IGBcbiAgICAgICAgICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFXG4gICAgICAgICAgICAgICAgICAgIGxpZ2h0X2FjY3VtdWxhdG9yX2RpZmZ1c2UgPSB2ZWM0KDEuKTtcbiAgICAgICAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICAgIGA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHbHVlIHRvZ2V0aGVyIHRoZSBmaW5hbCBsaWdodGluZyBmdW5jdGlvbiB0aGF0IHN1bXMgYWxsIHRoZSBsaWdodHNcbiAgICAgICAgbGV0IGNhbGN1bGF0ZUZ1bmN0aW9uID0gYFxuICAgICAgICAgICAgdmVjNCBjYWxjdWxhdGVMaWdodGluZyhpbiB2ZWMzIF9leWVUb1BvaW50LCBpbiB2ZWMzIF9ub3JtYWwsIGluIHZlYzQgX2NvbG9yKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBEbyBpbml0aWFsIG1hdGVyaWFsIGNhbGN1bGF0aW9ucyBvdmVyIG5vcm1hbCwgZW1pc3Npb24sIGFtYmllbnQsIGRpZmZ1c2UgYW5kIHNwZWN1bGFyIHZhbHVlc1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZU1hdGVyaWFsKF9leWVUb1BvaW50LF9ub3JtYWwpO1xuXG4gICAgICAgICAgICAgICAgLy8gVW4gcm9sbCB0aGUgbG9vcCBvZiBpbmRpdmlkdWFsIGxpZ3RocyB0byBjYWxjdWxhdGVcbiAgICAgICAgICAgICAgICAke2NhbGN1bGF0ZUxpZ2h0c31cblxuICAgICAgICAgICAgICAgIC8vICBGaW5hbCBsaWdodCBpbnRlbnNpdHkgY2FsY3VsYXRpb25cbiAgICAgICAgICAgICAgICB2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xuXG4gICAgICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRU1JU1NJT05cbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBtYXRlcmlhbC5lbWlzc2lvbjtcbiAgICAgICAgICAgICAgICAjZW5kaWZcblxuICAgICAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgKz0gbGlnaHRfYWNjdW11bGF0b3JfYW1iaWVudCAqIF9jb2xvciAqIG1hdGVyaWFsLmFtYmllbnQ7XG4gICAgICAgICAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgKz0gbGlnaHRfYWNjdW11bGF0b3JfYW1iaWVudCAqIF9jb2xvciAqIG1hdGVyaWFsLmRpZmZ1c2U7XG4gICAgICAgICAgICAgICAgICAgICNlbmRpZlxuICAgICAgICAgICAgICAgICNlbmRpZlxuXG4gICAgICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRVxuICAgICAgICAgICAgICAgICAgICBjb2xvciArPSBsaWdodF9hY2N1bXVsYXRvcl9kaWZmdXNlICogX2NvbG9yICogbWF0ZXJpYWwuZGlmZnVzZTtcbiAgICAgICAgICAgICAgICAjZW5kaWZcblxuICAgICAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yICs9IGxpZ2h0X2FjY3VtdWxhdG9yX3NwZWN1bGFyICogbWF0ZXJpYWwuc3BlY3VsYXI7XG4gICAgICAgICAgICAgICAgI2VuZGlmXG5cbiAgICAgICAgICAgICAgICAvLyBDbGFtcCBmaW5hbCBjb2xvclxuICAgICAgICAgICAgICAgIGNvbG9yID0gY2xhbXAoY29sb3IsIDAuMCwgMS4wKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgICAgIH1gO1xuXG4gICAgICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soTGlnaHQuYmxvY2ssIGNhbGN1bGF0ZUZ1bmN0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBDb21tb24gaW5zdGFuY2UgZGVmaW5pdGlvblxuICAgIGluamVjdCAoKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9ICBgXG4gICAgICAgICAgICB1bmlmb3JtICR7dGhpcy5zdHJ1Y3RfbmFtZX0gdV8ke3RoaXMubmFtZX07XG4gICAgICAgICAgICAke3RoaXMuc3RydWN0X25hbWV9ICR7dGhpcy5uYW1lfTtcbiAgICAgICAgICAgIGA7XG4gICAgICAgIGxldCBhc3NpZ24gPSBgXG4gICAgICAgICAgICAke3RoaXMubmFtZX0gPSB1XyR7dGhpcy5uYW1lfTtcXG5cbiAgICAgICAgYDtcblxuICAgICAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKExpZ2h0LmJsb2NrLCBpbnN0YW5jZSk7XG4gICAgICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soJ3NldHVwJywgYXNzaWduKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgbWV0aG9kIGNhbGxlZCBvbmNlIHBlciBmcmFtZVxuICAgIHVwZGF0ZSAoKSB7XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIG9uY2UgcGVyIGZyYW1lIHBlciBwcm9ncmFtIChlLmcuIGZvciBtYWluIHJlbmRlciBwYXNzLCB0aGVuIGZvciBlYWNoIGFkZGl0aW9uYWxcbiAgICAvLyBwYXNzIGZvciBmZWF0dXJlIHNlbGVjdGlvbiwgZXRjLilcbiAgICBzZXR1cFByb2dyYW0gKF9wcm9ncmFtKSB7XG4gICAgICAgIC8vICBUaHJlZSBjb21tb24gbGlnaHQgcHJvcGVydGllc1xuICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCc0ZnYnLCBgdV8ke3RoaXMubmFtZX0uYW1iaWVudGAsIHRoaXMuYW1iaWVudCk7XG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzRmdicsIGB1XyR7dGhpcy5uYW1lfS5kaWZmdXNlYCwgdGhpcy5kaWZmdXNlKTtcbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnNGZ2JywgYHVfJHt0aGlzLm5hbWV9LnNwZWN1bGFyYCwgdGhpcy5zcGVjdWxhcik7XG4gICAgfVxuXG59XG5cbkxpZ2h0LnR5cGVzID0ge307IC8vIHJlZmVyZW5jZXMgdG8gc3ViY2xhc3NlcyBieSBzaG9ydCBuYW1lXG5MaWdodC5ibG9jayA9ICdsaWdodGluZyc7IC8vIHNoYWRlciBibG9jayBuYW1lXG5MaWdodC5lbmFibGVkID0gdHJ1ZTsgLy8gbGlnaHRpbmcgY2FuIGJlIGdsb2JhbGx5IGVuYWJsZWQvZGlzYWJsZWRcblxuXG4vLyBMaWdodCBzdWJjbGFzc2VzXG5jbGFzcyBBbWJpZW50TGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIodmlldywgY29uZmlnKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2FtYmllbnQnO1xuICAgICAgICB0aGlzLnN0cnVjdF9uYW1lID0gJ0FtYmllbnRMaWdodCc7XG4gICAgfVxuXG4gICAgLy8gSW5qZWN0IHN0cnVjdCBhbmQgY2FsY3VsYXRlIGZ1bmN0aW9uXG4gICAgc3RhdGljIGluamVjdCgpIHtcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5hZGRCbG9jayhMaWdodC5ibG9jaywgc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9hbWJpZW50TGlnaHQnXSk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9ncmFtIChfcHJvZ3JhbSkge1xuICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCc0ZnYnLCBgdV8ke3RoaXMubmFtZX0uYW1iaWVudGAsIHRoaXMuYW1iaWVudCk7XG4gICAgfVxuXG59XG5MaWdodC50eXBlc1snYW1iaWVudCddID0gQW1iaWVudExpZ2h0O1xuXG5jbGFzcyBEaXJlY3Rpb25hbExpZ2h0IGV4dGVuZHMgTGlnaHQge1xuXG4gICAgY29uc3RydWN0b3IodmlldywgY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKHZpZXcsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdkaXJlY3Rpb25hbCc7XG4gICAgICAgIHRoaXMuc3RydWN0X25hbWUgPSAnRGlyZWN0aW9uYWxMaWdodCc7XG5cbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAoY29uZmlnLmRpcmVjdGlvbiB8fCBbMC4yLCAwLjcsIC0wLjVdKS5tYXAocGFyc2VGbG9hdCk7IC8vIFt4LCB5LCB6XVxuICAgIH1cblxuICAgIC8vIEluamVjdCBzdHJ1Y3QgYW5kIGNhbGN1bGF0ZSBmdW5jdGlvblxuICAgIHN0YXRpYyBpbmplY3QoKSB7XG4gICAgICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soTGlnaHQuYmxvY2ssIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvZGlyZWN0aW9uYWxMaWdodCddKTtcbiAgICB9XG5cbiAgICBzZXR1cFByb2dyYW0gKF9wcm9ncmFtKSB7XG4gICAgICAgIHN1cGVyLnNldHVwUHJvZ3JhbShfcHJvZ3JhbSk7XG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzNmdicsIGB1XyR7dGhpcy5uYW1lfS5kaXJlY3Rpb25gLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgfVxuXG59XG5MaWdodC50eXBlc1snZGlyZWN0aW9uYWwnXSA9IERpcmVjdGlvbmFsTGlnaHQ7XG5cblxuY2xhc3MgUG9pbnRMaWdodCBleHRlbmRzIExpZ2h0IHtcblxuICAgIGNvbnN0cnVjdG9yICh2aWV3LCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIodmlldywgY29uZmlnKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3BvaW50JztcbiAgICAgICAgdGhpcy5zdHJ1Y3RfbmFtZSA9ICdQb2ludExpZ2h0JztcblxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gY29uZmlnLnBvc2l0aW9uIHx8IFswLCAwLCAnMTAwcHgnXTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbl9leWUgPSBbXTsgLy8gcG9zaXRpb24gaW4gZXllc3BhY2VcbiAgICAgICAgdGhpcy5vcmlnaW4gPSBjb25maWcub3JpZ2luIHx8ICdncm91bmQnO1xuICAgICAgICB0aGlzLmF0dGVudWF0aW9uID0gIWlzTmFOKHBhcnNlRmxvYXQoY29uZmlnLmF0dGVudWF0aW9uKSkgPyBwYXJzZUZsb2F0KGNvbmZpZy5hdHRlbnVhdGlvbikgOiAwO1xuXG4gICAgICAgIGlmIChjb25maWcucmFkaXVzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcucmFkaXVzKSAmJiBjb25maWcucmFkaXVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHRoaXMucmFkaXVzID0gY29uZmlnLnJhZGl1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmFkaXVzID0gW251bGwsIGNvbmZpZy5yYWRpdXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW5qZWN0IHN0cnVjdCBhbmQgY2FsY3VsYXRlIGZ1bmN0aW9uXG4gICAgc3RhdGljIGluamVjdCAoKSB7XG4gICAgICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soTGlnaHQuYmxvY2ssIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvcG9pbnRMaWdodCddKTtcbiAgICB9XG5cbiAgICAvLyBJbmplY3QgaXNudGFuY2Utc3BlY2lmaWMgc2V0dGluZ3NcbiAgICBpbmplY3QoKSB7XG4gICAgICAgIHN1cGVyLmluamVjdCgpO1xuXG4gICAgICAgIFNoYWRlclByb2dyYW0uZGVmaW5lc1snVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0VYUE9ORU5UJ10gPSAodGhpcy5hdHRlbnVhdGlvbiAhPT0gMCk7XG4gICAgICAgIFNoYWRlclByb2dyYW0uZGVmaW5lc1snVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0lOTkVSX1JBRElVUyddID0gKHRoaXMucmFkaXVzICE9IG51bGwgJiYgdGhpcy5yYWRpdXNbMF0gIT0gbnVsbCk7XG4gICAgICAgIFNoYWRlclByb2dyYW0uZGVmaW5lc1snVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVUyddID0gKHRoaXMucmFkaXVzICE9IG51bGwpO1xuICAgIH1cblxuICAgIHVwZGF0ZSAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRXllUG9zaXRpb24oKTtcbiAgICB9XG5cbiAgICB1cGRhdGVFeWVQb3NpdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ3dvcmxkJykge1xuICAgICAgICAgICAgLy8gRm9yIHdvcmxkIG9yaWdpbiwgZm9ybWF0IGlzOiBbbG9uZ2l0dWRlLCBsYXRpdHVkZSwgbWV0ZXJzIChkZWZhdWx0KSBvciBwaXhlbHMgdy9weCB1bml0c11cblxuICAgICAgICAgICAgLy8gTW92ZSBsaWdodCdzIHdvcmxkIHBvc2l0aW9uIGludG8gY2FtZXJhIHNwYWNlXG4gICAgICAgICAgICBsZXQgW3gsIHldID0gR2VvLmxhdExuZ1RvTWV0ZXJzKHRoaXMucG9zaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbl9leWVbMF0gPSB4IC0gdGhpcy52aWV3LmNhbWVyYS5wb3NpdGlvbl9tZXRlcnNbMF07XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uX2V5ZVsxXSA9IHkgLSB0aGlzLnZpZXcuY2FtZXJhLnBvc2l0aW9uX21ldGVyc1sxXTtcblxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbl9leWVbMl0gPSBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModGhpcy5wb3NpdGlvblsyXSxcbiAgICAgICAgICAgICAgICB7IHpvb206IHRoaXMudmlldy56b29tLCBtZXRlcnNfcGVyX3BpeGVsOiBHZW8ubWV0ZXJzUGVyUGl4ZWwodGhpcy52aWV3Lnpvb20pIH0pO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbl9leWVbMl0gPSB0aGlzLnBvc2l0aW9uX2V5ZVsyXSAtIHRoaXMudmlldy5jYW1lcmEucG9zaXRpb25fbWV0ZXJzWzJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2dyb3VuZCcgfHwgdGhpcy5vcmlnaW4gPT09ICdjYW1lcmEnKSB7XG4gICAgICAgICAgICAvLyBGb3IgY2FtZXJhIG9yIGdyb3VuZCBvcmlnaW4sIGZvcm1hdCBpczogW3gsIHksIHpdIGluIG1ldGVycyAoZGVmYXVsdCkgb3IgcGl4ZWxzIHcvcHggdW5pdHNcblxuICAgICAgICAgICAgLy8gTGlnaHQgaXMgaW4gY2FtZXJhIHNwYWNlIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25fZXllID0gU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHRoaXMucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgeyB6b29tOiB0aGlzLnZpZXcuem9vbSwgbWV0ZXJzX3Blcl9waXhlbDogR2VvLm1ldGVyc1BlclBpeGVsKHRoaXMudmlldy56b29tKSB9KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3JpZ2luID09PSAnZ3JvdW5kJykge1xuICAgICAgICAgICAgICAgIC8vIExlYXZlIGxpZ2h0J3MgeHkgaW4gY2FtZXJhIHNwYWNlLCBidXQgeiBuZWVkcyB0byBiZSBtb3ZlZCByZWxhdGl2ZSB0byBncm91bmQgcGxhbmVcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uX2V5ZVsyXSA9IHRoaXMucG9zaXRpb25fZXllWzJdIC0gdGhpcy52aWV3LmNhbWVyYS5wb3NpdGlvbl9tZXRlcnNbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXR1cFByb2dyYW0gKF9wcm9ncmFtKSB7XG4gICAgICAgIHN1cGVyLnNldHVwUHJvZ3JhbShfcHJvZ3JhbSk7XG5cbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnNGYnLCBgdV8ke3RoaXMubmFtZX0ucG9zaXRpb25gLFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbl9leWVbMF0sIHRoaXMucG9zaXRpb25fZXllWzFdLCB0aGlzLnBvc2l0aW9uX2V5ZVsyXSwgMSk7XG5cbiAgICAgICAgaWYoU2hhZGVyUHJvZ3JhbS5kZWZpbmVzWydUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fRVhQT05FTlQnXSkge1xuICAgICAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnMWYnLCBgdV8ke3RoaXMubmFtZX0uYXR0ZW51YXRpb25FeHBvbmVudGAsIHRoaXMuYXR0ZW51YXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoU2hhZGVyUHJvZ3JhbS5kZWZpbmVzWydUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTJ10pIHtcbiAgICAgICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzFmJywgYHVfJHt0aGlzLm5hbWV9LmlubmVyUmFkaXVzYCxcbiAgICAgICAgICAgICAgICBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModGhpcy5yYWRpdXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHsgem9vbTogdGhpcy52aWV3Lnpvb20sIG1ldGVyc19wZXJfcGl4ZWw6IEdlby5tZXRlcnNQZXJQaXhlbCh0aGlzLnZpZXcuem9vbSkgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoU2hhZGVyUHJvZ3JhbS5kZWZpbmVzWydUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fT1VURVJfUkFESVVTJ10pIHtcbiAgICAgICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzFmJywgYHVfJHt0aGlzLm5hbWV9Lm91dGVyUmFkaXVzYCxcbiAgICAgICAgICAgICAgICBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModGhpcy5yYWRpdXNbMV0sXG4gICAgICAgICAgICAgICAgICAgIHsgem9vbTogdGhpcy52aWV3Lnpvb20sIG1ldGVyc19wZXJfcGl4ZWw6IEdlby5tZXRlcnNQZXJQaXhlbCh0aGlzLnZpZXcuem9vbSkgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuTGlnaHQudHlwZXNbJ3BvaW50J10gPSBQb2ludExpZ2h0O1xuXG5cbmNsYXNzIFNwb3RMaWdodCBleHRlbmRzIFBvaW50TGlnaHQge1xuXG4gICAgY29uc3RydWN0b3IgKHZpZXcsIGNvbmZpZykge1xuICAgICAgICBzdXBlcih2aWV3LCBjb25maWcpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnc3BvdGxpZ2h0JztcbiAgICAgICAgdGhpcy5zdHJ1Y3RfbmFtZSA9ICdTcG90TGlnaHQnO1xuXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gKGNvbmZpZy5kaXJlY3Rpb24gfHwgWzAsIDAsIC0xXSkubWFwKHBhcnNlRmxvYXQpOyAvLyBbeCwgeSwgel1cbiAgICAgICAgdGhpcy5leHBvbmVudCA9IGNvbmZpZy5leHBvbmVudCA/IHBhcnNlRmxvYXQoY29uZmlnLmV4cG9uZW50KSA6IDAuMjtcbiAgICAgICAgdGhpcy5hbmdsZSA9IGNvbmZpZy5hbmdsZSA/IHBhcnNlRmxvYXQoY29uZmlnLmFuZ2xlKSA6IDIwO1xuICAgIH1cblxuICAgIC8vIEluamVjdCBzdHJ1Y3QgYW5kIGNhbGN1bGF0ZSBmdW5jdGlvblxuICAgIHN0YXRpYyBpbmplY3QgKCkge1xuICAgICAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKExpZ2h0LmJsb2NrLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3Nwb3RMaWdodCddKTtcbiAgICB9XG5cbiAgICBzZXR1cFByb2dyYW0gKF9wcm9ncmFtKSB7XG4gICAgICAgIHN1cGVyLnNldHVwUHJvZ3JhbShfcHJvZ3JhbSk7XG5cbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnM2Z2JywgYHVfJHt0aGlzLm5hbWV9LmRpcmVjdGlvbmAsIHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnMWYnLCBgdV8ke3RoaXMubmFtZX0uc3BvdENvc0N1dG9mZmAsIE1hdGguY29zKHRoaXMuYW5nbGUgKiAzLjE0MTU5IC8gMTgwKSk7XG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzFmJywgYHVfJHt0aGlzLm5hbWV9LnNwb3RFeHBvbmVudGAsIHRoaXMuZXhwb25lbnQpO1xuICAgIH1cblxufVxuTGlnaHQudHlwZXNbJ3Nwb3RsaWdodCddID0gU3BvdExpZ2h0O1xuIiwiaW1wb3J0IHNoYWRlclNvdXJjZXMgZnJvbSAnLi9nbC9zaGFkZXJfc291cmNlcyc7IC8vIGJ1aWx0LWluIHNoYWRlcnNcbmltcG9ydCBHTFNMIGZyb20gJy4vZ2wvZ2xzbCc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9wYXJzZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRlcmlhbCB7XG4gICAgY29uc3RydWN0b3IgKGNvbmZpZykge1xuXG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICAgICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGFsbCBoYXZlIHRoZSBzYW1lIGRlZmF1bHRzLCBzbyB0aGV5IGNhbiBiZSBzZXQgaW4gYnVsa1xuICAgICAgICBmb3IgKGxldCBwcm9wIG9mIFsnZW1pc3Npb24nLCAnYW1iaWVudCcsICdkaWZmdXNlJywgJ3NwZWN1bGFyJ10pIHtcbiAgICAgICAgICAgIGlmIChjb25maWdbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25maWdbcHJvcF0udGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTogY29uZmlnW3Byb3BdLnRleHR1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjb25maWdbcHJvcF0ubWFwcGluZyB8fCAnc3BoZXJlbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlOiBHTFNMLmV4cGFuZFZlYzMoY29uZmlnW3Byb3BdLnNjYWxlICE9IG51bGwgPyBjb25maWdbcHJvcF0uc2NhbGUgOiAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudDogR0xTTC5leHBhbmRWZWM0KGNvbmZpZ1twcm9wXS5hbW91bnQgIT0gbnVsbCA/IGNvbmZpZ1twcm9wXS5hbW91bnQgOiAxKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29uZmlnW3Byb3BdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BdID0geyBhbW91bnQ6IEdMU0wuZXhwYW5kVmVjNChjb25maWdbcHJvcF0pIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb25maWdbcHJvcF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcF0gPSB7IGFtb3VudDogU3R5bGVQYXJzZXIucGFyc2VDb2xvcihjb25maWdbcHJvcF0pIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BdID0gY29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4dHJhIHNwZWN1bGFyIHByb3BzXG4gICAgICAgIGlmICh0aGlzLnNwZWN1bGFyKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWN1bGFyLnNoaW5pbmVzcyA9IGNvbmZpZy5zaGluaW5lc3MgPyBwYXJzZUZsb2F0KGNvbmZpZy5zaGluaW5lc3MpIDogMC4yO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm9ybWFsIG1hcHBpbmdcbiAgICAgICAgaWYgKGNvbmZpZy5ub3JtYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ub3JtYWwgPSB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZTogY29uZmlnLm5vcm1hbC50ZXh0dXJlLFxuICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNvbmZpZy5ub3JtYWwubWFwcGluZyB8fCAndHJpcGxhbmFyJyxcbiAgICAgICAgICAgICAgICBzY2FsZTogR0xTTC5leHBhbmRWZWMzKGNvbmZpZy5ub3JtYWwuc2NhbGUgIT0gbnVsbCA/IGNvbmZpZy5ub3JtYWwuc2NhbGUgOiAxKSxcbiAgICAgICAgICAgICAgICBhbW91bnQ6IGNvbmZpZy5ub3JtYWwuYW1vdW50ICE9IG51bGwgPyBjb25maWcubm9ybWFsLmFtb3VudCA6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgYSBtYXRlcmlhbCBjb25maWcgYmxvY2sgaGFzIHN1ZmZpY2llbnQgcHJvcGVydGllcyB0byBjcmVhdGUgYSBtYXRlcmlhbFxuICAgIHN0YXRpYyBpc1ZhbGlkIChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLmVtaXNzaW9uID09IG51bGwgJiZcbiAgICAgICAgICAgIGNvbmZpZy5hbWJpZW50ID09IG51bGwgJiZcbiAgICAgICAgICAgIGNvbmZpZy5kaWZmdXNlID09IG51bGwgJiZcbiAgICAgICAgICAgIGNvbmZpZy5zcGVjdWxhciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpbmplY3QgKHN0eWxlKSB7XG4gICAgICAgIC8vIEZvciBlYWNoIHByb3BlcnR5LCBzZXRzIGRlZmluZXMgdG8gY29uZmlndXJlIHRleHR1cmUgbWFwcGluZywgd2l0aCBhIHBhdHRlcm4gbGlrZTpcbiAgICAgICAgLy8gICBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0UsIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRV9URVhUVVJFLCBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VfVEVYVFVSRV9TUEhFUkVNQVBcbiAgICAgICAgLy8gQWxzbyBzZXRzIGZsYWdzIHRvIGtlZXAgdHJhY2sgb2YgZWFjaCB1bmlxdWUgbWFwcGluZyB0eXBlIGJlaW5nIHVzZWQsIGUuZy46XG4gICAgICAgIC8vICAgVEFOR1JBTV9NQVRFUklBTF9URVhUVVJFX1NQSEVSRU1BUFxuICAgICAgICAvLyBFbmFibGVzIHRleHR1cmUgY29vcmRpbmF0ZXMgaWYgbmVlZGVkIGFuZCBub3QgYWxyZWFkeSBvblxuICAgICAgICBmb3IgKGxldCBwcm9wIG9mIFsnZW1pc3Npb24nLCAnYW1iaWVudCcsICdkaWZmdXNlJywgJ3NwZWN1bGFyJ10pIHtcbiAgICAgICAgICAgIGxldCBkZWYgPSBgVEFOR1JBTV9NQVRFUklBTF8ke3Byb3AudG9VcHBlckNhc2UoKX1gO1xuICAgICAgICAgICAgbGV0IHRleGRlZiA9IGRlZiArICdfVEVYVFVSRSc7XG4gICAgICAgICAgICBzdHlsZS5kZWZpbmVzW2RlZl0gPSAodGhpc1twcm9wXSAhPSBudWxsKTtcbiAgICAgICAgICAgIGlmICh0aGlzW3Byb3BdICYmIHRoaXNbcHJvcF0udGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlLmRlZmluZXNbdGV4ZGVmXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3R5bGUuZGVmaW5lc1t0ZXhkZWYgKyAnXycgKyB0aGlzW3Byb3BdLm1hcHBpbmcudG9VcHBlckNhc2UoKV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0eWxlLmRlZmluZXNbYFRBTkdSQU1fTUFURVJJQUxfVEVYVFVSRV8ke3RoaXNbcHJvcF0ubWFwcGluZy50b1VwcGVyQ2FzZSgpfWBdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXhjb29yZHMgPSBzdHlsZS50ZXhjb29yZHMgfHwgKHRoaXNbcHJvcF0ubWFwcGluZyA9PT0gJ3V2Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3JtYWwgbWFwcGluZ1xuICAgICAgICAvLyBBcyBhbm92ZSwgc2V0cyBmbGFncyB0byBrZWVwIHRyYWNrIG9mIGVhY2ggdW5pcXVlIG1hcHBpbmcgdHlwZSBiZWluZyB1c2VkLCBlLmcuOlxuICAgICAgICAvLyAgIFRBTkdSQU1fTUFURVJJQUxfVEVYVFVSRV9TUEhFUkVNQVBcbiAgICAgICAgaWYgKHRoaXMubm9ybWFsICYmIHRoaXMubm9ybWFsLnRleHR1cmUpIHtcbiAgICAgICAgICAgIHN0eWxlLmRlZmluZXNbJ1RBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkUnXSA9IHRydWU7XG4gICAgICAgICAgICBzdHlsZS5kZWZpbmVzWydUQU5HUkFNX01BVEVSSUFMX05PUk1BTF9URVhUVVJFXycgKyB0aGlzLm5vcm1hbC5tYXBwaW5nLnRvVXBwZXJDYXNlKCldID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0eWxlLmRlZmluZXNbYFRBTkdSQU1fTUFURVJJQUxfVEVYVFVSRV8ke3RoaXMubm9ybWFsLm1hcHBpbmcudG9VcHBlckNhc2UoKX1gXSA9IHRydWU7XG4gICAgICAgICAgICBzdHlsZS50ZXhjb29yZHMgPSBzdHlsZS50ZXhjb29yZHMgfHwgKHRoaXMubm9ybWFsLm1hcHBpbmcgPT09ICd1dicpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGUucmVwbGFjZVNoYWRlckJsb2NrKE1hdGVyaWFsLmJsb2NrLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL21hdGVyaWFsJ10sICdNYXRlcmlhbCcpO1xuICAgICAgICBzdHlsZS5hZGRTaGFkZXJCbG9jaygnc2V0dXAnLCAnXFxubWF0ZXJpYWwgPSB1X21hdGVyaWFsO1xcbicsICdNYXRlcmlhbCcpO1xuICAgIH1cblxuICAgIHNldHVwUHJvZ3JhbSAoX3Byb2dyYW0pIHtcbiAgICAgICAgLy8gRm9yIGVhY2ggcHJvcGVydHksIHNldHMgdW5pZm9ybXMgaW4gdGhlIHBhdHRlcm46XG4gICAgICAgIC8vIHVfbWF0ZXJpYWwuZGlmZnVzZSwgdV9tYXRlcmlhbC5kaWZmdXNlU2NhbGUgdV9tYXRlcmlhbF9kaWZmdXNlX3RleHR1cmVcbiAgICAgICAgZm9yIChsZXQgcHJvcCBvZiBbJ2VtaXNzaW9uJywgJ2FtYmllbnQnLCAnZGlmZnVzZScsICdzcGVjdWxhciddKSB7XG4gICAgICAgICAgICBpZiAodGhpc1twcm9wXSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW3Byb3BdLnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3Byb2dyYW0uc2V0VGV4dHVyZVVuaWZvcm0oYHVfbWF0ZXJpYWxfJHtwcm9wfV90ZXh0dXJlYCwgdGhpc1twcm9wXS50ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnM2Z2JywgYHVfbWF0ZXJpYWwuJHtwcm9wfVNjYWxlYCwgdGhpc1twcm9wXS5zY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzRmdicsIGB1X21hdGVyaWFsLiR7cHJvcH1gLCB0aGlzW3Byb3BdLmFtb3VudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzW3Byb3BdLmFtb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCc0ZnYnLCBgdV9tYXRlcmlhbC4ke3Byb3B9YCwgdGhpc1twcm9wXS5hbW91bnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4dHJhIHNwZWN1bGFyIHByb3BzXG4gICAgICAgIGlmICh0aGlzLnNwZWN1bGFyKSB7XG4gICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCcxZicsICd1X21hdGVyaWFsLnNoaW5pbmVzcycsIHRoaXMuc3BlY3VsYXIuc2hpbmluZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vcm1hbCBtYXBwaW5nXG4gICAgICAgIGlmICh0aGlzLm5vcm1hbCAmJiB0aGlzLm5vcm1hbC50ZXh0dXJlKSB7XG4gICAgICAgICAgICBfcHJvZ3JhbS5zZXRUZXh0dXJlVW5pZm9ybSgndV9tYXRlcmlhbF9ub3JtYWxfdGV4dHVyZScsIHRoaXMubm9ybWFsLnRleHR1cmUpO1xuICAgICAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnM2Z2JywgJ3VfbWF0ZXJpYWwubm9ybWFsU2NhbGUnLCB0aGlzLm5vcm1hbC5zY2FsZSk7XG4gICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCcxZicsICd1X21hdGVyaWFsLm5vcm1hbEFtb3VudCcsIHRoaXMubm9ybWFsLmFtb3VudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk1hdGVyaWFsLmJsb2NrID0gJ21hdGVyaWFsJztcbiIsIi8qanNoaW50IHdvcmtlcjogdHJ1ZSovXG5cbi8vIE1vZHVsZXMgYW5kIGRlcGVuZGVuY2llcyB0byBleHBvc2UgaW4gdGhlIHB1YmxpYyBUYW5ncmFtIG1vZHVsZVxuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMvdXRpbHMnO1xuXG4vLyBUaGUgbGVhZmxldCBsYXllciBwbHVnaW4gaXMgY3VycmVudGx5IHRoZSBwcmltYXJ5IHB1YmxpYyBBUElcbmltcG9ydCB7bGVhZmxldExheWVyfSBmcm9tICcuL2xlYWZsZXRfbGF5ZXInO1xuXG4vLyBUaGUgc2NlbmUgd29ya2VyIGlzIG9ubHkgYWN0aXZhdGVkIHdoZW4gYSB3b3JrZXIgdGhyZWFkIGlzIGluc3RhbnRpYXRlZCwgYnV0IG11c3QgYWx3YXlzIGJlIGxvYWRlZFxuaW1wb3J0IFNjZW5lIGZyb20gJy4vc2NlbmUnO1xuaW1wb3J0IHtTY2VuZVdvcmtlcn0gZnJvbSAnLi9zY2VuZV93b3JrZXInO1xuXG4vLyBBZGRpdGlvbmFsIG1vZHVsZXMgYXJlIGV4cG9zZWQgZm9yIGRlYnVnZ2luZ1xuaW1wb3J0IHZlcnNpb24gZnJvbSAnLi91dGlscy92ZXJzaW9uJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IEdlbyBmcm9tICcuL2dlbyc7XG5pbXBvcnQgRGF0YVNvdXJjZSBmcm9tICcuL3NvdXJjZXMvZGF0YV9zb3VyY2UnO1xuaW1wb3J0ICcuL3NvdXJjZXMvZ2VvanNvbic7XG5pbXBvcnQgJy4vc291cmNlcy90b3BvanNvbic7XG5pbXBvcnQgJy4vc291cmNlcy9tdnQnO1xuaW1wb3J0IFRpbGVNYW5hZ2VyIGZyb20gJy4vdGlsZV9tYW5hZ2VyJztcbmltcG9ydCBHTFNMIGZyb20gJy4vZ2wvZ2xzbCc7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tICcuL2dsL3NoYWRlcl9wcm9ncmFtJztcbmltcG9ydCBWZXJ0ZXhEYXRhIGZyb20gJy4vZ2wvdmVydGV4X2RhdGEnO1xuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi9nbC90ZXh0dXJlJztcbmltcG9ydCBNYXRlcmlhbCBmcm9tICcuL21hdGVyaWFsJztcbmltcG9ydCBMaWdodCBmcm9tICcuL2xpZ2h0JztcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi91dGlscy93b3JrZXJfYnJva2VyJztcbmltcG9ydCB7cnVsZUNhY2hlfSBmcm9tICcuL3N0eWxlcy9ydWxlJztcbmltcG9ydCB7U3R5bGVNYW5hZ2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9tYW5hZ2VyJztcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX3BhcnNlcic7XG5pbXBvcnQgQ29sbGlzaW9uIGZyb20gJy4vbGFiZWxzL2NvbGxpc2lvbic7XG5pbXBvcnQgRmVhdHVyZVNlbGVjdGlvbiBmcm9tICcuL3NlbGVjdGlvbic7XG5cbmltcG9ydCB5YW1sIGZyb20gJ2pzLXlhbWwnO1xuXG4vLyBNYWtlIHNvbWUgbW9kdWxlcyBhY2Nlc3NpYmxlIGZvciBkZWJ1Z2dpbmdcbnZhciBkZWJ1ZyA9IHtcbiAgICBsb2csXG4gICAgeWFtbCxcbiAgICBVdGlscyxcbiAgICBHZW8sXG4gICAgRGF0YVNvdXJjZSxcbiAgICBUaWxlTWFuYWdlcixcbiAgICBHTFNMLFxuICAgIFNoYWRlclByb2dyYW0sXG4gICAgVmVydGV4RGF0YSxcbiAgICBUZXh0dXJlLFxuICAgIE1hdGVyaWFsLFxuICAgIExpZ2h0LFxuICAgIFNjZW5lLFxuICAgIFNjZW5lV29ya2VyLFxuICAgIFdvcmtlckJyb2tlcixcbiAgICBydWxlQ2FjaGUsXG4gICAgU3R5bGVNYW5hZ2VyLFxuICAgIFN0eWxlUGFyc2VyLFxuICAgIENvbGxpc2lvbixcbiAgICBGZWF0dXJlU2VsZWN0aW9uXG59O1xuXG4vLyBXaW5kb3cgY2FuIG9ubHkgYmUgc2V0IGluIG1haW4gdGhyZWFkXG5pZiAoVXRpbHMuaXNNYWluVGhyZWFkKSB7XG5cbiAgICB3aW5kb3cuVGFuZ3JhbSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBsZWFmbGV0TGF5ZXIsXG4gICAgICAgIGRlYnVnLFxuICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLnN0cmluZ1xuICAgIH07XG5cbn1cblxuaWYgKFV0aWxzLmlzV29ya2VyVGhyZWFkKSB7XG4gICAgc2VsZi5UYW5ncmFtID0ge1xuICAgICAgICBkZWJ1ZyxcbiAgICAgICAgdmVyc2lvbjogdmVyc2lvbi5zdHJpbmdcbiAgICB9O1xufVxuXG5pZiAoVXRpbHMuaXNNYWluVGhyZWFkKSB7XG4gICAgVXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lUG9seWZpbGwoKTtcbn1cblxuLy8gU2V0dXAgbG9nZ2luZyB0byBwcmVmaXggd2l0aCBUYW5ncmFtIHZlcnNpb25cbnZhciBvcmlnaW5hbEZhY3RvcnkgPSBsb2cubWV0aG9kRmFjdG9yeTtcbmxvZy5tZXRob2RGYWN0b3J5ID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGxvZ0xldmVsKSB7XG4gICAgdmFyIHJhd01ldGhvZCA9IG9yaWdpbmFsRmFjdG9yeShtZXRob2ROYW1lLCBsb2dMZXZlbCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5tZXNzYWdlKSB7XG4gICAgICAgIHJhd01ldGhvZChgVGFuZ3JhbSAke3ZlcnNpb24uc3RyaW5nfTpgLCAuLi5tZXNzYWdlKTtcbiAgICB9O1xufTtcbiIsImltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzL3V0aWxzJztcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi91dGlscy93b3JrZXJfYnJva2VyJztcbmltcG9ydCBzdWJzY3JpYmVNaXhpbiBmcm9tICcuL3V0aWxzL3N1YnNjcmliZSc7XG5pbXBvcnQgQ29udGV4dCBmcm9tICcuL2dsL2NvbnRleHQnO1xuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi9nbC90ZXh0dXJlJztcbmltcG9ydCBWZXJ0ZXhBcnJheU9iamVjdCBmcm9tICcuL2dsL3Zhbyc7XG5pbXBvcnQge1N0eWxlfSBmcm9tICcuL3N0eWxlcy9zdHlsZSc7XG5pbXBvcnQge1N0eWxlTWFuYWdlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfbWFuYWdlcic7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IFNjZW5lTG9hZGVyIGZyb20gJy4vc2NlbmVfbG9hZGVyJztcbmltcG9ydCBWaWV3IGZyb20gJy4vdmlldyc7XG5pbXBvcnQgTGlnaHQgZnJvbSAnLi9saWdodCc7XG5pbXBvcnQgVGlsZU1hbmFnZXIgZnJvbSAnLi90aWxlX21hbmFnZXInO1xuaW1wb3J0IERhdGFTb3VyY2UgZnJvbSAnLi9zb3VyY2VzL2RhdGFfc291cmNlJztcbmltcG9ydCBGZWF0dXJlU2VsZWN0aW9uIGZyb20gJy4vc2VsZWN0aW9uJztcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuL2dsL3JlbmRlcl9zdGF0ZSc7XG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5pbXBvcnQge1BvbHlnb25zfSBmcm9tICcuL3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29ucyc7XG5pbXBvcnQge0xpbmVzfSBmcm9tICcuL3N0eWxlcy9saW5lcy9saW5lcyc7XG5pbXBvcnQge1BvaW50c30gZnJvbSAnLi9zdHlsZXMvcG9pbnRzL3BvaW50cyc7XG5pbXBvcnQge1RleHRTdHlsZX0gZnJvbSAnLi9zdHlsZXMvdGV4dC90ZXh0JztcblxuLy8gQWRkIGJ1aWx0LWluIHJlbmRlcmluZyBzdHlsZXNcblN0eWxlTWFuYWdlci5yZWdpc3RlcihQb2x5Z29ucyk7XG5TdHlsZU1hbmFnZXIucmVnaXN0ZXIoTGluZXMpO1xuU3R5bGVNYW5hZ2VyLnJlZ2lzdGVyKFBvaW50cyk7XG5TdHlsZU1hbmFnZXIucmVnaXN0ZXIoVGV4dFN0eWxlKTtcblxuLy8gTG9hZCBzY2VuZSBkZWZpbml0aW9uOiBwYXNzIGFuIG9iamVjdCBkaXJlY3RseSwgb3IgYSBVUkwgYXMgc3RyaW5nIHRvIGxvYWQgcmVtb3RlbHlcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5lIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ19zb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHN1YnNjcmliZU1peGluKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXppbmcgPSBudWxsOyAvLyB3aWxsIGJlIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gc2NlbmUgaXMgbG9hZGVkXG4gICAgICAgIHRoaXMuc291cmNlcyA9IHt9O1xuXG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBWaWV3KHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnRpbGVfbWFuYWdlciA9IFRpbGVNYW5hZ2VyO1xuICAgICAgICB0aGlzLnRpbGVfbWFuYWdlci5pbml0KHsgc2NlbmU6IHRoaXMsIHZpZXc6IHRoaXMudmlldyB9KTtcbiAgICAgICAgdGhpcy5udW1fd29ya2VycyA9IG9wdGlvbnMubnVtV29ya2VycyB8fCAyO1xuICAgICAgICB0aGlzLmFsbG93X2Nyb3NzX2RvbWFpbl93b3JrZXJzID0gKG9wdGlvbnMuYWxsb3dDcm9zc0RvbWFpbldvcmtlcnMgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlKTtcbiAgICAgICAgdGhpcy53b3JrZXJfdXJsID0gb3B0aW9ucy53b3JrZXJVcmw7XG4gICAgICAgIGlmIChvcHRpb25zLmRpc2FibGVWZXJ0ZXhBcnJheU9iamVjdHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIFZlcnRleEFycmF5T2JqZWN0LmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIFV0aWxzLnVzZV9oaWdoX2RlbnNpdHlfZGlzcGxheSA9IG9wdGlvbnMuaGlnaERlbnNpdHlEaXNwbGF5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmhpZ2hEZW5zaXR5RGlzcGxheSA6IHRydWU7XG4gICAgICAgIFV0aWxzLnVwZGF0ZURldmljZVBpeGVsUmF0aW8oKTtcblxuICAgICAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMuY29uZmlnX3NvdXJjZSA9IGNvbmZpZ19zb3VyY2U7XG4gICAgICAgIHRoaXMuY29uZmlnX3NlcmlhbGl6ZWQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RfdmFsaWRfY29uZmlnX3NvdXJjZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5zdHlsZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGl2ZV9zdHlsZXMgPSB7fTtcblxuICAgICAgICB0aGlzLmJ1aWxkaW5nID0gbnVsbDsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmFja3MgY3VycmVudCBzY2VuZSBidWlsZGluZyBzdGF0ZSAodGlsZXMgYmVpbmcgYnVpbHQsIGV0Yy4pXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgYSByZWRyYXdcbiAgICAgICAgdGhpcy5hbmltYXRlZCA9IGZhbHNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWVzdCByZWRyYXcgZXZlcnkgZnJhbWVcbiAgICAgICAgdGhpcy5wcmVVcGRhdGUgPSBvcHRpb25zLnByZVVwZGF0ZTsgICAgICAgICAgICAgLy8gb3B0aW9uYWwgcHJlLXJlbmRlciBsb29wIGhvb2tcbiAgICAgICAgdGhpcy5wb3N0VXBkYXRlID0gb3B0aW9ucy5wb3N0VXBkYXRlOyAgICAgICAgICAgLy8gb3B0aW9uYWwgcG9zdC1yZW5kZXIgbG9vcCBob29rXG4gICAgICAgIHRoaXMucmVuZGVyX2xvb3AgPSAhb3B0aW9ucy5kaXNhYmxlUmVuZGVyTG9vcDsgIC8vIGRpc2FibGUgcmVuZGVyIGxvb3AgLSBhcHAgd2lsbCBoYXZlIHRvIG1hbnVhbGx5IGNhbGwgU2NlbmUucmVuZGVyKCkgcGVyIGZyYW1lXG4gICAgICAgIHRoaXMucmVuZGVyX2xvb3BfYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVuZGVyX2xvb3Bfc3RvcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbmRlcl9jb3VudCA9IDA7XG4gICAgICAgIHRoaXMubGFzdF9yZW5kZXJfY291bnQgPSAwO1xuICAgICAgICB0aGlzLnJlbmRlcl9jb3VudF9jaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZnJhbWUgPSAwO1xuICAgICAgICB0aGlzLnF1ZXVlX3NjcmVlbnNob3QgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzZXRUaW1lKCk7XG5cbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcjtcblxuICAgICAgICB0aGlzLmxpZ2h0cyA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG51bGw7XG5cbiAgICAgICAgLy8gTGlzdGVuIHRvIHJlbGF0ZWQgb2JqZWN0c1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIHZpZXc6IHtcbiAgICAgICAgICAgICAgICBtb3ZlOiAoKSA9PiB0aGlzLnRyaWdnZXIoJ21vdmUnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnZpZXcuc3Vic2NyaWJlKHRoaXMubGlzdGVuZXJzLnZpZXcpO1xuXG4gICAgICAgIHRoaXMudXBkYXRpbmcgPSAwO1xuICAgICAgICB0aGlzLmdlbmVyYXRpb24gPSAwOyAvLyBhbiBpZCB0aGF0IGlzIGluY3JlbWVudGVkIGVhY2ggdGltZSB0aGUgc2NlbmUgY29uZmlnIGlzIGludmFsaWRhdGVkXG4gICAgICAgIHRoaXMubGFzdF9jb21wbGV0ZV9nZW5lcmF0aW9uID0gMDsgLy8gbGFzdCBnZW5lcmF0aW9uIGlkIHdpdGggYSBjb21wbGV0ZSB2aWV3XG4gICAgICAgIHRoaXMuc2V0dXBEZWJ1ZygpO1xuXG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPSBvcHRpb25zLmxvZ0xldmVsIHx8ICd3YXJuJztcbiAgICAgICAgbG9nLnNldExldmVsKHRoaXMubG9nTGV2ZWwpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGUgKGNvbmZpZywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NlbmUoY29uZmlnLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBMb2FkIChvciByZWxvYWQpIHNjZW5lIGNvbmZpZ1xuICAgIC8vIE9wdGlvbmFsbHkgc3BlY2lmeSBuZXcgc2NlbmUgZmlsZSBVUkxcbiAgICBsb2FkKGNvbmZpZ19zb3VyY2UgPSBudWxsLCBjb25maWdfcGF0aCA9IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsaXppbmc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0aW5nKys7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBMb2FkIHNjZW5lIGRlZmluaXRpb24gKHNvdXJjZXMsIHN0eWxlcywgZXRjLiksIHRoZW4gY3JlYXRlIHN0eWxlcyAmIHdvcmtlcnNcbiAgICAgICAgdGhpcy5pbml0aWFsaXppbmcgPSB0aGlzLmxvYWRTY2VuZShjb25maWdfc291cmNlLCBjb25maWdfcGF0aClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuY3JlYXRlV29ya2VycygpKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlQ2FudmFzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEZlYXR1cmVTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnMudGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy50ZXh0dXJlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiAoKSA9PiB0aGlzLmRpcnR5ID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmc6IChkYXRhKSA9PiB0aGlzLnRyaWdnZXIoJ3dhcm5pbmcnLCBPYmplY3QuYXNzaWduKHsgdHlwZTogJ3RleHR1cmVzJyB9LCBkYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgVGV4dHVyZS5zdWJzY3JpYmUodGhpcy5saXN0ZW5lcnMudGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gT25seSByZXRhaW4gdmlzaWJsZSB0aWxlcyBmb3IgcmVidWlsZGluZ1xuICAgICAgICAgICAgICAgIHRoaXMudGlsZV9tYW5hZ2VyLnBydW5lVG9WaXNpYmxlVGlsZXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVDb25maWcoeyByZWJ1aWxkOiB0cnVlIH0pO1xuICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGluZy0tO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6aW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RfdmFsaWRfY29uZmlnX3NvdXJjZSA9IHRoaXMuY29uZmlnX3NvdXJjZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RfdmFsaWRfY29uZmlnX3BhdGggPSB0aGlzLmNvbmZpZ19wYXRoO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyX2xvb3AgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBSZW5kZXJMb29wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFJlZHJhdygpO1xuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemluZyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnVwZGF0aW5nID0gMDtcblxuICAgICAgICAgICAgLy8gUmVwb3J0IGFuZCByZXZlcnQgdG8gbGFzdCB2YWxpZCBjb25maWcgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBsZXQgdHlwZSwgbWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnWUFNTEV4Y2VwdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3lhbWwnO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAnRXJyb3IgcGFyc2luZyBzY2VuZSBZQU1MJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IG1vcmUgZXJyb3IgdHlwZXNcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gJ0Vycm9yIGluaXRpYWxpemluZyBzY2VuZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJywgeyB0eXBlLCBtZXNzYWdlLCBlcnJvciwgdXJsOiB0aGlzLmNvbmZpZ19zb3VyY2UgfSk7XG5cbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgU2NlbmUubG9hZCgpIGZhaWxlZCB0byBsb2FkICR7dGhpcy5jb25maWdfc291cmNlfTogJHtlcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0X3ZhbGlkX2NvbmZpZ19zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBsb2cud2FybihtZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oYFNjZW5lLmxvYWQoKSByZXZlcnRpbmcgdG8gbGFzdCB2YWxpZCBjb25maWd1cmF0aW9uYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZCh0aGlzLmxhc3RfdmFsaWRfY29uZmlnX3NvdXJjZSwgdGhpcy5sYXN0X3ZhbGlkX2NvbmZpZ19wYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZy5lcnJvcihtZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6aW5nO1xuICAgIH1cblxuICAgIC8vIEZvciBBUEkgY29tcGF0aWJpbGl0eVxuICAgIHJlbG9hZChjb25maWdfc291cmNlID0gbnVsbCwgY29uZmlnX3BhdGggPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWQoY29uZmlnX3NvdXJjZSwgY29uZmlnX3BhdGgpO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW5kZXJfbG9vcF9zdG9wID0gdHJ1ZTsgLy8gc2NoZWR1bGUgcmVuZGVyIGxvb3AgdG8gc3RvcFxuXG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVBbGwoKTsgLy8gY2xlYXIgYWxsIGV2ZW50IGxpc3RlbmVyc1xuXG4gICAgICAgIHRoaXMudmlldy51bnN1YnNjcmliZSh0aGlzLmxpc3RlbmVycy52aWV3KTtcbiAgICAgICAgVGV4dHVyZS51bnN1YnNjcmliZSh0aGlzLmxpc3RlbmVycy50ZXh0dXJlKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5nbCkge1xuICAgICAgICAgICAgVGV4dHVyZS5kZXN0cm95KHRoaXMuZ2wpO1xuICAgICAgICAgICAgU3R5bGVNYW5hZ2VyLmRlc3Ryb3kodGhpcy5nbCk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHt9O1xuXG4gICAgICAgICAgICB0aGlzLmdsID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc291cmNlcyA9IHt9O1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMud29ya2VycykpIHtcbiAgICAgICAgICAgIHRoaXMud29ya2Vycy5mb3JFYWNoKCh3b3JrZXIpID0+IHtcbiAgICAgICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMud29ya2VycyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRpbGVfbWFuYWdlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2FudmFzKCkge1xuICAgICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5jb250YWluZXIgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS50b3AgPSAwO1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5sZWZ0ID0gMDtcblxuICAgICAgICAvLyBGb3JjZSB0YW5ncmFtIGNhbnZhcyB1bmRlcm5lYXRoIGFsbCBsZWFmbGV0IGxheWVycywgYW5kIHNldCBiYWNrZ3JvdW5kIHRvIHRyYW5zcGFyZW50XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5nbCA9IENvbnRleHQuZ2V0Q29udGV4dCh0aGlzLmNhbnZhcywge1xuICAgICAgICAgICAgICAgIGFscGhhOiB0cnVlLCBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUsIC8vIFRPRE86IHZhcnkgdy9zY2VuZSBhbHBoYVxuICAgICAgICAgICAgICAgIGRldmljZV9waXhlbF9yYXRpbzogVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDb3VsZG4ndCBjcmVhdGUgV2ViR0wgY29udGV4dC4gXCIgK1xuICAgICAgICAgICAgICAgIFwiWW91ciBicm93c2VyIG1heSBub3Qgc3VwcG9ydCBXZWJHTCwgb3IgaXQncyB0dXJuZWQgb2ZmPyBcIiArXG4gICAgICAgICAgICAgICAgXCJWaXNpdCBodHRwOi8vd2ViZ2xyZXBvcnQuY29tLyBmb3IgbW9yZSBpbmZvLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNpemVNYXAodGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgsIHRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodCk7XG4gICAgICAgIFZlcnRleEFycmF5T2JqZWN0LmluaXQodGhpcy5nbCk7XG4gICAgICAgIFJlbmRlclN0YXRlLmluaXRpYWxpemUodGhpcy5nbCk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBVUkwgdG8gbG9hZCB0aGUgd2ViIHdvcmtlciBmcm9tXG4gICAgZ2V0V29ya2VyVXJsKCkge1xuICAgICAgICBsZXQgd29ya2VyX3VybCA9IHRoaXMud29ya2VyX3VybCB8fCBVdGlscy5maW5kQ3VycmVudFVSTCgndGFuZ3JhbS5kZWJ1Zy5qcycsICd0YW5ncmFtLm1pbi5qcycpO1xuXG4gICAgICAgIGlmICghd29ya2VyX3VybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgbG9hZCB3b3JrZXIgYmVjYXVzZSBjb3VsZG4ndCBmaW5kIGJhc2UgVVJMIHRoYXQgbGlicmFyeSB3YXMgbG9hZGVkIGZyb21cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbGxvd19jcm9zc19kb21haW5fd29ya2Vycykge1xuICAgICAgICAgICAgbGV0IGJvZHkgPSBgaW1wb3J0U2NyaXB0cygnJHt3b3JrZXJfdXJsfScpO2A7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtib2R5XSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JrZXJfdXJsO1xuICAgIH1cblxuICAgIC8vIFdlYiB3b3JrZXJzIGhhbmRsZSBoZWF2eSBkdXR5IHRpbGUgY29uc3RydWN0aW9uOiBuZXR3b3JraW5nLCBnZW9tZXRyeSBwcm9jZXNzaW5nLCBldGMuXG4gICAgY3JlYXRlV29ya2VycygpIHtcbiAgICAgICAgaWYgKCF0aGlzLndvcmtlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VXb3JrZXJzKHRoaXMuZ2V0V29ya2VyVXJsKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICAvLyBJbnN0YW50aWF0ZSB3b3JrZXJzIGZyb20gVVJMLCBpbml0IGV2ZW50IGhhbmRsZXJzXG4gICAgbWFrZVdvcmtlcnModXJsKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuXG4gICAgICAgIHRoaXMud29ya2VycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpZD0wOyBpZCA8IHRoaXMubnVtX3dvcmtlcnM7IGlkKyspIHtcbiAgICAgICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKHVybCk7XG4gICAgICAgICAgICB0aGlzLndvcmtlcnNbaWRdID0gd29ya2VyO1xuXG4gICAgICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMud29ya2VyTG9nTWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIFdvcmtlckJyb2tlci5hZGRXb3JrZXIod29ya2VyKTtcblxuICAgICAgICAgICAgbG9nLmRlYnVnKGBTY2VuZS5tYWtlV29ya2VyczogaW5pdGlhbGl6aW5nIHdvcmtlciAke2lkfWApO1xuICAgICAgICAgICAgbGV0IF9pZCA9IGlkO1xuICAgICAgICAgICAgcXVldWUucHVzaChXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2Uod29ya2VyLCAnc2VsZi5pbml0JywgaWQsIHRoaXMubnVtX3dvcmtlcnMsIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbykudGhlbihcbiAgICAgICAgICAgICAgICAoaWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKGBTY2VuZS5tYWtlV29ya2VyczogaW5pdGlhbGl6ZWQgd29ya2VyICR7aWR9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsb2cuZXJyb3IoYFNjZW5lLm1ha2VXb3JrZXJzOiBmYWlsZWQgdG8gaW5pdGlhbGl6ZSB3b3JrZXIgJHtfaWR9OmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmV4dF93b3JrZXIgPSAwO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocXVldWUpO1xuICAgIH1cblxuICAgIC8vIFJvdW5kIHJvYmluIHNlbGVjdGlvbiBvZiBuZXh0IHdvcmtlclxuICAgIG5leHRXb3JrZXIoKSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSB0aGlzLndvcmtlcnNbdGhpcy5uZXh0X3dvcmtlcl07XG4gICAgICAgIHRoaXMubmV4dF93b3JrZXIgPSAodGhpcy5uZXh0X3dvcmtlciArIDEpICUgdGhpcy53b3JrZXJzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9XG5cbiAgICAvLyBTY2VuZSBpcyByZWFkeSBmb3IgcmVuZGVyaW5nXG4gICAgcmVhZHkoKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3LnJlYWR5KCkgfHwgT2JqZWN0LmtleXModGhpcy5zb3VyY2VzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gUmVzaXplIHRoZSBtYXAgd2hlbiBkZXZpY2UgcGl4ZWwgcmF0aW8gY2hhbmdlcywgZS5nLiB3aGVuIHN3aXRjaGluZyBiZXR3ZWVuIGRpc3BsYXlzXG4gICAgdXBkYXRlRGV2aWNlUGl4ZWxSYXRpbyAoKSB7XG4gICAgICAgIGlmIChVdGlscy51cGRhdGVEZXZpY2VQaXhlbFJhdGlvKCkpIHtcbiAgICAgICAgICAgIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSh0aGlzLndvcmtlcnMsICdzZWxmLnVwZGF0ZURldmljZVBpeGVsUmF0aW8nLCBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8pXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5yZWJ1aWxkKCkpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5yZXNpemVNYXAodGhpcy52aWV3LnNpemUuY3NzLndpZHRoLCB0aGlzLnZpZXcuc2l6ZS5jc3MuaGVpZ2h0KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNpemVNYXAod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnZpZXcuc2V0Vmlld3BvcnRTaXplKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSB0aGlzLnZpZXcuc2l6ZS5jc3Mud2lkdGggKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gdGhpcy52aWV3LnNpemUuY3NzLmhlaWdodCArICdweCc7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMudmlldy5zaXplLmRldmljZS53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMudmlldy5zaXplLmRldmljZS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmdsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5nbC52aWV3cG9ydCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlcXVlc3Qgc2NlbmUgYmUgcmVkcmF3biBhdCBuZXh0IGFuaW1hdGlvbiBsb29wXG4gICAgcmVxdWVzdFJlZHJhdygpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gUmVkcmF3IHNjZW5lIGltbWVkaWF0ZWx5IC0gZG9uJ3Qgd2FpdCBmb3IgYW5pbWF0aW9uIGxvb3BcbiAgICAvLyBVc2Ugc3BhcmluZ2x5LCBidXQgZm9yIGNhc2VzIHdoZXJlIHlvdSBuZWVkIHRoZSBjbG9zZXN0IHBvc3NpYmxlIHN5bmMgd2l0aCBvdGhlciBVSSBlbGVtZW50cyxcbiAgICAvLyBzdWNoIGFzIG90aGVyLCBub24tV2ViR0wgbWFwIGxheWVycyAoZS5nLiBMZWFmbGV0IHJhc3RlciBsYXllcnMsIG1hcmtlcnMsIGV0Yy4pXG4gICAgaW1tZWRpYXRlUmVkcmF3KCkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICByZW5kZXJMb29wICgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJfbG9vcF9hY3RpdmUgPSB0cnVlOyAvLyBvbmx5IGxldCB0aGUgcmVuZGVyIGxvb3AgaW5zdGFudGlhdGUgb25jZVxuXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAvLyBSZW5kZXIgdGhlIHNjZW5lXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVxdWVzdCB0aGUgbmV4dCBmcmFtZSBpZiBub3Qgc2NoZWR1bGVkIHRvIHN0b3BcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcl9sb29wX3N0b3ApIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXJMb29wLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJfbG9vcF9zdG9wID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcl9sb29wX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0dXAgdGhlIHJlbmRlciBsb29wXG4gICAgc2V0dXBSZW5kZXJMb29wKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVuZGVyX2xvb3BfYWN0aXZlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5yZW5kZXJMb29wKCk7IH0sIDApOyAvLyBkZWxheSBzdGFydCBieSBvbmUgdGlja1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICAvLyBSZW5kZXIgb24gZGVtYW5kXG4gICAgICAgIHZhciB3aWxsX3JlbmRlciA9ICEoXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgIHRoaXMudXBkYXRpbmcgPiAwIHx8XG4gICAgICAgICAgICB0aGlzLnJlYWR5KCkgPT09IGZhbHNlXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUHJlLXJlbmRlciBsb29wIGhvb2tcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5wcmVVcGRhdGUod2lsbF9yZW5kZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmFpbCBpZiBubyBuZWVkIHRvIHJlbmRlclxuICAgICAgICBpZiAoIXdpbGxfcmVuZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlOyAvLyBzdWJjbGFzc2VzIGNhbiBzZXQgdGhpcyBiYWNrIHRvIHRydWUgd2hlbiBhbmltYXRpb24gaXMgbmVlZGVkXG5cbiAgICAgICAgLy8gUmVuZGVyIHRoZSBzY2VuZVxuICAgICAgICB0aGlzLnVwZGF0ZURldmljZVBpeGVsUmF0aW8oKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5jb21wbGV0ZVNjcmVlbnNob3QoKTsgLy8gY29tcGxldGVzIHNjcmVlbnNob3QgY2FwdHVyZSBpZiByZXF1ZXN0ZWRcbiAgICAgICAgdGhpcy51cGRhdGVWaWV3Q29tcGxldGUoKTsgLy8gZmlyZXMgZXZlbnQgd2hlbiByZW5kZXJlZCB0aWxlIHNldCBvciBzdHlsZSBjaGFuZ2VzXG5cbiAgICAgICAgLy8gUG9zdC1yZW5kZXIgbG9vcCBob29rXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wb3N0VXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnBvc3RVcGRhdGUod2lsbF9yZW5kZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVkcmF3IGV2ZXJ5IGZyYW1lIGlmIGFuaW1hdGluZ1xuICAgICAgICBpZiAodGhpcy5hbmltYXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZyYW1lKys7XG4gICAgICAgIGxvZy50cmFjZSgnU2NlbmUucmVuZGVyKCknKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMsIGNhbWVyYSwgbGlnaHRzXG4gICAgICAgIHRoaXMudmlldy51cGRhdGUoKTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5hY3RpdmVfc3R5bGVzKS5mb3JFYWNoKGkgPT4gdGhpcy5zdHlsZXNbaV0udXBkYXRlKCkpO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmxpZ2h0cykuZm9yRWFjaChpID0+IHRoaXMubGlnaHRzW2ldLnVwZGF0ZSgpKTtcblxuICAgICAgICAvLyBSZW5kZXJhYmxlIHRpbGUgbGlzdFxuICAgICAgICB0aGlzLnJlbmRlcmFibGVfdGlsZXMgPSB0aGlzLnRpbGVfbWFuYWdlci5nZXRSZW5kZXJhYmxlVGlsZXMoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJhYmxlX3RpbGVzX2NvdW50ID0gdGhpcy5yZW5kZXJhYmxlX3RpbGVzLmxlbmd0aDtcblxuICAgICAgICAvLyBSZW5kZXIgbWFpbiBwYXNzXG4gICAgICAgIHRoaXMucmVuZGVyX2NvdW50ID0gdGhpcy5yZW5kZXJQYXNzKCk7XG5cbiAgICAgICAgLy8gUmVuZGVyIHNlbGVjdGlvbiBwYXNzIChpZiBuZWVkZWQpXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5wZW5kaW5nUmVxdWVzdHMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlldy5wYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uY2xlYXJQZW5kaW5nUmVxdWVzdHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmJpbmQoKTsgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggdG8gRkJPXG4gICAgICAgICAgICB0aGlzLnJlbmRlclBhc3MoXG4gICAgICAgICAgICAgICAgJ3NlbGVjdGlvbl9wcm9ncmFtJywgICAgICAgICAgICAgICAgLy8gcmVuZGVyIHcvYWx0ZXJuYXRlIHByb2dyYW1cbiAgICAgICAgICAgICAgICB7IGFsbG93X2JsZW5kOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnJlYWQoKTsgICAgICAgICAgICAgICAgICAvLyByZWFkIHJlc3VsdHMgZnJvbSBzZWxlY3Rpb24gYnVmZmVyXG5cbiAgICAgICAgICAgIC8vIFJlc2V0IHRvIHNjcmVlbiBidWZmZXJcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVuZGVyX2NvdW50X2NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyX2NvdW50ICE9PSB0aGlzLmxhc3RfcmVuZGVyX2NvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcl9jb3VudF9jaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5nZXRGZWF0dXJlU2VsZWN0aW9uTWFwU2l6ZSgpLnRoZW4oc2l6ZSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oYFNjZW5lOiByZW5kZXJlZCAke3RoaXMucmVuZGVyX2NvdW50fSBwcmltaXRpdmVzICgke3NpemV9IGZlYXR1cmVzIGluIHNlbGVjdGlvbiBtYXApYCk7XG4gICAgICAgICAgICB9LCAoKSA9PiB7fSk7IC8vIG5vIG9wIHdoZW4gcHJvbWlzZSByZWplY3RzIChvbmx5IHByaW50IGxhc3QgcmVzcG9uc2UpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0X3JlbmRlcl9jb3VudCA9IHRoaXMucmVuZGVyX2NvdW50O1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFJlbmRlciBhbGwgYWN0aXZlIHN0eWxlcywgZ3JvdXBlZCBieSBibGVuZC9kZXB0aCB0eXBlIChvcGFxdWUsIG92ZXJsYXksIGV0Yy4pIGFuZCBieSBwcm9ncmFtIChzdHlsZSlcbiAgICAvLyBDYWxsZWQgYm90aCBmb3IgbWFpbiByZW5kZXIgcGFzcywgYW5kIGZvciBzZWNvbmRhcnkgcGFzc2VzIGxpa2Ugc2VsZWN0aW9uIGJ1ZmZlclxuICAgIHJlbmRlclBhc3MocHJvZ3JhbV9rZXkgPSAncHJvZ3JhbScsIHsgYWxsb3dfYmxlbmQgfSA9IHt9KSB7XG4gICAgICAgIC8vIG9wdGlvbmFsbHkgZm9yY2UgYWxwaGEgb2ZmIChlLmcuIGZvciBzZWxlY3Rpb24gcGFzcylcbiAgICAgICAgYWxsb3dfYmxlbmQgPSAoYWxsb3dfYmxlbmQgPT0gbnVsbCkgPyB0cnVlIDogYWxsb3dfYmxlbmQ7XG5cbiAgICAgICAgdGhpcy5jbGVhckZyYW1lKHsgY2xlYXJfY29sb3I6IHRydWUsIGNsZWFyX2RlcHRoOiB0cnVlIH0pO1xuXG4gICAgICAgIC8vIFNvcnQgc3R5bGVzIGJ5IGJsZW5kIG9yZGVyXG4gICAgICAgIGxldCBzdHlsZXMgPSBPYmplY3Qua2V5cyh0aGlzLmFjdGl2ZV9zdHlsZXMpLlxuICAgICAgICAgICAgbWFwKHMgPT4gdGhpcy5zdHlsZXNbc10pLlxuICAgICAgICAgICAgc29ydChTdHlsZS5ibGVuZE9yZGVyU29ydCk7XG5cbiAgICAgICAgLy8gUmVuZGVyIHN0eWxlc1xuICAgICAgICBsZXQgY291bnQgPSAwOyAvLyBob3cgbWFueSBwcmltaXRpdmVzIHdlcmUgcmVuZGVyZWRcbiAgICAgICAgbGV0IGxhc3RfYmxlbmQ7XG4gICAgICAgIGZvciAobGV0IHN0eWxlIG9mIHN0eWxlcykge1xuICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgcmVuZGVyIHN0YXRlIHdoZW4gYmxlbmQgbW9kZSBjaGFuZ2VzXG4gICAgICAgICAgICBpZiAoc3R5bGUuYmxlbmQgIT09IGxhc3RfYmxlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgICAgICAgICAgICAgICBTdHlsZS5yZW5kZXJfc3RhdGVzW3N0eWxlLmJsZW5kXSwgICAgICAgLy8gcmVuZGVyIHN0YXRlIGZvciBibGVuZCBtb2RlXG4gICAgICAgICAgICAgICAgICAgIHsgYmxlbmQ6IChhbGxvd19ibGVuZCAmJiBzdHlsZS5ibGVuZCkgfSAvLyBlbmFibGUvZGlzYWJsZSBibGVuZGluZyAoZS5nLiBubyBibGVuZCBmb3Igc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSZW5kZXJTdGF0ZShzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudCArPSB0aGlzLnJlbmRlclN0eWxlKHN0eWxlLm5hbWUsIHByb2dyYW1fa2V5KTtcbiAgICAgICAgICAgIGxhc3RfYmxlbmQgPSBzdHlsZS5ibGVuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG5cbiAgICByZW5kZXJTdHlsZShzdHlsZSwgcHJvZ3JhbV9rZXkpIHtcbiAgICAgICAgbGV0IGZpcnN0X2Zvcl9zdHlsZSA9IHRydWU7XG4gICAgICAgIGxldCByZW5kZXJfY291bnQgPSAwO1xuXG4gICAgICAgIGxldCBwcm9ncmFtID0gdGhpcy5zdHlsZXNbc3R5bGVdW3Byb2dyYW1fa2V5XTtcbiAgICAgICAgaWYgKCFwcm9ncmFtIHx8ICFwcm9ncmFtLmNvbXBpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbmRlciB0aWxlIEdMIGdlb21ldHJpZXNcbiAgICAgICAgZm9yIChsZXQgdCBpbiB0aGlzLnJlbmRlcmFibGVfdGlsZXMpIHtcbiAgICAgICAgICAgIGxldCB0aWxlID0gdGhpcy5yZW5kZXJhYmxlX3RpbGVzW3RdO1xuXG4gICAgICAgICAgICBpZiAodGlsZS5tZXNoZXNbc3R5bGVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3R5bGUtc3BlY2lmaWMgc3RhdGVcbiAgICAgICAgICAgIC8vIE9ubHkgc2V0dXAgc3R5bGUgaWYgcmVuZGVyaW5nIGZvciBmaXJzdCB0aW1lIHRoaXMgZnJhbWVcbiAgICAgICAgICAgIC8vIChsYXp5IGluaXQsIG5vdCBhbGwgc3R5bGVzIHdpbGwgYmUgdXNlZCBpbiBhbGwgc2NyZWVuIHZpZXdzOyBzb21lIHN0eWxlcyBtaWdodCBiZSBkZWZpbmVkIGJ1dCBuZXZlciB1c2VkKVxuICAgICAgICAgICAgaWYgKGZpcnN0X2Zvcl9zdHlsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGZpcnN0X2Zvcl9zdHlsZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgcHJvZ3JhbS51c2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlc1tzdHlsZV0uc2V0dXAoKTtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGRvbid0IHNldCB1bmlmb3JtcyB3aGVuIHRoZXkgaGF2ZW4ndCBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCcxZicsICd1X3RpbWUnLCB0aGlzLmFuaW1hdGVkID8gKCgoK25ldyBEYXRlKCkpIC0gdGhpcy5zdGFydF90aW1lKSAvIDEwMDApIDogMCk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldHVwUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIHRoaXMubGlnaHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlnaHRzW2ldLnNldHVwUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRpbGUtc3BlY2lmaWMgc3RhdGVcbiAgICAgICAgICAgIHRoaXMudmlldy5zZXR1cFRpbGUodGlsZSwgcHJvZ3JhbSk7XG5cbiAgICAgICAgICAgIC8vIFJlbmRlciB0aWxlXG4gICAgICAgICAgICB0aWxlLm1lc2hlc1tzdHlsZV0ucmVuZGVyKCk7XG4gICAgICAgICAgICByZW5kZXJfY291bnQgKz0gdGlsZS5tZXNoZXNbc3R5bGVdLmdlb21ldHJ5X2NvdW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcl9jb3VudDtcbiAgICB9XG5cbiAgICBjbGVhckZyYW1lKHsgY2xlYXJfY29sb3IsIGNsZWFyX2RlcHRoIH0gPSB7fSkge1xuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHRzXG4gICAgICAgIGNsZWFyX2NvbG9yID0gKGNsZWFyX2NvbG9yID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWU7IC8vIGRlZmF1bHQgdHJ1ZVxuICAgICAgICBjbGVhcl9kZXB0aCA9IChjbGVhcl9kZXB0aCA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlOyAvLyBkZWZhdWx0IHRydWVcblxuICAgICAgICAvLyBSZXNldCBmcmFtZSBzdGF0ZVxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuXG4gICAgICAgIGlmIChjbGVhcl9jb2xvcikge1xuICAgICAgICAgICAgZ2wuY2xlYXJDb2xvciguLi50aGlzLmJhY2tncm91bmQuY29sb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsZWFyX2RlcHRoKSB7XG4gICAgICAgICAgICBnbC5kZXB0aE1hc2sodHJ1ZSk7IC8vIGFsd2F5cyBjbGVhciBkZXB0aCBpZiByZXF1ZXN0ZWQsIGV2ZW4gaWYgZGVwdGggd3JpdGUgd2lsbCBiZSB0dXJuZWQgb2ZmXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xlYXJfY29sb3IgfHwgY2xlYXJfZGVwdGgpIHtcbiAgICAgICAgICAgIGxldCBtYXNrID0gKGNsZWFyX2NvbG9yICYmIGdsLkNPTE9SX0JVRkZFUl9CSVQpIHwgKGNsZWFyX2RlcHRoICYmIGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgZ2wuY2xlYXIobWFzayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRSZW5kZXJTdGF0ZSh7IGRlcHRoX3Rlc3QsIGRlcHRoX3dyaXRlLCBjdWxsX2ZhY2UsIGJsZW5kIH0gPSB7fSkge1xuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHRzXG4gICAgICAgIC8vIFRPRE86IHdoZW4gd2UgYWJzdHJhY3Qgb3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHJlbmRlciBwYXNzZXMsIHRoZXNlIGNhbiBiZSBwZXItcGFzcyBjb25maWcgb3B0aW9uc1xuICAgICAgICBkZXB0aF90ZXN0ID0gKGRlcHRoX3Rlc3QgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZTsgICAgIC8vIGRlZmF1bHQgdHJ1ZVxuICAgICAgICBkZXB0aF93cml0ZSA9IChkZXB0aF93cml0ZSA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlOyAgIC8vIGRlZmF1bHQgdHJ1ZVxuICAgICAgICBjdWxsX2ZhY2UgPSAoY3VsbF9mYWNlID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWU7ICAgICAgIC8vIGRlZmF1bHQgdHJ1ZVxuICAgICAgICBibGVuZCA9IChibGVuZCAhPSBudWxsKSA/IGJsZW5kIDogZmFsc2U7ICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgZmFsc2VcblxuICAgICAgICAvLyBSZXNldCBmcmFtZSBzdGF0ZVxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuXG4gICAgICAgIFJlbmRlclN0YXRlLmRlcHRoX3Rlc3Quc2V0KHsgZGVwdGhfdGVzdDogZGVwdGhfdGVzdCwgZGVwdGhfZnVuYzogZ2wuTEVRVUFMIH0pO1xuICAgICAgICBSZW5kZXJTdGF0ZS5kZXB0aF93cml0ZS5zZXQoeyBkZXB0aF93cml0ZTogZGVwdGhfd3JpdGUgfSk7XG4gICAgICAgIFJlbmRlclN0YXRlLmN1bGxpbmcuc2V0KHsgY3VsbDogY3VsbF9mYWNlLCBmYWNlOiBnbC5CQUNLIH0pO1xuXG4gICAgICAgIC8vIEJsZW5kaW5nIG9mIGFscGhhIGNoYW5uZWwgaXMgbW9kaWZpZWQgdG8gYWNjb3VudCBmb3IgV2ViR0wgYWxwaGEgYmVoYXZpb3IsIHNlZTpcbiAgICAgICAgLy8gaHR0cDovL3dlYmdsZnVuZGFtZW50YWxzLm9yZy93ZWJnbC9sZXNzb25zL3dlYmdsLWFuZC1hbHBoYS5odG1sXG4gICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExNTMzNDE2XG4gICAgICAgIGlmIChibGVuZCkge1xuICAgICAgICAgICAgLy8gT3BhcXVlOiBhbGwgc291cmNlLCBubyBkZXN0aW5hdGlvblxuICAgICAgICAgICAgaWYgKGJsZW5kID09PSAnb3BhcXVlJykge1xuICAgICAgICAgICAgICAgIFJlbmRlclN0YXRlLmJsZW5kaW5nLnNldCh7XG4gICAgICAgICAgICAgICAgICAgIGJsZW5kOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzcmM6IGdsLlNSQ19BTFBIQSwgZHN0OiBnbC5aRVJPXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUcmFkaXRpb25hbCBhbHBoYSBibGVuZGluZ1xuICAgICAgICAgICAgZWxzZSBpZiAoYmxlbmQgPT09ICdvdmVybGF5JyB8fCBibGVuZCA9PT0gJ2lubGF5Jykge1xuICAgICAgICAgICAgICAgIFJlbmRlclN0YXRlLmJsZW5kaW5nLnNldCh7XG4gICAgICAgICAgICAgICAgICAgIGJsZW5kOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzcmM6IGdsLlNSQ19BTFBIQSwgZHN0OiBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLFxuICAgICAgICAgICAgICAgICAgICBzcmNfYWxwaGE6IGdsLk9ORSwgZHN0X2FscGhhOiBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGRpdGl2ZSBibGVuZGluZ1xuICAgICAgICAgICAgZWxzZSBpZiAoYmxlbmQgPT09ICdhZGQnKSB7XG4gICAgICAgICAgICAgICAgUmVuZGVyU3RhdGUuYmxlbmRpbmcuc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgYmxlbmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNyYzogZ2wuT05FLCBkc3Q6IGdsLk9ORSxcbiAgICAgICAgICAgICAgICAgICAgc3JjX2FscGhhOiBnbC5PTkUsIGRzdF9hbHBoYTogZ2wuT05FX01JTlVTX1NSQ19BTFBIQVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTXVsdGlwbGljYXRpdmUgYmxlbmRpbmdcbiAgICAgICAgICAgIGVsc2UgaWYgKGJsZW5kID09PSAnbXVsdGlwbHknKSB7XG4gICAgICAgICAgICAgICAgUmVuZGVyU3RhdGUuYmxlbmRpbmcuc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgYmxlbmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNyYzogZ2wuWkVSTywgZHN0OiBnbC5TUkNfQ09MT1IsXG4gICAgICAgICAgICAgICAgICAgIHNyY19hbHBoYTogZ2wuT05FLCBkc3RfYWxwaGE6IGdsLk9ORV9NSU5VU19TUkNfQUxQSEFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFJlbmRlclN0YXRlLmJsZW5kaW5nLnNldCh7IGJsZW5kOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlcXVlc3QgZmVhdHVyZSBzZWxlY3Rpb24gYXQgZ2l2ZW4gcGl4ZWwuIFJ1bnMgYXN5bmMgYW5kIHJldHVybnMgcmVzdWx0cyB2aWEgYSBwcm9taXNlLlxuICAgIGdldEZlYXR1cmVBdChwaXhlbCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlNjZW5lLmdldEZlYXR1cmVBdCgpIGNhbGxlZCBiZWZvcmUgc2NlbmUgd2FzIGluaXRpYWxpemVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUG9pbnQgc2NhbGVkIHRvIFswLi4xXSByYW5nZVxuICAgICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgICAgICB4OiBwaXhlbC54ICogVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvIC8gdGhpcy52aWV3LnNpemUuZGV2aWNlLndpZHRoLFxuICAgICAgICAgICAgeTogcGl4ZWwueSAqIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbyAvIHRoaXMudmlldy5zaXplLmRldmljZS5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTsgLy8gbmVlZCB0byBtYWtlIHN1cmUgdGhlIHNjZW5lIHJlLXJlbmRlcnMgZm9yIHRoZXNlIHRvIGJlIHByb2Nlc3NlZFxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uZ2V0RmVhdHVyZUF0KHBvaW50KS5jYXRjaChyID0+IFByb21pc2UucmVzb2x2ZShyKSk7XG4gICAgfVxuXG4gICAgLy8gUmVidWlsZCBnZW9tZXRyeSwgd2l0aG91dCByZS1wYXJzaW5nIHRoZSBjb25maWcgb3IgcmUtY29tcGlsaW5nIHN0eWxlc1xuICAgIC8vIFRPRE86IGRldGVjdCB3aGljaCBlbGVtZW50cyBuZWVkIHRvIGJlIHJlZnJlc2hlZC9yZWJ1aWx0IChzdHlsZXNoZWV0IGNoYW5nZXMsIGV0Yy4pXG4gICAgcmVidWlsZChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYnVpbGRHZW9tZXRyeShvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBSZWJ1aWxkIGFsbCB0aWxlc1xuICAgIHJlYnVpbGRHZW9tZXRyeSh7IHN5bmMgPSB0cnVlIH0gPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gU2tpcCByZWJ1aWxkIGlmIGFscmVhZHkgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1aWxkaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gUXVldWUgdXAgdG8gb25lIHJlYnVpbGQgY2FsbCBhdCBhIHRpbWUsIG9ubHkgc2F2ZSBsYXN0IHJlcXVlc3RcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5idWlsZGluZy5xdWV1ZWQgJiYgdGhpcy5idWlsZGluZy5xdWV1ZWQucmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGlmeSBwcmV2aW91cyByZXF1ZXN0IHRoYXQgaXQgZGlkIG5vdCBjb21wbGV0ZVxuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ1NjZW5lLnJlYnVpbGRHZW9tZXRyeTogcmVxdWVzdCBzdXBlcmNlZGVkIGJ5IGEgbmV3ZXIgY2FsbCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkaW5nLnF1ZXVlZC5yZXNvbHZlKGZhbHNlKTsgLy8gZmFsc2UgZmxhZyBpbmRpY2F0ZXMgcmVidWlsZCByZXF1ZXN0IHdhcyBzdXBlcmNlZGVkXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBxdWV1ZWQgcmVxdWVzdFxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcucXVldWVkID0geyByZXNvbHZlLCByZWplY3QgfTtcbiAgICAgICAgICAgICAgICBsb2cudHJhY2UoYFNjZW5lLnJlYnVpbGRHZW9tZXRyeSgpOiBxdWV1aW5nIHJlcXVlc3RgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRyYWNrIHRpbGUgYnVpbGQgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcgPSB7IHJlc29sdmUsIHJlamVjdCB9O1xuXG4gICAgICAgICAgICAvLyBQcm9maWxpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnLnByb2ZpbGUuZ2VvbWV0cnlfYnVpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9maWxlKCdyZWJ1aWxkR2VvbWV0cnknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIGNvbmZpZyAoaW4gY2FzZSBKUyBvYmplY3RzIHdlcmUgbWFuaXB1bGF0ZWQgZGlyZWN0bHkpXG4gICAgICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3luY0NvbmZpZ1RvV29ya2VyKCk7XG4gICAgICAgICAgICAgICAgU3R5bGVNYW5hZ2VyLmNvbXBpbGUodGhpcy51cGRhdGVBY3RpdmVTdHlsZXMoKSwgdGhpcyk7IC8vIG9ubHkgcmVjb21waWxlIG5ld2x5IGFjdGl2ZSBzdHlsZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzZXRGZWF0dXJlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0VGltZSgpO1xuXG4gICAgICAgICAgICAvLyBSZWJ1aWxkIHZpc2libGUgdGlsZXMsIHNvcnRlZCBmcm9tIGNlbnRlclxuICAgICAgICAgICAgbGV0IGJ1aWxkID0gW107XG4gICAgICAgICAgICB0aGlzLnRpbGVfbWFuYWdlci5mb3JFYWNoVGlsZSgodGlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aWxlLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGQucHVzaCh0aWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGlsZV9tYW5hZ2VyLnJlbW92ZVRpbGUodGlsZS5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50aWxlX21hbmFnZXIuYnVpbGRUaWxlcyhidWlsZCk7XG4gICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gUHJvZmlsaW5nXG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zy5wcm9maWxlLmdlb21ldHJ5X2J1aWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZmlsZUVuZCgncmVidWlsZEdlb21ldHJ5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFRpbGUgbWFuYWdlciBmaW5pc2hlZCBidWlsZGluZyB0aWxlc1xuICAgIC8vIFRPRE8gbW92ZSB0byB0aWxlIG1hbmFnZXJcbiAgICB0aWxlTWFuYWdlckJ1aWxkRG9uZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVpbGRpbmcpIHtcbiAgICAgICAgICAgIGxvZy5pbmZvKGBTY2VuZTogYnVpbGQgZ2VvbWV0cnkgZmluaXNoZWRgKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1aWxkaW5nLnJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkaW5nLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFub3RoZXIgcmVidWlsZCBxdWV1ZWQ/XG4gICAgICAgICAgICB2YXIgcXVldWVkID0gdGhpcy5idWlsZGluZy5xdWV1ZWQ7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChxdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoYFNjZW5lOiBzdGFydGluZyBxdWV1ZWQgcmVidWlsZEdlb21ldHJ5KCkgcmVxdWVzdGApO1xuICAgICAgICAgICAgICAgIHRoaXMucmVidWlsZEdlb21ldHJ5KCkudGhlbihxdWV1ZWQucmVzb2x2ZSwgcXVldWVkLnJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgICBMb2FkIChvciByZWxvYWQpIHRoZSBzY2VuZSBjb25maWdcbiAgICAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAgICovXG4gICAgbG9hZFNjZW5lKGNvbmZpZ19zb3VyY2UgPSBudWxsLCBjb25maWdfcGF0aCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb25maWdfc291cmNlID0gY29uZmlnX3NvdXJjZSB8fCB0aGlzLmNvbmZpZ19zb3VyY2U7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZ19zb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ19wYXRoID0gVXRpbHMucGF0aEZvclVSTChjb25maWdfcGF0aCB8fCB0aGlzLmNvbmZpZ19zb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb25maWdfcGF0aCA9IFV0aWxzLnBhdGhGb3JVUkwoY29uZmlnX3BhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFNjZW5lTG9hZGVyLmxvYWRTY2VuZSh0aGlzLmNvbmZpZ19zb3VyY2UsIHRoaXMuY29uZmlnX3BhdGgpLnRoZW4oY29uZmlnID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2FkJywgeyBjb25maWc6IHRoaXMuY29uZmlnIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgc291cmNlIHRvIGEgc2NlbmUsIGFyZ3VtZW50cyBgbmFtZWAgYW5kIGBjb25maWdgIG5lZWQgdG8gYmUgcHJvdmlkZWQ6XG4gICAgLy8gIC0gSWYgdGhlIG5hbWUgZG9lc24ndCBtYXRjaCBhIHNvdXJjZXMgaXQgd2lsbCBjcmVhdGUgaXRcbiAgICAvLyAgLSB0aGUgYGNvbmZpZ2Agb2JqIGZvbGxvdyB0aGUgWUFNTCBzY2VuZSBzcGVjLCBleDogYGBge3R5cGU6ICdUb3BvSlNPTicsIHVybDogXCIvL3ZlY3Rvci5tYXB6ZW4uY29tL29zbS9hbGwve3p9L3t4fS97eX0udG9wb2pzb25cIl19YGBgXG4gICAgLy8gICAgdGhhdCBsb29rcyBsaWtlOlxuICAgIC8vXG4gICAgLy8gICAgICBzY2VuZS5zZXREYXRhU291cmNlKFwib3NtXCIsIHt0eXBlOiAnVG9wb0pTT04nLCB1cmw6IFwiLy92ZWN0b3IubWFwemVuLmNvbS9vc20vYWxsL3t6fS97eH0ve3l9LnRvcG9qc29uXCIgfSk7XG4gICAgLy9cbiAgICAvLyAgLSBhbHNvIGNhbiBiZSBwYXNzIGEgYGBgZGF0YWBgYCBvYmo6IGBgYHt0eXBlOiAnR2VvSlNPTicsIGRhdGE6IEpTT2JqIF19YGBgXG4gICAgLy9cbiAgICAvLyAgICAgIHZhciBnZW9qc29uX2RhdGEgPSB7fTtcbiAgICAvLyAgICAgIC4uLlxuICAgIC8vICAgICAgc2NlbmUuc2V0RGF0YVNvdXJjZShcImR5bmFtaWNfZGF0YVwiLCB7dHlwZTogJ0dlb0pTT04nLCBkYXRhOiBnZW9qc29uX2RhdGEgfSk7XG4gICAgLy9cbiAgICBzZXREYXRhU291cmNlIChuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFuYW1lIHx8ICFjb25maWcgfHwgIWNvbmZpZy50eXBlIHx8ICghY29uZmlnLnVybCAmJiAhY29uZmlnLmRhdGEpKSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoXCJObyBuYW1lIHByb3ZpZGVkIG9yIG5vdCBhIHZhbGlkIGNvbmZpZzpcIiwgbmFtZSwgY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsb2FkID0gKHRoaXMuY29uZmlnLnNvdXJjZXNbbmFtZV0gPT0gbnVsbCk7XG4gICAgICAgIGxldCBzb3VyY2UgPSB0aGlzLmNvbmZpZy5zb3VyY2VzW25hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcblxuICAgICAgICBpZiAoc291cmNlLmRhdGEgJiYgdHlwZW9mIHNvdXJjZS5kYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgc291cmNlLnVybCA9IFV0aWxzLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkoc291cmNlLmRhdGEpXSkpO1xuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZS5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29uZmlnKHsgcmVidWlsZDogdHJ1ZSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVidWlsZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9hZERhdGFTb3VyY2VzKCkge1xuICAgICAgICBsZXQgcmVzZXQgPSBbXTsgLy8gc291cmNlcyB0byByZXNldFxuICAgICAgICBsZXQgcHJldl9zb3VyY2VfbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZXMpO1xuXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5jb25maWcuc291cmNlcykge1xuICAgICAgICAgICAgbGV0IHNvdXJjZSA9IHRoaXMuY29uZmlnLnNvdXJjZXNbbmFtZV07XG4gICAgICAgICAgICBsZXQgcHJldl9zb3VyY2UgPSB0aGlzLnNvdXJjZXNbbmFtZV07XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VzW25hbWVdID0gRGF0YVNvdXJjZS5jcmVhdGUoT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLCB7bmFtZX0pKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc291cmNlc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc291cmNlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGBDb3VsZCBub3QgY3JlYXRlIGRhdGEgc291cmNlOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKGBTY2VuZTogJHttZXNzYWdlfWAsIHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd3YXJuaW5nJywgeyB0eXBlOiAnc291cmNlcycsIHNvdXJjZSwgbWVzc2FnZSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGF0YSBzb3VyY2UgY2hhbmdlZD9cbiAgICAgICAgICAgIGlmIChEYXRhU291cmNlLmNoYW5nZWQodGhpcy5zb3VyY2VzW25hbWVdLCBwcmV2X3NvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICByZXNldC5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU291cmNlcyB0aGF0IHdlcmUgcmVtb3ZlZFxuICAgICAgICBmb3IgKGxldCBzIG9mIHByZXZfc291cmNlX25hbWVzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uZmlnLnNvdXJjZXNbc10pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zb3VyY2VzW3NdOyAvLyBUT0RPOiByZW1vdmUgZnJvbSB3b3JrZXJzIHRvbz9cbiAgICAgICAgICAgICAgICByZXNldC5wdXNoKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRpbGVzIGZyb20gc291cmNlcyB0aGF0IGhhdmUgY2hhbmdlZFxuICAgICAgICBpZiAocmVzZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy50aWxlX21hbmFnZXIucmVtb3ZlVGlsZXModGlsZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChyZXNldC5pbmRleE9mKHRpbGUuc291cmNlLm5hbWUpID4gLTEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMb2FkIGFsbCB0ZXh0dXJlcyBpbiB0aGUgc2NlbmUgZGVmaW5pdGlvblxuICAgIGxvYWRUZXh0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIFRleHR1cmUuY3JlYXRlRnJvbU9iamVjdCh0aGlzLmdsLCB0aGlzLmNvbmZpZy50ZXh0dXJlcyk7XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIChjdXJyZW50bHkgbWFudWFsbHkpIGFmdGVyIHN0eWxlcyBhcmUgdXBkYXRlZCBpbiBzdHlsZXNoZWV0XG4gICAgdXBkYXRlU3R5bGVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQgJiYgIXRoaXMuaW5pdGlhbGl6aW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjZW5lLnVwZGF0ZVN0eWxlcygpIGNhbGxlZCBiZWZvcmUgc2NlbmUgd2FzIGluaXRpYWxpemVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAoUmUpYnVpbGQgc3R5bGVzIGZyb20gY29uZmlnXG4gICAgICAgIHRoaXMuc3R5bGVzID0gU3R5bGVNYW5hZ2VyLmJ1aWxkKHRoaXMuY29uZmlnLnN0eWxlcywgdGhpcyk7XG5cbiAgICAgICAgLy8gT3B0aW9uYWxseSBzZXQgR0wgY29udGV4dCAodXNlZCB3aGVuIGluaXRpYWxpemluZyBvciByZS1pbml0aWFsaXppbmcgR0wgcmVzb3VyY2VzKVxuICAgICAgICBmb3IgKHZhciBzdHlsZSBvZiBVdGlscy52YWx1ZXModGhpcy5zdHlsZXMpKSB7XG4gICAgICAgICAgICBzdHlsZS5zZXRHTCh0aGlzLmdsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgJiBjb21waWxlIGFjdGl2ZSBzdHlsZXNcbiAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVTdHlsZXMoKTtcbiAgICAgICAgU3R5bGVNYW5hZ2VyLmNvbXBpbGUoT2JqZWN0LmtleXModGhpcy5hY3RpdmVfc3R5bGVzKSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgdXBkYXRlQWN0aXZlU3R5bGVzKCkge1xuICAgICAgICAvLyBNYWtlIGEgc2V0IG9mIGN1cnJlbnRseSBhY3RpdmUgc3R5bGVzICh1c2VkIGluIGEgZHJhdyBydWxlKVxuICAgICAgICAvLyBOb3RlOiBkb2Vzbid0IGFjdHVhbGx5IGNoZWNrIGlmIGFueSBnZW9tZXRyeSBtYXRjaGVzIHRoZSBydWxlLCBqdXN0IHRoYXQgdGhlIHN0eWxlIGlzIHBvdGVudGlhbGx5IHJlbmRlcmFibGVcbiAgICAgICAgbGV0IHByZXZfc3R5bGVzID0gT2JqZWN0LmtleXModGhpcy5hY3RpdmVfc3R5bGVzIHx8IHt9KTtcbiAgICAgICAgdGhpcy5hY3RpdmVfc3R5bGVzID0ge307XG4gICAgICAgIHZhciBhbmltYXRlZCA9IGZhbHNlOyAvLyBpcyBhbnkgYWN0aXZlIHN0eWxlIGFuaW1hdGVkP1xuICAgICAgICBmb3IgKHZhciBydWxlIG9mIFV0aWxzLnJlY3Vyc2VWYWx1ZXModGhpcy5jb25maWcubGF5ZXJzKSkge1xuICAgICAgICAgICAgaWYgKHJ1bGUgJiYgcnVsZS5kcmF3KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgW25hbWUsIGdyb3VwXSBvZiBVdGlscy5lbnRyaWVzKHJ1bGUuZHJhdykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogd2FybiBvbiBub24tb2JqZWN0IGRyYXcgZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwgJiYgdHlwZW9mIGdyb3VwID09PSAnb2JqZWN0JyAmJiBncm91cC52aXNpYmxlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlX25hbWUgPSBncm91cC5zdHlsZSB8fCBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlcyA9IFtzdHlsZV9uYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uYWwgYWRkaXRpb25hbCBvdXRsaW5lIHN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAub3V0bGluZSAmJiBncm91cC5vdXRsaW5lLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goZ3JvdXAub3V0bGluZS5zdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IHN0eWxlcy5maWx0ZXIoeCA9PiB0aGlzLnN0eWxlc1t4XSkuZm9yRWFjaChzdHlsZV9uYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSB0aGlzLnN0eWxlc1tzdHlsZV9uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVfc3R5bGVzW3N0eWxlX25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLmFuaW1hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSBleHBsaWNpdGx5IHNldCBzY2VuZSBhbmltYXRpb24gZmxhZyBpZiBkZWZpbmVkLCBvdGhlcndpc2UgdHVybiBvbiBhbmltYXRpb25cbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIGFueSBhbmltYXRlZCBzdHlsZXNcbiAgICAgICAgdGhpcy5hbmltYXRlZCA9IHRoaXMuY29uZmlnLnNjZW5lLmFuaW1hdGVkICE9PSB1bmRlZmluZWQgPyB0aGlzLmNvbmZpZy5zY2VuZS5hbmltYXRlZCA6IGFuaW1hdGVkO1xuXG4gICAgICAgIC8vIENvbXBpbGUgbmV3bHkgYWN0aXZlIHN0eWxlc1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5hY3RpdmVfc3R5bGVzKS5maWx0ZXIocyA9PiBwcmV2X3N0eWxlcy5pbmRleE9mKHMpID09PSAtMSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IGFjdGl2ZSBjYW1lcmEgLSBmb3IgcHVibGljIEFQSVxuICAgIGdldEFjdGl2ZUNhbWVyYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRBY3RpdmVDYW1lcmEoKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgYWN0aXZlIGNhbWVyYSAtIGZvciBwdWJsaWMgQVBJXG4gICAgc2V0QWN0aXZlQ2FtZXJhKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5zZXRBY3RpdmVDYW1lcmEobmFtZSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGxpZ2h0aW5nXG4gICAgY3JlYXRlTGlnaHRzKCkge1xuICAgICAgICB0aGlzLmxpZ2h0cyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpIGluIHRoaXMuY29uZmlnLmxpZ2h0cykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5saWdodHNbaV0gfHwgdHlwZW9mIHRoaXMuY29uZmlnLmxpZ2h0c1tpXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsaWdodCA9IHRoaXMuY29uZmlnLmxpZ2h0c1tpXTtcbiAgICAgICAgICAgIGxpZ2h0Lm5hbWUgPSBpLnJlcGxhY2UoJy0nLCAnXycpOyAvLyBsaWdodCBuYW1lcyBhcmUgaW5qZWN0ZWQgaW4gc2hhZGVycywgY2FuJ3QgaGF2ZSBoeXBoZW5zXG4gICAgICAgICAgICBsaWdodC52aXNpYmxlID0gKGxpZ2h0LnZpc2libGUgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsaWdodC52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saWdodHNbbGlnaHQubmFtZV0gPSBMaWdodC5jcmVhdGUodGhpcy52aWV3LCBsaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTGlnaHQuaW5qZWN0KHRoaXMubGlnaHRzKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgYmFja2dyb3VuZCBjb2xvclxuICAgIHNldEJhY2tncm91bmQoKSB7XG4gICAgICAgIGxldCBiZyA9IHRoaXMuY29uZmlnLnNjZW5lLmJhY2tncm91bmQ7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IHt9O1xuICAgICAgICBpZiAoYmcgJiYgYmcuY29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZC5jb2xvciA9IFN0eWxlUGFyc2VyLnBhcnNlQ29sb3IoYmcuY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5iYWNrZ3JvdW5kLmNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmQuY29sb3IgPSBbMCwgMCwgMCwgMF07IC8vIGRlZmF1bHQgYmFja2dyb3VuZCBUT0RPOiB2YXJ5IHcvc2NlbmUgYWxwaGFcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGJhY2tncm91bmQgaXMgZnVsbHkgb3BhcXVlLCBzZXQgY2FudmFzIGJhY2tncm91bmQgdG8gbWF0Y2hcbiAgICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZC5jb2xvclszXSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID1cbiAgICAgICAgICAgICAgICBgcmdiYSgke3RoaXMuYmFja2dyb3VuZC5jb2xvci5tYXAoYyA9PiBNYXRoLmZsb29yKGMgKiAyNTUpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzY2VuZSBjb25maWcsIGFuZCBvcHRpb25hbGx5IHJlYnVpbGQgZ2VvbWV0cnlcbiAgICB1cGRhdGVDb25maWcoeyByZWJ1aWxkIH0gPSB7fSkge1xuICAgICAgICB0aGlzLmdlbmVyYXRpb24rKztcbiAgICAgICAgdGhpcy51cGRhdGluZysrO1xuICAgICAgICB0aGlzLmNvbmZpZy5zY2VuZSA9IHRoaXMuY29uZmlnLnNjZW5lIHx8IHt9O1xuXG4gICAgICAgIFN0eWxlTWFuYWdlci5pbml0KCk7XG4gICAgICAgIHRoaXMudmlldy5yZXNldCgpO1xuICAgICAgICB0aGlzLmNyZWF0ZUxpZ2h0cygpO1xuICAgICAgICB0aGlzLmxvYWREYXRhU291cmNlcygpO1xuICAgICAgICB0aGlzLmxvYWRUZXh0dXJlcygpO1xuICAgICAgICB0aGlzLnNldEJhY2tncm91bmQoKTtcblxuICAgICAgICAvLyBUT0RPOiBkZXRlY3QgY2hhbmdlcyB0byBzdHlsZXM/IGFscmVhZHkgKGN1cnJlbnRseSkgbmVlZCB0byByZWNvbXBpbGUgYW55d2F5IHdoZW4gY2FtZXJhIG9yIGxpZ2h0cyBjaGFuZ2VcbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZXMoKTtcblxuICAgICAgICAvLyBPcHRpb25hbGx5IHJlYnVpbGQgZ2VvbWV0cnlcbiAgICAgICAgbGV0IGRvbmU7XG4gICAgICAgIGlmIChyZWJ1aWxkKSB7XG4gICAgICAgICAgICBkb25lID0gdGhpcy5yZWJ1aWxkR2VvbWV0cnkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbmUgPSB0aGlzLnN5bmNDb25maWdUb1dvcmtlcigpOyAvLyByZWJ1aWxkR2VvbWV0cnkoKSBhbHJlYWR5IHN5bmNzIGNvbmZpZ1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluaXNoIGJ5IHVwZGF0aW5nIGJvdW5kcyBhbmQgcmUtcmVuZGVyaW5nXG4gICAgICAgIHJldHVybiBkb25lLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGluZy0tO1xuICAgICAgICAgICAgdGhpcy52aWV3LnVwZGF0ZUJvdW5kcygpO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UmVkcmF3KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNlcmlhbGl6ZSBjb25maWcgYW5kIHNlbmQgdG8gd29ya2VyXG4gICAgc3luY0NvbmZpZ1RvV29ya2VyKCkge1xuICAgICAgICAvLyBUZWxsIHdvcmtlcnMgd2UncmUgYWJvdXQgdG8gcmVidWlsZCAoc28gdGhleSBjYW4gdXBkYXRlIHN0eWxlcywgZXRjLilcbiAgICAgICAgdGhpcy5jb25maWdfc2VyaWFsaXplZCA9IFV0aWxzLnNlcmlhbGl6ZVdpdGhGdW5jdGlvbnModGhpcy5jb25maWcpO1xuICAgICAgICByZXR1cm4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHRoaXMud29ya2VycywgJ3NlbGYudXBkYXRlQ29uZmlnJywge1xuICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZ19zZXJpYWxpemVkLFxuICAgICAgICAgICAgZ2VuZXJhdGlvbjogdGhpcy5nZW5lcmF0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlc2V0RmVhdHVyZVNlbGVjdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgRmVhdHVyZVNlbGVjdGlvbih0aGlzLmdsLCB0aGlzLndvcmtlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMud29ya2Vycykge1xuICAgICAgICAgICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHRoaXMud29ya2VycywgJ3NlbGYucmVzZXRGZWF0dXJlU2VsZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXRzIHRoZSBjdXJyZW50IGZlYXR1cmUgc2VsZWN0aW9uIG1hcCBzaXplIGFjcm9zcyBhbGwgd29ya2Vycy4gUmV0dXJucyBhIHByb21pc2UuXG4gICAgZ2V0RmVhdHVyZVNlbGVjdGlvbk1hcFNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmZldGNoaW5nX3NlbGVjdGlvbl9tYXApIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmV0Y2hpbmdfc2VsZWN0aW9uX21hcCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSh0aGlzLndvcmtlcnMsICdzZWxmLmdldEZlYXR1cmVTZWxlY3Rpb25NYXBTaXplJylcbiAgICAgICAgICAgIC50aGVuKHNpemVzID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZldGNoaW5nX3NlbGVjdGlvbl9tYXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYik7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBpbnRlcm5hbCBjbG9jaywgbW9zdGx5IHVzZWZ1bCBmb3IgY29uc2lzdGVudCBleHBlcmllbmNlIHdoZW4gY2hhbmdpbmcgc3R5bGVzL2RlYnVnZ2luZ1xuICAgIHJlc2V0VGltZSgpIHtcbiAgICAgICAgdGhpcy5zdGFydF90aW1lID0gK25ldyBEYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gRmlyZXMgZXZlbnQgd2hlbiByZW5kZXJlZCB0aWxlIHNldCBvciBzdHlsZSBjaGFuZ2VzXG4gICAgdXBkYXRlVmlld0NvbXBsZXRlICgpIHtcbiAgICAgICAgaWYgKCh0aGlzLnJlbmRlcl9jb3VudF9jaGFuZ2VkIHx8IHRoaXMuZ2VuZXJhdGlvbiAhPT0gdGhpcy5sYXN0X2NvbXBsZXRlX2dlbmVyYXRpb24pICYmXG4gICAgICAgICAgICAhdGhpcy50aWxlX21hbmFnZXIuaXNMb2FkaW5nVmlzaWJsZVRpbGVzKCkpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdF9jb21wbGV0ZV9nZW5lcmF0aW9uID0gdGhpcy5nZW5lcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd2aWV3X2NvbXBsZXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldFZpZXdDb21wbGV0ZSAoKSB7XG4gICAgICAgIHRoaXMubGFzdF9jb21wbGV0ZV9nZW5lcmF0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUYWtlIGEgc2NyZWVuc2hvdFxuICAgIC8vIEFzeW5jaHJvbm91cyBiZWNhdXNlIHdlIGhhdmUgdG8gd2FpdCBmb3IgbmV4dCByZW5kZXIgdG8gY2FwdHVyZSBidWZmZXJcbiAgICAvLyBSZXR1cm5zIGEgcHJvbWlzZVxuICAgIHNjcmVlbnNob3QgKCkge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZV9zY3JlZW5zaG90ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlX3NjcmVlbnNob3QucHJvbWlzZTsgLy8gb25seSBjYXB0dXJlIG9uZSBzY3JlZW5zaG90IGF0IGEgdGltZVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVkcmF3KCk7XG5cbiAgICAgICAgLy8gV2lsbCByZXNvbHZlIG9uY2UgcmVuZGVyaW5nIGlzIGNvbXBsZXRlIGFuZCByZW5kZXIgYnVmZmVyIGlzIGNhcHR1cmVkXG4gICAgICAgIHRoaXMucXVldWVfc2NyZWVuc2hvdCA9IHt9O1xuICAgICAgICB0aGlzLnF1ZXVlX3NjcmVlbnNob3QucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucXVldWVfc2NyZWVuc2hvdC5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMucXVldWVfc2NyZWVuc2hvdC5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZV9zY3JlZW5zaG90LnByb21pc2U7XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIGFmdGVyIHJlbmRlcmluZywgY2FwdHVyZXMgcmVuZGVyIGJ1ZmZlciBhbmQgcmVzb2x2ZXMgcHJvbWlzZSB3aXRoIGltYWdlIGRhdGFcbiAgICBjb21wbGV0ZVNjcmVlbnNob3QgKCkge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZV9zY3JlZW5zaG90ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEdldCBkYXRhIFVSTCwgY29udmVydCB0byBibG9iXG4gICAgICAgICAgICAvLyBTdHJpcCBob3N0L21pbWV0eXBlL2V0Yy4sIGNvbnZlcnQgYmFzZTY0IHRvIGJpbmFyeSB3aXRob3V0IFVURi04IG1hbmdsaW5nXG4gICAgICAgICAgICAvLyBBZGFwdGVkIGZyb206IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3VuY29uZWQvNDM3MDgyMlxuICAgICAgICAgICAgdmFyIHVybCA9IHRoaXMuY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGF0b2IodXJsLnNsaWNlKDIyKSk7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2ldID0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYnVmZmVyXSwgeyB0eXBlOiAnaW1hZ2UvcG5nJyB9KTtcblxuICAgICAgICAgICAgLy8gUmVzb2x2ZSB3aXRoIHNjcmVlbnNob3QgZGF0YVxuICAgICAgICAgICAgdGhpcy5xdWV1ZV9zY3JlZW5zaG90LnJlc29sdmUoeyB1cmwsIGJsb2IgfSk7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlX3NjcmVlbnNob3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBTdGF0cy9kZWJ1Zy9wcm9maWxpbmcgbWV0aG9kc1xuXG4gICAgLy8gTG9nIG1lc3NhZ2VzIHBhc3MgdGhyb3VnaCBmcm9tIHdlYiB3b3JrZXJzXG4gICAgd29ya2VyTG9nTWVzc2FnZShldmVudCkge1xuICAgICAgICBsZXQgZGF0YSA9IHR5cGVvZiBldmVudC5kYXRhID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoZXZlbnQuZGF0YSkgOiBldmVudC5kYXRhOyAvLyBvcHRpb25hbCB1bi1zdHJpbmdpZnlcbiAgICAgICAgaWYgKGRhdGEudHlwZSAhPT0gJ2xvZycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB7IHdvcmtlcl9pZCwgbGV2ZWwsIG1zZyB9ID0gZGF0YTtcblxuICAgICAgICBpZiAobG9nW2xldmVsXSkge1xuICAgICAgICAgICAgbG9nW2xldmVsXShgd29ya2VyICR7d29ya2VyX2lkfTpgLCAgLi4ubXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihgU2NlbmUud29ya2VyTG9nTWVzc2FnZTogdW5yZWNvZ25pemVkIGxvZyBsZXZlbCAke2xldmVsfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvZmlsZSBoZWxwZXJzLCBpc3N1ZXMgYSBwcm9maWxlIG9uIG1haW4gdGhyZWFkICYgYWxsIHdvcmtlcnNcbiAgICBfcHJvZmlsZShuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUucHJvZmlsZShgbWFpbiB0aHJlYWQ6ICR7bmFtZX1gKTtcbiAgICAgICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHRoaXMud29ya2VycywgJ3NlbGYucHJvZmlsZScsIG5hbWUpO1xuICAgIH1cblxuICAgIF9wcm9maWxlRW5kKG5hbWUpIHtcbiAgICAgICAgY29uc29sZS5wcm9maWxlRW5kKGBtYWluIHRocmVhZDogJHtuYW1lfWApO1xuICAgICAgICBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UodGhpcy53b3JrZXJzLCAnc2VsZi5wcm9maWxlRW5kJywgbmFtZSk7XG4gICAgfVxuXG4gICAgLy8gRGVidWcgY29uZmlnIGFuZCBmdW5jdGlvbnNcbiAgICBzZXR1cERlYnVnICgpIHtcbiAgICAgICAgbGV0IHNjZW5lID0gdGhpcztcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IHtcbiAgICAgICAgICAgIHByb2ZpbGU6IHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeV9idWlsZDogZmFsc2VcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFJlYnVpbGQgZ2VvbWV0cnkgYSBnaXZlbiAjIG9mIHRpbWVzIGFuZCBwcmludCBhdmVyYWdlLCBtaW4sIG1heCB0aW1pbmdzXG4gICAgICAgICAgICB0aW1lUmVidWlsZCAobnVtID0gMSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAgICAgbGV0IHRpbWVzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IGN5Y2xlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSArbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2NlbmUucmVidWlsZChvcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzLnB1c2goK25ldyBEYXRlKCkgLSBzdGFydCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcy5sZW5ndGggPCBudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeWNsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGF2ZyA9IH5+KHRpbWVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8gdGltZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuaW5mbyhgUHJvZmlsZWQgcmVidWlsZCAke251bX0gdGltZXM6ICR7YXZnfSBhdmcgKCR7TWF0aC5taW4oLi4udGltZXMpfSBtaW4sICR7TWF0aC5tYXgoLi4udGltZXMpfSBtYXgpYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY3ljbGUoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFJldHVybiBnZW9tZXRyeSBjb3VudHMgb2YgdmlzaWJsZSB0aWxlcywgZ3JvdXBlZCBieSBzdHlsZSBuYW1lXG4gICAgICAgICAgICBnZW9tZXRyeUNvdW50QnlTdHlsZSAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvdW50cyA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHRpbGUgb2Ygc2NlbmUudGlsZV9tYW5hZ2VyLmdldFJlbmRlcmFibGVUaWxlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHN0eWxlIGluIHRpbGUubWVzaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudHNbc3R5bGVdID0gY291bnRzW3N0eWxlXSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRzW3N0eWxlXSArPSB0aWxlLm1lc2hlc1tzdHlsZV0uZ2VvbWV0cnlfY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50cztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdlb21ldHJ5Q291bnRCeUJhc2VTdHlsZSAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlX2NvdW50cyA9IHNjZW5lLmRlYnVnLmdlb21ldHJ5Q291bnRCeVN0eWxlKCk7XG4gICAgICAgICAgICAgICAgbGV0IGNvdW50cyA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHN0eWxlIGluIHN0eWxlX2NvdW50cykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmFzZSA9IHNjZW5lLnN0eWxlc1tzdHlsZV0uYnVpbHRfaW4gPyBzdHlsZSA6IHNjZW5lLnN0eWxlc1tzdHlsZV0uYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRzW2Jhc2VdID0gY291bnRzW2Jhc2VdIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50c1tiYXNlXSArPSBzdHlsZV9jb3VudHNbc3R5bGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY291bnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxufVxuIiwiaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IEdMU0wgZnJvbSAnLi9nbC9nbHNsJztcbi8vIGltcG9ydCBtZXJnZU9iamVjdHMgZnJvbSAnLi91dGlscy9tZXJnZSc7XG5pbXBvcnQge1N0eWxlTWFuYWdlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfbWFuYWdlcic7XG5cbnZhciBTY2VuZUxvYWRlcjtcblxuZXhwb3J0IGRlZmF1bHQgU2NlbmVMb2FkZXIgPSB7XG5cbiAgICAvLyBMb2FkIHNjZW5lcyBkZWZpbml0aW9ucyBmcm9tIFVSTCAmIHByb3Byb2Nlc3NcbiAgICBsb2FkU2NlbmUodXJsLCBwYXRoID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gU2NlbmVMb2FkZXIubG9hZFNjZW5lUmVjdXJzaXZlKHVybCwgcGF0aCkudGhlbihTY2VuZUxvYWRlci5maW5hbGl6ZSk7XG4gICAgfSxcblxuICAgIC8vIExvYWRzIHNjZW5lIGZpbGVzIGZyb20gVVJMLCByZWN1cnNpdmVseSBsb2FkaW5nICdpbmNsdWRlZCcgc2NlbmVzXG4gICAgLy8gT3B0aW9uYWwgKmluaXRpYWwqIHBhdGggb25seSAod29uJ3QgYmUgcGFzc2VkIHRvIHJlY3Vyc2l2ZSAnaW5jbHVkZScgY2FsbHMpXG4gICAgLy8gVXNlZnVsIGZvciBsb2FkaW5nIHJlc291cmNlcyBpbiBiYXNlIHNjZW5lIGZpbGUgZnJvbSBhIHNlcGFyYXRlIGxvY2F0aW9uXG4gICAgLy8gKGUuZy4gaW4gVGFuZ3JhbSBQbGF5LCB3aGVuIG1vZGlmaWVkIGxvY2FsIHNjZW5lIHNob3VsZCBzdGlsbCByZWZlciB0byBvcmlnaW5hbCByZXNvdXJjZSBVUkxzKVxuICAgIGxvYWRTY2VuZVJlY3Vyc2l2ZSh1cmwsIHBhdGggPSBudWxsKSB7XG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGggfHwgVXRpbHMucGF0aEZvclVSTCh1cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFV0aWxzLmxvYWRSZXNvdXJjZSh1cmwpLnRoZW4oY29uZmlnID0+IHtcbiAgICAgICAgICAgIHJldHVybiBTdHlsZU1hbmFnZXIubG9hZFJlbW90ZVN0eWxlcyhjb25maWcuc3R5bGVzLCBwYXRoKS5cbiAgICAgICAgICAgICAgICB0aGVuKHN0eWxlcyA9PiBTdHlsZU1hbmFnZXIubG9hZFNoYWRlckJsb2NrcyhzdHlsZXMsIHBhdGgpKS4gLy8gVE9ETzogZGVwcmVjYXRlIHJlbW90ZSBzaGFkZXIgYmxvY2tzP1xuICAgICAgICAgICAgICAgIHRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBhY2NlcHQgc2luZ2xlLXN0cmluZyBvciBhcnJheVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAodHlwZW9mIGNvbmZpZy5pbmNsdWRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgY29uZmlnLmluY2x1ZGUgPSBbY29uZmlnLmluY2x1ZGVdO1xuICAgICAgICAgICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZy5pbmNsdWRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgU2NlbmVMb2FkZXIubm9ybWFsaXplKGNvbmZpZywgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGVjdCBVUkxzIG9mIHNjZW5lcyB0byBpbmNsdWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCBpbmNsdWRlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgKGxldCB1cmwgb2YgY29uZmlnLmluY2x1ZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGluY2x1ZGVzLnB1c2goVXRpbHMuYWRkQmFzZVVSTCh1cmwsIHBhdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUgY29uZmlnLmluY2x1ZGU7IC8vIGRvbid0IHdhbnQgdG8gbWVyZ2UgdGhpcyBwcm9wZXJ0eVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBQcm9taXNlLlxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgYWxsKGluY2x1ZGVzLm1hcCh1cmwgPT4gU2NlbmVMb2FkZXIubG9hZFNjZW5lUmVjdXJzaXZlKHVybCkpKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoZW4oY29uZmlncyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgY29uZmlnID0gbWVyZ2VPYmplY3RzKHt9LCAuLi5jb25maWdzLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIFNjZW5lTG9hZGVyLm5vcm1hbGl6ZShjb25maWcsIHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIE5vcm1hbGl6ZSBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIGFkanVzdCB3aXRoaW4gZWFjaCBsb2NhbCBzY2VuZSBmaWxlICh1c3VhbGx5IGJ5IHBhdGgpXG4gICAgbm9ybWFsaXplKGNvbmZpZywgcGF0aCkge1xuICAgICAgICBTY2VuZUxvYWRlci5ub3JtYWxpemVEYXRhU291cmNlcyhjb25maWcsIHBhdGgpO1xuICAgICAgICBTY2VuZUxvYWRlci5ub3JtYWxpemVUZXh0dXJlcyhjb25maWcsIHBhdGgpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH0sXG5cbiAgICAvLyBFeHBhbmQgcGF0aHMgZm9yIGRhdGEgc291cmNlXG4gICAgbm9ybWFsaXplRGF0YVNvdXJjZXMoY29uZmlnLCBwYXRoKSB7XG4gICAgICAgIGNvbmZpZy5zb3VyY2VzID0gY29uZmlnLnNvdXJjZXMgfHwge307XG5cbiAgICAgICAgZm9yIChsZXQgc291cmNlIG9mICBVdGlscy52YWx1ZXMoY29uZmlnLnNvdXJjZXMpKSB7XG4gICAgICAgICAgICBzb3VyY2UudXJsID0gVXRpbHMuYWRkQmFzZVVSTChzb3VyY2UudXJsLCBwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfSxcblxuICAgIC8vIEV4cGFuZCBwYXRocyBhbmQgY2VudHJhbGl6ZSB0ZXh0dXJlIGRlZmluaXRpb25zIGZvciBhIHNjZW5lIG9iamVjdFxuICAgIG5vcm1hbGl6ZVRleHR1cmVzKGNvbmZpZywgcGF0aCkge1xuICAgICAgICBjb25maWcudGV4dHVyZXMgPSBjb25maWcudGV4dHVyZXMgfHwge307XG5cbiAgICAgICAgaWYgKGNvbmZpZy5zdHlsZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IFtzdHlsZV9uYW1lLCBzdHlsZV0gb2YgVXRpbHMuZW50cmllcyhjb25maWcuc3R5bGVzKSkge1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXggPSBzdHlsZS50ZXh0dXJlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRleHR1cmUgYnkgVVJMLCBleHBhbmQgcmVsYXRpdmUgdG8gc2NlbmUgZmlsZVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRleCA9PT0gJ3N0cmluZycgJiYgIWNvbmZpZy50ZXh0dXJlc1t0ZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dHVyZV9uYW1lID0gJ19fJyArIHN0eWxlX25hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcudGV4dHVyZXNbdGV4dHVyZV9uYW1lXSA9IHsgdXJsOiB0ZXggfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLnRleHR1cmUgPSB0ZXh0dXJlX25hbWU7IC8vIHBvaW50IHN0eWxlIHRvIGxvY2F0aW9uIG9mIHRleHR1cmVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUZXh0dXJlIGJ5IG9iamVjdCwgbW92ZSBpdCB0byB0aGUgZ2xvYmFsIHNjZW5lIHRleHR1cmUgc2V0IGFuZCBnaXZlIGl0IGEgZGVmYXVsdCBuYW1lXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0ZXggPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dHVyZV9uYW1lID0gJ19fJyArIHN0eWxlX25hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcudGV4dHVyZXNbdGV4dHVyZV9uYW1lXSA9IHRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLnRleHR1cmUgPSB0ZXh0dXJlX25hbWU7IC8vIHBvaW50IHN0eWxlIHRvIGxvY2F0aW9uIG9mIHRleHR1cmVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHN0eWxlIGhhcyB0ZXh0dXJlIHVuaWZvcm1zLCBleHBhbmQgdGV4dHVyZSBVUkxzIHJlbGF0aXZlIHRvIHNjZW5lIGZpbGVcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc2hhZGVycyAmJiBzdHlsZS5zaGFkZXJzLnVuaWZvcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHt0eXBlLCB2YWx1ZSwga2V5LCB1bmlmb3Jtc30gb2YgR0xTTC5wYXJzZVVuaWZvcm1zKHN0eWxlLnNoYWRlcnMudW5pZm9ybXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3NhbXBsZXIyRCcgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhY29uZmlnLnRleHR1cmVzW3ZhbHVlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0dXJlX25hbWUgPSAnX18nICsgc3R5bGVfbmFtZSArICdfdW5pZm9ybV8nICsga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy50ZXh0dXJlc1t0ZXh0dXJlX25hbWVdID0geyB1cmw6IHZhbHVlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXNba2V5XSA9IHRleHR1cmVfbmFtZTsgLy8gcG9pbnQgc3R5bGUgdG8gbG9jYXRpb24gb2YgdGV4dHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBzdHlsZSBoYXMgbWF0ZXJpYWwsIGV4cGFuZCB0ZXh0dXJlIFVSTHMgcmVsYXRpdmUgdG8gc2NlbmUgZmlsZVxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5tYXRlcmlhbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwcm9wIG9mIFsnZW1pc3Npb24nLCAnYW1iaWVudCcsICdkaWZmdXNlJywgJ3NwZWN1bGFyJywgJ25vcm1hbCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRlcmlhbCBwcm9wZXJ0eSBoYXMgYSB0ZXh0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUubWF0ZXJpYWxbcHJvcF0gIT0gbnVsbCAmJiBzdHlsZS5tYXRlcmlhbFtwcm9wXS50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleCA9IHN0eWxlLm1hdGVyaWFsW3Byb3BdLnRleHR1cmU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUZXh0dXJlIGJ5IFVSTCwgZXhwYW5kIHJlbGF0aXZlIHRvIHNjZW5lIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRleCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWNvbmZpZy50ZXh0dXJlc1t0ZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0dXJlX25hbWUgPSAnX18nICsgc3R5bGVfbmFtZSArICdfbWF0ZXJpYWxfJyArIHByb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy50ZXh0dXJlc1t0ZXh0dXJlX25hbWVdID0geyB1cmw6IHRleCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5tYXRlcmlhbFtwcm9wXS50ZXh0dXJlID0gdGV4dHVyZV9uYW1lOyAvLyBwb2ludCBzdHlsZSB0byBsb2NhdGlvbiBvZiB0ZXh0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRleHR1cmUgYnkgb2JqZWN0LCBtb3ZlIGl0IHRvIHRoZSBnbG9iYWwgc2NlbmUgdGV4dHVyZSBzZXQgYW5kIGdpdmUgaXQgYSBkZWZhdWx0IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGV4ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dHVyZV9uYW1lID0gJ19fJyArIHN0eWxlX25hbWUgKyAnX21hdGVyaWFsXycgKyBwcm9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcudGV4dHVyZXNbdGV4dHVyZV9uYW1lXSA9IHRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUubWF0ZXJpYWxbcHJvcF0udGV4dHVyZSA9IHRleHR1cmVfbmFtZTsgLy8gcG9pbnQgc3R5bGUgdG8gbG9jYXRpb24gb2YgdGV4dHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBwYXRoIHRvIHRleHR1cmVzXG4gICAgICAgIGlmIChjb25maWcudGV4dHVyZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHRleHR1cmUgb2YgVXRpbHMudmFsdWVzKGNvbmZpZy50ZXh0dXJlcykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dHVyZS51cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS51cmwgPSBVdGlscy5hZGRCYXNlVVJMKHRleHR1cmUudXJsLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH0sXG5cbiAgICAvLyBOb3JtYWxpemUgc29tZSBzY2VuZS13aWRlIHNldHRpbmdzIHRoYXQgYXBwbHkgdG8gdGhlIGZpbmFsLCBtZXJnZWQgc2NlbmVcbiAgICBmaW5hbGl6ZShjb25maWcpIHtcbiAgICAgICAgLy8gQXNzaWduIGlkcyB0byBkYXRhIHNvdXJjZXNcbiAgICAgICAgbGV0IHNvdXJjZV9pZCA9IDA7XG4gICAgICAgIGZvciAobGV0IHNvdXJjZSBpbiBjb25maWcuc291cmNlcykge1xuICAgICAgICAgICAgY29uZmlnLnNvdXJjZXNbc291cmNlXS5pZCA9IHNvdXJjZV9pZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgb25seSBvbmUgY2FtZXJhIHNwZWNpZmllZCwgc2V0IGl0IGFzIGRlZmF1bHRcbiAgICAgICAgY29uZmlnLmNhbWVyYXMgPSBjb25maWcuY2FtZXJhcyB8fCB7fTtcbiAgICAgICAgaWYgKGNvbmZpZy5jYW1lcmEpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jYW1lcmFzLmRlZmF1bHQgPSBjb25maWcuY2FtZXJhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gY2FtZXJhcyBzcGVjaWZpZWQsIGNyZWF0ZSBvbmVcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGNvbmZpZy5jYW1lcmFzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbmZpZy5jYW1lcmFzLmRlZmF1bHQgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vIGNhbWVyYSBzZXQgYXMgYWN0aXZlLCB1c2UgZmlyc3Qgb25lXG4gICAgICAgIGxldCBhY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgY2FtZXJhIG9mIFV0aWxzLnZhbHVlcyhjb25maWcuY2FtZXJhcykpIHtcbiAgICAgICAgICAgIGlmIChjYW1lcmEuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgICBjb25maWcuY2FtZXJhc1tPYmplY3Qua2V5cyhjb25maWcuY2FtZXJhcylbMF1dLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnN1cmUgdG9wLWxldmVsIHByb3BlcnRpZXNcbiAgICAgICAgY29uZmlnLmxpZ2h0cyA9IGNvbmZpZy5saWdodHMgfHwge307XG4gICAgICAgIGNvbmZpZy5zdHlsZXMgPSBjb25maWcuc3R5bGVzIHx8IHt9O1xuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG59O1xuIiwiLypqc2hpbnQgd29ya2VyOiB0cnVlKi9cbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzL3V0aWxzJztcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi91dGlscy93b3JrZXJfYnJva2VyJzsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5pbXBvcnQgbWVyZ2VPYmplY3RzIGZyb20gJy4vdXRpbHMvbWVyZ2UnO1xuaW1wb3J0IFRpbGUgZnJvbSAnLi90aWxlJztcbmltcG9ydCBEYXRhU291cmNlIGZyb20gJy4vc291cmNlcy9kYXRhX3NvdXJjZSc7XG5pbXBvcnQgRmVhdHVyZVNlbGVjdGlvbiBmcm9tICcuL3NlbGVjdGlvbic7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IHtTdHlsZU1hbmFnZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX21hbmFnZXInO1xuaW1wb3J0IHtwYXJzZVJ1bGVzfSBmcm9tICcuL3N0eWxlcy9ydWxlJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4vZ2wvdGV4dHVyZSc7XG5cbmV4cG9ydCB2YXIgU2NlbmVXb3JrZXIgPSBzZWxmO1xuXG4vLyBXb3JrZXIgZnVuY3Rpb25hbGl0eSB3aWxsIG9ubHkgYmUgZGVmaW5lZCBpbiB3b3JrZXIgdGhyZWFkXG5pZiAoVXRpbHMuaXNXb3JrZXJUaHJlYWQpIHtcblxuT2JqZWN0LmFzc2lnbihzZWxmLCB7XG5cbiAgICBGZWF0dXJlU2VsZWN0aW9uLFxuXG4gICAgc291cmNlczoge1xuICAgICAgICB0aWxlczoge30sXG4gICAgICAgIG9iamVjdHM6IHt9XG4gICAgfSxcbiAgICBzdHlsZXM6IHt9LFxuICAgIHJ1bGVzOiB7fSxcbiAgICBsYXllcnM6IHt9LFxuICAgIHRpbGVzOiB7fSxcbiAgICBvYmplY3RzOiB7fSxcbiAgICBjb25maWc6IHt9LCAgICAgLy8gcmF3IGNvbmZpZyAoZS5nLiBmdW5jdGlvbnMsIGV0Yy4gbm90IGV4cGFuZGVkKVxuXG4gICAgLy8gSW5pdGlhbGl6ZSB3b3JrZXJcbiAgICBpbml0ICh3b3JrZXJfaWQsIG51bV93b3JrZXJzLCBkZXZpY2VfcGl4ZWxfcmF0aW8pIHtcbiAgICAgICAgc2VsZi5fd29ya2VyX2lkID0gd29ya2VyX2lkO1xuICAgICAgICBzZWxmLm51bV93b3JrZXJzID0gbnVtX3dvcmtlcnM7XG4gICAgICAgIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbyA9IGRldmljZV9waXhlbF9yYXRpbztcbiAgICAgICAgRmVhdHVyZVNlbGVjdGlvbi5zZXRQcmVmaXgoc2VsZi5fd29ya2VyX2lkKTtcbiAgICAgICAgcmV0dXJuIHdvcmtlcl9pZDtcbiAgICB9LFxuXG4gICAgLy8gU3RhcnRzIGEgY29uZmlnIHJlZnJlc2hcbiAgICB1cGRhdGVDb25maWcgKHsgY29uZmlnLCBnZW5lcmF0aW9uIH0pIHtcbiAgICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShjb25maWcpO1xuXG4gICAgICAgIHNlbGYubGFzdF9jb25maWcgPSBtZXJnZU9iamVjdHMoe30sIHNlbGYuY29uZmlnKTtcbiAgICAgICAgc2VsZi5jb25maWcgPSBtZXJnZU9iamVjdHMoe30sIGNvbmZpZyk7XG4gICAgICAgIHNlbGYuZ2VuZXJhdGlvbiA9IGdlbmVyYXRpb247XG5cbiAgICAgICAgLy8gRGF0YSBibG9jayBmdW5jdGlvbnMgYXJlIG5vdCBjb250ZXh0IHdyYXBwZWQgbGlrZSB0aGUgcmVzdCBvZiB0aGUgc3R5bGUgZnVuY3Rpb25zIGFyZVxuICAgICAgICAvLyBUT0RPOiBwcm9iYWJseSB3YW50IGEgY2xlYW5lciB3YXkgdG8gZXhjbHVkZSB0aGVzZVxuICAgICAgICBmb3IgKGxldCBsYXllciBpbiBjb25maWcubGF5ZXJzKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmxheWVyc1tsYXllcl0pIHtcbiAgICAgICAgICAgICAgICBjb25maWcubGF5ZXJzW2xheWVyXS5kYXRhID0gVXRpbHMuc3RyaW5nc1RvRnVuY3Rpb25zKGNvbmZpZy5sYXllcnNbbGF5ZXJdLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGRhdGEgc291cmNlc1xuICAgICAgICBjb25maWcuc291cmNlcyA9IFV0aWxzLnN0cmluZ3NUb0Z1bmN0aW9ucyhjb25maWcuc291cmNlcyk7IC8vIHBhcnNlIG5ldyBzb3VyY2VzXG4gICAgICAgIHNlbGYuc291cmNlcy50aWxlcyA9IHt9OyAvLyBjbGVhciBwcmV2aW91cyBzb3VyY2VzXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gY29uZmlnLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIGxldCBzb3VyY2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IERhdGFTb3VyY2UuY3JlYXRlKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZy5zb3VyY2VzW25hbWVdLCB7bmFtZX0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNvdXJjZS50aWxlZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc291cmNlcy50aWxlc1tuYW1lXSA9IHNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERpc3RyaWJ1dGUgb2JqZWN0IHNvdXJjZXMgYWNyb3NzIHdvcmtlcnNcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmlkICUgc2VsZi5udW1fd29ya2VycyA9PT0gc2VsZi5fd29ya2VyX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExvYWQgc291cmNlIGlmIG5vdCBjYWNoZWRcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zb3VyY2VzLm9iamVjdHNbbmFtZV0gPSBzb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5vYmplY3RzW3NvdXJjZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vYmplY3RzW3NvdXJjZS5uYW1lXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLmxvYWQoc2VsZi5vYmplY3RzW3NvdXJjZS5uYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhciB0aWxlIGNhY2hlIGlmIGRhdGEgc291cmNlIGNvbmZpZyBjaGFuZ2VkXG4gICAgICAgIGlmICghc2VsZi5jb25maWcuc291cmNlcyB8fFxuICAgICAgICAgICAgIXNlbGYubGFzdF9jb25maWcuc291cmNlcyB8fFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VsZi5jb25maWcuc291cmNlcykuc29tZShzID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc2VsZi5jb25maWcuc291cmNlc1tzXSkgIT09IEpTT04uc3RyaW5naWZ5KHNlbGYubGFzdF9jb25maWcuc291cmNlc1tzXSk7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgc2VsZi50aWxlcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhwYW5kIHN0eWxlc1xuICAgICAgICBjb25maWcgPSBVdGlscy5zdHJpbmdzVG9GdW5jdGlvbnMoY29uZmlnLCBTdHlsZVBhcnNlci53cmFwRnVuY3Rpb24pO1xuICAgICAgICBzZWxmLnN0eWxlcyA9IFN0eWxlTWFuYWdlci5idWlsZChjb25maWcuc3R5bGVzLCB7IGdlbmVyYXRpb246IHNlbGYuZ2VuZXJhdGlvbiB9KTtcblxuICAgICAgICAvLyBQYXJzZSBlYWNoIHRvcC1sZXZlbCBsYXllciBhcyBhIHNlcGFyYXRlIHJ1bGUgdHJlZVxuICAgICAgICBzZWxmLmxheWVycyA9IGNvbmZpZy5sYXllcnM7XG4gICAgICAgIHNlbGYucnVsZXMgPSBwYXJzZVJ1bGVzKHNlbGYubGF5ZXJzKTtcblxuICAgICAgICAvLyBTeW5jIHRldHh1cmUgaW5mbyBmcm9tIG1haW4gdGhyZWFkXG4gICAgICAgIHNlbGYuc3luY2luZ190ZXh0dXJlcyA9IHNlbGYuc3luY1RleHR1cmVzKGNvbmZpZy50ZXh0dXJlcyk7XG5cbiAgICAgICAgLy8gUmV0dXJuIHByb21pc2UgZm9yIHdoZW4gY29uZmlnIHJlZnJlc2ggZmluaXNoZXNcbiAgICAgICAgc2VsZi5jb25maWd1cmluZyA9IHNlbGYuc3luY2luZ190ZXh0dXJlcy50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIFV0aWxzLmxvZygnZGVidWcnLCBgdXBkYXRlZCBjb25maWdgKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2hlbiBjb25maWcgcmVmcmVzaCBpcyBmaW5pc2hlZFxuICAgIGF3YWl0Q29uZmlndXJhdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNvbmZpZ3VyaW5nO1xuICAgIH0sXG5cbiAgICAvLyBCdWlsZCBhIHRpbGU6IGxvYWQgZnJvbSB0aWxlIHNvdXJjZSBpZiBidWlsZGluZyBmb3IgZmlyc3QgdGltZSwgb3RoZXJ3aXNlIHJlYnVpbGQgd2l0aCBleGlzdGluZyBkYXRhXG4gICAgYnVpbGRUaWxlICh7IHRpbGUgfSkge1xuICAgICAgICAvLyBUaWxlIGNhY2hlZD9cbiAgICAgICAgaWYgKHNlbGYuZ2V0VGlsZSh0aWxlLmtleSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSBsb2FkaW5nP1xuICAgICAgICAgICAgaWYgKHNlbGYuZ2V0VGlsZSh0aWxlLmtleSkubG9hZGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aWxlIGNhY2hlXG4gICAgICAgIHRpbGUgPSBzZWxmLnRpbGVzW3RpbGUua2V5XSA9IE9iamVjdC5hc3NpZ24oc2VsZi5nZXRUaWxlKHRpbGUua2V5KSB8fCB7fSwgdGlsZSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGNvbmZpZyAoc3R5bGVzLCBldGMuKSwgdGhlbiBidWlsZCB0aWxlXG4gICAgICAgIHJldHVybiBzZWxmLmF3YWl0Q29uZmlndXJhdGlvbigpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gRmlyc3QgdGltZSBidWlsZGluZyB0aGUgdGlsZVxuICAgICAgICAgICAgaWYgKHRpbGUubG9hZGVkICE9PSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIHRpbGUubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRpbGUubG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRpbGUuZXJyb3IgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubG9hZFRpbGVTb3VyY2VEYXRhKHRpbGUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLmdldFRpbGUodGlsZS5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMubG9nKCd0cmFjZScsIGBzdG9wIHRpbGUgYnVpbGQgYWZ0ZXIgZGF0YSBzb3VyY2UgbG9hZCBiZWNhdXNlIHRpbGUgd2FzIHJlbW92ZWQ6ICR7dGlsZS5rZXl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXYXJuIGFuZCBjb250aW51ZSBvbiBkYXRhIHNvdXJjZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbGUuc291cmNlX2RhdGEuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVdGlscy5sb2coJ3dhcm4nLCBgdGlsZSBsb2FkIGVycm9yKHMpIGZvciAke3RpbGUua2V5fTogJHt0aWxlLnNvdXJjZV9kYXRhLmVycm9yfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFRpbGUuYnVpbGRHZW9tZXRyeSh0aWxlLCBzZWxmLmxheWVycywgc2VsZi5ydWxlcywgc2VsZi5zdHlsZXMpLnRoZW4oa2V5cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShXb3JrZXJCcm9rZXIucmV0dXJuV2l0aFRyYW5zZmVyYWJsZXMoeyB0aWxlOiBUaWxlLnNsaWNlKHRpbGUsIGtleXMpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZS5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUuZXJyb3IgPSBlcnJvci50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMubG9nKCdlcnJvcicsIGB0aWxlIGxvYWQgZXJyb3IgZm9yICR7dGlsZS5rZXl9OiAke3RpbGUuZXJyb3J9IGF0OiAke2Vycm9yLnN0YWNrfWApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgdGlsZTogVGlsZS5zbGljZSh0aWxlKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaWxlIGFscmVhZHkgbG9hZGVkLCBqdXN0IHJlYnVpbGRcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIFV0aWxzLmxvZygndHJhY2UnLCBgdXNlZCB3b3JrZXIgY2FjaGUgZm9yIHRpbGUgJHt0aWxlLmtleX1gKTtcblxuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIGdlb21ldHJ5XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRpbGUuYnVpbGRHZW9tZXRyeSh0aWxlLCBzZWxmLmxheWVycywgc2VsZi5ydWxlcywgc2VsZi5zdHlsZXMpLnRoZW4oa2V5cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBXb3JrZXJCcm9rZXIucmV0dXJuV2l0aFRyYW5zZmVyYWJsZXMoeyB0aWxlOiBUaWxlLnNsaWNlKHRpbGUsIGtleXMpIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gTG9hZCB0aGlzIHRpbGUncyBkYXRhIHNvdXJjZVxuICAgIGxvYWRUaWxlU291cmNlRGF0YSAodGlsZSkge1xuICAgICAgICBpZiAoc2VsZi5zb3VyY2VzLnRpbGVzW3RpbGUuc291cmNlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuc291cmNlcy50aWxlc1t0aWxlLnNvdXJjZV0ubG9hZCh0aWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRpbGUuc291cmNlX2RhdGEgPSB7IGVycm9yOiBgRGF0YSBzb3VyY2UgJyR7dGlsZS5zb3VyY2V9JyBub3QgZm91bmRgIH07XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRpbGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFRpbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBzZWxmLnRpbGVzW2tleV07XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aWxlXG4gICAgcmVtb3ZlVGlsZSAoa2V5KSB7XG4gICAgICAgIHZhciB0aWxlID0gc2VsZi50aWxlc1trZXldO1xuXG4gICAgICAgIGlmICh0aWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENhbmNlbCBpZiBsb2FkaW5nXG4gICAgICAgICAgICBpZiAodGlsZS5sb2FkaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgVXRpbHMubG9nKCd0cmFjZScsIGBjYW5jZWwgdGlsZSBsb2FkIGZvciAke2tleX1gKTtcbiAgICAgICAgICAgICAgICB0aWxlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgVGlsZS5jYW5jZWwodGlsZSk7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGNhY2hlXG4gICAgICAgICAgICBGZWF0dXJlU2VsZWN0aW9uLmNsZWFyVGlsZShrZXkpO1xuICAgICAgICAgICAgZGVsZXRlIHNlbGYudGlsZXNba2V5XTtcbiAgICAgICAgICAgIFV0aWxzLmxvZygndHJhY2UnLCBgcmVtb3ZlIHRpbGUgZnJvbSBjYWNoZSBmb3IgJHtrZXl9YCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gR2V0IGEgZmVhdHVyZSBmcm9tIHRoZSBzZWxlY3Rpb24gbWFwXG4gICAgZ2V0RmVhdHVyZVNlbGVjdGlvbiAoeyBpZCwga2V5IH0gPSB7fSkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gRmVhdHVyZVNlbGVjdGlvbi5tYXBba2V5XTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgZmVhdHVyZTogKHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24uZmVhdHVyZSlcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gUmVzZXRzIHRoZSBmZWF0dXJlIHNlbGVjdGlvbiBzdGF0ZVxuICAgIHJlc2V0RmVhdHVyZVNlbGVjdGlvbiAoKSB7XG4gICAgICAgIEZlYXR1cmVTZWxlY3Rpb24ucmVzZXQoKTtcbiAgICB9LFxuXG4gICAgLy8gU2VsZWN0aW9uIG1hcCBzaXplIGZvciB0aGlzIHdvcmtlclxuICAgIGdldEZlYXR1cmVTZWxlY3Rpb25NYXBTaXplICgpIHtcbiAgICAgICAgcmV0dXJuIEZlYXR1cmVTZWxlY3Rpb24uZ2V0TWFwU2l6ZSgpO1xuICAgIH0sXG5cbiAgICAvLyBUZXh0dXJlIGluZm8gbmVlZHMgdG8gYmUgc3luY2VkIGZyb20gbWFpbiB0aHJlYWQsIGUuZy4gd2lkdGgvaGVpZ2h0LCB3aGljaCB3ZSBvbmx5IGtub3cgYWZ0ZXIgdGhlIHRleHR1cmUgbG9hZHNcbiAgICBzeW5jVGV4dHVyZXMgKHRleF9jb25maWcpIHtcbiAgICAgICAgbGV0IHRleHR1cmVzID0gW107XG4gICAgICAgIGlmICh0ZXhfY29uZmlnKSB7XG4gICAgICAgICAgICB0ZXh0dXJlcy5wdXNoKC4uLk9iamVjdC5rZXlzKHRleF9jb25maWcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFV0aWxzLmxvZygndHJhY2UnLCAnc3luYyB0ZXh0dXJlcyB0byB3b3JrZXI6JywgdGV4dHVyZXMpO1xuICAgICAgICBpZiAodGV4dHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuc3luY1RleHR1cmVzVG9Xb3JrZXIodGV4dHVyZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9LFxuXG4gICAgLy8gU3luYyBkZXZpY2UgcGl4ZWwgcmF0aW8gZnJvbSBtYWluIHRocmVhZFxuICAgIHVwZGF0ZURldmljZVBpeGVsUmF0aW8gKGRldmljZV9waXhlbF9yYXRpbykge1xuICAgICAgICBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8gPSBkZXZpY2VfcGl4ZWxfcmF0aW87XG4gICAgfSxcblxuICAgIC8vIFByb2ZpbGluZyBoZWxwZXJzXG4gICAgcHJvZmlsZSAobmFtZSkge1xuICAgICAgICBjb25zb2xlLnByb2ZpbGUoYHdvcmtlciAke3NlbGYuX3dvcmtlcl9pZH06ICR7bmFtZX1gKTtcbiAgICB9LFxuXG4gICAgcHJvZmlsZUVuZCAobmFtZSkge1xuICAgICAgICBjb25zb2xlLnByb2ZpbGVFbmQoYHdvcmtlciAke3NlbGYuX3dvcmtlcl9pZH06ICR7bmFtZX1gKTtcbiAgICB9XG5cbn0pO1xuXG5Xb3JrZXJCcm9rZXIuYWRkVGFyZ2V0KCdzZWxmJywgc2VsZik7XG5cbn1cbiIsImltcG9ydCBUZXh0dXJlIGZyb20gJy4vZ2wvdGV4dHVyZSc7XG5pbXBvcnQgV29ya2VyQnJva2VyIGZyb20gJy4vdXRpbHMvd29ya2VyX2Jyb2tlcic7XG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGZWF0dXJlU2VsZWN0aW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKGdsLCB3b3JrZXJzKSB7XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy53b3JrZXJzID0gd29ya2VyczsgLy8gcG9vbCBvZiB3b3JrZXJzIHRvIHJlcXVlc3QgZmVhdHVyZSBsb29rLXVwcyBmcm9tLCBrZXllZCBieSBpZFxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICBpbml0KCkge1xuICAgICAgICAvLyBTZWxlY3Rpb24gc3RhdGUgdHJhY2tpbmdcbiAgICAgICAgdGhpcy5yZXF1ZXN0cyA9IHt9OyAvLyBwZW5kaW5nIHNlbGVjdGlvbiByZXF1ZXN0c1xuICAgICAgICB0aGlzLmZlYXR1cmUgPSBudWxsOyAvLyBjdXJyZW50bHkgc2VsZWN0ZWQgZmVhdHVyZVxuICAgICAgICB0aGlzLnJlYWRfZGVsYXkgPSA1OyAvLyBkZWxheSB0aW1lIGZyb20gc2VsZWN0aW9uIHJlbmRlciB0byBmcmFtZWJ1ZmZlciBzYW1wbGUsIHRvIGF2b2lkIENQVS9HUFUgc3luYyBsb2NrXG4gICAgICAgIHRoaXMucmVhZF9kZWxheV90aW1lciA9IG51bGw7IC8vIGN1cnJlbnQgdGltZXIgKHNldFRpbWVvdXQpIGZvciBkZWxheWVkIHNlbGVjdGlvbiByZWFkc1xuXG4gICAgICAgIHRoaXMucGl4ZWwgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgdGhpcy5waXhlbDMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnBpeGVsLmJ1ZmZlcik7XG5cbiAgICAgICAgLy8gRnJhbWUgYnVmZmVyIGZvciBzZWxlY3Rpb25cbiAgICAgICAgLy8gVE9ETzogaW5pdGlhdGUgbGF6aWx5IGluIGNhc2Ugd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnkgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMuZmJvID0gdGhpcy5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCB0aGlzLmZibyk7XG4gICAgICAgIHRoaXMuZmJvX3NpemUgPSB7IHdpZHRoOiAyNTYsIGhlaWdodDogMjU2IH07IC8vIFRPRE86IG1ha2UgY29uZmlndXJhYmxlIC8gYWRhcHRpdmUgYmFzZWQgb24gY2FudmFzIHNpemVcbiAgICAgICAgdGhpcy5mYm9fc2l6ZS5hc3BlY3QgPSB0aGlzLmZib19zaXplLndpZHRoIC8gdGhpcy5mYm9fc2l6ZS5oZWlnaHQ7XG5cbiAgICAgICAgLy8gVGV4dHVyZSBmb3IgdGhlIEZCTyBjb2xvciBhdHRhY2htZW50XG4gICAgICAgIHZhciBmYm9fdGV4dHVyZSA9IFRleHR1cmUuY3JlYXRlKCB0aGlzLmdsLCAnc2VsZWN0aW9uX2ZibycsIHsgZmlsdGVyaW5nOiAnbmVhcmVzdCcgfSk7XG4gICAgICAgIGZib190ZXh0dXJlLnNldERhdGEodGhpcy5mYm9fc2l6ZS53aWR0aCwgdGhpcy5mYm9fc2l6ZS5oZWlnaHQsIG51bGwsIHsgZmlsdGVyaW5nOiAnbmVhcmVzdCcgfSk7XG4gICAgICAgIHRoaXMuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGhpcy5nbC5GUkFNRUJVRkZFUiwgdGhpcy5nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGhpcy5nbC5URVhUVVJFXzJELCBmYm9fdGV4dHVyZS50ZXh0dXJlLCAwKTtcblxuICAgICAgICAvLyBSZW5kZXJidWZmZXIgZm9yIHRoZSBGQk8gZGVwdGggYXR0YWNobWVudFxuICAgICAgICB2YXIgZmJvX2RlcHRoX3JiID0gdGhpcy5nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgdGhpcy5nbC5iaW5kUmVuZGVyYnVmZmVyKHRoaXMuZ2wuUkVOREVSQlVGRkVSLCBmYm9fZGVwdGhfcmIpO1xuICAgICAgICB0aGlzLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UodGhpcy5nbC5SRU5ERVJCVUZGRVIsIHRoaXMuZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHRoaXMuZmJvX3NpemUud2lkdGgsIHRoaXMuZmJvX3NpemUuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCB0aGlzLmdsLkRFUFRIX0FUVEFDSE1FTlQsIHRoaXMuZ2wuUkVOREVSQlVGRkVSLCBmYm9fZGVwdGhfcmIpO1xuXG4gICAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmdsICYmIHRoaXMuZmJvKSB7XG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuZmJvKTtcbiAgICAgICAgICAgIHRoaXMuZmJvID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogZnJlZSB0ZXh0dXJlP1xuICAgIH1cblxuICAgIGJpbmQoKSB7XG4gICAgICAgIC8vIFN3aXRjaCB0byBGQk9cbiAgICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgdGhpcy5mYm8pO1xuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuZmJvX3NpemUud2lkdGgsIHRoaXMuZmJvX3NpemUuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBSZXF1ZXN0IGZlYXR1cmUgc2VsZWN0aW9uXG4gICAgLy8gUnVucyBhc3luY2hyb25vdXNseSwgc2NoZWR1bGVzIHNlbGVjdGlvbiBidWZmZXIgdG8gYmUgdXBkYXRlZFxuICAgIGdldEZlYXR1cmVBdChwb2ludCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gUXVldWUgcmVxdWVzdHMgZm9yIGZlYXR1cmUgc2VsZWN0aW9uLCBhbmQgdGhleSB3aWxsIGJlIHBpY2tlZCB1cCBieSB0aGUgcmVuZGVyIGxvb3BcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uX3JlcXVlc3RfaWQgPSAodGhpcy5zZWxlY3Rpb25fcmVxdWVzdF9pZCArIDEpIHx8IDA7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RzW3RoaXMuc2VsZWN0aW9uX3JlcXVlc3RfaWRdID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwb2ludCcsXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuc2VsZWN0aW9uX3JlcXVlc3RfaWQsXG4gICAgICAgICAgICAgICAgcG9pbnQsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFueSBwZW5kaW5nIHNlbGVjdGlvbiByZXF1ZXN0c1xuICAgIHBlbmRpbmdSZXF1ZXN0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdHM7XG4gICAgfVxuXG4gICAgY2xlYXJQZW5kaW5nUmVxdWVzdHMoKSB7XG4gICAgICAgIGZvciAodmFyIHIgaW4gdGhpcy5yZXF1ZXN0cykge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzW3JdO1xuXG4gICAgICAgICAgICAvLyBUaGlzIHJlcXVlc3Qgd2FzIGFscmVhZHkgc2VudCB0byB0aGUgd29ya2VyLCB3ZSdyZSBqdXN0IGF3YWl0aW5nIGl0cyByZXBseVxuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc2VudCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZWplY3QgcmVxdWVzdCBzaW5jZSBpdCB3aWxsIG5ldmVyIGJlIGZ1bGZpbGxlZFxuICAgICAgICAgICAgLy8gVE9ETzogcGFzcyBhIHJlYXNvbiBmb3IgcmVqZWN0aW9uP1xuICAgICAgICAgICAgcmVxdWVzdC5yZWplY3QoeyByZXF1ZXN0IH0pO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVxdWVzdHNbcl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZWFkIHBlbmRpbmcgcmVzdWx0cyBmcm9tIHRoZSBzZWxlY3Rpb24gYnVmZmVyLiBDYWxsZWQgYWZ0ZXIgcmVuZGVyaW5nIHRvIHNlbGVjdGlvbiBidWZmZXIuXG4gICAgcmVhZCgpIHtcbiAgICAgICAgLy8gRGVsYXkgcmVhZGluZyB0aGUgcGl4ZWwgcmVzdWx0IGZyb20gdGhlIHNlbGVjdGlvbiBidWZmZXIgdG8gYXZvaWQgQ1BVL0dQVSBzeW5jIGxvY2suXG4gICAgICAgIC8vIENhbGxpbmcgcmVhZFBpeGVscyBzeW5jaHJvbm91c2x5IGNhdXNlZCBhIG1hc3NpdmUgcGVyZm9ybWFuY2UgaGl0LCBwcmVzdW1hYmx5IHNpbmNlIGl0XG4gICAgICAgIC8vIGZvcmNlZCB0aGlzIGZ1bmN0aW9uIHRvIHdhaXQgZm9yIHRoZSBHUFUgdG8gZmluaXNoIHJlbmRlcmluZyBhbmQgcmV0cmlldmUgdGhlIHRleHR1cmUgY29udGVudHMuXG4gICAgICAgIGlmICh0aGlzLnJlYWRfZGVsYXlfdGltZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhZF9kZWxheV90aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFkX2RlbGF5X3RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZmJvKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgciBpbiB0aGlzLnJlcXVlc3RzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzW3JdO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyByZXF1ZXN0IHdhcyBhbHJlYWR5IHNlbnQgdG8gdGhlIHdvcmtlciwgd2UncmUganVzdCBhd2FpdGluZyBpdHMgcmVwbHlcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgb3RoZXIgc2VsZWN0aW9uIHR5cGVzLCBzdWNoIGFzIGZlYXR1cmVzIHdpdGhpbiBhIGJveFxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnR5cGUgIT09ICdwb2ludCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgc2VsZWN0aW9uIG1hcCBhZ2FpbnN0IEZCT1xuICAgICAgICAgICAgICAgIGdsLnJlYWRQaXhlbHMoXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IocmVxdWVzdC5wb2ludC54ICogdGhpcy5mYm9fc2l6ZS53aWR0aCksXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKDEgLSByZXF1ZXN0LnBvaW50LnkpICogdGhpcy5mYm9fc2l6ZS5oZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICAxLCAxLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnBpeGVsKTtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZV9rZXkgPSAodGhpcy5waXhlbFswXSArICh0aGlzLnBpeGVsWzFdIDw8IDgpICsgKHRoaXMucGl4ZWxbMl0gPDwgMTYpICsgKHRoaXMucGl4ZWxbM10gPDwgMjQpKSA+Pj4gMDtcblxuICAgICAgICAgICAgICAgIC8vIElmIGZlYXR1cmUgZm91bmQsIGFzayBhcHByb3ByaWF0ZSB3ZWIgd29ya2VyIHRvIGxvb2t1cCBmZWF0dXJlXG4gICAgICAgICAgICAgICAgdmFyIHdvcmtlcl9pZCA9IHRoaXMucGl4ZWxbM107XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtlcl9pZCAhPT0gMjU1KSB7IC8vIDI1NSBpbmRpY2F0ZXMgYW4gZW1wdHkgc2VsZWN0aW9uIGJ1ZmZlciBwaXhlbFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy53b3JrZXJzW3dvcmtlcl9pZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud29ya2Vyc1t3b3JrZXJfaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZWxmLmdldEZlYXR1cmVTZWxlY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaWQ6IHJlcXVlc3QuaWQsIGtleTogZmVhdHVyZV9rZXkgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoUmVhZChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5vIGZlYXR1cmUgZm91bmQsIGJ1dCBzdGlsbCBuZWVkIHRvIHJlc29sdmUgcHJvbWlzZVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaFJlYWQoeyBpZDogcmVxdWVzdC5pZCwgZmVhdHVyZTogbnVsbCB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXF1ZXN0LnNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG4gICAgICAgIH0sIHRoaXMucmVhZF9kZWxheSk7XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIG9uIG1haW4gdGhyZWFkIHdoZW4gYSB3ZWIgd29ya2VyIGZpbmRzIGEgZmVhdHVyZSBpbiB0aGUgc2VsZWN0aW9uIGJ1ZmZlclxuICAgIGZpbmlzaFJlYWQgKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzW21lc3NhZ2UuaWRdO1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihcIkZlYXR1cmVTZWxlY3Rpb24uZmluaXNoUmVhZCgpOiBjb3VsZCBub3QgZmluZCBtZXNzYWdlXCIsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuOyAvLyByZXF1ZXN0IHdhcyBjbGVhcmVkIGJlZm9yZSBpdCByZXR1cm5lZFxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZlYXR1cmUgPSBtZXNzYWdlLmZlYXR1cmU7XG4gICAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmICgoZmVhdHVyZSAhPSBudWxsICYmIHRoaXMuZmVhdHVyZSA9PSBudWxsKSB8fFxuICAgICAgICAgICAgKGZlYXR1cmUgPT0gbnVsbCAmJiB0aGlzLmZlYXR1cmUgIT0gbnVsbCkgfHxcbiAgICAgICAgICAgIChmZWF0dXJlICE9IG51bGwgJiYgdGhpcy5mZWF0dXJlICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShmZWF0dXJlKSAhPT0gSlNPTi5zdHJpbmdpZnkodGhpcy5mZWF0dXJlKSkpIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mZWF0dXJlID0gZmVhdHVyZTsgLy8gc3RvcmUgdGhlIG1vc3QgcmVjZW50bHkgc2VsZWN0ZWQgZmVhdHVyZVxuXG4gICAgICAgIC8vIFJlc29sdmUgdGhlIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdC5yZXNvbHZlKHsgZmVhdHVyZSwgY2hhbmdlZCwgcmVxdWVzdCB9KTtcbiAgICAgICAgZGVsZXRlIHRoaXMucmVxdWVzdHNbbWVzc2FnZS5pZF07IC8vIGRvbmUgcHJvY2Vzc2luZyB0aGlzIHJlcXVlc3RcbiAgICB9XG5cblxuICAgIC8vIFNlbGVjdGlvbiBtYXAgZ2VuZXJhdGlvblxuICAgIC8vIEVhY2ggd29ya2VyIHdpbGwgY3JlYXRlIGl0cyBvd24gaW5kZXBlbmRlbnQsICdsb2NhbCcgc2VsZWN0aW9uIG1hcFxuXG4gICAgLy8gQ3JlYXRlIGEgdW5pcXVlIDMyLWJpdCBjb2xvciB0byBpZGVudGlmeSBhIGZlYXR1cmVcbiAgICAvLyBXb3JrZXJzIGluZGVwZW5kZW50bHkgY3JlYXRlL21vZGlmeSBzZWxlY3Rpb24gY29sb3JzIGluIHRoZWlyIG93biB0aHJlYWRzLCBidXQgd2UgYWxzb1xuICAgIC8vIG5lZWQgdGhlIG1haW4gdGhyZWFkIHRvIGtub3cgd2hlcmUgZWFjaCBmZWF0dXJlIGNvbG9yIG9yaWdpbmF0ZWQuIFRvIGFjY29tcGxpc2ggdGhpcyxcbiAgICAvLyB3ZSBwYXJ0aXRpb24gdGhlIG1hcCBieSBzZXR0aW5nIHRoZSA0dGggY29tcG9uZW50IChhbHBoYSBjaGFubmVsKSB0byB0aGUgd29ya2VyJ3MgaWQuXG4gICAgc3RhdGljIG1ha2VFbnRyeSh0aWxlKSB7XG4gICAgICAgIC8vIDMyLWJpdCBjb2xvciBrZXlcbiAgICAgICAgdGhpcy5tYXBfZW50cnkrKztcbiAgICAgICAgdmFyIGlyID0gdGhpcy5tYXBfZW50cnkgJiAyNTU7XG4gICAgICAgIHZhciBpZyA9ICh0aGlzLm1hcF9lbnRyeSA+PiA4KSAmIDI1NTtcbiAgICAgICAgdmFyIGliID0gKHRoaXMubWFwX2VudHJ5ID4+IDE2KSAmIDI1NTtcbiAgICAgICAgdmFyIGlhID0gdGhpcy5tYXBfcHJlZml4O1xuICAgICAgICB2YXIgciA9IGlyIC8gMjU1O1xuICAgICAgICB2YXIgZyA9IGlnIC8gMjU1O1xuICAgICAgICB2YXIgYiA9IGliIC8gMjU1O1xuICAgICAgICB2YXIgYSA9IGlhIC8gMjU1O1xuICAgICAgICB2YXIga2V5ID0gKGlyICsgKGlnIDw8IDgpICsgKGliIDw8IDE2KSArIChpYSA8PCAyNCkpID4+PiAwOyAvLyBuZWVkIHVuc2lnbmVkIHJpZ2h0IHNoaWZ0IHRvIGNvbnZlcnQgdG8gcG9zaXRpdmUgI1xuXG4gICAgICAgIHRoaXMubWFwW2tleV0gPSB7XG4gICAgICAgICAgICBjb2xvcjogW3IsIGcsIGIsIGFdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1hcF9zaXplKys7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aWxlLXNwZWNpZmljIHRyYWNraW5nIGluZm9cbiAgICAgICAgaWYgKCF0aGlzLnRpbGVzW3RpbGUua2V5XSkge1xuICAgICAgICAgICAgdGhpcy50aWxlc1t0aWxlLmtleV0gPSB7XG4gICAgICAgICAgICAgICAgZW50cmllczogW10sICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IG9mIGZlYXR1cmUgZW50cmllcyBpbiB0aGlzIHRocmVhZFxuICAgICAgICAgICAgICAgIHRpbGU6IHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1YnNldCBvZiB0aWxlIHByb3BlcnRpZXMgdG8gcGFzcyBiYWNrIHdpdGggZmVhdHVyZVxuICAgICAgICAgICAgICAgICAgICBrZXk6IHRpbGUua2V5LFxuICAgICAgICAgICAgICAgICAgICBjb29yZHM6IHRpbGUuY29vcmRzLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZV96b29tOiB0aWxlLnN0eWxlX3pvb20sXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogdGlsZS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb246IHRpbGUuZ2VuZXJhdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRpbGVzW3RpbGUua2V5XS5lbnRyaWVzLnB1c2goa2V5KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5tYXBba2V5XTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbWFrZUNvbG9yKGZlYXR1cmUsIHRpbGUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcy5tYWtlRW50cnkodGlsZSk7XG4gICAgICAgIHNlbGVjdG9yLmZlYXR1cmUgPSB7XG4gICAgICAgICAgICBpZDogZmVhdHVyZS5pZCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IGZlYXR1cmUucHJvcGVydGllcyxcbiAgICAgICAgICAgIGxheWVyczogY29udGV4dC5sYXllcnMsXG4gICAgICAgICAgICB0aWxlOiB0aGlzLnRpbGVzW3RpbGUua2V5XS50aWxlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLmNvbG9yO1xuICAgIH1cblxuICAgIHN0YXRpYyByZXNldCgpIHtcbiAgICAgICAgdGhpcy50aWxlcyA9IHt9O1xuICAgICAgICB0aGlzLm1hcCA9IHt9O1xuICAgICAgICB0aGlzLm1hcF9zaXplID0gMDtcbiAgICAgICAgdGhpcy5tYXBfZW50cnkgPSAwO1xuICAgIH1cblxuICAgIHN0YXRpYyBjbGVhclRpbGUoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLnRpbGVzW2tleV0pIHtcbiAgICAgICAgICAgIHRoaXMudGlsZXNba2V5XS5lbnRyaWVzLmZvckVhY2goayA9PiBkZWxldGUgdGhpcy5tYXBba10pO1xuICAgICAgICAgICAgdGhpcy5tYXBfc2l6ZSAtPSB0aGlzLnRpbGVzW2tleV0uZW50cmllcy5sZW5ndGg7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy50aWxlc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldE1hcFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcF9zaXplO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZXRQcmVmaXgocHJlZml4KSB7XG4gICAgICAgIHRoaXMubWFwX3ByZWZpeCA9IHByZWZpeDtcbiAgICB9XG5cbn1cblxuLy8gU3RhdGljIHByb3BlcnRpZXNcbkZlYXR1cmVTZWxlY3Rpb24ubWFwID0ge307ICAgLy8gdGhpcyB3aWxsIGJlIHVuaXF1ZSBwZXIgbW9kdWxlIGluc3RhbmNlIChzbyB1bmlxdWUgcGVyIHdvcmtlcilcbkZlYXR1cmVTZWxlY3Rpb24udGlsZXMgPSB7fTsgLy8gc2VsZWN0aW9uIGtleXMsIGJ5IHRpbGVcbkZlYXR1cmVTZWxlY3Rpb24ubWFwX3NpemUgPSAwO1xuRmVhdHVyZVNlbGVjdGlvbi5tYXBfZW50cnkgPSAwO1xuRmVhdHVyZVNlbGVjdGlvbi5tYXBfcHJlZml4ID0gMDsgLy8gc2V0IGJ5IHdvcmtlciB0byB3b3JrZXIgaWQgI1xuRmVhdHVyZVNlbGVjdGlvbi5kZWZhdWx0Q29sb3IgPSBbMCwgMCwgMCwgMV07XG4iLCIvKmpzaGludCB3b3JrZXI6IHRydWUgKi9cbmltcG9ydCBHZW8gZnJvbSAnLi4vZ2VvJztcbmltcG9ydCB7TWV0aG9kTm90SW1wbGVtZW50ZWR9IGZyb20gJy4uL3V0aWxzL2Vycm9ycyc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhU291cmNlIHtcblxuICAgIGNvbnN0cnVjdG9yIChjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7IC8vIHNhdmUgb3JpZ2luYWwgY29uZmlnXG4gICAgICAgIHRoaXMuaWQgPSBjb25maWcuaWQ7XG4gICAgICAgIHRoaXMubmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgICAgICB0aGlzLnBhZF9zY2FsZSA9IGNvbmZpZy5wYWRfc2NhbGUgfHwgMC4wMDAxOyAvLyBzY2FsZSB0aWxlIHVwIGJ5IHNtYWxsIGZhY3RvciB0byBjb3ZlciBzZWFtc1xuICAgICAgICB0aGlzLmRlZmF1bHRfd2luZGluZyA9IG51bGw7IC8vIHdpbmRpbmcgb3JkZXIgd2lsbCBhZGFwdCB0byBkYXRhIHNvdXJjZVxuXG4gICAgICAgIC8vIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBzb3VyY2UgZGF0YVxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IGNvbmZpZy50cmFuc2Zvcm07XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmJpbmQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcHRpb25hbCBhZGRpdGlvbmFsIGRhdGEgdG8gcGFzcyB0byB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuZXh0cmFfZGF0YSA9IGNvbmZpZy5leHRyYV9kYXRhO1xuXG4gICAgICAgIC8vIE9wdGlvbmFsIGFkZGl0aW9uYWwgc2NyaXB0cyBtYWRlIGF2YWlsYWJsZSB0byB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uXG4gICAgICAgIGlmICh0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJyAmJiBjb25maWcuc2NyaXB0cykge1xuICAgICAgICAgICAgY29uZmlnLnNjcmlwdHMuZm9yRWFjaChmdW5jdGlvbihzLCBzaSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydFNjcmlwdHMocyk7XG4gICAgICAgICAgICAgICAgICAgIFV0aWxzLmxvZygnaW5mbycsICdEYXRhU291cmNlOiBsb2FkZWQgbGlicmFyeTogJyArIHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBVdGlscy5sb2coJ2Vycm9yJywgJ0RhdGFTb3VyY2U6IGZhaWxlZCB0byBsb2FkIGxpYnJhcnk6ICcgKyBzKTtcbiAgICAgICAgICAgICAgICAgICAgVXRpbHMubG9nKCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3Zlcnpvb20gd2lsbCBhcHBseSBmb3Igem9vbXMgaGlnaGVyIHRoYW4gdGhpc1xuICAgICAgICB0aGlzLm1heF96b29tID0gY29uZmlnLm1heF96b29tIHx8IEdlby5kZWZhdWx0X3NvdXJjZV9tYXhfem9vbTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSB0aWxlIHNvdXJjZSBieSB0eXBlLCBmYWN0b3J5LXN0eWxlXG4gICAgc3RhdGljIGNyZWF0ZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChEYXRhU291cmNlLnR5cGVzW3NvdXJjZS50eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhU291cmNlLnR5cGVzW3NvdXJjZS50eXBlXShzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYSBkYXRhIHNvdXJjZSBkZWZpbml0aW9uIGNoYW5nZWRcbiAgICBzdGF0aWMgY2hhbmdlZCAoc291cmNlLCBwcmV2X3NvdXJjZSkge1xuICAgICAgICBpZiAoIXNvdXJjZSB8fCAhcHJldl9zb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGN1ciA9IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS5jb25maWcsIHsgaWQ6IG51bGwgfSk7IC8vIG51bGwgb3V0IGlkcyBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIGNvbXBhcmUgdGhlbVxuICAgICAgICBsZXQgcHJldiA9IE9iamVjdC5hc3NpZ24oe30sIHByZXZfc291cmNlLmNvbmZpZywgeyBpZDogbnVsbCB9KTtcblxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY3VyKSAhPT0gSlNPTi5zdHJpbmdpZnkocHJldik7XG4gICAgfVxuXG4gICAgLy8gTWVyY2F0b3IgcHJvamVjdGlvblxuICAgIHN0YXRpYyBwcm9qZWN0RGF0YSAoc291cmNlKSB7XG4gICAgICAgIHZhciB0aW1lciA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICBmb3IgKHZhciB0IGluIHNvdXJjZS5sYXllcnMpIHtcbiAgICAgICAgICAgIHZhciBudW1fZmVhdHVyZXMgPSBzb3VyY2UubGF5ZXJzW3RdLmZlYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGY9MDsgZiA8IG51bV9mZWF0dXJlczsgZisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBzb3VyY2UubGF5ZXJzW3RdLmZlYXR1cmVzW2ZdO1xuICAgICAgICAgICAgICAgIEdlby50cmFuc2Zvcm1HZW9tZXRyeShmZWF0dXJlLmdlb21ldHJ5LCBjb29yZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBbeCwgeV0gPSBHZW8ubGF0TG5nVG9NZXRlcnMoY29vcmQpO1xuICAgICAgICAgICAgICAgICAgICBjb29yZFswXSA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkWzFdID0geTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb3VyY2UuZGVidWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc291cmNlLmRlYnVnLnByb2plY3Rpb24gPSArbmV3IERhdGUoKSAtIHRpbWVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgIFJlLXNjYWxlIGdlb21ldHJpZXMgd2l0aGluIGVhY2ggc291cmNlIHRvIGludGVybmFsIHRpbGUgdW5pdHNcbiAgICAqL1xuICAgIHN0YXRpYyBzY2FsZURhdGEgKHNvdXJjZSwge2Nvb3Jkczoge3p9LCBtaW4sIG1heH0pIHtcbiAgICAgICAgbGV0IHVuaXRzX3Blcl9tZXRlciA9IEdlby51bml0c1Blck1ldGVyKHopO1xuICAgICAgICBmb3IgKHZhciB0IGluIHNvdXJjZS5sYXllcnMpIHtcbiAgICAgICAgICAgIHZhciBudW1fZmVhdHVyZXMgPSBzb3VyY2UubGF5ZXJzW3RdLmZlYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGY9MDsgZiA8IG51bV9mZWF0dXJlczsgZisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBzb3VyY2UubGF5ZXJzW3RdLmZlYXR1cmVzW2ZdO1xuICAgICAgICAgICAgICAgIEdlby50cmFuc2Zvcm1HZW9tZXRyeShmZWF0dXJlLmdlb21ldHJ5LCBjb29yZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkWzBdID0gKGNvb3JkWzBdIC0gbWluLngpICogdW5pdHNfcGVyX21ldGVyO1xuICAgICAgICAgICAgICAgICAgICBjb29yZFsxXSA9IChjb29yZFsxXSAtIG1pbi55KSAqIHVuaXRzX3Blcl9tZXRlciAqIC0xOyAvLyBmbGlwIGNvb3JkcyBwb3NpdGl2ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9hZChkZXN0KSB7XG4gICAgICAgIGRlc3Quc291cmNlX2RhdGEgPSB7fTtcbiAgICAgICAgZGVzdC5zb3VyY2VfZGF0YS5sYXllcnMgPSB7fTtcbiAgICAgICAgZGVzdC5wYWRfc2NhbGUgPSB0aGlzLnBhZF9zY2FsZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZChkZXN0KS50aGVuKChkZXN0KSA9PiB7XG4gICAgICAgICAgICAvLyBQb3N0LXByb2Nlc3NpbmdcbiAgICAgICAgICAgIGZvciAobGV0IGxheWVyIGluIGRlc3Quc291cmNlX2RhdGEubGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBkZXN0LnNvdXJjZV9kYXRhLmxheWVyc1tsYXllcl07XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5mZWF0dXJlcykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBHZW8udHJhbnNmb3JtR2VvbWV0cnkoZmVhdHVyZS5nZW9tZXRyeSwgY29vcmQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsaXAgWSBjb29yZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZFsxXSA9IC1jb29yZFsxXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNsaWdodGx5IHNjYWxlIHVwIHRpbGUgdG8gY292ZXIgc2VhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYWRfc2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRbMF0gPSBNYXRoLnJvdW5kKGNvb3JkWzBdICogKDEgKyB0aGlzLnBhZF9zY2FsZSkgLSAoR2VvLnRpbGVfc2NhbGUgKiB0aGlzLnBhZF9zY2FsZS8yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkWzFdID0gTWF0aC5yb3VuZChjb29yZFsxXSAqICgxICsgdGhpcy5wYWRfc2NhbGUpIC0gKEdlby50aWxlX3NjYWxlICogdGhpcy5wYWRfc2NhbGUvMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgZmlyc3QgZW5jb3VudGVyZWQgcG9seWdvbiB3aW5kaW5nIG9yZGVyIGFzIGRlZmF1bHQgZm9yIGRhdGEgc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURlZmF1bHRXaW5kaW5nKGZlYXR1cmUuZ2VvbWV0cnkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlc3QuZGVmYXVsdF93aW5kaW5nID0gdGhpcy5kZWZhdWx0X3dpbmRpbmcgfHwgJ0NDVyc7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFN1Yi1jbGFzc2VzIG11c3QgaW1wbGVtZW50XG4gICAgX2xvYWQoZGVzdCkge1xuICAgICAgICB0aHJvdyBuZXcgTWV0aG9kTm90SW1wbGVtZW50ZWQoJ19sb2FkJyk7XG4gICAgfVxuXG4gICAgLy8gSW5mZXIgd2luZGluZyBmb3IgZGF0YSBzb3VyY2UgZnJvbSBmaXJzdCByaW5nIG9mIHByb3ZpZGVkIGdlb21ldHJ5XG4gICAgdXBkYXRlRGVmYXVsdFdpbmRpbmcgKGdlb20pIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdF93aW5kaW5nID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChnZW9tLnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdF93aW5kaW5nID0gR2VvLnJpbmdXaW5kaW5nKGdlb20uY29vcmRpbmF0ZXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZ2VvbS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdF93aW5kaW5nID0gR2VvLnJpbmdXaW5kaW5nKGdlb20uY29vcmRpbmF0ZXNbMF1bMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRfd2luZGluZztcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBhIG5ldyBkYXRhIHNvdXJjZSB0eXBlLCB1bmRlciBhIHR5cGUgbmFtZVxuICAgIHN0YXRpYyByZWdpc3Rlcih0eXBlX2NsYXNzLCB0eXBlX25hbWUpIHtcbiAgICAgICAgaWYgKCF0eXBlX2NsYXNzIHx8ICF0eXBlX25hbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIERhdGFTb3VyY2UudHlwZXNbdHlwZV9uYW1lXSA9IHR5cGVfY2xhc3M7XG4gICAgfVxuXG59XG5cbkRhdGFTb3VyY2UudHlwZXMgPSB7fTsgLy8gc2V0IG9mIHN1cHBvcnRlZCBkYXRhIHNvdXJjZSBjbGFzc2VzLCByZWZlcmVuY2VkIGJ5IHR5cGUgbmFtZVxuXG5cbi8qKiogR2VuZXJpYyBuZXR3b3JrIGxvYWRpbmcgc291cmNlIC0gYWJzdHJhY3QgY2xhc3MgKioqL1xuXG5leHBvcnQgY2xhc3MgTmV0d29ya1NvdXJjZSBleHRlbmRzIERhdGFTb3VyY2Uge1xuXG4gICAgY29uc3RydWN0b3IgKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihzb3VyY2UpO1xuICAgICAgICB0aGlzLnVybCA9IFV0aWxzLmFkZFBhcmFtc1RvVVJMKHNvdXJjZS51cmwsIHNvdXJjZS51cmxfcGFyYW1zKTtcbiAgICAgICAgdGhpcy5yZXNwb25zZV90eXBlID0gXCJcIjsgLy8gdXNlIHRvIHNldCBleHBsaWNpdCBYSFIgdHlwZVxuXG4gICAgICAgIGlmICh0aGlzLnVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignTmV0d29yayBkYXRhIHNvdXJjZSBtdXN0IHByb3ZpZGUgYSBgdXJsYCBwcm9wZXJ0eScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2xvYWQgKGRlc3QpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMuZm9ybWF0VXJsKHRoaXMudXJsLCBkZXN0KTtcblxuICAgICAgICBsZXQgc291cmNlX2RhdGEgPSBkZXN0LnNvdXJjZV9kYXRhO1xuICAgICAgICBzb3VyY2VfZGF0YS51cmwgPSB1cmw7XG4gICAgICAgIGRlc3QuZGVidWcgPSBkZXN0LmRlYnVnIHx8IHt9O1xuICAgICAgICBkZXN0LmRlYnVnLm5ldHdvcmsgPSArbmV3IERhdGUoKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc291cmNlX2RhdGEuZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgLy8gRm9yIHRlc3RpbmcgbmV0d29yayBlcnJvcnNcbiAgICAgICAgICAgIC8vIHZhciBwcm9taXNlID0gVXRpbHMuaW8odXJsLCA2MCAqIDEwMCwgdGhpcy5yZXNwb25zZV90eXBlKTtcbiAgICAgICAgICAgIC8vIGlmIChNYXRoLnJhbmRvbSgpIDwgLjcpIHtcbiAgICAgICAgICAgIC8vICAgICBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QoRXJyb3IoJ2Zha2UgZGF0YSBzb3VyY2UgZXJyb3InKSk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBwcm9taXNlLnRoZW4oKGJvZHkpID0+IHtcbiAgICAgICAgICAgIGxldCBwcm9taXNlID0gVXRpbHMuaW8odXJsLCA2MCAqIDEwMDAsIHRoaXMucmVzcG9uc2VfdHlwZSk7XG4gICAgICAgICAgICBzb3VyY2VfZGF0YS5yZXF1ZXN0ID0gcHJvbWlzZS5yZXF1ZXN0O1xuXG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oKGJvZHkpID0+IHtcbiAgICAgICAgICAgICAgICBkZXN0LmRlYnVnLnJlc3BvbnNlX3NpemUgPSBib2R5Lmxlbmd0aCB8fCBib2R5LmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgZGVzdC5kZWJ1Zy5uZXR3b3JrID0gK25ldyBEYXRlKCkgLSBkZXN0LmRlYnVnLm5ldHdvcms7XG4gICAgICAgICAgICAgICAgZGVzdC5kZWJ1Zy5wYXJzaW5nID0gK25ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVNvdXJjZURhdGEoZGVzdCwgc291cmNlX2RhdGEsIGJvZHkpO1xuICAgICAgICAgICAgICAgIGRlc3QuZGVidWcucGFyc2luZyA9ICtuZXcgRGF0ZSgpIC0gZGVzdC5kZWJ1Zy5wYXJzaW5nO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGVzdCk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBzb3VyY2VfZGF0YS5lcnJvciA9IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkZXN0KTsgLy8gcmVzb2x2ZSByZXF1ZXN0IGJ1dCBwYXNzIGFsb25nIGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU3ViLWNsYXNzZXMgbXVzdCBpbXBsZW1lbnQ6XG5cbiAgICBmb3JtYXRVcmwgKHVybF90ZW1wbGF0ZSwgZGVzdCkge1xuICAgICAgICB0aHJvdyBuZXcgTWV0aG9kTm90SW1wbGVtZW50ZWQoJ2Zvcm1hdFVybCcpO1xuICAgIH1cblxuICAgIHBhcnNlU291cmNlRGF0YSAoZGVzdCwgc291cmNlLCByZXBvbnNlKSB7XG4gICAgICAgIHRocm93IG5ldyBNZXRob2ROb3RJbXBsZW1lbnRlZCgncGFyc2VTb3VyY2VEYXRhJyk7XG4gICAgfVxufVxuXG5cbi8qKiogR2VuZXJpYyBuZXR3b3JrIHRpbGUgbG9hZGluZyAtIGFic3RyYWN0IGNsYXNzICoqKi9cblxuZXhwb3J0IGNsYXNzIE5ldHdvcmtUaWxlU291cmNlIGV4dGVuZHMgTmV0d29ya1NvdXJjZSB7XG5cbiAgICBjb25zdHJ1Y3RvciAoc291cmNlKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZSk7XG5cbiAgICAgICAgdGhpcy50aWxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudXJsX2hvc3RzID0gbnVsbDtcbiAgICAgICAgdmFyIGhvc3RfbWF0Y2ggPSB0aGlzLnVybC5tYXRjaCgve3M6XFxbKFtefStdKylcXF19Lyk7XG4gICAgICAgIGlmIChob3N0X21hdGNoICE9IG51bGwgJiYgaG9zdF9tYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLnVybF9ob3N0cyA9IGhvc3RfbWF0Y2hbMV0uc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHRoaXMubmV4dF9ob3N0ID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvcm1hdFVybCh1cmxfdGVtcGxhdGUsIHRpbGUpIHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IEdlby53cmFwVGlsZSh0aWxlLmNvb3JkcywgeyB4OiB0cnVlIH0pO1xuICAgICAgICBsZXQgdXJsID0gdXJsX3RlbXBsYXRlLnJlcGxhY2UoJ3t4fScsIGNvb3Jkcy54KS5yZXBsYWNlKCd7eX0nLCBjb29yZHMueSkucmVwbGFjZSgne3p9JywgY29vcmRzLnopO1xuXG4gICAgICAgIGlmICh0aGlzLnVybF9ob3N0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgve3M6XFxbKFtefStdKylcXF19LywgdGhpcy51cmxfaG9zdHNbdGhpcy5uZXh0X2hvc3RdKTtcbiAgICAgICAgICAgIHRoaXMubmV4dF9ob3N0ID0gKHRoaXMubmV4dF9ob3N0ICsgMSkgJSB0aGlzLnVybF9ob3N0cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG5cbiAgICAvLyBDaGVja3MgZm9yIHRoZSB4L3kveiB0aWxlIHBhdHRlcm4gaW4gVVJMIHRlbXBsYXRlXG4gICAgdXJsSGFzVGlsZVBhdHRlcm4odXJsKSB7XG4gICAgICAgIHJldHVybiB1cmwgJiZcbiAgICAgICAgICAgIHVybC5zZWFyY2goJ3t4fScpID4gLTEgJiZcbiAgICAgICAgICAgIHVybC5zZWFyY2goJ3t5fScpID4gLTEgJiZcbiAgICAgICAgICAgIHVybC5zZWFyY2goJ3t6fScpID4gLTE7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgRGF0YVNvdXJjZSwge05ldHdvcmtTb3VyY2UsIE5ldHdvcmtUaWxlU291cmNlfSBmcm9tICcuL2RhdGFfc291cmNlJztcbmltcG9ydCB7TVZUU291cmNlfSBmcm9tICcuL212dCc7XG5pbXBvcnQgR2VvIGZyb20gJy4uL2dlbyc7XG5cbi8vIEZvciB0aWxpbmcgR2VvSlNPTiBjbGllbnQtc2lkZVxuaW1wb3J0IGdlb2pzb252dCBmcm9tICdnZW9qc29uLXZ0JztcblxuLyoqXG4gR2VvSlNPTiBzdGFuZGFsb25lIChub24tdGlsZWQpIHNvdXJjZVxuIFVzZXMgZ2VvanNvbi12dCBzcGxpdCBpbnRvIHRpbGVzIGNsaWVudC1zaWRlXG4qL1xuXG5leHBvcnQgY2xhc3MgR2VvSlNPTlNvdXJjZSBleHRlbmRzIE5ldHdvcmtTb3VyY2Uge1xuXG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZSk7XG4gICAgICAgIHRoaXMudGlsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxvYWRfZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMudGlsZV9pbmRleGVzID0ge307IC8vIGdlb2pzb24tdnQgdGlsZSBpbmRpY2VzLCBieSBsYXllciBuYW1lXG4gICAgICAgIHRoaXMubWF4X3pvb20gPSBNYXRoLm1heCh0aGlzLm1heF96b29tIHx8IDAsIDE1KTsgLy8gVE9ETzogbWF4IHpvb20gPCAxNSBjYXVzZXMgYXJ0aWZhY3RzL25vLWRyYXcgYXQgMjAsIGludmVzdGlnYXRlXG4gICAgICAgIHRoaXMucGFkX3NjYWxlID0gMDsgLy8gd2UgZG9uJ3Qgd2FudCBwYWRkaW5nIG9uIGF1dG8tdGlsZWQgc291cmNlc1xuICAgIH1cblxuICAgIF9sb2FkKGRlc3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRfZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkX2RhdGEgPSBzdXBlci5fbG9hZCh7IHNvdXJjZV9kYXRhOiB7IGxheWVyczoge30gfSB9KS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBsYXllcnMgPSBkYXRhLnNvdXJjZV9kYXRhLmxheWVycztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsYXllcl9uYW1lIGluIGxheWVycykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbGVfaW5kZXhlc1tsYXllcl9uYW1lXSA9IGdlb2pzb252dChsYXllcnNbbGF5ZXJfbmFtZV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFpvb206IHRoaXMubWF4X3pvb20sICAvLyBtYXggem9vbSB0byBwcmVzZXJ2ZSBkZXRhaWwgb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHRvbGVyYW5jZTogMywgLy8gc2ltcGxpZmljYXRpb24gdG9sZXJhbmNlIChoaWdoZXIgbWVhbnMgc2ltcGxlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudDogR2VvLnRpbGVfc2NhbGUsIC8vIHRpbGUgZXh0ZW50IChib3RoIHdpZHRoIGFuZCBoZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXI6IDAgICAgIC8vIHRpbGUgYnVmZmVyIG9uIGVhY2ggc2lkZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRfZGF0YS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGxheWVyX25hbWUgaW4gdGhpcy50aWxlX2luZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICBkZXN0LnNvdXJjZV9kYXRhLmxheWVyc1tsYXllcl9uYW1lXSA9IHRoaXMuZ2V0VGlsZUZlYXR1cmVzKGRlc3QsIGxheWVyX25hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldFRpbGVGZWF0dXJlcyh0aWxlLCBsYXllcl9uYW1lKSB7XG4gICAgICAgIGxldCBjb29yZHMgPSBHZW8ud3JhcFRpbGUodGlsZS5jb29yZHMsIHsgeDogdHJ1ZSB9KTtcblxuICAgICAgICAvLyByZXF1ZXN0IGEgcGFydGljdWxhciB0aWxlXG4gICAgICAgIGxldCB0ID0gdGhpcy50aWxlX2luZGV4ZXNbbGF5ZXJfbmFtZV0uZ2V0VGlsZShjb29yZHMueiwgY29vcmRzLngsIGNvb3Jkcy55KTtcblxuICAgICAgICAvLyBDb252ZXJ0IGZyb20gTVZULXN0eWxlIEpTT04gc3RydWN0IHRvIEdlb0pTT05cbiAgICAgICAgbGV0IGNvbGxlY3Rpb247XG4gICAgICAgIGlmICh0ICYmIHQuZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgICAgICAgICBmZWF0dXJlczogW11cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAobGV0IGZlYXR1cmUgb2YgdC5mZWF0dXJlcykge1xuICAgICAgICAgICAgICAgIC8vIEdlb0pTT04gZmVhdHVyZVxuICAgICAgICAgICAgICAgIGxldCBmID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB7fSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogZmVhdHVyZS50YWdzXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLnR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZi5nZW9tZXRyeS5jb29yZGluYXRlcyA9IGZlYXR1cmUuZ2VvbWV0cnkubWFwKGNvb3JkID0+IFtjb29yZFswXSwgY29vcmRbMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgZi5nZW9tZXRyeS50eXBlID0gJ011bHRpUG9pbnQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmZWF0dXJlLnR5cGUgPT09IDIgfHwgZmVhdHVyZS50eXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBmZWF0dXJlLmdlb21ldHJ5Lm1hcChyaW5nID0+XG4gICAgICAgICAgICAgICAgICAgICAgICByaW5nLm1hcChjb29yZCA9PiBbY29vcmRbMF0sIGNvb3JkWzFdXSlcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS50eXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLmdlb21ldHJ5LnR5cGUgPSAnTXVsdGlMaW5lU3RyaW5nJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLmdlb21ldHJ5ID0gTVZUU291cmNlLmRlY29kZU11bHRpUG9seWdvbihmLmdlb21ldHJ5KTsgLy8gdW4tZmxhdHRlbiByaW5nc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmZlYXR1cmVzLnB1c2goZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICBmb3JtYXRVcmwgKGRlc3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsO1xuICAgIH1cblxuICAgIHBhcnNlU291cmNlRGF0YSAodGlsZSwgc291cmNlLCByZXNwb25zZSkge1xuICAgICAgICBzb3VyY2UubGF5ZXJzID0gdGhpcy5nZXRMYXllcnMoSlNPTi5wYXJzZShyZXNwb25zZSkpO1xuICAgIH1cblxuICAgIC8vIERldGVjdCBzaW5nbGUgb3IgbXVsdGlwbGUgbGF5ZXJzIGluIHJldHVybmVkIGRhdGFcbiAgICBnZXRMYXllcnMgKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ0ZlYXR1cmUnIHx8IGRhdGEudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgX2RlZmF1bHQ6IGRhdGEgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbi8qKlxuIE1hcHplbi9PU00uVVMtc3R5bGUgR2VvSlNPTiB2ZWN0b3IgdGlsZXNcbiBAY2xhc3MgR2VvSlNPTlRpbGVTb3VyY2VcbiovXG5leHBvcnQgY2xhc3MgR2VvSlNPTlRpbGVTb3VyY2UgZXh0ZW5kcyBOZXR3b3JrVGlsZVNvdXJjZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoc291cmNlKTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgVVJMIHRpbGUgcGF0dGVybiwgaWYgbm90IGZvdW5kLCB0cmVhdCBhcyBzdGFuZGFsb25lIEdlb0pTT04vVG9wb0pTT04gb2JqZWN0XG4gICAgICAgIGlmICghdGhpcy51cmxIYXNUaWxlUGF0dGVybih0aGlzLnVybCkpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGluc3RhbmNlIHR5cGUgZnJvbSBwYXJlbnQgY2xhc3NcbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgR2VvSlNPTlRpbGVTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGluc3RhbmNlIHR5cGVcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdlb0pTT05Tb3VyY2Uoc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFBhc3MgYmFjayB0byBwYXJlbnQgY2xhc3MgdG8gaW5zdGFudGlhdGVcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwYXJzZVNvdXJjZURhdGEgKHRpbGUsIHNvdXJjZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlR2VvSlNPTihkYXRhLCB0aWxlLCBzb3VyY2UpO1xuICAgIH1cblxuICAgIHByZXBhcmVHZW9KU09OIChkYXRhLCB0aWxlLCBzb3VyY2UpIHtcbiAgICAgICAgLy8gQXBwbHkgb3B0aW9uYWwgZGF0YSB0cmFuc2Zvcm1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMudHJhbnNmb3JtKGRhdGEsIHRoaXMuZXh0cmFfZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBzb3VyY2UubGF5ZXJzID0gR2VvSlNPTlNvdXJjZS5wcm90b3R5cGUuZ2V0TGF5ZXJzKGRhdGEpO1xuXG4gICAgICAgIC8vIEEgXCJzeW50aGV0aWNcIiB0aWxlIHRoYXQgYWRqdXN0cyB0aGUgdGlsZSBtaW4gYW5jaG9yIHRvIGFjY291bnQgZm9yIHRpbGUgbG9uZ2l0dWRlIHdyYXBwaW5nXG4gICAgICAgIGxldCBhbmNob3IgPSB7XG4gICAgICAgICAgICBjb29yZHM6IHRpbGUuY29vcmRzLFxuICAgICAgICAgICAgbWluOiBHZW8ubWV0ZXJzRm9yVGlsZShHZW8ud3JhcFRpbGUodGlsZS5jb29yZHMsIHsgeDogdHJ1ZSB9KSlcbiAgICAgICAgfTtcblxuICAgICAgICBEYXRhU291cmNlLnByb2plY3REYXRhKHNvdXJjZSk7IC8vIG1lcmNhdG9yIHByb2plY3Rpb25cbiAgICAgICAgRGF0YVNvdXJjZS5zY2FsZURhdGEoc291cmNlLCBhbmNob3IpOyAvLyByZS1zY2FsZSBmcm9tIG1ldGVycyB0byBsb2NhbCB0aWxlIGNvb3Jkc1xuICAgIH1cblxufVxuXG5EYXRhU291cmNlLnJlZ2lzdGVyKEdlb0pTT05UaWxlU291cmNlLCAnR2VvSlNPTicpOyAgICAgIC8vIHByZWZlcmVkIHNob3J0ZXIgbmFtZVxuRGF0YVNvdXJjZS5yZWdpc3RlcihHZW9KU09OVGlsZVNvdXJjZSwgJ0dlb0pTT05UaWxlcycpOyAvLyBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHlcbiIsImltcG9ydCBEYXRhU291cmNlLCB7TmV0d29ya1RpbGVTb3VyY2V9IGZyb20gJy4vZGF0YV9zb3VyY2UnO1xuaW1wb3J0IEdlbyBmcm9tICcuLi9nZW8nO1xuXG5pbXBvcnQgUGJmIGZyb20gJ3BiZic7XG5pbXBvcnQge1ZlY3RvclRpbGUsIFZlY3RvclRpbGVGZWF0dXJlfSBmcm9tICd2ZWN0b3ItdGlsZSc7XG5cbi8qKlxuIE1hcGJveCBWZWN0b3IgVGlsZSBmb3JtYXRcbiBAY2xhc3MgTVZUU291cmNlXG4qL1xuZXhwb3J0IGNsYXNzIE1WVFNvdXJjZSBleHRlbmRzIE5ldHdvcmtUaWxlU291cmNlIHtcblxuICAgIGNvbnN0cnVjdG9yIChzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoc291cmNlKTtcbiAgICAgICAgdGhpcy5yZXNwb25zZV90eXBlID0gXCJhcnJheWJ1ZmZlclwiOyAvLyBiaW5hcnkgZGF0YVxuICAgIH1cblxuICAgIHBhcnNlU291cmNlRGF0YSAodGlsZSwgc291cmNlLCByZXNwb25zZSkge1xuICAgICAgICAvLyBDb252ZXJ0IE1hcGJveCB2ZWN0b3IgdGlsZSB0byBHZW9KU09OXG4gICAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpO1xuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IFBiZihkYXRhKTtcbiAgICAgICAgc291cmNlLmRhdGEgPSBuZXcgVmVjdG9yVGlsZShidWZmZXIpO1xuICAgICAgICBzb3VyY2UubGF5ZXJzID0gdGhpcy50b0dlb0pTT04oc291cmNlLmRhdGEpO1xuICAgICAgICBkZWxldGUgc291cmNlLmRhdGE7IC8vIGNvbW1lbnQgb3V0IHRvIHNhdmUgcmF3IGRhdGEgZm9yIGRlYnVnZ2luZ1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBsYXllcnMvZmVhdHVyZXMgdXNpbmcgTWFwYm94IGxpYiBBUEksIGNvbnZlcnQgdG8gR2VvSlNPTiBmZWF0dXJlc1xuICAgIC8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGgga2V5cyBmb3IgZWFjaCBsYXllciwgZS5nLiB7IGxheWVyOiBnZW9qc29uIH1cbiAgICB0b0dlb0pTT04gKHRpbGUpIHtcbiAgICAgICAgdmFyIGxheWVycyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBsIGluIHRpbGUubGF5ZXJzKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aWxlLmxheWVyc1tsXTtcbiAgICAgICAgICAgIHZhciBsYXllcl9nZW9qc29uID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgICAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBmPTA7IGYgPCBsYXllci5sZW5ndGg7IGYrKykge1xuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gbGF5ZXIuZmVhdHVyZShmKTtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZV9nZW9qc29uID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB7fSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogZmVhdHVyZS5wcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmVfZ2VvanNvbi5nZW9tZXRyeTtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBmZWF0dXJlLmxvYWRHZW9tZXRyeSgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHI9MDsgciA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByaW5nID0gY29vcmRpbmF0ZXNbcl07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGM9MDsgYyA8IHJpbmcubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpbmdbY10gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmluZ1tjXS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpbmdbY10ueVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xuXG4gICAgICAgICAgICAgICAgaWYgKFZlY3RvclRpbGVGZWF0dXJlLnR5cGVzW2ZlYXR1cmUudHlwZV0gPT09ICdQb2ludCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkudHlwZSA9ICdQb2ludCc7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFZlY3RvclRpbGVGZWF0dXJlLnR5cGVzW2ZlYXR1cmUudHlwZV0gPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS50eXBlID0gJ0xpbmVTdHJpbmcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5jb29yZGluYXRlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnR5cGUgPSAnTXVsdGlMaW5lU3RyaW5nJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChWZWN0b3JUaWxlRmVhdHVyZS50eXBlc1tmZWF0dXJlLnR5cGVdID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBNVlRTb3VyY2UuZGVjb2RlTXVsdGlQb2x5Z29uKGdlb21ldHJ5KTsgLy8gdW4tZmxhdHRlbiByaW5nc1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxheWVyX2dlb2pzb24uZmVhdHVyZXMucHVzaChmZWF0dXJlX2dlb2pzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF5ZXJzW2xdID0gbGF5ZXJfZ2VvanNvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF5ZXJzO1xuICAgIH1cblxuICAgIC8vIERlY29kZSBtdWx0aXBvbHlnb25zLCB3aGljaCBhcmUgZW5jb2RlZCBhcyBhIHNpbmdsZSBzZXQgb2YgcmluZ3NcbiAgICAvLyBXaW5kaW5nIG9yZGVyIG9mIGZpcnN0IHJpbmcgaXMgYXNzdW1lZCB0byBpbmRpY2F0ZSBleHRlcmlvciByaW5nLFxuICAgIC8vIHRoZSBvcHBvc2l0ZSB3aW5kaW5nIG9yZGVyIGluZGljYXRlcyB0aGUgc3RhcnQgb2YgYSBuZXcgcG9seWdvbi5cbiAgICBzdGF0aWMgZGVjb2RlTXVsdGlQb2x5Z29uIChnZW9tKSB7XG4gICAgICAgIGxldCBwb2x5cyA9IFtdO1xuICAgICAgICBsZXQgcG9seSA9IFtdO1xuICAgICAgICBsZXQgb3V0ZXJfd2luZGluZztcbiAgICAgICAgZm9yIChsZXQgcmluZyBvZiBnZW9tLmNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICBsZXQgd2luZGluZyA9IEdlby5yaW5nV2luZGluZyhyaW5nKTtcbiAgICAgICAgICAgIGlmICh3aW5kaW5nID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCB6ZXJvLWFyZWEgcmluZ3NcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3V0ZXJfd2luZGluZyA9IG91dGVyX3dpbmRpbmcgfHwgd2luZGluZzsgLy8gYXNzdW1lIGZpcnN0IHJpbmcgaW5kaWNhdGVzIG91dGVyIHJpbmcgd2luZGluZ1xuXG4gICAgICAgICAgICBpZiAod2luZGluZyA9PT0gb3V0ZXJfd2luZGluZyAmJiBwb2x5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwb2x5cy5wdXNoKHBvbHkpO1xuICAgICAgICAgICAgICAgIHBvbHkgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvbHkucHVzaChyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9seS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwb2x5cy5wdXNoKHBvbHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2luZ2xlIG9yIG11bHRpP1xuICAgICAgICBpZiAocG9seXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBnZW9tLnR5cGUgPSAnUG9seWdvbic7XG4gICAgICAgICAgICBnZW9tLmNvb3JkaW5hdGVzID0gcG9seXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW9tLnR5cGUgPSAnTXVsdGlQb2x5Z29uJztcbiAgICAgICAgICAgIGdlb20uY29vcmRpbmF0ZXMgPSBwb2x5cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZW9tO1xuICAgIH1cblxufVxuXG5EYXRhU291cmNlLnJlZ2lzdGVyKE1WVFNvdXJjZSwgJ01WVCcpO1xuIiwiaW1wb3J0IERhdGFTb3VyY2UgZnJvbSAnLi9kYXRhX3NvdXJjZSc7XG5pbXBvcnQge0dlb0pTT05Tb3VyY2UsIEdlb0pTT05UaWxlU291cmNlfSBmcm9tICcuL2dlb2pzb24nO1xuXG5pbXBvcnQgdG9wb2pzb24gZnJvbSAndG9wb2pzb24nO1xuXG4vKipcbiBUb3BvSlNPTiBzdGFuZGFsb25lIChub24tdGlsZWQpIHNvdXJjZVxuIFVzZXMgZ2VvanNvbi12dCBzcGxpdCBpbnRvIHRpbGVzIGNsaWVudC1zaWRlXG4qL1xuXG5leHBvcnQgY2xhc3MgVG9wb0pTT05Tb3VyY2UgZXh0ZW5kcyBHZW9KU09OU291cmNlIHtcblxuICAgIHBhcnNlU291cmNlRGF0YSAodGlsZSwgc291cmNlLCByZXNwb25zZSkge1xuICAgICAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UpO1xuICAgICAgICBkYXRhID0gdGhpcy50b0dlb0pTT04oZGF0YSk7XG4gICAgICAgIHNvdXJjZS5sYXllcnMgPSB0aGlzLmdldExheWVycyhkYXRhKTtcbiAgICB9XG5cbiAgICB0b0dlb0pTT04gKGRhdGEpIHtcbiAgICAgICAgLy8gU2luZ2xlIGxheWVyXG4gICAgICAgIGlmIChkYXRhLm9iamVjdHMgJiZcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEub2JqZWN0cykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBsZXQgbGF5ZXIgPSBPYmplY3Qua2V5cyhkYXRhLm9iamVjdHMpWzBdO1xuICAgICAgICAgICAgZGF0YSA9IHRvcG9qc29uLmZlYXR1cmUoZGF0YSwgZGF0YS5vYmplY3RzW2xheWVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGUgbGF5ZXJzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxheWVycyA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGRhdGEub2JqZWN0cykge1xuICAgICAgICAgICAgICAgIGxheWVyc1trZXldID0gdG9wb2pzb24uZmVhdHVyZShkYXRhLCBkYXRhLm9iamVjdHNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhID0gbGF5ZXJzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxufVxuXG4vKipcbiBNYXB6ZW4vT1NNLlVTLXN0eWxlIFRvcG9KU09OIHZlY3RvciB0aWxlc1xuIEBjbGFzcyBUb3BvSlNPTlRpbGVTb3VyY2VcbiovXG5leHBvcnQgY2xhc3MgVG9wb0pTT05UaWxlU291cmNlIGV4dGVuZHMgR2VvSlNPTlRpbGVTb3VyY2Uge1xuXG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIGxldCBfdGhpcyA9IHN1cGVyKHNvdXJjZSk7XG5cbiAgICAgICAgLy8gUmVwbGFjZSB3aXRoIG5vbi10aWxlZCBzb3VyY2UgaWYgdGlsZWQgc291cmNlIGZhaWxlZCB0byBpbnN0YW50aWF0ZVxuICAgICAgICBpZiAoX3RoaXMgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVG9wb0pTT05Tb3VyY2Uoc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhcnNlU291cmNlRGF0YSAodGlsZSwgc291cmNlLCByZXNwb25zZSkge1xuICAgICAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UpO1xuICAgICAgICBkYXRhID0gVG9wb0pTT05Tb3VyY2UucHJvdG90eXBlLnRvR2VvSlNPTihkYXRhKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlR2VvSlNPTihkYXRhLCB0aWxlLCBzb3VyY2UpO1xuICAgIH1cblxufVxuXG5EYXRhU291cmNlLnJlZ2lzdGVyKFRvcG9KU09OVGlsZVNvdXJjZSwgJ1RvcG9KU09OJyk7ICAgICAgICAvLyBwcmVmZXJlZCBzaG9ydGVyIG5hbWVcbkRhdGFTb3VyY2UucmVnaXN0ZXIoVG9wb0pTT05UaWxlU291cmNlLCAnVG9wb0pTT05UaWxlcycpOyAgIC8vIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eVxuXG4iLCIvLyBHZW9tZXRyeSBidWlsZGluZyBmdW5jdGlvbnNcblxuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuaW1wb3J0IEdlbyBmcm9tICcuLi9nZW8nO1xuXG5pbXBvcnQgZWFyY3V0IGZyb20gJ2VhcmN1dCc7XG5cbnZhciBCdWlsZGVycztcbmV4cG9ydCBkZWZhdWx0IEJ1aWxkZXJzID0ge307XG5cbkJ1aWxkZXJzLmRlYnVnID0gZmFsc2U7XG5cbkJ1aWxkZXJzLnRpbGVfYm91bmRzID0gW1xuICAgIHsgeDogMCwgeTogMH0sXG4gICAgeyB4OiBHZW8udGlsZV9zY2FsZSwgeTogLUdlby50aWxlX3NjYWxlIH0gLy8gVE9ETzogY29ycmVjdCBmb3IgZmxpcHBlZCB5LWF4aXM/XG5dO1xuXG5jb25zdCBkZWZhdWx0X3V2cyA9IFswLCAwLCAxLCAxXTtcbmNvbnN0IHplcm9fdmVjMiA9IFswLCAwXTtcbmNvbnN0IHVwX3ZlYzMgPSBbMCwgMCwgMV07XG5cbi8vIFJlLXNjYWxlIFVWcyBmcm9tIFswLCAxXSByYW5nZSB0byBhIHNtYWxsZXIgYXJlYSB3aXRoaW4gdGhlIGltYWdlXG5CdWlsZGVycy5nZXRUZXhjb29yZHNGb3JTcHJpdGUgPSBmdW5jdGlvbiAoYXJlYV9vcmlnaW4sIGFyZWFfc2l6ZSwgdGV4X3NpemUpIHtcbiAgICB2YXIgYXJlYV9vcmlnaW5feSA9IHRleF9zaXplWzFdIC0gYXJlYV9vcmlnaW5bMV0gLSBhcmVhX3NpemVbMV07XG5cbiAgICByZXR1cm4gW1xuICAgICAgICBhcmVhX29yaWdpblswXSAvIHRleF9zaXplWzBdLFxuICAgICAgICBhcmVhX29yaWdpbl95IC8gdGV4X3NpemVbMV0sXG4gICAgICAgIChhcmVhX3NpemVbMF0gKyBhcmVhX29yaWdpblswXSkgLyB0ZXhfc2l6ZVswXSxcbiAgICAgICAgKGFyZWFfc2l6ZVsxXSArIGFyZWFfb3JpZ2luX3kpIC8gdGV4X3NpemVbMV1cbiAgICBdO1xufTtcblxuLy8gVGVzc2VsYXRlIGEgZmxhdCAyRCBwb2x5Z29uXG4vLyB4ICYgeSBjb29yZGluYXRlcyB3aWxsIGJlIHNldCBhcyBmaXJzdCB0d28gZWxlbWVudHMgb2YgcHJvdmlkZWQgdmVydGV4X3RlbXBsYXRlXG5CdWlsZGVycy5idWlsZFBvbHlnb25zID0gZnVuY3Rpb24gKFxuICAgIHBvbHlnb25zLFxuICAgIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsXG4gICAgeyB0ZXhjb29yZF9pbmRleCwgdGV4Y29vcmRfc2NhbGUsIHRleGNvb3JkX25vcm1hbGl6ZSB9KSB7XG5cbiAgICBpZiAodGV4Y29vcmRfaW5kZXgpIHtcbiAgICAgICAgdGV4Y29vcmRfbm9ybWFsaXplID0gdGV4Y29vcmRfbm9ybWFsaXplIHx8IDE7XG4gICAgICAgIHZhciBbbWluX3UsIG1pbl92LCBtYXhfdSwgbWF4X3ZdID0gdGV4Y29vcmRfc2NhbGUgfHwgZGVmYXVsdF91dnM7XG4gICAgfVxuXG4gICAgdmFyIG51bV9wb2x5Z29ucyA9IHBvbHlnb25zLmxlbmd0aDtcbiAgICBmb3IgKHZhciBwPTA7IHAgPCBudW1fcG9seWdvbnM7IHArKykge1xuICAgICAgICB2YXIgcG9seWdvbiA9IHBvbHlnb25zW3BdO1xuXG4gICAgICAgIC8vIEZpbmQgcG9seWdvbiBleHRlbnRzIHRvIGNhbGN1bGF0ZSBVVnMsIGZpdCB0aGVtIHRvIHRoZSBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94XG4gICAgICAgIGlmICh0ZXhjb29yZF9pbmRleCkge1xuICAgICAgICAgICAgdmFyIFttaW5feCwgbWluX3ksIG1heF94LCBtYXhfeV0gPSBHZW8uZmluZEJvdW5kaW5nQm94KHBvbHlnb24pO1xuICAgICAgICAgICAgdmFyIHNwYW5feCA9IG1heF94IC0gbWluX3g7XG4gICAgICAgICAgICB2YXIgc3Bhbl95ID0gbWF4X3kgLSBtaW5feTtcbiAgICAgICAgICAgIHZhciBzY2FsZV91ID0gKG1heF91IC0gbWluX3UpIC8gc3Bhbl94O1xuICAgICAgICAgICAgdmFyIHNjYWxlX3YgPSAobWF4X3YgLSBtaW5fdikgLyBzcGFuX3k7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXNzZWxsYXRlXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IEJ1aWxkZXJzLnRyaWFuZ3VsYXRlUG9seWdvbihwb2x5Z29uKTtcblxuICAgICAgICAvLyBBZGQgdmVydGV4IGRhdGFcbiAgICAgICAgdmFyIG51bV92ZXJ0aWNlcyA9IHZlcnRpY2VzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgdj0wOyB2IDwgbnVtX3ZlcnRpY2VzOyB2KyspIHtcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1t2XTtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVswXSA9IHZlcnRleFswXTtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVsxXSA9IHZlcnRleFsxXTtcblxuICAgICAgICAgICAgLy8gQWRkIFVWc1xuICAgICAgICAgICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XG4gICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMF0gPSAoKHZlcnRleFswXSAtIG1pbl94KSAqIHNjYWxlX3UgKyBtaW5fdSkgKiB0ZXhjb29yZF9ub3JtYWxpemU7XG4gICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMV0gPSAoKHZlcnRleFsxXSAtIG1pbl95KSAqIHNjYWxlX3YgKyBtaW5fdikgKiB0ZXhjb29yZF9ub3JtYWxpemU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZlcnRleF9kYXRhLmFkZFZlcnRleCh2ZXJ0ZXhfdGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gVGVzc2VsYXRlIGFuZCBleHRydWRlIGEgZmxhdCAyRCBwb2x5Z29uIGludG8gYSBzaW1wbGUgM0QgbW9kZWwgd2l0aCBmaXhlZCBoZWlnaHQgYW5kIGFkZCB0byBHTCB2ZXJ0ZXggYnVmZmVyXG5CdWlsZGVycy5idWlsZEV4dHJ1ZGVkUG9seWdvbnMgPSBmdW5jdGlvbiAoXG4gICAgcG9seWdvbnMsXG4gICAgeiwgaGVpZ2h0LCBtaW5faGVpZ2h0LFxuICAgIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsXG4gICAgbm9ybWFsX2luZGV4LFxuICAgIG5vcm1hbF9ub3JtYWxpemUsXG4gICAge1xuICAgICAgICByZW1vdmVfdGlsZV9lZGdlcyxcbiAgICAgICAgdGlsZV9lZGdlX3RvbGVyYW5jZSxcbiAgICAgICAgdGV4Y29vcmRfaW5kZXgsXG4gICAgICAgIHRleGNvb3JkX3NjYWxlLFxuICAgICAgICB0ZXhjb29yZF9ub3JtYWxpemUsXG4gICAgICAgIHdpbmRpbmdcbiAgICB9KSB7XG5cbiAgICAvLyBUb3BcbiAgICB2YXIgbWluX3ogPSB6ICsgKG1pbl9oZWlnaHQgfHwgMCk7XG4gICAgdmFyIG1heF96ID0geiArIGhlaWdodDtcbiAgICB2ZXJ0ZXhfdGVtcGxhdGVbMl0gPSBtYXhfejtcbiAgICBCdWlsZGVycy5idWlsZFBvbHlnb25zKHBvbHlnb25zLCB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLCB7IHRleGNvb3JkX2luZGV4LCB0ZXhjb29yZF9zY2FsZSwgdGV4Y29vcmRfbm9ybWFsaXplIH0pO1xuXG4gICAgLy8gV2FsbHNcbiAgICAvLyBGaXQgVVZzIHRvIHdhbGwgcXVhZFxuICAgIGlmICh0ZXhjb29yZF9pbmRleCkge1xuICAgICAgICB0ZXhjb29yZF9ub3JtYWxpemUgPSB0ZXhjb29yZF9ub3JtYWxpemUgfHwgMTtcbiAgICAgICAgdmFyIFttaW5fdSwgbWluX3YsIG1heF91LCBtYXhfdl0gPSB0ZXhjb29yZF9zY2FsZSB8fCBkZWZhdWx0X3V2cztcbiAgICAgICAgdmFyIHRleGNvb3JkcyA9IFtcbiAgICAgICAgICAgIFttaW5fdSwgbWF4X3ZdLFxuICAgICAgICAgICAgW21pbl91LCBtaW5fdl0sXG4gICAgICAgICAgICBbbWF4X3UsIG1pbl92XSxcblxuICAgICAgICAgICAgW21heF91LCBtaW5fdl0sXG4gICAgICAgICAgICBbbWF4X3UsIG1heF92XSxcbiAgICAgICAgICAgIFttaW5fdSwgbWF4X3ZdXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgdmFyIG51bV9wb2x5Z29ucyA9IHBvbHlnb25zLmxlbmd0aDtcbiAgICBmb3IgKHZhciBwPTA7IHAgPCBudW1fcG9seWdvbnM7IHArKykge1xuICAgICAgICB2YXIgcG9seWdvbiA9IHBvbHlnb25zW3BdO1xuXG4gICAgICAgIGZvciAodmFyIHE9MDsgcSA8IHBvbHlnb24ubGVuZ3RoOyBxKyspIHtcbiAgICAgICAgICAgIHZhciBjb250b3VyID0gcG9seWdvbltxXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgdz0wOyB3IDwgY29udG91ci5sZW5ndGggLSAxOyB3KyspIHtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlX3RpbGVfZWRnZXMgJiYgQnVpbGRlcnMub3V0c2lkZVRpbGUoY29udG91clt3XSwgY29udG91clt3KzFdLCB0aWxlX2VkZ2VfdG9sZXJhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gZG9uJ3QgZXh0cnVkZSB0aWxlIGVkZ2VzXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2FsbCBvcmRlciBpcyBkZXBlbmRlbnQgb24gd2luZGluZyBvcmRlciwgc28gdGhhdCBub3JtYWxzIGZhY2Ugb3V0d2FyZFxuICAgICAgICAgICAgICAgIGxldCB3MCwgdzE7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRpbmcgPT09ICdDQ1cnKSB7XG4gICAgICAgICAgICAgICAgICAgIHcwID0gdztcbiAgICAgICAgICAgICAgICAgICAgdzEgPSB3KzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3MCA9IHcrMTtcbiAgICAgICAgICAgICAgICAgICAgdzEgPSB3O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFR3byB0cmlhbmdsZXMgZm9yIHRoZSBxdWFkIGZvcm1lZCBieSBlYWNoIHZlcnRleCBwYWlyLCBnb2luZyBmcm9tIGJvdHRvbSB0byB0b3AgaGVpZ2h0XG4gICAgICAgICAgICAgICAgdmFyIHdhbGxfdmVydGljZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIFtjb250b3VyW3cxXVswXSwgY29udG91clt3MV1bMV0sIG1heF96XSxcbiAgICAgICAgICAgICAgICAgICAgW2NvbnRvdXJbdzFdWzBdLCBjb250b3VyW3cxXVsxXSwgbWluX3pdLFxuICAgICAgICAgICAgICAgICAgICBbY29udG91clt3MF1bMF0sIGNvbnRvdXJbdzBdWzFdLCBtaW5fel0sXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIFtjb250b3VyW3cwXVswXSwgY29udG91clt3MF1bMV0sIG1pbl96XSxcbiAgICAgICAgICAgICAgICAgICAgW2NvbnRvdXJbdzBdWzBdLCBjb250b3VyW3cwXVsxXSwgbWF4X3pdLFxuICAgICAgICAgICAgICAgICAgICBbY29udG91clt3MV1bMF0sIGNvbnRvdXJbdzFdWzFdLCBtYXhfel1cbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FsYyB0aGUgbm9ybWFsIG9mIHRoZSB3YWxsIGZyb20gdXAgdmVjdG9yIGFuZCBvbmUgc2VnbWVudCBvZiB0aGUgd2FsbCB0cmlhbmdsZXNcbiAgICAgICAgICAgICAgICBsZXQgd2FsbF92ZWMgPSBWZWN0b3Iubm9ybWFsaXplKFtjb250b3VyW3cxXVswXSAtIGNvbnRvdXJbdzBdWzBdLCBjb250b3VyW3cxXVsxXSAtIGNvbnRvdXJbdzBdWzFdLCAwXSk7XG4gICAgICAgICAgICAgICAgbGV0IG5vcm1hbCA9IFZlY3Rvci5jcm9zcyh1cF92ZWMzLCB3YWxsX3ZlYyk7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdmVydGV4IHRlbXBsYXRlIHdpdGggY3VycmVudCBzdXJmYWNlIG5vcm1hbFxuICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtub3JtYWxfaW5kZXggKyAwXSA9IG5vcm1hbFswXSAqIG5vcm1hbF9ub3JtYWxpemU7XG4gICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW25vcm1hbF9pbmRleCArIDFdID0gbm9ybWFsWzFdICogbm9ybWFsX25vcm1hbGl6ZTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbbm9ybWFsX2luZGV4ICsgMl0gPSBub3JtYWxbMl0gKiBub3JtYWxfbm9ybWFsaXplO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd3Y9MDsgd3YgPCB3YWxsX3ZlcnRpY2VzLmxlbmd0aDsgd3YrKykge1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbMF0gPSB3YWxsX3ZlcnRpY2VzW3d2XVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlWzFdID0gd2FsbF92ZXJ0aWNlc1t3dl1bMV07XG4gICAgICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVsyXSA9IHdhbGxfdmVydGljZXNbd3ZdWzJdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXhjb29yZF9pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMF0gPSB0ZXhjb29yZHNbd3ZdWzBdICogdGV4Y29vcmRfbm9ybWFsaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMV0gPSB0ZXhjb29yZHNbd3ZdWzFdICogdGV4Y29vcmRfbm9ybWFsaXplO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmVydGV4X2RhdGEuYWRkVmVydGV4KHZlcnRleF90ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gQnVpbGQgdGVzc2VsbGF0ZWQgdHJpYW5nbGVzIGZvciBhIHBvbHlsaW5lXG52YXIgY29ybmVyc0ZvckNhcCA9IHtcbiAgICBidXR0OiAwLFxuICAgIHNxdWFyZTogMixcbiAgICByb3VuZDogM1xufTtcblxudmFyIHRyaWFuZ2xlc0ZvckpvaW4gPSB7XG4gICAgbWl0ZXI6IDAsXG4gICAgYmV2ZWw6IDEsXG4gICAgcm91bmQ6IDNcbn07XG5cbkJ1aWxkZXJzLmJ1aWxkUG9seWxpbmVzID0gZnVuY3Rpb24gKFxuICAgIGxpbmVzLFxuICAgIHdpZHRoLFxuICAgIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsXG4gICAge1xuICAgICAgICBjbG9zZWRfcG9seWdvbixcbiAgICAgICAgcmVtb3ZlX3RpbGVfZWRnZXMsXG4gICAgICAgIHRpbGVfZWRnZV90b2xlcmFuY2UsXG4gICAgICAgIHRleGNvb3JkX2luZGV4LFxuICAgICAgICB0ZXhjb29yZF9zY2FsZSxcbiAgICAgICAgdGV4Y29vcmRfbm9ybWFsaXplLFxuICAgICAgICBzY2FsaW5nX2luZGV4LFxuICAgICAgICBzY2FsaW5nX25vcm1hbGl6ZSxcbiAgICAgICAgam9pbiwgY2FwLFxuICAgICAgICBtaXRlcl9saW1pdFxuICAgIH0pIHtcblxuICAgIHZhciBjb3JuZXJzT25DYXAgPSBjb3JuZXJzRm9yQ2FwW2NhcF0gfHwgMDsgICAgICAgICAvLyBkZWZhdWx0ICdidXR0J1xuICAgIHZhciB0cmlhbmdsZXNPbkpvaW4gPSB0cmlhbmdsZXNGb3JKb2luW2pvaW5dIHx8IDA7ICAvLyBkZWZhdWx0ICdtaXRlcidcblxuICAgIC8vIENvbmZpZ3VyZSBtaXRlciBsaW1pdFxuICAgIGlmICh0cmlhbmdsZXNPbkpvaW4gPT09IDApIHtcbiAgICAgICAgbWl0ZXJfbGltaXQgPSBtaXRlcl9saW1pdCB8fCAzOyAvLyBkZWZhdWx0IG1pdGVyIGxpbWl0XG4gICAgICAgIHZhciBtaXRlcl9sZW5fc3EgPSBtaXRlcl9saW1pdCAqIG1pdGVyX2xpbWl0O1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHZhcmlhYmxlc1xuICAgIGlmICh0ZXhjb29yZF9pbmRleCkge1xuICAgICAgICB0ZXhjb29yZF9ub3JtYWxpemUgPSB0ZXhjb29yZF9ub3JtYWxpemUgfHwgMTtcbiAgICAgICAgdmFyIFttaW5fdSwgbWluX3YsIG1heF91LCBtYXhfdl0gPSB0ZXhjb29yZF9zY2FsZSB8fCBkZWZhdWx0X3V2cztcbiAgICB9XG5cbiAgICAvLyBWYWx1ZXMgdGhhdCBhcmUgY29uc3RhbnQgZm9yIGVhY2ggbGluZSBhbmQgYXJlIHBhc3NlZCB0byBoZWxwZXIgZnVuY3Rpb25zXG4gICAgdmFyIGNvbnN0YW50cyA9IHtcbiAgICAgICAgdmVydGV4X2RhdGEsXG4gICAgICAgIHZlcnRleF90ZW1wbGF0ZSxcbiAgICAgICAgaGFsZldpZHRoOiB3aWR0aC8yLFxuICAgICAgICB2ZXJ0aWNlczogW10sXG4gICAgICAgIHNjYWxpbmdfaW5kZXgsXG4gICAgICAgIHNjYWxpbmdfbm9ybWFsaXplLFxuICAgICAgICBzY2FsaW5nVmVjczogc2NhbGluZ19pbmRleCAmJiBbXSxcbiAgICAgICAgdGV4Y29vcmRfaW5kZXgsXG4gICAgICAgIHRleGNvb3JkczogdGV4Y29vcmRfaW5kZXggJiYgW10sXG4gICAgICAgIHRleGNvb3JkX25vcm1hbGl6ZSxcbiAgICAgICAgbWluX3UsIG1pbl92LCBtYXhfdSwgbWF4X3YsXG4gICAgICAgIG5QYWlyczogMFxuICAgIH07XG5cbiAgICBmb3IgKHZhciBsbiA9IDA7IGxuIDwgbGluZXMubGVuZ3RoOyBsbisrKSB7XG4gICAgICAgIC8vIFJlbW92ZSBkdXBlIHBvaW50cyBmcm9tIGxpbmVzXG4gICAgICAgIHZhciBsaW5lID0gZGVkdXBlTGluZShsaW5lc1tsbl0sIGNsb3NlZF9wb2x5Z29uKTtcbiAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCBpZiBubyB2YWxpZCBsaW5lIHJlbWFpbmluZ1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpbmVTaXplID0gbGluZS5sZW5ndGg7XG5cbiAgICAgICAgLy8gSWdub3JlIG5vbi1saW5lc1xuICAgICAgICBpZiAobGluZVNpemUgPCAyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBJbml0aWFsaXplIHZhcmlhYmxlc1xuICAgICAgICB2YXIgY29vcmRQcmV2ID0gWzAsIDBdLCAvLyBQcmV2aW91cyBwb2ludCBjb29yZGluYXRlc1xuICAgICAgICAgICAgY29vcmRDdXJyID0gWzAsIDBdLCAvLyBDdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzXG4gICAgICAgICAgICBjb29yZE5leHQgPSBbMCwgMF07IC8vIE5leHQgcG9pbnQgY29vcmRpbmF0ZXNcblxuICAgICAgICB2YXIgbm9ybVByZXYgPSBbMCwgMF0sICAvLyBSaWdodCBub3JtYWwgdG8gc2VnbWVudCBiZXR3ZWVuIHByZXZpb3VzIGFuZCBjdXJyZW50IG1fcG9pbnRzXG4gICAgICAgICAgICBub3JtQ3VyciA9IFswLCAwXSwgIC8vIFJpZ2h0IG5vcm1hbCBhdCBjdXJyZW50IHBvaW50LCBzY2FsZWQgZm9yIG1pdGVyIGpvaW50XG4gICAgICAgICAgICBub3JtTmV4dCA9IFswLCAwXTsgIC8vIFJpZ2h0IG5vcm1hbCB0byBzZWdtZW50IGJldHdlZW4gY3VycmVudCBhbmQgbmV4dCBtX3BvaW50c1xuXG4gICAgICAgIHZhciBpc1ByZXYgPSBmYWxzZSxcbiAgICAgICAgICAgIGlzTmV4dCA9IHRydWU7XG5cbiAgICAgICAgLy8gQWRkIHZlcnRpY2VzIHRvIGJ1ZmZlciBhY2NvcmRpbmcgdG8gdGhlaXIgaW5kZXhcbiAgICAgICAgaW5kZXhQYWlycyhjb25zdGFudHMpO1xuXG4gICAgICAgIC8vIERvIHRoaXMgd2l0aCB0aGUgcmVzdCAoZXhjZXB0IHRoZSBsYXN0IG9uZSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lU2l6ZSA7IGkrKykge1xuXG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBhIG5leHQgb25lP1xuICAgICAgICAgICAgaXNOZXh0ID0gaSsxIDwgbGluZVNpemU7XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXYpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHByZXZpb3VzIG9uZSwgY29weSB0aGUgY3VycmVudCAocHJldmlvdXMpIHZhbHVlcyBvbiAqUHJldlxuICAgICAgICAgICAgICAgIGNvb3JkUHJldiA9IGNvb3JkQ3VycjtcbiAgICAgICAgICAgICAgICBub3JtUHJldiA9IFZlY3Rvci5ub3JtYWxpemUoVmVjdG9yLnBlcnAoY29vcmRQcmV2LCBsaW5lW2ldKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDAgJiYgY2xvc2VkX3BvbHlnb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHRoZSBmaXJzdCBwb2ludCBhbmQgaXMgYSBjbG9zZWQgcG9seWdvblxuXG4gICAgICAgICAgICAgICAgdmFyIG5lZWRUb0Nsb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlX3RpbGVfZWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoQnVpbGRlcnMub3V0c2lkZVRpbGUobGluZVtpXSwgbGluZVtsaW5lU2l6ZS0yXSwgdGlsZV9lZGdlX3RvbGVyYW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRUb0Nsb3NlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobmVlZFRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRQcmV2ID0gbGluZVtsaW5lU2l6ZS0yXTtcbiAgICAgICAgICAgICAgICAgICAgbm9ybVByZXYgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKGNvb3JkUHJldiwgbGluZVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICBpc1ByZXYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXNzaWduIGN1cnJlbnQgY29vcmRpbmF0ZVxuICAgICAgICAgICAgY29vcmRDdXJyID0gbGluZVtpXTtcblxuICAgICAgICAgICAgaWYgKGlzTmV4dCkge1xuICAgICAgICAgICAgICAgIGNvb3JkTmV4dCA9IGxpbmVbaSsxXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xvc2VkX3BvbHlnb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHRoZSBsYXN0IHBvaW50IGluIGEgY2xvc2VkIHBvbHlnb25cbiAgICAgICAgICAgICAgICBjb29yZE5leHQgPSBsaW5lWzFdO1xuICAgICAgICAgICAgICAgIGlzTmV4dCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc05leHQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIG5vdCB0aGUgbGFzdCBvbmUgZ2V0IG5leHQgY29vcmRpbmF0ZXMgYW5kIGNhbGN1bGF0ZSB0aGUgcmlnaHQgbm9ybWFsXG5cbiAgICAgICAgICAgICAgICBub3JtTmV4dCA9IFZlY3Rvci5ub3JtYWxpemUoVmVjdG9yLnBlcnAoY29vcmRDdXJyLCBjb29yZE5leHQpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlX3RpbGVfZWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJ1aWxkZXJzLm91dHNpZGVUaWxlKGNvb3JkQ3VyciwgY29vcmROZXh0LCB0aWxlX2VkZ2VfdG9sZXJhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybUN1cnIgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKGNvb3JkUHJldiwgY29vcmRDdXJyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4UGFpcihjb29yZEN1cnIsIG5vcm1DdXJyLCBpL2xpbmVTaXplLCBjb25zdGFudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50cy5uUGFpcnMrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB2ZXJ0aWNlcyB0byBidWZmZXIgYWNvcmRpbmcgdGhlaXIgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFBhaXJzKGNvbnN0YW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXYgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAgQ29tcHV0ZSBjdXJyZW50IG5vcm1hbFxuICAgICAgICAgICAgaWYgKGlzUHJldikge1xuICAgICAgICAgICAgICAgIC8vICBJZiB0aGVyZSBpcyBhIFBSRVZJT1VTIC4uLlxuICAgICAgICAgICAgICAgIGlmIChpc05leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uIGFuZCBhIE5FWFQgT05FLCBjb21wdXRlIHByZXZpb3VzIGFuZCBuZXh0IG5vcm1hbHMgKHNjYWxlZCBieSB0aGUgYW5nbGUgd2l0aCB0aGUgbGFzdCBwcmV2KVxuICAgICAgICAgICAgICAgICAgICBub3JtQ3VyciA9IFZlY3Rvci5ub3JtYWxpemUoVmVjdG9yLmFkZChub3JtUHJldiwgbm9ybU5leHQpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gMiAvICgxICsgTWF0aC5hYnMoVmVjdG9yLmRvdChub3JtUHJldiwgbm9ybUN1cnIpKSk7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1DdXJyID0gVmVjdG9yLm11bHQobm9ybUN1cnIsc2NhbGUqc2NhbGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLiBhbmQgdGhlcmUgaXMgTk9UIGEgTkVYVCBPTkUsIGNvcHkgdGhlIHByZXZpb3VzIG5leHQgb25lICh3aGljaCBpcyB0aGUgY3VycmVudCBvbmUpXG4gICAgICAgICAgICAgICAgICAgIG5vcm1DdXJyID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3IucGVycChjb29yZFByZXYsIGNvb3JkQ3VycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgTk8gUFJFVklPVVMgLi4uXG4gICAgICAgICAgICAgICAgaWYgKGlzTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi4gYW5kIGEgTkVYVCBPTkUsXG4gICAgICAgICAgICAgICAgICAgIG5vcm1OZXh0ID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3IucGVycChjb29yZEN1cnIsIGNvb3JkTmV4dCkpO1xuICAgICAgICAgICAgICAgICAgICBub3JtQ3VyciA9IG5vcm1OZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLiBhbmQgTk8gTkVYVCBPTkUsIG5vdGhpbmcgdG8gZG8gKHdpdGhvdXQgcHJldiBvciBuZXh0IG9uZSB0aGlzIGlzIGp1c3QgYSBwb2ludClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNQcmV2IHx8IGlzTmV4dCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgdGhlIEJFR0lOTklORyBvZiBhIExJTkVcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiAhaXNQcmV2ICYmICFjbG9zZWRfcG9seWdvbikge1xuICAgICAgICAgICAgICAgICAgICBhZGRDYXAoY29vcmRDdXJyLCBub3JtQ3VyciwgY29ybmVyc09uQ2FwLCB0cnVlLCBjb25zdGFudHMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vICBNaXRlciBsaW1pdDogaWYgbWl0ZXIgam9pbiBpcyB0b28gc2hhcnAsIGNvbnZlcnQgdG8gYmV2ZWwgaW5zdGVhZFxuICAgICAgICAgICAgICAgIGlmICh0cmlhbmdsZXNPbkpvaW4gPT09IDAgJiYgVmVjdG9yLmxlbmd0aFNxKG5vcm1DdXJyKSA+IG1pdGVyX2xlbl9zcSkge1xuICAgICAgICAgICAgICAgICAgICB0cmlhbmdsZXNPbkpvaW4gPSB0cmlhbmdsZXNGb3JKb2luWydiZXZlbCddOyAvLyBzd2l0Y2ggdG8gYmV2ZWxcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgSk9JTlxuICAgICAgICAgICAgICAgIGlmICh0cmlhbmdsZXNPbkpvaW4gIT09IDAgJiYgaXNQcmV2ICYmIGlzTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRKb2luKFtjb29yZFByZXYsIGNvb3JkQ3VyciwgY29vcmROZXh0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbm9ybVByZXYsbm9ybUN1cnIsIG5vcm1OZXh0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpL2xpbmVTaXplLCB0cmlhbmdsZXNPbkpvaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXhQYWlyKGNvb3JkQ3Vyciwgbm9ybUN1cnIsIGkvKGxpbmVTaXplLTEpLCBjb25zdGFudHMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc05leHQpIHtcbiAgICAgICAgICAgICAgICAgICBjb25zdGFudHMublBhaXJzKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXNQcmV2ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB2ZXJ0aWNlcyB0byBidWZmZXIgYWNjb3JkaW5nIHRvIHRoZWlyIGluZGV4XG4gICAgICAgIGluZGV4UGFpcnMoY29uc3RhbnRzKTtcblxuICAgICAgICAgLy8gSWYgaXQncyB0aGUgRU5EIG9mIGEgTElORVxuICAgICAgICBpZighY2xvc2VkX3BvbHlnb24pIHtcbiAgICAgICAgICAgIGFkZENhcChjb29yZEN1cnIsIG5vcm1DdXJyLCBjb3JuZXJzT25DYXAgLCBmYWxzZSwgY29uc3RhbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIFJlbW92ZSBkdXBsaWNhdGUgcG9pbnRzIGZyb20gYSBsaW5lLCBjcmVhdGluZyBhIG5ldyBsaW5lIG9ubHkgd2hlbiBwb2ludHMgbXVzdCBiZSByZW1vdmVkXG5mdW5jdGlvbiBkZWR1cGVMaW5lIChsaW5lLCBjbG9zZWQpIHtcbiAgICBsZXQgaSwgZHVwZXM7XG5cbiAgICAvLyBDb2xsZWN0IGR1cGUgcG9pbnRzXG4gICAgZm9yIChpPTA7IGkgPCBsaW5lLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAobGluZVtpXVswXSA9PT0gbGluZVtpKzFdWzBdICYmIGxpbmVbaV1bMV0gPT09IGxpbmVbaSsxXVsxXSkge1xuICAgICAgICAgICAgZHVwZXMgPSBkdXBlcyB8fCBbXTtcbiAgICAgICAgICAgIGR1cGVzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgZHVwZSBwb2ludHNcbiAgICBpZiAoZHVwZXMpIHtcbiAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCk7XG4gICAgICAgIGR1cGVzLmZvckVhY2goZCA9PiBsaW5lLnNwbGljZShkLCAxKSk7XG4gICAgfVxuXG4gICAgLy8gTGluZSBuZWVkcyBhdCBsZWFzdCAyIHBvaW50cywgcG9seWdvbiBuZWVkcyBhdCBsZWFzdCAzICgrMSB0byBjbG9zZSlcbiAgICBpZiAoIWNsb3NlZCAmJiBsaW5lLmxlbmd0aCA8IDIgfHwgY2xvc2VkICYmIGxpbmUubGVuZ3RoIDwgNCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBsaW5lO1xufVxuXG4vLyBBZGQgdG8gZXF1aWRpc3RhbnQgcGFpcnMgb2YgdmVydGljZXMgKGludGVybmFsIG1ldGhvZCBmb3IgcG9seWxpbmUgYnVpbGRlcilcbmZ1bmN0aW9uIGFkZFZlcnRleChjb29yZCwgbm9ybWFsLCB1diwgeyBoYWxmV2lkdGgsIHZlcnRpY2VzLCBzY2FsaW5nVmVjcywgdGV4Y29vcmRzIH0pIHtcbiAgICBpZiAoc2NhbGluZ1ZlY3MpIHtcbiAgICAgICAgLy8gIGEuIElmIHNjYWxpbmcgaXMgb24gYWRkIHRoZSB2ZXJ0ZXggKHRoZSBjdXJyQ29vcmQpIGFuZCB0aGUgc2NhbGluZyBWZWNzIChub3JtYWxzIHBvaW50aW5nIHdoZXJlIHRvIGV4dHJ1ZGUgdGhlIHZlcnRpY2VzKVxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKGNvb3JkKTtcbiAgICAgICAgc2NhbGluZ1ZlY3MucHVzaChub3JtYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICBiLiBBZGQgdGhlIGV4dHJ1ZGVkIHZlcnRpY2VzXG4gICAgICAgIHZlcnRpY2VzLnB1c2goW2Nvb3JkWzBdICsgbm9ybWFsWzBdICogaGFsZldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICBjb29yZFsxXSArIG5vcm1hbFsxXSAqIGhhbGZXaWR0aF0pO1xuICAgIH1cblxuICAgIC8vIGMpIEFkZCBVVnMgaWYgdGhleSBhcmUgZW5hYmxlZFxuICAgIGlmICh0ZXhjb29yZHMpIHtcbiAgICAgICAgdGV4Y29vcmRzLnB1c2godXYpO1xuICAgIH1cbn1cblxuLy8gIEFkZCB0byBlcXVpZGlzdGFudCBwYWlycyBvZiB2ZXJ0aWNlcyAoaW50ZXJuYWwgbWV0aG9kIGZvciBwb2x5bGluZSBidWlsZGVyKVxuZnVuY3Rpb24gYWRkVmVydGV4UGFpciAoY29vcmQsIG5vcm1hbCwgdl9wY3QsIGNvbnN0YW50cykge1xuICAgIGlmIChjb25zdGFudHMudGV4Y29vcmRzKSB7XG4gICAgICAgIGFkZFZlcnRleChjb29yZCwgbm9ybWFsLCBbY29uc3RhbnRzLm1heF91LCAoMS12X3BjdCkqY29uc3RhbnRzLm1pbl92ICsgdl9wY3QqY29uc3RhbnRzLm1heF92XSwgY29uc3RhbnRzKTtcbiAgICAgICAgYWRkVmVydGV4KGNvb3JkLCBWZWN0b3IubmVnKG5vcm1hbCksIFtjb25zdGFudHMubWluX3UsICgxLXZfcGN0KSpjb25zdGFudHMubWluX3YgKyB2X3BjdCpjb25zdGFudHMubWF4X3ZdLCBjb25zdGFudHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWRkVmVydGV4KGNvb3JkLCBub3JtYWwsIG51bGwsIGNvbnN0YW50cyk7XG4gICAgICAgIGFkZFZlcnRleChjb29yZCwgVmVjdG9yLm5lZyhub3JtYWwpLCBudWxsLCBjb25zdGFudHMpO1xuICAgIH1cbn1cblxuLy8gIFRlc3NhbGF0ZSBhIEZBTiBnZW9tZXRyeSBiZXR3ZWVuIHBvaW50cyBBICAgICAgIEJcbi8vICB1c2luZyB0aGVpciBub3JtYWxzIGZyb20gYSBjZW50ZXIgICAgICAgIFxcIC4gLiAvXG4vLyAgYW5kIGludGVycG9sYXRpbmcgdGhlaXIgVVZzICAgICAgICAgICAgICAgXFwgcCAvXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcLi9cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENcbmZ1bmN0aW9uIGFkZEZhbiAoY29vcmQsIG5BLCBuQywgbkIsIHVBLCB1QywgdUIsIHNpZ25lZCwgbnVtVHJpYW5nbGVzLCBjb25zdGFudHMpIHtcblxuICAgIGlmIChudW1UcmlhbmdsZXMgPCAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBZGQgcHJldmlvdXMgdmVydGljZXMgdG8gYnVmZmVyIGFuZCBjbGVhciB0aGUgYnVmZmVycyBhbmQgaW5kZXggcGFpcnNcbiAgICAvLyBiZWNhdXNlIHdlIGFyZSBnb2luZyB0byBhZGQgbW9yZSB0cmlhbmdsZXMuXG4gICAgaW5kZXhQYWlycyhjb25zdGFudHMpO1xuXG4gICAgLy8gSW5pdGlhbCBwYXJhbWV0ZXJzXG4gICAgdmFyIG5vcm1DdXJyID0gVmVjdG9yLnNldChuQSk7XG4gICAgdmFyIG5vcm1QcmV2ID0gWzAsMF07XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gQSBhbmQgQlxuICAgIHZhciBhbmdsZV9kZWx0YSA9IFZlY3Rvci5hbmdsZUJldHdlZW4obkEsIG5CKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgYW5nbGUgZm9yIGVhY2ggdHJpYW5nbGVcbiAgICB2YXIgYW5nbGVfc3RlcCA9IGFuZ2xlX2RlbHRhL251bVRyaWFuZ2xlcztcblxuICAgIC8vIEpvaW5zIHRoYXQgdHVybiBsZWZ0IG9yIHJpZ2h0IGJlaGF2ZSBkaWZlcmVudGx5Li4uXG4gICAgLy8gdHJpYW5nbGVzIG5lZWQgdG8gYmUgcm90YXRlZCBpbiBkaWZlcmVudCBkaXJlY3Rpb25zXG4gICAgaWYgKCFzaWduZWQpIHtcbiAgICAgICAgYW5nbGVfc3RlcCAqPSAtMTtcbiAgICB9XG5cbiAgICBpZiAoY29uc3RhbnRzLnRleGNvb3Jkcykge1xuICAgICAgICB2YXIgdXZDdXJyID0gVmVjdG9yLnNldCh1QSk7XG4gICAgICAgIHZhciB1dl9kZWx0YSA9IFZlY3Rvci5kaXYoVmVjdG9yLnN1Yih1Qix1QSksIG51bVRyaWFuZ2xlcyk7XG4gICAgfVxuXG4gICAgLy8gIEFkZCB0aGUgRklSU1QgYW5kIENFTlRFUiB2ZXJ0ZXhcbiAgICAvLyAgVGhlIHRyaWFuZ2xlcyB3aWxsIGJlIGNvbXBvc2VkIGluIGEgRkFOIHN0eWxlIGFyb3VuZCBpdFxuICAgIGFkZFZlcnRleChjb29yZCwgbkMsIHVDLCBjb25zdGFudHMpO1xuXG4gICAgLy8gIEFkZCBmaXJzdCBjb3JuZXJcbiAgICBhZGRWZXJ0ZXgoY29vcmQsIG5vcm1DdXJyLCB1QSwgY29uc3RhbnRzKTtcblxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcmVzdCBvZiB0aGUgY29ybmVyc1xuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtVHJpYW5nbGVzOyB0KyspIHtcbiAgICAgICAgbm9ybVByZXYgPSBWZWN0b3Iubm9ybWFsaXplKG5vcm1DdXJyKTtcbiAgICAgICAgbm9ybUN1cnIgPSBWZWN0b3Iucm90KFZlY3Rvci5ub3JtYWxpemUobm9ybUN1cnIpLCBhbmdsZV9zdGVwKTsgICAgIC8vICBSb3RhdGUgdGhlIGV4dHJ1c2lvbiBub3JtYWxcbiAgICAgICAgaWYgKGNvbnN0YW50cy50ZXhjb29yZHMpIHtcbiAgICAgICAgICAgIHV2Q3VyciA9IFZlY3Rvci5hZGQodXZDdXJyLHV2X2RlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRWZXJ0ZXgoY29vcmQsIG5vcm1DdXJyLCB1dkN1cnIsIGNvbnN0YW50cyk7ICAgICAgLy8gIEFkZCBjb21wdXRlZCBjb3JuZXJcbiAgICB9XG5cbiAgICAvLyBJbmRleCB0aGUgdmVydGljZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRyaWFuZ2xlczsgaSsrKSB7XG4gICAgICAgIGlmIChzaWduZWQpIHtcbiAgICAgICAgICAgIGFkZEluZGV4KGkrMiwgY29uc3RhbnRzKTtcbiAgICAgICAgICAgIGFkZEluZGV4KDAsIGNvbnN0YW50cyk7XG4gICAgICAgICAgICBhZGRJbmRleChpKzEsIGNvbnN0YW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRJbmRleChpKzEsIGNvbnN0YW50cyk7XG4gICAgICAgICAgICBhZGRJbmRleCgwLCBjb25zdGFudHMpO1xuICAgICAgICAgICAgYWRkSW5kZXgoaSsyLCBjb25zdGFudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgdGhlIGJ1ZmZlclxuICAgIGNvbnN0YW50cy52ZXJ0aWNlcyA9IFtdO1xuICAgIGlmIChjb25zdGFudHMuc2NhbGluZ1ZlY3MpIHtcbiAgICAgICAgY29uc3RhbnRzLnNjYWxpbmdWZWNzID0gW107XG4gICAgfVxuICAgIGlmIChjb25zdGFudHMudGV4Y29vcmRzKSB7XG4gICAgICAgIGNvbnN0YW50cy50ZXhjb29yZHMgPSBbXTtcbiAgICB9XG59XG5cbi8vICBhZGRCZXZlbCAgICBBIC0tLS0tIEJcbi8vICAgICAgICAgICAgIC8gXFwgLCAuIC8gXFxcbi8vICAgICAgICAgICAvICAgL1xcICAgL1xcICBcXFxuLy8gICAgICAgICAgICAgIC8gIFxcIC8gICBcXCBcXFxuLy8gICAgICAgICAgICAgICAgLyBDIFxcXG5mdW5jdGlvbiBhZGRCZXZlbCAoY29vcmQsIG5BLCBuQywgbkIsIHVBLCB1QywgdUIsIHNpZ25lZCwgY29uc3RhbnRzKSB7XG4gICAgLy8gQWRkIHByZXZpb3VzIHZlcnRpY2VzIHRvIGJ1ZmZlciBhbmQgY2xlYXIgdGhlIGJ1ZmZlcnMgYW5kIGluZGV4IHBhaXJzXG4gICAgLy8gYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gYWRkIG1vcmUgdHJpYW5nbGVzLlxuICAgIGluZGV4UGFpcnMoY29uc3RhbnRzKTtcblxuICAgIC8vICBBZGQgdGhlIEZJUlNUIGFuZCBDRU5URVIgdmVydGV4XG4gICAgYWRkVmVydGV4KGNvb3JkLCBuQywgdUMsIGNvbnN0YW50cyk7XG4gICAgYWRkVmVydGV4KGNvb3JkLCBuQSwgdUEsIGNvbnN0YW50cyk7XG4gICAgYWRkVmVydGV4KGNvb3JkLCBuQiwgdUIsIGNvbnN0YW50cyk7XG5cbiAgICBpZiAoc2lnbmVkKSB7XG4gICAgICAgIGFkZEluZGV4KDIsIGNvbnN0YW50cyk7XG4gICAgICAgIGFkZEluZGV4KDAsIGNvbnN0YW50cyk7XG4gICAgICAgIGFkZEluZGV4KDEsIGNvbnN0YW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWRkSW5kZXgoMSwgY29uc3RhbnRzKTtcbiAgICAgICAgYWRkSW5kZXgoMCwgY29uc3RhbnRzKTtcbiAgICAgICAgYWRkSW5kZXgoMiwgY29uc3RhbnRzKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhciB0aGUgYnVmZmVyXG4gICAgY29uc3RhbnRzLnZlcnRpY2VzID0gW107XG4gICAgaWYgKGNvbnN0YW50cy5zY2FsaW5nVmVjcykge1xuICAgICAgICBjb25zdGFudHMuc2NhbGluZ1ZlY3MgPSBbXTtcbiAgICB9XG4gICAgaWYgKGNvbnN0YW50cy50ZXhjb29yZHMpIHtcbiAgICAgICAgY29uc3RhbnRzLnRleGNvb3JkcyA9IFtdO1xuICAgIH1cbn1cblxuXG4vLyAgVGVzc2FsYXRlIGEgU1FVQVJFIGdlb21ldHJ5IGJldHdlZW4gQSBhbmQgQiAgICAgKyAuLi4uLi4uLitcbi8vICBhbmQgaW50ZXJwb2xhdGluZyB0aGVpciBVVnMgICAgICAgICAgICAgICAgICAgICA6IFxcICAyICAvIDpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDFcXCAgIC8zIDpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIC0tIEMgLS0gQlxuZnVuY3Rpb24gYWRkU3F1YXJlIChjb29yZCwgbkEsIG5CLCB1QSwgdUMsIHVCLCBzaWduZWQsIGNvbnN0YW50cykge1xuXG4gICAgLy8gQWRkIHByZXZpb3VzIHZlcnRpY2VzIHRvIGJ1ZmZlciBhbmQgY2xlYXIgdGhlIGJ1ZmZlcnMgYW5kIGluZGV4IHBhaXJzXG4gICAgLy8gYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gYWRkIG1vcmUgdHJpYW5nbGVzLlxuICAgIGluZGV4UGFpcnMoY29uc3RhbnRzKTtcblxuICAgIC8vIEluaXRpYWwgcGFyYW1ldGVyc1xuICAgIHZhciBub3JtQ3VyciA9IFZlY3Rvci5zZXQobkEpO1xuICAgIHZhciBub3JtUHJldiA9IFswLDBdO1xuICAgIGlmIChjb25zdGFudHMudGV4Y29vcmRzKSB7XG4gICAgICAgIHZhciB1dkN1cnIgPSBWZWN0b3Iuc2V0KHVBKTtcbiAgICAgICAgdmFyIHV2X2RlbHRhID0gVmVjdG9yLmRpdihWZWN0b3Iuc3ViKHVCLHVBKSwgNCk7XG4gICAgfVxuXG4gICAgLy8gRmlyc3QgYW5kIGxhc3QgY2FwIGhhdmUgZGlmZmVyZW50IGRpcmVjdGlvbnNcbiAgICB2YXIgYW5nbGVfc3RlcCA9IDAuNzg1Mzk4MTYzMzk7IC8vIFBJLzQgPSA0NSBkZWdyZWVzXG4gICAgaWYgKCFzaWduZWQpIHtcbiAgICAgICAgYW5nbGVfc3RlcCAqPSAtMTtcbiAgICB9XG5cbiAgICAvLyAgQWRkIHRoZSBGSVJTVCBhbmQgQ0VOVEVSIHZlcnRleFxuICAgIC8vICBUaGUgdHJpYW5nbGVzIHdpbGwgYmUgYWRkIGluIGEgRkFOIHN0eWxlIGFyb3VuZCBpdFxuICAgIC8vXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgIEEgLS0gQ1xuICAgIGFkZFZlcnRleChjb29yZCwgemVyb192ZWMyLCB1QywgY29uc3RhbnRzKTtcblxuICAgIC8vICBBZGQgZmlyc3QgY29ybmVyICAgICArXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgIDpcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgQSAtLSBDXG4gICAgYWRkVmVydGV4KGNvb3JkLCBub3JtQ3VyciwgdUEsIGNvbnN0YW50cyk7XG5cbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJlc3Qgb2YgdGhlIGNvb3JuZXJzIGNvbXBsZXRpbmcgdGhlIHRyaWFuZ2xlc1xuICAgIC8vIChleGNlcHQgdGhlIGNvcm5lciAxIHRvIHNhdmUgb25lIHRyaWFuZ2xlIHRvIGJlIGRyYXcgKVxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgNDsgdCsrKSB7XG5cbiAgICAgICAgLy8gMCAgICAgMSAgICAgMlxuICAgICAgICAvLyAgKyAuLi4uLi4uLitcbiAgICAgICAgLy8gIDogXFwgICAgIC8gOlxuICAgICAgICAvLyAgOiAgXFwgICAvICA6XG4gICAgICAgIC8vICBBIC0tIEMgLS0gQiAgM1xuXG4gICAgICAgIG5vcm1QcmV2ID0gVmVjdG9yLm5vcm1hbGl6ZShub3JtQ3Vycik7XG4gICAgICAgIG5vcm1DdXJyID0gVmVjdG9yLnJvdCggVmVjdG9yLm5vcm1hbGl6ZShub3JtQ3VyciksIGFuZ2xlX3N0ZXApOyAgICAgLy8gIFJvdGF0ZSB0aGUgZXh0cnVzaW9uIG5vcm1hbFxuXG4gICAgICAgIGlmICh0ID09PSAwIHx8IHQgPT09IDIpIHtcbiAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIG1ha2UgdGhpcyBcImZhblwiIGxvb2sgbGlrZSBhIHNxdWFyZSB0aGUgbWl0dGVycyBuZWVkIHRvIGJlIHN0cmVhY2hcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IDIgLyAoMSArIE1hdGguYWJzKFZlY3Rvci5kb3Qobm9ybVByZXYsIG5vcm1DdXJyKSkpO1xuICAgICAgICAgICAgbm9ybUN1cnIgPSBWZWN0b3IubXVsdChub3JtQ3Vyciwgc2NhbGUqc2NhbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnN0YW50cy50ZXhjb29yZHMpIHtcbiAgICAgICAgICAgIHV2Q3VyciA9IFZlY3Rvci5hZGQodXZDdXJyLHV2X2RlbHRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ICE9PSAxKSB7XG4gICAgICAgICAgICAvLyAgQWRkIGNvbXB1dGVkIGNvcm5lciAoZXhjZXB0IHRoZSBjb3JuZXIgMSlcbiAgICAgICAgICAgIGFkZFZlcnRleChjb29yZCwgbm9ybUN1cnIsIHV2Q3VyciwgY29uc3RhbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGlmIChzaWduZWQpIHtcbiAgICAgICAgICAgIGFkZEluZGV4KGkrMiwgY29uc3RhbnRzKTtcbiAgICAgICAgICAgIGFkZEluZGV4KDAsIGNvbnN0YW50cyk7XG4gICAgICAgICAgICBhZGRJbmRleChpKzEsIGNvbnN0YW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRJbmRleChpKzEsIGNvbnN0YW50cyk7XG4gICAgICAgICAgICBhZGRJbmRleCgwLCBjb25zdGFudHMpO1xuICAgICAgICAgICAgYWRkSW5kZXgoaSsyLCBjb25zdGFudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgdGhlIGJ1ZmZlclxuICAgIGNvbnN0YW50cy52ZXJ0aWNlcyA9IFtdO1xuICAgIGlmIChjb25zdGFudHMuc2NhbGluZ1ZlY3MpIHtcbiAgICAgICAgY29uc3RhbnRzLnNjYWxpbmdWZWNzID0gW107XG4gICAgfVxuICAgIGlmIChjb25zdGFudHMudGV4Y29vcmRzKSB7XG4gICAgICAgIGNvbnN0YW50cy50ZXhjb29yZHMgPSBbXTtcbiAgICB9XG59XG5cbi8vICBBZGQgc3BlY2lhbCBqb2lucyAobm90IG1pdGVyKSB0eXBlcyB0aGF0IHJlcXVpcmUgRkFOIHRlc3NlbGxhdGlvbnNcbi8vICBVc2luZyBodHRwOi8vd3d3LmNvZGVwcm9qZWN0LmNvbS9BcnRpY2xlcy8yMjY1NjkvRHJhd2luZy1wb2x5bGluZXMtYnktdGVzc2VsbGF0aW9uIGFzIHJlZmVyZW5jZVxuZnVuY3Rpb24gYWRkSm9pbiAoY29vcmRzLCBub3JtYWxzLCB2X3BjdCwgblRyaWFuZ2xlcywgY29uc3RhbnRzKSB7XG4gICAgdmFyIHNpZ25lZCA9IFZlY3Rvci5zaWduZWRfYXJlYShjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzJdKSA+IDA7XG4gICAgdmFyIG5BID0gbm9ybWFsc1swXSwgICAgICAgICAgICAgIC8vIG5vcm1hbCB0byBwb2ludCBBIChhVClcbiAgICAgICAgbkMgPSBWZWN0b3IubmVnKG5vcm1hbHNbMV0pLCAgLy8gbm9ybWFsIHRvIGNlbnRlciAoLXZQKVxuICAgICAgICBuQiA9IG5vcm1hbHNbMl07ICAgICAgICAgICAgICAvLyBub3JtYWwgdG8gcG9pbnQgQiAoYlQpXG5cbiAgICBpZiAoY29uc3RhbnRzLnRleGNvb3Jkcykge1xuICAgICAgICB2YXIgdUEgPSBbY29uc3RhbnRzLm1heF91LCAoMS12X3BjdCkqY29uc3RhbnRzLm1pbl92ICsgdl9wY3QqY29uc3RhbnRzLm1heF92XSxcbiAgICAgICAgICAgIHVDID0gW2NvbnN0YW50cy5taW5fdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl0sXG4gICAgICAgICAgICB1QiA9IFtjb25zdGFudHMubWF4X3UsICgxLXZfcGN0KSpjb25zdGFudHMubWluX3YgKyB2X3BjdCpjb25zdGFudHMubWF4X3ZdO1xuICAgIH1cblxuICAgIGlmIChzaWduZWQpIHtcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkEsIHVBLCBjb25zdGFudHMpO1xuICAgICAgICBhZGRWZXJ0ZXgoY29vcmRzWzFdLCBuQywgdUMsIGNvbnN0YW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbkEgPSBWZWN0b3IubmVnKG5vcm1hbHNbMF0pO1xuICAgICAgICBuQyA9IG5vcm1hbHNbMV07XG4gICAgICAgIG5CID0gVmVjdG9yLm5lZyhub3JtYWxzWzJdKTtcblxuICAgICAgICBpZiAoY29uc3RhbnRzLnRleGNvb3Jkcykge1xuICAgICAgICAgICAgdUEgPSBbY29uc3RhbnRzLm1pbl91LCAoMS12X3BjdCkqY29uc3RhbnRzLm1pbl92ICsgdl9wY3QqY29uc3RhbnRzLm1heF92XTtcbiAgICAgICAgICAgIHVDID0gW2NvbnN0YW50cy5tYXhfdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl07XG4gICAgICAgICAgICB1QiA9IFtjb25zdGFudHMubWluX3UsICgxLXZfcGN0KSpjb25zdGFudHMubWluX3YgKyB2X3BjdCpjb25zdGFudHMubWF4X3ZdO1xuICAgICAgICB9XG4gICAgICAgIGFkZFZlcnRleChjb29yZHNbMV0sIG5DLCB1QywgY29uc3RhbnRzKTtcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkEsIHVBLCBjb25zdGFudHMpO1xuICAgIH1cblxuICAgIGlmIChuVHJpYW5nbGVzID09PSAxKSB7XG4gICAgICAgIGFkZEJldmVsKGNvb3Jkc1sxXSwgbkEsIG5DLCBuQiwgdUEsIHVDLCB1Qiwgc2lnbmVkLCBjb25zdGFudHMpO1xuICAgIH0gZWxzZSBpZiAoblRyaWFuZ2xlcyA+IDEpe1xuICAgICAgICBhZGRGYW4oY29vcmRzWzFdLCBuQSwgbkMsIG5CLCB1QSwgdUMsIHVCLCBzaWduZWQsIG5UcmlhbmdsZXMsIGNvbnN0YW50cyk7XG4gICAgfVxuXG4gICAgaWYgKHNpZ25lZCkge1xuICAgICAgICBhZGRWZXJ0ZXgoY29vcmRzWzFdLCBuQiwgdUIsIGNvbnN0YW50cyk7XG4gICAgICAgIGFkZFZlcnRleChjb29yZHNbMV0sIG5DLCB1QywgY29uc3RhbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhZGRWZXJ0ZXgoY29vcmRzWzFdLCBuQywgdUMsIGNvbnN0YW50cyk7XG4gICAgICAgIGFkZFZlcnRleChjb29yZHNbMV0sIG5CLCB1QiwgY29uc3RhbnRzKTtcbiAgICB9XG59XG5cbi8vICBGdW5jdGlvbiB0byBhZGQgdGhlIHZlcnRleCBuZWVkIGZvciBsaW5lIGNhcHMsXG4vLyAgYmVjYXVzZSByZS11c2UgdGhlIGJ1ZmZlcnMgbmVlZHMgdG8gYmUgYXQgdGhlIGVuZFxuZnVuY3Rpb24gYWRkQ2FwIChjb29yZCwgbm9ybWFsLCBudW1Db3JuZXJzLCBpc0JlZ2lubmluZywgY29uc3RhbnRzKSB7XG5cbiAgICBpZiAobnVtQ29ybmVycyA8IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFVWc1xuICAgIHZhciB1dkEsIHV2QiwgdXZDO1xuICAgIGlmIChjb25zdGFudHMudGV4Y29vcmRzKSB7XG4gICAgICAgIHV2QyA9IFtjb25zdGFudHMubWluX3UrKGNvbnN0YW50cy5tYXhfdS1jb25zdGFudHMubWluX3UpLzIsIGNvbnN0YW50cy5taW5fdl07ICAgLy8gQ2VudGVyIHBvaW50IFVWc1xuXG4gICAgICAgIGlmIChpc0JlZ2lubmluZykge1xuICAgICAgICAgICAgdXZBID0gW2NvbnN0YW50cy5taW5fdSxjb25zdGFudHMubWluX3ZdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCZWdpbm5pbmcgYW5nbGUgVVZzXG4gICAgICAgICAgICB1dkIgPSBbY29uc3RhbnRzLm1heF91LGNvbnN0YW50cy5taW5fdl07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZGluZyBhbmdsZSBVVnNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHV2QSA9IFtjb25zdGFudHMubWluX3UsY29uc3RhbnRzLm1heF92XTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmVnaW5pbmcgYW5nbGUgVVZzXG4gICAgICAgICAgICB1dkIgPSBbY29uc3RhbnRzLm1heF91LGNvbnN0YW50cy5tYXhfdl07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZGluZyBhbmdsZSBVVnNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICggbnVtQ29ybmVycyA9PT0gMiApe1xuICAgICAgICAvLyBJZiBjYXBzIGFyZSBzZXQgYXMgc3F1YXJlc1xuICAgICAgICBhZGRTcXVhcmUoIGNvb3JkLFxuICAgICAgICAgICAgICAgICAgIFZlY3Rvci5uZWcobm9ybWFsKSwgbm9ybWFsLFxuICAgICAgICAgICAgICAgICAgIHV2QSwgdXZDLCB1dkIsXG4gICAgICAgICAgICAgICAgICAgaXNCZWdpbm5pbmcsXG4gICAgICAgICAgICAgICAgICAgY29uc3RhbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBjYXBzIGFyZSBzZXQgYXMgcm91bmQgKCBudW1Db3JuZXJzPT09MyApXG4gICAgICAgIGFkZEZhbiggY29vcmQsXG4gICAgICAgICAgICAgICAgVmVjdG9yLm5lZyhub3JtYWwpLCB6ZXJvX3ZlYzIsIG5vcm1hbCxcbiAgICAgICAgICAgICAgICB1dkEsIHV2QywgdXZCLFxuICAgICAgICAgICAgICAgIGlzQmVnaW5uaW5nLCBudW1Db3JuZXJzKjIsIGNvbnN0YW50cyk7XG4gICAgfVxufVxuXG4vLyBBZGQgYSB2ZXJ0ZXggYmFzZWQgb24gdGhlIGluZGV4IHBvc2l0aW9uIGludG8gdGhlIFZCTyAoaW50ZXJuYWwgbWV0aG9kIGZvciBwb2x5bGluZSBidWlsZGVyKVxuZnVuY3Rpb24gYWRkSW5kZXggKGluZGV4LCB7IHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsIGhhbGZXaWR0aCwgdmVydGljZXMsIHNjYWxpbmdfaW5kZXgsIHNjYWxpbmdfbm9ybWFsaXplLCBzY2FsaW5nVmVjcywgdGV4Y29vcmRfaW5kZXgsIHRleGNvb3JkcywgdGV4Y29vcmRfbm9ybWFsaXplIH0pIHtcbiAgICAvLyBQcmV2ZW50IGFjY2VzcyB0byB1bmRlZmluZWQgdmVydGljZXNcbiAgICBpZiAoaW5kZXggPj0gdmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQgdmVydGV4IHBvc2l0aW9uXG4gICAgdmVydGV4X3RlbXBsYXRlWzBdID0gdmVydGljZXNbaW5kZXhdWzBdO1xuICAgIHZlcnRleF90ZW1wbGF0ZVsxXSA9IHZlcnRpY2VzW2luZGV4XVsxXTtcblxuICAgIC8vIHNldCBVVnNcbiAgICBpZiAodGV4Y29vcmRfaW5kZXgpIHtcbiAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMF0gPSB0ZXhjb29yZHNbaW5kZXhdWzBdICogdGV4Y29vcmRfbm9ybWFsaXplO1xuICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAxXSA9IHRleGNvb3Jkc1tpbmRleF1bMV0gKiB0ZXhjb29yZF9ub3JtYWxpemU7XG4gICAgfVxuXG4gICAgLy8gc2V0IFNjYWxpbmcgdmVydGV4IChYLCBZIG5vcm1hbCBkaXJlY3Rpb24gKyBaIGhhbGZ3aWR0aCBhcyBhdHRyaWJ1dGUpXG4gICAgaWYgKHNjYWxpbmdfaW5kZXgpIHtcbiAgICAgICAgdmVydGV4X3RlbXBsYXRlW3NjYWxpbmdfaW5kZXggKyAwXSA9IHNjYWxpbmdWZWNzW2luZGV4XVswXSAqIHNjYWxpbmdfbm9ybWFsaXplO1xuICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbc2NhbGluZ19pbmRleCArIDFdID0gc2NhbGluZ1ZlY3NbaW5kZXhdWzFdICogc2NhbGluZ19ub3JtYWxpemU7XG4gICAgICAgIHZlcnRleF90ZW1wbGF0ZVtzY2FsaW5nX2luZGV4ICsgMl0gPSBoYWxmV2lkdGg7XG4gICAgfVxuXG4gICAgLy8gIEFkZCB2ZXJ0ZXggdG8gVkJPXG4gICAgdmVydGV4X2RhdGEuYWRkVmVydGV4KHZlcnRleF90ZW1wbGF0ZSk7XG59XG5cbi8vIEFkZCB0aGUgaW5kZXggdmVydGV4IHRvIHRoZSBWQk8gYW5kIGNsZWFuIHRoZSBidWZmZXJzXG5mdW5jdGlvbiBpbmRleFBhaXJzIChjb25zdGFudHMpIHtcbiAgICAvLyBBZGQgdmVydGljZXMgdG8gYnVmZmVyIGFjb3JkaW5nIHRoZWlyIGluZGV4XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25zdGFudHMublBhaXJzOyBpKyspIHtcbiAgICAgICAgYWRkSW5kZXgoMippKzIsIGNvbnN0YW50cyk7XG4gICAgICAgIGFkZEluZGV4KDIqaSsxLCBjb25zdGFudHMpO1xuICAgICAgICBhZGRJbmRleCgyKmkrMCwgY29uc3RhbnRzKTtcblxuICAgICAgICBhZGRJbmRleCgyKmkrMiwgY29uc3RhbnRzKTtcbiAgICAgICAgYWRkSW5kZXgoMippKzMsIGNvbnN0YW50cyk7XG4gICAgICAgIGFkZEluZGV4KDIqaSsxLCBjb25zdGFudHMpO1xuICAgIH1cblxuICAgIGNvbnN0YW50cy5uUGFpcnMgPSAwO1xuXG4gICAgLy8gQ2xlYW4gdGhlIGJ1ZmZlclxuICAgIGNvbnN0YW50cy52ZXJ0aWNlcyA9IFtdO1xuICAgIGlmIChjb25zdGFudHMuc2NhbGluZ1ZlY3MpIHtcbiAgICAgICAgY29uc3RhbnRzLnNjYWxpbmdWZWNzID0gW107XG4gICAgfVxuICAgIGlmIChjb25zdGFudHMudGV4Y29vcmRzKSB7XG4gICAgICAgIGNvbnN0YW50cy50ZXhjb29yZHMgPSBbXTtcbiAgICB9XG59XG5cbi8vIEJ1aWxkIGEgYmlsbGJvYXJkIHNwcml0ZSBxdWFkIGNlbnRlcmVkIG9uIGEgcG9pbnQuIFNwcml0ZXMgYXJlIGludGVuZGVkIHRvIGJlIGRyYXduIGluIHNjcmVlbnNwYWNlLCBhbmQgaGF2ZVxuLy8gcHJvcGVydGllcyBmb3Igd2lkdGgsIGhlaWdodCwgYW5nbGUsIGFuZCBhIHNjYWxlIGZhY3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIGludGVycG9sYXRlIHRoZSBzY3JlZW5zcGFjZSBzaXplXG4vLyBvZiBhIHNwcml0ZSBiZXR3ZWVuIHR3byB6b29tIGxldmVscy5cbkJ1aWxkZXJzLmJ1aWxkUXVhZHNGb3JQb2ludHMgPSBmdW5jdGlvbiAocG9pbnRzLCB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLFxuICAgIHsgdGV4Y29vcmRfaW5kZXgsIHBvc2l0aW9uX2luZGV4LCBzaGFwZV9pbmRleCwgb2Zmc2V0X2luZGV4IH0sXG4gICAgeyBxdWFkLCBxdWFkX3NjYWxlLCBvZmZzZXQsIGFuZ2xlLCB0ZXhjb29yZF9zY2FsZSwgdGV4Y29vcmRfbm9ybWFsaXplIH0pIHtcbiAgICBsZXQgdzIgPSBxdWFkWzBdIC8gMjtcbiAgICBsZXQgaDIgPSBxdWFkWzFdIC8gMjtcbiAgICBsZXQgc2NhbGluZyA9IFtcbiAgICAgICAgWy13MiwgLWgyXSxcbiAgICAgICAgW3cyLCAtaDJdLFxuICAgICAgICBbdzIsIGgyXSxcblxuICAgICAgICBbLXcyLCAtaDJdLFxuICAgICAgICBbdzIsIGgyXSxcbiAgICAgICAgWy13MiwgaDJdXG4gICAgXTtcblxuICAgIGxldCB0ZXhjb29yZHM7XG4gICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XG4gICAgICAgIHRleGNvb3JkX25vcm1hbGl6ZSA9IHRleGNvb3JkX25vcm1hbGl6ZSB8fCAxO1xuXG4gICAgICAgIHZhciBbbWluX3UsIG1pbl92LCBtYXhfdSwgbWF4X3ZdID0gdGV4Y29vcmRfc2NhbGUgfHwgZGVmYXVsdF91dnM7XG4gICAgICAgIHRleGNvb3JkcyA9IFtcbiAgICAgICAgICAgIFttaW5fdSwgbWluX3ZdLFxuICAgICAgICAgICAgW21heF91LCBtaW5fdl0sXG4gICAgICAgICAgICBbbWF4X3UsIG1heF92XSxcblxuICAgICAgICAgICAgW21pbl91LCBtaW5fdl0sXG4gICAgICAgICAgICBbbWF4X3UsIG1heF92XSxcbiAgICAgICAgICAgIFttaW5fdSwgbWF4X3ZdXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgbGV0IG51bV9wb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgIGZvciAobGV0IHA9MDsgcCA8IG51bV9wb2ludHM7IHArKykge1xuICAgICAgICBsZXQgcG9pbnQgPSBwb2ludHNbcF07XG5cbiAgICAgICAgZm9yIChsZXQgcG9zPTA7IHBvcyA8IDY7IHBvcysrKSB7XG4gICAgICAgICAgICAvLyBBZGQgdGV4Y29vcmRzXG4gICAgICAgICAgICBpZiAodGV4Y29vcmRfaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAwXSA9IHRleGNvb3Jkc1twb3NdWzBdICogdGV4Y29vcmRfbm9ybWFsaXplO1xuICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVt0ZXhjb29yZF9pbmRleCArIDFdID0gdGV4Y29vcmRzW3Bvc11bMV0gKiB0ZXhjb29yZF9ub3JtYWxpemU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtwb3NpdGlvbl9pbmRleCArIDBdID0gcG9pbnRbMF07XG4gICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbcG9zaXRpb25faW5kZXggKyAxXSA9IHBvaW50WzFdO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbc2hhcGVfaW5kZXggKyAwXSA9IHNjYWxpbmdbcG9zXVswXTtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtzaGFwZV9pbmRleCArIDFdID0gc2NhbGluZ1twb3NdWzFdO1xuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3NoYXBlX2luZGV4ICsgMl0gPSBhbmdsZTtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtzaGFwZV9pbmRleCArIDNdID0gcXVhZF9zY2FsZTtcblxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW29mZnNldF9pbmRleCArIDBdID0gb2Zmc2V0WzBdO1xuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW29mZnNldF9pbmRleCArIDFdID0gb2Zmc2V0WzFdO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhfZGF0YS5hZGRWZXJ0ZXgodmVydGV4X3RlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLyogVXRpbGl0eSBmdW5jdGlvbnMgKi9cblxuLy8gVHJpYW5ndWxhdGlvbiB1c2luZyBlYXJjdXRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvZWFyY3V0XG5CdWlsZGVycy50cmlhbmd1bGF0ZVBvbHlnb24gPSBmdW5jdGlvbiAoY29udG91cnMpXG57XG4gICAgcmV0dXJuIGVhcmN1dChjb250b3Vycyk7XG59O1xuXG4vLyBUZXN0cyBpZiBhIGxpbmUgc2VnbWVudCAoZnJvbSBwb2ludCBBIHRvIEIpIGlzIG91dHNpZGUgdGhlIHRpbGUgYm91bmRzXG4vLyAod2l0aGluIGEgY2VydGFpbiB0b2xlcmFuY2UgdG8gYWNjb3VudCBmb3IgZ2VvbWV0cnkgbmVhcmx5IG9uIHRpbGUgZWRnZXMpXG5CdWlsZGVycy5vdXRzaWRlVGlsZSA9IGZ1bmN0aW9uIChfYSwgX2IsIHRvbGVyYW5jZSkge1xuICAgIGxldCB0aWxlX21pbiA9IEJ1aWxkZXJzLnRpbGVfYm91bmRzWzBdO1xuICAgIGxldCB0aWxlX21heCA9IEJ1aWxkZXJzLnRpbGVfYm91bmRzWzFdO1xuXG4gICAgLy8gVE9ETzogZml4IGZsaXBwZWQgWSBjb29yZHMgaGVyZSwgY29uZnVzaW5nIHdpdGggJ21heCcgcmVmZXJlbmNlXG4gICAgaWYgKChfYVswXSA8PSB0aWxlX21pbi54ICsgdG9sZXJhbmNlICYmIF9iWzBdIDw9IHRpbGVfbWluLnggKyB0b2xlcmFuY2UpIHx8XG4gICAgICAgIChfYVswXSA+PSB0aWxlX21heC54IC0gdG9sZXJhbmNlICYmIF9iWzBdID49IHRpbGVfbWF4LnggLSB0b2xlcmFuY2UpIHx8XG4gICAgICAgIChfYVsxXSA+PSB0aWxlX21pbi55IC0gdG9sZXJhbmNlICYmIF9iWzFdID49IHRpbGVfbWluLnkgLSB0b2xlcmFuY2UpIHx8XG4gICAgICAgIChfYVsxXSA8PSB0aWxlX21heC55ICsgdG9sZXJhbmNlICYmIF9iWzFdIDw9IHRpbGVfbWF4LnkgKyB0b2xlcmFuY2UpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG4iLCIvLyBMaW5lIHJlbmRlcmluZyBzdHlsZVxuXG5pbXBvcnQge1N0eWxlfSBmcm9tICcuLi9zdHlsZSc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuLi9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IHtTdHlsZU1hbmFnZXJ9IGZyb20gJy4uL3N0eWxlX21hbmFnZXInO1xuaW1wb3J0IGdsIGZyb20gJy4uLy4uL2dsL2NvbnN0YW50cyc7IC8vIHdlYiB3b3JrZXJzIGRvbid0IGhhdmUgYWNjZXNzIHRvIEdMIGNvbnRleHQsIHNvIGltcG9ydCBhbGwgR0wgY29uc3RhbnRzXG5pbXBvcnQgVmVydGV4TGF5b3V0IGZyb20gJy4uLy4uL2dsL3ZlcnRleF9sYXlvdXQnO1xuaW1wb3J0IEJ1aWxkZXJzIGZyb20gJy4uL2J1aWxkZXJzJztcbmltcG9ydCBHZW8gZnJvbSAnLi4vLi4vZ2VvJztcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi91dGlscy91dGlscyc7XG5cbmV4cG9ydCB2YXIgTGluZXMgPSBPYmplY3QuY3JlYXRlKFN0eWxlKTtcblxuT2JqZWN0LmFzc2lnbihMaW5lcywge1xuICAgIG5hbWU6ICdsaW5lcycsXG4gICAgYnVpbHRfaW46IHRydWUsXG4gICAgdmVydGV4X3NoYWRlcl9rZXk6ICdzdHlsZXMvcG9seWdvbnMvcG9seWdvbnNfdmVydGV4JywgLy8gcmUtdXNlIHBvbHlnb24gc2hhZGVyc1xuICAgIGZyYWdtZW50X3NoYWRlcl9rZXk6ICdzdHlsZXMvcG9seWdvbnMvcG9seWdvbnNfZnJhZ21lbnQnLFxuICAgIHNlbGVjdGlvbjogdHJ1ZSwgLy8gdHVybiBmZWF0dXJlIHNlbGVjdGlvbiBvblxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgU3R5bGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIEJhc2ljIGF0dHJpYnV0ZXMsIG90aGVycyBjYW4gYmUgYWRkZWQgKHNlZSB0ZXh0dXJlIFVWcyBiZWxvdylcbiAgICAgICAgdmFyIGF0dHJpYnMgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3Bvc2l0aW9uJywgc2l6ZTogNCwgdHlwZTogZ2wuU0hPUlQsIG5vcm1hbGl6ZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfZXh0cnVkZScsIHNpemU6IDQsIHR5cGU6IGdsLlNIT1JULCBub3JtYWxpemVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX2NvbG9yJywgc2l6ZTogNCwgdHlwZTogZ2wuVU5TSUdORURfQllURSwgbm9ybWFsaXplZDogdHJ1ZSB9XG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gVGVsbCB0aGUgc2hhZGVyIHdlIHdhbnQgYSBvcmRlciBpbiB2ZXJ0ZXggYXR0cmlidXRlcywgYW5kIHRvIGV4dHJ1ZGUgbGluZXNcbiAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fTEFZRVJfT1JERVIgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9FWFRSVURFX0xJTkVTID0gdHJ1ZTtcblxuICAgICAgICAvLyBPcHRpb25hbCBmZWF0dXJlIHNlbGVjdGlvblxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGF0dHJpYnMucHVzaCh7IG5hbWU6ICdhX3NlbGVjdGlvbl9jb2xvcicsIHNpemU6IDQsIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEUsIG5vcm1hbGl6ZWQ6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcHRpb25hbCB0ZXh0dXJlIFVWc1xuICAgICAgICBpZiAodGhpcy50ZXhjb29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lcy5UQU5HUkFNX1RFWFRVUkVfQ09PUkRTID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQWRkIHZlcnRleCBhdHRyaWJ1dGUgZm9yIFVWcyBvbmx5IHdoZW4gbmVlZGVkXG4gICAgICAgICAgICBhdHRyaWJzLnB1c2goeyBuYW1lOiAnYV90ZXhjb29yZCcsIHNpemU6IDIsIHR5cGU6IGdsLlVOU0lHTkVEX1NIT1JULCBub3JtYWxpemVkOiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0ID0gbmV3IFZlcnRleExheW91dChhdHRyaWJzKTtcblxuICAgICAgICAvLyBBZGRpdGlvbmFsIHNpbmdsZS1hbGxvY2F0ZWQgb2JqZWN0IHVzZWQgZm9yIGhvbGRpbmcgb3V0bGluZSBzdHlsZSBhcyBpdCBpcyBwcm9jZXNzZWRcbiAgICAgICAgLy8gU2VwYXJhdGUgZnJvbSB0aGlzLmZlYXR1cmVfc3R5bGUgc28gdGhhdCBvdXRsaW5lIHByb3BlcnRpZXMgZG8gbm90IG92ZXJ3cml0ZSBjYWxjdWxhdGVkXG4gICAgICAgIC8vIGlubGluZSBwcm9wZXJ0aWVzIChvdXRsaW5lIGNhbGwgaXMgbWFkZSAqd2l0aGluKiB0aGUgaW5saW5lIGNhbGwpXG4gICAgICAgIHRoaXMub3V0bGluZV9mZWF0dXJlX3N0eWxlID0ge307XG4gICAgICAgIHRoaXMuaW5saW5lX2ZlYXR1cmVfc3R5bGUgPSB0aGlzLmZlYXR1cmVfc3R5bGU7IC8vIHNhdmUgcmVmZXJlbmNlIHRvIG1haW4gY29tcHV0ZWQgc3R5bGUgb2JqZWN0XG4gICAgfSxcblxuICAgIC8vIENhbGN1bGF0ZSB3aWR0aCBhdCB6b29tIGdpdmVuIGluIGBjb250ZXh0YFxuICAgIGNhbGNXaWR0aCAod2lkdGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuICh3aWR0aCAmJiBTdHlsZVBhcnNlci5jYWNoZURpc3RhbmNlKHdpZHRoLCBjb250ZXh0KSkgfHwgMDtcbiAgICB9LFxuXG4gICAgLy8gQ2FsY3VsYXRlIHdpZHRoIGF0IG5leHQgem9vbSAodXNlZCBmb3IgbGluZSB3aWR0aCBpbnRlcnBvbGF0aW9uKVxuICAgIGNhbGNXaWR0aE5leHRab29tICh3aWR0aCwgY29udGV4dCkge1xuICAgICAgICBjb250ZXh0Lnpvb20rKztcbiAgICAgICAgbGV0IHZhbCA9IHRoaXMuY2FsY1dpZHRoKHdpZHRoLCBjb250ZXh0KTtcbiAgICAgICAgY29udGV4dC56b29tLS07XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIF9wYXJzZUZlYXR1cmUgKGZlYXR1cmUsIHJ1bGVfc3R5bGUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5mZWF0dXJlX3N0eWxlO1xuXG4gICAgICAgIC8vIGxpbmUgd2lkdGggaW4gbWV0ZXJzXG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMuY2FsY1dpZHRoKHJ1bGVfc3R5bGUud2lkdGgsIGNvbnRleHQpO1xuICAgICAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIHNraXAgbGluZXMgd2l0aCBuZWdhdGl2ZSB3aWR0aFxuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0X3dpZHRoID0gdGhpcy5jYWxjV2lkdGhOZXh0Wm9vbShydWxlX3N0eWxlLm5leHRfd2lkdGgsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmICgod2lkdGggPT09IDAgJiYgbmV4dF93aWR0aCA9PT0gMCkgfHwgbmV4dF93aWR0aCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gc2tpcCBsaW5lcyB0aGF0IGRvbid0IGludGVycG9sYXRlIHRvIGEgcG9zaXRpdmUgdmFsdWUgYXQgbmV4dCB6b29tXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb252ZXJ0IHRvIHVuaXRzIGFuZCByZWxhdGl2ZSBjaGFuZ2UgZnJvbSBwcmV2aW91cyB6b29tXG4gICAgICAgIC8vIE5COiBtdWx0aXBseSBieSAyIGJlY2F1c2UgYSBnaXZlbiB3aWR0aCBpcyB0d2ljZSBhcyBiaWcgaW4gc2NyZWVuIHNwYWNlIGF0IHRoZSBuZXh0IHpvb21cbiAgICAgICAgc3R5bGUud2lkdGggPSB3aWR0aCAqIGNvbnRleHQudW5pdHNfcGVyX21ldGVyO1xuICAgICAgICBzdHlsZS5uZXh0X3dpZHRoID0gKG5leHRfd2lkdGggKiAyKSAtIHdpZHRoO1xuICAgICAgICBzdHlsZS5uZXh0X3dpZHRoICo9IGNvbnRleHQudW5pdHNfcGVyX21ldGVyO1xuICAgICAgICBzdHlsZS5uZXh0X3dpZHRoIC89IDI7IC8vIE5COiBkaXZpZGUgYnkgMiBiZWNhdXNlIGV4dHJ1c2lvbiB3aWR0aCBpcyBoYWx2ZWQgaW4gYnVpbGRlciAtIHJlbW92ZT9cblxuICAgICAgICBzdHlsZS5jb2xvciA9IHRoaXMucGFyc2VDb2xvcihydWxlX3N0eWxlLmNvbG9yLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKCFzdHlsZS5jb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGVpZ2h0IGRlZmF1bHRzIHRvIGZlYXR1cmUgaGVpZ2h0LCBidXQgZXh0cnVkZSBzdHlsZSBjYW4gZHluYW1pY2FsbHkgYWRqdXN0IGhlaWdodCBieSByZXR1cm5pbmcgYSBudW1iZXIgb3IgYXJyYXkgKGluc3RlYWQgb2YgYSBib29sZWFuKVxuICAgICAgICBzdHlsZS56ID0gKHJ1bGVfc3R5bGUueiAmJiBTdHlsZVBhcnNlci5jYWNoZURpc3RhbmNlKHJ1bGVfc3R5bGUueiB8fCAwLCBjb250ZXh0KSkgfHwgU3R5bGVQYXJzZXIuZGVmYXVsdHMuejtcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gZmVhdHVyZS5wcm9wZXJ0aWVzLmhlaWdodCB8fCBTdHlsZVBhcnNlci5kZWZhdWx0cy5oZWlnaHQ7XG4gICAgICAgIHN0eWxlLmV4dHJ1ZGUgPSBTdHlsZVBhcnNlci5ldmFsUHJvcChydWxlX3N0eWxlLmV4dHJ1ZGUsIGNvbnRleHQpO1xuICAgICAgICBpZiAoc3R5bGUuZXh0cnVkZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZS5leHRydWRlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IHN0eWxlLmV4dHJ1ZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHN0eWxlLmV4dHJ1ZGUpKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gc3R5bGUuZXh0cnVkZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJhaXNlIGxpbmUgaGVpZ2h0IGlmIGV4dHJ1ZGVkXG4gICAgICAgIGlmIChzdHlsZS5leHRydWRlICYmIHN0eWxlLmhlaWdodCkge1xuICAgICAgICAgICAgc3R5bGUueiArPSBzdHlsZS5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZS5jYXAgPSBydWxlX3N0eWxlLmNhcDtcbiAgICAgICAgc3R5bGUuam9pbiA9IHJ1bGVfc3R5bGUuam9pbjtcbiAgICAgICAgc3R5bGUubWl0ZXJfbGltaXQgPSBydWxlX3N0eWxlLm1pdGVyX2xpbWl0O1xuICAgICAgICBzdHlsZS50aWxlX2VkZ2VzID0gcnVsZV9zdHlsZS50aWxlX2VkZ2VzOyAvLyB1c3VhbGx5IGFjdGl2YXRlZCBmb3IgZGVidWdnaW5nLCBvciByYXJlIHZpc3VhbGl6YXRpb24gbmVlZHNcblxuICAgICAgICAvLyBDb25zdHJ1Y3QgYW4gb3V0bGluZSBzdHlsZVxuICAgICAgICAvLyBSZXVzYWJsZSBvdXRsaW5lIHN0eWxlIG9iamVjdCwgbWFya2VkIGFzIGFscmVhZHkgd3JhcHBlZCBpbiBjYWNoZSBvYmplY3RzIChwcmVwcm9jZXNzZWQgPSB0cnVlKVxuICAgICAgICBzdHlsZS5vdXRsaW5lID0gc3R5bGUub3V0bGluZSB8fCB7IHdpZHRoOiB7fSwgbmV4dF93aWR0aDoge30sIHByZXByb2Nlc3NlZDogdHJ1ZSB9O1xuXG4gICAgICAgIGlmIChydWxlX3N0eWxlLm91dGxpbmUgJiYgcnVsZV9zdHlsZS5vdXRsaW5lLmNvbG9yICYmIHJ1bGVfc3R5bGUub3V0bGluZS53aWR0aCkge1xuICAgICAgICAgICAgLy8gb3V0bGluZSB3aWR0aCBpbiBtZXRlcnNcbiAgICAgICAgICAgIC8vIE5COiBtdWx0aXBseSBieSAyIGJlY2F1c2Ugb3V0bGluZSBpcyBhcHBsaWVkIG9uIGJvdGggc2lkZXMgb2YgbGluZVxuICAgICAgICAgICAgbGV0IG91dGxpbmVfd2lkdGggPSB0aGlzLmNhbGNXaWR0aChydWxlX3N0eWxlLm91dGxpbmUud2lkdGgsIGNvbnRleHQpICogMjtcbiAgICAgICAgICAgIGxldCBvdXRsaW5lX25leHRfd2lkdGggPSB0aGlzLmNhbGNXaWR0aE5leHRab29tKHJ1bGVfc3R5bGUub3V0bGluZS5uZXh0X3dpZHRoLCBjb250ZXh0KSAqIDI7XG5cbiAgICAgICAgICAgIGlmICgob3V0bGluZV93aWR0aCA9PT0gMCAmJiBvdXRsaW5lX25leHRfd2lkdGggPT09IDApIHx8IG91dGxpbmVfd2lkdGggPCAwIHx8IG91dGxpbmVfbmV4dF93aWR0aCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIGxpbmVzIHRoYXQgZG9uJ3QgaW50ZXJwb2xhdGUgYmV0d2VlbiB6ZXJvIG9yIGdyZWF0ZXIgd2lkdGhcbiAgICAgICAgICAgICAgICBzdHlsZS5vdXRsaW5lLndpZHRoLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdHlsZS5vdXRsaW5lLm5leHRfd2lkdGgudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN0eWxlLm91dGxpbmUuY29sb3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWFpbnRhaW4gY29uc2lzdGVudCBvdXRsaW5lIHdpZHRoIGFyb3VuZCB0aGUgbGluZSBmaWxsXG4gICAgICAgICAgICAgICAgc3R5bGUub3V0bGluZS53aWR0aC52YWx1ZSA9IG91dGxpbmVfd2lkdGggKyB3aWR0aDtcbiAgICAgICAgICAgICAgICBzdHlsZS5vdXRsaW5lLm5leHRfd2lkdGgudmFsdWUgPSBvdXRsaW5lX25leHRfd2lkdGggKyBuZXh0X3dpZHRoO1xuXG4gICAgICAgICAgICAgICAgc3R5bGUub3V0bGluZS5jb2xvciA9IHJ1bGVfc3R5bGUub3V0bGluZS5jb2xvcjtcbiAgICAgICAgICAgICAgICBzdHlsZS5vdXRsaW5lLmNhcCA9IHJ1bGVfc3R5bGUub3V0bGluZS5jYXAgfHwgcnVsZV9zdHlsZS5jYXA7XG4gICAgICAgICAgICAgICAgc3R5bGUub3V0bGluZS5qb2luID0gcnVsZV9zdHlsZS5vdXRsaW5lLmpvaW4gfHwgcnVsZV9zdHlsZS5qb2luO1xuICAgICAgICAgICAgICAgIHN0eWxlLm91dGxpbmUubWl0ZXJfbGltaXQgPSBydWxlX3N0eWxlLm91dGxpbmUubWl0ZXJfbGltaXQgfHwgcnVsZV9zdHlsZS5taXRlcl9saW1pdDtcbiAgICAgICAgICAgICAgICBzdHlsZS5vdXRsaW5lLnN0eWxlID0gcnVsZV9zdHlsZS5vdXRsaW5lLnN0eWxlIHx8IHRoaXMubmFtZTtcblxuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgZGVmaW5lZCBvdXRsaW5lIG9yZGVyLCBvciBpbmhlcml0ZWQgZnJvbSBpbm5lciBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGVfc3R5bGUub3V0bGluZS5vcmRlcikge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5vdXRsaW5lLm9yZGVyID0gdGhpcy5wYXJzZU9yZGVyKHJ1bGVfc3R5bGUub3V0bGluZS5vcmRlciwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5vdXRsaW5lLm9yZGVyID0gc3R5bGUub3JkZXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgbGV0IG91dGxpbmUgYmUgYWJvdmUgaW5uZXIgbGluZVxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5vdXRsaW5lLm9yZGVyID4gc3R5bGUub3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUub3V0bGluZS5vcmRlciA9IHN0eWxlLm9yZGVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE91dGxpbmVzIGFyZSBhbHdheXMgYXQgaGFsZi1sYXllciBpbnRlcnZhbHMgdG8gYXZvaWQgY29uZmxpY3Rpbmcgd2l0aCBpbm5lciBsaW5lc1xuICAgICAgICAgICAgICAgIHN0eWxlLm91dGxpbmUub3JkZXIgLT0gMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3R5bGUub3V0bGluZS53aWR0aC52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBzdHlsZS5vdXRsaW5lLm5leHRfd2lkdGgudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgc3R5bGUub3V0bGluZS5jb2xvciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcblxuICAgIF9wcmVwcm9jZXNzIChkcmF3KSB7XG4gICAgICAgIGRyYXcuY29sb3IgPSBTdHlsZVBhcnNlci5jb2xvckNhY2hlT2JqZWN0KGRyYXcuY29sb3IpO1xuICAgICAgICBkcmF3LndpZHRoID0gU3R5bGVQYXJzZXIuY2FjaGVPYmplY3QoZHJhdy53aWR0aCwgU3R5bGVQYXJzZXIuY2FjaGVVbml0cyk7XG4gICAgICAgIGRyYXcubmV4dF93aWR0aCA9IFN0eWxlUGFyc2VyLmNhY2hlT2JqZWN0KGRyYXcud2lkdGgsIFN0eWxlUGFyc2VyLmNhY2hlVW5pdHMpOyAvLyB3aWR0aCB3aWxsIGJlIGNvbXB1dGVkIGZvciBuZXh0IHpvb21cbiAgICAgICAgZHJhdy56ID0gU3R5bGVQYXJzZXIuY2FjaGVPYmplY3QoZHJhdy56LCBTdHlsZVBhcnNlci5jYWNoZVVuaXRzKTtcblxuICAgICAgICBpZiAoZHJhdy5vdXRsaW5lKSB7XG4gICAgICAgICAgICBkcmF3Lm91dGxpbmUuY29sb3IgPSBTdHlsZVBhcnNlci5jb2xvckNhY2hlT2JqZWN0KGRyYXcub3V0bGluZS5jb2xvcik7XG4gICAgICAgICAgICBkcmF3Lm91dGxpbmUud2lkdGggPSBTdHlsZVBhcnNlci5jYWNoZU9iamVjdChkcmF3Lm91dGxpbmUud2lkdGgsIFN0eWxlUGFyc2VyLmNhY2hlVW5pdHMpO1xuICAgICAgICAgICAgZHJhdy5vdXRsaW5lLm5leHRfd2lkdGggPSBTdHlsZVBhcnNlci5jYWNoZU9iamVjdChkcmF3Lm91dGxpbmUud2lkdGgsIFN0eWxlUGFyc2VyLmNhY2hlVW5pdHMpOyAvLyB3aWR0aCByZS1jb21wdXRlZCBmb3IgbmV4dCB6b29tXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgXCJ0ZW1wbGF0ZVwiIHRoYXQgc2V0cyBjb25zdGFudCBhdHRpYnV0ZXMgZm9yIGVhY2ggdmVydGV4LCB3aGljaCBpcyB0aGVuIG1vZGlmaWVkIHBlciB2ZXJ0ZXggb3IgcGVyIGZlYXR1cmUuXG4gICAgICogQSBwbGFpbiBKUyBhcnJheSBtYXRjaGluZyB0aGUgb3JkZXIgb2YgdGhlIHZlcnRleCBsYXlvdXQuXG4gICAgICovXG4gICAgbWFrZVZlcnRleFRlbXBsYXRlKHN0eWxlKSB7XG4gICAgICAgIGxldCBpID0gMDtcblxuICAgICAgICAvLyBwb3NpdGlvbiAtIHggJiB5IGNvb3JkcyB3aWxsIGJlIGZpbGxlZCBpbiBwZXItdmVydGV4IGJlbG93XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gMDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLnogfHwgMDtcblxuICAgICAgICAvLyBsYXllciBvcmRlciAtIHcgY29vcmQgb2YgJ3Bvc2l0aW9uJyBhdHRyaWJ1dGUgKGZvciBwYWNraW5nIGVmZmljaWVuY3kpXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSB0aGlzLnNjYWxlT3JkZXIoc3R5bGUub3JkZXIpO1xuXG4gICAgICAgIC8vIGV4dHJ1c2lvbiB2ZWN0b3JcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IDA7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gMDtcblxuICAgICAgICAvLyBzY2FsaW5nIHRvIHByZXZpb3VzIGFuZCBuZXh0IHpvb21cbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLm5leHRfd2lkdGg7XG5cbiAgICAgICAgLy8gY29sb3JcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLmNvbG9yWzBdICogMjU1O1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUuY29sb3JbMV0gKiAyNTU7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5jb2xvclsyXSAqIDI1NTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLmNvbG9yWzNdICogMjU1O1xuXG4gICAgICAgIC8vIHNlbGVjdGlvbiBjb2xvclxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5zZWxlY3Rpb25fY29sb3JbMF0gKiAyNTU7XG4gICAgICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzFdICogMjU1O1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLnNlbGVjdGlvbl9jb2xvclsyXSAqIDI1NTtcbiAgICAgICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5zZWxlY3Rpb25fY29sb3JbM10gKiAyNTU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGV4dHVyZSBVVnMgdG8gdGVtcGxhdGUgb25seSBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHRoaXMudGV4Y29vcmRzKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gMDtcbiAgICAgICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGV4X3RlbXBsYXRlO1xuICAgIH0sXG5cbiAgICBidWlsZExpbmVzKGxpbmVzLCBzdHlsZSwgdmVydGV4X2RhdGEsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gT3V0bGluZSAoYnVpbGQgZmlyc3Qgc28gdGhhdCBibGVuZGVkIGdlb21ldHJ5IHdpdGhvdXQgYSBkZXB0aCB0ZXN0IGlzIGRyYXduIGZpcnN0L3VuZGVyIHRoZSBpbm5lciBsaW5lKVxuICAgICAgICB0aGlzLmZlYXR1cmVfc3R5bGUgPSB0aGlzLm91dGxpbmVfZmVhdHVyZV9zdHlsZTsgLy8gc3dhcCBpbiBvdXRsaW5lLXNwZWNpZmljIHN0eWxlIGhvbGRlclxuICAgICAgICBpZiAoc3R5bGUub3V0bGluZSAmJiBzdHlsZS5vdXRsaW5lLmNvbG9yICE9IG51bGwgJiYgc3R5bGUub3V0bGluZS53aWR0aC52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgb3V0bGluZV9zdHlsZSA9IFN0eWxlTWFuYWdlci5zdHlsZXNbc3R5bGUub3V0bGluZS5zdHlsZV07XG4gICAgICAgICAgICBpZiAob3V0bGluZV9zdHlsZSkge1xuICAgICAgICAgICAgICAgIG91dGxpbmVfc3R5bGUuYWRkRmVhdHVyZShjb250ZXh0LmZlYXR1cmUsIHN0eWxlLm91dGxpbmUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFpbiBsaW5lXG4gICAgICAgIHRoaXMuZmVhdHVyZV9zdHlsZSA9IHRoaXMuaW5saW5lX2ZlYXR1cmVfc3R5bGU7IC8vIHJlc3RvcmUgY2FsY3VsYXRlZCBzdHlsZSBmb3IgaW5saW5lXG4gICAgICAgIGxldCB2ZXJ0ZXhfdGVtcGxhdGUgPSB0aGlzLm1ha2VWZXJ0ZXhUZW1wbGF0ZShzdHlsZSk7XG4gICAgICAgIEJ1aWxkZXJzLmJ1aWxkUG9seWxpbmVzKFxuICAgICAgICAgICAgbGluZXMsXG4gICAgICAgICAgICBzdHlsZS53aWR0aCxcbiAgICAgICAgICAgIHZlcnRleF9kYXRhLFxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNhcDogc3R5bGUuY2FwLFxuICAgICAgICAgICAgICAgIGpvaW46IHN0eWxlLmpvaW4sXG4gICAgICAgICAgICAgICAgbWl0ZXJfbGltaXQ6IHN0eWxlLm1pdGVyX2xpbWl0LFxuICAgICAgICAgICAgICAgIHNjYWxpbmdfaW5kZXg6IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX2V4dHJ1ZGUsXG4gICAgICAgICAgICAgICAgc2NhbGluZ19ub3JtYWxpemU6IFV0aWxzLnNjYWxlSW50MTYoMSwgMjU2KSwgLy8gc2NhbGUgZXh0cnVzaW9uIG5vcm1hbHMgdG8gc2lnbmVkIHNob3J0cyB3LzI1NiB1bml0IGJhc2lzXG4gICAgICAgICAgICAgICAgdGV4Y29vcmRfaW5kZXg6IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX3RleGNvb3JkLFxuICAgICAgICAgICAgICAgIHRleGNvb3JkX3NjYWxlOiB0aGlzLnRleGNvb3JkX3NjYWxlLFxuICAgICAgICAgICAgICAgIHRleGNvb3JkX25vcm1hbGl6ZTogNjU1MzUsIC8vIHNjYWxlIFVWcyB0byB1bnNpZ25lZCBzaG9ydHNcbiAgICAgICAgICAgICAgICBjbG9zZWRfcG9seWdvbjogb3B0aW9ucyAmJiBvcHRpb25zLmNsb3NlZF9wb2x5Z29uLFxuICAgICAgICAgICAgICAgIHJlbW92ZV90aWxlX2VkZ2VzOiAhc3R5bGUudGlsZV9lZGdlcyAmJiBvcHRpb25zICYmIG9wdGlvbnMucmVtb3ZlX3RpbGVfZWRnZXMsXG4gICAgICAgICAgICAgICAgdGlsZV9lZGdlX3RvbGVyYW5jZTogR2VvLnRpbGVfc2NhbGUgKiBjb250ZXh0LnRpbGUucGFkX3NjYWxlICogNFxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBidWlsZFBvbHlnb25zKHBvbHlnb25zLCBzdHlsZSwgdmVydGV4X2RhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gUmVuZGVyIHBvbHlnb25zIGFzIGluZGl2aWR1YWwgbGluZXNcbiAgICAgICAgZm9yIChsZXQgcD0wOyBwIDwgcG9seWdvbnMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRMaW5lcyhwb2x5Z29uc1twXSwgc3R5bGUsIHZlcnRleF9kYXRhLCBjb250ZXh0LCB7IGNsb3NlZF9wb2x5Z29uOiB0cnVlLCByZW1vdmVfdGlsZV9lZGdlczogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG4iLCIvLyBTZXRzIG9mIHZhbHVlcyB0byBtYXRjaCBmb3IgZGlyZWN0aW9uYWwgYW5kIGNvcm5lciBhbmNob3JzXG5jb25zdCBsZWZ0cyA9IFsnbGVmdCcsICd0b3AtbGVmdCcsICdib3R0b20tbGVmdCddO1xuY29uc3QgcmlnaHRzID0gWydyaWdodCcsICd0b3AtcmlnaHQnLCAnYm90dG9tLXJpZ2h0J107XG5jb25zdCB0b3BzID0gWyd0b3AnLCAndG9wLWxlZnQnLCAndG9wLXJpZ2h0J107XG5jb25zdCBib3R0b21zID0gWydib3R0b20nLCAnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0J107XG5cbnZhciBQb2ludEFuY2hvcjtcblxuZXhwb3J0IGRlZmF1bHQgUG9pbnRBbmNob3IgPSB7XG5cbiAgICBjb21wdXRlT2Zmc2V0IChvZmZzZXQsIHNpemUsIGFuY2hvcikge1xuICAgICAgICBpZiAoIWFuY2hvciB8fCBhbmNob3IgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9mZnNldDIgPSBbb2Zmc2V0WzBdLCBvZmZzZXRbMV1dO1xuXG4gICAgICAgIC8vIEFuIG9wdGlvbmFsIGxlZnQvcmlnaHQgb2Zmc2V0XG4gICAgICAgIGlmICh0aGlzLmlzTGVmdEFuY2hvcihhbmNob3IpKSB7XG4gICAgICAgICAgICBvZmZzZXQyWzBdIC09IHNpemVbMF0gLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNSaWdodEFuY2hvcihhbmNob3IpKSB7XG4gICAgICAgICAgICBvZmZzZXQyWzBdICs9IHNpemVbMF0gLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW4gb3B0aW9uYWwgdG9wL2JvdHRvbSBvZmZzZXRcbiAgICAgICAgaWYgKHRoaXMuaXNUb3BBbmNob3IoYW5jaG9yKSkge1xuICAgICAgICAgICAgb2Zmc2V0MlsxXSAtPSBzaXplWzFdIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzQm90dG9tQW5jaG9yKGFuY2hvcikpIHtcbiAgICAgICAgICAgIG9mZnNldDJbMV0gKz0gc2l6ZVsxXSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2Zmc2V0MjtcbiAgICB9LFxuXG4gICAgaXNMZWZ0QW5jaG9yIChhbmNob3IpIHtcbiAgICAgICAgcmV0dXJuIChsZWZ0cy5pbmRleE9mKGFuY2hvcikgPiAtMSk7XG4gICAgfSxcblxuICAgIGlzUmlnaHRBbmNob3IgKGFuY2hvcikge1xuICAgICAgICByZXR1cm4gKHJpZ2h0cy5pbmRleE9mKGFuY2hvcikgPiAtMSk7XG4gICAgfSxcblxuICAgIGlzVG9wQW5jaG9yIChhbmNob3IpIHtcbiAgICAgICAgcmV0dXJuICh0b3BzLmluZGV4T2YoYW5jaG9yKSA+IC0xKTtcbiAgICB9LFxuXG4gICAgaXNCb3R0b21BbmNob3IgKGFuY2hvcikge1xuICAgICAgICByZXR1cm4gKGJvdHRvbXMuaW5kZXhPZihhbmNob3IpID4gLTEpO1xuICAgIH1cblxufTtcbiIsIi8vIFBvaW50IHJlbmRlcmluZyBzdHlsZVxuXG5pbXBvcnQge1N0eWxlfSBmcm9tICcuLi9zdHlsZSc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuLi9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IGdsIGZyb20gJy4uLy4uL2dsL2NvbnN0YW50cyc7IC8vIHdlYiB3b3JrZXJzIGRvbid0IGhhdmUgYWNjZXNzIHRvIEdMIGNvbnRleHQsIHNvIGltcG9ydCBhbGwgR0wgY29uc3RhbnRzXG5pbXBvcnQgVmVydGV4TGF5b3V0IGZyb20gJy4uLy4uL2dsL3ZlcnRleF9sYXlvdXQnO1xuaW1wb3J0IEJ1aWxkZXJzIGZyb20gJy4uL2J1aWxkZXJzJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4uLy4uL2dsL3RleHR1cmUnO1xuaW1wb3J0IEdlbyBmcm9tICcuLi8uLi9nZW8nO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vLi4vdmVjdG9yJztcbmltcG9ydCBDb2xsaXNpb24gZnJvbSAnLi4vLi4vbGFiZWxzL2NvbGxpc2lvbic7XG5pbXBvcnQgTGFiZWxQb2ludCBmcm9tICcuLi8uLi9sYWJlbHMvbGFiZWxfcG9pbnQnO1xuXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxuZXhwb3J0IHZhciBQb2ludHMgPSBPYmplY3QuY3JlYXRlKFN0eWxlKTtcblxuT2JqZWN0LmFzc2lnbihQb2ludHMsIHtcbiAgICBuYW1lOiAncG9pbnRzJyxcbiAgICBidWlsdF9pbjogdHJ1ZSxcbiAgICBzZWxlY3Rpb246IHRydWUsIC8vIHR1cm4gZmVhdHVyZSBzZWxlY3Rpb24gb25cbiAgICBibGVuZDogJ292ZXJsYXknLCAvLyBvdmVybGF5cyBkcmF3biBvbiB0b3Agb2YgYWxsIG90aGVyIHN0eWxlcywgd2l0aCBibGVuZGluZ1xuXG4gICAgaW5pdChvcHRpb25zID0ge30pIHtcbiAgICAgICAgU3R5bGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIEJhc2Ugc2hhZGVyc1xuICAgICAgICB0aGlzLnZlcnRleF9zaGFkZXJfa2V5ID0gJ3N0eWxlcy9wb2ludHMvcG9pbnRzX3ZlcnRleCc7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRfc2hhZGVyX2tleSA9ICdzdHlsZXMvcG9pbnRzL3BvaW50c19mcmFnbWVudCc7XG5cbiAgICAgICAgdmFyIGF0dHJpYnMgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3Bvc2l0aW9uJywgc2l6ZTogNCwgdHlwZTogZ2wuU0hPUlQsIG5vcm1hbGl6ZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2Ffc2hhcGUnLCBzaXplOiA0LCB0eXBlOiBnbC5TSE9SVCwgbm9ybWFsaXplZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYV90ZXhjb29yZCcsIHNpemU6IDIsIHR5cGU6IGdsLlVOU0lHTkVEX1NIT1JULCBub3JtYWxpemVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX29mZnNldCcsIHNpemU6IDIsIHR5cGU6IGdsLlNIT1JULCBub3JtYWxpemVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX2NvbG9yJywgc2l6ZTogNCwgdHlwZTogZ2wuVU5TSUdORURfQllURSwgbm9ybWFsaXplZDogdHJ1ZSB9XG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gT3B0aW9uYWwgZmVhdHVyZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBhdHRyaWJzLnB1c2goeyBuYW1lOiAnYV9zZWxlY3Rpb25fY29sb3InLCBzaXplOiA0LCB0eXBlOiBnbC5VTlNJR05FRF9CWVRFLCBub3JtYWxpemVkOiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UncmUgbm90IHJlbmRlcmluZyBhcyBvdmVybGF5LCB3ZSBuZWVkIGEgbGF5ZXIgYXR0cmlidXRlXG4gICAgICAgIGlmICh0aGlzLmJsZW5kICE9PSAnb3ZlcmxheScpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lcy5UQU5HUkFNX0xBWUVSX09SREVSID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmVydGV4X2xheW91dCA9IG5ldyBWZXJ0ZXhMYXlvdXQoYXR0cmlicyk7XG5cbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fUE9JTlRfVEVYVFVSRSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNoYWRlcnMudW5pZm9ybXMgPSB0aGlzLnNoYWRlcnMudW5pZm9ybXMgfHwge307XG4gICAgICAgICAgICB0aGlzLnNoYWRlcnMudW5pZm9ybXMudV90ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5xdWV1ZXMgPSB7fTtcbiAgICB9LFxuXG4gICAgcmVzZXQgKCkge1xuICAgICAgICB0aGlzLnF1ZXVlcyA9IHt9O1xuICAgIH0sXG5cbiAgICAvLyBPdmVycmlkZSB0byBxdWV1ZSBmZWF0dXJlcyBpbnN0ZWFkIG9mIHByb2Nlc3NpbmcgaW1tZWRpYXRlbHlcbiAgICBhZGRGZWF0dXJlIChmZWF0dXJlLCBkcmF3LCBjb250ZXh0KSB7XG4gICAgICAgIGxldCB0aWxlID0gY29udGV4dC50aWxlO1xuXG4gICAgICAgIC8vIENhbGxlZCBoZXJlIGJlY2F1c2Ugb3RoZXJ3aXNlIGl0IHdpbGwgYmUgZGVsYXllZCB1bnRpbCB0aGUgZmVhdHVyZSBxdWV1ZSBpcyBwYXJzZWQsXG4gICAgICAgIC8vIGFuZCB3ZSB3YW50IHRoZSBwcmVwcm9jZXNzaW5nIGRvbmUgYmVmb3JlIHdlIGV2YWx1YXRlIHRleHQgc3R5bGUgYmVsb3dcbiAgICAgICAgZHJhdyA9IHRoaXMucHJlcHJvY2VzcyhkcmF3KTtcbiAgICAgICAgaWYgKCFkcmF3KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3R5bGUgPSB7fTtcbiAgICAgICAgc3R5bGUuY29sb3IgPSB0aGlzLnBhcnNlQ29sb3IoZHJhdy5jb2xvciwgY29udGV4dCk7XG5cbiAgICAgICAgLy8gcmVxdWlyZSBjb2xvciBvciB0ZXh0dXJlXG4gICAgICAgIGlmICghc3R5bGUuY29sb3IgJiYgIXRoaXMudGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3ByaXRlID0gc3R5bGUuc3ByaXRlID0gU3R5bGVQYXJzZXIuZXZhbFByb3AoZHJhdy5zcHJpdGUsIGNvbnRleHQpO1xuICAgICAgICBzdHlsZS5zcHJpdGVfZGVmYXVsdCA9IGRyYXcuc3ByaXRlX2RlZmF1bHQ7IC8vIG9wdGlvbmFsIGZhbGxiYWNrIGlmICdzcHJpdGUnIG5vdCBmb3VuZFxuXG4gICAgICAgIC8vIGlmIHBvaW50IGhhcyB0ZXh0dXJlIGFuZCBzcHJpdGVzLCByZXF1aXJlIGEgdmFsaWQgc3ByaXRlIHRvIGRyYXdcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSAmJiBUZXh0dXJlLnRleHR1cmVzW3RoaXMudGV4dHVyZV0gJiYgVGV4dHVyZS50ZXh0dXJlc1t0aGlzLnRleHR1cmVdLnNwcml0ZXMpIHtcbiAgICAgICAgICAgIGlmICghc3ByaXRlICYmICFzdHlsZS5zcHJpdGVfZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFUZXh0dXJlLnRleHR1cmVzW3RoaXMudGV4dHVyZV0uc3ByaXRlc1tzcHJpdGVdKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc3ByaXRlIG5vdCBmb3VuZCwgY2hlY2sgZm9yIGRlZmF1bHQgc3ByaXRlXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnNwcml0ZV9kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZSA9IHN0eWxlLnNwcml0ZV9kZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIVRleHR1cmUudGV4dHVyZXNbdGhpcy50ZXh0dXJlXS5zcHJpdGVzW3Nwcml0ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKGBTdHlsZTogaW4gc3R5bGUgJyR7dGhpcy5uYW1lfScsIGNvdWxkIG5vdCBmaW5kIGRlZmF1bHQgc3ByaXRlICcke3Nwcml0ZX0nIGZvciB0ZXh0dXJlICcke3RoaXMudGV4dHVyZX0nYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKGBTdHlsZTogaW4gc3R5bGUgJyR7dGhpcy5uYW1lfScsIGNvdWxkIG5vdCBmaW5kIHNwcml0ZSAnJHtzcHJpdGV9JyBmb3IgdGV4dHVyZSAnJHt0aGlzLnRleHR1cmV9J2ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNwcml0ZSkge1xuICAgICAgICAgICAgbG9nLndhcm4oYFN0eWxlOiBpbiBzdHlsZSAnJHt0aGlzLm5hbWV9Jywgc3ByaXRlICcke3Nwcml0ZX0nIHdhcyBzcGVjaWZpZWQsIGJ1dCB0ZXh0dXJlICcke3RoaXMudGV4dHVyZX0nIGhhcyBubyBzcHJpdGVzYCk7XG4gICAgICAgICAgICBzcHJpdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0cyB0ZXhjb29yZCBzY2FsZSBpZiBuZWVkZWQgKGUuZy4gZm9yIHNwcml0ZSBzdWItYXJlYSlcbiAgICAgICAgbGV0IHNwcml0ZV9pbmZvO1xuICAgICAgICBpZiAodGhpcy50ZXh0dXJlICYmIHNwcml0ZSkge1xuICAgICAgICAgICAgc3ByaXRlX2luZm8gPSBUZXh0dXJlLmdldFNwcml0ZUluZm8odGhpcy50ZXh0dXJlLCBzcHJpdGUpO1xuICAgICAgICAgICAgc3R5bGUudGV4Y29vcmRzID0gc3ByaXRlX2luZm8udGV4Y29vcmRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGUudGV4Y29vcmRzID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBvaW50cyBjYW4gYmUgcGxhY2VkIG9mZiB0aGUgZ3JvdW5kXG4gICAgICAgIHN0eWxlLnogPSAoZHJhdy56ICYmIFN0eWxlUGFyc2VyLmNhY2hlRGlzdGFuY2UoZHJhdy56LCBjb250ZXh0KSkgfHwgU3R5bGVQYXJzZXIuZGVmYXVsdHMuejtcblxuICAgICAgICAvLyBwb2ludCBzaXplIGRlZmluZWQgZXhwbGljaXRseSwgb3IgZGVmYXVsdHMgdG8gc3ByaXRlIHNpemUsIG9yIGdlbmVyaWMgZmFsbGJhY2tcbiAgICAgICAgc3R5bGUuc2l6ZSA9IGRyYXcuc2l6ZTtcbiAgICAgICAgaWYgKCFzdHlsZS5zaXplKSB7XG4gICAgICAgICAgICBpZiAoc3ByaXRlX2luZm8pIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5zaXplID0gc3ByaXRlX2luZm8uc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlLnNpemUgPSBbMTYsIDE2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlLnNpemUgPSBTdHlsZVBhcnNlci5jYWNoZVByb3BlcnR5KHN0eWxlLnNpemUsIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2l6ZSB3aWxsIGJlIHNjYWxlZCB0byAxNi1iaXQgc2lnbmVkIGludCwgc28gbWF4IGFsbG93ZWQgd2lkdGggKyBoZWlnaHQgb2YgMjU2IHBpeGVsc1xuICAgICAgICBzdHlsZS5zaXplID0gW1xuICAgICAgICAgICAgTWF0aC5taW4oKHN0eWxlLnNpemVbMF0gfHwgc3R5bGUuc2l6ZSksIDI1NiksXG4gICAgICAgICAgICBNYXRoLm1pbigoc3R5bGUuc2l6ZVsxXSB8fCBzdHlsZS5zaXplKSwgMjU2KVxuICAgICAgICBdO1xuXG4gICAgICAgIHN0eWxlLmFuZ2xlID0gU3R5bGVQYXJzZXIuZXZhbFByb3AoZHJhdy5hbmdsZSwgY29udGV4dCkgfHwgMDtcblxuICAgICAgICAvLyBwb2x5Z29ucyByZW5kZXJpbmcgYXMgcG9pbnRzIHdpbGwgcmVuZGVyIGF0IHRoZSBwb2x5Z29uJ3MgY2VudHJvaWQgYnkgZGVmYXVsdCxcbiAgICAgICAgLy8gYnV0IGNhbiBiZSBzZXQgdG8gcmVuZGVyIGF0IGVhY2ggaW5kaXZpZHVhbCBwb2x5Z29uIHBvaW50IGluc3RlYWRcbiAgICAgICAgc3R5bGUuY2VudHJvaWQgPSAoZHJhdy5jZW50cm9pZCAhPSBudWxsKSA/IGRyYXcuY2VudHJvaWQgOiB0cnVlO1xuXG4gICAgICAgIHRoaXMuY29tcHV0ZUxheW91dChzdHlsZSwgZmVhdHVyZSwgZHJhdywgY29udGV4dCwgdGlsZSk7XG5cbiAgICAgICAgLy8gUXVldWUgdGhlIGZlYXR1cmUgZm9yIHByb2Nlc3NpbmdcbiAgICAgICAgaWYgKCF0aGlzLnRpbGVfZGF0YVt0aWxlLmtleV0pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnREYXRhKHRpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnF1ZXVlc1t0aWxlLmtleV0pIHtcbiAgICAgICAgICAgIHRoaXMucXVldWVzW3RpbGUua2V5XSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5xdWV1ZXNbdGlsZS5rZXldLnB1c2goe1xuICAgICAgICAgICAgZmVhdHVyZSwgZHJhdywgY29udGV4dCwgc3R5bGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgd2l0aCBjb2xsaXNpb24gbWFuYWdlclxuICAgICAgICBDb2xsaXNpb24uYWRkU3R5bGUodGhpcy5uYW1lLCB0aWxlLmtleSk7XG4gICAgfSxcblxuICAgIC8vIE92ZXJyaWRlXG4gICAgZW5kRGF0YSAodGlsZSkge1xuICAgICAgICBpZiAodGlsZS5jYW5jZWxlZCkge1xuICAgICAgICAgICAgVXRpbHMubG9nKCd0cmFjZScsIGBTdHlsZSAke3RoaXMubmFtZX06IHN0b3AgdGlsZSBidWlsZCBiZWNhdXNlIHRpbGUgd2FzIGNhbmNlbGVkOiAke3RpbGUua2V5fWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHF1ZXVlID0gdGhpcy5xdWV1ZXNbdGlsZS5rZXldO1xuICAgICAgICB0aGlzLnF1ZXVlc1t0aWxlLmtleV0gPSBbXTtcblxuICAgICAgICAvLyBGb3IgZWFjaCBmZWF0dXJlLCBjcmVhdGUgb25lIG9yIG1vcmUgcG9pbnQgbGFiZWxzXG4gICAgICAgIGxldCBib3hlcyA9IFtdO1xuICAgICAgICBxdWV1ZS5mb3JFYWNoKHEgPT4ge1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gcS5zdHlsZTtcbiAgICAgICAgICAgIGxldCBmZWF0dXJlID0gcS5mZWF0dXJlO1xuICAgICAgICAgICAgbGV0IGdlb21ldHJ5ID0gZmVhdHVyZS5nZW9tZXRyeTtcblxuICAgICAgICAgICAgbGV0IGZlYXR1cmVfbGFiZWxzID0gdGhpcy5idWlsZExhYmVsc0Zyb21HZW9tZXRyeShzdHlsZS5zaXplLCBnZW9tZXRyeSwgc3R5bGUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmZWF0dXJlX2xhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBsYWJlbCA9IGZlYXR1cmVfbGFiZWxzW2ldO1xuICAgICAgICAgICAgICAgIGJveGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLFxuICAgICAgICAgICAgICAgICAgICBkcmF3OiBxLmRyYXcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHEuY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIGxheW91dDogc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN1Ym1pdCBwb2ludCBsYWJlbHMgZm9yIGNvbGxpc2lvbiwgdGhlbiBidWlsZCBnZW9tZXRyeSBmb3IgcmVtYWluaW5nIG9uZXNcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbi5jb2xsaWRlKGJveGVzLCB0aGlzLm5hbWUsIHRpbGUua2V5KS50aGVuKGJveGVzID0+IHtcbiAgICAgICAgICAgIGJveGVzLmZvckVhY2gocSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlX3N0eWxlID0gcS5zdHlsZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmVfc3R5bGUubGFiZWwgPSBxLmxhYmVsO1xuXG4gICAgICAgICAgICAgICAgU3R5bGUuYWRkRmVhdHVyZS5jYWxsKHRoaXMsIHEuZmVhdHVyZSwgcS5kcmF3LCBxLmNvbnRleHQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBTdHlsZS5lbmREYXRhLmNhbGwodGhpcywgdGlsZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfcHJlcHJvY2VzcyAoZHJhdykge1xuICAgICAgICBkcmF3LmNvbG9yID0gU3R5bGVQYXJzZXIuY29sb3JDYWNoZU9iamVjdChkcmF3LmNvbG9yKTtcbiAgICAgICAgZHJhdy56ID0gU3R5bGVQYXJzZXIuY2FjaGVPYmplY3QoZHJhdy56LCBTdHlsZVBhcnNlci5jYWNoZVVuaXRzKTtcblxuICAgICAgICAvLyBTaXplICgxZCB2YWx1ZSBvciAyZCBhcnJheSlcbiAgICAgICAgZHJhdy5zaXplID0gU3R5bGVQYXJzZXIuY2FjaGVPYmplY3QoZHJhdy5zaXplLCB2ID0+IEFycmF5LmlzQXJyYXkodikgPyB2Lm1hcChwYXJzZUZsb2F0KSA6IHBhcnNlRmxvYXQodikpO1xuXG4gICAgICAgIC8vIE9mZnNldCAoMmQgYXJyYXkpXG4gICAgICAgIGRyYXcub2Zmc2V0ID0gU3R5bGVQYXJzZXIuY2FjaGVPYmplY3QoZHJhdy5vZmZzZXQsIHYgPT4gKEFycmF5LmlzQXJyYXkodikgJiYgdi5tYXAocGFyc2VGbG9hdCkpIHx8IDApO1xuXG4gICAgICAgIC8vIEJ1ZmZlciAoMWQgdmFsdWUgb3IgMmQgYXJyYXksIGV4cGFuZCAxZCB0byAyZClcbiAgICAgICAgZHJhdy5idWZmZXIgPSBTdHlsZVBhcnNlci5jYWNoZU9iamVjdChkcmF3LmJ1ZmZlciwgdiA9PiAoQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbdiwgdl0pLm1hcChwYXJzZUZsb2F0KSB8fCAwKTtcblxuICAgICAgICByZXR1cm4gZHJhdztcbiAgICB9LFxuXG4gICAgLy8gQ29tcHV0ZSBsYWJlbCBsYXlvdXQtcmVsYXRlZCBwcm9wZXJ0aWVzXG4gICAgY29tcHV0ZUxheW91dCAodGFyZ2V0LCBmZWF0dXJlLCBkcmF3LCBjb250ZXh0LCB0aWxlKSB7XG4gICAgICAgIGxldCBsYXlvdXQgPSB0YXJnZXQgfHwge307XG4gICAgICAgIGxheW91dC5pZCA9IGZlYXR1cmU7XG4gICAgICAgIGxheW91dC51bml0c19wZXJfcGl4ZWwgPSB0aWxlLnVuaXRzX3Blcl9waXhlbCB8fCAxO1xuXG4gICAgICAgIC8vIGNvbGxpc2lvbiBmbGFnXG4gICAgICAgIGxheW91dC5jb2xsaWRlID0gKGRyYXcuY29sbGlkZSA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlO1xuXG4gICAgICAgIC8vIGxhYmVsIGFuY2hvcnMgKHBvaW50IGxhYmVscyBvbmx5KVxuICAgICAgICAvLyBsYWJlbCBwb3NpdGlvbiB3aWxsIGJlIGFkanVzdGVkIGluIHRoZSBnaXZlbiBkaXJlY3Rpb24sIHJlbGF0aXZlIHRvIGl0cyBvcmlnaW5hbCBwb2ludFxuICAgICAgICAvLyBvbmUgb2Y6IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgdG9wLWxlZnQsIHRvcC1yaWdodCwgYm90dG9tLWxlZnQsIGJvdHRvbS1yaWdodFxuICAgICAgICBsYXlvdXQuYW5jaG9yID0gZHJhdy5hbmNob3I7XG5cbiAgICAgICAgLy8gbGFiZWwgb2Zmc2V0IGFuZCBidWZmZXIgaW4gcGl4ZWwgKGFwcGxpZWQgaW4gc2NyZWVuIHNwYWNlKVxuICAgICAgICBsYXlvdXQub2Zmc2V0ID0gU3R5bGVQYXJzZXIuY2FjaGVQcm9wZXJ0eShkcmF3Lm9mZnNldCwgY29udGV4dCkgfHwgU3R5bGVQYXJzZXIuemVyb1BhaXI7XG4gICAgICAgIGxheW91dC5idWZmZXIgPSBTdHlsZVBhcnNlci5jYWNoZVByb3BlcnR5KGRyYXcuYnVmZmVyLCBjb250ZXh0KSB8fCBTdHlsZVBhcnNlci56ZXJvUGFpcjtcblxuICAgICAgICAvLyBsYWJlbCBwcmlvcml0eSAobG93ZXIgaXMgaGlnaGVyKVxuICAgICAgICBsZXQgcHJpb3JpdHkgPSBkcmF3LnByaW9yaXR5O1xuICAgICAgICBpZiAocHJpb3JpdHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gcHJpb3JpdHkoY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmlvcml0eSA9IC0xID4+PiAwOyAvLyBkZWZhdWx0IHRvIG1heCBwcmlvcml0eSB2YWx1ZSBpZiBub25lIHNldFxuICAgICAgICB9XG4gICAgICAgIGxheW91dC5wcmlvcml0eSA9IHByaW9yaXR5O1xuXG4gICAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgfSxcblxuICAgIC8vIEJ1aWxkcyBvbmUgb3IgbW9yZSBwb2ludCBsYWJlbHMgZm9yIGEgZ2VvbWV0cnlcbiAgICBidWlsZExhYmVsc0Zyb21HZW9tZXRyeSAoc2l6ZSwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGxhYmVscyA9IFtdO1xuXG4gICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSBcIlBvaW50XCIpIHtcbiAgICAgICAgICAgIGxhYmVscy5wdXNoKG5ldyBMYWJlbFBvaW50KGdlb21ldHJ5LmNvb3JkaW5hdGVzLCBzaXplLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJNdWx0aVBvaW50XCIpIHtcbiAgICAgICAgICAgIGxldCBwb2ludHMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKG5ldyBMYWJlbFBvaW50KHBvaW50LCBzaXplLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIFBvaW50IGF0IGVhY2ggbGluZSB2ZXJ0ZXhcbiAgICAgICAgICAgIGxldCBwb2ludHMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxzLnB1c2gobmV3IExhYmVsUG9pbnQocG9pbnRzW2ldLCBzaXplLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJNdWx0aUxpbmVTdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gUG9pbnQgYXQgZWFjaCBsaW5lIHZlcnRleFxuICAgICAgICAgICAgbGV0IGxpbmVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICBmb3IgKGxldCBsbiA9IDA7IGxuIDwgbGluZXMubGVuZ3RoOyBsbisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvaW50cyA9IGxpbmVzW2xuXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbHMucHVzaChuZXcgTGFiZWxQb2ludChwb2ludHNbaV0sIHNpemUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcbiAgICAgICAgICAgIC8vIFBvaW50IGF0IHBvbHlnb24gY2VudHJvaWQgKG9mIG91dGVyIHJpbmcpXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jZW50cm9pZCkge1xuICAgICAgICAgICAgICAgIGxldCBjZW50cm9pZCA9IEdlby5jZW50cm9pZChnZW9tZXRyeS5jb29yZGluYXRlc1swXSk7XG4gICAgICAgICAgICAgICAgbGFiZWxzLnB1c2gobmV3IExhYmVsUG9pbnQoY2VudHJvaWQsIHNpemUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvaW50IGF0IGVhY2ggcG9seWdvbiB2ZXJ0ZXggKGFsbCByaW5ncylcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCByaW5ncyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGxuID0gMDsgbG4gPCByaW5ncy5sZW5ndGg7IGxuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50cyA9IHJpbmdzW2xuXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKG5ldyBMYWJlbFBvaW50KHBvaW50c1tpXSwgc2l6ZSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiTXVsdGlQb2x5Z29uXCIpIHtcbiAgICAgICAgICAgIGxldCBjZW50cm9pZCA9IEdlby5tdWx0aUNlbnRyb2lkKGdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgICAgICAgICAgIGxhYmVscy5wdXNoKG5ldyBMYWJlbFBvaW50KGNlbnRyb2lkLCBzaXplLCBvcHRpb25zKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIFwidGVtcGxhdGVcIiB0aGF0IHNldHMgY29uc3RhbnQgYXR0aWJ1dGVzIGZvciBlYWNoIHZlcnRleCwgd2hpY2ggaXMgdGhlbiBtb2RpZmllZCBwZXIgdmVydGV4IG9yIHBlciBmZWF0dXJlLlxuICAgICAqIEEgcGxhaW4gSlMgYXJyYXkgbWF0Y2hpbmcgdGhlIG9yZGVyIG9mIHRoZSB2ZXJ0ZXggbGF5b3V0LlxuICAgICAqL1xuICAgIG1ha2VWZXJ0ZXhUZW1wbGF0ZShzdHlsZSkge1xuICAgICAgICBsZXQgY29sb3IgPSBzdHlsZS5jb2xvciB8fCBTdHlsZVBhcnNlci5kZWZhdWx0cy5jb2xvcjtcblxuICAgICAgICAvLyBwb3NpdGlvbiAtIHggJiB5IGNvb3JkcyB3aWxsIGJlIGZpbGxlZCBpbiBwZXItdmVydGV4IGJlbG93XG4gICAgICAgIHRoaXMuZmlsbFZlcnRleFRlbXBsYXRlKCdhX3Bvc2l0aW9uJywgMCwgeyBzaXplOiAyIH0pO1xuICAgICAgICB0aGlzLmZpbGxWZXJ0ZXhUZW1wbGF0ZSgnYV9wb3NpdGlvbicsIHN0eWxlLnogfHwgMCwgeyBzaXplOiAxLCBvZmZzZXQ6IDIgfSk7XG4gICAgICAgIC8vIGxheWVyIG9yZGVyIC0gdyBjb29yZCBvZiAncG9zaXRpb24nIGF0dHJpYnV0ZSAoZm9yIHBhY2tpbmcgZWZmaWNpZW5jeSlcbiAgICAgICAgdGhpcy5maWxsVmVydGV4VGVtcGxhdGUoJ2FfcG9zaXRpb24nLCB0aGlzLnNjYWxlT3JkZXIoc3R5bGUub3JkZXIpLCB7IHNpemU6IDEsIG9mZnNldDogMyB9KTtcblxuICAgICAgICAvLyBzY2FsaW5nIHZlY3RvciAtICh4LCB5KSBjb21wb25lbnRzIHBlciBwaXhlbCwgeiA9IGFuZ2xlLCB3ID0gc2NhbGluZyBmYWN0b3JcbiAgICAgICAgdGhpcy5maWxsVmVydGV4VGVtcGxhdGUoJ2Ffc2hhcGUnLCAwLCB7IHNpemU6IDQgfSk7XG5cbiAgICAgICAgLy8gdGV4dHVyZSBjb29yZHNcbiAgICAgICAgdGhpcy5maWxsVmVydGV4VGVtcGxhdGUoJ2FfdGV4Y29vcmQnLCAwLCB7IHNpemU6IDIgfSk7XG5cbiAgICAgICAgLy8gb2Zmc2V0c1xuICAgICAgICB0aGlzLmZpbGxWZXJ0ZXhUZW1wbGF0ZSgnYV9vZmZzZXQnLCAwLCB7IHNpemU6IDIgfSk7XG5cbiAgICAgICAgLy8gY29sb3JcbiAgICAgICAgdGhpcy5maWxsVmVydGV4VGVtcGxhdGUoJ2FfY29sb3InLCBWZWN0b3IubXVsdChjb2xvciwgMjU1KSwgeyBzaXplOiA0IH0pO1xuXG4gICAgICAgIC8vIHNlbGVjdGlvbiBjb2xvclxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZmlsbFZlcnRleFRlbXBsYXRlKCdhX3NlbGVjdGlvbl9jb2xvcicsIFZlY3Rvci5tdWx0KHN0eWxlLnNlbGVjdGlvbl9jb2xvciwgMjU1KSwgeyBzaXplOiA0IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGV4X3RlbXBsYXRlO1xuICAgIH0sXG5cbiAgICBidWlsZFF1YWQgKHBvaW50cywgc2l6ZSwgYW5nbGUsIG9mZnNldCwgdGV4Y29vcmRfc2NhbGUsIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUpIHtcbiAgICAgICAgQnVpbGRlcnMuYnVpbGRRdWFkc0ZvclBvaW50cyhcbiAgICAgICAgICAgIHBvaW50cyxcbiAgICAgICAgICAgIHZlcnRleF9kYXRhLFxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleGNvb3JkX2luZGV4OiB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV90ZXhjb29yZCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbl9pbmRleDogdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgc2hhcGVfaW5kZXg6IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX3NoYXBlLFxuICAgICAgICAgICAgICAgIG9mZnNldF9pbmRleDogdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfb2Zmc2V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHF1YWQ6IFsgVXRpbHMuc2NhbGVJbnQxNihzaXplWzBdLCAyNTYpLCBVdGlscy5zY2FsZUludDE2KHNpemVbMV0sIDI1NikgXSxcbiAgICAgICAgICAgICAgICBxdWFkX3NjYWxlOiBVdGlscy5zY2FsZUludDE2KDEsIDI1NiksXG4gICAgICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBVdGlscy5zY2FsZUludDE2KGFuZ2xlLCAzNjApLFxuICAgICAgICAgICAgICAgIHRleGNvb3JkX3NjYWxlOiB0ZXhjb29yZF9zY2FsZSxcbiAgICAgICAgICAgICAgICB0ZXhjb29yZF9ub3JtYWxpemU6IDY1NTM1XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8vIEJ1aWxkIHF1YWQgZm9yIHBvaW50IHNwcml0ZVxuICAgIGJ1aWxkIChzdHlsZSwgdmVydGV4X2RhdGEpIHtcbiAgICAgICAgbGV0IHZlcnRleF90ZW1wbGF0ZSA9IHRoaXMubWFrZVZlcnRleFRlbXBsYXRlKHN0eWxlKTtcbiAgICAgICAgbGV0IGxhYmVsID0gc3R5bGUubGFiZWw7XG5cbiAgICAgICAgdGhpcy5idWlsZFF1YWQoXG4gICAgICAgICAgICBbbGFiZWwucG9zaXRpb25dLCAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uXG4gICAgICAgICAgICBzdHlsZS5zaXplLCAgICAgICAgICAgICAgICAgICAgIC8vIHNpemUgaW4gcGl4ZWxzXG4gICAgICAgICAgICBzdHlsZS5hbmdsZSwgICAgICAgICAgICAgICAgICAgIC8vIGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgICAgICAgIGxhYmVsLm9wdGlvbnMub2Zmc2V0LCAgICAgICAgICAgLy8gb2Zmc2V0IGZyb20gY2VudGVyIGluIHBpeGVsc1xuICAgICAgICAgICAgc3R5bGUudGV4Y29vcmRzLCAgICAgICAgICAgICAgICAvLyB0ZXh0dXJlIFVWc1xuICAgICAgICAgICAgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSAgICAvLyBWQk8gYW5kIGRhdGEgZm9yIGN1cnJlbnQgdmVydGV4XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8vIE92ZXJyaWRlIHRvIHBhc3MtdGhyb3VnaCB0byBnZW5lcmljIHBvaW50IGJ1aWxkZXJcbiAgICBidWlsZExpbmVzIChsaW5lcywgc3R5bGUsIHZlcnRleF9kYXRhKSB7XG4gICAgICAgIHRoaXMuYnVpbGQoc3R5bGUsIHZlcnRleF9kYXRhKTtcbiAgICB9LFxuXG4gICAgYnVpbGRQb2ludHMgKHBvaW50cywgc3R5bGUsIHZlcnRleF9kYXRhKSB7XG4gICAgICAgIHRoaXMuYnVpbGQoc3R5bGUsIHZlcnRleF9kYXRhKTtcbiAgICB9LFxuXG4gICAgYnVpbGRQb2x5Z29ucyAocG9pbnRzLCBzdHlsZSwgdmVydGV4X2RhdGEpIHtcbiAgICAgICAgdGhpcy5idWlsZChzdHlsZSwgdmVydGV4X2RhdGEpO1xuICAgIH1cblxufSk7XG4iLCIvLyBQb2x5Z29uIHJlbmRlcmluZyBzdHlsZVxuXG5pbXBvcnQge1N0eWxlfSBmcm9tICcuLi9zdHlsZSc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuLi9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IGdsIGZyb20gJy4uLy4uL2dsL2NvbnN0YW50cyc7IC8vIHdlYiB3b3JrZXJzIGRvbid0IGhhdmUgYWNjZXNzIHRvIEdMIGNvbnRleHQsIHNvIGltcG9ydCBhbGwgR0wgY29uc3RhbnRzXG5pbXBvcnQgVmVydGV4TGF5b3V0IGZyb20gJy4uLy4uL2dsL3ZlcnRleF9sYXlvdXQnO1xuaW1wb3J0IEJ1aWxkZXJzIGZyb20gJy4uL2J1aWxkZXJzJztcbmltcG9ydCBHZW8gZnJvbSAnLi4vLi4vZ2VvJztcblxuZXhwb3J0IHZhciBQb2x5Z29ucyA9IE9iamVjdC5jcmVhdGUoU3R5bGUpO1xuXG5PYmplY3QuYXNzaWduKFBvbHlnb25zLCB7XG4gICAgbmFtZTogJ3BvbHlnb25zJyxcbiAgICBidWlsdF9pbjogdHJ1ZSxcbiAgICB2ZXJ0ZXhfc2hhZGVyX2tleTogJ3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29uc192ZXJ0ZXgnLFxuICAgIGZyYWdtZW50X3NoYWRlcl9rZXk6ICdzdHlsZXMvcG9seWdvbnMvcG9seWdvbnNfZnJhZ21lbnQnLFxuICAgIHNlbGVjdGlvbjogdHJ1ZSwgLy8gdHVybiBmZWF0dXJlIHNlbGVjdGlvbiBvblxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgU3R5bGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIEJhc2ljIGF0dHJpYnV0ZXMsIG90aGVycyBjYW4gYmUgYWRkZWQgKHNlZSB0ZXh0dXJlIFVWcyBiZWxvdylcbiAgICAgICAgdmFyIGF0dHJpYnMgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3Bvc2l0aW9uJywgc2l6ZTogNCwgdHlwZTogZ2wuU0hPUlQsIG5vcm1hbGl6ZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2Ffbm9ybWFsJywgc2l6ZTogMywgdHlwZTogZ2wuQllURSwgbm9ybWFsaXplZDogdHJ1ZSB9LCAvLyBnZXRzIHBhZGRlZCB0byA0LWJ5dGVzXG4gICAgICAgICAgICB7IG5hbWU6ICdhX2NvbG9yJywgc2l6ZTogNCwgdHlwZTogZ2wuVU5TSUdORURfQllURSwgbm9ybWFsaXplZDogdHJ1ZSB9XG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gVGVsbCB0aGUgc2hhZGVyIHdlIGhhdmUgYSBub3JtYWwgYW5kIG9yZGVyIGF0dHJpYnV0ZXNcbiAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fTk9STUFMX0FUVFJJQlVURSA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5UQU5HUkFNX0xBWUVSX09SREVSID0gdHJ1ZTtcblxuICAgICAgICAvLyBPcHRpb25hbCBmZWF0dXJlIHNlbGVjdGlvblxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGF0dHJpYnMucHVzaCh7IG5hbWU6ICdhX3NlbGVjdGlvbl9jb2xvcicsIHNpemU6IDQsIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEUsIG5vcm1hbGl6ZWQ6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcHRpb25hbCB0ZXh0dXJlIFVWc1xuICAgICAgICBpZiAodGhpcy50ZXhjb29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lcy5UQU5HUkFNX1RFWFRVUkVfQ09PUkRTID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQWRkIHZlcnRleCBhdHRyaWJ1dGUgZm9yIFVWcyBvbmx5IHdoZW4gbmVlZGVkXG4gICAgICAgICAgICBhdHRyaWJzLnB1c2goeyBuYW1lOiAnYV90ZXhjb29yZCcsIHNpemU6IDIsIHR5cGU6IGdsLlVOU0lHTkVEX1NIT1JULCBub3JtYWxpemVkOiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0ID0gbmV3IFZlcnRleExheW91dChhdHRyaWJzKTtcbiAgICB9LFxuXG4gICAgX3BhcnNlRmVhdHVyZSAoZmVhdHVyZSwgcnVsZV9zdHlsZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmZlYXR1cmVfc3R5bGU7XG5cbiAgICAgICAgc3R5bGUuY29sb3IgPSB0aGlzLnBhcnNlQ29sb3IocnVsZV9zdHlsZS5jb2xvciwgY29udGV4dCk7XG4gICAgICAgIGlmICghc3R5bGUuY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGVpZ2h0IGRlZmF1bHRzIHRvIGZlYXR1cmUgaGVpZ2h0LCBidXQgZXh0cnVkZSBzdHlsZSBjYW4gZHluYW1pY2FsbHkgYWRqdXN0IGhlaWdodCBieSByZXR1cm5pbmcgYSBudW1iZXIgb3IgYXJyYXkgKGluc3RlYWQgb2YgYSBib29sZWFuKVxuICAgICAgICBzdHlsZS56ID0gKHJ1bGVfc3R5bGUueiAmJiBTdHlsZVBhcnNlci5jYWNoZURpc3RhbmNlKHJ1bGVfc3R5bGUueiwgY29udGV4dCkpIHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLno7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9IGZlYXR1cmUucHJvcGVydGllcy5oZWlnaHQgfHwgU3R5bGVQYXJzZXIuZGVmYXVsdHMuaGVpZ2h0O1xuICAgICAgICBzdHlsZS5taW5faGVpZ2h0ID0gZmVhdHVyZS5wcm9wZXJ0aWVzLm1pbl9oZWlnaHQgfHwgU3R5bGVQYXJzZXIuZGVmYXVsdHMubWluX2hlaWdodDtcbiAgICAgICAgc3R5bGUuZXh0cnVkZSA9IFN0eWxlUGFyc2VyLmV2YWxQcm9wKHJ1bGVfc3R5bGUuZXh0cnVkZSwgY29udGV4dCk7XG4gICAgICAgIGlmIChzdHlsZS5leHRydWRlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlLmV4dHJ1ZGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gc3R5bGUuZXh0cnVkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUuZXh0cnVkZSkpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5taW5faGVpZ2h0ID0gc3R5bGUuZXh0cnVkZVswXTtcbiAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBzdHlsZS5leHRydWRlWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGUudGlsZV9lZGdlcyA9IHJ1bGVfc3R5bGUudGlsZV9lZGdlczsgLy8gdXN1YWxseSBhY3RpdmF0ZWQgZm9yIGRlYnVnZ2luZywgb3IgcmFyZSB2aXN1YWxpemF0aW9uIG5lZWRzXG5cbiAgICAgICAgLy8gc3R5bGUub3V0bGluZSA9IHN0eWxlLm91dGxpbmUgfHwge307XG4gICAgICAgIC8vIGlmIChydWxlX3N0eWxlLm91dGxpbmUpIHtcbiAgICAgICAgLy8gICAgIHN0eWxlLm91dGxpbmUuY29sb3IgPSBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKHJ1bGVfc3R5bGUub3V0bGluZS5jb2xvciwgY29udGV4dCk7XG4gICAgICAgIC8vICAgICBzdHlsZS5vdXRsaW5lLndpZHRoID0gU3R5bGVQYXJzZXIucGFyc2VEaXN0YW5jZShydWxlX3N0eWxlLm91dGxpbmUud2lkdGgsIGNvbnRleHQpO1xuICAgICAgICAvLyAgICAgc3R5bGUub3V0bGluZS50aWxlX2VkZ2VzID0gcnVsZV9zdHlsZS5vdXRsaW5lLnRpbGVfZWRnZXM7XG4gICAgICAgIC8vICAgICBzdHlsZS5vdXRsaW5lLmNhcCA9IHJ1bGVfc3R5bGUub3V0bGluZS5jYXAgfHwgcnVsZV9zdHlsZS5jYXA7XG4gICAgICAgIC8vICAgICBzdHlsZS5vdXRsaW5lLmpvaW4gPSBydWxlX3N0eWxlLm91dGxpbmUuam9pbiB8fCBydWxlX3N0eWxlLmpvaW47XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gZWxzZSB7XG4gICAgICAgIC8vICAgICBzdHlsZS5vdXRsaW5lLmNvbG9yID0gbnVsbDtcbiAgICAgICAgLy8gICAgIHN0eWxlLm91dGxpbmUud2lkdGggPSBudWxsO1xuICAgICAgICAvLyAgICAgc3R5bGUub3V0bGluZS50aWxlX2VkZ2VzID0gZmFsc2U7XG4gICAgICAgIC8vIH1cblxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcblxuICAgIF9wcmVwcm9jZXNzIChkcmF3KSB7XG4gICAgICAgIGRyYXcuY29sb3IgPSBTdHlsZVBhcnNlci5jb2xvckNhY2hlT2JqZWN0KGRyYXcuY29sb3IpO1xuICAgICAgICBkcmF3LnogPSBTdHlsZVBhcnNlci5jYWNoZU9iamVjdChkcmF3LnosIFN0eWxlUGFyc2VyLmNhY2hlVW5pdHMpO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSBcInRlbXBsYXRlXCIgdGhhdCBzZXRzIGNvbnN0YW50IGF0dGlidXRlcyBmb3IgZWFjaCB2ZXJ0ZXgsIHdoaWNoIGlzIHRoZW4gbW9kaWZpZWQgcGVyIHZlcnRleCBvciBwZXIgZmVhdHVyZS5cbiAgICAgKiBBIHBsYWluIEpTIGFycmF5IG1hdGNoaW5nIHRoZSBvcmRlciBvZiB0aGUgdmVydGV4IGxheW91dC5cbiAgICAgKi9cbiAgICBtYWtlVmVydGV4VGVtcGxhdGUoc3R5bGUpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuXG4gICAgICAgIC8vIHBvc2l0aW9uIC0geCAmIHkgY29vcmRzIHdpbGwgYmUgZmlsbGVkIGluIHBlci12ZXJ0ZXggYmVsb3dcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IDA7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUueiB8fCAwO1xuXG4gICAgICAgIC8vIGxheWVyIG9yZGVyIC0gdyBjb29yZCBvZiAncG9zaXRpb24nIGF0dHJpYnV0ZSAoZm9yIHBhY2tpbmcgZWZmaWNpZW5jeSlcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHRoaXMuc2NhbGVPcmRlcihzdHlsZS5vcmRlcik7XG5cbiAgICAgICAgLy8gbm9ybWFsXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gMDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IDEgKiAxMjc7XG5cbiAgICAgICAgLy8gY29sb3JcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLmNvbG9yWzBdICogMjU1O1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUuY29sb3JbMV0gKiAyNTU7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5jb2xvclsyXSAqIDI1NTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLmNvbG9yWzNdICogMjU1O1xuXG4gICAgICAgIC8vIHNlbGVjdGlvbiBjb2xvclxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5zZWxlY3Rpb25fY29sb3JbMF0gKiAyNTU7XG4gICAgICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzFdICogMjU1O1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLnNlbGVjdGlvbl9jb2xvclsyXSAqIDI1NTtcbiAgICAgICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5zZWxlY3Rpb25fY29sb3JbM10gKiAyNTU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGV4dHVyZSBVVnMgdG8gdGVtcGxhdGUgb25seSBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHRoaXMudGV4Y29vcmRzKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gMDtcbiAgICAgICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGV4X3RlbXBsYXRlO1xuICAgIH0sXG5cbiAgICBidWlsZFBvbHlnb25zKHBvbHlnb25zLCBzdHlsZSwgdmVydGV4X2RhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHZlcnRleF90ZW1wbGF0ZSA9IHRoaXMubWFrZVZlcnRleFRlbXBsYXRlKHN0eWxlKTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0ZXhjb29yZF9pbmRleDogdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfdGV4Y29vcmQsXG4gICAgICAgICAgICB0ZXhjb29yZF9zY2FsZTogdGhpcy50ZXhjb29yZF9zY2FsZSxcbiAgICAgICAgICAgIHRleGNvb3JkX25vcm1hbGl6ZTogNjU1MzUsIC8vIHNjYWxlIFVWcyB0byB1bnNpZ25lZCBzaG9ydHNcbiAgICAgICAgICAgIHJlbW92ZV90aWxlX2VkZ2VzOiAhc3R5bGUudGlsZV9lZGdlcyxcbiAgICAgICAgICAgIHRpbGVfZWRnZV90b2xlcmFuY2U6IEdlby50aWxlX3NjYWxlICogY29udGV4dC50aWxlLnBhZF9zY2FsZSAqIDQsXG4gICAgICAgICAgICB3aW5kaW5nOiBjb250ZXh0LndpbmRpbmdcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBFeHRydWRlZCBwb2x5Z29ucyAoZS5nLiAzRCBidWlsZGluZ3MpXG4gICAgICAgIGlmIChzdHlsZS5leHRydWRlICYmIHN0eWxlLmhlaWdodCkge1xuICAgICAgICAgICAgQnVpbGRlcnMuYnVpbGRFeHRydWRlZFBvbHlnb25zKFxuICAgICAgICAgICAgICAgIHBvbHlnb25zLFxuICAgICAgICAgICAgICAgIHN0eWxlLnosIHN0eWxlLmhlaWdodCwgc3R5bGUubWluX2hlaWdodCxcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLFxuICAgICAgICAgICAgICAgIHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX25vcm1hbCxcbiAgICAgICAgICAgICAgICAxMjcsIC8vIHNjYWxlIG5vcm1hbHMgdG8gc2lnbmVkIGJ5dGVzXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWd1bGFyIHBvbHlnb25zXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgQnVpbGRlcnMuYnVpbGRQb2x5Z29ucyhcbiAgICAgICAgICAgICAgICBwb2x5Z29ucyxcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuIiwiaW1wb3J0IHtTdHlsZXN9IGZyb20gJy4vc3R5bGVfbWFuYWdlcic7XG5pbXBvcnQgbWVyZ2VPYmplY3RzIGZyb20gJy4uL3V0aWxzL21lcmdlJztcbmltcG9ydCB7bWF0Y2h9IGZyb20gJ21hdGNoLWZlYXR1cmUnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCBjb25zdCB3aGl0ZUxpc3QgPSBbJ2ZpbHRlcicsICdkcmF3JywgJ3Zpc2libGUnLCAnZGF0YScsICdwcm9wZXJ0aWVzJ107XG5cbmV4cG9ydCBsZXQgcnVsZUNhY2hlID0ge307XG5cbmZ1bmN0aW9uIGNhY2hlS2V5IChydWxlcykge1xuICAgIGlmIChydWxlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBrID0gcnVsZXNbMF07XG4gICAgICAgIGZvciAodmFyIGk9MTsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBrICs9ICcvJyArIHJ1bGVzW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGs7XG4gICAgfVxuICAgIHJldHVybiBydWxlc1swXTtcbn1cblxuLy8gTWVyZ2UgbWF0Y2hpbmcgbGF5ZXIgcnVsZSB0cmVlcyBpbnRvIGEgZmluYWwgZHJhdyBncm91cFxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlVHJlZXMobWF0Y2hpbmdUcmVlcywgZ3JvdXApIHtcbiAgICBsZXQgZHJhd3MsIHRyZWVEZXB0aCA9IDA7XG5cbiAgICBsZXQgZHJhdyA9IHtcbiAgICAgICAgdmlzaWJsZTogdHJ1ZSAvLyB2aXNpYmxlIGJ5IGRlZmF1bHRcbiAgICB9O1xuXG4gICAgLy8gRmluZCBkZWVwZXN0IHRyZWVcbiAgICBmb3IgKGxldCB0PTA7IHQgPCBtYXRjaGluZ1RyZWVzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIGlmIChtYXRjaGluZ1RyZWVzW3RdLmxlbmd0aCA+IHRyZWVEZXB0aCkge1xuICAgICAgICAgICAgdHJlZURlcHRoID0gbWF0Y2hpbmdUcmVlc1t0XS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyBydWxlcyB0byBwYXJzZVxuICAgIGlmICh0cmVlRGVwdGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gSXRlcmF0ZSB0cmVlcyBpbiBwYXJhbGxlbFxuICAgIGZvciAobGV0IHg9MDsgeCA8IHRyZWVEZXB0aDsgeCsrKSB7XG4gICAgICAgIC8vIFB1bGwgb3V0IHRoZSByZXF1ZXN0ZWQgZHJhdyBncm91cCwgZm9yIGVhY2ggdHJlZSwgYXQgdGhpcyBkZXB0aFxuICAgICAgICBkcmF3cyA9IG1hdGNoaW5nVHJlZXMubWFwKHRyZWUgPT4gdHJlZVt4XSAmJiB0cmVlW3hdW2dyb3VwXSk7XG4gICAgICAgIGlmIChkcmF3cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29ydCBieSBsYXllciBuYW1lIGJlZm9yZSBtZXJnaW5nLCBzbyBydWxlcyBhcmUgYXBwbGllZCBkZXRlcm1pbmlzdGljYWxseVxuICAgICAgICAvLyB3aGVuIG11bHRpcGxlIHJ1bGVzIG1vZGlmeSB0aGUgc2FtZSBwcm9wZXJ0aWVzXG4gICAgICAgIGRyYXdzLnNvcnQoKGEsIGIpID0+IChhICYmIGEubGF5ZXJfbmFtZSkgPiAoYiAmJiBiLmxheWVyX25hbWUpID8gMSA6IC0xKTtcblxuICAgICAgICAvLyBNZXJnZSBkcmF3IG9iamVjdHNcbiAgICAgICAgbWVyZ2VPYmplY3RzKGRyYXcsIC4uLmRyYXdzKTtcblxuICAgICAgICAvLyBSZW1vdmUgbGF5ZXIgbmFtZXMsIHRoZXkgd2VyZSBvbmx5IHVzZWQgdHJhbnNpZW50bHkgdG8gc29ydCBhbmQgY2FsY3VsYXRlIGZpbmFsIGxheWVyXG4gICAgICAgIC8vIChmaW5hbCBtZXJnZWQgbmFtZXMgd2lsbCBub3QgYmUgYWNjdXJhdGUgc2luY2Ugb25seSBvbmUgdHJlZSBjYW4gd2luKVxuICAgICAgICBkZWxldGUgZHJhdy5sYXllcl9uYW1lO1xuICAgIH1cblxuICAgIC8vIFNob3J0LWNpcmN1aXQgaWYgbm90IHZpc2libGVcbiAgICBpZiAoZHJhdy52aXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZHJhdztcbn1cblxuXG5jbGFzcyBSdWxlIHtcblxuICAgIGNvbnN0cnVjdG9yKHtuYW1lLCBwYXJlbnQsIGRyYXcsIHZpc2libGUsIGZpbHRlciwgcHJvcGVydGllc30pIHtcbiAgICAgICAgdGhpcy5pZCA9IFJ1bGUuaWQrKztcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZnVsbF9uYW1lID0gdGhpcy5wYXJlbnQgPyAodGhpcy5wYXJlbnQuZnVsbF9uYW1lICsgJzonICsgdGhpcy5uYW1lKSA6IHRoaXMubmFtZTtcbiAgICAgICAgdGhpcy5kcmF3ID0gZHJhdztcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHZpc2libGUgIT09IHVuZGVmaW5lZCA/IHZpc2libGUgOiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQudmlzaWJsZSk7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCA/IHByb3BlcnRpZXMgOiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucHJvcGVydGllcyk7XG5cbiAgICAgICAgLy8gRGVub3JtYWxpemUgbGF5ZXIgbmFtZSAmIHByb3BlcnRpZXMgdG8gZHJhdyBncm91cHNcbiAgICAgICAgaWYgKHRoaXMuZHJhdykge1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXAgaW4gdGhpcy5kcmF3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3W2dyb3VwXSA9IHRoaXMuZHJhd1tncm91cF0gfHwge307XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3W2dyb3VwXS5sYXllcl9uYW1lID0gdGhpcy5mdWxsX25hbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3W2dyb3VwXS5wcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYnVpbGRGaWx0ZXIoKTtcbiAgICAgICAgdGhpcy5idWlsZERyYXcoKTtcbiAgICB9XG5cbiAgICBidWlsZERyYXcoKSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlZERyYXcgPSBjYWxjdWxhdGVEcmF3KHRoaXMpO1xuICAgIH1cblxuICAgIGJ1aWxkRmlsdGVyKCkge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVvZiB0aGlzLmZpbHRlcjtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyICE9IG51bGwgJiYgdHlwZSAhPT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gSW52YWxpZCBmaWx0ZXJcbiAgICAgICAgICAgIGxldCBtc2cgPSBgRmlsdGVyIGZvciBsYXllciAke3RoaXMuZnVsbF9uYW1lfSBpcyBpbnZhbGlkLCBmaWx0ZXIgdmFsdWUgbXVzdCBiZSBhbiBvYmplY3Qgb3IgZnVuY3Rpb24sIGA7XG4gICAgICAgICAgICBtc2cgKz0gYGJ1dCB3YXMgc2V0IHRvIFxcYGZpbHRlcjogJHt0aGlzLmZpbHRlcn1cXGAgaW5zdGVhZGA7XG4gICAgICAgICAgICBsb2cud2Fybihtc2cpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRab29tcygpO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXIgPSB0aGlzLmZpbHRlciAmJiBtYXRjaCh0aGlzLmZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gSW52YWxpZCBmaWx0ZXJcbiAgICAgICAgICAgIGxldCBtc2cgPSBgRmlsdGVyIGZvciBsYXllciAke3RoaXMuZnVsbF9uYW1lfSBpcyBpbnZhbGlkLCBcXGBmaWx0ZXI6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5maWx0ZXIpfVxcYCBgO1xuICAgICAgICAgICAgbXNnICs9IGBmYWlsZWQgd2l0aCBlcnJvciAke2UubWVzc2FnZX0sICR7ZS5zdGFja31gO1xuICAgICAgICAgICAgbG9nLndhcm4obXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFpvb21zIG9mdGVuIGN1bGwgbGFyZ2Ugc3dhdGhzIG9mIHRoZSBsYXllciBydWxlIHRyZWUsIHNvIHRoZXkgZ2V0IHNwZWNpYWwgdHJlYXRtZW50IGFuZCBhcmUgY2hlY2tlZCBmaXJzdFxuICAgIGJ1aWxkWm9vbXMoKSB7XG4gICAgICAgIGxldCB6b29tID0gdGhpcy5maWx0ZXIgJiYgdGhpcy5maWx0ZXIuJHpvb207XG4gICAgICAgIGxldCB6dHlwZSA9IHR5cGVvZiB6b29tO1xuICAgICAgICBpZiAoem9vbSAhPSBudWxsICYmIHp0eXBlICE9PSAnZnVuY3Rpb24nKSB7IC8vIGRvbid0IGFjY2VsZXJhdGUgZnVuY3Rpb24tYmFzZWQgZmlsdGVyc1xuICAgICAgICAgICAgdGhpcy56b29tcyA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoenR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b29tc1t6b29tXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHpvb20pKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgej0wOyB6IDwgem9vbS5sZW5ndGg7IHorKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnpvb21zW3pvb21bel1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh6dHlwZSA9PT0gJ29iamVjdCcgJiYgKHpvb20ubWluICE9IG51bGwgfHwgem9vbS5tYXggIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgem1pbiA9IHpvb20ubWluIHx8IDA7XG4gICAgICAgICAgICAgICAgbGV0IHptYXggPSB6b29tLm1heCB8fCAyNTsgLy8gVE9ETzogcmVwbGFjZSBjb25zdGFudCBmb3IgbWF4IHBvc3NpYmxlIHpvb21cbiAgICAgICAgICAgICAgICBmb3IgKGxldCB6PXptaW47IHogPCB6bWF4OyB6KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy56b29tc1t6XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5maWx0ZXIuJHpvb207IC8vIGRvbid0IHByb2Nlc3Mgem9vbSB0aHJvdWdoIHVzdWFsIGdlbmVyaWMgZmlsdGVyIGxvZ2ljXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBkcmF3OiB0aGlzLmRyYXdcbiAgICAgICAgfTtcbiAgICB9XG5cbn1cblxuUnVsZS5pZCA9IDA7XG5cblxuZXhwb3J0IGNsYXNzIFJ1bGVMZWFmIGV4dGVuZHMgUnVsZSB7XG4gICAgY29uc3RydWN0b3Ioe25hbWUsIHBhcmVudCwgZHJhdywgdmlzaWJsZSwgZmlsdGVyLCBwcm9wZXJ0aWVzfSkge1xuICAgICAgICBzdXBlcih7bmFtZSwgcGFyZW50LCBkcmF3LCB2aXNpYmxlLCBmaWx0ZXIsIHByb3BlcnRpZXN9KTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGNsYXNzIFJ1bGVUcmVlIGV4dGVuZHMgUnVsZSB7XG4gICAgY29uc3RydWN0b3Ioe25hbWUsIHBhcmVudCwgZHJhdywgdmlzaWJsZSwgcnVsZXMsIGZpbHRlciwgcHJvcGVydGllc30pIHtcbiAgICAgICAgc3VwZXIoe25hbWUsIHBhcmVudCwgZHJhdywgdmlzaWJsZSwgZmlsdGVyLCBwcm9wZXJ0aWVzfSk7XG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlcyB8fCBbXTtcbiAgICB9XG5cbiAgICBhZGRSdWxlKHJ1bGUpIHtcbiAgICAgICAgdGhpcy5ydWxlcy5wdXNoKHJ1bGUpO1xuICAgIH1cblxuICAgIGJ1aWxkRHJhd0dyb3Vwcyhjb250ZXh0KSB7XG4gICAgICAgIGxldCBydWxlcyA9IFtdLCBydWxlX2lkcyA9IFtdO1xuICAgICAgICAvL1RPRE8sIHNob3VsZCB0aGlzIGZ1bmN0aW9uIHRha2UgYSBSdWxlVHJlZVxuICAgICAgICBtYXRjaEZlYXR1cmUoY29udGV4dCwgW3RoaXNdLCBydWxlcywgcnVsZV9pZHMpO1xuXG4gICAgICAgIGlmIChydWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgY2FjaGVfa2V5ID0gY2FjaGVLZXkocnVsZV9pZHMpO1xuXG4gICAgICAgICAgICAvLyBPbmx5IGV2YWx1YXRlIGVhY2ggcnVsZSBjb21iaW5hdGlvbiBvbmNlICh1bmRlZmluZWQgbWVhbnMgbm90IHlldCBldmFsdWF0ZWQsXG4gICAgICAgICAgICAvLyBudWxsIG1lYW5zIGV2YWx1YXRlZCB3aXRoIG5vIGRyYXcgb2JqZWN0KVxuICAgICAgICAgICAgaWYgKHJ1bGVDYWNoZVtjYWNoZV9rZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIGFsbCB0aGUgdW5pcXVlIHZpc2libGUgZHJhdyBibG9ja3MgZm9yIHRoaXMgcnVsZSB0cmVlXG4gICAgICAgICAgICAgICAgbGV0IGRyYXdfcnVsZXMgPSBydWxlcy5tYXAoeCA9PiB4ICYmIHgudmlzaWJsZSAhPT0gZmFsc2UgJiYgeC5jYWxjdWxhdGVkRHJhdyk7XG4gICAgICAgICAgICAgICAgbGV0IGRyYXdfa2V5cyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcj0wOyByIDwgZHJhd19ydWxlcy5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IGRyYXdfcnVsZXNbcl07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcnVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZz0wOyBnIDwgcnVsZS5sZW5ndGg7IGcrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gcnVsZVtnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdfa2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBlYWNoIGRyYXcgZ3JvdXBcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkcmF3X2tleSBpbiBkcmF3X2tleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUNhY2hlW2NhY2hlX2tleV0gPSBydWxlQ2FjaGVbY2FjaGVfa2V5XSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUNhY2hlW2NhY2hlX2tleV1bZHJhd19rZXldID0gbWVyZ2VUcmVlcyhkcmF3X3J1bGVzLCBkcmF3X2tleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzYXZlIHRoZSBvbmVzIHRoYXQgd2VyZW4ndCBudWxsXG4gICAgICAgICAgICAgICAgICAgIGlmICghcnVsZUNhY2hlW2NhY2hlX2tleV1bZHJhd19rZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcnVsZUNhY2hlW2NhY2hlX2tleV1bZHJhd19rZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUNhY2hlW2NhY2hlX2tleV1bZHJhd19rZXldLmtleSA9IGNhY2hlX2tleSArICcvJyArIGRyYXdfa2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUNhY2hlW2NhY2hlX2tleV1bZHJhd19rZXldLmxheWVycyA9IHJ1bGVzLm1hcCh4ID0+IHggJiYgeC5mdWxsX25hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTm8gcnVsZXMgZXZhbHVhdGVkXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGVDYWNoZVtjYWNoZV9rZXldICYmIE9iamVjdC5rZXlzKHJ1bGVDYWNoZVtjYWNoZV9rZXldKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUNhY2hlW2NhY2hlX2tleV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydWxlQ2FjaGVbY2FjaGVfa2V5XTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5mdW5jdGlvbiBpc1doaXRlTGlzdGVkKGtleSkge1xuICAgIHJldHVybiB3aGl0ZUxpc3QuaW5kZXhPZihrZXkpID4gLTE7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Fsa1VwKHJ1bGUsIGNiKSB7XG5cbiAgICBpZiAocnVsZS5wYXJlbnQpIHtcbiAgICAgICAgd2Fsa1VwKHJ1bGUucGFyZW50LCBjYik7XG4gICAgfVxuXG4gICAgY2IocnVsZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YWxrRG93bihydWxlLCBjYikge1xuXG4gICAgaWYgKHJ1bGUucnVsZXMpIHtcbiAgICAgICAgcnVsZS5ydWxlcy5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgICAgICB3YWxrRG93bihyLCBjYik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNiKHJ1bGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBQcm9wcyhvYmopIHtcbiAgICBsZXQgd2hpdGVMaXN0ZWQgPSB7fSwgbm9uV2hpdGVMaXN0ZWQgPSB7fTtcblxuICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGlzV2hpdGVMaXN0ZWQoa2V5KSkge1xuICAgICAgICAgICAgd2hpdGVMaXN0ZWRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9uV2hpdGVMaXN0ZWRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbd2hpdGVMaXN0ZWQsIG5vbldoaXRlTGlzdGVkXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZURyYXcocnVsZSkge1xuXG4gICAgbGV0IGRyYXcgID0gW107XG5cbiAgICBpZiAocnVsZS5wYXJlbnQpIHtcbiAgICAgICAgbGV0IGNzID0gcnVsZS5wYXJlbnQuY2FsY3VsYXRlZERyYXcgfHwgW107XG4gICAgICAgIGRyYXcucHVzaCguLi5jcyk7XG4gICAgfVxuXG4gICAgZHJhdy5wdXNoKHJ1bGUuZHJhdyk7XG4gICAgcmV0dXJuIGRyYXc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJ1bGVUcmVlKG5hbWUsIHJ1bGUsIHBhcmVudCkge1xuXG4gICAgbGV0IHByb3BlcnRpZXMgPSB7bmFtZSwgcGFyZW50fTtcbiAgICBsZXQgW3doaXRlTGlzdGVkLCBub25XaGl0ZUxpc3RlZF0gPSBncm91cFByb3BzKHJ1bGUpO1xuICAgIGxldCBlbXB0eSA9IGlzRW1wdHkobm9uV2hpdGVMaXN0ZWQpO1xuICAgIGxldCBDcmVhdGU7XG5cbiAgICBpZiAoZW1wdHkgJiYgcGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgQ3JlYXRlID0gUnVsZUxlYWY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgQ3JlYXRlID0gUnVsZVRyZWU7XG4gICAgfVxuXG4gICAgbGV0IHIgPSBuZXcgQ3JlYXRlKE9iamVjdC5hc3NpZ24ocHJvcGVydGllcywgd2hpdGVMaXN0ZWQpKTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmFkZFJ1bGUocik7XG4gICAgfVxuXG4gICAgaWYgKCFlbXB0eSkge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gbm9uV2hpdGVMaXN0ZWQpIHtcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IG5vbldoaXRlTGlzdGVkW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBwYXJzZVJ1bGVUcmVlKGtleSwgcHJvcGVydHksIHIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGxheWVyXG4gICAgICAgICAgICAgICAgbGV0IG1zZyA9IGBMYXllciB2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdDogY2FuJ3QgY3JlYXRlIGxheWVyICcke2tleX06ICR7SlNPTi5zdHJpbmdpZnkocHJvcGVydHkpfSdgO1xuICAgICAgICAgICAgICAgIG1zZyArPSBgLCB1bmRlciBwYXJlbnQgbGF5ZXIgJyR7ci5mdWxsX25hbWV9Jy5gO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHBhcmVudCBpcyBhIHN0eWxlIG5hbWUsIHRoaXMgbWF5IGJlIGFuIGluY29ycmVjdGx5IG5lc3RlZCBsYXllclxuICAgICAgICAgICAgICAgIGlmIChTdHlsZXNbci5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBtc2cgKz0gYCBUaGUgcGFyZW50ICcke3IubmFtZX0nIGlzIGFsc28gdGhlIG5hbWUgb2YgYSBzdHlsZSwgZGlkIHlvdSBtZWFuIHRvIGNyZWF0ZSBhICdkcmF3JyBncm91cGA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyArPSBgIHVuZGVyICcke3BhcmVudC5uYW1lfSdgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSBgIGluc3RlYWQ/YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nLndhcm4obXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUnVsZXMocnVsZXMpIHtcbiAgICBsZXQgcnVsZVRyZWVzID0ge307XG5cbiAgICBmb3IgKGxldCBrZXkgaW4gcnVsZXMpIHtcbiAgICAgICAgbGV0IHJ1bGUgPSBydWxlc1trZXldO1xuICAgICAgICBpZiAocnVsZSkge1xuICAgICAgICAgICAgcnVsZVRyZWVzW2tleV0gPSBwYXJzZVJ1bGVUcmVlKGtleSwgcnVsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnVsZVRyZWVzO1xufVxuXG5cbmZ1bmN0aW9uIGRvZXNNYXRjaChydWxlLCBjb250ZXh0KSB7XG4gICAgLy8gem9vbSBwcmUtZmlsdGVyOiBza2lwIHJlc3Qgb2YgZmlsdGVyIGlmIG91dCBvZiBydWxlIHpvb20gcmFuZ2VcbiAgICBpZiAocnVsZS56b29tcyAhPSBudWxsICYmICFydWxlLnpvb21zW2NvbnRleHQuem9vbV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAoKHR5cGVvZiBydWxlLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyAmJiBydWxlLmZpbHRlcihjb250ZXh0KSkgfHwgKHJ1bGUuZmlsdGVyID09IG51bGwpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoRmVhdHVyZShjb250ZXh0LCBydWxlcywgY29sbGVjdGVkUnVsZXMsIGNvbGxlY3RlZFJ1bGVzSWRzKSB7XG4gICAgbGV0IG1hdGNoZWQgPSBmYWxzZTtcbiAgICBsZXQgY2hpbGRNYXRjaGVkID0gZmFsc2U7XG5cbiAgICBpZiAocnVsZXMubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxuXG4gICAgZm9yIChsZXQgcj0wOyByIDwgcnVsZXMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBydWxlc1tyXTtcbiAgICAgICAgY29udGV4dC5wcm9wZXJ0aWVzID0gY3VycmVudC5wcm9wZXJ0aWVzO1xuXG4gICAgICAgIGlmIChjdXJyZW50IGluc3RhbmNlb2YgUnVsZUxlYWYpIHtcblxuICAgICAgICAgICAgaWYgKGRvZXNNYXRjaChjdXJyZW50LCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbGxlY3RlZFJ1bGVzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgICAgY29sbGVjdGVkUnVsZXNJZHMucHVzaChjdXJyZW50LmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBSdWxlVHJlZSkge1xuICAgICAgICAgICAgaWYgKGRvZXNNYXRjaChjdXJyZW50LCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgY2hpbGRNYXRjaGVkID0gbWF0Y2hGZWF0dXJlKFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LnJ1bGVzLFxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWRSdWxlcyxcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkUnVsZXNJZHNcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZE1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkUnVsZXMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkUnVsZXNJZHMucHVzaChjdXJyZW50LmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnByb3BlcnRpZXMgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVkO1xufVxuIiwiLy8gUmVuZGVyaW5nIHN0eWxlc1xuXG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuL3N0eWxlX3BhcnNlcic7XG5pbXBvcnQgRmVhdHVyZVNlbGVjdGlvbiBmcm9tICcuLi9zZWxlY3Rpb24nO1xuaW1wb3J0IFNoYWRlclByb2dyYW0gZnJvbSAnLi4vZ2wvc2hhZGVyX3Byb2dyYW0nO1xuaW1wb3J0IFZCT01lc2ggZnJvbSAnLi4vZ2wvdmJvX21lc2gnO1xuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi4vZ2wvdGV4dHVyZSc7XG5pbXBvcnQgTWF0ZXJpYWwgZnJvbSAnLi4vbWF0ZXJpYWwnO1xuaW1wb3J0IExpZ2h0IGZyb20gJy4uL2xpZ2h0JztcbmltcG9ydCBzaGFkZXJTb3VyY2VzIGZyb20gJy4uL2dsL3NoYWRlcl9zb3VyY2VzJzsgLy8gYnVpbHQtaW4gc2hhZGVyc1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzL3V0aWxzJztcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbi8vIEJhc2UgY2xhc3NcblxuZXhwb3J0IHZhciBTdHlsZSA9IHtcbiAgICBpbml0ICh7IGdlbmVyYXRpb24gfSA9IHt9KSB7XG4gICAgICAgIGlmICghdGhpcy5pc0J1aWx0SW4oKSkge1xuICAgICAgICAgICAgdGhpcy5idWlsdF9pbiA9IGZhbHNlOyAvLyBleHBsaWNpdGx5IHNldCB0byBmYWxzZSB0byBhdm9pZCBhbnkgY29uZnVzaW9uXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdlbmVyYXRpb24gPSBnZW5lcmF0aW9uOyAgICAgICAgICAgICAgIC8vIHNjZW5lIGdlbmVyYXRpb24gaWQgdGhpcyBzdHlsZSB3YXMgY3JlYXRlZCBmb3JcbiAgICAgICAgdGhpcy5kZWZpbmVzID0gKHRoaXMuaGFzT3duUHJvcGVydHkoJ2RlZmluZXMnKSAmJiB0aGlzLmRlZmluZXMpIHx8IHt9OyAvLyAjZGVmaW5lcyB0byBiZSBpbmplY3RlZCBpbnRvIHRoZSBzaGFkZXJzXG4gICAgICAgIHRoaXMuc2hhZGVycyA9ICh0aGlzLmhhc093blByb3BlcnR5KCdzaGFkZXJzJykgJiYgdGhpcy5zaGFkZXJzKSB8fCB7fTsgLy8gc2hhZGVyIGN1c3RvbWl6YXRpb24gKHVuaWZvcm1zLCBkZWZpbmVzLCBibG9ja3MsIGV0Yy4pXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb24gfHwgZmFsc2U7ICAgLy8gZmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgc3R5bGUgc3VwcG9ydHMgZmVhdHVyZSBzZWxlY3Rpb25cbiAgICAgICAgdGhpcy5jb21waWxpbmcgPSBmYWxzZTsgICAgICAgICAgICAgICAgICAgICAvLyBwcm9ncmFtcyBhcmUgY3VycmVudGx5IGNvbXBpbGluZ1xuICAgICAgICB0aGlzLmNvbXBpbGVkID0gZmFsc2U7ICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2dyYW1zIGFyZSBmaW5pc2hlZCBjb21waWxpbmdcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDsgICAgICAgICAgICAgICAgICAgICAgICAvLyBHTCBwcm9ncmFtIHJlZmVyZW5jZSAoZm9yIG1haW4gcmVuZGVyIHBhc3MpXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uX3Byb2dyYW0gPSBudWxsOyAgICAgICAgICAgICAgLy8gR0wgcHJvZ3JhbSByZWZlcmVuY2UgZm9yIGZlYXR1cmUgc2VsZWN0aW9uIHJlbmRlciBwYXNzXG4gICAgICAgIHRoaXMuZmVhdHVyZV9zdHlsZSA9IHt9OyAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGUgZm9yIGZlYXR1cmUgY3VycmVudGx5IGJlaW5nIHBhcnNlZCwgc2hhcmVkIHRvIGxlc3NlbiBHQy9tZW1vcnkgdGhyYXNoXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlID0gW107ICAgICAgICAgICAgICAgICAgLy8gc2hhcmVkIHNpbmdsZS12ZXJ0ZXggdGVtcGxhdGUsIGZpbGxlZCBvdXQgYnkgZWFjaCBzdHlsZVxuICAgICAgICB0aGlzLnRpbGVfZGF0YSA9IHt9O1xuXG4gICAgICAgIC8vIERlZmF1bHQgd29ybGQgY29vcmRzIHRvIHdyYXAgZXZlcnkgMTAwLDAwMCBtZXRlcnMsIGNhbiB0dXJuIG9mZiBieSBzZXR0aW5nIHRoaXMgdG8gJ2ZhbHNlJ1xuICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9XT1JMRF9QT1NJVElPTl9XUkFQID0gMTAwMDAwO1xuXG4gICAgICAgIC8vIEJsZW5kaW5nXG4gICAgICAgIHRoaXMuYmxlbmQgPSB0aGlzLmJsZW5kIHx8ICdvcGFxdWUnOyAgICAgICAgLy8gZGVmYXVsdDogb3BhcXVlIHN0eWxlcyBhcmUgZHJhd24gZmlyc3QsIHdpdGhvdXQgYmxlbmRpbmdcbiAgICAgICAgdGhpcy5kZWZpbmVzW2BUQU5HUkFNX0JMRU5EXyR7dGhpcy5ibGVuZC50b1VwcGVyQ2FzZSgpfWBdID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuYmxlbmRfb3JkZXIgPT0gbnVsbCkgeyAvLyBjb250cm9scyBvcmRlciBvZiByZW5kZXJpbmcgZm9yIHN0eWxlcyB3L25vbi1vcGFxdWUgYmxlbmRpbmdcbiAgICAgICAgICAgIHRoaXMuYmxlbmRfb3JkZXIgPSAtMTsgLy8gZGVmYXVsdHMgdG8gZmlyc3RcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBzdHlsZSBkZWZpbmVzIGl0cyBvd24gbWF0ZXJpYWwsIHJlcGxhY2UgdGhlIGluaGVyaXRlZCBtYXRlcmlhbCBpbnN0YW5jZVxuICAgICAgICBpZiAoISh0aGlzLm1hdGVyaWFsIGluc3RhbmNlb2YgTWF0ZXJpYWwpKSB7XG4gICAgICAgICAgICBpZiAoIU1hdGVyaWFsLmlzVmFsaWQodGhpcy5tYXRlcmlhbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGVyaWFsID0gU3R5bGVQYXJzZXIuZGVmYXVsdHMubWF0ZXJpYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1hdGVyaWFsID0gbmV3IE1hdGVyaWFsKHRoaXMubWF0ZXJpYWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF0ZXJpYWwuaW5qZWN0KHRoaXMpO1xuXG4gICAgICAgIC8vIFNldCBsaWdodGluZyBtb2RlOiBmcmFnbWVudCwgdmVydGV4LCBvciBub25lIChzcGVjaWZpZWQgYXMgJ2ZhbHNlJylcbiAgICAgICAgTGlnaHQuc2V0TW9kZSh0aGlzLmxpZ2h0aW5nLCB0aGlzKTtcblxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgZGVzdHJveSAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb2dyYW0pIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uX3Byb2dyYW0pIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uX3Byb2dyYW0uZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25fcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdsID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICByZXNldCAoKSB7XG4gICAgfSxcblxuICAgIGlzQnVpbHRJbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc093blByb3BlcnR5KCdidWlsdF9pbicpICYmIHRoaXMuYnVpbHRfaW47XG4gICAgfSxcblxuICAgIGZpbGxWZXJ0ZXhUZW1wbGF0ZShhdHRyaWJ1dGUsIHZhbHVlLCB7IHNpemUsIG9mZnNldCB9KSB7XG4gICAgICAgIG9mZnNldCA9IChvZmZzZXQgPT09IHVuZGVmaW5lZCkgPyAwIDogb2Zmc2V0O1xuXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMudmVydGV4X2xheW91dC5pbmRleFthdHRyaWJ1dGVdO1xuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbG9nLndhcm4oYFN0eWxlOiBpbiBzdHlsZSAnJHt0aGlzLm5hbWV9Jywgbm8gaW5kZXggZm91bmQgaW4gdmVydGV4IGxheW91dCBmb3IgYXR0cmlidXRlICcke2F0dHJpYnV0ZX0nYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgICAgICAgbGV0IHYgPSB2YWx1ZS5sZW5ndGggPiBpID8gdmFsdWVbaV0gOiB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2luZGV4ICsgaSArIG9mZnNldF0gPSB2O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiogU3R5bGUgcGFyc2luZyBhbmQgZ2VvbWV0cnkgY29uc3RydWN0aW9uICoqKi9cblxuICAgIC8vIFJldHVybnMgYW4gb2JqZWN0IHRvIGhvbGQgZmVhdHVyZSBkYXRhIChmb3IgYSB0aWxlIG9yIG90aGVyIG9iamVjdClcbiAgICBzdGFydERhdGEgKHRpbGUpIHtcbiAgICAgICAgdGhpcy50aWxlX2RhdGFbdGlsZS5rZXldID0ge1xuICAgICAgICAgICAgdmVydGV4X2RhdGE6IG51bGwsXG4gICAgICAgICAgICB1bmlmb3JtczogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlX2RhdGFbdGlsZS5rZXldO1xuICAgIH0sXG5cbiAgICAvLyBGaW5hbGl6ZXMgYW4gb2JqZWN0IGhvbGRpbmcgZmVhdHVyZSBkYXRhIChmb3IgYSB0aWxlIG9yIG90aGVyIG9iamVjdClcbiAgICBlbmREYXRhICh0aWxlKSB7XG4gICAgICAgIGlmICh0aWxlLmNhbmNlbGVkKSB7XG4gICAgICAgICAgICBVdGlscy5sb2coJ2RlYnVnJywgYHN0b3AgdGlsZSBidWlsZCBiZWNhdXNlIHRpbGUgd2FzIHJlbW92ZWQ6ICR7dGlsZS5rZXl9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgIHZhciB0aWxlX2RhdGEgPSB0aGlzLnRpbGVfZGF0YVt0aWxlLmtleV07XG4gICAgICAgdGhpcy50aWxlX2RhdGFbdGlsZS5rZXldID0gbnVsbDtcblxuICAgICAgIGlmICh0aWxlX2RhdGEgJiYgdGlsZV9kYXRhLnZlcnRleF9kYXRhICYmIHRpbGVfZGF0YS52ZXJ0ZXhfZGF0YS52ZXJ0ZXhfY291bnQgPiAwKSB7XG4gICAgICAgICAgIC8vIE9ubHkga2VlcCBmaW5hbCBieXRlIGJ1ZmZlclxuICAgICAgICAgICB0aWxlX2RhdGEudmVydGV4X2RhdGEuZW5kKCk7XG4gICAgICAgICAgIHRpbGVfZGF0YS52ZXJ0ZXhfZGF0YSA9IHRpbGVfZGF0YS52ZXJ0ZXhfZGF0YS5idWZmZXI7XG4gICAgICAgfVxuICAgICAgIGVsc2Uge1xuICAgICAgICAgICB0aWxlX2RhdGEgPSBudWxsOyAvLyBkb24ndCBzZW5kIHRpbGUgZGF0YSBiYWNrIGlmIGRvZXNuJ3QgaGF2ZSBnZW9tZXRyeVxuICAgICAgIH1cblxuICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGlsZV9kYXRhKTtcbiAgICB9LFxuXG4gICAgLy8gSGFzIG1lc2ggZGF0YSBmb3IgYSBnaXZlbiB0aWxlP1xuICAgIGhhc0RhdGFGb3JUaWxlICh0aWxlX2tleSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlX2RhdGFbdGlsZV9rZXldICE9IG51bGw7XG4gICAgfSxcblxuICAgIGFkZEZlYXR1cmUgKGZlYXR1cmUsIHJ1bGUsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHRpbGUgPSBjb250ZXh0LnRpbGU7XG4gICAgICAgIGlmICh0aWxlLmdlbmVyYXRpb24gIT09IHRoaXMuZ2VuZXJhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnRpbGVfZGF0YVt0aWxlLmtleV0pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnREYXRhKHRpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0eWxlID0gdGhpcy5wYXJzZUZlYXR1cmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gYWxsb3cgc3ViY2xhc3NlcyB0byBwYXNzIGV4dHJhIGFyZ3NcblxuICAgICAgICAvLyBTa2lwIGZlYXR1cmU/XG4gICAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcnN0IGZlYXR1cmUgaW4gdGhpcyByZW5kZXIgc3R5bGU/XG4gICAgICAgIGlmICghdGhpcy50aWxlX2RhdGFbdGlsZS5rZXldLnZlcnRleF9kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnRpbGVfZGF0YVt0aWxlLmtleV0udmVydGV4X2RhdGEgPSB0aGlzLnZlcnRleF9sYXlvdXQuY3JlYXRlVmVydGV4RGF0YSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5idWlsZEdlb21ldHJ5KGZlYXR1cmUuZ2VvbWV0cnksIHN0eWxlLCB0aGlzLnRpbGVfZGF0YVt0aWxlLmtleV0udmVydGV4X2RhdGEsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBidWlsZEdlb21ldHJ5IChnZW9tZXRyeSwgc3R5bGUsIHZlcnRleF9kYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRQb2x5Z29ucyhbZ2VvbWV0cnkuY29vcmRpbmF0ZXNdLCBzdHlsZSwgdmVydGV4X2RhdGEsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkUG9seWdvbnMoZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkTGluZXMoW2dlb21ldHJ5LmNvb3JkaW5hdGVzXSwgc3R5bGUsIHZlcnRleF9kYXRhLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5idWlsZExpbmVzKGdlb21ldHJ5LmNvb3JkaW5hdGVzLCBzdHlsZSwgdmVydGV4X2RhdGEsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2ludCcpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRQb2ludHMoW2dlb21ldHJ5LmNvb3JkaW5hdGVzXSwgc3R5bGUsIHZlcnRleF9kYXRhLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2ludCcpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRQb2ludHMoZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcGFyc2VGZWF0dXJlIChmZWF0dXJlLCBydWxlX3N0eWxlLCBjb250ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmZlYXR1cmVfc3R5bGU7XG5cbiAgICAgICAgICAgIHJ1bGVfc3R5bGUgPSB0aGlzLnByZXByb2Nlc3MocnVsZV9zdHlsZSk7XG4gICAgICAgICAgICBpZiAoIXJ1bGVfc3R5bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBvcmRlciBpZiBpdCB3YXMgbm90IGNhY2hlZFxuICAgICAgICAgICAgc3R5bGUub3JkZXIgPSB0aGlzLnBhcnNlT3JkZXIocnVsZV9zdHlsZS5vcmRlciwgY29udGV4dCk7XG5cbiAgICAgICAgICAgIC8vIEZlYXR1cmUgc2VsZWN0aW9uIChvbmx5IGlmIHN0eWxlIHN1cHBvcnRzIGl0KVxuICAgICAgICAgICAgdmFyIHNlbGVjdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0eWxlLmludGVyYWN0aXZlID0gcnVsZV9zdHlsZS5pbnRlcmFjdGl2ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHNlbGVjdGFibGUgPSBTdHlsZVBhcnNlci5ldmFsUHJvcChzdHlsZS5pbnRlcmFjdGl2ZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGZlYXR1cmUgaXMgbWFya2VkIGFzIHNlbGVjdGFibGVcbiAgICAgICAgICAgIGlmIChzZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuc2VsZWN0aW9uX2NvbG9yID0gRmVhdHVyZVNlbGVjdGlvbi5tYWtlQ29sb3IoZmVhdHVyZSwgY29udGV4dC50aWxlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlLnNlbGVjdGlvbl9jb2xvciA9IEZlYXR1cmVTZWxlY3Rpb24uZGVmYXVsdENvbG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdWJjbGFzcyBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgc3R5bGUgPSB0aGlzLl9wYXJzZUZlYXR1cmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gYWxsb3cgc3ViY2xhc3NlcyB0byBwYXNzIGV4dHJhIGFyZ3NcblxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoJ1N0eWxlLnBhcnNlRmVhdHVyZTogc3R5bGUgcGFyc2luZyBlcnJvcicsIGZlYXR1cmUsIHN0eWxlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3BhcnNlRmVhdHVyZSAoZmVhdHVyZSwgcnVsZV9zdHlsZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlX3N0eWxlO1xuICAgIH0sXG5cbiAgICBwcmVwcm9jZXNzIChydWxlX3N0eWxlKSB7XG4gICAgICAgIC8vIFByZXByb2Nlc3MgZmlyc3QgdGltZVxuICAgICAgICBpZiAoIXJ1bGVfc3R5bGUucHJlcHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBydWxlX3N0eWxlID0gdGhpcy5fcHJlcHJvY2VzcyhydWxlX3N0eWxlKTsgLy8gb3B0aW9uYWwgc3ViY2xhc3MgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgIGlmICghcnVsZV9zdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1bGVfc3R5bGUucHJlcHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZV9zdHlsZTtcbiAgICB9LFxuXG4gICAgLy8gb3B0aW9uYWxseSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc1xuICAgIF9wcmVwcm9jZXNzIChydWxlX3N0eWxlKSB7XG4gICAgICAgIHJldHVybiBydWxlX3N0eWxlO1xuICAgIH0sXG5cbiAgICAvLyBQYXJzZSBhbiBvcmRlciB2YWx1ZVxuICAgIHBhcnNlT3JkZXIgKG9yZGVyLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBvcmRlciBpZiBpdCB3YXMgbm90IGNhY2hlZFxuICAgICAgICBpZiAodHlwZW9mIG9yZGVyICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIFN0eWxlUGFyc2VyLmNhbGN1bGF0ZU9yZGVyKG9yZGVyLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgfSxcblxuICAgIC8vIEV4cGFuZCBmaW5hbCBwcmVjaXNpb24gZm9yIGhhbGYtbGF5ZXJzIChmb3Igb3V0bGluZXMpXG4gICAgc2NhbGVPcmRlciAob3JkZXIpIHtcbiAgICAgICAgcmV0dXJuIG9yZGVyICogMjtcbiAgICB9LFxuXG4gICAgLy8gUGFyc2UgYSBjb2xvciBvZiBjaG9vc2UgYSBkZWZhdWx0IGlmIGFjY2VwdGFibGUsIHJldHVybiB1bmRlZmluZWQgaWYgY29sb3IgbWlzc2luZ1xuICAgIHBhcnNlQ29sb3IoY29sb3IsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gTmVlZCBlaXRoZXIgYSBjb2xvciwgb3IgYSBzaGFkZXIgYmxvY2sgZm9yICdjb2xvcicgb3IgJ2ZpbHRlcidcbiAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gU3R5bGVQYXJzZXIuY2FjaGVDb2xvcihjb2xvciwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zaGFkZXJzLmJsb2Nrcy5jb2xvciB8fCB0aGlzLnNoYWRlcnMuYmxvY2tzLmZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIFN0eWxlUGFyc2VyLmRlZmF1bHRzLmNvbG9yO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEJ1aWxkIGZ1bmN0aW9ucyBhcmUgbm8tb3BzIHVudGlsIG92ZXJyaWRlblxuICAgIGJ1aWxkUG9seWdvbnMgKCkge30sXG4gICAgYnVpbGRMaW5lcyAoKSB7fSxcbiAgICBidWlsZFBvaW50cyAoKSB7fSxcblxuXG4gICAgLyoqKiBHTCBzdGF0ZSBhbmQgcmVuZGVyaW5nICoqKi9cblxuICAgIHNldEdMIChnbCkge1xuICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgICAgIHRoaXMubWF4X3RleHR1cmVfc2l6ZSA9IFRleHR1cmUuZ2V0TWF4VGV4dHVyZVNpemUodGhpcy5nbCk7XG4gICAgfSxcblxuICAgIG1ha2VNZXNoICh2ZXJ0ZXhfZGF0YSwgeyB1bmlmb3JtcyB9ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWQk9NZXNoKHRoaXMuZ2wsIHZlcnRleF9kYXRhLCB0aGlzLnZlcnRleF9sYXlvdXQsIHsgdW5pZm9ybXMgfSk7XG4gICAgfSxcblxuICAgIGNvbXBpbGUgKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2wpIHtcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcihgc3R5bGUuY29tcGlsZSgpOiBza2lwcGluZyBmb3IgJHt0aGlzLm5hbWV9IGJlY2F1c2Ugbm8gR0wgY29udGV4dGApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbXBpbGluZykge1xuICAgICAgICAgICAgdGhyb3cobmV3IEVycm9yKGBzdHlsZS5jb21waWxlKCk6IHNraXBwaW5nIGZvciAke3RoaXMubmFtZX0gYmVjYXVzZSBzdHlsZSBpcyBhbHJlYWR5IGNvbXBpbGluZ2ApKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBpbGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBCdWlsZCBkZWZpbmVzICYgZm9yIHNlbGVjdGlvbiAobmVlZCB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IHNpbmNlIHRoZSBmaXJzdCBpcyBzdG9yZWQgYXMgYSByZWZlcmVuY2UgYnkgdGhlIHByb2dyYW0pXG4gICAgICAgIHZhciBkZWZpbmVzID0gdGhpcy5idWlsZERlZmluZUxpc3QoKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uX2RlZmluZXMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZpbmVzKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbl9kZWZpbmVzLlRBTkdSQU1fRkVBVFVSRV9TRUxFQ1RJT04gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGFueSBjdXN0b20gY29kZSBibG9ja3MsIHVuaWZvcm0gZGVwZW5kZW5jaWVzLCBldGMuXG4gICAgICAgIHZhciBibG9ja3MgPSAodGhpcy5zaGFkZXJzICYmIHRoaXMuc2hhZGVycy5ibG9ja3MpO1xuICAgICAgICB2YXIgYmxvY2tfc2NvcGVzID0gKHRoaXMuc2hhZGVycyAmJiB0aGlzLnNoYWRlcnMuYmxvY2tfc2NvcGVzKTtcbiAgICAgICAgdmFyIHVuaWZvcm1zID0gKHRoaXMuc2hhZGVycyAmJiB0aGlzLnNoYWRlcnMudW5pZm9ybXMpO1xuXG4gICAgICAgIC8vIGFjY2VwdCBhIHNpbmdsZSBleHRlbnNpb24sIG9yIGFuIGFycmF5IG9mIGV4dGVuc2lvbnNcbiAgICAgICAgdmFyIGV4dGVuc2lvbnMgPSAodGhpcy5zaGFkZXJzICYmIHRoaXMuc2hhZGVycy5leHRlbnNpb25zKTtcbiAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucyA9IFtleHRlbnNpb25zXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBzaGFkZXJzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0gPSBuZXcgU2hhZGVyUHJvZ3JhbShcbiAgICAgICAgICAgICAgICB0aGlzLmdsLFxuICAgICAgICAgICAgICAgIHNoYWRlclNvdXJjZXNbdGhpcy52ZXJ0ZXhfc2hhZGVyX2tleV0sXG4gICAgICAgICAgICAgICAgc2hhZGVyU291cmNlc1t0aGlzLmZyYWdtZW50X3NoYWRlcl9rZXldLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBkZWZpbmVzLFxuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtcyxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzLFxuICAgICAgICAgICAgICAgICAgICBibG9ja19zY29wZXMsXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtLmNvbXBpbGUoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25fcHJvZ3JhbSA9IG5ldyBTaGFkZXJQcm9ncmFtKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLFxuICAgICAgICAgICAgICAgICAgICBzaGFkZXJTb3VyY2VzW3RoaXMudmVydGV4X3NoYWRlcl9rZXldLFxuICAgICAgICAgICAgICAgICAgICBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3NlbGVjdGlvbl9mcmFnbWVudCddLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAodGhpcy5uYW1lICsgJyAoc2VsZWN0aW9uKScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lczogc2VsZWN0aW9uX2RlZmluZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrX3Njb3BlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25fcHJvZ3JhbS5jb21waWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbl9wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5jb21waWxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcihgc3R5bGUuY29tcGlsZSgpOiBzdHlsZSAke3RoaXMubmFtZX0gZXJyb3I6YCwgZXJyb3IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tcGlsaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcGlsZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBzaGFkZXIgYmxvY2tcbiAgICBhZGRTaGFkZXJCbG9jayAoa2V5LCBibG9jaywgc2NvcGUgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2hhZGVycy5ibG9ja3MgPSB0aGlzLnNoYWRlcnMuYmxvY2tzIHx8IHt9O1xuICAgICAgICB0aGlzLnNoYWRlcnMuYmxvY2tzW2tleV0gPSB0aGlzLnNoYWRlcnMuYmxvY2tzW2tleV0gfHwgW107XG4gICAgICAgIHRoaXMuc2hhZGVycy5ibG9ja3Nba2V5XS5wdXNoKGJsb2NrKTtcblxuICAgICAgICB0aGlzLnNoYWRlcnMuYmxvY2tfc2NvcGVzID0gdGhpcy5zaGFkZXJzLmJsb2NrX3Njb3BlcyB8fCB7fTtcbiAgICAgICAgdGhpcy5zaGFkZXJzLmJsb2NrX3Njb3Blc1trZXldID0gdGhpcy5zaGFkZXJzLmJsb2NrX3Njb3Blc1trZXldIHx8IFtdO1xuICAgICAgICB0aGlzLnNoYWRlcnMuYmxvY2tfc2NvcGVzW2tleV0ucHVzaChzY29wZSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhbGwgc2hhZGVyIGJsb2NrcyBmb3Iga2V5XG4gICAgcmVtb3ZlU2hhZGVyQmxvY2sgKGtleSkge1xuICAgICAgICBpZiAodGhpcy5zaGFkZXJzLmJsb2Nrcykge1xuICAgICAgICAgICAgdGhpcy5zaGFkZXJzLmJsb2Nrc1trZXldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZXBsYWNlU2hhZGVyQmxvY2sgKGtleSwgYmxvY2ssIHNjb3BlID0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlbW92ZVNoYWRlckJsb2NrKGtleSk7XG4gICAgICAgIHRoaXMuYWRkU2hhZGVyQmxvY2soa2V5LCBibG9jaywgc2NvcGUpO1xuICAgIH0sXG5cbiAgICAvKiogVE9ETzogY291bGQgcHJvYmFibHkgY29tYmluZSBhbmQgZ2VuZXJhbGl6ZSB0aGlzIHdpdGggc2ltaWxhciBtZXRob2QgaW4gU2hhZGVyUHJvZ3JhbVxuICAgICAqIChsaXN0IG9mIGRlZmluZSBvYmplY3RzIHRoYXQgaW5oZXJpdCBmcm9tIGVhY2ggb3RoZXIpXG4gICAgICovXG4gICAgYnVpbGREZWZpbmVMaXN0ICgpIHtcbiAgICAgICAgLy8gQWRkIGFueSBjdXN0b20gZGVmaW5lcyB0byBidWlsdC1pbiBzdHlsZSBkZWZpbmVzXG4gICAgICAgIHZhciBkZWZpbmVzID0ge307IC8vIGNyZWF0ZSBhIG5ldyBvYmplY3QgdG8gYXZvaWQgbXV0YXRpbmcgYSBwcm90b3R5cGUgdmFsdWUgdGhhdCBtYXkgYmUgc2hhcmVkIHdpdGggb3RoZXIgc3R5bGVzXG4gICAgICAgIGlmICh0aGlzLmRlZmluZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZCBpbiB0aGlzLmRlZmluZXMpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVzW2RdID0gdGhpcy5kZWZpbmVzW2RdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNoYWRlcnMgIT0gbnVsbCAmJiB0aGlzLnNoYWRlcnMuZGVmaW5lcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGQgaW4gdGhpcy5zaGFkZXJzLmRlZmluZXMpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVzW2RdID0gdGhpcy5zaGFkZXJzLmRlZmluZXNbZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmluZXM7XG5cbiAgICB9LFxuXG4gICAgLy8gU2V0dXAgYW55IEdMIHN0YXRlIGZvciByZW5kZXJpbmdcbiAgICBzZXR1cCAoKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybXMoKTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5zZXR1cFByb2dyYW0oU2hhZGVyUHJvZ3JhbS5jdXJyZW50KTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IHN0eWxlIHVuaWZvcm1zIG9uIGN1cnJlbnRseSBib3VuZCBwcm9ncmFtXG4gICAgc2V0VW5pZm9ybXMgKCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IFNoYWRlclByb2dyYW0uY3VycmVudDtcbiAgICAgICAgaWYgKCFwcm9ncmFtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm1zKHRoaXMuc2hhZGVycyAmJiB0aGlzLnNoYWRlcnMudW5pZm9ybXMsIHRydWUpOyAvLyByZXNldCB0ZXh0dXJlIHVuaXQgdG8gMFxuICAgIH0sXG5cbiAgICAvLyBSZW5kZXIgc3RhdGUgc2V0dGluZ3MgYnkgYmxlbmQgbW9kZVxuICAgIHJlbmRlcl9zdGF0ZXM6IHtcbiAgICAgICAgb3BhcXVlOiB7IGRlcHRoX3Rlc3Q6IHRydWUsIGRlcHRoX3dyaXRlOiB0cnVlIH0sXG4gICAgICAgIGFkZDogeyBkZXB0aF90ZXN0OiB0cnVlLCBkZXB0aF93cml0ZTogZmFsc2UgfSxcbiAgICAgICAgbXVsdGlwbHk6IHsgZGVwdGhfdGVzdDogdHJ1ZSwgZGVwdGhfd3JpdGU6IGZhbHNlIH0sXG4gICAgICAgIGlubGF5OiB7IGRlcHRoX3Rlc3Q6IHRydWUsIGRlcHRoX3dyaXRlOiBmYWxzZSB9LFxuICAgICAgICBvdmVybGF5OiB7IGRlcHRoX3Rlc3Q6IGZhbHNlLCBkZXB0aF93cml0ZTogZmFsc2UgfVxuICAgIH0sXG5cbiAgICAvLyBEZWZhdWx0IHNvcnQgb3JkZXIgZm9yIGJsZW5kIG1vZGVzXG4gICAgZGVmYXVsdF9ibGVuZF9vcmRlcnM6IHtcbiAgICAgICAgb3BhcXVlOiAwLFxuICAgICAgICBhZGQ6IDEsXG4gICAgICAgIG11bHRpcGx5OiAyLFxuICAgICAgICBpbmxheTogMyxcbiAgICAgICAgb3ZlcmxheTogNFxuICAgIH0sXG5cbiAgICAvLyBDb21wYXJpc29uIGZ1bmN0aW9uIGZvciBzb3J0aW5nIHN0eWxlcyBieSBibGVuZFxuICAgIGJsZW5kT3JkZXJTb3J0IChhLCBiKSB7XG4gICAgICAgIC8vIG9wYXF1ZSBhbHdheXMgY29tZXMgZmlyc3RcbiAgICAgICAgaWYgKGEuYmxlbmQgPT09ICdvcGFxdWUnIHx8IGIuYmxlbmQgPT09ICdvcGFxdWUnKSB7XG4gICAgICAgICAgICBpZiAoYS5ibGVuZCA9PT0gJ29wYXF1ZScgJiYgYi5ibGVuZCA9PT0gJ29wYXF1ZScpIHsgLy8gaWYgYm90aCBhcmUgb3BhcXVlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEubmFtZSA8IGIubmFtZSA/IC0xIDogMTsgLy8gdXNlIG5hbWUgYXMgdGllIGJyZWFrZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGEuYmxlbmQgPT09ICdvcGFxdWUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xOyAvLyBvbmx5IGBhYCB3YXMgb3BhcXVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTsgLy8gb25seSBgYmAgd2FzIG9wYXF1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlIGV4cGxpY2l0IGJsZW5kIG9yZGVyIGlmIHBvc3NpYmxlXG4gICAgICAgIGlmIChhLmJsZW5kX29yZGVyIDwgYi5ibGVuZF9vcmRlcikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuYmxlbmRfb3JkZXIgPiBiLmJsZW5kX29yZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGJsZW5kIG9yZGVycyBhcmUgZXF1YWwsIHVzZSBkZWZhdWx0IG9yZGVyIGJ5IGJsZW5kIG1vZGVcbiAgICAgICAgaWYgKFN0eWxlLmRlZmF1bHRfYmxlbmRfb3JkZXJzW2EuYmxlbmRdIDwgU3R5bGUuZGVmYXVsdF9ibGVuZF9vcmRlcnNbYi5ibGVuZF0pIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChTdHlsZS5kZWZhdWx0X2JsZW5kX29yZGVyc1thLmJsZW5kXSA+IFN0eWxlLmRlZmF1bHRfYmxlbmRfb3JkZXJzW2IuYmxlbmRdKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhLm5hbWUgPCBiLm5hbWUgPyAtMSA6IDE7IC8vIHVzZSBuYW1lIGFzIHRpZSBicmVha2VyXG4gICAgfSxcblxuICAgIHVwZGF0ZSAoKSB7XG4gICAgICAgIC8vIFN0eWxlLXNwZWNpZmljIGFuaW1hdGlvblxuICAgICAgICAvLyBpZiAodHlwZW9mIHRoaXMuYW5pbWF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICAgICB0aGlzLmFuaW1hdGlvbigpO1xuICAgICAgICAvLyB9XG4gICAgfVxuXG59O1xuIiwiLy8gTWFuYWdlIHJlbmRlcmluZyBzdHlsZXNcblxuaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gJy4uL2dsL3NoYWRlcl9wcm9ncmFtJztcbmltcG9ydCBzaGFkZXJTb3VyY2VzIGZyb20gJy4uL2dsL3NoYWRlcl9zb3VyY2VzJzsgLy8gYnVpbHQtaW4gc2hhZGVyc1xuaW1wb3J0IHtTdHlsZX0gZnJvbSAnLi9zdHlsZSc7XG5pbXBvcnQgbWVyZ2VPYmplY3RzIGZyb20gJy4uL3V0aWxzL21lcmdlJztcbmltcG9ydCBHZW8gZnJvbSAnLi4vZ2VvJztcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCB2YXIgU3R5bGVNYW5hZ2VyID0ge307XG5leHBvcnQgdmFyIFN0eWxlcyA9IHt9O1xuZXhwb3J0IHZhciBCYXNlU3R5bGVzID0ge307XG5cblN0eWxlTWFuYWdlci5zdHlsZXMgPSBTdHlsZXM7XG5cbi8vIFNldCB0aGUgYmFzZSBvYmplY3QgdXNlZCB0byBpbnN0YW50aWF0ZSBzdHlsZXNcblN0eWxlTWFuYWdlci5iYXNlU3R5bGUgPSBTdHlsZTtcblxuLy8gR2xvYmFsIGNvbmZpZ3VyYXRpb24gZm9yIGFsbCBzdHlsZXNcblN0eWxlTWFuYWdlci5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIFNoYWRlclByb2dyYW0ucmVtb3ZlQmxvY2soJ2dsb2JhbCcpO1xuICAgIFNoYWRlclByb2dyYW0ucmVtb3ZlQmxvY2soJ3NldHVwJyk7XG5cbiAgICAvLyBVbnBhY2tpbmcgZnVuY3Rpb25zIChmb3Igbm9ybWFsaXplZCB2ZXJ0ZXggYXR0cmlidXRlcylcbiAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKCdnbG9iYWwnLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3VucGFjayddKTtcblxuICAgIC8vIE1vZGVsIGFuZCB3b3JsZCBwb3NpdGlvbiBhY2Nlc3NvcnNcbiAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKCdnbG9iYWwnLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL2FjY2Vzc29ycyddKTtcblxuICAgIC8vIExheWVyIHJlLW9yZGVyaW5nIGZ1bmN0aW9uXG4gICAgU2hhZGVyUHJvZ3JhbS5hZGRCbG9jaygnZ2xvYmFsJywgc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9sYXllcl9vcmRlciddKTtcblxuICAgIC8vIEZlYXR1cmUgc2VsZWN0aW9uIGdsb2JhbFxuICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soJ2dsb2JhbCcsIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvc2VsZWN0aW9uX2dsb2JhbHMnXSk7XG5cbiAgICAvLyBGZWF0dXJlIHNlbGVjdGlvbiB2ZXJ0ZXggc2hhZGVyIHN1cHBvcnRcbiAgICBTaGFkZXJQcm9ncmFtLnJlcGxhY2VCbG9jaygnc2V0dXAnLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3NlbGVjdGlvbl92ZXJ0ZXgnXSk7XG5cbiAgICAvLyBNaW5pbXVtIHZhbHVlIGZvciBmbG9hdCBjb21wYXJpc29uc1xuICAgIFNoYWRlclByb2dyYW0uZGVmaW5lcy5UQU5HUkFNX0VQU0lMT04gPSAwLjAwMDAxO1xuXG4gICAgLy8gYXNzdW1lIG1pbiAxNi1iaXQgZGVwdGggYnVmZmVyLCBpbiBwcmFjdGljZSB1c2VzIDE0LWJpdHMsIDEgZXh0cmEgYml0IHRvIGhhbmRsZSB2aXJ0dWFsIGhhbGYtbGF5ZXJzXG4gICAgLy8gZm9yIG91dGxpbmVzIChpbnNlcnRlZCBpbiBiZXR3ZWVuIGxheWVycyksIGFub3RoZXIgZXh0cmEgYml0IHRvIHByZXZlbnQgcHJlY2lzaW9uIGxvc3NcbiAgICBTaGFkZXJQcm9ncmFtLmRlZmluZXMuVEFOR1JBTV9MQVlFUl9ERUxUQSA9IDEgLyAoMSA8PCAxNCk7XG5cbiAgICAvLyBJbnRlcm5hbCB0aWxlIHNjYWxlXG4gICAgU2hhZGVyUHJvZ3JhbS5kZWZpbmVzLlRBTkdSQU1fVElMRV9TQ0FMRSA9IGB2ZWMzKCR7R2VvLnRpbGVfc2NhbGV9LiwgJHtHZW8udGlsZV9zY2FsZX0uLCB1X21ldGVyc19wZXJfcGl4ZWwgKiAke0dlby50aWxlX3NpemV9LilgO1xufTtcblxuLy8gRGVzdHJveSBhbGwgc3R5bGVzIGZvciBhIGdpdmVuIEdMIGNvbnRleHRcblN0eWxlTWFuYWdlci5kZXN0cm95ID0gZnVuY3Rpb24gKGdsKSB7XG4gICAgT2JqZWN0LmtleXMoU3R5bGVzKS5mb3JFYWNoKChfbmFtZSkgPT4ge1xuICAgICAgICB2YXIgc3R5bGUgPSBTdHlsZXNbX25hbWVdO1xuICAgICAgICBpZiAoc3R5bGUuZ2wgPT09IGdsKSB7XG4gICAgICAgICAgICBsb2cudHJhY2UoYFN0eWxlTWFuYWdlci5kZXN0cm95OiBkZXN0cm95aW5nIHJlbmRlciBzdHlsZSAke3N0eWxlLm5hbWV9YCk7XG5cbiAgICAgICAgICAgIGlmICghc3R5bGUuaXNCdWlsdEluKCkpIHtcbiAgICAgICAgICAgICAgICBTdHlsZU1hbmFnZXIucmVtb3ZlKHN0eWxlLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vLyBSZWdpc3RlciBhIHN0eWxlXG5TdHlsZU1hbmFnZXIucmVnaXN0ZXIgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICBTdHlsZXNbc3R5bGUubmFtZV0gPSBzdHlsZTtcbiAgICBCYXNlU3R5bGVzW3N0eWxlLm5hbWVdID0gc3R5bGU7XG59O1xuXG4vLyBSZW1vdmUgYSBzdHlsZVxuU3R5bGVNYW5hZ2VyLnJlbW92ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgZGVsZXRlIFN0eWxlc1tuYW1lXTtcbn07XG5cbi8vIExvYWQgc3R5bGUgZGVmaW5pdGlvbnMgZnJvbSBleHRlcm5hbCBVUkxzXG5TdHlsZU1hbmFnZXIubG9hZFJlbW90ZVN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXMsIGJhc2UpIHtcbiAgICAvLyBDb2xsZWN0IFVSTHMgYW5kIG1vZGVzIHRvIGltcG9ydCBmcm9tIHRoZW1cbiAgICAvLyBUaGlzIGlzIGRvbmUgYXMgYSBzZXBhcmF0ZSBzdGVwIGJlY3Vhc2UgaXQgaXMgcG9zc2libGUgdG8gaW1wb3J0IG11bHRpcGxlIG1vZGVzIGZyb20gYSBzaW5nbGVcbiAgICAvLyBVUkwsIGFuZCB3ZSB3YW50IHRvIGF2b2lkIGR1cGxpY2F0ZSBjYWxscyBmb3IgdGhlIHNhbWUgZmlsZS5cbiAgICB2YXIgdXJscyA9IHt9O1xuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHN0eWxlc1tuYW1lXTtcbiAgICAgICAgaWYgKHN0eWxlLnVybCkge1xuICAgICAgICAgICAgbGV0IHVybCA9IHN0eWxlLnVybDtcbiAgICAgICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gVXRpbHMuYWRkQmFzZVVSTCh1cmwsIGJhc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXVybHNbdXJsXSkge1xuICAgICAgICAgICAgICAgIHVybHNbdXJsXSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIGEgbGlzdCBvZiB0aGUgc3R5bGVzIHRvIGltcG9ydCBmb3IgdGhpcyBVUkxcbiAgICAgICAgICAgIHVybHNbdXJsXS5wdXNoKHtcbiAgICAgICAgICAgICAgICB0YXJnZXRfbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBzb3VyY2VfbmFtZTogc3R5bGUubmFtZSB8fCBuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFzIGVhY2ggVVJMIGZpbmlzaGVzIGxvYWRpbmcsIHJlcGxhY2UgdGhlIHRhcmdldCBzdHlsZShzKVxuICAgIHJldHVybiBQcm9taXNlLmFsbChPYmplY3Qua2V5cyh1cmxzKS5tYXAodXJsID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIFV0aWxzLmxvYWRSZXNvdXJjZSh1cmwpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBNaXhpbiByZW1vdGUgc3R5bGVzLCB3aXRoaW4gZWFjaCByZW1vdGUgZmlsZVxuICAgICAgICAgICAgICAgIC8vIFRPRE86IG1heSBub3QgaGFuZGxlIG11bHRpcGxlIGxldmVscyBvZiBtaXhpbnMsIGFuZCB3aWxsIG5vdCBoYW5kbGUgbmVzdGVkIHJlbW90ZSBmaWxlc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHNvdXJjZV9uYW1lIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNvdXJjZV9pbXBvcnQgPSB1cmxzW3VybF0gJiYgdXJsc1t1cmxdLmZpbHRlcihzID0+IHMuc291cmNlX25hbWUgPT09IHNvdXJjZV9uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlX2ltcG9ydCA9IHNvdXJjZV9pbXBvcnQgJiYgc291cmNlX2ltcG9ydFswXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlX2ltcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGltcG9ydGVkIG5hbWUgaWYgZGlmZmVyZW50IGZyb20gbmFtZSBpbiBzb3VyY2UgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtzb3VyY2VfbmFtZV0ubmFtZSA9IHNvdXJjZV9pbXBvcnQudGFyZ2V0X25hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3NvdXJjZV9uYW1lXS5uYW1lID0gc291cmNlX25hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkYXRhW3NvdXJjZV9uYW1lXSA9IFN0eWxlTWFuYWdlci5taXgoZGF0YVtzb3VyY2VfbmFtZV0sIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCByZW1vdGUgc3R5bGVzIHRvIGxvY2FsIHN0eWxlc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHRhcmdldCBvZiB1cmxzW3VybF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YVt0YXJnZXQuc291cmNlX25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXNbdGFyZ2V0LnRhcmdldF9uYW1lXSA9IGRhdGFbdGFyZ2V0LnNvdXJjZV9uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZXNbdGFyZ2V0LnRhcmdldF9uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGBTdHlsZU1hbmFnZXIubG9hZFJlbW90ZVN0eWxlczogZXJyb3IgaW1wb3J0aW5nIHN0eWxlICR7dGFyZ2V0LnRhcmdldF9uYW1lfSwgY291bGQgbm90IGZpbmQgc291cmNlIHN0eWxlICR7dGFyZ2V0LnNvdXJjZV9uYW1lfSBpbiAke3VybH1gKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihgU3R5bGVNYW5hZ2VyLmxvYWRSZW1vdGVTdHlsZXM6IGVycm9yIGltcG9ydGluZyBzdHlsZShzKSAke0pTT04uc3RyaW5naWZ5KHVybHNbdXJsXSl9IGZyb20gJHt1cmx9YCwgZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pKS50aGVuKCgpID0+IFByb21pc2UucmVzb2x2ZShzdHlsZXMpKTtcbn07XG5cbi8vIFByZWxvYWQgc2hhZGVyIGJsb2NrcyBmcm9tIGV4dGVybmFsIFVSTHNcblN0eWxlTWFuYWdlci5sb2FkU2hhZGVyQmxvY2tzID0gZnVuY3Rpb24gKHN0eWxlcywgYmFzZSkge1xuICAgIGlmICghc3R5bGVzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xuICAgIH1cbiAgICB2YXIgcXVldWUgPSBbXTtcbiAgICBmb3IgKHZhciBzdHlsZSBvZiBVdGlscy52YWx1ZXMoc3R5bGVzKSkge1xuICAgICAgICBpZiAoc3R5bGUuc2hhZGVycyAmJiBzdHlsZS5zaGFkZXJzLmJsb2Nrcykge1xuICAgICAgICAgICAgbGV0IF9ibG9ja3MgPSBzdHlsZS5zaGFkZXJzLmJsb2NrcztcblxuICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgYmxvY2tdIG9mIFV0aWxzLmVudHJpZXMoc3R5bGUuc2hhZGVycy5ibG9ja3MpKSB7XG4gICAgICAgICAgICAgICAgbGV0IF9rZXkgPSBrZXk7XG5cbiAgICAgICAgICAgICAgICAvLyBBcnJheSBvZiBibG9ja3NcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShibG9jaykpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgYj0wOyBiIDwgYmxvY2subGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYmxvY2tbYl0gPT09ICdvYmplY3QnICYmIGJsb2NrW2JdLnVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfaW5kZXggPSBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1cmwgPSBibG9ja1tiXS51cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gVXRpbHMuYWRkQmFzZVVSTCh1cmwsIGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goVXRpbHMuaW8oVXRpbHMuY2FjaGVCdXN0ZXJGb3JVcmwodXJsKSkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmxvY2tzW19rZXldW19pbmRleF0gPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuZXJyb3IoYFN0eWxlTWFuYWdlci5sb2FkU2hhZGVyQmxvY2tzOiBlcnJvciBsb2FkaW5nIHNoYWRlciBibG9ja2AsIF9ibG9ja3MsIF9rZXksIF9pbmRleCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTaW5nbGUgYmxvY2tcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYmxvY2sgPT09ICdvYmplY3QnICYmIGJsb2NrLnVybCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gYmxvY2sudXJsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gVXRpbHMuYWRkQmFzZVVSTCh1cmwsIGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChVdGlscy5pbyhVdGlscy5jYWNoZUJ1c3RlckZvclVybCh1cmwpKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYmxvY2tzW19rZXldID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cuZXJyb3IoYFN0eWxlTWFuYWdlci5sb2FkU2hhZGVyQmxvY2tzOiBlcnJvciBsb2FkaW5nIHNoYWRlciBibG9ja2AsIF9ibG9ja3MsIF9rZXksIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocXVldWUpLnRoZW4oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHN0eWxlcykpOyAvLyBUT0RPOiBhZGQgZXJyb3Jcbn07XG5cblN0eWxlTWFuYWdlci5taXggPSBmdW5jdGlvbiAoc3R5bGUsIHN0eWxlcykge1xuICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgaGF2ZSBhbHJlYWR5IGFwcGxpZWQgbWl4aW5zIHRvIHRoaXMgc3R5bGVcbiAgICBpZiAoc3R5bGUubWl4ZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cbiAgICBzdHlsZS5taXhlZCA9IHt9O1xuXG4gICAgLy8gTWl4aW4gc291cmNlcywgaW4gb3JkZXJcbiAgICBsZXQgc291cmNlcyA9IFtdO1xuICAgIGlmIChzdHlsZS5taXgpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUubWl4KSkge1xuICAgICAgICAgICAgc291cmNlcy5wdXNoKC4uLnN0eWxlLm1peCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VzLnB1c2goc3R5bGUubWl4KTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VzID0gc291cmNlcy5tYXAoeCA9PiBzdHlsZXNbeF0pLmZpbHRlcih4ID0+IHggJiYgeCAhPT0gc3R5bGUpOyAvLyBUT0RPOiB3YXJuaW5nIG9uIHRyeWluZyB0byBtaXggaW50byBzZWxmXG5cbiAgICAgICAgLy8gVHJhY2sgd2hpY2ggc3R5bGVzIHdlcmUgbWl4ZWQgaW50byB0aGlzIG9uZVxuICAgICAgICBmb3IgKGxldCBzIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgICAgIHN0eWxlLm1peGVkW3MubmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNvdXJjZXMucHVzaChzdHlsZSk7XG5cbiAgICAvLyBGbGFncyAtIE9SJ2QsIHRydWUgaWYgYW55IHN0eWxlIGhhcyBpdCBzZXRcbiAgICBzdHlsZS5hbmltYXRlZCA9IHNvdXJjZXMuc29tZSh4ID0+IHggJiYgeC5hbmltYXRlZCk7XG4gICAgc3R5bGUudGV4Y29vcmRzID0gc291cmNlcy5zb21lKHggPT4geCAmJiB4LnRleGNvb3Jkcyk7XG5cbiAgICAvLyBPdmVyd3JpdGVzIC0gbGFzdCBkZWZpbml0aW9uIHdpbnNcbiAgICBzdHlsZS5iYXNlID0gc291cmNlcy5tYXAoeCA9PiB4LmJhc2UpLmZpbHRlcih4ID0+IHgpLnBvcCgpO1xuICAgIHN0eWxlLmxpZ2h0aW5nID0gc291cmNlcy5tYXAoeCA9PiB4LmxpZ2h0aW5nKS5maWx0ZXIoeCA9PiB4ICE9IG51bGwpLnBvcCgpO1xuICAgIHN0eWxlLnRleHR1cmUgPSBzb3VyY2VzLm1hcCh4ID0+IHgudGV4dHVyZSkuZmlsdGVyKHggPT4geCkucG9wKCk7XG4gICAgaWYgKHNvdXJjZXMuc29tZSh4ID0+IHguaGFzT3duUHJvcGVydHkoJ2JsZW5kJykgJiYgeC5ibGVuZCkpIHtcbiAgICAgICAgLy8gb25seSBtaXggYmxlbmQgaWYgZXhwbGljaXRseSBzZXQsIG90aGVyd2lzZSBsZXQgYmFzZSBzdHlsZSBjaG9vc2UgYmxlbmRpbmcgbW9kZVxuICAgICAgICAvLyBoYXNPd25Qcm9wZXJ0eSBjaGVjayBnaXZlcyBwcmVmZXJlbmNlIHRvIGJhc2Ugc3R5bGUgcHJvdG90eXBlXG4gICAgICAgIHN0eWxlLmJsZW5kID0gc291cmNlcy5tYXAoeCA9PiB4Lmhhc093blByb3BlcnR5KCdibGVuZCcpICYmIHguYmxlbmQpLmZpbHRlcih4ID0+IHgpLnBvcCgpO1xuICAgIH1cbiAgICBzdHlsZS5ibGVuZF9vcmRlciA9IHNvdXJjZXMubWFwKHggPT4geC5ibGVuZF9vcmRlcikuZmlsdGVyKHggPT4geCAhPSBudWxsKS5wb3AoKTtcblxuICAgIC8vIE1lcmdlcyAtIHByb3BlcnR5LXNwZWNpZmljIHJ1bGVzIGZvciBtZXJnaW5nIHZhbHVlc1xuICAgIHN0eWxlLmRlZmluZXMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5zb3VyY2VzLm1hcCh4ID0+IHguZGVmaW5lcykuZmlsdGVyKHggPT4geCkpOyAvLyBpbnRlcm5hbCBkZWZpbmVzIChub3QgdXNlci1kZWZpbmVkKVxuICAgIHN0eWxlLm1hdGVyaWFsID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uc291cmNlcy5tYXAoeCA9PiB4Lm1hdGVyaWFsKS5maWx0ZXIoeCA9PiB4KSk7XG5cbiAgICAvLyBNaXggc2hhZGVyIHByb3BlcnRpZXNcbiAgICBTdHlsZU1hbmFnZXIubWl4U2hhZGVycyhzdHlsZSwgc3R5bGVzLCBzb3VyY2VzKTtcbiAgICByZXR1cm4gc3R5bGU7XG59O1xuXG4vLyBNaXggdGhlIHByb3BlcnRlcyBpbiB0aGUgXCJzaGFkZXJzXCIgYmxvY2tcblN0eWxlTWFuYWdlci5taXhTaGFkZXJzID0gZnVuY3Rpb24gKHN0eWxlLCBzdHlsZXMsIHNvdXJjZXMpIHtcbiAgICBsZXQgc2hhZGVycyA9IHt9OyAvLyBuZXdseSBtaXhlZCBzaGFkZXJzIHByb3BlcnRpZXNcbiAgICBsZXQgc2hhZGVyX21lcmdlcyA9IHNvdXJjZXMubWFwKHggPT4geC5zaGFkZXJzKS5maWx0ZXIoeCA9PiB4KTsgLy8ganVzdCB0aGUgc291cmNlIHN0eWxlcyB3aXRoIHNoYWRlciBwcm9wZXJ0aWVzXG5cbiAgICAvLyBEZWZpbmVzXG4gICAgc2hhZGVycy5kZWZpbmVzID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uc2hhZGVyX21lcmdlcy5tYXAoeCA9PiB4LmRlZmluZXMpLmZpbHRlcih4ID0+IHgpKTtcblxuICAgIC8vIFVuaWZvcm1zXG4gICAgc2hhZGVycy51bmlmb3JtcyA9IHt9OyAgLy8gdW5pZm9ybXMgZm9yIHRoaXMgc3R5bGUsIGJvdGggZXhwbGljaXRseSBkZWZpbmVkLCBhbmQgbWl4ZWQgZnJvbSBvdGhlciBzdHlsZXNcbiAgICBzaGFkZXJzLl91bmlmb3JtcyA9IChzdHlsZS5zaGFkZXJzICYmIHN0eWxlLnNoYWRlcnMudW5pZm9ybXMpIHx8IHt9OyAvLyB1bmlmb3JtcyBleHBsaWNpdGx5IGRlZmluZWQgYnkgKnRoaXMqIHN0eWxlXG4gICAgc2hhZGVycy5fdW5pZm9ybV9zY29wZXMgPSB7fTsgLy8gdHJhY2tzIHdoaWNoIHN0eWxlIGVhY2ggdW5pZm9ybSBvcmlnaW5hdGVkIGZyb20gKHRoaXMgb25lLCBvciBhbmNlc3RvcilcblxuICAgIC8vIE1peCBpbiB1bmlmb3JtcyBmcm9tIGFuY2VzdG9ycywgcHJvdmlkaW5nIG1lYW5zIHRvIGFjY2Vzc1xuICAgIHNvdXJjZXNcbiAgICAgICAgLmZpbHRlcih4ID0+IHguc2hhZGVycyAmJiB4LnNoYWRlcnMudW5pZm9ybXMpXG4gICAgICAgIC5mb3JFYWNoKHggPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgdSBpbiB4LnNoYWRlcnMudW5pZm9ybXMpIHtcbiAgICAgICAgICAgICAgICBzaGFkZXJzLl91bmlmb3JtX3Njb3Blc1t1XSA9IHgubmFtZTtcblxuICAgICAgICAgICAgICAgIC8vIERlZmluZSBnZXR0ZXIgYW5kIHNldHRlciBmb3IgdGhpcyB1bmlmb3JtXG4gICAgICAgICAgICAgICAgLy8gR2V0dGVyIHJldHVybnMgdmFsdWUgZm9yIHRoaXMgc3R5bGUgaWYgcHJlc2VudCwgb3RoZXJ3aXNlIGFza3MgYXBwcm9wcmlhdGUgYW5jZXN0b3IgZm9yIGl0XG4gICAgICAgICAgICAgICAgLy8gU2V0dGVyIHNldHMgdGhlIHZhbHVlIGZvciB0aGlzIHN0eWxlICh3aGV0aGVyIHByZXZpb3VzbHkgcHJlc2VudCBpbiB0aGlzIHN0eWxlIG9yIG5vdClcbiAgICAgICAgICAgICAgICAvLyBNaW1pY3MgSlMgcHJvdG90eXBlL2hhc093blByb3BlcnR5IGJlaGF2aW9yLCBidXQgd2l0aCBtdWx0aXBsZSBhbmNlc3RvcnMgKHZpYSBtaXhpbnMpXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNoYWRlcnMudW5pZm9ybXMsIHUsIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuaWZvcm0gaXMgZXhwbGljaXRseSBkZWZpbmVkIG9uIHRoaXMgc3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFkZXJzLl91bmlmb3Jtc1t1XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoYWRlcnMuX3VuaWZvcm1zW3VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5pZm9ybSB3YXMgbWl4ZWQgZnJvbSBhbm90aGVyIHN0eWxlLCBmb3J3YXJkIHJlcXVlc3QgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElkZW50aWZ5IGNoZWNrIGlzIG5lZWRlZCB0byBwcmV2ZW50IGluZmluaXRlIHJlY3Vyc2lvbiBpZiBhIHByZXZpb3VzbHkgZGVmaW5lZCB1bmlmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBzZXQgdG8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHlsZXNbc2hhZGVycy5fdW5pZm9ybV9zY29wZXNbdV1dLnNoYWRlcnMudW5pZm9ybXMgIT09IHNoYWRlcnMudW5pZm9ybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGVzW3NoYWRlcnMuX3VuaWZvcm1fc2NvcGVzW3VdXS5zaGFkZXJzLnVuaWZvcm1zW3VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFkZXJzLl91bmlmb3Jtc1t1XSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAvLyBFeHRlbnNpb25zOiBidWlsZCBhIGxpc3Qgb2YgdW5pcXVlIGV4dGVuc2lvbnNcbiAgICBzaGFkZXJzLmV4dGVuc2lvbnMgPSBPYmplY3Qua2V5cyhzaGFkZXJfbWVyZ2VzXG4gICAgICAgIC5tYXAoeCA9PiB4LmV4dGVuc2lvbnMpXG4gICAgICAgIC5maWx0ZXIoeCA9PiB4KVxuICAgICAgICAucmVkdWNlKChwcmV2LCBjdXIpID0+IHtcbiAgICAgICAgICAgIC8vIHNpbmdsZSBleHRlbnNpb25cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHByZXZbY3VyXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhcnJheSBvZiBleHRlbnNpb25zXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXIuZm9yRWFjaCh4ID0+IHByZXZbeF0gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9LCB7fSkgfHwge31cbiAgICApO1xuXG4gICAgLy8gU2hhZGVyIGJsb2Nrc1xuICAgIC8vIE1hcmsgYWxsIHNoYWRlciBibG9ja3MgZm9yIHRoZSB0YXJnZXQgc3R5bGUgYXMgb3JpZ2luYXRpbmcgd2l0aCBpdHMgb3duIG5hbWVcbiAgICBpZiAoc3R5bGUuc2hhZGVycyAmJiBzdHlsZS5zaGFkZXJzLmJsb2Nrcykge1xuICAgICAgICBzdHlsZS5zaGFkZXJzLmJsb2NrX3Njb3BlcyA9IHN0eWxlLnNoYWRlcnMuYmxvY2tfc2NvcGVzIHx8IHt9O1xuICAgICAgICBmb3IgKGxldCBbaywgYmxvY2tdIG9mIFV0aWxzLmVudHJpZXMoc3R5bGUuc2hhZGVycy5ibG9ja3MpKSB7XG4gICAgICAgICAgICBzdHlsZS5zaGFkZXJzLmJsb2NrX3Njb3Blc1trXSA9IHN0eWxlLnNoYWRlcnMuYmxvY2tfc2NvcGVzW2tdIHx8IFtdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYmxvY2spKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuc2hhZGVycy5ibG9ja19zY29wZXNba10ucHVzaCguLi5ibG9jay5tYXAoKCkgPT4gc3R5bGUubmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuc2hhZGVycy5ibG9ja19zY29wZXNba10ucHVzaChzdHlsZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1lcmdlIHNoYWRlciBibG9ja3MsIGtlZXBpbmcgdHJhY2sgb2Ygd2hpY2ggc3R5bGUgZWFjaCBibG9jayBvcmlnaW5hdGVkIGZyb21cbiAgICBsZXQgbWl4ZWQgPSB7fTsgLy8gYWxsIHNjb3BlcyBtaXhlZCBzbyBmYXJcbiAgICBmb3IgKGxldCBzb3VyY2Ugb2Ygc2hhZGVyX21lcmdlcykge1xuICAgICAgICBpZiAoIXNvdXJjZS5ibG9ja3MpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2hhZGVycy5ibG9ja3MgPSBzaGFkZXJzLmJsb2NrcyB8fCB7fTtcbiAgICAgICAgc2hhZGVycy5ibG9ja19zY29wZXMgPSBzaGFkZXJzLmJsb2NrX3Njb3BlcyB8fCB7fTtcbiAgICAgICAgbGV0IG1peGVkX3NvdXJjZSA9IHt9OyAvLyBzY29wZXMgbWl4ZWQgZm9yIHRoaXMgc291cmNlIHN0eWxlXG5cbiAgICAgICAgZm9yIChsZXQgW3QsIGJsb2NrXSBvZiBVdGlscy5lbnRyaWVzKHNvdXJjZS5ibG9ja3MpKSB7XG4gICAgICAgICAgICBsZXQgYmxvY2tfc2NvcGUgPSBzb3VyY2UuYmxvY2tfc2NvcGVzW3RdO1xuXG4gICAgICAgICAgICBzaGFkZXJzLmJsb2Nrc1t0XSA9IHNoYWRlcnMuYmxvY2tzW3RdIHx8IFtdO1xuICAgICAgICAgICAgc2hhZGVycy5ibG9ja19zY29wZXNbdF0gPSBzaGFkZXJzLmJsb2NrX3Njb3Blc1t0XSB8fCBbXTtcblxuICAgICAgICAgICAgLy8gc3RhbmRhcmRpemUgb24gYXJyYXlzIChibG9jayBjYW4gYmUgc2luZ2xlIG9yIG11bHRpLXZhbHVlKVxuICAgICAgICAgICAgYmxvY2sgPSBBcnJheS5pc0FycmF5KGJsb2NrKSA/IGJsb2NrIDogW2Jsb2NrXTtcbiAgICAgICAgICAgIGJsb2NrX3Njb3BlID0gQXJyYXkuaXNBcnJheShibG9ja19zY29wZSkgPyBibG9ja19zY29wZSA6IFtibG9ja19zY29wZV07XG5cbiAgICAgICAgICAgIGZvciAobGV0IGI9MDsgYiA8IGJsb2NrLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBibG9ja3Mgd2UndmUgYWxyZWFkeSBtaXhlZCBpbiBmcm9tIHRoZSBzYW1lIHNjb3BlXG4gICAgICAgICAgICAgICAgLy8gUmVwZWF0aW5nIHNjb3BlIGluZGljYXRlcyBhIGRpYW1vbmQgcGF0dGVybiB3aGVyZSBhIHN0eWxlIGlzIGJlaW5nIG1peGVkIG11bHRpcGxlIHRpbWVzXG4gICAgICAgICAgICAgICAgaWYgKG1peGVkW2Jsb2NrX3Njb3BlW2JdXSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWl4ZWRfc291cmNlW2Jsb2NrX3Njb3BlW2JdXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBzaGFkZXJzLmJsb2Nrc1t0XS5wdXNoKGJsb2NrW2JdKTtcbiAgICAgICAgICAgICAgICBzaGFkZXJzLmJsb2NrX3Njb3Blc1t0XS5wdXNoKGJsb2NrX3Njb3BlW2JdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBzdHlsZXMgbWl4ZWQgaW4gZnJvbSB0aGlzIHNvdXJjZSAtIHRoZXkgY291bGQgYmUgbXVsdGktbGV2ZWwgYW5jZXN0b3JzLFxuICAgICAgICAvLyBiZXlvbmQgdGhlIGZpcnN0LWxldmVsIFwicGFyZW50c1wiIGRlZmluZWQgaW4gdGhpcyBzdHlsZSdzIGBtaXhgIGxpc3RcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZS5taXhlZCwgbWl4ZWRfc291cmNlKTtcbiAgICB9XG5cbiAgICBzdHlsZS5zaGFkZXJzID0gc2hhZGVyczsgLy8gYXNzaWduIGJhY2sgdG8gc3R5bGVcbiAgICByZXR1cm4gc3R5bGU7XG59O1xuXG4vLyBDcmVhdGUgYSBuZXcgc3R5bGVcbi8vIG5hbWU6IG5hbWUgb2YgbmV3IHN0eWxlXG4vLyBjb25maWc6IHByb3BlcnRpZXMgb2YgbmV3IHN0eWxlXG4vLyBzdHlsZXM6IHdvcmtpbmcgc2V0IG9mIHN0eWxlcyBiZWluZyBidWlsdCAodXNlZCBmb3IgbWl4aW5nIGluIGV4aXN0aW5nIHN0eWxlcylcblN0eWxlTWFuYWdlci5jcmVhdGUgPSBmdW5jdGlvbiAobmFtZSwgY29uZmlnLCBzdHlsZXMgPSB7fSkge1xuICAgIGxldCBzdHlsZSA9IG1lcmdlT2JqZWN0cyh7fSwgY29uZmlnKTsgLy8gZGVlcCBjb3B5XG4gICAgc3R5bGUubmFtZSA9IG5hbWU7XG5cbiAgICAvLyBTdHlsZSBtaXhpbnNcbiAgICBzdHlsZSA9IFN0eWxlTWFuYWdlci5taXgoc3R5bGUsIHN0eWxlcyk7XG5cbiAgICAvLyBIYXMgYmFzZSBzdHlsZT9cbiAgICAvLyBPbmx5IHJlbmRlcmFibGUgKGluc3RhbnRpYXRlZCkgc3R5bGVzIHNob3VsZCBiZSBpbmNsdWRlZCBmb3IgcnVuLXRpbWUgdXNlXG4gICAgLy8gT3RoZXJzIGFyZSBpbnRlcm1lZGlhcnkvYWJzdHJhY3QsIHVzZWQgZHVyaW5nIHN0eWxlIGNvbXBvc2l0aW9uIGJ1dCBub3QgZXhlY3V0aW9uXG4gICAgaWYgKHN0eWxlLmJhc2UgJiYgQmFzZVN0eWxlc1tzdHlsZS5iYXNlXSkge1xuICAgICAgICBTdHlsZXNbbmFtZV0gPSBzdHlsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShCYXNlU3R5bGVzW3N0eWxlLmJhc2VdKSwgc3R5bGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbn07XG5cbi8vIENhbGxlZCB0byBjcmVhdGUgYW5kIGluaXRpYWxpemUgc3R5bGVzXG5TdHlsZU1hbmFnZXIuYnVpbGQgPSBmdW5jdGlvbiAoc3R5bGVzLCBzY2VuZSA9IHt9KSB7XG4gICAgLy8gU29ydCBzdHlsZXMgYnkgZGVwZW5kZW5jeSwgdGhlbiBidWlsZCB0aGVtXG4gICAgbGV0IHN0eWxlX2RlcHMgPSBPYmplY3Qua2V5cyhzdHlsZXMpLnNvcnQoXG4gICAgICAgIChhLCBiKSA9PiBTdHlsZU1hbmFnZXIuaW5oZXJpdGFuY2VEZXB0aChhLCBzdHlsZXMpIC0gU3R5bGVNYW5hZ2VyLmluaGVyaXRhbmNlRGVwdGgoYiwgc3R5bGVzKVxuICAgICk7XG5cbiAgICAvLyBPbmx5IGtlZXAgYnVpbHQtaW4gYmFzZSBzdHlsZXNcbiAgICBmb3IgKGxldCBzbmFtZSBpbiBTdHlsZXMpIHtcbiAgICAgICAgaWYgKCFCYXNlU3R5bGVzW3NuYW1lXSkge1xuICAgICAgICAgICAgZGVsZXRlIFN0eWxlc1tzbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBTdHlsZXNbc25hbWVdLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXb3JraW5nIHNldCBvZiBzdHlsZXMgYmVpbmcgYnVpbHRcbiAgICBsZXQgd3MgPSB7fTtcbiAgICBmb3IgKGxldCBzbmFtZSBvZiBzdHlsZV9kZXBzKSB7XG4gICAgICAgIHdzW3NuYW1lXSA9IFN0eWxlTWFuYWdlci5jcmVhdGUoc25hbWUsIHN0eWxlc1tzbmFtZV0sIHdzKTtcbiAgICB9XG5cbiAgICBTdHlsZU1hbmFnZXIuaW5pdFN0eWxlcyhzY2VuZSk7XG4gICAgcmV0dXJuIFN0eWxlcztcbn07XG5cbi8vIEluaXRpYWxpemUgYWxsIHN0eWxlc1xuU3R5bGVNYW5hZ2VyLmluaXRTdHlsZXMgPSBmdW5jdGlvbiAoc2NlbmUpIHtcbiAgICAvLyBJbml0aWFsaXplIGFsbFxuICAgIGZvciAobGV0IHNuYW1lIGluIFN0eWxlcykge1xuICAgICAgICBTdHlsZXNbc25hbWVdLmluaXQoc2NlbmUpO1xuICAgIH1cbn07XG5cbi8vIEdpdmVuIGEgc3R5bGUga2V5IGluIGEgc2V0IG9mIHN0eWxlcyB0byBhZGQsIGNvdW50IHRoZSBsZW5ndGggb2YgdGhlIGluaGVyaXRhbmNlIGNoYWluXG4vLyBUT0RPOiByZW1vdmUgY3VycmVudCAoU3R5bGVzKSBhbmQgZnV0dXJlIChzdHlsZXMpIGR1cGxpY2F0aW9uLCBjb25mdXNpbmdcblN0eWxlTWFuYWdlci5pbmhlcml0YW5jZURlcHRoID0gZnVuY3Rpb24gKGtleSwgc3R5bGVzKSB7XG4gICAgbGV0IHBhcmVudHMgPSAwO1xuXG4gICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICBsZXQgc3R5bGUgPSBzdHlsZXNba2V5XTtcbiAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHNjZW5lIGRlZiBlcnJvciwgdHJ5aW5nIHRvIGV4dGVuZCBhIHN0eWxlIHRoYXQgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXBlbmRlbmN5IGNoYWluIGVuZHMgd2hlbiB0aGlzIHN0eWxlIGlzbid0IG1peGluZyBpbiBhbnkgb3RoZXJzXG4gICAgICAgIGlmICghc3R5bGUubWl4KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYXZlcnNlIG5leHQgcGFyZW50IHN0eWxlXG4gICAgICAgIHBhcmVudHMrKztcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZS5taXgpKSB7XG4gICAgICAgICAgICAvLyBJZiBtdWx0aXBsZSBtaXhpbnMsIGZpbmQgdGhlIGRlZXBlc3Qgb25lXG4gICAgICAgICAgICBwYXJlbnRzICs9IE1hdGgubWF4KC4uLnN0eWxlLm1peC5tYXAocyA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5aW5nIHRvIG1peCBpbnRvIGl0c2VsZiFcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gU3R5bGVNYW5hZ2VyLmluaGVyaXRhbmNlRGVwdGgocywgc3R5bGVzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJ5aW5nIHRvIG1peCBpbnRvIGl0c2VsZiFcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHN0eWxlLm1peCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBzaW5nbGUgbWl4aW4sIGNvbnRpbnVlIGxvb3AgdXAgdGhlIHRyZWVcbiAgICAgICAgICAgIGtleSA9IHN0eWxlLm1peDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyZW50cztcbn07XG5cbi8vIENvbXBpbGUgYWxsIHN0eWxlc1xuU3R5bGVNYW5hZ2VyLmNvbXBpbGUgPSBmdW5jdGlvbiAoa2V5cywgc2NlbmUpIHtcbiAgICBrZXlzID0ga2V5cyB8fCBPYmplY3Qua2V5cyhTdHlsZXMpO1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGxldCBzdHlsZSA9IFN0eWxlc1trZXldO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3R5bGUuY29tcGlsZSgpO1xuICAgICAgICAgICAgbG9nLnRyYWNlKGBTdHlsZU1hbmFnZXIuY29tcGlsZSgpOiBjb21waWxlZCBzdHlsZSAke2tleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgbG9nLmVycm9yKGBTdHlsZU1hbmFnZXIuY29tcGlsZSgpOiBlcnJvciBjb21waWxpbmcgc3R5bGUgJHtrZXl9OmAsIGVycm9yKTtcblxuICAgICAgICAgICAgc2NlbmUudHJpZ2dlcignd2FybmluZycsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3R5bGVzJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRXJyb3IgY29tcGlsaW5nIHN0eWxlICR7a2V5fWAsXG4gICAgICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICAgICAgc2hhZGVyX2Vycm9yczogc3R5bGUucHJvZ3JhbSAmJiBzdHlsZS5wcm9ncmFtLnNoYWRlcl9lcnJvcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9nLmRlYnVnKGBTdHlsZU1hbmFnZXIuY29tcGlsZSgpOiBjb21waWxlZCBhbGwgc3R5bGVzYCk7XG59O1xuXG4vLyBHZXQgYWxsIHN0eWxlcyB3aXRoIG1lc2ggZGF0YSBmb3IgYSBnaXZlbiB0aWxlXG5TdHlsZU1hbmFnZXIuc3R5bGVzRm9yVGlsZSA9IGZ1bmN0aW9uICh0aWxlX2tleSkge1xuICAgIGxldCBzdHlsZXMgPSBbXTtcbiAgICBmb3IgKGxldCBzIGluIFN0eWxlcykge1xuICAgICAgICBpZiAoU3R5bGVzW3NdLmhhc0RhdGFGb3JUaWxlKHRpbGVfa2V5KSkge1xuICAgICAgICAgICAgc3R5bGVzLnB1c2gocyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlcztcbn07XG4iLCJpbXBvcnQgVXRpbHMgZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IEdlbyBmcm9tICcuLi9nZW8nO1xuXG5pbXBvcnQgcGFyc2VDU1NDb2xvciBmcm9tICdjc3Njb2xvcnBhcnNlcic7XG5cbmV4cG9ydCB2YXIgU3R5bGVQYXJzZXIgPSB7fTtcblxuLy8gV3JhcHMgc3R5bGUgZnVuY3Rpb25zIGFuZCBwcm92aWRlcyBhIHNjb3BlIG9mIGNvbW1vbmx5IGFjY2Vzc2libGUgZGF0YTpcbi8vIC0gZmVhdHVyZTogdGhlICdwcm9wZXJ0aWVzJyBvZiB0aGUgZmVhdHVyZSwgZS5nLiBhY2Nlc3NlZCBhcyAnZmVhdHVyZS5uYW1lJ1xuLy8gLSAkem9vbTogdGhlIGN1cnJlbnQgbWFwIHpvb20gbGV2ZWxcbi8vIC0gJGdlb21ldHJ5OiB0aGUgdHlwZSBvZiBnZW9tZXRyeSwgJ3BvaW50JywgJ2xpbmUnLCBvciAncG9seWdvbidcbi8vIC0gJG1ldGVyc19wZXJfcGl4ZWw6IGNvbnZlcnNpb24gZm9yIG1ldGVycy9waXhlbHMgYXQgY3VycmVudCBtYXAgem9vbVxuLy8gLSBwcm9wZXJ0aWVzOiB1c2VyLWRlZmluZWQgcHJvcGVydGllcyBvbiB0aGUgc3R5bGUtcnVsZSBvYmplY3QgaW4gdGhlIHN0eWxlc2hlZXRcblN0eWxlUGFyc2VyLndyYXBGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgdmFyIGYgPSBgZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gY29udGV4dC5mZWF0dXJlLnByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgdmFyICR6b29tID0gY29udGV4dC56b29tO1xuICAgICAgICAgICAgICAgIHZhciAkbGF5ZXIgPSBjb250ZXh0LmxheWVyO1xuICAgICAgICAgICAgICAgIHZhciAkZ2VvbWV0cnkgPSBjb250ZXh0Lmdlb21ldHJ5O1xuICAgICAgICAgICAgICAgIHZhciAkbWV0ZXJzX3Blcl9waXhlbCA9IGNvbnRleHQubWV0ZXJzX3Blcl9waXhlbDtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IGNvbnRleHQucHJvcGVydGllcztcblxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSAoJHtmdW5jfSgpKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IG51bGw7IC8vIGNvbnZlcnQgTmFOcyB0byBudWxsc1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9YDtcbiAgICByZXR1cm4gZjtcbn07XG5cblxuLy8gU3R5bGUgcGFyc2luZ1xuXG5TdHlsZVBhcnNlci56ZXJvUGFpciA9IE9iamVjdC5mcmVlemUoWzAsIDBdKTsgLy8gc2luZ2xlIGFsbG9jYXRpb24gZm9yIHplcm8gdmFsdWVzIHRoYXQgd29uJ3QgYmUgbW9kaWZpZWRcblxuLy8gU3R5bGUgZGVmYXVsdHNcblN0eWxlUGFyc2VyLmRlZmF1bHRzID0ge1xuICAgIGNvbG9yOiBbMSwgMSwgMSwgMV0sXG4gICAgd2lkdGg6IDEsXG4gICAgc2l6ZTogMSxcbiAgICBleHRydWRlOiBmYWxzZSxcbiAgICBoZWlnaHQ6IDIwLFxuICAgIG1pbl9oZWlnaHQ6IDAsXG4gICAgb3JkZXI6IDAsXG4gICAgejogMCxcbiAgICBtYXRlcmlhbDoge1xuICAgICAgICBhbWJpZW50OiAxLFxuICAgICAgICBkaWZmdXNlOiAxXG4gICAgfVxufTtcblxuLy8gU3R5bGUgbWFjcm9zXG5TdHlsZVBhcnNlci5tYWNyb3MgPSB7XG4gICAgLy8gcHNldWRvLXJhbmRvbSBjb2xvciBieSBnZW9tZXRyeSBpZFxuICAgICdTdHlsZS5jb2xvci5wc2V1ZG9SYW5kb21Db2xvcic6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgMC43ICogKHBhcnNlSW50KGZlYXR1cmUuaWQsIDE2KSAvIDEwMCAlIDEpLCAgICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICAwLjcgKiAocGFyc2VJbnQoZmVhdHVyZS5pZCwgMTYpIC8gMTAwMDAgJSAxKSwgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgIDAuNyAqIChwYXJzZUludChmZWF0dXJlLmlkLCAxNikgLyAxMDAwMDAwICUgMSksIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgMVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICAvLyByYW5kb20gY29sb3JcbiAgICAnU3R5bGUuY29sb3IucmFuZG9tQ29sb3InOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFswLjcgKiBNYXRoLnJhbmRvbSgpLCAwLjcgKiBNYXRoLnJhbmRvbSgpLCAwLjcgKiBNYXRoLnJhbmRvbSgpLCAxXTtcbiAgICB9XG59O1xuXG4vLyBBIGNvbnRleHQgb2JqZWN0IHRoYXQgaXMgcGFzc2VkIHRvIHN0eWxlIHBhcnNpbmcgZnVuY3Rpb25zIHRvIHByb3ZpZGUgYSBzY29wZSBvZiBjb21tb25seSB1c2VkIHZhbHVlc1xuU3R5bGVQYXJzZXIuZ2V0RmVhdHVyZVBhcnNlQ29udGV4dCA9IGZ1bmN0aW9uIChmZWF0dXJlLCB0aWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmVhdHVyZSxcbiAgICAgICAgdGlsZSxcbiAgICAgICAgem9vbTogdGlsZS5zdHlsZV96b29tLFxuICAgICAgICBnZW9tZXRyeTogR2VvLmdlb21ldHJ5VHlwZShmZWF0dXJlLmdlb21ldHJ5LnR5cGUpLFxuICAgICAgICBtZXRlcnNfcGVyX3BpeGVsOiB0aWxlLm1ldGVyc19wZXJfcGl4ZWwsXG4gICAgICAgIHVuaXRzX3Blcl9tZXRlcjogdGlsZS51bml0c19wZXJfbWV0ZXJcbiAgICB9O1xufTtcblxuLy8gQnVpbGQgYSBzdHlsZSBwYXJhbSBjYWNoZSBvYmplY3Rcbi8vIGB2YWx1ZWAgaXMgcmF3IHZhbHVlLCBjYWNoZSBtZXRob2RzIHdpbGwgYWRkIG90aGVyIHByb3BlcnRpZXMgYXMgbmVlZGVkXG4vLyBgdHJhbnNmb3JtYCBpcyBvcHRpb25hbCB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gcnVuIG9uIHZhbHVlcyAoZXhjZXB0IGZ1bmN0aW9uIHZhbHVlcylcblN0eWxlUGFyc2VyLmNhY2hlT2JqZWN0ID0gZnVuY3Rpb24gKG9iaiwgdHJhbnNmb3JtID0gbnVsbCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9iai52YWx1ZSkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogb2JqLnZhbHVlLCB6b29tOiAob2JqLnpvb20gPyB7fSA6IG51bGwpIH07IC8vIGNsb25lIGV4aXN0aW5nIGNhY2hlIG9iamVjdFxuICAgIH1cblxuICAgIGxldCBjID0geyB2YWx1ZTogb2JqIH07XG5cbiAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjLnZhbHVlKSAmJiBBcnJheS5pc0FycmF5KGMudmFsdWVbMF0pKSB7IC8vIHpvb20gc3RvcHNcbiAgICAgICAgICAgIGMudmFsdWUgPSBjLnZhbHVlLm1hcCh2ID0+IFt2WzBdLCB0cmFuc2Zvcm0odlsxXSldKTtcbiAgICAgICAgICAgIGMuem9vbSA9IHt9OyAvLyB3aWxsIGhvbGQgdmFsdWVzIGludGVycG9sYXRlZCBieSB6b29tXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGMudmFsdWUgIT09ICdmdW5jdGlvbicpIHsgLy8gZG9uJ3QgdHJhbnNmb3JtIGZ1bmN0aW9uc1xuICAgICAgICAgICAgYy52YWx1ZSA9IHRyYW5zZm9ybShjLnZhbHVlKTsgLy8gc2luZ2xlIHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYztcbn07XG5cbi8vIENvbnZlcnQgb2xkLXN0eWxlIGNvbG9yIG1hY3JvIGludG8gYSBmdW5jdGlvblxuLy8gVE9ETzogZGVwcmVjYXRlIHRoaXMgbWFjcm8gc3ludGF4XG5TdHlsZVBhcnNlci5jb2xvckNhY2hlT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBTdHlsZVBhcnNlci5jYWNoZU9iamVjdChvYmosIHYgPT4ge1xuICAgICAgICBpZiAodiA9PT0gJ1N0eWxlLmNvbG9yLnBzZXVkb1JhbmRvbUNvbG9yJykge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnN0cmluZ1RvRnVuY3Rpb24oU3R5bGVQYXJzZXIud3JhcEZ1bmN0aW9uKFN0eWxlUGFyc2VyLm1hY3Jvc1snU3R5bGUuY29sb3IucHNldWRvUmFuZG9tQ29sb3InXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYgPT09ICdTdHlsZS5jb2xvci5yYW5kb21Db2xvcicpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHlsZVBhcnNlci5tYWNyb3NbJ1N0eWxlLmNvbG9yLnJhbmRvbUNvbG9yJ107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdjtcbiAgICB9KTtcbn07XG5cbi8vIEludGVycG9sYXRpb24gYW5kIGNhY2hpbmcgZm9yIGEgZ2VuZXJpYyBwcm9wZXJ0eSAobm90IGEgY29sb3Igb3IgZGlzdGFuY2UpXG4vLyB7IHZhbHVlOiBvcmlnaW5hbCwgc3RhdGljOiB2YWwsIHpvb206IHsgMTogdmFsMSwgMjogdmFsMiwgLi4uIH0sIGR5bmFtaWM6IGZ1bmN0aW9uKCl7Li4ufSB9XG5TdHlsZVBhcnNlci5jYWNoZVByb3BlcnR5ID0gZnVuY3Rpb24odmFsLCBjb250ZXh0KSB7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsLmR5bmFtaWMpIHsgLy8gZnVuY3Rpb24sIGNvbXB1dGUgZWFjaCB0aW1lIChubyBjYWNoaW5nKVxuICAgICAgICBsZXQgdiA9IHZhbC5keW5hbWljKGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsLnN0YXRpYykgeyAvLyBzaW5nbGUgc3RhdGljIHZhbHVlXG4gICAgICAgIHJldHVybiB2YWwuc3RhdGljO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWwuem9vbSAmJiB2YWwuem9vbVtjb250ZXh0Lnpvb21dKSB7IC8vIGludGVycG9sYXRlZCwgY2FjaGVkXG4gICAgICAgIHJldHVybiB2YWwuem9vbVtjb250ZXh0Lnpvb21dO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gbm90IHlldCBldmF1bGF0ZWQgZm9yIGNhY2hlXG4gICAgICAgIC8vIER5bmFtaWMgZnVuY3Rpb24tYmFzZWRcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbC5keW5hbWljID0gdmFsLnZhbHVlO1xuICAgICAgICAgICAgbGV0IHYgPSB2YWwuZHluYW1pYyhjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IG9mIHpvb20taW50ZXJwb2xhdGVkIHN0b3BzLCBlLmcuIFt6b29tLCB2YWx1ZV0gcGFpcnNcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwudmFsdWUpICYmIEFycmF5LmlzQXJyYXkodmFsLnZhbHVlWzBdKSkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHZhbHVlIGZvciBjdXJyZW50IHpvb21cbiAgICAgICAgICAgIHZhbC56b29tID0gdmFsLnpvb20gfHwge307XG4gICAgICAgICAgICB2YWwuem9vbSA9IHt9O1xuICAgICAgICAgICAgdmFsLnpvb21bY29udGV4dC56b29tXSA9IFV0aWxzLmludGVycG9sYXRlKGNvbnRleHQuem9vbSwgdmFsLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWwuem9vbVtjb250ZXh0Lnpvb21dO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmdsZSBzdGF0aWMgdmFsdWVcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWwuc3RhdGljID0gdmFsLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zdGF0aWM7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5TdHlsZVBhcnNlci5jb252ZXJ0VW5pdHMgPSBmdW5jdGlvbih2YWwsIGNvbnRleHQpIHtcbiAgICAvLyBwcmUtcGFyc2VkIHVuaXRzXG4gICAgaWYgKHZhbC52YWwgIT0gbnVsbCkge1xuICAgICAgICBpZiAodmFsLnVuaXRzID09PSAncHgnKSB7IC8vIGNvbnZlcnQgZnJvbSBwaXhlbHNcbiAgICAgICAgICAgIHJldHVybiB2YWwudmFsICogR2VvLm1ldGVyc1BlclBpeGVsKGNvbnRleHQuem9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbC52YWw7XG4gICAgfVxuICAgIC8vIHVuLXBhcnNlZCB1bml0IHN0cmluZ1xuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB1bml0cyA9IHZhbC5tYXRjaCgvKFswLTkuLV0rKShbYS16XSspLyk7XG4gICAgICAgIGlmICh1bml0cyAmJiB1bml0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQodW5pdHNbMV0pO1xuICAgICAgICAgICAgdW5pdHMgPSB1bml0c1syXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3B4JykgeyAvLyBjb252ZXJ0IGZyb20gcGl4ZWxzXG4gICAgICAgICAgICB2YWwgKj0gR2VvLm1ldGVyc1BlclBpeGVsKGNvbnRleHQuem9vbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbXVsdGlwbGUgdmFsdWVzIG9yIHN0b3BzXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIC8vIEFycmF5IG9mIGFycmF5cywgZS5nLiB6b29tLWludGVycG9sYXRlZCBzdG9wc1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxbMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLm1hcCh2ID0+IFt2WzBdLCBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModlsxXSwgY29udGV4dCldKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheSBvZiB2YWx1ZXNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLm1hcCh2ID0+IFN0eWxlUGFyc2VyLmNvbnZlcnRVbml0cyh2LCBjb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn07XG5cbi8vIFByZS1wYXJzZSB1bml0cyBmcm9tIHN0cmluZyB2YWx1ZXNcblN0eWxlUGFyc2VyLmNhY2hlVW5pdHMgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIG9iaiA9IHsgdmFsOiBwYXJzZUZsb2F0KHZhbCkgfTtcbiAgICBpZiAob2JqLnZhbCAhPT0gMCAmJiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiB2YWwudHJpbSgpLnNsaWNlKC0yKSA9PT0gJ3B4Jykge1xuICAgICAgICBvYmoudW5pdHMgPSAncHgnO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufTtcblxuLy8gVGFrZXMgYSBkaXN0YW5jZSBjYWNoZSBvYmplY3QgYW5kIHJldHVybnMgYSBkaXN0YW5jZSB2YWx1ZSBmb3IgdGhpcyB6b29tXG4vLyAoY2FjaGluZyB0aGUgcmVzdWx0IGZvciBmdXR1cmUgdXNlKVxuLy8geyB2YWx1ZTogb3JpZ2luYWwsIHpvb206IHsgejogbWV0ZXJzIH0sIGR5bmFtaWM6IGZ1bmN0aW9uKCl7Li4ufSB9XG5TdHlsZVBhcnNlci5jYWNoZURpc3RhbmNlID0gZnVuY3Rpb24odmFsLCBjb250ZXh0KSB7XG4gICAgaWYgKHZhbC5keW5hbWljKSB7XG4gICAgICAgIGxldCB2ID0gdmFsLmR5bmFtaWMoY29udGV4dCk7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWwuem9vbSAmJiB2YWwuem9vbVtjb250ZXh0Lnpvb21dKSB7XG4gICAgICAgIHJldHVybiB2YWwuem9vbVtjb250ZXh0Lnpvb21dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gRHluYW1pYyBmdW5jdGlvbi1iYXNlZFxuICAgICAgICBpZiAodHlwZW9mIHZhbC52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsLmR5bmFtaWMgPSB2YWwudmFsdWU7XG4gICAgICAgICAgICBsZXQgdiA9IHZhbC5keW5hbWljKGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXkgb2Ygem9vbS1pbnRlcnBvbGF0ZWQgc3RvcHMsIGUuZy4gW3pvb20sIHZhbHVlXSBwYWlyc1xuICAgICAgICBlbHNlIGlmICh2YWwuem9vbSkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHZhbHVlIGZvciBjdXJyZW50IHpvb21cbiAgICAgICAgICAgIC8vIERvIGZpbmFsIHVuaXQgY29udmVyc2lvbiBhcyBsYXRlIGFzIHBvc3NpYmxlLCB3aGVuIGludGVycG9sYXRpb24gdmFsdWVzIGhhdmUgYmVlbiBkZXRlcm1pbmVkXG4gICAgICAgICAgICB2YWwuem9vbVtjb250ZXh0Lnpvb21dID0gVXRpbHMuaW50ZXJwb2xhdGUoY29udGV4dC56b29tLCB2YWwudmFsdWUsXG4gICAgICAgICAgICAgICAgdiA9PiBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModiwgY29udGV4dCkpO1xuXG4gICAgICAgICAgICByZXR1cm4gdmFsLnpvb21bY29udGV4dC56b29tXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModmFsLnZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIENhY2hlIHByZXZpb3VzbHkgcGFyc2VkIGNvbG9yIHN0cmluZ3NcblN0eWxlUGFyc2VyLnN0cmluZ19jb2xvcnMgPSB7fTtcblN0eWxlUGFyc2VyLmNvbG9yRm9yU3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgLy8gQ2FjaGVkXG4gICAgaWYgKFN0eWxlUGFyc2VyLnN0cmluZ19jb2xvcnNbc3RyaW5nXSkge1xuICAgICAgICByZXR1cm4gU3R5bGVQYXJzZXIuc3RyaW5nX2NvbG9yc1tzdHJpbmddO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBhbmQgY2FjaGVcbiAgICBsZXQgY29sb3IgPSBwYXJzZUNTU0NvbG9yLnBhcnNlQ1NTQ29sb3Ioc3RyaW5nKTtcbiAgICBpZiAoY29sb3IgJiYgY29sb3IubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIGNvbG9yWzBdIC89IDI1NTtcbiAgICAgICAgY29sb3JbMV0gLz0gMjU1O1xuICAgICAgICBjb2xvclsyXSAvPSAyNTU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb2xvciA9IFN0eWxlUGFyc2VyLmRlZmF1bHRzLmNvbG9yO1xuICAgIH1cbiAgICBTdHlsZVBhcnNlci5zdHJpbmdfY29sb3JzW3N0cmluZ10gPSBjb2xvcjtcbiAgICByZXR1cm4gY29sb3I7XG59O1xuXG4vLyBUYWtlcyBhIGNvbG9yIGNhY2hlIG9iamVjdCBhbmQgcmV0dXJucyBhIGNvbG9yIHZhbHVlIGZvciB0aGlzIHpvb21cbi8vIChjYWNoaW5nIHRoZSByZXN1bHQgZm9yIGZ1dHVyZSB1c2UpXG4vLyB7IHZhbHVlOiBvcmlnaW5hbCwgc3RhdGljOiBbcixnLGIsYV0sIHpvb206IHsgejogW3IsZyxiLGFdIH0sIGR5bmFtaWM6IGZ1bmN0aW9uKCl7Li4ufSB9XG5TdHlsZVBhcnNlci5jYWNoZUNvbG9yID0gZnVuY3Rpb24odmFsLCBjb250ZXh0ID0ge30pIHtcbiAgICBpZiAodmFsLmR5bmFtaWMpIHtcbiAgICAgICAgbGV0IHYgPSB2YWwuZHluYW1pYyhjb250ZXh0KTtcblxuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2ID0gU3R5bGVQYXJzZXIuY29sb3JGb3JTdHJpbmcodik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodiAmJiB2WzNdID09IG51bGwpIHtcbiAgICAgICAgICAgIHZbM10gPSAxOyAvLyBkZWZhdWx0IGFscGhhXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbC5zdGF0aWMpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5zdGF0aWM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbC56b29tICYmIHZhbC56b29tW2NvbnRleHQuem9vbV0pIHtcbiAgICAgICAgcmV0dXJuIHZhbC56b29tW2NvbnRleHQuem9vbV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBEeW5hbWljIGZ1bmN0aW9uLWJhc2VkIGNvbG9yXG4gICAgICAgIGlmICh0eXBlb2YgdmFsLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWwuZHluYW1pYyA9IHZhbC52YWx1ZTtcbiAgICAgICAgICAgIGxldCB2ID0gdmFsLmR5bmFtaWMoY29udGV4dCk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2ID0gU3R5bGVQYXJzZXIuY29sb3JGb3JTdHJpbmcodik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2ICYmIHZbM10gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZbM10gPSAxOyAvLyBkZWZhdWx0IGFscGhhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5nbGUgc3RyaW5nIGNvbG9yXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWwuc3RhdGljID0gU3R5bGVQYXJzZXIuY29sb3JGb3JTdHJpbmcodmFsLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWwuc3RhdGljO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IG9mIHpvb20taW50ZXJwb2xhdGVkIHN0b3BzLCBlLmcuIFt6b29tLCBjb2xvcl0gcGFpcnNcbiAgICAgICAgZWxzZSBpZiAodmFsLnpvb20pIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGFueSBzdHJpbmcgY29sb3JzIGluc2lkZSBzdG9wcywgdGhlIGZpcnN0IHRpbWUgd2UgZW5jb3VudGVyIHRoaXMgcHJvcGVydHlcbiAgICAgICAgICAgIGlmICghdmFsLnpvb21fcHJlcHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgdmFsLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2ID0gdmFsLnZhbHVlW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAmJiB0eXBlb2YgdlsxXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZbMV0gPSBTdHlsZVBhcnNlci5jb2xvckZvclN0cmluZyh2WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWwuem9vbV9wcmVwcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgY29sb3IgZm9yIGN1cnJlbnQgem9vbVxuICAgICAgICAgICAgdmFsLnpvb21bY29udGV4dC56b29tXSA9IFV0aWxzLmludGVycG9sYXRlKGNvbnRleHQuem9vbSwgdmFsLnZhbHVlKTtcbiAgICAgICAgICAgIHZhbC56b29tW2NvbnRleHQuem9vbV1bM10gPSB2YWwuem9vbVtjb250ZXh0Lnpvb21dWzNdIHx8IDE7IC8vIGRlZmF1bHQgYWxwaGFcbiAgICAgICAgICAgIHJldHVybiB2YWwuem9vbVtjb250ZXh0Lnpvb21dO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmdsZSBhcnJheSBjb2xvclxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbC5zdGF0aWMgPSB2YWwudmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsLnN0YXRpYyAmJiB2YWwuc3RhdGljWzNdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YWwuc3RhdGljWzNdID0gMTsgLy8gZGVmYXVsdCBhbHBoYVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbC5zdGF0aWM7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5TdHlsZVBhcnNlci5wYXJzZUNvbG9yID0gZnVuY3Rpb24odmFsLCBjb250ZXh0ID0ge30pIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWwgPSB2YWwoY29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgQ1NTLXN0eWxlIGNvbG9yc1xuICAgIC8vIFRPRE86IGNoYW5nZSBhbGwgY29sb3JzIHRvIHVzZSAwLTI1NSByYW5nZSBpbnRlcm5hbGx5IHRvIGF2b2lkIGRpdmlkaW5nIGFuZCB0aGVuIHJlLW11bHRpcGx5aW5nIGluIGdlb20gYnVpbGRlclxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWwgPSBTdHlsZVBhcnNlci5jb2xvckZvclN0cmluZyh2YWwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkgJiYgQXJyYXkuaXNBcnJheSh2YWxbMF0pKSB7XG4gICAgICAgIC8vIEFycmF5IG9mIHpvb20taW50ZXJwb2xhdGVkIHN0b3BzLCBlLmcuIFt6b29tLCBjb2xvcl0gcGFpcnNcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdiA9IHZhbFtpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdlsxXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2WzFdID0gU3R5bGVQYXJzZXIuY29sb3JGb3JTdHJpbmcodlsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC56b29tKSB7XG4gICAgICAgICAgICB2YWwgPSBVdGlscy5pbnRlcnBvbGF0ZShjb250ZXh0Lnpvb20sIHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0c1xuICAgIGlmICh2YWwpIHtcbiAgICAgICAgLy8gYWxwaGFcbiAgICAgICAgaWYgKHZhbFszXSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWxbM10gPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWwgPSBbMCwgMCwgMCwgMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbn07XG5cblN0eWxlUGFyc2VyLmNhbGN1bGF0ZU9yZGVyID0gZnVuY3Rpb24ob3JkZXIsIGNvbnRleHQpIHtcbiAgICAvLyBDb21wdXRlZCBvcmRlclxuICAgIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3JkZXIgPSBvcmRlcihjb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9yZGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBPcmRlciB0aWVkIHRvIGZlYXR1cmUgcHJvcGVydHlcbiAgICAgICAgaWYgKGNvbnRleHQuZmVhdHVyZS5wcm9wZXJ0aWVzW29yZGVyXSkge1xuICAgICAgICAgICAgb3JkZXIgPSBjb250ZXh0LmZlYXR1cmUucHJvcGVydGllc1tvcmRlcl07XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhwbGljaXQgb3JkZXIgdmFsdWVcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcmRlciA9IHBhcnNlRmxvYXQob3JkZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yZGVyO1xufTtcblxuLy8gRXZhbHVhdGUgYSBmdW5jdGlvbi1iYXNlZCBwcm9wZXJ0eSwgb3IgcGFzcy10aHJvdWdoIHN0YXRpYyB2YWx1ZVxuU3R5bGVQYXJzZXIuZXZhbFByb3AgPSBmdW5jdGlvbihwcm9wLCBjb250ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBwcm9wKGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcDtcbn07XG4iLCJpbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IEJ1aWxkZXJzIGZyb20gJy4uL2J1aWxkZXJzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FudmFzVGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7IC8vIHJlbmRlciB0ZXh0IG9uIHRyYW5zcGFyZW50IGJhY2tncm91bmRcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9XG5cbiAgICByZXNpemUgKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIC8vIFNldCBmb250IHN0eWxlIHBhcmFtcyBmb3IgY2FudmFzIGRyYXdpbmdcbiAgICBzZXRGb250ICh0aWxlLCB7IGZvbnRfY3NzLCBmaWxsLCBzdHJva2UsIHN0cm9rZV93aWR0aCwgcHhfc2l6ZSB9KSB7XG4gICAgICAgIHRoaXMucHhfc2l6ZSA9IHB4X3NpemU7XG4gICAgICAgIHRoaXMudGV4dF9idWZmZXIgPSA4OyAvLyBwaXhlbCBwYWRkaW5nIGFyb3VuZCB0ZXh0XG4gICAgICAgIGxldCBjdHggPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgICAgY3R4LmZvbnQgPSBmb250X2NzcztcbiAgICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlO1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0cm9rZV93aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG51bGw7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbDtcbiAgICAgICAgY3R4Lm1pdGVyTGltaXQgPSAyO1xuICAgIH1cblxuICAgIHRleHRTaXplcyAodGlsZSwgdGV4dHMpIHtcbiAgICAgICAgZm9yIChsZXQgc3R5bGUgaW4gdGV4dHMpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0X2luZm9zID0gdGV4dHNbc3R5bGVdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB0ZXh0IGluIHRleHRfaW5mb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dF9zZXR0aW5ncyA9IHRleHRfaW5mb3NbdGV4dF0udGV4dF9zZXR0aW5ncztcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGV4dCBzaXplc1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Rm9udCh0aWxlLCB0ZXh0X3NldHRpbmdzKTsgLy8gVE9ETzogb25seSBzZXQgb25jZSBhYm92ZVxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAgICAgIHRleHRfaW5mb3NbdGV4dF0sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dFNpemUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRfc2V0dGluZ3MudHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dF9zZXR0aW5ncy50ZXh0X3dyYXBcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dHM7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZXMgd2lkdGggYW5kIGhlaWdodCBvZiB0ZXh0IGJhc2VkIG9uIGN1cnJlbnQgZm9udCBzdHlsZVxuICAgIC8vIEluY2x1ZGVzIHdvcmQgd3JhcHBpbmcsIHJldHVybnMgc2l6ZSBpbmZvIGZvciB3aG9sZSB0ZXh0IGJsb2NrIGFuZCBpbmRpdmlkdWFsIGxpbmVzXG4gICAgdGV4dFNpemUgKHRleHQsIHRpbGUsIHRyYW5zZm9ybSwgdGV4dF93cmFwKSB7XG4gICAgICAgIGxldCBzdHIgPSB0aGlzLmFwcGx5VGV4dFRyYW5zZm9ybSh0ZXh0LCB0cmFuc2Zvcm0pO1xuICAgICAgICBsZXQgY3R4ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgYnVmZmVyID0gdGhpcy50ZXh0X2J1ZmZlciAqIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbztcbiAgICAgICAgbGV0IGxlYWRpbmcgPSAyICogVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvOyAvLyBtYWtlIGNvbmZpZ3VyYWJsZSBhbmQvb3IgdXNlIENhbnZhcyBUZXh0TWV0cmljcyB3aGVuIGF2YWlsYWJsZVxuICAgICAgICBsZXQgbGluZV9oZWlnaHQgPSB0aGlzLnB4X3NpemUgKyBsZWFkaW5nOyAvLyBweF9zaXplIGFscmVhZHkgaW4gZGV2aWNlIHBpeGVsc1xuXG4gICAgICAgIC8vIFdvcmQgd3JhcHBpbmdcbiAgICAgICAgLy8gTGluZSBicmVha3MgY2FuIGJlIGNhdXNlZCBieTpcbiAgICAgICAgLy8gIC0gaW1wbGljaXQgbGluZSBicmVhayB3aGVuIGEgbWF4aW11bSBjaGFyYWN0ZXIgdGhyZXNob2xkIGlzIGV4Y2VlZGVkIHBlciBsaW5lICh0ZXh0X3dyYXApXG4gICAgICAgIC8vICAtIGV4cGxpY2l0IGxpbmUgYnJlYWsgaW4gdGhlIGxhYmVsIHRleHQgKFxcbilcbiAgICAgICAgbGV0IHdvcmRzO1xuICAgICAgICBpZiAodHlwZW9mIHRleHRfd3JhcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHdvcmRzID0gc3RyLnNwbGl0KCcgJyk7IC8vIHNwbGl0IHdvcmRzIG9uIHNwYWNlc1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd29yZHMgPSBbc3RyXTsgLy8gbm8gbWF4IGxpbmUgd29yZCB3cmFwcGluZyAoYnV0IG5ldyBsaW5lcyB3aWxsIHN0aWxsIGJlIGluIGVmZmVjdClcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3X2xpbmVfdGVtcGxhdGUgPSB7IHdpZHRoOiAwLCBjaGFyczogMCwgdGV4dDogJycgfTtcbiAgICAgICAgbGV0IGxpbmUgPSBPYmplY3QuYXNzaWduKHt9LCBuZXdfbGluZV90ZW1wbGF0ZSk7IC8vIGN1cnJlbnQgbGluZVxuICAgICAgICBsZXQgbGluZXMgPSBbXTsgLy8gY29tcGxldGVkIGxpbmVzXG4gICAgICAgIGxldCBtYXhfd2lkdGggPSAwOyAvLyBtYXggd2lkdGggdG8gZml0IGFsbCBsaW5lc1xuXG4gICAgICAgIC8vIGFkZCBjdXJyZW50IGxpbmUgYnVmZmVyIHRvIGNvbXBsZXRlZCBsaW5lcywgb3B0aW9uYWxseSBzdGFydCBuZXcgbGluZVxuICAgICAgICBmdW5jdGlvbiBhZGRMaW5lIChuZXdfbGluZSkge1xuICAgICAgICAgICAgbGluZS50ZXh0ID0gbGluZS50ZXh0LnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChsaW5lLnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxpbmUud2lkdGggPSBjdHgubWVhc3VyZVRleHQobGluZS50ZXh0KS53aWR0aDtcbiAgICAgICAgICAgICAgICBtYXhfd2lkdGggPSBNYXRoLm1heChtYXhfd2lkdGgsIE1hdGguY2VpbChsaW5lLndpZHRoKSk7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdfbGluZSkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBPYmplY3QuYXNzaWduKHt9LCBuZXdfbGluZV90ZW1wbGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJzdCBpdGVyYXRlIG9uIHNwYWNlLWJyZWFrIGdyb3VwcyAod2lsbCBiZSBvbmUgaWYgbWF4IGxpbmUgbGVuZ3RoIG9mZiksIHRoZW4gaXRlcmF0ZSBvbiBsaW5lLWJyZWFrIGdyb3Vwc1xuICAgICAgICBmb3IgKGxldCB3PTA7IHcgPCB3b3Jkcy5sZW5ndGg7IHcrKykge1xuICAgICAgICAgICAgbGV0IGJyZWFrcyA9IHdvcmRzW3ddLnNwbGl0KCdcXG4nKTsgLy8gc3BsaXQgb24gbGluZSBicmVha3NcblxuICAgICAgICAgICAgZm9yIChsZXQgbj0wOyBuIDwgYnJlYWtzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdvcmQgPSBicmVha3Nbbl07XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBhZGRpbmcgY3VycmVudCB3b3JkIHdvdWxkIG92ZXJmbG93LCBhZGQgYSBuZXcgbGluZSBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuY2hhcnMgKyB3b3JkLmxlbmd0aCA+IHRleHRfd3JhcCAmJiBsaW5lLmNoYXJzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRMaW5lKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFkZCBjdXJyZW50IHdvcmQgKHBsdXMgc3BhY2UpXG4gICAgICAgICAgICAgICAgbGluZS5jaGFycyArPSB3b3JkLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgbGluZS50ZXh0ICs9IHdvcmQgKyAnICc7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBsaW5lIGJyZWFrcyBwcmVzZW50LCBhZGQgbmV3IGxpbmUgKHVubGVzcyBvbiBsYXN0IGxpbmUpXG4gICAgICAgICAgICAgICAgaWYgKGJyZWFrcy5sZW5ndGggPiAxICYmIG4gPCBicmVha3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRMaW5lKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGRMaW5lKGZhbHNlKTtcblxuICAgICAgICAvLyBGaW5hbCBkaW1lbnNpb25zIG9mIHRleHRcbiAgICAgICAgbGV0IGhlaWdodCA9IGxpbmVzLmxlbmd0aCAqIGxpbmVfaGVpZ2h0O1xuXG4gICAgICAgIGxldCBjb2xsaXNpb25fc2l6ZSA9IFtcbiAgICAgICAgICAgIG1heF93aWR0aCAvIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbyxcbiAgICAgICAgICAgIGhlaWdodCAvIFV0aWxzLmRldmljZV9waXhlbF9yYXRpb1xuICAgICAgICBdO1xuXG4gICAgICAgIGxldCB0ZXh0dXJlX3NpemUgPSBbXG4gICAgICAgICAgICBtYXhfd2lkdGggKyBidWZmZXIgKiAyLFxuICAgICAgICAgICAgaGVpZ2h0ICsgYnVmZmVyICogMlxuICAgICAgICBdO1xuXG4gICAgICAgIGxldCBsb2dpY2FsX3NpemUgPSB0ZXh0dXJlX3NpemUubWFwKHYgPT4gdiAvIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbyk7XG5cbiAgICAgICAgLy8gUmV0dXJucyBsaW5lcyAody9wZXItbGluZSBpbmZvIGZvciBkcmF3aW5nKSBhbmQgdGV4dCdzIG92ZXJhbGwgYm91bmRpbmcgYm94ICsgY2FudmFzIHNpemVcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmVzLFxuICAgICAgICAgICAgc2l6ZTogeyBjb2xsaXNpb25fc2l6ZSwgdGV4dHVyZV9zaXplLCBsb2dpY2FsX3NpemUsIGxpbmVfaGVpZ2h0IH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBEcmF3IG9uZSBvciBtb3JlIGxpbmVzIG9mIHRleHQgYXQgc3BlY2lmaWVkIGxvY2F0aW9uLCBhZGp1c3RpbmcgZm9yIGJ1ZmZlciBhbmQgYmFzZWxpbmVcbiAgICBkcmF3VGV4dCAobGluZXMsIFt4LCB5XSwgc2l6ZSwgdGlsZSwgeyBzdHJva2UsIHRyYW5zZm9ybSwgYWxpZ24gfSkge1xuICAgICAgICBhbGlnbiA9IGFsaWduIHx8ICdjZW50ZXInO1xuXG4gICAgICAgIGZvciAobGV0IGxpbmVfbnVtPTA7IGxpbmVfbnVtIDwgbGluZXMubGVuZ3RoOyBsaW5lX251bSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IGxpbmVzW2xpbmVfbnVtXTtcbiAgICAgICAgICAgIGxldCBzdHIgPSB0aGlzLmFwcGx5VGV4dFRyYW5zZm9ybShsaW5lLnRleHQsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICBsZXQgYnVmZmVyID0gdGhpcy50ZXh0X2J1ZmZlciAqIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbztcbiAgICAgICAgICAgIGxldCB0ZXh0dXJlX3NpemUgPSBzaXplLnRleHR1cmVfc2l6ZTtcbiAgICAgICAgICAgIGxldCBsaW5lX2hlaWdodCA9IHNpemUubGluZV9oZWlnaHQ7XG5cbiAgICAgICAgICAgIC8vIFRleHQgYWxpZ25tZW50XG4gICAgICAgICAgICBsZXQgdHg7XG4gICAgICAgICAgICBpZiAoYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgIHR4ID0geCArIGJ1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIHR4ID0geCArIHRleHR1cmVfc2l6ZVswXS8yIC0gbGluZS53aWR0aC8yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICB0eCA9IHggKyB0ZXh0dXJlX3NpemVbMF0gLSBsaW5lLndpZHRoIC0gYnVmZmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbiB0aGUgYWJzZW5jZSBvZiBiZXR0ZXIgQ2FudmFzIFRleHRNZXRyaWNzIChub3Qgc3VwcG9ydGVkIGJ5IGJyb3dzZXJzIHlldCksXG4gICAgICAgICAgICAvLyAwLjc1IGJ1ZmZlciBwcm9kdWNlcyBhIGJldHRlciBhcHByb3hpbWF0ZSB2ZXJ0aWNhbCBjZW50ZXJpbmcgb2YgdGV4dFxuICAgICAgICAgICAgbGV0IHR5ID0geSArIGJ1ZmZlciAqIDAuNzUgKyAobGluZV9udW0gKyAxKSAqIGxpbmVfaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZVRleHQoc3RyLCB0eCwgdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxUZXh0KHN0ciwgdHgsIHR5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJhc3Rlcml6ZSAodGlsZSwgdGV4dHMsIHRleHR1cmVfc2l6ZSkge1xuICAgICAgICBmb3IgKGxldCBzdHlsZSBpbiB0ZXh0cykge1xuICAgICAgICAgICAgbGV0IHRleHRfaW5mb3MgPSB0ZXh0c1tzdHlsZV07XG5cbiAgICAgICAgICAgIGZvciAobGV0IHRleHQgaW4gdGV4dF9pbmZvcykge1xuICAgICAgICAgICAgICAgIGxldCBpbmZvID0gdGV4dF9pbmZvc1t0ZXh0XTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Rm9udCh0aWxlLCBpbmZvLnRleHRfc2V0dGluZ3MpOyAvLyBUT0RPOiBvbmx5IHNldCBvbmNlIGFib3ZlXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3VGV4dChpbmZvLmxpbmVzLCBpbmZvLnBvc2l0aW9uLCBpbmZvLnNpemUsIHRpbGUsIHtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBpbmZvLnRleHRfc2V0dGluZ3Muc3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGluZm8udGV4dF9zZXR0aW5ncy50cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgICAgIGFsaWduOiBpbmZvLnRleHRfc2V0dGluZ3MuYWxpZ25cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGluZm8udGV4Y29vcmRzID0gQnVpbGRlcnMuZ2V0VGV4Y29vcmRzRm9yU3ByaXRlKFxuICAgICAgICAgICAgICAgICAgICBpbmZvLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBpbmZvLnNpemUudGV4dHVyZV9zaXplLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlX3NpemVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGxhY2UgdGV4dCBsYWJlbHMgd2l0aGluIGFuIGF0bGFzIG9mIHRoZSBnaXZlbiBtYXggc2l6ZVxuICAgIHNldFRleHR1cmVUZXh0UG9zaXRpb25zICh0ZXh0cywgbWF4X3RleHR1cmVfc2l6ZSkge1xuICAgICAgICAvLyBGaW5kIHdpZGVzdCBsYWJlbFxuICAgICAgICBsZXQgd2lkZXN0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgc3R5bGUgaW4gdGV4dHMpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0X2luZm9zID0gdGV4dHNbc3R5bGVdO1xuICAgICAgICAgICAgZm9yIChsZXQgdGV4dCBpbiB0ZXh0X2luZm9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSB0ZXh0X2luZm9zW3RleHRdLnNpemUudGV4dHVyZV9zaXplO1xuICAgICAgICAgICAgICAgIGlmIChzaXplWzBdID4gd2lkZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZGVzdCA9IHNpemVbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGF5b3V0IGxhYmVscywgc3RhY2tlZCBpbiBjb2x1bW5zXG4gICAgICAgIGxldCBjeCA9IDAsIGN5ID0gMDsgLy8gY3VycmVudCB4L3kgcG9zaXRpb24gaW4gYXRsYXNcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7ICAgICAvLyBvdmVyYWxsIGF0bGFzIGhlaWdodFxuICAgICAgICBmb3IgKGxldCBzdHlsZSBpbiB0ZXh0cykge1xuICAgICAgICAgICAgbGV0IHRleHRfaW5mb3MgPSB0ZXh0c1tzdHlsZV07XG4gICAgICAgICAgICBmb3IgKGxldCB0ZXh0IGluIHRleHRfaW5mb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dF9pbmZvID0gdGV4dF9pbmZvc1t0ZXh0XTtcbiAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHRleHRfaW5mby5zaXplLnRleHR1cmVfc2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAoY3kgKyBzaXplWzFdIDwgbWF4X3RleHR1cmVfc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0X2luZm8ucG9zaXRpb24gPSBbY3gsIGN5XTsgLy8gYWRkIGxhYmVsIHRvIGN1cnJlbnQgY29sdW1uXG4gICAgICAgICAgICAgICAgICAgIGN5ICs9IHNpemVbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjeSA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gY3k7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIHN0YXJ0IG5ldyBjb2x1bW4gaWYgdGFsbGVyIHRoYW4gdGV4dHVyZVxuICAgICAgICAgICAgICAgICAgICBjeCArPSB3aWRlc3Q7XG4gICAgICAgICAgICAgICAgICAgIGN5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGV4dF9pbmZvLnBvc2l0aW9uID0gW2N4LCBjeV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtjeCArIHdpZGVzdCwgaGVpZ2h0XTsgLy8gb3ZlcmFsbCBhdGxhcyBzaXplXG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIGJlZm9yZSByYXN0ZXJpemF0aW9uXG4gICAgYXBwbHlUZXh0VHJhbnNmb3JtICh0ZXh0LCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSA9PT0gJ2NhcGl0YWxpemUnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXHdcXFMqL2csIGZ1bmN0aW9uICh0eHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHh0LnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJhbnNmb3JtID09PSAndXBwZXJjYXNlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmFuc2Zvcm0gPT09ICdsb3dlcmNhc2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgZm9udCBDU1Mtc3R5bGUgc2l6ZSAoJzEycHgnLCAnMTRwdCcsICcxLjVlbScsIGV0Yy4pIHRvIHBpeGVsIHNpemUgKGFkanVzdGVkIGZvciBkZXZpY2UgcGl4ZWwgcmF0aW8pXG4gICAgLy8gRGVmYXVsdHMgdW5pdHMgdG8gcGl4ZWxzIGlmIG5vdCBzcGVjaWZpZWRcbiAgICBzdGF0aWMgZm9udFBpeGVsU2l6ZSAoc2l6ZSkge1xuICAgICAgICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2l6ZSA9ICh0eXBlb2Ygc2l6ZSA9PT0gJ3N0cmluZycpID8gc2l6ZSA6IFN0cmluZyhzaXplKTsgLy8gbmVlZCBhIHN0cmluZyBmb3IgcmVnZXhcblxuICAgICAgICBsZXQgWywgcHhfc2l6ZSwgdW5pdHNdID0gc2l6ZS5tYXRjaChDYW52YXNUZXh0LmZvbnRfc2l6ZV9yZSkgfHwgW107XG4gICAgICAgIHVuaXRzID0gdW5pdHMgfHwgJ3B4JztcblxuICAgICAgICBpZiAodW5pdHMgPT09IFwiZW1cIikge1xuICAgICAgICAgICAgcHhfc2l6ZSAqPSAxNjtcbiAgICAgICAgfSBlbHNlIGlmICh1bml0cyA9PT0gXCJwdFwiKSB7XG4gICAgICAgICAgICBweF9zaXplIC89IDAuNzU7XG4gICAgICAgIH0gZWxzZSBpZiAodW5pdHMgPT09IFwiJVwiKSB7XG4gICAgICAgICAgICBweF9zaXplIC89IDYuMjU7XG4gICAgICAgIH1cblxuICAgICAgICBweF9zaXplID0gcGFyc2VGbG9hdChweF9zaXplKTtcbiAgICAgICAgcHhfc2l6ZSAqPSBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW87XG4gICAgICAgIHJldHVybiBweF9zaXplO1xuICAgIH1cblxufVxuXG4vLyBFeHRyYWN0IGZvbnQgc2l6ZSBhbmQgdW5pdHNcbkNhbnZhc1RleHQuZm9udF9zaXplX3JlID0gLygoPzpbMC05XSpcXC4pP1swLTldKylcXHMqKHB4fHB0fGVtfCUpPy87XG4iLCIvLyBUZXh0IHJlbmRlcmluZyBzdHlsZVxuXG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuLi8uLi9nbC90ZXh0dXJlJztcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi4vLi4vdXRpbHMvd29ya2VyX2Jyb2tlcic7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IEdlbyBmcm9tICcuLi8uLi9nZW8nO1xuaW1wb3J0IHtTdHlsZX0gZnJvbSAnLi4vc3R5bGUnO1xuaW1wb3J0IHtQb2ludHN9IGZyb20gJy4uL3BvaW50cy9wb2ludHMnO1xuaW1wb3J0IENhbnZhc1RleHQgZnJvbSAnLi9jYW52YXNfdGV4dCc7XG5pbXBvcnQgQ29sbGlzaW9uIGZyb20gJy4uLy4uL2xhYmVscy9jb2xsaXNpb24nO1xuaW1wb3J0IExhYmVsUG9pbnQgZnJvbSAnLi4vLi4vbGFiZWxzL2xhYmVsX3BvaW50JztcbmltcG9ydCBMYWJlbExpbmUgZnJvbSAnLi4vLi4vbGFiZWxzL2xhYmVsX2xpbmUnO1xuaW1wb3J0IFRleHRTZXR0aW5ncyBmcm9tICcuL3RleHRfc2V0dGluZ3MnO1xuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi4vc3R5bGVfcGFyc2VyJztcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCBsZXQgVGV4dFN0eWxlID0gT2JqZWN0LmNyZWF0ZShQb2ludHMpO1xuXG5PYmplY3QuYXNzaWduKFRleHRTdHlsZSwge1xuICAgIG5hbWU6ICd0ZXh0JyxcbiAgICBzdXBlcjogUG9pbnRzLFxuICAgIGJ1aWx0X2luOiB0cnVlLFxuICAgIHNlbGVjdGlvbjogZmFsc2UsIC8vIG5vIGZlYXR1cmUgc2VsZWN0aW9uIGZvciB0ZXh0IGJ5IGRlZmF1bHRcblxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMuc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIFByb3ZpZGUgYSBob29rIGZvciB0aGlzIG9iamVjdCB0byBiZSBjYWxsZWQgZnJvbSB3b3JrZXIgdGhyZWFkc1xuICAgICAgICB0aGlzLm1haW5fdGhyZWFkX3RhcmdldCA9ICdUZXh0U3R5bGUtJyArIHRoaXMubmFtZTtcbiAgICAgICAgaWYgKFV0aWxzLmlzTWFpblRocmVhZCkge1xuICAgICAgICAgICAgV29ya2VyQnJva2VyLmFkZFRhcmdldCh0aGlzLm1haW5fdGhyZWFkX3RhcmdldCwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQb2ludCBzdHlsZSAocGFyZW50IGNsYXNzKSByZXF1aXJlcyB0ZXh0dXJpbmcgdG8gYmUgdHVybmVkIG9uXG4gICAgICAgIC8vIChsYWJlbHMgYXJlIGFsd2F5cyBkcmF3biB3aXRoIHRleHR1cmVzKVxuICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9QT0lOVF9URVhUVVJFID0gdHJ1ZTtcblxuICAgICAgICAvLyBNYW51YWxseSB1bi1tdWx0aXBseSBhbHBoYSwgYmVjYXVzZSBDYW52YXMgdGV4dCByYXN0ZXJpemF0aW9uIGlzIHByZS1tdWx0aXBsaWVkXG4gICAgICAgIHRoaXMuZGVmaW5lcy5UQU5HUkFNX1VOTVVMVElQTFlfQUxQSEEgPSB0cnVlO1xuXG4gICAgICAgIC8vIEZhZGUgb3V0IHRleHQgd2hlbiB0aWxlIGlzIHpvb21pbmcgb3V0LCBlLmcuIGFjdGluZyBhcyBwcm94eSB0aWxlc1xuICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9GQURFX09OX1pPT01fT1VUID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fRkFERV9PTl9aT09NX09VVF9SQVRFID0gMjsgLy8gZmFkZSBhdCAyeCwgZS5nLiBmdWxseSB0cmFuc3BhcmVudCBhdCAwLjUgem9vbSBsZXZlbCBhd2F5XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0sXG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zdXBlci5yZXNldC5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAoVXRpbHMuaXNNYWluVGhyZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IG5ldyBDYW52YXNUZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVXRpbHMuaXNXb3JrZXJUaHJlYWQpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHMgPSB7fTsgLy8gdW5pcXVlIHRleHRzLCBncm91cGVkIGJ5IHRpbGUsIGJ5IHN0eWxlXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ2FsbGVkIG9uIHdvcmtlciB0aHJlYWQgdG8gcmVsZWFzZSB0aWxlLXNwZWNpZmljIHJlc291cmNlc1xuICAgIGZyZWVUaWxlICh0aWxlKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRleHRzW3RpbGUua2V5XTtcbiAgICB9LFxuXG4gICAgLy8gRnJlZSB0aWxlLXNwZWNpZmljIHJlc291cmNlcyBiZWZvcmUgZmluc2hpbmcgc3R5bGUgY29uc3RydWN0aW9uXG4gICAgZmluaXNoVGlsZSh0aWxlKSB7XG4gICAgICAgIHRoaXMuZnJlZVRpbGUodGlsZSk7XG4gICAgICAgIHJldHVybiBTdHlsZS5lbmREYXRhLmNhbGwodGhpcywgdGlsZSk7XG4gICAgfSxcblxuICAgIC8vIE92ZXJyaWRlIHRvIHF1ZXVlIGZlYXR1cmVzIGluc3RlYWQgb2YgcHJvY2Vzc2luZyBpbW1lZGlhdGVseVxuICAgIGFkZEZlYXR1cmUgKGZlYXR1cmUsIGRyYXcsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHRpbGUgPSBjb250ZXh0LnRpbGU7XG4gICAgICAgIGlmICh0aWxlLmdlbmVyYXRpb24gIT09IHRoaXMuZ2VuZXJhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsbGVkIGhlcmUgYmVjYXVzZSBvdGhlcndpc2UgaXQgd2lsbCBiZSBkZWxheWVkIHVudGlsIHRoZSBmZWF0dXJlIHF1ZXVlIGlzIHBhcnNlZCxcbiAgICAgICAgLy8gYW5kIHdlIHdhbnQgdGhlIHByZXByb2Nlc3NpbmcgZG9uZSBiZWZvcmUgd2UgZXZhbHVhdGUgdGV4dCBzdHlsZSBiZWxvd1xuICAgICAgICBkcmF3ID0gdGhpcy5wcmVwcm9jZXNzKGRyYXcpO1xuICAgICAgICBpZiAoIWRyYXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXB1dGUgbGFiZWwgdGV4dFxuICAgICAgICBsZXQgdGV4dCA9IHRoaXMucGFyc2VUZXh0U291cmNlKGZlYXR1cmUsIGRyYXcsIGNvbnRleHQpO1xuICAgICAgICBpZiAodGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIG5vIHRleHQgZm9yIHRoaXMgZmVhdHVyZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0ZXh0IHN0eWxlIGFuZCBsYXlvdXQgc2V0dGluZ3MgZm9yIHRoaXMgZmVhdHVyZSBsYWJlbFxuICAgICAgICBsZXQgbGF5b3V0ID0gdGhpcy5jb21wdXRlTGF5b3V0KHt9LCBmZWF0dXJlLCBkcmF3LCBjb250ZXh0LCB0aWxlLCB0ZXh0KTtcbiAgICAgICAgbGV0IHRleHRfc2V0dGluZ3MgPSBUZXh0U2V0dGluZ3MuY29tcHV0ZShmZWF0dXJlLCBkcmF3LCBjb250ZXh0KTtcbiAgICAgICAgbGV0IHRleHRfc2V0dGluZ3Nfa2V5ID0gVGV4dFNldHRpbmdzLmtleSh0ZXh0X3NldHRpbmdzKTtcblxuICAgICAgICAvLyBmaXJzdCBsYWJlbCBpbiB0aWxlLCBvciB3aXRoIHRoaXMgc3R5bGU/XG4gICAgICAgIHRoaXMudGV4dHNbdGlsZS5rZXldID0gdGhpcy50ZXh0c1t0aWxlLmtleV0gfHwge307XG4gICAgICAgIHRoaXMudGV4dHNbdGlsZS5rZXldW3RleHRfc2V0dGluZ3Nfa2V5XSA9IHRoaXMudGV4dHNbdGlsZS5rZXldW3RleHRfc2V0dGluZ3Nfa2V5XSB8fCB7fTtcblxuICAgICAgICAvLyB1bmlxdWUgdGV4dCBzdHJpbmdzLCBncm91cGVkIGJ5IHRleHQgZHJhd2luZyBzdHlsZVxuICAgICAgICBpZiAoIXRoaXMudGV4dHNbdGlsZS5rZXldW3RleHRfc2V0dGluZ3Nfa2V5XVt0ZXh0XSkge1xuICAgICAgICAgICAgLy8gZmlyc3QgbGFiZWwgd2l0aCB0aGlzIHRleHQvc3R5bGUvdGlsZSBjb21iaW5hdGlvbiwgbWFrZSBhIG5ldyBsYWJlbCBlbnRyeVxuICAgICAgICAgICAgdGhpcy50ZXh0c1t0aWxlLmtleV1bdGV4dF9zZXR0aW5nc19rZXldW3RleHRdID0ge1xuICAgICAgICAgICAgICAgIHRleHRfc2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgcmVmOiAwIC8vICMgb2YgdGltZXMgdGhpcyB0ZXh0L3N0eWxlIGNvbWJvIGFwcGVhcnMgaW4gdGlsZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFF1ZXVlIHRoZSBmZWF0dXJlIGZvciBwcm9jZXNzaW5nXG4gICAgICAgIGlmICghdGhpcy50aWxlX2RhdGFbdGlsZS5rZXldKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RGF0YSh0aWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5xdWV1ZXNbdGlsZS5rZXldKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlc1t0aWxlLmtleV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucXVldWVzW3RpbGUua2V5XS5wdXNoKHtcbiAgICAgICAgICAgIGZlYXR1cmUsIGRyYXcsIGNvbnRleHQsXG4gICAgICAgICAgICB0ZXh0LCB0ZXh0X3NldHRpbmdzX2tleSwgbGF5b3V0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlZ2lzdGVyIHdpdGggY29sbGlzaW9uIG1hbmFnZXJcbiAgICAgICAgQ29sbGlzaW9uLmFkZFN0eWxlKHRoaXMubmFtZSwgdGlsZS5rZXkpO1xuICAgIH0sXG5cbiAgICAvLyBPdmVycmlkZVxuICAgIGVuZERhdGEgKHRpbGUpIHtcbiAgICAgICAgbGV0IHF1ZXVlID0gdGhpcy5xdWV1ZXNbdGlsZS5rZXldO1xuICAgICAgICB0aGlzLnF1ZXVlc1t0aWxlLmtleV0gPSBbXTtcblxuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy50ZXh0c1t0aWxlLmtleV18fHt9KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpcnN0IGNhbGwgdG8gbWFpbiB0aHJlYWQsIGFzayBmb3IgdGV4dCBwaXhlbCBzaXplc1xuICAgICAgICByZXR1cm4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHRoaXMubWFpbl90aHJlYWRfdGFyZ2V0KycuY2FsY1RleHRTaXplcycsIHRpbGUua2V5LCB0aGlzLnRleHRzW3RpbGUua2V5XSkudGhlbih0ZXh0cyA9PiB7XG4gICAgICAgICAgICBpZiAodGlsZS5jYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgIFV0aWxzLmxvZygndHJhY2UnLCBgU3R5bGUgJHt0aGlzLm5hbWV9OiBzdG9wIHRpbGUgYnVpbGQgYmVjYXVzZSB0aWxlIHdhcyBjYW5jZWxlZDogJHt0aWxlLmtleX0sIHBvc3QtY2FsY1RleHRTaXplcygpYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRleHRzKSB7XG4gICAgICAgICAgICAgICAgQ29sbGlzaW9uLmNvbGxpZGUoe30sIHRoaXMubmFtZSwgdGlsZS5rZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRpbGUodGlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRleHRzW3RpbGUua2V5XSA9IHRleHRzO1xuXG4gICAgICAgICAgICBsZXQgbGFiZWxzID0gdGhpcy5jcmVhdGVMYWJlbHModGlsZS5rZXksIHF1ZXVlKTtcblxuICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbi5jb2xsaWRlKGxhYmVscywgdGhpcy5uYW1lLCB0aWxlLmtleSkudGhlbihsYWJlbHMgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aWxlLmNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIFV0aWxzLmxvZygndHJhY2UnLCBgc3RvcCB0aWxlIGJ1aWxkIGJlY2F1c2UgdGlsZSB3YXMgY2FuY2VsZWQ6ICR7dGlsZS5rZXl9LCBwb3N0LWNvbGxpZGUoKWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxhYmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVGlsZSh0aWxlKTsgLy8gbm8gbGFiZWxzIHZpc2libGUgZm9yIHRoaXMgdGlsZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY3VsbFRleHRTdHlsZXModGV4dHMsIGxhYmVscyk7XG5cbiAgICAgICAgICAgICAgICAvLyBzZWNvbmQgY2FsbCB0byBtYWluIHRocmVhZCwgZm9yIHJhc3Rlcml6aW5nIHRoZSBzZXQgb2YgdGV4dHNcbiAgICAgICAgICAgICAgICByZXR1cm4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHRoaXMubWFpbl90aHJlYWRfdGFyZ2V0KycucmFzdGVyaXplVGV4dHMnLCB0aWxlLmtleSwgdGV4dHMpLnRoZW4oKHsgdGV4dHMsIHRleHR1cmUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGlsZS5jYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMubG9nKCd0cmFjZScsIGBzdG9wIHRpbGUgYnVpbGQgYmVjYXVzZSB0aWxlIHdhcyBjYW5jZWxlZDogJHt0aWxlLmtleX0sIHBvc3QtcmFzdGVyaXplVGV4dHMoKWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRzW3RpbGUua2V5XSA9IHRleHRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCdWlsZCBxdWV1ZWQgZmVhdHVyZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVscy5mb3JFYWNoKHEgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0X3NldHRpbmdzX2tleSA9IHEudGV4dF9zZXR0aW5nc19rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHRfaW5mbyA9IHRoaXMudGV4dHNbdGlsZS5rZXldICYmIHRoaXMudGV4dHNbdGlsZS5rZXldW3RleHRfc2V0dGluZ3Nfa2V5XSAmJiB0aGlzLnRleHRzW3RpbGUua2V5XVt0ZXh0X3NldHRpbmdzX2tleV1bcS50ZXh0XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldHVwIHN0eWxpbmcgb2JqZWN0IGV4cGVjdGVkIGJ5IFN0eWxlIGNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlID0gdGhpcy5mZWF0dXJlX3N0eWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLmxhYmVsID0gcS5sYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5zaXplID0gdGV4dF9pbmZvLnNpemUubG9naWNhbF9zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLmFuZ2xlID0gVXRpbHMucmFkVG9EZWcocS5sYWJlbC5hbmdsZSkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS50ZXhjb29yZHMgPSB0ZXh0X2luZm8udGV4Y29vcmRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3R5bGUuYWRkRmVhdHVyZS5jYWxsKHRoaXMsIHEuZmVhdHVyZSwgcS5kcmF3LCBxLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUaWxlKHRpbGUpLnRoZW4odGlsZV9kYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0dGFjaCB0aWxlLXNwZWNpZmljIGxhYmVsIGF0bGFzIHRvIG1lc2ggYXMgYSB0ZXh0dXJlIHVuaWZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlICYmIHRpbGVfZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVfZGF0YS51bmlmb3JtcyA9IHsgdV90ZXh0dXJlOiB0ZXh0dXJlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZV9kYXRhLnRleHR1cmVzID0gW3RleHR1cmVdOyAvLyBhc3NpZ24gdGV4dHVyZSBvd25lcnNoaXAgdG8gdGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aWxlX2RhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBjcmVhdGVMYWJlbHMgKHRpbGVfa2V5LCBmZWF0dXJlX3F1ZXVlKSB7XG4gICAgICAgIGxldCBsYWJlbHMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBmPTA7IGYgPCBmZWF0dXJlX3F1ZXVlLmxlbmd0aDsgZisrKSB7XG4gICAgICAgICAgICBsZXQgeyBmZWF0dXJlLCBkcmF3LCBjb250ZXh0LCB0ZXh0LCB0ZXh0X3NldHRpbmdzX2tleSwgbGF5b3V0IH0gPSBmZWF0dXJlX3F1ZXVlW2ZdO1xuICAgICAgICAgICAgbGV0IHRleHRfaW5mbyA9IHRoaXMudGV4dHNbdGlsZV9rZXldW3RleHRfc2V0dGluZ3Nfa2V5XVt0ZXh0XTtcblxuICAgICAgICAgICAgbGV0IGZlYXR1cmVfbGFiZWxzID0gdGhpcy5idWlsZExhYmVsc0Zyb21HZW9tZXRyeSh0ZXh0X2luZm8uc2l6ZS5jb2xsaXNpb25fc2l6ZSwgZmVhdHVyZS5nZW9tZXRyeSwgbGF5b3V0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmVhdHVyZV9sYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSBmZWF0dXJlX2xhYmVsc1tpXTtcbiAgICAgICAgICAgICAgICBsYWJlbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUsIGRyYXcsIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRleHQsIHRleHRfc2V0dGluZ3Nfa2V5LCBsYXlvdXQsIGxhYmVsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgdW51c2VkIHRleHQvc3R5bGUgY29tYmluYXRpb25zIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHJhc3Rlcml6YXRpb25cbiAgICBjdWxsVGV4dFN0eWxlcyh0ZXh0cywgbGFiZWxzKSB7XG4gICAgICAgIC8vIENvdW50IGhvdyBtYW55IHRpbWVzIGVhY2ggdGV4dC9zdHlsZSBjb21iaW5hdGlvbiBpcyB1c2VkXG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGV4dHNbbGFiZWxzW2ldLnRleHRfc2V0dGluZ3Nfa2V5XVtsYWJlbHNbaV0udGV4dF0ucmVmKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgdGV4dC9zdHlsZSBjb21iaW5hdGlvbnMgdGhhdCBoYXZlIG5vIHZpc2libGUgbGFiZWxzXG4gICAgICAgIGZvciAobGV0IHN0eWxlIGluIHRleHRzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0ZXh0IGluIHRleHRzW3N0eWxlXSkge1xuICAgICAgICAgICAgICAgIC8vIG5vIGxhYmVscyBmb3IgdGhpcyB0ZXh0XG4gICAgICAgICAgICAgICAgaWYgKHRleHRzW3N0eWxlXVt0ZXh0XS5yZWYgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBkcm9wIGxhYmVsIHRleHQgJHt0ZXh0fSBpbiBzdHlsZSAke3N0eWxlfWApO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGV4dHNbc3R5bGVdW3RleHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHN0eWxlIGluIHRleHRzKSB7XG4gICAgICAgICAgICAvLyBubyBsYWJlbHMgZm9yIHRoaXMgc3R5bGVcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0ZXh0c1tzdHlsZV0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBkcm9wIGxhYmVsIHRleHQgc3R5bGUgJHtzdHlsZX1gKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGV4dHNbc3R5bGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIENhbGxlZCBvbiBtYWluIHRocmVhZCBmcm9tIHdvcmtlciwgdG8gY29tcHV0ZSB0aGUgc2l6ZSBvZiBlYWNoIHRleHQgc3RyaW5nLFxuICAgIC8vIHdlcmUgaXQgdG8gYmUgcmVuZGVyZWQuIFRoaXMgaW5mbyBpcyB0aGVuIHVzZWQgdG8gcGVyZm9ybSBpbml0aWFsIGxhYmVsIGN1bGxpbmcsICpiZWZvcmUqXG4gICAgLy8gbGFiZWxzIGFyZSBhY3R1YWxseSByZW5kZXJlZC5cbiAgICBjYWxjVGV4dFNpemVzICh0aWxlX2tleSwgdGV4dHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLnRleHRTaXplcyh0aWxlX2tleSwgdGV4dHMpO1xuICAgIH0sXG5cbiAgICAvLyBDYWxsZWQgb24gbWFpbiB0aHJlYWQgZnJvbSB3b3JrZXIsIHRvIGNyZWF0ZSBhdGxhcyBvZiBsYWJlbHMgZm9yIGEgdGlsZVxuICAgIHJhc3Rlcml6ZVRleHRzICh0aWxlX2tleSwgdGV4dHMpIHtcbiAgICAgICAgbGV0IGNhbnZhcyA9IG5ldyBDYW52YXNUZXh0KCk7XG4gICAgICAgIGxldCB0ZXh0dXJlX3NpemUgPSBjYW52YXMuc2V0VGV4dHVyZVRleHRQb3NpdGlvbnModGV4dHMsIHRoaXMubWF4X3RleHR1cmVfc2l6ZSk7XG4gICAgICAgIGxvZy50cmFjZShgdGV4dCBzdW1tYXJ5IGZvciB0aWxlICR7dGlsZV9rZXl9OiBmaXRzIGluICR7dGV4dHVyZV9zaXplWzBdfXgke3RleHR1cmVfc2l6ZVsxXX1weGApO1xuXG4gICAgICAgIC8vIGZpdHMgaW4gbWF4IHRleHR1cmUgc2l6ZT9cbiAgICAgICAgaWYgKHRleHR1cmVfc2l6ZVswXSA8IHRoaXMubWF4X3RleHR1cmVfc2l6ZSAmJiB0ZXh0dXJlX3NpemVbMV0gPCB0aGlzLm1heF90ZXh0dXJlX3NpemUpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBjYW52YXMgc2l6ZSAmIHJhc3Rlcml6ZSBhbGwgdGhlIHRleHQgc3RyaW5ncyB3ZSBuZWVkXG4gICAgICAgICAgICBjYW52YXMucmVzaXplKC4uLnRleHR1cmVfc2l6ZSk7XG4gICAgICAgICAgICBjYW52YXMucmFzdGVyaXplKHRpbGVfa2V5LCB0ZXh0cywgdGV4dHVyZV9zaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihbXG4gICAgICAgICAgICAgICAgYExhYmVsIGF0bGFzIGZvciB0aWxlICR7dGlsZV9rZXl9IGlzICR7dGV4dHVyZV9zaXplWzBdfXgke3RleHR1cmVfc2l6ZVsxXX1weCwgYCxcbiAgICAgICAgICAgICAgICBgYnV0IG1heCBHTCB0ZXh0dXJlIHNpemUgaXMgJHt0aGlzLm1heF90ZXh0dXJlX3NpemV9eCR7dGhpcy5tYXhfdGV4dHVyZV9zaXplfXB4YF0uam9pbignJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgdGV4dHVyZVxuICAgICAgICBsZXQgdCA9ICdsYWJlbHMtJyArIHRpbGVfa2V5ICsgJy0nICsgKFRleHRTdHlsZS50ZXh0dXJlX2lkKyspO1xuICAgICAgICBUZXh0dXJlLmNyZWF0ZSh0aGlzLmdsLCB0LCB7XG4gICAgICAgICAgICBlbGVtZW50OiBjYW52YXMuY2FudmFzLFxuICAgICAgICAgICAgZmlsdGVyaW5nOiAnbGluZWFyJyxcbiAgICAgICAgICAgIFVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTDogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4geyB0ZXh0cywgdGV4dHVyZTogdCB9OyAvLyB0ZXh0dXJlIGlzIHJldHVybmVkIGJ5IG5hbWUgKG5vdCBpbnN0YW5jZSlcbiAgICB9LFxuXG4gICAgLy8gU2V0cyB1cCBjYWNoaW5nIGZvciBkcmF3IHJ1bGUgcHJvcGVydGllc1xuICAgIF9wcmVwcm9jZXNzIChkcmF3KSB7XG4gICAgICAgIGlmICghZHJhdy5mb250KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb2xvcnNcbiAgICAgICAgZHJhdy5mb250LmZpbGwgPSBTdHlsZVBhcnNlci5jYWNoZU9iamVjdChkcmF3LmZvbnQuZmlsbCk7XG4gICAgICAgIGlmIChkcmF3LmZvbnQuc3Ryb2tlKSB7XG4gICAgICAgICAgICBkcmF3LmZvbnQuc3Ryb2tlLmNvbG9yID0gU3R5bGVQYXJzZXIuY2FjaGVPYmplY3QoZHJhdy5mb250LnN0cm9rZS5jb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IGZvbnQgYW5kIHRleHQgc3Ryb2tlIHNpemVzXG4gICAgICAgIGRyYXcuZm9udC5weF9zaXplID0gU3R5bGVQYXJzZXIuY2FjaGVPYmplY3QoZHJhdy5mb250LnNpemUsIENhbnZhc1RleHQuZm9udFBpeGVsU2l6ZSk7XG4gICAgICAgIGlmIChkcmF3LmZvbnQuc3Ryb2tlICYmIGRyYXcuZm9udC5zdHJva2Uud2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgZHJhdy5mb250LnN0cm9rZS53aWR0aCA9IFN0eWxlUGFyc2VyLmNhY2hlT2JqZWN0KGRyYXcuZm9udC5zdHJva2Uud2lkdGgsIHBhcnNlRmxvYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT2Zmc2V0ICgyZCBhcnJheSlcbiAgICAgICAgZHJhdy5vZmZzZXQgPSBTdHlsZVBhcnNlci5jYWNoZU9iamVjdChkcmF3Lm9mZnNldCwgdiA9PiAoQXJyYXkuaXNBcnJheSh2KSAmJiB2Lm1hcChwYXJzZUZsb2F0KSkgfHwgMCk7XG5cbiAgICAgICAgLy8gQnVmZmVyICgxZCB2YWx1ZSBvciBvciAyZCBhcnJheSlcbiAgICAgICAgZHJhdy5idWZmZXIgPSBTdHlsZVBhcnNlci5jYWNoZU9iamVjdChkcmF3LmJ1ZmZlciwgdiA9PiAoQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbdiwgdl0pLm1hcChwYXJzZUZsb2F0KSB8fCAwKTtcblxuICAgICAgICAvLyBSZXBlYXQgcnVsZXNcbiAgICAgICAgZHJhdy5yZXBlYXRfZGlzdGFuY2UgPSBTdHlsZVBhcnNlci5jYWNoZU9iamVjdChkcmF3LnJlcGVhdF9kaXN0YW5jZSwgcGFyc2VGbG9hdCk7XG5cbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgfSxcblxuICAgIC8vIENvbXB1dGUgdGhlIGxhYmVsIHRleHQsIGRlZmF1bHQgaXMgdmFsdWUgb2YgZmVhdHVyZS5wcm9wZXJ0aWVzLm5hbWVcbiAgICAvLyAtIFN0cmluZyB2YWx1ZSBpbmRpY2F0ZXMgYSBmZWF0dXJlIHByb3BlcnR5IGxvb2stdXAsIGUuZy4gYHNob3J0X25hbWVgIG1lYW5zIHVzZSBmZWF0dXJlLnByb3BlcnRpZXMuc2hvcnRfbmFtZVxuICAgIC8vIC0gRnVuY3Rpb24gd2lsbCB1c2UgdGhlIHJldHVybiB2YWx1ZSBhcyB0aGUgbGFiZWwgdGV4dCAoZm9yIGN1c3RvbSBsYWJlbHMpXG4gICAgLy8gLSBBcnJheSAob2Ygc3RyaW5ncyBhbmQvb3IgZnVuY3Rpb25zKSBkZWZpbmVzIGEgbGlzdCBvZiBmYWxsYmFja3MsIGV2YWx1YXRlZCBhY2NvcmRpbmcgdG8gdGhlIGFib3ZlIHJ1bGVzLFxuICAgIC8vICAgd2l0aCB0aGUgZmlyc3Qgbm9uLW51bGwgdmFsdWUgdXNlZCBhcyB0aGUgbGFiZWwgdGV4dFxuICAgIC8vICAgZS5nLiBgW25hbWU6ZXMsIG5hbWU6ZW4sIG5hbWVdYCBwcmVmZXJzIFNwYW5pc2ggbmFtZXMsIGZvbGxvd2VkIGJ5IEVuZ2xpc2gsIGFuZCBsYXN0IHRoZSBkZWZhdWx0IGxvY2FsIG5hbWVcbiAgICBwYXJzZVRleHRTb3VyY2UgKGZlYXR1cmUsIGRyYXcsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHRleHQ7XG4gICAgICAgIGxldCBzb3VyY2UgPSBkcmF3LnRleHRfc291cmNlIHx8ICduYW1lJztcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzPTA7IHMgPCBzb3VyY2UubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVtzXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGZlYXR1cmUucHJvcGVydGllc1tzb3VyY2Vbc11dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZVtzXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gc291cmNlW3NdKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBzdG9wIGlmIHdlIGZvdW5kIGEgdGV4dCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGV4dCA9IGZlYXR1cmUucHJvcGVydGllc1tzb3VyY2VdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRleHQgPSBzb3VyY2UoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSxcblxuICAgIC8vIEFkZGl0aW9uYWwgdGV4dC1zcGVjaWZpYyBsYXlvdXQgc2V0dGluZ3NcbiAgICBjb21wdXRlTGF5b3V0ICh0YXJnZXQsIGZlYXR1cmUsIGRyYXcsIGNvbnRleHQsIHRpbGUsIHRleHQpIHtcbiAgICAgICAgbGV0IGxheW91dCA9IHRhcmdldCB8fCB7fTtcblxuICAgICAgICAvLyBjb21tb24gc2V0dGluZ3Mgdy9wb2ludHNcbiAgICAgICAgbGF5b3V0ID0gUG9pbnRzLmNvbXB1dGVMYXlvdXQobGF5b3V0LCBmZWF0dXJlLCBkcmF3LCBjb250ZXh0LCB0aWxlKTtcblxuICAgICAgICAvLyB0aWxlIGJvdW5kYXJ5IGhhbmRsaW5nXG4gICAgICAgIGxheW91dC5jdWxsX2Zyb21fdGlsZSA9IChkcmF3LmN1bGxfZnJvbV90aWxlICE9IG51bGwpID8gZHJhdy5jdWxsX2Zyb21fdGlsZSA6IHRydWU7XG4gICAgICAgIGxheW91dC5tb3ZlX2ludG9fdGlsZSA9IChkcmF3Lm1vdmVfaW50b190aWxlICE9IG51bGwpID8gZHJhdy5tb3ZlX2ludG9fdGlsZSA6IHRydWU7XG5cbiAgICAgICAgLy8gbGFiZWwgbGluZSBleGNlZWQgcGVyY2VudGFnZVxuICAgICAgICBpZiAoZHJhdy5saW5lX2V4Y2VlZCAmJiBkcmF3LmxpbmVfZXhjZWVkLnN1YnN0cigtMSkgPT09ICclJykge1xuICAgICAgICAgICAgbGF5b3V0LmxpbmVfZXhjZWVkID0gcGFyc2VGbG9hdChkcmF3LmxpbmVfZXhjZWVkLnN1YnN0cigwLGRyYXcubGluZV9leGNlZWQubGVuZ3RoLTEpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxheW91dC5saW5lX2V4Y2VlZCA9IDgwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwZWF0IG1pbmltdW0gZGlzdGFuY2VcbiAgICAgICAgbGF5b3V0LnJlcGVhdF9kaXN0YW5jZSA9IFN0eWxlUGFyc2VyLmNhY2hlUHJvcGVydHkoZHJhdy5yZXBlYXRfZGlzdGFuY2UsIGNvbnRleHQpO1xuICAgICAgICBpZiAobGF5b3V0LnJlcGVhdF9kaXN0YW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBsYXlvdXQucmVwZWF0X2Rpc3RhbmNlID0gR2VvLnRpbGVfc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBsYXlvdXQucmVwZWF0X2Rpc3RhbmNlICo9IGxheW91dC51bml0c19wZXJfcGl4ZWw7XG5cbiAgICAgICAgLy8gcmVwZWF0IGdyb3VwIGtleVxuICAgICAgICBpZiAodHlwZW9mIGRyYXcucmVwZWF0X2dyb3VwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBsYXlvdXQucmVwZWF0X2dyb3VwID0gZHJhdy5yZXBlYXRfZ3JvdXAoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRyYXcucmVwZWF0X2dyb3VwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbGF5b3V0LnJlcGVhdF9ncm91cCA9IGRyYXcucmVwZWF0X2dyb3VwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGF5b3V0LnJlcGVhdF9ncm91cCA9IGRyYXcua2V5OyAvLyBkZWZhdWx0IHRvIHVuaXF1ZSBzZXQgb2YgbWF0Y2hpbmcgbGF5ZXJzXG4gICAgICAgIH1cbiAgICAgICAgbGF5b3V0LnJlcGVhdF9ncm91cCArPSAnLycgKyB0ZXh0O1xuXG4gICAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgfSxcblxuICAgIC8vIEJ1aWxkcyBvbmUgb3IgbW9yZSBsYWJlbHMgZm9yIGEgZ2VvbWV0cnlcbiAgICBidWlsZExhYmVsc0Zyb21HZW9tZXRyeSAoc2l6ZSwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGxhYmVscyA9IFtdO1xuXG4gICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSBcIkxpbmVTdHJpbmdcIikge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG5cbiAgICAgICAgICAgIGxhYmVscy5wdXNoKG5ldyBMYWJlbExpbmUoc2l6ZSwgbGluZXMsIG9wdGlvbnMpKTtcbiAgICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSBcIk11bHRpTGluZVN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gbGluZXNbaV07XG4gICAgICAgICAgICAgICAgbGFiZWxzLnB1c2gobmV3IExhYmVsTGluZShzaXplLCBsaW5lLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2ludFwiKSB7XG4gICAgICAgICAgICBsYWJlbHMucHVzaChuZXcgTGFiZWxQb2ludChnZW9tZXRyeS5jb29yZGluYXRlcywgc2l6ZSwgb3B0aW9ucykpO1xuICAgICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiTXVsdGlQb2ludFwiKSB7XG4gICAgICAgICAgICBsZXQgcG9pbnRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKG5ldyBMYWJlbFBvaW50KHBvaW50LCBzaXplLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcbiAgICAgICAgICAgIGxldCBjZW50cm9pZCA9IEdlby5jZW50cm9pZChnZW9tZXRyeS5jb29yZGluYXRlc1swXSk7XG4gICAgICAgICAgICBsYWJlbHMucHVzaChuZXcgTGFiZWxQb2ludChjZW50cm9pZCwgc2l6ZSwgb3B0aW9ucykpO1xuICAgICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiTXVsdGlQb2x5Z29uXCIpIHtcbiAgICAgICAgICAgIGxldCBjZW50cm9pZCA9IEdlby5tdWx0aUNlbnRyb2lkKGdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgICAgICAgICAgIGxhYmVscy5wdXNoKG5ldyBMYWJlbFBvaW50KGNlbnRyb2lkLCBzaXplLCBvcHRpb25zKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgIH1cblxufSk7XG5cblRleHRTdHlsZS50ZXh0dXJlX2lkID0gMDsgLy8gbmFtZXNwYWNlcyBwZXItdGlsZSBsYWJlbCB0ZXh0dXJlc1xuIiwiaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBHZW8gZnJvbSAnLi4vLi4vZ2VvJztcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4uL3N0eWxlX3BhcnNlcic7XG5pbXBvcnQgUG9pbnRBbmNob3IgZnJvbSAnLi4vcG9pbnRzL3BvaW50X2FuY2hvcic7XG5cbnZhciBUZXh0U2V0dGluZ3M7XG5cbmV4cG9ydCBkZWZhdWx0IFRleHRTZXR0aW5ncyA9IHtcblxuICAgIC8vIEEga2V5IGZvciBncm91cGluZyBhbGwgbGFiZWxzIG9mIHRoZSBzYW1lIHRleHQgc3R5bGUgKGUuZy4gc2FtZSBDYW52YXMgc3RhdGUsIHRvIG1pbmltaXplIHN0YXRlIGNoYW5nZXMpXG4gICAga2V5IChzZXR0aW5ncykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc2V0dGluZ3Muc3R5bGUsXG4gICAgICAgICAgICBzZXR0aW5ncy53ZWlnaHQsXG4gICAgICAgICAgICBzZXR0aW5ncy5mYW1pbHksXG4gICAgICAgICAgICBzZXR0aW5ncy5weF9zaXplLFxuICAgICAgICAgICAgc2V0dGluZ3MuZmlsbCxcbiAgICAgICAgICAgIHNldHRpbmdzLnN0cm9rZSxcbiAgICAgICAgICAgIHNldHRpbmdzLnN0cm9rZV93aWR0aCxcbiAgICAgICAgICAgIHNldHRpbmdzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIHNldHRpbmdzLnR5cGVmYWNlLFxuICAgICAgICAgICAgc2V0dGluZ3MudGV4dF93cmFwLFxuICAgICAgICAgICAgc2V0dGluZ3MuYWxpZ25cbiAgICAgICAgXS5qb2luKCcvJyk7IC8vIHR5cGVmYWNlIGZvciBsZWdhY3lcbiAgICB9LFxuXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgc3R5bGU6ICdub3JtYWwnLFxuICAgICAgICB3ZWlnaHQ6IG51bGwsXG4gICAgICAgIHNpemU6ICcxMnB4JyxcbiAgICAgICAgcHhfc2l6ZTogMTIsXG4gICAgICAgIGZhbWlseTogJ0hlbHZldGljYScsXG4gICAgICAgIGZpbGw6ICd3aGl0ZScsXG4gICAgICAgIHRleHRfd3JhcDogMTUsXG4gICAgICAgIGFsaWduOiAnY2VudGVyJ1xuICAgIH0sXG5cbiAgICBjb21wdXRlIChmZWF0dXJlLCBkcmF3LCBjb250ZXh0KSB7XG4gICAgICAgIGxldCBzdHlsZSA9IHt9O1xuXG4gICAgICAgIGRyYXcuZm9udCA9IGRyYXcuZm9udCB8fCB0aGlzLmRlZmF1bHRzO1xuXG4gICAgICAgIC8vIFVzZSBmaWxsIGlmIHNwZWNpZmllZCwgb3IgZGVmYXVsdFxuICAgICAgICBzdHlsZS5maWxsID0gKGRyYXcuZm9udC5maWxsICYmIFV0aWxzLnRvQ1NTQ29sb3IoU3R5bGVQYXJzZXIuY2FjaGVDb2xvcihkcmF3LmZvbnQuZmlsbCwgY29udGV4dCkpKSB8fCB0aGlzLmRlZmF1bHRzLmZpbGw7XG5cbiAgICAgICAgLy8gRm9udCBwcm9wZXJ0aWVzIGFyZSBtb2RlbGVkIGFmdGVyIENTUyBuYW1lczpcbiAgICAgICAgLy8gLSBmYW1pbHk6IEhlbHZldGljYSwgRnV0dXJhLCBldGMuXG4gICAgICAgIC8vIC0gc2l6ZTogaW4gcHQsIHB4LCBvciBlbVxuICAgICAgICAvLyAtIHN0eWxlOiBub3JtYWwsIGl0YWxpYywgb2JsaXF1ZVxuICAgICAgICAvLyAtIHdlaWdodDogbm9ybWFsLCBib2xkLCBldGMuXG4gICAgICAgIC8vIC0gdHJhbnNmb3JtOiBjYXBpdGFsaXplLCB1cHBlcmNhc2UsIGxvd2VyY2FzZVxuICAgICAgICBzdHlsZS5zdHlsZSA9IGRyYXcuZm9udC5zdHlsZSB8fCB0aGlzLmRlZmF1bHRzLnN0eWxlO1xuICAgICAgICBzdHlsZS53ZWlnaHQgPSBkcmF3LmZvbnQud2VpZ2h0IHx8IHRoaXMuZGVmYXVsdHMud2VpZ2h0O1xuICAgICAgICBzdHlsZS5mYW1pbHkgPSAoZHJhdy5mb250LmZhbWlseSA/IGAke2RyYXcuZm9udC5mYW1pbHl9LCBgIDogJycpICsgdGhpcy5kZWZhdWx0cy5mYW1pbHk7XG4gICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IGRyYXcuZm9udC50cmFuc2Zvcm07XG5cbiAgICAgICAgLy8gb3JpZ2luYWwgc2l6ZSAobm90IGN1cnJlbnRseSB1c2VkLCBidXQgdXNlZnVsIGZvciBkZWJ1Z2dpbmcpXG4gICAgICAgIHN0eWxlLnNpemUgPSBkcmF3LmZvbnQuc2l6ZSB8fCBkcmF3LmZvbnQudHlwZWZhY2UgfHwgdGhpcy5kZWZhdWx0cy5zaXplOyAvLyBUT0RPOiAndHlwZWZhY2UnIGxlZ2FjeSBzeW50YXgsIGRlcHJlY2F0ZVxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZWQgcGl4ZWwgc2l6ZVxuICAgICAgICBzdHlsZS5weF9zaXplID0gU3R5bGVQYXJzZXIuY2FjaGVQcm9wZXJ0eShkcmF3LmZvbnQucHhfc2l6ZSwgY29udGV4dCkgfHwgdGhpcy5kZWZhdWx0cy5weF9zaXplO1xuXG4gICAgICAgIC8vIFVzZSBzdHJva2UgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChkcmF3LmZvbnQuc3Ryb2tlICYmIGRyYXcuZm9udC5zdHJva2UuY29sb3IpIHtcbiAgICAgICAgICAgIHN0eWxlLnN0cm9rZSA9IFV0aWxzLnRvQ1NTQ29sb3IoU3R5bGVQYXJzZXIuY2FjaGVDb2xvcihkcmF3LmZvbnQuc3Ryb2tlLmNvbG9yLCBjb250ZXh0KSB8fCB0aGlzLmRlZmF1bHRzLnN0cm9rZSk7XG4gICAgICAgICAgICBzdHlsZS5zdHJva2Vfd2lkdGggPSBTdHlsZVBhcnNlci5jYWNoZVByb3BlcnR5KGRyYXcuZm9udC5zdHJva2Uud2lkdGgsIGNvbnRleHQpIHx8IHRoaXMuZGVmYXVsdHMuc3Ryb2tlX3dpZHRoO1xuICAgICAgICAgICAgc3R5bGUuc3Ryb2tlX3dpZHRoICo9IFV0aWxzLmRldmljZV9waXhlbF9yYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmF3LmZvbnQudHlwZWZhY2UpIHsgLy8gJ3R5cGVmYWNlJyBsZWdhY3kgc3ludGF4LCBkZXByZWNhdGVcbiAgICAgICAgICAgIHN0eWxlLmZvbnRfY3NzID0gZHJhdy5mb250LnR5cGVmYWNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3R5bGUuZm9udF9jc3MgPSB0aGlzLmZvbnRDU1Moc3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV29yZCB3cmFwIGFuZCB0ZXh0IGFsaWdubWVudFxuICAgICAgICAvLyBOb3QgYSBmb250IHByb3BlcnRpZXMsIGJ1dCBhZmZlY3QgYXRsYXMgb2YgdW5pcXVlIHRleHQgdGV4dHVyZXNcbiAgICAgICAgbGV0IHRleHRfd3JhcCA9IGRyYXcudGV4dF93cmFwOyAvLyB1c2UgZXhwbGljaXRseSBzZXQgdmFsdWVcbiAgICAgICAgaWYgKHRleHRfd3JhcCA9PSBudWxsICYmIEdlby5nZW9tZXRyeVR5cGUoZmVhdHVyZS5nZW9tZXRyeS50eXBlKSAhPT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICAvLyBwb2ludCBsYWJlbHMgKGZvciBwb2ludCBhbmQgcG9seWdvbiBmZWF0dXJlcykgaGF2ZSB3b3JkIHdyYXAgb24gdy9kZWZhdWx0IG1heCBsZW5ndGgsXG4gICAgICAgICAgICAvLyBsaW5lIGxhYmVscyBkZWZhdWx0IG9mZlxuICAgICAgICAgICAgdGV4dF93cmFwID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHRpbmcgdG8gJ3RydWUnIGNhdXNlcyBkZWZhdWx0IHdyYXAgdmFsdWUgdG8gYmUgdXNlZFxuICAgICAgICBpZiAodGV4dF93cmFwID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0ZXh0X3dyYXAgPSB0aGlzLmRlZmF1bHRzLnRleHRfd3JhcDtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS50ZXh0X3dyYXAgPSB0ZXh0X3dyYXA7XG5cbiAgICAgICAgLy8gZGVmYXVsdCBhbGlnbm1lbnQgdG8gbWF0Y2ggYW5jaG9yXG4gICAgICAgIGlmICghZHJhdy5hbGlnbiAmJiBkcmF3LmFuY2hvciAmJiBkcmF3LmFuY2hvciAhPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIGlmIChQb2ludEFuY2hvci5pc0xlZnRBbmNob3IoZHJhdy5hbmNob3IpKSB7XG4gICAgICAgICAgICAgICAgZHJhdy5hbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChQb2ludEFuY2hvci5pc1JpZ2h0QW5jaG9yKGRyYXcuYW5jaG9yKSkge1xuICAgICAgICAgICAgICAgIGRyYXcuYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZS5hbGlnbiA9IGRyYXcuYWxpZ24gfHwgdGhpcy5kZWZhdWx0cy5hbGlnbjtcblxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcblxuICAgIC8vIEJ1aWxkIENTUy1zdHlsZSBmb250IHN0cmluZyAodG8gc2V0IENhbnZhcyBkcmF3IHN0YXRlKVxuICAgIGZvbnRDU1MgKHsgc3R5bGUsIHdlaWdodCwgcHhfc2l6ZSwgZmFtaWx5IH0pIHtcbiAgICAgICAgcmV0dXJuIFtzdHlsZSwgd2VpZ2h0LCBweF9zaXplICsgJ3B4JywgZmFtaWx5XVxuICAgICAgICAgICAgLmZpbHRlcih4ID0+IHgpIC8vIHJlbW92ZSBudWxsIHByb3BzXG4gICAgICAgICAgICAuam9pbignICcpO1xuICAgIH1cblxufTtcbiIsImltcG9ydCBHZW8gZnJvbSAnLi9nZW8nO1xuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfcGFyc2VyJztcbmltcG9ydCB7U3R5bGVNYW5hZ2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9tYW5hZ2VyJztcbmltcG9ydCBDb2xsaXNpb24gZnJvbSAnLi9sYWJlbHMvY29sbGlzaW9uJztcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi91dGlscy93b3JrZXJfYnJva2VyJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4vZ2wvdGV4dHVyZSc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy91dGlscyc7XG5cbmltcG9ydCB7bWF0NCwgdmVjM30gZnJvbSAnLi91dGlscy9nbC1tYXRyaXgnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGUge1xuXG4gICAgLyoqXG4gICAgICAgIFRpbGVcbiAgICAgICAgQGNvbnN0cnVjdG9yXG4gICAgICAgIFJlcXVpcmVkIHByb3BlcnRpZXM6XG4gICAgICAgIGNvb3Jkczogb2JqZWN0IHdpdGgge3gsIHksIHp9IHByb3BlcnRpZXMgaWRlbnRpZnlpbmcgdGlsZSBjb29yZGluYXRlIGxvY2F0aW9uXG4gICAgICAgIHdvcmtlcjogd2ViIHdvcmtlciB0byBoYW5kbGUgdGlsZSBjb25zdHJ1Y3Rpb25cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgY29vcmRzLCBzdHlsZV96b29tLCBzb3VyY2UsIHdvcmtlciwgdmlldyB9KSB7XG4gICAgICAgIHRoaXMud29ya2VyID0gd29ya2VyO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5nZW5lcmF0aW9uID0gbnVsbDtcblxuICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm94eSA9IG51bGw7XG4gICAgICAgIHRoaXMucHJveHlfZGVwdGggPSAwO1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVidWcgPSB7fTtcblxuICAgICAgICB0aGlzLmNvb3JkcyA9IFRpbGUuY29vcmRpbmF0ZVdpdGhNYXhab29tKGNvb3JkcywgdGhpcy5zb3VyY2UubWF4X3pvb20pO1xuICAgICAgICB0aGlzLnN0eWxlX3pvb20gPSBzdHlsZV96b29tOyAvLyB6b29tIGxldmVsIHRvIGJlIHVzZWQgZm9yIHN0eWxpbmdcbiAgICAgICAgdGhpcy5rZXkgPSBUaWxlLmtleSh0aGlzLmNvb3JkcywgdGhpcy5zb3VyY2UsIHRoaXMuc3R5bGVfem9vbSk7XG4gICAgICAgIHRoaXMubWluID0gR2VvLm1ldGVyc0ZvclRpbGUodGhpcy5jb29yZHMpO1xuICAgICAgICB0aGlzLm1heCA9IEdlby5tZXRlcnNGb3JUaWxlKHt4OiB0aGlzLmNvb3Jkcy54ICsgMSwgeTogdGhpcy5jb29yZHMueSArIDEsIHo6IHRoaXMuY29vcmRzLnogfSksXG4gICAgICAgIHRoaXMuc3BhbiA9IHsgeDogKHRoaXMubWF4LnggLSB0aGlzLm1pbi54KSwgeTogKHRoaXMubWF4LnkgLSB0aGlzLm1pbi55KSB9O1xuICAgICAgICB0aGlzLmJvdW5kcyA9IHsgc3c6IHsgeDogdGhpcy5taW4ueCwgeTogdGhpcy5tYXgueSB9LCBuZTogeyB4OiB0aGlzLm1heC54LCB5OiB0aGlzLm1pbi55IH0gfTtcbiAgICAgICAgdGhpcy5jZW50ZXJfZGlzdCA9IDA7XG5cbiAgICAgICAgLy8gVW5pdHMgcGVyIHBpeGVsIG5lZWRzIHRvIGFjY291bnQgZm9yIG92ZXItem9vbWluZ1xuICAgICAgICB0aGlzLnVuaXRzX3Blcl9waXhlbCA9IEdlby51bml0c19wZXJfcGl4ZWw7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlX3pvb20gPiB0aGlzLmNvb3Jkcy56KSB7XG4gICAgICAgICAgICB0aGlzLnVuaXRzX3Blcl9waXhlbCAvPSBNYXRoLnBvdygyLCB0aGlzLnN0eWxlX3pvb20gLSB0aGlzLmNvb3Jkcy56KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWV0ZXJzX3Blcl9waXhlbCA9IEdlby5tZXRlcnNQZXJQaXhlbCh0aGlzLmNvb3Jkcy56KTtcbiAgICAgICAgdGhpcy51bml0c19wZXJfbWV0ZXIgPSBHZW8udW5pdHNQZXJNZXRlcih0aGlzLmNvb3Jkcy56KTtcblxuICAgICAgICB0aGlzLm1lc2hlcyA9IHt9OyAvLyByZW5kZXJhYmxlIFZCTyBtZXNoZXMga2V5ZWQgYnkgc3R5bGVcbiAgICAgICAgdGhpcy50ZXh0dXJlcyA9IFtdOyAvLyB0ZXh0dXJlcyB0aGF0IHRoZSB0aWxlIG93bnMgKGxhYmVscywgZXRjLilcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaWxlKHNwZWMpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjb29yZChjKSB7XG4gICAgICAgIHJldHVybiB7eDogYy54LCB5OiBjLnksIHo6IGMueiwga2V5OiBUaWxlLmNvb3JkS2V5KGMpfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY29vcmRLZXkoe3gsIHksIHp9KSB7XG4gICAgICAgIHJldHVybiB4ICsgJy8nICsgeSArICcvJyArIHo7XG4gICAgfVxuXG4gICAgc3RhdGljIGtleSAoY29vcmRzLCBzb3VyY2UsIHN0eWxlX3pvb20pIHtcbiAgICAgICAgY29vcmRzID0gVGlsZS5jb29yZGluYXRlV2l0aE1heFpvb20oY29vcmRzLCBzb3VyY2UubWF4X3pvb20pO1xuICAgICAgICBpZiAoY29vcmRzLnkgPCAwIHx8IGNvb3Jkcy55ID49ICgxIDw8IGNvb3Jkcy56KSB8fCBjb29yZHMueiA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gY3VsbCB0aWxlcyBvdXQgb2YgcmFuZ2UgKHggd2lsbCB3cmFwKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc291cmNlLm5hbWUsIHN0eWxlX3pvb20sIGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnpdLmpvaW4oJy8nKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY29vcmRpbmF0ZUF0Wm9vbSh7eCwgeSwgeiwga2V5fSwgem9vbSkge1xuICAgICAgICBpZiAoeiAhPT0gem9vbSkge1xuICAgICAgICAgICAgbGV0IHpzY2FsZSA9IE1hdGgucG93KDIsIHogLSB6b29tKTtcbiAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKHggLyB6c2NhbGUpO1xuICAgICAgICAgICAgeSA9IE1hdGguZmxvb3IoeSAvIHpzY2FsZSk7XG4gICAgICAgICAgICB6ID0gem9vbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVGlsZS5jb29yZCh7eCwgeSwgen0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBjb29yZGluYXRlV2l0aE1heFpvb20oe3gsIHksIHp9LCBtYXhfem9vbSkge1xuICAgICAgICBpZiAobWF4X3pvb20gIT09IHVuZGVmaW5lZCAmJiB6ID4gbWF4X3pvb20pIHtcbiAgICAgICAgICAgIHJldHVybiBUaWxlLmNvb3JkaW5hdGVBdFpvb20oe3gsIHksIHp9LCBtYXhfem9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRpbGUuY29vcmQoe3gsIHksIHp9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2hpbGRyZW5Gb3JDb29yZGluYXRlKHt4LCB5LCB6LCBrZXl9KSB7XG4gICAgICAgIGlmICghVGlsZS5jb29yZF9jaGlsZHJlbltrZXldKSB7XG4gICAgICAgICAgICB6Kys7XG4gICAgICAgICAgICB4ICo9IDI7XG4gICAgICAgICAgICB5ICo9IDI7XG4gICAgICAgICAgICBUaWxlLmNvb3JkX2NoaWxkcmVuW2tleV0gPSBbXG4gICAgICAgICAgICAgICAgVGlsZS5jb29yZCh7eCwgeSwgICAgICB6fSksIFRpbGUuY29vcmQoe3g6IHgrMSwgeSwgICAgICB6fSksXG4gICAgICAgICAgICAgICAgVGlsZS5jb29yZCh7eCwgeTogeSsxLCB6fSksIFRpbGUuY29vcmQoe3g6IHgrMSwgeTogeSsxLCB6fSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRpbGUuY29vcmRfY2hpbGRyZW5ba2V5XTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNEZXNjZW5kYW50KHBhcmVudCwgZGVzY2VuZGFudCkge1xuICAgICAgICBpZiAoZGVzY2VuZGFudC56ID4gcGFyZW50LnopIHtcbiAgICAgICAgICAgIGxldCB7eCwgeX0gPSBUaWxlLmNvb3JkaW5hdGVBdFpvb20oZGVzY2VuZGFudCwgcGFyZW50LnopO1xuICAgICAgICAgICAgcmV0dXJuIChwYXJlbnQueCA9PT0geCAmJiBwYXJlbnQueSA9PT0geSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNvcnQgYSBzZXQgb2YgdGlsZSBpbnN0YW5jZXMgKHdoaWNoIGFscmVhZHkgaGF2ZSBhIGRpc3RhbmNlIGZyb20gY2VudGVyIHRpbGUgY29tcHV0ZWQpXG4gICAgc3RhdGljIHNvcnQodGlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRpbGVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGxldCBhZCA9IGEuY2VudGVyX2Rpc3Q7XG4gICAgICAgICAgICBsZXQgYmQgPSBiLmNlbnRlcl9kaXN0O1xuICAgICAgICAgICAgcmV0dXJuIChiZCA+IGFkID8gLTEgOiAoYmQgPT09IGFkID8gMCA6IDEpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRnJlZSByZXNvdXJjZXMgb3duZWQgYnkgdGlsZVxuICAgIC8vIE9wdGlvbmFsbHkgcGFzcyB0ZXh0dXJlcyB0byBwcmVzZXJ2ZVxuICAgIGZyZWVSZXNvdXJjZXMocHJlc2VydmUgPSB7fSkge1xuICAgICAgICBpZiAodGhpcy5tZXNoZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG0gaW4gdGhpcy5tZXNoZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc2hlc1ttXS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50ZXh0dXJlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLnRleHR1cmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVzZXJ2ZS50ZXh0dXJlcyB8fCBwcmVzZXJ2ZS50ZXh0dXJlcy5pbmRleE9mKHQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dHVyZSA9IFRleHR1cmUudGV4dHVyZXNbdF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWVzaGVzID0ge307XG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSBbXTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLndvcmtlck1lc3NhZ2UoJ3NlbGYucmVtb3ZlVGlsZScsIHRoaXMua2V5KTtcbiAgICAgICAgdGhpcy5mcmVlUmVzb3VyY2VzKCk7XG4gICAgICAgIHRoaXMud29ya2VyID0gbnVsbDtcbiAgICB9XG5cbiAgICBidWlsZEFzTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLm5hbWUsXG4gICAgICAgICAgICBjb29yZHM6IHRoaXMuY29vcmRzLFxuICAgICAgICAgICAgbWluOiB0aGlzLm1pbixcbiAgICAgICAgICAgIG1heDogdGhpcy5tYXgsXG4gICAgICAgICAgICB1bml0c19wZXJfcGl4ZWw6IHRoaXMudW5pdHNfcGVyX3BpeGVsLFxuICAgICAgICAgICAgbWV0ZXJzX3Blcl9waXhlbDogdGhpcy5tZXRlcnNfcGVyX3BpeGVsLFxuICAgICAgICAgICAgdW5pdHNfcGVyX21ldGVyOiB0aGlzLnVuaXRzX3Blcl9tZXRlcixcbiAgICAgICAgICAgIHN0eWxlX3pvb206IHRoaXMuc3R5bGVfem9vbSxcbiAgICAgICAgICAgIGdlbmVyYXRpb246IHRoaXMuZ2VuZXJhdGlvbixcbiAgICAgICAgICAgIGRlYnVnOiB0aGlzLmRlYnVnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgd29ya2VyTWVzc2FnZSAoLi4ubWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHRoaXMud29ya2VyLCAuLi5tZXNzYWdlKTtcbiAgICB9XG5cbiAgICBidWlsZChnZW5lcmF0aW9uKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGlvbiA9IGdlbmVyYXRpb247XG4gICAgICAgIGlmICghdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud29ya2VyTWVzc2FnZSgnc2VsZi5idWlsZFRpbGUnLCB7IHRpbGU6IHRoaXMuYnVpbGRBc01lc3NhZ2UoKSB9KS5jYXRjaChlID0+IHsgdGhyb3cgZTsgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgIENhbGxlZCBvbiB3b3JrZXIgdG8gY2FuY2VsIGxvYWRpbmdcbiAgICAgICAgU3RhdGljIG1ldGhvZCBiZWNhdXNlIHRoZSB3b3JrZXIgb25seSBoYXMgb2JqZWN0IHJlcHJlc2VudGF0aW9ucyBvZiB0aWxlIGRhdGEsIHRoZXJlIGlzIG5vXG4gICAgICAgIHRpbGUgaW5zdGFuY2UgY3JlYXRlZCB5ZXQuXG4gICAgKi9cbiAgICBzdGF0aWMgY2FuY2VsKHRpbGUpIHtcbiAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICAgIHRpbGUuY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRpbGUuc291cmNlX2RhdGEgJiYgdGlsZS5zb3VyY2VfZGF0YS5yZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgdGlsZS5zb3VyY2VfZGF0YS5yZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBUaWxlLmFib3J0QnVpbGQodGlsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGdlb21ldHJ5IGZvciB0aWxlIC0gY2FsbGVkIGJ5IHdlYiB3b3JrZXJcbiAgICAvLyBSZXR1cm5zIGEgc2V0IG9mIHRpbGUga2V5cyB0aGF0IHNob3VsZCBiZSBzZW50IHRvIHRoZSBtYWluIHRocmVhZCAoc28gdGhhdCB3ZSBjYW4gbWluaW1pemUgZGF0YSBleGNoYW5nZSBiZXR3ZWVuIHdvcmtlciBhbmQgbWFpbiB0aHJlYWQpXG4gICAgc3RhdGljIGJ1aWxkR2VvbWV0cnkgKHRpbGUsIGxheWVycywgcnVsZXMsIHN0eWxlcykge1xuICAgICAgICB0aWxlLmRlYnVnLnJlbmRlcmluZyA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICB0aWxlLmRlYnVnLmZlYXR1cmVzID0gMDtcblxuICAgICAgICBsZXQgZGF0YSA9IHRpbGUuc291cmNlX2RhdGE7XG5cbiAgICAgICAgQ29sbGlzaW9uLnN0YXJ0VGlsZSh0aWxlLmtleSk7XG5cbiAgICAgICAgLy8gVHJlYXQgdG9wLWxldmVsIHN0eWxlIHJ1bGVzIGFzICdsYXllcnMnXG4gICAgICAgIGZvciAobGV0IGxheWVyX25hbWUgaW4gbGF5ZXJzKSB7XG4gICAgICAgICAgICBsZXQgbGF5ZXIgPSBsYXllcnNbbGF5ZXJfbmFtZV07XG4gICAgICAgICAgICAvLyBTa2lwIGxheWVycyB3aXRoIG5vIGRhdGEgc291cmNlIGRlZmluZWRcbiAgICAgICAgICAgIGlmICghbGF5ZXIgfHwgIWxheWVyLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBsb2cud2FybihgTGF5ZXIgJHtsYXllcn0gd2FzIGRlZmluZWQgd2l0aG91dCBhIGdlb21ldHJ5IGRhdGEgc291cmNlIGFuZCB3aWxsIG5vdCBiZSByZW5kZXJlZC5gKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU291cmNlIG5hbWVzIGRvbid0IG1hdGNoXG4gICAgICAgICAgICBpZiAobGF5ZXIuZGF0YS5zb3VyY2UgIT09IHRpbGUuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCBkYXRhIGZvciBvbmUgb3IgbW9yZSBsYXllcnMgZnJvbSBzb3VyY2VcbiAgICAgICAgICAgIGxldCBzb3VyY2VfbGF5ZXJzID0gVGlsZS5nZXREYXRhRm9yU291cmNlKGRhdGEsIGxheWVyLmRhdGEsIGxheWVyX25hbWUpO1xuXG4gICAgICAgICAgICAvLyBSZW5kZXIgZmVhdHVyZXMgaW4gbGF5ZXJcbiAgICAgICAgICAgIGZvciAobGV0IHM9MDsgcyA8IHNvdXJjZV9sYXllcnMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc291cmNlX2xheWVyID0gc291cmNlX2xheWVyc1tzXTtcbiAgICAgICAgICAgICAgICBsZXQgZ2VvbSA9IHNvdXJjZV9sYXllci5nZW9tO1xuICAgICAgICAgICAgICAgIGlmICghZ2VvbSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBmID0gMDsgZiA8IGdlb20uZmVhdHVyZXMubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZlYXR1cmUgPSBnZW9tLmZlYXR1cmVzW2ZdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5nZW9tZXRyeSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCBmZWF0dXJlcyB3L28gZ2VvbWV0cnkgKHZhbGlkIEdlb0pTT04pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodGlsZS5jYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMubG9nKCdkZWJ1ZycsIGBzdG9wIHRpbGUgYnVpbGQgYmVjYXVzZSB0aWxlIGFmdGVyICR7dGlsZS5kZWJ1Zy5mZWF0dXJlc30gYmVjYXVzZSBpdCB3YXMgcmVtb3ZlZDogJHt0aWxlLmtleX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250ZXh0ID0gU3R5bGVQYXJzZXIuZ2V0RmVhdHVyZVBhcnNlQ29udGV4dChmZWF0dXJlLCB0aWxlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC53aW5kaW5nID0gdGlsZS5kZWZhdWx0X3dpbmRpbmc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGF5ZXIgPSBzb3VyY2VfbGF5ZXIubGF5ZXI7IC8vIGFkZCBkYXRhIHNvdXJjZSBsYXllciBuYW1lXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGRyYXcgZ3JvdXBzIGZvciB0aGlzIGZlYXR1cmVcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxheWVyX3J1bGVzID0gcnVsZXNbbGF5ZXJfbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBkcmF3X2dyb3VwcyA9IGxheWVyX3J1bGVzLmJ1aWxkRHJhd0dyb3Vwcyhjb250ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkcmF3X2dyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW5kZXIgZHJhdyBncm91cHNcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBfbmFtZSBpbiBkcmF3X2dyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gZHJhd19ncm91cHNbZ3JvdXBfbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWdyb3VwLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIHN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGVfbmFtZSA9IGdyb3VwLnN0eWxlIHx8IGdyb3VwX25hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSBzdHlsZXNbc3R5bGVfbmFtZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cud2FybihgU3R5bGUgJyR7c3R5bGVfbmFtZX0nIG5vdCBmb3VuZCBmb3IgcnVsZSBpbiBsYXllciAnJHtsYXllcl9uYW1lfSc6YCwgZ3JvdXAsIGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmxheWVycyA9IGdyb3VwLmxheWVyczsgIC8vIGFkZCBtYXRjaGluZyBkcmF3IGxheWVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5wcm9wZXJ0aWVzID0gZ3JvdXAucHJvcGVydGllczsgLy8gYWRkIHJ1bGUtc3BlY2lmaWMgcHJvcGVydGllcyB0byBjb250ZXh0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLmFkZEZlYXR1cmUoZmVhdHVyZSwgZ3JvdXAsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnByb3BlcnRpZXMgPSBudWxsOyAvLyBjbGVhciBncm91cC1zcGVjaWZpYyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aWxlLmRlYnVnLmZlYXR1cmVzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRpbGUuZGVidWcucmVuZGVyaW5nID0gK25ldyBEYXRlKCkgLSB0aWxlLmRlYnVnLnJlbmRlcmluZztcblxuICAgICAgICAvLyBGaW5hbGl6ZSBhcnJheSBidWZmZXIgZm9yIGVhY2ggcmVuZGVyIHN0eWxlXG4gICAgICAgIGxldCB0aWxlX3N0eWxlcyA9IFN0eWxlTWFuYWdlci5zdHlsZXNGb3JUaWxlKHRpbGUua2V5KTtcbiAgICAgICAgdGlsZS5tZXNoX2RhdGEgPSB7fTtcbiAgICAgICAgbGV0IHF1ZXVlID0gW107XG4gICAgICAgIGZvciAobGV0IHM9MDsgcyA8IHRpbGVfc3R5bGVzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICBsZXQgc3R5bGVfbmFtZSA9IHRpbGVfc3R5bGVzW3NdO1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gc3R5bGVzW3N0eWxlX25hbWVdO1xuICAgICAgICAgICAgcXVldWUucHVzaChzdHlsZS5lbmREYXRhKHRpbGUpLnRoZW4oKHN0eWxlX2RhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVfZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aWxlLm1lc2hfZGF0YVtzdHlsZV9uYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleF9kYXRhOiBzdHlsZV9kYXRhLnZlcnRleF9kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXM6IHN0eWxlX2RhdGEudW5pZm9ybXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlczogc3R5bGVfZGF0YS50ZXh0dXJlc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChxdWV1ZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBDb2xsaXNpb24ucmVzZXRUaWxlKHRpbGUua2V5KTtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIGtleXMgdG8gYmUgdHJhbnNmZXJlZCB0byBtYWluIHRocmVhZFxuICAgICAgICAgICAgcmV0dXJuIFsnbWVzaF9kYXRhJ107XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICBSZXRyaWV2ZXMgZ2VvbWV0cnkgZnJvbSBhIHRpbGUgYWNjb3JkaW5nIHRvIGEgZGF0YSBzb3VyY2UgZGVmaW5pdGlvblxuICAgICAgICBSZXR1cm5zIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aDpcbiAgICAgICAgICAgIGxheWVyOiBzb3VyY2UgbGF5ZXIgbmFtZVxuICAgICAgICAgICAgZ2VvbTogR2VvSlNPTiBGZWF0dXJlQ29sbGVjdGlvblxuICAgICovXG4gICAgc3RhdGljIGdldERhdGFGb3JTb3VyY2UgKHNvdXJjZV9kYXRhLCBzb3VyY2VfY29uZmlnLCBkZWZhdWx0X2xheWVyID0gbnVsbCkge1xuICAgICAgICB2YXIgbGF5ZXJzID0gW107XG5cbiAgICAgICAgaWYgKHNvdXJjZV9jb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgbm8gbGF5ZXIgc3BlY2lmaWVkLCBhbmQgYSBkZWZhdWx0IHNvdXJjZSBsYXllciBleGlzdHNcbiAgICAgICAgICAgIGlmICghc291cmNlX2NvbmZpZy5sYXllciAmJiBzb3VyY2VfZGF0YS5sYXllcnMuX2RlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBsYXllcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiAnX2RlZmF1bHQnLFxuICAgICAgICAgICAgICAgICAgICBnZW9tOiBzb3VyY2VfZGF0YS5sYXllcnMuX2RlZmF1bHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIG5vIGxheWVyIHNwZWNpZmllZCwgYW5kIGEgZGVmYXVsdCByZXF1ZXN0ZWQgbGF5ZXIgZXhpc3RzXG4gICAgICAgICAgICBlbHNlIGlmICghc291cmNlX2NvbmZpZy5sYXllciAmJiBkZWZhdWx0X2xheWVyKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsYXllcjogZGVmYXVsdF9sYXllcixcbiAgICAgICAgICAgICAgICAgICAgZ2VvbTogc291cmNlX2RhdGEubGF5ZXJzW2RlZmF1bHRfbGF5ZXJdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBhIGxheWVyIGlzIHNwZWNpZmllZCBieSBuYW1lLCB1c2UgaXRcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VfY29uZmlnLmxheWVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGxheWVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IHNvdXJjZV9jb25maWcubGF5ZXIsXG4gICAgICAgICAgICAgICAgICAgIGdlb206IHNvdXJjZV9kYXRhLmxheWVyc1tzb3VyY2VfY29uZmlnLmxheWVyXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgbXVsdGlwbGUgbGF5ZXJzIGFyZSBzcGVjaWZpZWQgYnkgbmFtZSwgY29tYmluZSB0aGVtXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZV9jb25maWcubGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgc291cmNlX2NvbmZpZy5sYXllci5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZV9kYXRhLmxheWVyc1tsYXllcl0gJiYgc291cmNlX2RhdGEubGF5ZXJzW2xheWVyXS5mZWF0dXJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb206IHNvdXJjZV9kYXRhLmxheWVyc1tsYXllcl1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBc3NlbWJsZSBhIGN1c3RvbSBsYXllciB2aWEgYSBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIHdpdGggYWxsIHNvdXJjZSBsYXllcnNcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VfY29uZmlnLmxheWVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBnZW9tOiBzb3VyY2VfY29uZmlnLmxheWVyKHNvdXJjZV9kYXRhLmxheWVycylcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VzdG9tIGxheWVyIGhhcyBubyBuYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGF5ZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgIENhbGxlZCBvbiBtYWluIHRocmVhZCB3aGVuIGEgd2ViIHdvcmtlciBjb21wbGV0ZXMgcHJvY2Vzc2luZ1xuICAgICAgIGZvciBhIHNpbmdsZSB0aWxlLlxuICAgICovXG4gICAgYnVpbGRNZXNoZXMoc3R5bGVzKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWJ1Z1xuICAgICAgICB0aGlzLmRlYnVnLmdlb21ldHJpZXMgPSAwO1xuICAgICAgICB0aGlzLmRlYnVnLmJ1ZmZlcl9zaXplID0gMDtcblxuICAgICAgICAvLyBDcmVhdGUgVkJPc1xuICAgICAgICBsZXQgbWVzaGVzID0ge30sIHRleHR1cmVzID0gW107IC8vIG5ldyByZXNvdXJjZXMsIHRvIGJlIHN3YXBwZWQgaW5cbiAgICAgICAgbGV0IG1lc2hfZGF0YSA9IHRoaXMubWVzaF9kYXRhO1xuICAgICAgICBpZiAobWVzaF9kYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzIGluIG1lc2hfZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNoX2RhdGFbc10udmVydGV4X2RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Zy5idWZmZXJfc2l6ZSArPSBtZXNoX2RhdGFbc10udmVydGV4X2RhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHlsZXNbc10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKGBDb3VsZCBub3QgY3JlYXRlIG1lc2ggYmVjYXVzZSBzdHlsZSAnJHtzfScgbm90IGZvdW5kLCBmb3IgdGlsZSAke3RoaXMua2V5fSwgYWJvcnRpbmcgdGlsZWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzaGVzW3NdID0gc3R5bGVzW3NdLm1ha2VNZXNoKG1lc2hfZGF0YVtzXS52ZXJ0ZXhfZGF0YSwgbWVzaF9kYXRhW3NdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Zy5nZW9tZXRyaWVzICs9IG1lc2hlc1tzXS5nZW9tZXRyeV9jb3VudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBc3NpZ24gb3duZXJzaGlwIHRvIHRleHR1cmVzIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmIChtZXNoX2RhdGFbc10udGV4dHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZXMucHVzaCguLi5tZXNoX2RhdGFbc10udGV4dHVyZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5tZXNoX2RhdGE7IC8vIFRPRE86IG1pZ2h0IHdhbnQgdG8gcHJlc2VydmUgdGhpcyBmb3IgcmVidWlsZGluZyBnZW9tZXRyaWVzIHdoZW4gc3R5bGVzL2V0Yy4gY2hhbmdlP1xuXG4gICAgICAgIC8vIFN3YXAgaW4gbmV3IGRhdGEsIGZyZWUgb2xkIGRhdGFcbiAgICAgICAgdGhpcy5mcmVlUmVzb3VyY2VzKHsgdGV4dHVyZXMgfSk7IC8vIHRleHR1cmVzIHRvIHByZXNlcnZlIGFyZSBwYXNzZWQgKGF2b2lkIGZsaWNrZXJpbmcgZnJvbSBkZWxldGUvcmUtY3JlYXRlKVxuICAgICAgICB0aGlzLm1lc2hlcyA9IG1lc2hlcztcbiAgICAgICAgdGhpcy50ZXh0dXJlcyA9IHRleHR1cmVzO1xuXG4gICAgICAgIHRoaXMuZGVidWcuZ2VvbV9yYXRpbyA9ICh0aGlzLmRlYnVnLmdlb21ldHJpZXMgLyB0aGlzLmRlYnVnLmZlYXR1cmVzKS50b0ZpeGVkKDEpO1xuICAgICAgICB0aGlzLnByaW50RGVidWcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAgQ2FsbGVkIG9uIG1haW4gdGhyZWFkIHdoZW4gd2ViIHdvcmtlciBjb21wbGV0ZXMgcHJvY2Vzc2luZywgYnV0IHRpbGUgaGFzIHNpbmNlIGJlZW4gZGlzY2FyZGVkXG4gICAgICAgIEZyZWVzIHJlc291cmNlcyB0aGF0IHdvdWxkIGhhdmUgYmVlbiB0cmFuc2ZlcnJlZCB0byB0aGUgdGlsZSBvYmplY3QuXG4gICAgICAgIFN0YXRpYyBtZXRob2QgYmVjYXVzZSB0aGUgdGlsZSBvYmplY3Qgbm8gbG9uZ2VyIGV4aXN0cyAodGhlIHRpbGUgZGF0YSByZXR1cm5lZCBieSB0aGUgd29ya2VyIGlzIHBhc3NlZCBpbnN0ZWFkKS5cbiAgICAqL1xuICAgIHN0YXRpYyBhYm9ydEJ1aWxkICh0aWxlKSB7XG4gICAgICAgIGlmICh0aWxlLm1lc2hfZGF0YSkge1xuICAgICAgICAgICAgZm9yIChsZXQgcyBpbiB0aWxlLm1lc2hfZGF0YSkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0dXJlcyA9IHRpbGUubWVzaF9kYXRhW3NdLnRleHR1cmVzO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRleHR1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dHVyZSA9IFRleHR1cmUudGV4dHVyZXNbdF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy50cmFjZShgZGVzdHJveWluZyB0ZXh0dXJlICR7dH0gZm9yIHRpbGUgJHt0aWxlLmtleX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSByZWxhdGl2ZSB0byB2aWV3XG4gICAgdXBkYXRlICgpIHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHRoaXMuY29vcmRzO1xuICAgICAgICBpZiAoY29vcmRzLnogIT09IHRoaXMudmlldy5jZW50ZXIudGlsZS56KSB7XG4gICAgICAgICAgICBjb29yZHMgPSBUaWxlLmNvb3JkaW5hdGVBdFpvb20oY29vcmRzLCB0aGlzLnZpZXcuY2VudGVyLnRpbGUueik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jZW50ZXJfZGlzdCA9IE1hdGguYWJzKHRoaXMudmlldy5jZW50ZXIudGlsZS54IC0gY29vcmRzLngpICsgTWF0aC5hYnModGhpcy52aWV3LmNlbnRlci50aWxlLnkgLSBjb29yZHMueSk7XG4gICAgfVxuXG4gICAgLy8gU2V0IGFzIGEgcHJveHkgdGlsZSBmb3IgYW5vdGhlciB0aWxlXG4gICAgc2V0UHJveHlGb3IgKHRpbGUpIHtcbiAgICAgICAgdGhpcy5wcm94eSA9IHRpbGU7XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wcm94eV9kZXB0aCA9IDE7IC8vIGRyYXcgcHJveGllcyBhIGhhbGYtbGF5ZXIgYmFjayAob3JkZXIgaXMgc2NhbGVkIDJ4IHRvIGF2b2lkIGludGVnZXIgdHJ1bmNhdGlvbilcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByb3h5X2RlcHRoID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBtb2RlbCBtYXRyaXggYW5kIHRpbGUgdW5pZm9ybXNcbiAgICBzZXR1cFByb2dyYW0gKHsgbW9kZWwsIG1vZGVsMzIgfSwgcHJvZ3JhbSkge1xuICAgICAgICAvLyBUaWxlIG9yaWdpblxuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzRmJywgJ3VfdGlsZV9vcmlnaW4nLCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLnN0eWxlX3pvb20sIHRoaXMuY29vcmRzLnopO1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzFmJywgJ3VfdGlsZV9wcm94eV9kZXB0aCcsIHRoaXMucHJveHlfZGVwdGgpO1xuXG4gICAgICAgIC8vIE1vZGVsIC0gdHJhbnNmb3JtIHRpbGUgc3BhY2UgaW50byB3b3JsZCBzcGFjZSAobWV0ZXJzLCBhYnNvbHV0ZSBtZXJjYXRvciBwb3NpdGlvbilcbiAgICAgICAgbWF0NC5pZGVudGl0eShtb2RlbCk7XG4gICAgICAgIG1hdDQudHJhbnNsYXRlKG1vZGVsLCBtb2RlbCwgdmVjMy5mcm9tVmFsdWVzKHRoaXMubWluLngsIHRoaXMubWluLnksIDApKTtcbiAgICAgICAgbWF0NC5zY2FsZShtb2RlbCwgbW9kZWwsIHZlYzMuZnJvbVZhbHVlcyh0aGlzLnNwYW4ueCAvIEdlby50aWxlX3NjYWxlLCAtMSAqIHRoaXMuc3Bhbi55IC8gR2VvLnRpbGVfc2NhbGUsIDEpKTsgLy8gc2NhbGUgdGlsZSBsb2NhbCBjb29yZHMgdG8gbWV0ZXJzXG4gICAgICAgIG1hdDQuY29weShtb2RlbDMyLCBtb2RlbCk7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnTWF0cml4NGZ2JywgJ3VfbW9kZWwnLCBmYWxzZSwgbW9kZWwzMik7XG4gICAgfVxuXG4gICAgLy8gU2xpY2UgYSBzdWJzZXQgb2Yga2V5cyBvdXQgb2YgYSB0aWxlXG4gICAgLy8gSW5jbHVkZXMgYSBtaW5pbXVtIHNldCBvZiBwcmUtZGVmaW5lZCBrZXlzIGZvciBsb2FkIHN0YXRlLCBkZWJ1Zy4gZXRjLlxuICAgIC8vIFdlIHVzZSB0aGlzIHRvIHNlbmQgYSBzdWJzZXQgb2YgdGhlIHRpbGUgYmFjayB0byB0aGUgbWFpbiB0aHJlYWQsIHRvIG1pbmltaXplIHVubmVjZXNzYXJ5IGRhdGEgdHJhbnNmZXJcbiAgICAvLyAoZS5nLiB2ZXJ5IGxhcmdlIGl0ZW1zIGxpa2UgZmVhdHVyZSBnZW9tZXRyeSBhcmUgbm90IG5lZWRlZCBvbiB0aGUgbWFpbiB0aHJlYWQpXG4gICAgc3RhdGljIHNsaWNlICh0aWxlLCBrZXlzKSB7XG4gICAgICAgIGxldCBrZWVwID0gW1xuICAgICAgICAgICAgJ2tleScsXG4gICAgICAgICAgICAnbG9hZGluZycsXG4gICAgICAgICAgICAnbG9hZGVkJyxcbiAgICAgICAgICAgICdnZW5lcmF0aW9uJyxcbiAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAnZGVidWcnXG4gICAgICAgIF07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgICAgICBrZWVwLnB1c2goLi4ua2V5cyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCdWlsZCB0aGUgdGlsZSBzdWJzZXRcbiAgICAgICAgdmFyIHRpbGVfc3Vic2V0ID0ge307XG4gICAgICAgIGZvciAobGV0IGtleSBvZiBrZWVwKSB7XG4gICAgICAgICAgICB0aWxlX3N1YnNldFtrZXldID0gdGlsZVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRpbGVfc3Vic2V0O1xuICAgIH1cblxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvdGhlcikge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBvdGhlcltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHByaW50RGVidWcgKCkge1xuICAgICAgICBsb2cuZGVidWcoYFRpbGU6IGRlYnVnIGZvciAke3RoaXMua2V5fTogWyAgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmRlYnVnKX0gXWApO1xuICAgIH1cblxufVxuXG5UaWxlLmNvb3JkX2NoaWxkcmVuID0ge307IC8vIG9ubHkgYWxsb2NhdGUgY2hpbGRyZW4gY29vcmRpbmF0ZXMgb25jZSBwZXIgY29vcmRpbmF0ZVxuIiwiaW1wb3J0IFRpbGUgZnJvbSAnLi90aWxlJztcbmltcG9ydCBUaWxlUHlyYW1pZCBmcm9tICcuL3RpbGVfcHlyYW1pZCc7XG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5jb25zdCBUaWxlTWFuYWdlciA9IHtcblxuICAgIGluaXQoeyBzY2VuZSwgdmlldyB9KSB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy50aWxlcyA9IHt9O1xuICAgICAgICB0aGlzLnB5cmFtaWQgPSBUaWxlUHlyYW1pZDtcbiAgICAgICAgdGhpcy5weXJhbWlkLnJlc2V0KCk7XG4gICAgICAgIHRoaXMudmlzaWJsZV9jb29yZHMgPSB7fTtcbiAgICAgICAgdGhpcy5xdWV1ZWRfY29vcmRzID0gW107XG4gICAgICAgIHRoaXMuYnVpbGRpbmdfdGlsZXMgPSBudWxsO1xuICAgIH0sXG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmZvckVhY2hUaWxlKHRpbGUgPT4gdGlsZS5kZXN0cm95KCkpO1xuICAgICAgICB0aGlzLnRpbGVzID0ge307XG4gICAgICAgIHRoaXMucHlyYW1pZC5yZXNldCgpO1xuICAgICAgICB0aGlzLnZpc2libGVfY29vcmRzID0ge307XG4gICAgICAgIHRoaXMucXVldWVkX2Nvb3JkcyA9IFtdO1xuICAgICAgICB0aGlzLnNjZW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy52aWV3ID0gbnVsbDtcbiAgICB9LFxuXG4gICAga2VlcFRpbGUodGlsZSkge1xuICAgICAgICB0aGlzLnRpbGVzW3RpbGUua2V5XSA9IHRpbGU7XG4gICAgICAgIHRoaXMucHlyYW1pZC5hZGRUaWxlKHRpbGUpO1xuICAgIH0sXG5cbiAgICBoYXNUaWxlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlc1trZXldICE9PSB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIGZvcmdldFRpbGUoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1RpbGUoa2V5KSkge1xuICAgICAgICAgICAgbGV0IHRpbGUgPSB0aGlzLnRpbGVzW2tleV07XG4gICAgICAgICAgICB0aGlzLnB5cmFtaWQucmVtb3ZlVGlsZSh0aWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLnRpbGVzW2tleV07XG4gICAgICAgIHRoaXMudGlsZUJ1aWxkU3RvcChrZXkpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBzaW5nbGUgdGlsZVxuICAgIHJlbW92ZVRpbGUoa2V5KSB7XG4gICAgICAgIGxvZy50cmFjZShgdGlsZSB1bmxvYWQgZm9yICR7a2V5fWApO1xuXG4gICAgICAgIHZhciB0aWxlID0gdGhpcy50aWxlc1trZXldO1xuXG4gICAgICAgIGlmICh0aWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRpbGUuZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mb3JnZXRUaWxlKHRpbGUua2V5KTtcbiAgICAgICAgdGhpcy5zY2VuZS5yZXF1ZXN0UmVkcmF3KCk7XG4gICAgfSxcblxuICAgIC8vIFJ1biBhIGZ1bmN0aW9uIG9uIGVhY2ggdGlsZVxuICAgIGZvckVhY2hUaWxlKGZ1bmMpIHtcbiAgICAgICAgZm9yIChsZXQgdCBpbiB0aGlzLnRpbGVzKSB7XG4gICAgICAgICAgICBmdW5jKHRoaXMudGlsZXNbdF0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aWxlcyB0aGF0IHBhc3MgYSBmaWx0ZXIgY29uZGl0aW9uXG4gICAgcmVtb3ZlVGlsZXMoZmlsdGVyKSB7XG4gICAgICAgIGxldCByZW1vdmVfdGlsZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgdCBpbiB0aGlzLnRpbGVzKSB7XG4gICAgICAgICAgICBsZXQgdGlsZSA9IHRoaXMudGlsZXNbdF07XG4gICAgICAgICAgICBpZiAoZmlsdGVyKHRpbGUpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlX3RpbGVzLnB1c2godCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcj0wOyByIDwgcmVtb3ZlX3RpbGVzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICBsZXQga2V5ID0gcmVtb3ZlX3RpbGVzW3JdO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVUaWxlKGtleSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlVGlsZXNGb3JWaWV3KCkge1xuICAgICAgICAvLyBGaW5kIHZpc2libGUgdGlsZXMgYW5kIGxvYWQgbmV3IG9uZXNcbiAgICAgICAgbGV0IHByZXZfY29vcmRzID0gT2JqZWN0LmtleXModGhpcy52aXNpYmxlX2Nvb3Jkcyk7XG4gICAgICAgIHRoaXMudmlzaWJsZV9jb29yZHMgPSB7fTtcbiAgICAgICAgbGV0IHRpbGVfY29vcmRzID0gdGhpcy52aWV3LmZpbmRWaXNpYmxlVGlsZUNvb3JkaW5hdGVzKCk7XG4gICAgICAgIGZvciAobGV0IGNvb3JkcyBvZiB0aWxlX2Nvb3Jkcykge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZUNvb3JkaW5hdGUoY29vcmRzKTtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZV9jb29yZHNbY29vcmRzLmtleV0gPSBjb29yZHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB2aXNpYmxlIGNvb3JkcyBjaGFuZ2VkXG4gICAgICAgIC8vIFRPRE86IG1vdmUgdG8gYSBuZXcgdmlldyBtYW5hZ2VyIG9iamVjdFxuICAgICAgICBsZXQgbmV3X2Nvb3JkcyA9IE9iamVjdC5rZXlzKHRoaXMudmlzaWJsZV9jb29yZHMpO1xuICAgICAgICBsZXQgY29vcmRzX2NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHByZXZfY29vcmRzLmxlbmd0aCAhPT0gbmV3X2Nvb3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvb3Jkc19jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXZfY29vcmRzLnNvcnQoKTtcbiAgICAgICAgICAgIG5ld19jb29yZHMuc29ydCgpO1xuICAgICAgICAgICAgaWYgKCFwcmV2X2Nvb3Jkcy5ldmVyeSgoYywgaSkgPT4gbmV3X2Nvb3Jkc1tpXSA9PT0gYykpIHtcbiAgICAgICAgICAgICAgICBjb29yZHNfY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVRpbGVTdGF0ZXMoKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlVGlsZVN0YXRlcyAoKSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaFRpbGUodGlsZSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkodGlsZSk7XG4gICAgICAgICAgICB0aWxlLnVwZGF0ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmxvYWRRdWV1ZWRDb29yZGluYXRlcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVByb3h5VGlsZXMoKTtcbiAgICAgICAgdGhpcy52aWV3LnBydW5lVGlsZXNGb3JWaWV3KCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZVByb3h5VGlsZXMgKCkge1xuICAgICAgICBpZiAodGhpcy52aWV3Lnpvb21fZGlyZWN0aW9uID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhciBwcmV2aW91cyBwcm94aWVzXG4gICAgICAgIHRoaXMuZm9yRWFjaFRpbGUodGlsZSA9PiB0aWxlLnNldFByb3h5Rm9yKG51bGwpKTtcblxuICAgICAgICBsZXQgcHJveHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb3JFYWNoVGlsZSh0aWxlID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuem9vbV9kaXJlY3Rpb24gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGlsZS52aXNpYmxlICYmIHRpbGUubG9hZGluZyAmJiB0aWxlLmNvb3Jkcy56ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcCA9IHRoaXMucHlyYW1pZC5nZXRBbmNlc3Rvcih0aWxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuc2V0UHJveHlGb3IodGlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm94eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnZpZXcuem9vbV9kaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbGUudmlzaWJsZSAmJiB0aWxlLmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSB0aGlzLnB5cmFtaWQuZ2V0RGVzY2VuZGFudHModGlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHQgb2YgZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5zZXRQcm94eUZvcih0aWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFwcm94eSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lnpvb21fZGlyZWN0aW9uID0gMDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVWaXNpYmlsaXR5KHRpbGUpIHtcbiAgICAgICAgdGlsZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aWxlLnN0eWxlX3pvb20gPT09IHRoaXMudmlldy50aWxlX3pvb20pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc2libGVfY29vcmRzW3RpbGUuY29vcmRzLmtleV0pIHtcbiAgICAgICAgICAgICAgICB0aWxlLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYnJ1dGUgZm9yY2VcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy52aXNpYmxlX2Nvb3Jkcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVGlsZS5pc0Rlc2NlbmRhbnQodGlsZS5jb29yZHMsIHRoaXMudmlzaWJsZV9jb29yZHNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgdGlsZXMgdGhhdCBhcmVuJ3QgdmlzaWJsZSwgYW5kIGZsYWcgcmVtYWluaW5nIHZpc2libGUgb25lcyB0byBiZSB1cGRhdGVkIChmb3IgbG9hZGluZywgcHJveHksIGV0Yy4pXG4gICAgcHJ1bmVUb1Zpc2libGVUaWxlcyAoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlVGlsZXModGlsZSA9PiAhdGlsZS52aXNpYmxlKTtcbiAgICB9LFxuXG4gICAgZ2V0UmVuZGVyYWJsZVRpbGVzKCkge1xuICAgICAgICBsZXQgdGlsZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgdCBpbiB0aGlzLnRpbGVzKSB7XG4gICAgICAgICAgICBsZXQgdGlsZSA9IHRoaXMudGlsZXNbdF07XG4gICAgICAgICAgICBpZiAodGlsZS52aXNpYmxlICYmIHRpbGUubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgdGlsZXMucHVzaCh0aWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlsZXM7XG4gICAgfSxcblxuICAgIGlzTG9hZGluZ1Zpc2libGVUaWxlcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudGlsZXMpLnNvbWUoayA9PiB0aGlzLnRpbGVzW2tdLnZpc2libGUgJiYgdGhpcy50aWxlc1trXS5sb2FkaW5nKTtcbiAgICB9LFxuXG4gICAgLy8gUXVldWUgYSB0aWxlIGZvciBsb2FkXG4gICAgcXVldWVDb29yZGluYXRlKGNvb3Jkcykge1xuICAgICAgICB0aGlzLnF1ZXVlZF9jb29yZHNbdGhpcy5xdWV1ZWRfY29vcmRzLmxlbmd0aF0gPSBjb29yZHM7XG4gICAgfSxcblxuICAgIC8vIExvYWQgYWxsIHF1ZXVlZCB0aWxlc1xuICAgIGxvYWRRdWV1ZWRDb29yZGluYXRlcygpIHtcbiAgICAgICAgaWYgKHRoaXMucXVldWVkX2Nvb3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvcnQgcXVldWVkIHRpbGVzIGZyb20gY2VudGVyIHRpbGVcbiAgICAgICAgdGhpcy5xdWV1ZWRfY29vcmRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGxldCBhZCA9IE1hdGguYWJzKHRoaXMudmlldy5jZW50ZXIudGlsZS54IC0gYS54KSArIE1hdGguYWJzKHRoaXMudmlldy5jZW50ZXIudGlsZS55IC0gYS55KTtcbiAgICAgICAgICAgIGxldCBiZCA9IE1hdGguYWJzKHRoaXMudmlldy5jZW50ZXIudGlsZS54IC0gYi54KSArIE1hdGguYWJzKHRoaXMudmlldy5jZW50ZXIudGlsZS55IC0gYi55KTtcbiAgICAgICAgICAgIHJldHVybiAoYmQgPiBhZCA/IC0xIDogKGJkID09PSBhZCA/IDAgOiAxKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnF1ZXVlZF9jb29yZHMuZm9yRWFjaChjb29yZHMgPT4gdGhpcy5sb2FkQ29vcmRpbmF0ZShjb29yZHMpKTtcbiAgICAgICAgdGhpcy5xdWV1ZWRfY29vcmRzID0gW107XG4gICAgfSxcblxuICAgIC8vIExvYWQgYWxsIHRpbGVzIHRvIGNvdmVyIGEgZ2l2ZW4gbG9naWNhbCB0aWxlIGNvb3JkaW5hdGVcbiAgICBsb2FkQ29vcmRpbmF0ZShjb29yZHMpIHtcbiAgICAgICAgLy8gU2tpcCBpZiBub3QgYXQgY3VycmVudCBzY2VuZSB6b29tXG4gICAgICAgIGlmIChjb29yZHMueiAhPT0gdGhpcy52aWV3LmNlbnRlci50aWxlLnopIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBuZWNlc3NhcnkgdGlsZXMgZm9yIGVhY2ggc291cmNlXG4gICAgICAgIGZvciAobGV0IHMgaW4gdGhpcy5zY2VuZS5zb3VyY2VzKSB7XG4gICAgICAgICAgICBsZXQgc291cmNlID0gdGhpcy5zY2VuZS5zb3VyY2VzW3NdO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UudGlsZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGtleSA9IFRpbGUua2V5KGNvb3Jkcywgc291cmNlLCB0aGlzLnZpZXcudGlsZV96b29tKTtcbiAgICAgICAgICAgIGlmIChrZXkgJiYgIXRoaXMuaGFzVGlsZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRpbGUgPSBUaWxlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrZXI6IHRoaXMuc2NlbmUubmV4dFdvcmtlcigpLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZV96b29tOiB0aGlzLnZpZXcuc3R5bGVab29tKGNvb3Jkcy56KSxcbiAgICAgICAgICAgICAgICAgICAgdmlldzogdGhpcy52aWV3XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmtlZXBUaWxlKHRpbGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRUaWxlKHRpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFNvcnQgYW5kIGJ1aWxkIGEgbGlzdCBvZiB0aWxlc1xuICAgIGJ1aWxkVGlsZXModGlsZXMpIHtcbiAgICAgICAgVGlsZS5zb3J0KHRpbGVzKS5mb3JFYWNoKHRpbGUgPT4gdGhpcy5idWlsZFRpbGUodGlsZSkpO1xuICAgICAgICB0aGlzLmNoZWNrQnVpbGRRdWV1ZSgpO1xuICAgIH0sXG5cbiAgICBidWlsZFRpbGUodGlsZSkge1xuICAgICAgICB0aGlzLnRpbGVCdWlsZFN0YXJ0KHRpbGUua2V5KTtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KHRpbGUpO1xuICAgICAgICB0aWxlLnVwZGF0ZSgpO1xuICAgICAgICB0aWxlLmJ1aWxkKHRoaXMuc2NlbmUuZ2VuZXJhdGlvbilcbiAgICAgICAgICAgIC50aGVuKG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7IC8vIGVtcHR5IG1lc3NhZ2UgbWVhbnMgdGlsZSBidWlsZCB3YXMgYWJvcnRlZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkVGlsZUNvbXBsZXRlZChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihgRXJyb3IgYnVpbGRpbmcgdGlsZSAke3RpbGUua2V5fTpgLCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcmdldFRpbGUodGlsZS5rZXkpO1xuICAgICAgICAgICAgICAgIFRpbGUuYWJvcnRCdWlsZCh0aWxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBDYWxsZWQgb24gbWFpbiB0aHJlYWQgd2hlbiBhIHdlYiB3b3JrZXIgY29tcGxldGVzIHByb2Nlc3NpbmcgZm9yIGEgc2luZ2xlIHRpbGUgKGluaXRpYWwgbG9hZCwgb3IgcmVidWlsZClcbiAgICBidWlsZFRpbGVDb21wbGV0ZWQoeyB0aWxlIH0pIHtcbiAgICAgICAgLy8gUmVtb3ZlZCB0aGlzIHRpbGUgZHVyaW5nIGxvYWQ/XG4gICAgICAgIGlmICh0aGlzLnRpbGVzW3RpbGUua2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2cudHJhY2UoYGRpc2NhcmRlZCB0aWxlICR7dGlsZS5rZXl9IGluIFRpbGVNYW5hZ2VyLmJ1aWxkVGlsZUNvbXBsZXRlZCBiZWNhdXNlIHByZXZpb3VzbHkgcmVtb3ZlZGApO1xuICAgICAgICAgICAgVGlsZS5hYm9ydEJ1aWxkKHRpbGUpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUaWxlU3RhdGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVpbHQgd2l0aCBhbiBvdXRkYXRlZCBzY2VuZSBjb25maWd1cmF0aW9uP1xuICAgICAgICBlbHNlIGlmICh0aWxlLmdlbmVyYXRpb24gIT09IHRoaXMuc2NlbmUuZ2VuZXJhdGlvbikge1xuICAgICAgICAgICAgbG9nLmRlYnVnKGBkaXNjYXJkZWQgdGlsZSAke3RpbGUua2V5fSBpbiBUaWxlTWFuYWdlci5idWlsZFRpbGVDb21wbGV0ZWQgYmVjYXVzZSBidWlsdCB3aXRoIGAgK1xuICAgICAgICAgICAgICAgIGBzY2VuZSBjb25maWcgZ2VuICR7dGlsZS5nZW5lcmF0aW9ufSwgY3VycmVudCAke3RoaXMuc2NlbmUuZ2VuZXJhdGlvbn1gKTtcbiAgICAgICAgICAgIHRoaXMuZm9yZ2V0VGlsZSh0aWxlLmtleSk7XG4gICAgICAgICAgICBUaWxlLmFib3J0QnVpbGQodGlsZSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRpbGVTdGF0ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aWxlIHdpdGggcHJvcGVydGllcyBmcm9tIHdvcmtlclxuICAgICAgICAgICAgaWYgKHRoaXMudGlsZXNbdGlsZS5rZXldKSB7XG4gICAgICAgICAgICAgICAgdGlsZSA9IHRoaXMudGlsZXNbdGlsZS5rZXldLm1lcmdlKHRpbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aWxlLmJ1aWxkTWVzaGVzKHRoaXMuc2NlbmUuc3R5bGVzKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGlsZVN0YXRlcygpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5yZXF1ZXN0UmVkcmF3KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRpbGVCdWlsZFN0b3AodGlsZS5rZXkpO1xuICAgIH0sXG5cbiAgICAvLyBUcmFjayB0aWxlIGJ1aWxkIHN0YXRlXG4gICAgdGlsZUJ1aWxkU3RhcnQoa2V5KSB7XG4gICAgICAgIHRoaXMuYnVpbGRpbmdfdGlsZXMgPSB0aGlzLmJ1aWxkaW5nX3RpbGVzIHx8IHt9O1xuICAgICAgICB0aGlzLmJ1aWxkaW5nX3RpbGVzW2tleV0gPSB0cnVlO1xuICAgICAgICBsb2cudHJhY2UoYHRpbGVCdWlsZFN0YXJ0IGZvciAke2tleX06ICR7T2JqZWN0LmtleXModGhpcy5idWlsZGluZ190aWxlcykubGVuZ3RofWApO1xuICAgIH0sXG5cbiAgICB0aWxlQnVpbGRTdG9wKGtleSkge1xuICAgICAgICAvLyBEb25lIGJ1aWxkaW5nP1xuICAgICAgICBpZiAodGhpcy5idWlsZGluZ190aWxlcykge1xuICAgICAgICAgICAgbG9nLnRyYWNlKGB0aWxlQnVpbGRTdG9wIGZvciAke2tleX06ICR7T2JqZWN0LmtleXModGhpcy5idWlsZGluZ190aWxlcykubGVuZ3RofWApO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYnVpbGRpbmdfdGlsZXNba2V5XTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tCdWlsZFF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ2hlY2sgc3RhdHVzIG9mIHRpbGUgYnVpbGRpbmcgcXVldWUgYW5kIG5vdGlmeSBzY2VuZSB3aGVuIHdlJ3JlIGRvbmVcbiAgICBjaGVja0J1aWxkUXVldWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWlsZGluZ190aWxlcyB8fCBPYmplY3Qua2V5cyh0aGlzLmJ1aWxkaW5nX3RpbGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRpbmdfdGlsZXMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zY2VuZS50aWxlTWFuYWdlckJ1aWxkRG9uZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFN1bSBvZiBhIGRlYnVnIHByb3BlcnR5IGFjcm9zcyB0aWxlc1xuICAgIGdldERlYnVnU3VtKHByb3AsIGZpbHRlcikge1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLnRpbGVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50aWxlc1t0XS5kZWJ1Z1twcm9wXSAhPSBudWxsICYmICh0eXBlb2YgZmlsdGVyICE9PSAnZnVuY3Rpb24nIHx8IGZpbHRlcih0aGlzLnRpbGVzW3RdKSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gdGhpcy50aWxlc1t0XS5kZWJ1Z1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH0sXG5cbiAgICAvLyBBdmVyYWdlIG9mIGEgZGVidWcgcHJvcGVydHkgYWNyb3NzIHRpbGVzXG4gICAgZ2V0RGVidWdBdmVyYWdlKHByb3AsIGZpbHRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREZWJ1Z1N1bShwcm9wLCBmaWx0ZXIpIC8gT2JqZWN0LmtleXModGhpcy50aWxlcykubGVuZ3RoO1xuICAgIH1cblxufTtcblxuZXhwb3J0IGRlZmF1bHQgVGlsZU1hbmFnZXI7XG4iLCJpbXBvcnQgR2VvIGZyb20gJy4vZ2VvJztcbmltcG9ydCBUaWxlIGZyb20gJy4vdGlsZSc7XG5cbmNvbnN0IFRpbGVQeXJhbWlkID0ge1xuXG4gICAgY29vcmRzOiB7fSxcbiAgICBtYXhfcHJveHlfZGVzY2VuZGFudF9kZXB0aDogMywgLy8gIyBvZiBsZXZlbHMgZGVlcCB0byBzZWFyY2ggZm9yIGRlc2NlbmRhbnQgcHJveHkgdGlsZXNcblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmNvb3JkcyA9IHt9O1xuICAgIH0sXG5cbiAgICBzb3VyY2VUaWxlcyhjb29yZCwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmNvb3Jkc1tjb29yZC5rZXldICYmXG4gICAgICAgICAgICB0aGlzLmNvb3Jkc1tjb29yZC5rZXldLnNvdXJjZXMgJiZcbiAgICAgICAgICAgIHRoaXMuY29vcmRzW2Nvb3JkLmtleV0uc291cmNlcy5nZXQoc291cmNlLm5hbWUpKTtcbiAgICB9LFxuXG4gICAgYWRkVGlsZSh0aWxlKSB7XG4gICAgICAgIC8vIEFkZCB0YXJnZXQgdGlsZVxuICAgICAgICBsZXQga2V5ID0gdGlsZS5jb29yZHMua2V5O1xuICAgICAgICBsZXQgY29vcmQgPSB0aGlzLmNvb3Jkc1trZXldO1xuICAgICAgICBpZiAoIWNvb3JkKSB7XG4gICAgICAgICAgICBjb29yZCA9IHRoaXMuY29vcmRzW2tleV0gPSB7IGRlc2NlbmRhbnRzOiAwIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvb3JkLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIGNvb3JkLnNvdXJjZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvb3JkLnNvdXJjZXMuZ2V0KHRpbGUuc291cmNlLm5hbWUpKSB7XG4gICAgICAgICAgICBjb29yZC5zb3VyY2VzLnNldCh0aWxlLnNvdXJjZS5uYW1lLCBuZXcgTWFwKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvb3JkLnNvdXJjZXMuZ2V0KHRpbGUuc291cmNlLm5hbWUpLnNldCh0aWxlLnN0eWxlX3pvb20sIHRpbGUpO1xuXG4gICAgICAgIC8vIEluY3JlbWVudCByZWZlcmVuY2UgY291bnQgdXAgdGhlIHRpbGUgcHlyYW1pZFxuICAgICAgICBmb3IgKGxldCB6ID0gdGlsZS5jb29yZHMueiAtIDE7IHogPj0gMDsgei0tKSB7XG4gICAgICAgICAgICBsZXQgdXAgPSBUaWxlLmNvb3JkaW5hdGVBdFpvb20odGlsZS5jb29yZHMsIHopO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvb3Jkc1t1cC5rZXldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb29yZHNbdXAua2V5XSA9IHsgZGVzY2VuZGFudHM6IDAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29vcmRzW3VwLmtleV0uZGVzY2VuZGFudHMrKztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmVUaWxlKHRpbGUpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRhcmdldCB0aWxlXG4gICAgICAgIGxldCBzb3VyY2VfdGlsZXMgPSB0aGlzLnNvdXJjZVRpbGVzKHRpbGUuY29vcmRzLCB0aWxlLnNvdXJjZSk7XG4gICAgICAgIGxldCBrZXkgPSB0aWxlLmNvb3Jkcy5rZXk7XG5cbiAgICAgICAgaWYgKHNvdXJjZV90aWxlcykge1xuICAgICAgICAgICAgc291cmNlX3RpbGVzLmRlbGV0ZSh0aWxlLnN0eWxlX3pvb20pO1xuICAgICAgICAgICAgaWYgKHNvdXJjZV90aWxlcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHNvdXJjZVxuICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzW2tleV0uc291cmNlcy5kZWxldGUodGlsZS5zb3VyY2UubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29vcmRzW2tleV0uc291cmNlcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvb3Jkc1trZXldLnNvdXJjZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29vcmRzW2tleV0uZGVzY2VuZGFudHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB3aG9sZSBjb29yZFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29vcmRzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWNyZW1lbnQgcmVmZXJlbmNlIGNvdW50IHVwIHRoZSB0aWxlIHB5cmFtaWRcbiAgICAgICAgZm9yIChsZXQgeiA9IHRpbGUuY29vcmRzLnogLSAxOyB6ID49IDA7IHotLSkge1xuICAgICAgICAgICAgbGV0IGRvd24gPSBUaWxlLmNvb3JkaW5hdGVBdFpvb20odGlsZS5jb29yZHMsIHopO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29vcmRzW2Rvd24ua2V5XSAmJiB0aGlzLmNvb3Jkc1tkb3duLmtleV0uZGVzY2VuZGFudHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb29yZHNbZG93bi5rZXldLmRlc2NlbmRhbnRzLS07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29vcmRzW2Rvd24ua2V5XS5kZXNjZW5kYW50cyA9PT0gMCAmJiAhdGhpcy5jb29yZHNbZG93bi5rZXldLnNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29vcmRzW2Rvd24ua2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0QW5jZXN0b3IgKHsgY29vcmRzLCBzdHlsZV96b29tLCBzb3VyY2UgfSkge1xuICAgICAgICAvLyBGaXJzdCBjaGVjayBvdmVyem9vbWVkIHRpbGVzIGF0IHNhbWUgY29vcmRpbmF0ZSB6b29tXG4gICAgICAgIGlmIChzdHlsZV96b29tID4gc291cmNlLm1heF96b29tKSB7XG4gICAgICAgICAgICBsZXQgc291cmNlX3RpbGVzID0gdGhpcy5zb3VyY2VUaWxlcyhjb29yZHMsIHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoc291cmNlX3RpbGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeiA9IHN0eWxlX3pvb20gLSAxOyB6ID49IHNvdXJjZS5tYXhfem9vbTsgei0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VfdGlsZXMuaGFzKHopICYmIHNvdXJjZV90aWxlcy5nZXQoeikubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlX3RpbGVzLmdldCh6KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlX3pvb20gPSBzb3VyY2UubWF4X3pvb207XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayB0aWxlcyBhdCBuZXh0IHpvb20gdXBcbiAgICAgICAgc3R5bGVfem9vbS0tO1xuICAgICAgICBsZXQgcGFyZW50ID0gVGlsZS5jb29yZGluYXRlQXRab29tKGNvb3JkcywgY29vcmRzLnogLSAxKTtcbiAgICAgICAgbGV0IHBhcmVudF90aWxlcyA9IHRoaXMuc291cmNlVGlsZXMocGFyZW50LCBzb3VyY2UpO1xuICAgICAgICBpZiAocGFyZW50X3RpbGVzICYmIHBhcmVudF90aWxlcy5oYXMoc3R5bGVfem9vbSkgJiYgcGFyZW50X3RpbGVzLmdldChzdHlsZV96b29tKS5sb2FkZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRfdGlsZXMuZ2V0KHN0eWxlX3pvb20pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpZG4ndCBmaW5kIGFuY2VzdG9yLCB0cnkgbmV4dCBsZXZlbFxuICAgICAgICAvLyBUT0RPOiBtYXggZGVwdGggbGV2ZWxzIHRvIGNoZWNrXG4gICAgICAgIGlmIChwYXJlbnQueiA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFuY2VzdG9yKHsgY29vcmRzOiBwYXJlbnQsIHN0eWxlX3pvb20sIHNvdXJjZSB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXREZXNjZW5kYW50cyAoeyBjb29yZHMsIHN0eWxlX3pvb20sIHNvdXJjZSB9LCBsZXZlbCA9IDEpIHtcbiAgICAgICAgbGV0IGRlc2NlbmRhbnRzID0gW107XG5cbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgb3Zlcnpvb21lZCB0aWxlcyBhdCBzYW1lIGNvb3JkaW5hdGUgem9vbVxuICAgICAgICBpZiAoc3R5bGVfem9vbSA+PSBzb3VyY2UubWF4X3pvb20pIHtcbiAgICAgICAgICAgIGxldCBzb3VyY2VfdGlsZXMgPSB0aGlzLnNvdXJjZVRpbGVzKGNvb3Jkcywgc291cmNlKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VfdGlsZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VhcmNoX21heF96b29tID0gTWF0aC5tYXgoR2VvLmRlZmF1bHRfdmlld19tYXhfem9vbSwgc3R5bGVfem9vbSArIHRoaXMubWF4X3Byb3h5X2Rlc2NlbmRhbnRfZGVwdGgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHogPSBzdHlsZV96b29tICsgMTsgeiA8PSBzZWFyY2hfbWF4X3pvb207IHorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlX3RpbGVzLmhhcyh6KSAmJiBzb3VyY2VfdGlsZXMuZ2V0KHopLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY2VuZGFudHMucHVzaChzb3VyY2VfdGlsZXMuZ2V0KHopKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjZW5kYW50cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXNjZW5kYW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRpbGVzIGF0IG5leHQgem9vbSBkb3duXG4gICAgICAgIGlmICh0aGlzLmNvb3Jkc1tjb29yZHMua2V5XSAmJiB0aGlzLmNvb3Jkc1tjb29yZHMua2V5XS5kZXNjZW5kYW50cyA+IDApIHtcbiAgICAgICAgICAgIHN0eWxlX3pvb20rKztcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIFRpbGUuY2hpbGRyZW5Gb3JDb29yZGluYXRlKGNvb3JkcykpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRfdGlsZXMgPSB0aGlzLnNvdXJjZVRpbGVzKGNoaWxkLCBzb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZF90aWxlcyAmJiBjaGlsZF90aWxlcy5oYXMoc3R5bGVfem9vbSkgJiYgY2hpbGRfdGlsZXMuZ2V0KHN0eWxlX3pvb20pLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjZW5kYW50cy5wdXNoKGNoaWxkX3RpbGVzLmdldChzdHlsZV96b29tKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRpZG4ndCBmaW5kIGNoaWxkLCB0cnkgbmV4dCBsZXZlbFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxldmVsIDw9IHRoaXMubWF4X3Byb3h5X2Rlc2NlbmRhbnRfZGVwdGggJiYgY2hpbGQueiA8PSBzb3VyY2UubWF4X3pvb20pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY2VuZGFudHMucHVzaCguLi50aGlzLmdldERlc2NlbmRhbnRzKHsgY29vcmRzOiBjaGlsZCwgc291cmNlLCBzdHlsZV96b29tIH0sIGxldmVsICsgMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjZW5kYW50cztcbiAgICB9XG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVQeXJhbWlkO1xuIiwiXG5cbmV4cG9ydCBjbGFzcyBNZXRob2ROb3RJbXBsZW1lbnRlZCBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2ROYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSAgICA9ICdNZXRob2ROb3RJbXBsZW1lbnRlZCc7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9ICdNZXRob2QgJyArIG1ldGhvZE5hbWUgKyAnIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3MnO1xuICAgIH1cbn1cbiIsIi8vIFBhcnRpYWwgaW1wb3J0IG9mIGdsLW1hdHJpeCB2aWEgbW9kdWxhcml6ZWQgc3RhY2stZ2wgZm9ya3Ncbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL2dsLW1hdHJpeFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3N0YWNrZ2xcblxuLy8gdmVjM1xuXG4vLyBTdWJzdGl0dXRlIDY0LWJpdCB2ZXJzaW9uXG4vLyBXZSBuZWVkIHRoZSBleHRyYSBwcmVjaXNpb24gd2hlbiBtdWx0aXBseWluZyBtYXRyaWNlcyB3L21lcmNhdG9yIHByb2plY3RlZCB2YWx1ZXNcbmNvbnN0IHZlYzMgPSB7XG4gICAgZnJvbVZhbHVlcyAoeCwgeSwgeikge1xuICAgICAgICB2YXIgb3V0ID0gbmV3IEZsb2F0NjRBcnJheSgzKTtcbiAgICAgICAgb3V0WzBdID0geDtcbiAgICAgICAgb3V0WzFdID0geTtcbiAgICAgICAgb3V0WzJdID0gejtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG59O1xuXG5cbi8vIG1hdDNcblxuaW1wb3J0IHtkZWZhdWx0IGFzIG1hdDNfbm9ybWFsRnJvbU1hdDR9IGZyb20gJ2dsLW1hdDMvbm9ybWFsLWZyb20tbWF0NCc7XG5pbXBvcnQge2RlZmF1bHQgYXMgbWF0M19pbnZlcnR9IGZyb20gJ2dsLW1hdDMvaW52ZXJ0JztcblxuY29uc3QgbWF0MyA9IHtcbiAgICBub3JtYWxGcm9tTWF0NDogbWF0M19ub3JtYWxGcm9tTWF0NCxcbiAgICBpbnZlcnQ6IG1hdDNfaW52ZXJ0XG59O1xuXG5cbi8vIG1hdDRcblxuaW1wb3J0IHtkZWZhdWx0IGFzIG1hdDRfbXVsdGlwbHl9IGZyb20gJ2dsLW1hdDQvbXVsdGlwbHknO1xuaW1wb3J0IHtkZWZhdWx0IGFzIG1hdDRfdHJhbnNsYXRlfSBmcm9tICdnbC1tYXQ0L3RyYW5zbGF0ZSc7XG5pbXBvcnQge2RlZmF1bHQgYXMgbWF0NF9zY2FsZX0gZnJvbSAnZ2wtbWF0NC9zY2FsZSc7XG5pbXBvcnQge2RlZmF1bHQgYXMgbWF0NF9wZXJzcGVjdGl2ZX0gZnJvbSAnZ2wtbWF0NC9wZXJzcGVjdGl2ZSc7XG5pbXBvcnQge2RlZmF1bHQgYXMgbWF0NF9sb29rQXR9IGZyb20gJ2dsLW1hdDQvbG9va0F0JztcbmltcG9ydCB7ZGVmYXVsdCBhcyBtYXQ0X2lkZW50aXR5fSBmcm9tICdnbC1tYXQ0L2lkZW50aXR5JztcbmltcG9ydCB7ZGVmYXVsdCBhcyBtYXQ0X2NvcHl9IGZyb20gJ2dsLW1hdDQvY29weSc7XG5cbmNvbnN0IG1hdDQgPSB7XG4gICAgbXVsdGlwbHk6IG1hdDRfbXVsdGlwbHksXG4gICAgdHJhbnNsYXRlOiBtYXQ0X3RyYW5zbGF0ZSxcbiAgICBzY2FsZTogbWF0NF9zY2FsZSxcbiAgICBwZXJzcGVjdGl2ZTogbWF0NF9wZXJzcGVjdGl2ZSxcbiAgICBsb29rQXQ6IG1hdDRfbG9va0F0LFxuICAgIGlkZW50aXR5OiBtYXQ0X2lkZW50aXR5LFxuICAgIGNvcHk6IG1hdDRfY29weVxufTtcblxuXG5leHBvcnQge3ZlYzMsIG1hdDMsIG1hdDR9O1xuIiwiLy8gRGVlcC9yZWN1cnNpdmUgbWVyZ2Ugb2Ygb25lIG9yIG1vcmUgc291cmNlIG9iamVjdHMgaW50byBhIGRlc3RpbmF0aW9uIG9iamVjdFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VPYmplY3RzIChkZXN0LCAuLi5zb3VyY2VzKSB7XG4gICAgZm9yIChsZXQgcz0wOyBzIDwgc291cmNlcy5sZW5ndGg7IHMrKykge1xuICAgICAgICBsZXQgc291cmNlID0gc291cmNlc1tzXTtcbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2UgdGhlIHNvdXJjZSBpbnRvIHRoZSBkZXN0aW5hdGlvbiBpZiBpdCBpcyBhIGEgbm9uLW51bGwga2V5L3ZhbHVlIG9iamVjdFxuICAgICAgICAgICAgLy8gKGUuZy4gZG9uJ3QgbWVyZ2UgYXJyYXlzLCB0aG9zZSBhcmUgdHJlYXRlZCBhcyBzY2FsYXIgdmFsdWVzOyBudWxsIHZhbHVlcyB3aWxsIG92ZXJ3cml0ZS9lcmFzZVxuICAgICAgICAgICAgLy8gdGhlIHByZXZpb3VzIGRlc3RpbmF0aW9uIHZhbHVlKVxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZGVzdFtrZXldID0gbWVyZ2VPYmplY3RzKGRlc3Rba2V5XSB8fCB7fSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3ZlcndyaXRlIHRoZSBwcmV2aW91cyBkZXN0aW5hdGlvbiB2YWx1ZSBpZiB0aGUgc291cmNlIHByb3BlcnR5IGlzOiBhIHNjYWxhciAobnVtYmVyL3N0cmluZyksXG4gICAgICAgICAgICAvLyBhbiBhcnJheSwgb3IgYSBudWxsIHZhbHVlXG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVzdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmRlZmluZWQgc291cmNlIHByb3BlcnRpZXMgYXJlIGlnbm9yZWRcbiAgICAgICAgfVxuXG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuIiwiaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPQkIge1xuXG4gICAgY29uc3RydWN0b3IgKHgsIHksIGEsIHcsIGgpIHtcbiAgICAgICAgdGhpcy5kaW1lbnNpb24gPSBbdywgaF07XG4gICAgICAgIHRoaXMuYW5nbGUgPSBhO1xuICAgICAgICB0aGlzLmNlbnRyb2lkID0gW3gsIHldO1xuICAgICAgICB0aGlzLnF1YWQgPSBbXTtcbiAgICAgICAgdGhpcy5heGVzID0gW107XG5cbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBtb3ZlIChweCwgcHkpIHtcbiAgICBcdHRoaXMuY2VudHJvaWQgPSBbcHgsIHB5XTtcblxuICAgIFx0dGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBnZXRFeHRlbnQgKCkge1xuICAgIFx0bGV0IGluZiA9IDFlNjtcbiAgICBcdGxldCBhYWJiID0gW2luZiwgaW5mLCAtaW5mLCAtaW5mXTtcblxuICAgIFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICAgIGFhYmJbMF0gPSBNYXRoLm1pbih0aGlzLnF1YWRbaV1bMF0sIGFhYmJbMF0pO1xuICAgICAgICAgICAgYWFiYlsxXSA9IE1hdGgubWluKHRoaXMucXVhZFtpXVsxXSwgYWFiYlsxXSk7XG4gICAgICAgICAgICBhYWJiWzJdID0gTWF0aC5tYXgodGhpcy5xdWFkW2ldWzBdLCBhYWJiWzJdKTtcbiAgICAgICAgICAgIGFhYmJbM10gPSBNYXRoLm1heCh0aGlzLnF1YWRbaV1bMV0sIGFhYmJbM10pO1xuICAgIFx0fVxuXG4gICAgXHRyZXR1cm4gYWFiYjtcbiAgICB9XG5cbiAgICBwZXJwQXhlcyAoKSB7XG4gICAgXHR0aGlzLmF4ZXNbMF0gPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5zdWIodGhpcy5xdWFkWzJdLCB0aGlzLnF1YWRbM10pKTtcbiAgICBcdHRoaXMuYXhlc1sxXSA9IFZlY3Rvci5ub3JtYWxpemUoVmVjdG9yLnN1Yih0aGlzLnF1YWRbMl0sIHRoaXMucXVhZFsxXSkpO1xuICAgIH1cblxuICAgIHVwZGF0ZSAoKSB7XG4gICAgXHRsZXQgeCA9IFsgTWF0aC5jb3ModGhpcy5hbmdsZSksIE1hdGguc2luKHRoaXMuYW5nbGUpXTtcbiAgICBcdGxldCB5ID0gWy1NYXRoLnNpbih0aGlzLmFuZ2xlKSwgTWF0aC5jb3ModGhpcy5hbmdsZSldO1xuXG4gICAgXHR4ID0gVmVjdG9yLm11bHQoeCwgdGhpcy5kaW1lbnNpb25bMF0gLyAyLjApO1xuICAgIFx0eSA9IFZlY3Rvci5tdWx0KHksIHRoaXMuZGltZW5zaW9uWzFdIC8gMi4wKTtcblxuICAgIFx0dGhpcy5xdWFkWzBdID0gVmVjdG9yLnN1YihWZWN0b3Iuc3ViKHRoaXMuY2VudHJvaWQsIHgpLCB5KTsgLy8gbG93ZXItbGVmdFxuICAgIFx0dGhpcy5xdWFkWzFdID0gVmVjdG9yLnN1YihWZWN0b3IuYWRkKHRoaXMuY2VudHJvaWQsIHgpLCB5KTsgLy8gbG93ZXItcmlnaHRcbiAgICBcdHRoaXMucXVhZFsyXSA9IFZlY3Rvci5hZGQoVmVjdG9yLmFkZCh0aGlzLmNlbnRyb2lkLCB4KSwgeSk7IC8vIHVwZXItcmlnaHRcbiAgICBcdHRoaXMucXVhZFszXSA9IFZlY3Rvci5hZGQoVmVjdG9yLnN1Yih0aGlzLmNlbnRyb2lkLCB4KSwgeSk7IC8vIHVwZXItbGVmdFxuXG4gICAgXHR0aGlzLnBlcnBBeGVzKCk7XG4gICAgfVxuXG4gICAgc3RhdGljIHByb2plY3RUb0F4aXMgKG9iYiwgYXhpcykge1xuICAgIFx0bGV0IGluZiA9IDFlNjtcbiAgICBcdGxldCBtaW4gPSBpbmY7XG4gICAgXHRsZXQgbWF4ID0gLWluZjtcblxuICAgIFx0bGV0IHF1YWQgPSBvYmIucXVhZDtcblxuICAgIFx0Ly8gZm9yIGVhY2ggYXhpcywgcHJvamVjdCBvYmIgcXVhZCB0byBpdCBhbmQgZmluZCBtaW4gYW5kIG1heCB2YWx1ZXNcbiAgICBcdGZvciAobGV0IGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgZCA9ICBWZWN0b3IuZG90KHF1YWRbaV0sIGF4aXMpO1xuICAgICAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBkKTtcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZCk7XG4gICAgXHR9XG5cbiAgICBcdHJldHVybiBbbWluLCBtYXhdO1xuICAgIH1cblxuICAgIHN0YXRpYyBheGlzQ29sbGlkZSAob2JiX2EsIG9iYl9iLCBheGVzKSB7XG4gICAgXHRmb3IgKGxldCBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgIFx0XHRsZXQgYV9wcm9qID0gT0JCLnByb2plY3RUb0F4aXMob2JiX2EsIGF4ZXNbaV0pO1xuICAgIFx0XHRsZXQgYl9wcm9qID0gT0JCLnByb2plY3RUb0F4aXMob2JiX2IsIGF4ZXNbaV0pO1xuXG4gICAgXHRcdGlmIChiX3Byb2pbMF0gPiBhX3Byb2pbMV0gfHwgYl9wcm9qWzFdIDwgYV9wcm9qWzBdKSB7XG4gICAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICAgIFx0XHR9XG4gICAgXHR9XG4gICAgXHRyZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaW50ZXJzZWN0KG9iYl9hLCBvYmJfYikge1xuICAgIFx0cmV0dXJuIE9CQi5heGlzQ29sbGlkZShvYmJfYSwgb2JiX2IsIG9iYl9hLmF4ZXMpICYmIE9CQi5heGlzQ29sbGlkZShvYmJfYSwgb2JiX2IsIG9iYl9iLmF4ZXMpO1xuICAgIH1cblxufVxuXG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdWJzY3JpYmVNaXhpbiAodGFyZ2V0KSB7XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgIC8vIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHRhcmdldCwge1xuXG4gICAgICAgIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgICAgICAgICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgICAgICAgICAvLyBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5zdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgICAgICAgLy8gdmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgLy8gaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIC8vICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bnN1YnNjcmliZUFsbCgpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5jbGVhcigpO1xuICAgICAgICAgICAgLy8gbGlzdGVuZXJzID0gW107XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJpZ2dlcihldmVudCwgLi4uZGF0YSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcltldmVudF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJbZXZlbnRdKC4uLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbn1cbiIsIi8vIE1pc2NlbGxhbmVvdXMgdXRpbGl0aWVzXG4vKmpzaGludCB3b3JrZXI6IHRydWUqL1xuXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB5YW1sIGZyb20gJ2pzLXlhbWwnO1xuaW1wb3J0IEdlbyBmcm9tICcuLi9nZW8nO1xuXG52YXIgVXRpbHM7XG5leHBvcnQgZGVmYXVsdCBVdGlscyA9IHt9O1xuXG4vLyBBZGQgYSBiYXNlIFVSTCBmb3Igc2NoZW1lbGVzcyBvciBwcm90b2NvbC1sZXNzIFVSTHNcbi8vIERlZmF1bHRzIHRvIGFkZGluZyBjdXJyZW50IHdpbmRvdyBwcm90b2NvbCBhbmQgYmFzZSwgb3IgYWRkcyBhIGN1c3RvbSBiYXNlIGlmIHNwZWNpZmllZFxuLy8gTWF5YmUgdXNlIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvVVJJLmpzIGlmIG1vcmUgcm9idXN0IGZ1bmN0aW9uYWxpdHkgaXMgbmVlZGVkXG5VdGlscy5hZGRCYXNlVVJMID0gZnVuY3Rpb24gKHVybCwgYmFzZSkge1xuICAgIGlmICghdXJsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTY2hlbWVsZXNzLCBhZGQgcHJvdG9jb2xcbiAgICBpZiAodXJsLnN1YnN0cigwLCAyKSA9PT0gJy8vJykge1xuICAgICAgICB1cmwgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyB1cmw7XG4gICAgfVxuICAgIC8vIE5vIGh0dHAocykgb3IgZGF0YSwgYWRkIGJhc2VcbiAgICBlbHNlIGlmICh1cmwuc2VhcmNoKC9eKGh0dHB8aHR0cHN8ZGF0YXxibG9iKTovKSA8IDApIHtcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gKHVybFswXSAhPT0gJy8nKTtcbiAgICAgICAgdmFyIGJhc2VfaW5mbztcbiAgICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgICAgIGJhc2VfaW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTsgLy8gdXNlIGEgdGVtcG9yYXJ5IGVsZW1lbnQgdG8gcGFyc2UgVVJMXG4gICAgICAgICAgICBiYXNlX2luZm8uaHJlZiA9IGJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiYXNlX2luZm8gPSB3aW5kb3cubG9jYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgICAgIGxldCBwYXRoID0gYmFzZV9pbmZvLmhyZWYubWF0Y2goLyhbXlxcI10rKS8pOyAvLyBzdHJpcCBoYXNoXG4gICAgICAgICAgICBwYXRoID0gKHBhdGggJiYgcGF0aC5sZW5ndGggPiAxKSA/IHBhdGhbMF0gOiAnJztcbiAgICAgICAgICAgIHVybCA9IHBhdGggKyB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBFYXN5IHdheVxuICAgICAgICAgICAgaWYgKGJhc2VfaW5mby5vcmlnaW4pIHtcbiAgICAgICAgICAgICAgICB1cmwgPSBiYXNlX2luZm8ub3JpZ2luICsgJy8nICsgdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFyZCB3YXkgKElFMTEpXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gdXJsLm1hdGNoKC9eKChodHRwfGh0dHBzfGRhdGF8YmxvYik6XFwvXFwvW15cXC9dKlxcLykvKTtcbiAgICAgICAgICAgICAgICBvcmlnaW4gPSAob3JpZ2luICYmIG9yaWdpbi5sZW5ndGggPiAxKSA/IG9yaWdpblswXSA6ICcnO1xuICAgICAgICAgICAgICAgIHVybCA9IG9yaWdpbiArIHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufTtcblxuVXRpbHMucGF0aEZvclVSTCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBpZiAodXJsICYmIHVybC5zZWFyY2goL14oZGF0YXxibG9iKTovKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHVybC5zdWJzdHIoMCwgdXJsLmxhc3RJbmRleE9mKCcvJykgKyAxKSB8fCAnLi8nO1xuICAgIH1cbiAgICByZXR1cm4gJy4vJztcbn07XG5cblV0aWxzLmNhY2hlQnVzdGVyRm9yVXJsID0gZnVuY3Rpb24gKHVybCkge1xuICAgIGlmICh1cmwuc2VhcmNoKC9eKGRhdGF8YmxvYik6LykgPiAtMSkge1xuICAgICAgICByZXR1cm4gdXJsOyAvLyBubyBjYWNoZS1idXN0aW5nIG9uIG9iamVjdCBvciBkYXRhIFVSTHNcbiAgICB9XG4gICAgaWYgKHVybC5pbmRleE9mKCc/JykgPiAtMSkge1xuICAgICAgICB1cmwgKz0gJyYnICsgKCtuZXcgRGF0ZSgpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVybCArPSAnPycgKyAoK25ldyBEYXRlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufTtcblxuLy8gQWRkIGEgc2V0IG9mIHF1ZXJ5IHN0cmluZyBwYXJhbXMgdG8gYSBVUkxcbi8vIHBhcmFtczogaGFzaCBvZiBrZXkvdmFsdWUgcGFpcnMgb2YgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnNcblV0aWxzLmFkZFBhcmFtc1RvVVJMID0gZnVuY3Rpb24gKHVybCwgcGFyYW1zKSB7XG4gICAgaWYgKCFwYXJhbXMgfHwgT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG5cbiAgICB2YXIgcXNfaW5kZXggPSB1cmwuaW5kZXhPZignPycpO1xuICAgIHZhciBoYXNoX2luZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcblxuICAgIC8vIFNhdmUgYW5kIHRyaW0gaGFzaFxuICAgIHZhciBoYXNoID0gJyc7XG4gICAgaWYgKGhhc2hfaW5kZXggPiAtMSkge1xuICAgICAgICBoYXNoID0gdXJsLnNsaWNlKGhhc2hfaW5kZXgpO1xuICAgICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaF9pbmRleCk7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgcXVlcnkgc3RyaW5nXG4gICAgaWYgKHFzX2luZGV4ID09PSAtMSkge1xuICAgICAgICBxc19pbmRleCA9IHVybC5sZW5ndGg7XG4gICAgICAgIHVybCArPSAnPyc7XG4gICAgfVxuICAgIHFzX2luZGV4Kys7IC8vIGFkdmFuY2VkIHBhc3QgJz8nXG5cbiAgICAvLyBCdWlsZCBxdWVyeSBzdHJpbmcgcGFyYW1zXG4gICAgdmFyIHVybF9wYXJhbXMgPSAnJztcbiAgICBmb3IgKHZhciBwIGluIHBhcmFtcykge1xuICAgICAgICB1cmxfcGFyYW1zICs9IGAke3B9PSR7cGFyYW1zW3BdfSZgO1xuICAgIH1cblxuICAgIC8vIEluc2VydCBuZXcgcXVlcnkgc3RyaW5nIHBhcmFtcyBhbmQgcmVzdG9yZSBoYXNoXG4gICAgLy8gTk9URTogZG9lc24ndCByZXBsYWNlIGFueSB2YWx1ZXMgYWxyZWFkeSBwcmVzZW50IG9uIHF1ZXJ5IHN0cmluZywganVzdCBpbnNlcnRzIGR1cGUgdmFsdWVzXG4gICAgdXJsID0gdXJsLnNsaWNlKDAsIHFzX2luZGV4KSArIHVybF9wYXJhbXMgKyB1cmwuc2xpY2UocXNfaW5kZXgpICsgaGFzaDtcblxuICAgIHJldHVybiB1cmw7XG59O1xuXG4vLyBQb2x5ZmlsbCAoZm9yIFNhZmFyaSBjb21wYXRpYmlsaXR5KVxuVXRpbHMuX2NyZWF0ZU9iamVjdFVSTCA9IHVuZGVmaW5lZDtcblV0aWxzLmNyZWF0ZU9iamVjdFVSTCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBpZiAoVXRpbHMuX2NyZWF0ZU9iamVjdFVSTCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIFV0aWxzLl9jcmVhdGVPYmplY3RVUkwgPSAod2luZG93LlVSTCAmJiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTCkgfHwgKHdpbmRvdy53ZWJraXRVUkwgJiYgd2luZG93LndlYmtpdFVSTC5jcmVhdGVPYmplY3RVUkwpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgVXRpbHMuX2NyZWF0ZU9iamVjdFVSTCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgVXRpbHMuX2NyZWF0ZU9iamVjdFVSTCA9IG51bGw7XG4gICAgICAgICAgICBsb2cud2Fybihgd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwgKG9yIHZlbmRvciBwcmVmaXgpIG5vdCBmb3VuZCwgdW5hYmxlIHRvIGNyZWF0ZSBsb2NhbCBibG9iIFVSTHNgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChVdGlscy5fY3JlYXRlT2JqZWN0VVJMKSB7XG4gICAgICAgIHJldHVybiBVdGlscy5fY3JlYXRlT2JqZWN0VVJMKHVybCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbn07XG5cblV0aWxzLmlvID0gZnVuY3Rpb24gKHVybCwgdGltZW91dCA9IDYwMDAwLCByZXNwb25zZVR5cGUgPSAndGV4dCcsIG1ldGhvZCA9ICdHRVQnLCBoZWFkZXJzID0ge30pIHtcbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICByZXF1ZXN0Lm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgICAgICByZXF1ZXN0LnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIGlmIChbJ3RleHQnLCAnanNvbiddLmluZGV4T2YocmVxdWVzdC5yZXNwb25zZVR5cGUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KEVycm9yKCdSZXF1ZXN0IGVycm9yIHdpdGggYSBzdGF0dXMgb2YgJyArIHJlcXVlc3Quc3RhdHVzVGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICByZWplY3QoRXJyb3IoJ1RoZXJlIHdhcyBhIG5ldHdvcmsgZXJyb3InICsgZXZ0LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICByZWplY3QoRXJyb3IoJ3RpbWVvdXQgJysgZXZ0LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgJ3JlcXVlc3QnLCB7XG4gICAgICAgIHZhbHVlOiByZXF1ZXN0XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cblV0aWxzLnBhcnNlUmVzb3VyY2UgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgIHZhciBkYXRhO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIGpzeWFtbCAnanNvbicgb3B0aW9uIGFsbG93cyBkdXBsaWNhdGUga2V5c1xuICAgICAgICAvLyBLZWVwaW5nIHRoaXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBidXQgc2hvdWxkIGNvbnNpZGVyIG1pZ3JhdGluZyB0byByZXF1aXJpbmdcbiAgICAgICAgLy8gdW5pcXVlIGtleXMsIGFzIHRoaXMgaXMgWUFNTCBzcGVjLiBCdXQgVGFuZ3JhbSBFUyBjdXJyZW50bHkgYWNjZXB0cyBkdXBlIGtleXMgYXMgd2VsbCxcbiAgICAgICAgLy8gc28gc2hvdWxkIGNvbnNpZGVyIGhvdyBiZXN0IHRvIHVuaWZ5LlxuICAgICAgICBkYXRhID0geWFtbC5zYWZlTG9hZChib2R5LCB7IGpzb246IHRydWUgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn07XG5cblV0aWxzLmxvYWRSZXNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIFV0aWxzLmlvKFV0aWxzLmNhY2hlQnVzdGVyRm9yVXJsKHNvdXJjZSkpLnRoZW4oKGJvZHkpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IFV0aWxzLnBhcnNlUmVzb3VyY2UoYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8vIE5lZWRlZCBmb3Igb2xkZXIgYnJvd3NlcnMgdGhhdCBzdGlsbCBzdXBwb3J0IFdlYkdMIChTYWZhcmkgNiBldGMuKVxuVXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lUG9seWZpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPVxuICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICB8fFxuICAgICAgICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICB8fFxuICAgICAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgMTAwMCAvNjApO1xuICAgICAgICAgICAgfTtcbiAgICB9XG59O1xuXG4vLyBTdHJpbmdpZnkgYW4gb2JqZWN0IGludG8gSlNPTiwgYnV0IGNvbnZlcnQgZnVuY3Rpb25zIHRvIHN0cmluZ3NcblV0aWxzLnNlcmlhbGl6ZVdpdGhGdW5jdGlvbnMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeShvYmosIGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgICAgLy8gQ29udmVydCBmdW5jdGlvbnMgdG8gc3RyaW5nc1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn07XG5cbi8vIFBhcnNlIGEgSlNPTiBzdHJpbmcsIGJ1dCBjb252ZXJ0IGZ1bmN0aW9uLWxpa2Ugc3RyaW5ncyBiYWNrIGludG8gZnVuY3Rpb25zXG5VdGlscy5kZXNlcmlhbGl6ZVdpdGhGdW5jdGlvbnMgPSBmdW5jdGlvbihzZXJpYWxpemVkLCB3cmFwKSB7XG4gICAgdmFyIG9iaiA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgb2JqID0gVXRpbHMuc3RyaW5nc1RvRnVuY3Rpb25zKG9iaiwgd3JhcCk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbi8vIFJlY3Vyc2l2ZWx5IHBhcnNlIGFuIG9iamVjdCwgYXR0ZW1wdGluZyB0byBjb252ZXJ0IHN0cmluZyBwcm9wZXJ0aWVzIHRoYXQgbG9vayBsaWtlIGZ1bmN0aW9ucyBiYWNrIGludG8gZnVuY3Rpb25zXG5VdGlscy5zdHJpbmdzVG9GdW5jdGlvbnMgPSBmdW5jdGlvbihvYmosIHdyYXApIHtcbiAgICAvLyBDb252ZXJ0IHN0cmluZ1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICBvYmogPSBVdGlscy5zdHJpbmdUb0Z1bmN0aW9uKG9iaiwgd3JhcCk7XG4gICAgfVxuICAgIC8vIExvb3AgdGhyb3VnaCBvYmplY3QgcHJvcGVydGllc1xuICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAobGV0IHAgaW4gb2JqKSB7XG4gICAgICAgICAgICBvYmpbcF0gPSBVdGlscy5zdHJpbmdzVG9GdW5jdGlvbnMob2JqW3BdLCB3cmFwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufTtcblxuLy8gQ29udmVydCBzdHJpbmcgYmFjayBpbnRvIGEgZnVuY3Rpb25cbi8vIFRPRE86IG1ha2UgZnVuY3Rpb24gbWF0Y2hpbmcgdG9sZXJhbnQgb2Ygd2hpdGVzcGFjZSBhbmQgbXVsdGlsaW5lc1xuVXRpbHMuc3RyaW5nVG9GdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbCwgd3JhcCkge1xuICAgIC8vIENvbnZlcnQgc3RyaW5ncyBiYWNrIGludG8gZnVuY3Rpb25zXG4gICAgaWYgKHZhbC5tYXRjaCgvXlxccypmdW5jdGlvblxccypcXHcqXFxzKlxcKFtcXHNcXFNdKlxcKVxccypcXHtbXFxzXFxTXSpcXH0vbSkgIT0gbnVsbCkge1xuICAgICAgICB2YXIgZjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd3JhcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGV2YWwoJ2YgPSAnICsgd3JhcCh2YWwpKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmFsKCdmID0gJyArIHZhbCk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGZhbGwtYmFjayB0byBvcmlnaW5hbCB2YWx1ZSBpZiBwYXJzaW5nIGZhaWxlZFxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufTtcblxuLy8gTG9nIHdyYXBwZXIsIHNlbmRzIG1lc3NhZ2UgdG8gbWFpbiB0aHJlYWQgZm9yIGRpc3BsYXksIGFuZCBpbmNsdWRlcyB3b3JrZXIgaWQgI1xuVXRpbHMubG9nID0gZnVuY3Rpb24gKGxldmVsLCAuLi5tc2cpIHtcbiAgICBsZXZlbCA9IGxldmVsIHx8ICdpbmZvJztcbiAgICBpZiAoVXRpbHMuaXNXb3JrZXJUaHJlYWQpIHtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB0eXBlOiAnbG9nJyxcbiAgICAgICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgICAgIHdvcmtlcl9pZDogc2VsZi5fd29ya2VyX2lkLFxuICAgICAgICAgICAgbXNnOiBtc2dcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbG9nW2xldmVsXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsb2dbbGV2ZWxdKC4uLm1zZyk7XG4gICAgfVxufTtcblxuLy8gRGVmYXVsdCB0byBhbGxvd2luZyBoaWdoIHBpeGVsIGRlbnNpdHlcbi8vIFJldHVybnMgdHJ1ZSBpZiBkaXNwbGF5IGRlbnNpdHkgY2hhbmdlZFxuVXRpbHMudXNlX2hpZ2hfZGVuc2l0eV9kaXNwbGF5ID0gdHJ1ZTtcblV0aWxzLnVwZGF0ZURldmljZVBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHByZXYgPSBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW87XG4gICAgVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvID0gKFV0aWxzLnVzZV9oaWdoX2RlbnNpdHlfZGlzcGxheSAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgfHwgMTtcbiAgICByZXR1cm4gVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvICE9PSBwcmV2O1xufTtcblxuLy8gTWFyayB0aHJlYWQgYXMgbWFpbiBvciB3b3JrZXJcbihmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAod2luZG93LmRvY3VtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFV0aWxzLmlzV29ya2VyVGhyZWFkID0gZmFsc2U7XG4gICAgICAgICAgICBVdGlscy5pc01haW5UaHJlYWQgICA9IHRydWU7XG4gICAgICAgICAgICBVdGlscy51cGRhdGVEZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHNlbGYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgVXRpbHMuaXNXb3JrZXJUaHJlYWQgPSB0cnVlO1xuICAgICAgICAgICAgVXRpbHMuaXNNYWluVGhyZWFkICAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn0pKCk7XG5cbi8vIEdldCBVUkwgdGhhdCB0aGUgY3VycmVudCBzY3JpcHQgd2FzIGxvYWRlZCBmcm9tXG4vLyBJZiBjdXJyZW50U2NyaXB0IGlzIG5vdCBhdmFpbGFibGUsIGxvb3BzIHRocm91Z2ggPHNjcmlwdD4gZWxlbWVudHMgc2VhcmNoaW5nIGZvciBhIGxpc3Qgb2YgcHJvdmlkZWQgcGF0aHNcbi8vIGUuZy4gVXRpbHMuZmluZEN1cnJlbnRVUkwoJ3RhbmdyYW0uZGVidWcuanMnLCAndGFuZ3JhbS5taW4uanMnKTtcblV0aWxzLmZpbmRDdXJyZW50VVJMID0gZnVuY3Rpb24gKC4uLnBhdGhzKSB7XG4gICAgLy8gRmluZCBjdXJyZW50bHkgZXhlY3V0aW5nIHNjcmlwdFxuICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0O1xuICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgcmV0dXJuIHNjcmlwdC5zcmM7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGF0aHMpKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIG9uIGxvb3BpbmcgdGhyb3VnaCA8c2NyaXB0PiBlbGVtZW50cyBpZiBkb2N1bWVudC5jdXJyZW50U2NyaXB0IGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgdmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gICAgICAgIGZvciAodmFyIHM9MDsgcyA8IHNjcmlwdHMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NyaXB0c1tzXS5zcmMuaW5kZXhPZihwYXRoKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdHNbc10uc3JjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIFVzZWQgZm9yIGRpZmZlcmVudGlhdGluZyBiZXR3ZWVuIHBvd2VyLW9mLTIgYW5kIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzXG4vLyBWaWE6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTk3MjIyNDcvd2ViZ2wtd2FpdC1mb3ItdGV4dHVyZS10by1sb2FkXG5VdGlscy5pc1Bvd2VyT2YyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYgKHZhbHVlIC0gMSkpID09PSAwO1xufTtcblxuVXRpbHMubmV4dFBvd2VyT2YyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMiwgTWF0aC5jZWlsKE1hdGgubG9nMih2YWx1ZSkpKTtcbn07XG5cbi8vIEludGVycG9sYXRlICd4JyBhbG9uZyBhIHNlcmllcyBvZiBjb250cm9sIHBvaW50c1xuLy8gJ3BvaW50cycgaXMgYW4gYXJyYXkgb2YgY29udHJvbCBwb2ludHMgaW4gdGhlIGZvcm0gW3gsIHldXG4vL1xuLy8gRXhhbXBsZTpcbi8vICAgICBDb250cm9sIHBvaW50czpcbi8vICAgICAgICAgWzAsIDVdOiAgd2hlbiB4PTAsIHk9NVxuLy8gICAgICAgICBbNCwgMTBdOiB3aGVuIHg9NCwgeT0xMFxuLy9cbi8vICAgICBVdGlscy5pbnRlcnBvbGF0ZSgyLCBbWzAsIDVdLCBbNCwgMTBdXSk7XG4vLyAgICAgLT4gY29tcHV0ZXMgeD0yLCBoYWxmd2F5IGJldHdlZW4geD0wIGFuZCB4PTQ6ICgxMCAtIDUpIC8gMiArNVxuLy8gICAgIC0+IHJldHVybnMgNy41XG4vL1xuLy8gVE9ETzogYWRkIG90aGVyIGludGVycG9sYXRpb24gbWV0aG9kcyBiZXNpZGVzIGxpbmVhclxuLy9cblV0aWxzLmludGVycG9sYXRlID0gZnVuY3Rpb24oeCwgcG9pbnRzLCB0cmFuc2Zvcm0pIHtcbiAgICAvLyBJZiB0aGlzIGRvZXNuJ3QgcmVzZW1ibGUgYSBsaXN0IG9mIGNvbnRyb2wgcG9pbnRzLCBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSB8fCAhQXJyYXkuaXNBcnJheShwb2ludHNbMF0pKSB7XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBvaW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuXG4gICAgdmFyIHgxLCB4MiwgZCwgeSwgeTEsIHkyO1xuXG4gICAgLy8gTWluIGJvdW5kc1xuICAgIGlmICh4IDw9IHBvaW50c1swXVswXSkge1xuICAgICAgICB5ID0gcG9pbnRzWzBdWzFdO1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgeSA9IHRyYW5zZm9ybSh5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNYXggYm91bmRzXG4gICAgZWxzZSBpZiAoeCA+PSBwb2ludHNbcG9pbnRzLmxlbmd0aC0xXVswXSkge1xuICAgICAgICB5ID0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMV1bMV07XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB5ID0gdHJhbnNmb3JtKHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZpbmQgd2hpY2ggY29udHJvbCBwb2ludHMgeCBpcyBiZXR3ZWVuXG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh4ID49IHBvaW50c1tpXVswXSAmJiB4IDwgcG9pbnRzW2krMV1bMF0pIHtcbiAgICAgICAgICAgICAgICAvLyBMaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgICAgIHgxID0gcG9pbnRzW2ldWzBdO1xuICAgICAgICAgICAgICAgIHgyID0gcG9pbnRzW2krMV1bMF07XG5cbiAgICAgICAgICAgICAgICAvLyBNdWx0aXBsZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb2ludHNbaV1bMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYz0wOyBjIDwgcG9pbnRzW2ldWzFdLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gdHJhbnNmb3JtKHBvaW50c1tpXVsxXVtjXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB0cmFuc2Zvcm0ocG9pbnRzW2krMV1bMV1bY10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSB5MiAtIHkxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlbY10gPSBkICogKHggLSB4MSkgLyAoeDIgLSB4MSkgKyB5MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBwb2ludHNbaSsxXVsxXVtjXSAtIHBvaW50c1tpXVsxXVtjXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5W2NdID0gZCAqICh4IC0geDEpIC8gKHgyIC0geDEpICsgcG9pbnRzW2ldWzFdW2NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNpbmdsZSB2YWx1ZVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSB0cmFuc2Zvcm0ocG9pbnRzW2ldWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0gdHJhbnNmb3JtKHBvaW50c1tpKzFdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSB5MiAtIHkxO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGQgKiAoeCAtIHgxKSAvICh4MiAtIHgxKSArIHkxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHBvaW50c1tpKzFdWzFdIC0gcG9pbnRzW2ldWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGQgKiAoeCAtIHgxKSAvICh4MiAtIHgxKSArIHBvaW50c1tpXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geTtcbn07XG5cbi8vIEl0ZXJhdG9ycyAoRVM2IGdlbmVyYXRvcnMpXG5cbi8vIEl0ZXJhdG9yIGZvciBrZXkvdmFsdWUgcGFpcnMgb2YgYW4gb2JqZWN0XG5VdGlscy5lbnRyaWVzID0gZnVuY3Rpb24qIChvYmopIHtcbiAgICBmb3IgKHZhciBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICB5aWVsZCBba2V5LCBvYmpba2V5XV07XG4gICAgfVxufTtcblxuLy8gSXRlcmF0b3IgZm9yIHZhbHVlcyBvZiBhbiBvYmplY3RcblV0aWxzLnZhbHVlcyA9IGZ1bmN0aW9uKiAob2JqKSB7XG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgeWllbGQgb2JqW2tleV07XG4gICAgfVxufTtcblxuLy8gUmVjdXJzaXZlIGl0ZXJhdG9ycyBmb3IgYWxsIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LCBubyBtYXR0ZXIgaG93IGRlZXBseSBuZXN0ZWRcbi8vIFRPRE86IGZpeCBmb3IgY2lyY3VsYXIgc3RydWN0dXJlc1xuVXRpbHMucmVjdXJzZUVudHJpZXMgPSBmdW5jdGlvbiogKG9iaikge1xuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgaWYgKG9ialtrZXldKSB7XG4gICAgICAgICAgICB5aWVsZCBba2V5LCBvYmpba2V5XSwgb2JqXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIFV0aWxzLnJlY3Vyc2VFbnRyaWVzKG9ialtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblV0aWxzLnJlY3Vyc2VWYWx1ZXMgPSBmdW5jdGlvbiogKG9iaikge1xuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgaWYgKG9ialtrZXldKSB7XG4gICAgICAgICAgICB5aWVsZCBvYmpba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIFV0aWxzLnJlY3Vyc2VWYWx1ZXMob2JqW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gU2NhbGUgYSAqc2lnbmVkKiBzaG9ydCBmb3IgdXNlIGluIGEgR0wgVkJPXG4vLyBgdW5pdGAgaXMgYW4gb3B0aW9uYWwgc2NhbGluZyBmYWN0b3IgdG8gbWltaWMgZml4ZWQgcG9pbnQsIHNpbmNlIHRoZXNlIHZhbHVlcyB3aWxsIGJlXG4vLyBub3JtYWxpemVkIHRvIDAtMSwgZS5nLiBkaXZpZGUgaW5wdXQgYnkgdW5pdCBvbiB0aGUgd2F5IGluLCBtdWx0aXBseSBpdCBiYWNrIGluIHRoZSBzaGFkZXJcblV0aWxzLnNjYWxlSW50MTYgPSBmdW5jdGlvbiAodmFsLCB1bml0KSB7XG4gICAgcmV0dXJuICh2YWwgLyB1bml0KSAqIDMyNzY3O1xufTtcblxuVXRpbHMuZGVnVG9SYWQgPSBmdW5jdGlvbiAoZGVncmVlcykge1xuICAgIHJldHVybiBkZWdyZWVzICogTWF0aC5QSSAvIDE4MDtcbn07XG5cblV0aWxzLnJhZFRvRGVnID0gZnVuY3Rpb24gKHJhZGlhbnMpIHtcbiAgICByZXR1cm4gcmFkaWFucyAqIDE4MCAvIE1hdGguUEk7XG59O1xuXG5VdGlscy50b0NTU0NvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKGNvbG9yWzNdID09PSAxKSB7IC8vIGZ1bGwgb3BhY2l0eVxuICAgICAgICByZXR1cm4gYHJnYigke2NvbG9yLnNsaWNlKDAsIDMpLm1hcChjID0+IE1hdGgucm91bmQoYyAqIDI1NSkpLmpvaW4oJywgJyl9KWA7XG4gICAgfVxuICAgIC8vIFJHQiBpcyBiZXR3ZWVuIFswLCAyNTVdIG9wYWNpdHkgaXMgYmV0d2VlbiBbMCwgMV1cbiAgICByZXR1cm4gYHJnYmEoJHtjb2xvci5tYXAoKGMsIGkpID0+IChpIDwgMyAmJiBNYXRoLnJvdW5kKGMgKiAyNTUpKSB8fCBjKS5qb2luKCcsICcpfSlgO1xufTtcblxuVXRpbHMucG9pbnRJblRpbGUgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICByZXR1cm4gcG9pbnRbMF0gPj0gMCAmJsKgcG9pbnRbMV0gPiAtR2VvLnRpbGVfc2NhbGUgJiYgcG9pbnRbMF0gPCBHZW8udGlsZV9zY2FsZSAmJiBwb2ludFsxXSA8PSAwO1xufTtcblxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NjE2NDYxL2dlbmVyYXRlLWEtaGFzaC1mcm9tLXN0cmluZy1pbi1qYXZhc2NyaXB0LWpxdWVyeVxuVXRpbHMuaGFzaFN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBsZXQgaGFzaCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCBjaHIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgY2hyO1xuICAgICAgICBoYXNoIHw9IDA7XG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xufTtcblxuVXRpbHMuZGVib3VuY2UgPSBmdW5jdGlvbiAoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBsZXQgY29udGV4dCA9IHRoaXMsXG4gICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBsZXQgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4iLCJ2YXIgdmVyc2lvbjtcbmV4cG9ydCBkZWZhdWx0IHZlcnNpb24gPSB7XG4gICAgZ2V0IHN0cmluZygpIHsgcmV0dXJuIGB2JHt2ZXJzaW9uLm1ham9yfS4ke3ZlcnNpb24ubWlub3J9LiR7dmVyc2lvbi5wYXRjaH1gOyB9LFxuICAgIG1ham9yOiAwLFxuICAgIG1pbm9yOiA2LFxuICAgIHBhdGNoOiAxLFxuICAgIHByZTogZmFsc2Vcbn07XG4iLCIvKmpzaGludCB3b3JrZXI6IHRydWUqL1xuXG4vLyBXb3JrZXJCcm9rZXIgcm91dGVzIG1lc3NhZ2VzIGJldHdlZW4gd2ViIHdvcmtlcnMgYW5kIHRoZSBtYWluIHRocmVhZCwgYWxsb3dpbmcgZm9yIHNpbXBsZXJcbi8vIGFzeW5jIGNvZGUgdmlhIHByb21pc2VzLiBFeGFtcGxlIHVzYWdlOlxuLy9cbi8vIEluIHdlYiB3b3JrZXIsIHJlZ2lzdGVyIHNlbGYgYXMgdGFyZ2V0IGRlZmluZSBhIG1ldGhvZDpcbi8vXG4vLyAgICAgV29ya2VyQnJva2VyLmFkZFRhcmdldCgnc2VsZicsIHNlbGYpO1xuLy9cbi8vICAgICBzZWxmLnNxdWFyZSA9IGZ1bmN0aW9uICh4KSB7XG4vLyAgICAgICAgIHJldHVybiB4ICogeDtcbi8vICAgICB9O1xuLy9cbi8vIEluIG1haW4gdGhyZWFkLCBpbnZva2UgdGhhdCBtZXRob2QgYW5kIHJlY2VpdmUgdGhlIHJlc3VsdCAoaWYgYW55KSBhcyBhIHByb21pc2U6XG4vL1xuLy8gICAgIHdvcmtlciA9IG5ldyBXb3JrZXIoLi4uKTtcbi8vICAgICBXb3JrZXJCcm9rZXIuYWRkV29ya2VyKHdvcmtlcik7XG4vL1xuLy8gICAgIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSh3b3JrZXIsICdzZWxmLnNxdWFyZScsIDUpLnRoZW4oZnVuY3Rpb24oeSkge1xuLy8gICAgICAgICBjb25zb2xlLmxvZyh5KTtcbi8vICAgICB9KTtcbi8vXG4vLyAgICAgLT4gcHJpbnRzIDI1XG4vL1xuLy8gQXN5bmMgY29kZTpcbi8vXG4vLyBGb3Igc3luY2hyb25vdXMgY29kZSB0aGF0IG11c3QgcGFzcyBhIHJldHVybiB2YWx1ZSB0byB0aGUgbWFpbiB0aHJlYWQsIHRoZSBmdW5jdGlvbiBjYW4gc2ltcGx5XG4vLyByZXR1cm4gYW4gaW1tZWRpYXRlIHZhbHVlIChzZWUgZXhhbXBsZSBhYm92ZSkuIEZvciBjYXNlcyB3aGVyZSB0aGUgd29ya2VyIG1ldGhvZCBuZWVkcyB0byBydW5cbi8vIGFzeW5jaHJvbm91cyBjb2RlLCB0aGUgZnVuY3Rpb24gY2FuIHJldHVybiBhIHByb21pc2UsIGFuZCB0aGUgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgdmFsdWUgd2lsbFxuLy8gYmUgc2VudCBiYWNrIHRvIHRoZSBtYWluIHRocmVhZCB3aGVuIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbi8vXG4vLyBFcnJvciBoYW5kbGluZzpcbi8vXG4vLyBJZiB0aGUgd29ya2VyIG1ldGhvZCBlaXRoZXIgdGhyb3dzIGFuIGVycm9yLCBvciByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGlzIHJlamVjdGVkLCBpdCB3aWxsIGJlXG4vLyBzZW50IGJhY2sgdG8gdGhlIG1haW4gdGhyZWFkIGFzIGEgcHJvbWlzZSByZWplY3Rpb24uIFRoZXNlIHR3byBleGFtcGxlcyBhcmUgZXF1aXZhbGVudDpcbi8vXG4vLyAgICAgSW4gd29ya2VyLCB0aHJvd2luZyBhbiBlcnJvcjpcbi8vXG4vLyAgICAgICAgIHNlbGYuYnJva2VuID0gZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcnJvciBpbiB3b3JrZXIhJyk7XG4vLyAgICAgICAgIH07XG4vL1xuLy8gICAgIEluIHdvcmtlciwgcmV0dXJuaW5nIGEgcmVqZWN0ZWQgcHJvbWlzZTpcbi8vXG4vLyAgICAgICAgIHNlbGYuYnJva2VuID0gZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignZXJyb3IgaW4gd29ya2VyIScpKTtcbi8vICAgICAgICAgfTtcbi8vXG4vLyAgICAgSW4gbWFpbiB0aHJlYWQsIGJvdGggZXJyb3JzIGFyZSByZWNlaXZlZCBhcyBhIHByb21pc2UgcmVqZWN0aW9uOlxuLy9cbi8vICAgICAgICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHdvcmtlciwgJ3NlbGYuYnJva2VuJykudGhlbihcbi8vICAgICAgICAgICAgIC8vIFByb21pc2UgcmVzb2x2ZWRcbi8vICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzdWNjZXNzIScpO1xuLy8gICAgICAgICAgICAgfSxcbi8vICAgICAgICAgICAgIC8vIFByb21pc2UgcmVqZWN0ZWRcbi8vICAgICAgICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4vLyAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yIScsIGVycm9yKTtcbi8vICAgICAgICAgICAgIH0pO1xuLy9cbi8vICAgICAgICAgLT4gcHJpbnRzICdlcnJvciEgZXJyb3IgaW4gd29ya2VyJ1xuLy9cbi8vIENhbGxpbmcgZnJvbSB3b3JrZXIgdG8gbWFpbiB0aHJlYWQ6XG4vL1xuLy8gVGhlIHNhbWUgc3R5bGUgb2YgY2FsbHMgY2FuIGJlIG1hZGUgKmZyb20qIGEgd2ViIHdvcmtlciwgdG8gdGhlIG1haW4gdGhyZWFkLiBUaGUgQVBJIGlzIHRoZSBzYW1lXG4vLyB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCB0aGUgZmlyc3QgYXJndW1lbnQsICd3b3JrZXInLCBpcyBub3QgbmVlZGVkIGZvciBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UoKSxcbi8vIHNpbmNlIHRoZSBtYWluIHRocmVhZCBpcyB0aGUgaW1wbGljaXQgdGFyZ2V0LlxuLy9cbi8vIEluIG1haW4gdGhyZWFkLCBkZWZpbmUgYSBtZXRob2QgYW5kIHJlZ2lzdGVyIGl0OlxuLy9cbi8vICAgICB2YXIgZ2VvbWV0cnkgPSB7XG4vLyAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24oeCwgeSkge1xuLy8gICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbi8vICAgICAgICAgfVxuLy8gICAgIH07XG4vL1xuLy8gICAgIFdvcmtlckJyb2tlci5hZGRUYXJnZXQoJ2dlb21ldHJ5JywgZ2VvbWV0cnkpO1xuLy9cbi8vIEluIHdvcmtlciB0aHJlYWQ6XG4vL1xuLy8gICAgIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSgnZ2VvbWV0cnkubGVuZ3RoJywgMywgNCkudGhlbihmdW5jdGlvbihkKSB7XG4vLyAgICAgICAgIGNvbnNvbGUubG9nKGQpO1xuLy8gICAgIH0pO1xuLy9cbi8vICAgICAtPiBwcmludHMgNVxuLy9cblxuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMnO1xuXG52YXIgV29ya2VyQnJva2VyO1xuZXhwb3J0IGRlZmF1bHQgV29ya2VyQnJva2VyID0ge307XG5cbi8vIEdsb2JhbCBsaXN0IG9mIGFsbCB3b3JrZXIgbWVzc2FnZXNcbi8vIFVuaXF1ZWx5IHRyYWNrcyBldmVyeSBjYWxsIG1hZGUgYmV0d2VlbiBtYWluIHRocmVhZCBhbmQgYSB3b3JrZXJcbnZhciBtZXNzYWdlX2lkID0gMDtcbnZhciBtZXNzYWdlcyA9IHt9O1xuXG4vLyBSZWdpc3RlciBhbiBvYmplY3QgdG8gcmVjZWl2ZSBjYWxscyBmcm9tIG90aGVyIHRocmVhZFxudmFyIHRhcmdldHMgPSB7fTtcbldvcmtlckJyb2tlci5hZGRUYXJnZXQgPSBmdW5jdGlvbiAobmFtZSwgdGFyZ2V0KSB7XG4gICAgdGFyZ2V0c1tuYW1lXSA9IHRhcmdldDtcbn07XG5cbi8vIEdpdmVuIGEgZG90LW5vdGF0aW9uLXN0eWxlIG1ldGhvZCBuYW1lLCBlLmcuICdPYmplY3Qub2JqZWN0Lm1ldGhvZCcsXG4vLyBmaW5kIHRoZSBvYmplY3QgdG8gY2FsbCB0aGUgbWV0aG9kIG9uIGZyb20gdGhlIGxpc3Qgb2YgcmVnaXN0ZXJlZCB0YXJnZXRzXG5mdW5jdGlvbiBmaW5kVGFyZ2V0IChtZXRob2QpIHtcbiAgICB2YXIgY2hhaW4gPSBbXTtcbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY2hhaW4gPSBtZXRob2Quc3BsaXQoJy4nKTtcbiAgICAgICAgbWV0aG9kID0gY2hhaW4ucG9wKCk7XG4gICAgfVxuXG4gICAgLy8gdGFyZ2V0ID0gdGFyZ2V0IHx8IChVdGlscy5pc01haW5UaHJlYWQgJiYgd2luZG93KSB8fCAoVXRpbHMuaXNXb3JrZXJUaHJlYWQgJiYgc2VsZik7XG4gICAgdmFyIHRhcmdldCA9IHRhcmdldHM7XG5cbiAgICBmb3IgKGxldCBtPTA7IG0gPCBjaGFpbi5sZW5ndGg7IG0rKykge1xuICAgICAgICBpZiAodGFyZ2V0W2NoYWluW21dXSkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W2NoYWluW21dXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbbWV0aG9kLCB0YXJnZXRdO1xufVxuXG4vLyBNYWluIHRocmVhZDpcbi8vIC0gU2VuZCBtZXNzYWdlcyB0byB3b3JrZXJzLCBhbmQgb3B0aW9uYWxseSByZWNlaXZlIGFuIGFzeW5jIHJlc3BvbnNlIGFzIGEgcHJvbWlzZVxuLy8gLSBSZWNlaXZlIG1lc3NhZ2VzIGZyb20gd29ya2VycywgYW5kIG9wdGlvbmFsbHkgc2VuZCBhbiBhc3luYyByZXNwb25zZSBiYWNrIGFzIGEgcHJvbWlzZVxuZnVuY3Rpb24gc2V0dXBNYWluVGhyZWFkICgpIHtcblxuICAgIC8vIFNlbmQgYSBtZXNzYWdlIHRvIGEgd29ya2VyLCBhbmQgb3B0aW9uYWxseSBnZXQgYW4gYXN5bmMgcmVzcG9uc2VcbiAgICAvLyBBcmd1bWVudHM6XG4gICAgLy8gICAtIHdvcmtlcjogb25lIG9yIG1vcmUgd2ViIHdvcmtlciBpbnN0YW5jZXMgdG8gc2VuZCB0aGUgbWVzc2FnZSB0byAoc2luZ2xlIHZhbHVlIG9yIGFycmF5KVxuICAgIC8vICAgLSBtZXRob2Q6IHRoZSBtZXRob2Qgd2l0aCB0aGlzIG5hbWUsIHNwZWNpZmllZCB3aXRoIGRvdC1ub3RhdGlvbiwgd2lsbCBiZSBpbnZva2VkIGluIHRoZSB3b3JrZXJcbiAgICAvLyAgIC0gbWVzc2FnZTogd2lsbCBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZCBjYWxsXG4gICAgLy8gUmV0dXJuczpcbiAgICAvLyAgIC0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgaWYgdGhlIHdvcmtlciBtZXRob2QgcmV0dXJucyBhIHZhbHVlIChjb3VsZCBiZSBpbW1lZGlhdGVseSwgb3IgYXN5bmMpXG4gICAgLy9cbiAgICBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAod29ya2VyLCBtZXRob2QsIC4uLm1lc3NhZ2UpIHtcbiAgICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSB3b3JrZXIgc3BlY2lmaWVkLCBwb3N0IHRvIG11bHRpcGxlXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHdvcmtlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgICB3b3JrZXIubWFwKHcgPT4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHcsIG1ldGhvZCwgLi4ubWVzc2FnZSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhY2sgc3RhdGUgb2YgdGhpcyBtZXNzYWdlXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbWVzc2FnZXNbbWVzc2FnZV9pZF0gPSB7IG1ldGhvZCwgbWVzc2FnZSwgcmVzb2x2ZSwgcmVqZWN0IH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB0eXBlOiAnbWFpbl9zZW5kJywgICAgICAvLyBtYXJrIG1lc3NhZ2UgYXMgbWV0aG9kIGludm9jYXRpb24gZnJvbSBtYWluIHRocmVhZFxuICAgICAgICAgICAgbWVzc2FnZV9pZCwgICAgICAgICAgICAgLy8gdW5pcXVlIGlkIGZvciB0aGlzIG1lc3NhZ2UsIGZvciBsaWZlIG9mIHByb2dyYW1cbiAgICAgICAgICAgIG1ldGhvZCwgICAgICAgICAgICAgICAgIC8vIHdpbGwgZGlzcGF0Y2ggdG8gYSBmdW5jdGlvbiBvZiB0aGlzIG5hbWUgd2l0aGluIHRoZSB3b3JrZXJcbiAgICAgICAgICAgIG1lc3NhZ2UgICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UgcGF5bG9hZFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgbWVzc2FnZV9pZCsrO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGEgd29ya2VyIHRvIGNvbW11bmljYXRlIHdpdGggLSBlYWNoIHdvcmtlciBtdXN0IGJlIHJlZ2lzdGVyZWQgZnJvbSB0aGUgbWFpbiB0aHJlYWRcbiAgICB2YXIgd29ya2VyX2lkID0gMDtcbiAgICB2YXIgd29ya2VycyA9IG5ldyBNYXAoKTtcblxuICAgIFdvcmtlckJyb2tlci5hZGRXb3JrZXIgPSBmdW5jdGlvbiAod29ya2VyKSB7XG5cbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBhbGwgcmVnaXN0ZXJlZCB3b3JrZXJzXG4gICAgICAgIHdvcmtlcnMuc2V0KHdvcmtlciwgd29ya2VyX2lkKyspO1xuXG4gICAgICAgIC8vIExpc3RlbiBmb3IgbWVzc2FnZXMgY29taW5nIGJhY2sgZnJvbSB0aGUgd29ya2VyLCBhbmQgZnVsZmlsbCB0aGF0IG1lc3NhZ2UncyBwcm9taXNlXG4gICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IG1heWJlRGVjb2RlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgaWYgKGRhdGEudHlwZSAhPT0gJ3dvcmtlcl9yZXBseScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFBhc3MgdGhlIHJlc3VsdCB0byB0aGUgcHJvbWlzZVxuICAgICAgICAgICAgdmFyIGlkID0gZGF0YS5tZXNzYWdlX2lkO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VzW2lkXSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzW2lkXS5yZWplY3QoZGF0YS5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1tpZF0ucmVzb2x2ZShkYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgbWVzc2FnZXNbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBMaXN0ZW4gZm9yIG1lc3NhZ2VzIGluaXRpYXRpbmcgYSBjYWxsIGZyb20gdGhlIHdvcmtlciwgZGlzcGF0Y2ggdGhlbSxcbiAgICAgICAgLy8gYW5kIHNlbmQgYW55IHJldHVybiB2YWx1ZSBiYWNrIHRvIHRoZSB3b3JrZXJcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gbWF5YmVEZWNvZGUoZXZlbnQuZGF0YSk7XG5cbiAgICAgICAgICAgIC8vIFVuaXF1ZSBpZCBmb3IgdGhpcyBtZXNzYWdlICYgcmV0dXJuIGNhbGwgdG8gbWFpbiB0aHJlYWRcbiAgICAgICAgICAgIHZhciBpZCA9IGRhdGEubWVzc2FnZV9pZDtcbiAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgIT09ICd3b3JrZXJfc2VuZCcgfHwgaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgcmVxdWVzdGVkIG1ldGhvZCBhbmQgc2F2ZSB0aGUgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICAvLyB2YXIgdGFyZ2V0ID0gdGFyZ2V0c1tkYXRhLnRhcmdldF07XG4gICAgICAgICAgICB2YXIgW21ldGhvZF9uYW1lLCB0YXJnZXRdID0gZmluZFRhcmdldChkYXRhLm1ldGhvZCk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBXb3JrZXIgYnJva2VyIGNvdWxkIG5vdCBkaXNwYXRjaCBtZXNzYWdlIHR5cGUgJHtkYXRhLm1ldGhvZH0gb24gdGFyZ2V0ICR7ZGF0YS50YXJnZXR9IGJlY2F1c2Ugbm8gb2JqZWN0IHdpdGggdGhhdCBuYW1lIGlzIHJlZ2lzdGVyZWQgb24gbWFpbiB0aHJlYWRgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1ldGhvZCA9ICh0eXBlb2YgdGFyZ2V0W21ldGhvZF9uYW1lXSA9PT0gJ2Z1bmN0aW9uJykgJiYgdGFyZ2V0W21ldGhvZF9uYW1lXTtcbiAgICAgICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFdvcmtlciBicm9rZXIgY291bGQgbm90IGRpc3BhdGNoIG1lc3NhZ2UgdHlwZSAke2RhdGEubWV0aG9kfSBvbiB0YXJnZXQgJHtkYXRhLnRhcmdldH0gYmVjYXVzZSBvYmplY3QgaGFzIG5vIG1ldGhvZCB3aXRoIHRoYXQgbmFtZWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBlcnJvcjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRhcmdldCwgZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvd24gZXJyb3JzIHdpbGwgYmUgcGFzc2VkIGJhY2sgKGluIHN0cmluZyBmb3JtKSB0byB3b3JrZXJcbiAgICAgICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNlbmQgcmV0dXJuIHZhbHVlIHRvIHdvcmtlclxuICAgICAgICAgICAgbGV0IHBheWxvYWQsIHRyYW5zZmVyYWJsZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8gQXN5bmMgcmVzdWx0XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBXb3JrZXJCcm9rZXIucmV0dXJuV2l0aFRyYW5zZmVyYWJsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMgPSB2YWx1ZS50cmFuc2ZlcmFibGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbWFpbl9yZXBseScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSBtYXliZUVuY29kZShwYXlsb2FkLCB0cmFuc2ZlcmFibGVzKTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHBheWxvYWQsIHRyYW5zZmVyYWJsZXMubWFwKHQgPT4gdC5vYmplY3QpKTtcbiAgICAgICAgICAgICAgICAgICAgZnJlZVRyYW5zZmVyYWJsZXModHJhbnNmZXJhYmxlcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmICh0cmFuc2ZlcmFibGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIFV0aWxzLmxvZygndHJhY2UnLCBgJyR7bWV0aG9kX25hbWV9JyB0cmFuc2ZlcnJlZCAke3RyYW5zZmVyYWJsZXMubGVuZ3RofSBvYmplY3RzIHRvIHdvcmtlciB0aHJlYWRgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbWFpbl9yZXBseScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGAke2Vycm9yLm1lc3NhZ2V9OiAke2Vycm9yLnN0YWNrfWAgOiBlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbW1lZGlhdGUgcmVzdWx0XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgV29ya2VyQnJva2VyLnJldHVybldpdGhUcmFuc2ZlcmFibGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMgPSByZXN1bHQudHJhbnNmZXJhYmxlcztcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtYWluX3JlcGx5JyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYCR7ZXJyb3IubWVzc2FnZX06ICR7ZXJyb3Iuc3RhY2t9YCA6IGVycm9yKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IG1heWJlRW5jb2RlKHBheWxvYWQsIHRyYW5zZmVyYWJsZXMpO1xuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShwYXlsb2FkLCB0cmFuc2ZlcmFibGVzLm1hcCh0ID0+IHQub2JqZWN0KSk7XG4gICAgICAgICAgICAgICAgZnJlZVRyYW5zZmVyYWJsZXModHJhbnNmZXJhYmxlcyk7XG4gICAgICAgICAgICAgICAgLy8gaWYgKHRyYW5zZmVyYWJsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vICAgICBVdGlscy5sb2coJ3RyYWNlJywgYCcke21ldGhvZF9uYW1lfScgdHJhbnNmZXJyZWQgJHt0cmFuc2ZlcmFibGVzLmxlbmd0aH0gb2JqZWN0cyB0byB3b3JrZXIgdGhyZWFkYCk7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH07XG5cbiAgICAvLyBFeHBvc2UgZm9yIGRlYnVnZ2luZ1xuICAgIFdvcmtlckJyb2tlci5nZXRNZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgIH07XG5cbiAgICBXb3JrZXJCcm9rZXIuZ2V0TWVzc2FnZUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZV9pZDtcbiAgICB9O1xuXG59XG5cbi8vIFdvcmtlciB0aHJlYWRzOlxuLy8gLSBSZWNlaXZlIG1lc3NhZ2VzIGZyb20gbWFpbiB0aHJlYWQsIGFuZCBvcHRpb25hbGx5IHNlbmQgYW4gYXN5bmMgcmVzcG9uc2UgYmFjayBhcyBhIHByb21pc2Vcbi8vIC0gU2VuZCBtZXNzYWdlcyB0byBtYWluIHRocmVhZCwgYW5kIG9wdGlvbmFsbHkgcmVjZWl2ZSBhbiBhc3luYyByZXNwb25zZSBhcyBhIHByb21pc2VcbmZ1bmN0aW9uIHNldHVwV29ya2VyVGhyZWFkICgpIHtcblxuICAgIC8vIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBtYWluIHRocmVhZCwgYW5kIG9wdGlvbmFsbHkgZ2V0IGFuIGFzeW5jIHJlc3BvbnNlIGFzIGEgcHJvbWlzZVxuICAgIC8vIEFyZ3VtZW50czpcbiAgICAvLyAgIC0gbWV0aG9kOiB0aGUgbWV0aG9kIHdpdGggdGhpcyBuYW1lLCBzcGVjaWZpZWQgd2l0aCBkb3Qtbm90YXRpb24sIHdpbGwgYmUgaW52b2tlZCBvbiB0aGUgbWFpbiB0aHJlYWRcbiAgICAvLyAgIC0gbWVzc2FnZTogd2lsbCBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZCBjYWxsXG4gICAgLy8gUmV0dXJuczpcbiAgICAvLyAgIC0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgaWYgdGhlIG1haW4gdGhyZWFkIG1ldGhvZCByZXR1cm5zIGEgdmFsdWUgKGNvdWxkIGJlIGltbWVkaWF0ZWx5LCBvciBhc3luYylcbiAgICAvL1xuICAgIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uIChtZXRob2QsIC4uLm1lc3NhZ2UpIHtcbiAgICAgICAgLy8gVHJhY2sgc3RhdGUgb2YgdGhpcyBtZXNzYWdlXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbWVzc2FnZXNbbWVzc2FnZV9pZF0gPSB7IG1ldGhvZCwgbWVzc2FnZSwgcmVzb2x2ZSwgcmVqZWN0IH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ3dvcmtlcl9zZW5kJywgICAgLy8gbWFyayBtZXNzYWdlIGFzIG1ldGhvZCBpbnZvY2F0aW9uIGZyb20gd29ya2VyXG4gICAgICAgICAgICBtZXNzYWdlX2lkLCAgICAgICAgICAgICAvLyB1bmlxdWUgaWQgZm9yIHRoaXMgbWVzc2FnZSwgZm9yIGxpZmUgb2YgcHJvZ3JhbVxuICAgICAgICAgICAgbWV0aG9kLCAgICAgICAgICAgICAgICAgLy8gd2lsbCBkaXNwYXRjaCB0byBhIG1ldGhvZCBvZiB0aGlzIG5hbWUgb24gdGhlIG1haW4gdGhyZWFkXG4gICAgICAgICAgICBtZXNzYWdlICAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIHBheWxvYWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWVzc2FnZV9pZCsrO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLy8gTGlzdGVuIGZvciBtZXNzYWdlcyBjb21pbmcgYmFjayBmcm9tIHRoZSBtYWluIHRocmVhZCwgYW5kIGZ1bGZpbGwgdGhhdCBtZXNzYWdlJ3MgcHJvbWlzZVxuICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgICBsZXQgZGF0YSA9IG1heWJlRGVjb2RlKGV2ZW50LmRhdGEpO1xuICAgICAgICBpZiAoZGF0YS50eXBlICE9PSAnbWFpbl9yZXBseScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhc3MgdGhlIHJlc3VsdCB0byB0aGUgcHJvbWlzZVxuICAgICAgICB2YXIgaWQgPSBkYXRhLm1lc3NhZ2VfaWQ7XG4gICAgICAgIGlmIChtZXNzYWdlc1tpZF0pIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXNbaWRdLnJlamVjdChkYXRhLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzW2lkXS5yZXNvbHZlKGRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgbWVzc2FnZXNbaWRdO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZWNlaXZlIG1lc3NhZ2VzIGZyb20gbWFpbiB0aHJlYWQsIGRpc3BhdGNoIHRoZW0sIGFuZCBzZW5kIGJhY2sgYSByZXBseVxuICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgICBsZXQgZGF0YSA9IG1heWJlRGVjb2RlKGV2ZW50LmRhdGEpO1xuXG4gICAgICAgIC8vIFVuaXF1ZSBpZCBmb3IgdGhpcyBtZXNzYWdlICYgcmV0dXJuIGNhbGwgdG8gbWFpbiB0aHJlYWRcbiAgICAgICAgdmFyIGlkID0gZGF0YS5tZXNzYWdlX2lkO1xuICAgICAgICBpZiAoZGF0YS50eXBlICE9PSAnbWFpbl9zZW5kJyB8fCBpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxsIHRoZSByZXF1ZXN0ZWQgd29ya2VyIG1ldGhvZCBhbmQgc2F2ZSB0aGUgcmV0dXJuIHZhbHVlXG4gICAgICAgIHZhciBbbWV0aG9kX25hbWUsIHRhcmdldF0gPSBmaW5kVGFyZ2V0KGRhdGEubWV0aG9kKTtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBXb3JrZXIgYnJva2VyIGNvdWxkIG5vdCBkaXNwYXRjaCBtZXNzYWdlIHR5cGUgJHtkYXRhLm1ldGhvZH0gb24gdGFyZ2V0ICR7ZGF0YS50YXJnZXR9IGJlY2F1c2Ugbm8gb2JqZWN0IHdpdGggdGhhdCBuYW1lIGlzIHJlZ2lzdGVyZWQgb24gbWFpbiB0aHJlYWRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZXRob2QgPSAodHlwZW9mIHRhcmdldFttZXRob2RfbmFtZV0gPT09ICdmdW5jdGlvbicpICYmIHRhcmdldFttZXRob2RfbmFtZV07XG5cbiAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBXb3JrZXIgYnJva2VyIGNvdWxkIG5vdCBkaXNwYXRjaCBtZXNzYWdlIHR5cGUgJHtkYXRhLm1ldGhvZH0gYmVjYXVzZSB3b3JrZXIgaGFzIG5vIG1ldGhvZCB3aXRoIHRoYXQgbmFtZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCwgZXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkodGFyZ2V0LCBkYXRhLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgIC8vIFRocm93biBlcnJvcnMgd2lsbCBiZSBwYXNzZWQgYmFjayAoaW4gc3RyaW5nIGZvcm0pIHRvIG1haW4gdGhyZWFkXG4gICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZW5kIHJldHVybiB2YWx1ZSB0byBtYWluIHRocmVhZFxuICAgICAgICBsZXQgcGF5bG9hZCwgdHJhbnNmZXJhYmxlcyA9IFtdO1xuXG4gICAgICAgIC8vIEFzeW5jIHJlc3VsdFxuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmVzdWx0LnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgV29ya2VyQnJva2VyLnJldHVybldpdGhUcmFuc2ZlcmFibGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMgPSB2YWx1ZS50cmFuc2ZlcmFibGVzO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3b3JrZXJfcmVwbHknLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBtYXliZUVuY29kZShwYXlsb2FkLCB0cmFuc2ZlcmFibGVzKTtcbiAgICAgICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHBheWxvYWQsIHRyYW5zZmVyYWJsZXMubWFwKHQgPT4gdC5vYmplY3QpKTtcbiAgICAgICAgICAgICAgICBmcmVlVHJhbnNmZXJhYmxlcyh0cmFuc2ZlcmFibGVzKTtcbiAgICAgICAgICAgICAgICAvLyBpZiAodHJhbnNmZXJhYmxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIFV0aWxzLmxvZygndHJhY2UnLCBgJyR7bWV0aG9kX25hbWV9JyB0cmFuc2ZlcnJlZCAke3RyYW5zZmVyYWJsZXMubGVuZ3RofSBvYmplY3RzIHRvIG1haW4gdGhyZWFkYCk7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3b3JrZXJfcmVwbHknLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYCR7ZXJyb3IubWVzc2FnZX06ICR7ZXJyb3Iuc3RhY2t9YCA6IGVycm9yKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW1tZWRpYXRlIHJlc3VsdFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBXb3JrZXJCcm9rZXIucmV0dXJuV2l0aFRyYW5zZmVyYWJsZXMpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcmFibGVzID0gcmVzdWx0LnRyYW5zZmVyYWJsZXM7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd3b3JrZXJfcmVwbHknLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VfaWQ6IGlkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBlcnJvcjogKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBgJHtlcnJvci5tZXNzYWdlfTogJHtlcnJvci5zdGFja31gIDogZXJyb3IpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcGF5bG9hZCA9IG1heWJlRW5jb2RlKHBheWxvYWQsIHRyYW5zZmVyYWJsZXMpO1xuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShwYXlsb2FkLCB0cmFuc2ZlcmFibGVzLm1hcCh0ID0+IHQub2JqZWN0KSk7XG4gICAgICAgICAgICBmcmVlVHJhbnNmZXJhYmxlcyh0cmFuc2ZlcmFibGVzKTtcbiAgICAgICAgICAgIC8vIGlmICh0cmFuc2ZlcmFibGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vICAgICBVdGlscy5sb2coJ3RyYWNlJywgYCcke21ldGhvZF9uYW1lfScgdHJhbnNmZXJyZWQgJHt0cmFuc2ZlcmFibGVzLmxlbmd0aH0gb2JqZWN0cyB0byBtYWluIHRocmVhZGApO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgfSk7XG5cbn1cblxuLy8gU3BlY2lhbCByZXR1cm4gdmFsdWUgd3JhcHBlciwgdG8gaW5kaWNhdGUgdGhhdCB3ZSB3YW50IHRvIGZpbmQgYW5kIGluY2x1ZGVcbi8vIHRyYW5zZmVyYWJsZSBvYmplY3RzIGluIHRoZSByZXNwb25zZSBtZXNzYWdlXG5Xb3JrZXJCcm9rZXIucmV0dXJuV2l0aFRyYW5zZmVyYWJsZXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV29ya2VyQnJva2VyLnJldHVybldpdGhUcmFuc2ZlcmFibGVzKSkge1xuICAgICAgICByZXR1cm4gbmV3IFdvcmtlckJyb2tlci5yZXR1cm5XaXRoVHJhbnNmZXJhYmxlcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMudHJhbnNmZXJhYmxlcyA9IGZpbmRUcmFuc2ZlcmFibGVzKHRoaXMudmFsdWUpO1xufTtcblxuLy8gQnVpbGQgYSBsaXN0IG9mIHRyYW5zZmVyYWJsZSBvYmplY3RzIGZyb20gYSBzb3VyY2Ugb2JqZWN0XG4vLyBSZXR1cm5zIGEgbGlzdCBvZiBpbmZvIGFib3V0IGVhY2ggdHJhbnNmZXJhYmxlOlxuLy8gICAtIG9iamVjdDogdGhlIGFjdHVhbCB0cmFuc2ZlcmFibGUgb2JqZWN0XG4vLyAgIC0gcGFyZW50OiB0aGUgcGFyZW50IG9iamVjdCB0aGF0IHRoZSB0cmFuc2ZlcmFibGUgaXMgYSBwcm9wZXJ0eSBvZiAoaWYgYW55KVxuLy8gICAtIHByb3BlcnR5OiB0aGUgcHJvcGVydHkgbmFtZSBvZiB0aGUgdHJhbnNmZXJhYmxlIG9uIHRoZSBwYXJlbnQgb2JqZWN0IChpZiBhbnkpXG4vLyBUT0RPOiBhZGQgb3B0aW9uIGluIGNhc2UgeW91IERPTidUIHdhbnQgdG8gdHJhbnNmZXIgb2JqZWN0c1xuZnVuY3Rpb24gZmluZFRyYW5zZmVyYWJsZXMoc291cmNlLCBwYXJlbnQgPSBudWxsLCBwcm9wZXJ0eSA9IG51bGwsIGxpc3QgPSBbXSkge1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIC8vIENoZWNrIGVhY2ggYXJyYXkgZWxlbWVudFxuICAgICAgICBzb3VyY2UuZm9yRWFjaCgoeCwgaSkgPT4gZmluZFRyYW5zZmVyYWJsZXMoeCwgc291cmNlLCBpLCBsaXN0KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIElzIHRoZSBvYmplY3QgYSB0cmFuc2ZlcmFibGUgYXJyYXkgYnVmZmVyP1xuICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIGxpc3QucHVzaCh7IG9iamVjdDogc291cmNlLCBwYXJlbnQsIHByb3BlcnR5IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9yIGxvb2tzIGxpa2UgYSB0eXBlZCBhcnJheSAoaGFzIGFuIGFycmF5IGJ1ZmZlciBwcm9wZXJ0eSk/XG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgbGlzdC5wdXNoKHsgb2JqZWN0OiBzb3VyY2UuYnVmZmVyLCBwYXJlbnQsIHByb3BlcnR5IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSBjaGVjayBlYWNoIHByb3BlcnR5XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBmaW5kVHJhbnNmZXJhYmxlcyhzb3VyY2VbcHJvcF0sIHNvdXJjZSwgcHJvcCwgbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIFJlbW92ZSBuZXV0ZXJlZCB0cmFuc2ZlcmFibGVzIGZyb20gcGFyZW50IG9iamVjdHMsIGFzIHRoZXkgc2hvdWxkIG5vIGxvbmdlciBiZSBhY2Nlc3NlZCBhZnRlciB0cmFuc2ZlclxuZnVuY3Rpb24gZnJlZVRyYW5zZmVyYWJsZXModHJhbnNmZXJhYmxlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0cmFuc2ZlcmFibGVzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyYW5zZmVyYWJsZXMuZmlsdGVyKHQgPT4gdC5wYXJlbnQgJiYgdC5wcm9wZXJ0eSkuZm9yRWFjaCh0ID0+IGRlbGV0ZSB0LnBhcmVudFt0LnByb3BlcnR5XSk7XG59XG5cbi8vIE1lc3NhZ2UgcGF5bG9hZCBjYW4gYmUgc3RyaW5naWZpZWQgZm9yIGZhc3RlciB0cmFuc2ZlciwgaWYgaXQgZG9lcyBub3QgaW5jbHVkZSB0cmFuc2ZlcmFibGUgb2JqZWN0c1xuZnVuY3Rpb24gbWF5YmVFbmNvZGUgKHBheWxvYWQsIHRyYW5zZmVyYWJsZXMpIHtcbiAgICBpZiAodHJhbnNmZXJhYmxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgIH1cbiAgICByZXR1cm4gcGF5bG9hZDtcbn1cblxuLy8gUGFyc2Ugc3RyaW5naWZpZWQgbWVzc2FnZSBwYXlsb2FkXG5mdW5jdGlvbiBtYXliZURlY29kZSAoZGF0YSkge1xuICAgIHJldHVybiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShkYXRhKSA6IGRhdGEpO1xufVxuXG4vLyBTZXR1cCB0aGlzIHRocmVhZCBhcyBhcHByb3ByaWF0ZVxuaWYgKFV0aWxzLmlzTWFpblRocmVhZCkge1xuICAgIHNldHVwTWFpblRocmVhZCgpO1xufVxuXG5pZiAoVXRpbHMuaXNXb3JrZXJUaHJlYWQpIHtcbiAgICBzZXR1cFdvcmtlclRocmVhZCgpO1xufVxuIiwiLyoqKiBWZWN0b3IgZnVuY3Rpb25zIC0gdmVjdG9ycyBwcm92aWRlZCBhcyBbeCwgeSwgel0gYXJyYXlzICoqKi9cblxudmFyIFZlY3RvcjtcbmV4cG9ydCBkZWZhdWx0IFZlY3RvciA9IHt9O1xuXG5WZWN0b3Iuc2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgViA9IFtdO1xuICAgIHZhciBsaW0gPSB2Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbTsgaSsrKSB7XG4gICAgICAgIFZbaV0gPSB2W2ldO1xuICAgIH1cbiAgICByZXR1cm4gVjtcbn07XG5cblZlY3Rvci5uZWcgPSBmdW5jdGlvbiAodikge1xuICAgIHZhciBWID0gW107XG4gICAgdmFyIGxpbSA9IHYubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGltOyBpKyspIHtcbiAgICAgICAgVltpXSA9IHZbaV0gKiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIFY7XG59O1xuXG4vLyBBZGRpdGlvbiBvZiB0d28gdmVjdG9yc1xuVmVjdG9yLmFkZCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICB2YXIgdiA9IFtdO1xuICAgIHZhciBsaW0gPSBNYXRoLm1pbih2MS5sZW5ndGgsdjIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbTsgaSsrKSB7XG4gICAgICAgIHZbaV0gPSB2MVtpXSArIHYyW2ldO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn07XG5cbi8vIFN1YnN0cmFjdGlvbiBvZiB0d28gdmVjdG9yc1xuVmVjdG9yLnN1YiA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICB2YXIgdiA9IFtdO1xuICAgIHZhciBsaW0gPSBNYXRoLm1pbih2MS5sZW5ndGgsdjIubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGltOyBpKyspIHtcbiAgICAgICAgdltpXSA9IHYxW2ldIC0gdjJbaV07XG4gICAgfVxuICAgIHJldHVybiB2O1xufTtcblxuVmVjdG9yLnNpZ25lZF9hcmVhID0gZnVuY3Rpb24gKHYxLCB2MiwgdjMpIHtcbiAgICByZXR1cm4gKHYyWzBdLXYxWzBdKSoodjNbMV0tdjFbMV0pIC0gKHYzWzBdLXYxWzBdKSoodjJbMV0tdjFbMV0pO1xufTtcblxuLy8gTXVsdGlwbGljYXRpb24gb2YgdHdvIHZlY3RvcnNcblZlY3Rvci5tdWx0ID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgIHZhciB2ID0gW10sXG4gICAgICAgIGxlbiA9IHYxLmxlbmd0aCxcbiAgICAgICAgaTtcblxuICAgIGlmICh0eXBlb2YgdjIgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIE11bGl0cGx5IGJ5IHNjYWxhclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZbaV0gPSB2MVtpXSAqIHYyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBNdWx0aXBseSB0d28gdmVjdG9yc1xuICAgICAgICBsZW4gPSBNYXRoLm1pbih2MS5sZW5ndGgsdjIubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2W2ldID0gdjFbaV0gKiB2MltpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbn07XG5cbi8vIERpdmlzaW9uIG9mIHR3byB2ZWN0b3JzXG5WZWN0b3IuZGl2ID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgIHZhciB2ID0gW10sXG4gICAgICAgIGk7XG4gICAgaWYodHlwZW9mIHYyID09PSAnbnVtYmVyJyl7XG4gICAgICAgIC8vIERpdmlkZSBieSBzY2FsYXJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHYxLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZbaV0gPSB2MVtpXSAvIHYyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGl2aWRlIHRvIHZlY3RvcnNcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKHYxLmxlbmd0aCx2Mi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZbaV0gPSB2MVtpXSAvIHYyW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xufTtcblxuLy8gR2V0IDJEIHBlcnBlbmRpY3VsYXJcblZlY3Rvci5wZXJwID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgIHJldHVybiBbIHYyWzFdIC0gdjFbMV0sXG4gICAgICAgICAgICAgdjFbMF0gLSB2MlswXSBdO1xufTtcblxuLy8gR2V0IDJEIHZlY3RvciByb3RhdGVkXG5WZWN0b3Iucm90ID0gZnVuY3Rpb24gKHYsIGEpIHtcbiAgICB2YXIgYyA9IE1hdGguY29zKGEpO1xuICAgIHZhciBzID0gTWF0aC5zaW4oYSk7XG4gICAgcmV0dXJuIFt2WzBdICogYyAtIHZbMV0gKiBzLFxuICAgICAgICAgICAgdlswXSAqIHMgKyB2WzFdICogY107XG59O1xuXG4vLyBHZXQgMkQgaGVhZGluZyBhbmdsZVxuVmVjdG9yLmFuZ2xlID0gZnVuY3Rpb24gKFt4LCB5XSkge1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHkseCk7XG59O1xuXG4vLyBHZXQgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9yc1xuVmVjdG9yLmFuZ2xlQmV0d2VlbiA9IGZ1bmN0aW9uKEEsIEIpe1xuICAgIHZhciBkZWx0YSA9IFZlY3Rvci5kb3QoQSwgQik7XG4gICAgaWYgKGRlbHRhIDwgLTEpIHtcbiAgICAgICAgZGVsdGEgPSAtMTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguYWNvcyhkZWx0YSk7XG59O1xuXG4vLyBDb21wYXJlIHR3byBwb2ludHNcblZlY3Rvci5pc0VxdWFsID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgIHZhciBsZW4gPSB2MS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodjFbaV0gIT09IHYyW2ldKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIFZlY3RvciBsZW5ndGggc3F1YXJlZFxuVmVjdG9yLmxlbmd0aFNxID0gZnVuY3Rpb24gKHYpXG57XG4gICAgaWYgKHYubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiAodlswXSp2WzBdICsgdlsxXSp2WzFdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAodlswXSp2WzBdICsgdlsxXSp2WzFdICsgdlsyXSp2WzJdKTtcbiAgICB9XG59O1xuXG4vLyBWZWN0b3IgbGVuZ3RoXG5WZWN0b3IubGVuZ3RoID0gZnVuY3Rpb24gKHYpXG57XG4gICAgcmV0dXJuIE1hdGguc3FydChWZWN0b3IubGVuZ3RoU3EodikpO1xufTtcblxuLy8gTm9ybWFsaXplIGEgdmVjdG9yXG5WZWN0b3Iubm9ybWFsaXplID0gZnVuY3Rpb24gKHYpXG57XG4gICAgdmFyIGQ7XG4gICAgaWYgKHYubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGQgPSB2WzBdKnZbMF0gKyB2WzFdKnZbMV07XG4gICAgICAgIGQgPSBNYXRoLnNxcnQoZCk7XG5cbiAgICAgICAgaWYgKGQgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbdlswXSAvIGQsIHZbMV0gLyBkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGQgPSB2WzBdKnZbMF0gKyB2WzFdKnZbMV0gKyB2WzJdKnZbMl07XG4gICAgICAgIGQgPSBNYXRoLnNxcnQoZCk7XG5cbiAgICAgICAgaWYgKGQgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbdlswXSAvIGQsIHZbMV0gLyBkLCB2WzJdIC8gZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgICB9XG59O1xuXG4vLyBDcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzXG5WZWN0b3IuY3Jvc3MgID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgIHJldHVybiBbXG4gICAgICAgICh2MVsxXSAqIHYyWzJdKSAtICh2MVsyXSAqIHYyWzFdKSxcbiAgICAgICAgKHYxWzJdICogdjJbMF0pIC0gKHYxWzBdICogdjJbMl0pLFxuICAgICAgICAodjFbMF0gKiB2MlsxXSkgLSAodjFbMV0gKiB2MlswXSlcbiAgICBdO1xufTtcblxuLy8gRG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcblZlY3Rvci5kb3QgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgdmFyIG4gPSAwO1xuICAgIHZhciBsaW0gPSBNYXRoLm1pbih2MS5sZW5ndGgsIHYyLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW07IGkrKykge1xuICAgICAgICBuICs9IHYxW2ldICogdjJbaV07XG4gICAgfVxuICAgIHJldHVybiBuO1xufTtcblxuLy8gRmluZCB0aGUgaW50ZXJzZWN0aW9uIG9mIHR3byBsaW5lcyBzcGVjaWZpZWQgYXMgc2VnbWVudHMgZnJvbSBwb2ludHMgKHAxLCBwMikgYW5kIChwMywgcDQpXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmUtbGluZV9pbnRlcnNlY3Rpb25cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3JhbWVyJ3NfcnVsZVxuVmVjdG9yLmxpbmVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAocDEsIHAyLCBwMywgcDQsIHBhcmFsbGVsX3RvbGVyYW5jZSkge1xuICAgIHBhcmFsbGVsX3RvbGVyYW5jZSA9IHBhcmFsbGVsX3RvbGVyYW5jZSB8fCAwLjAxO1xuXG4gICAgLy8gYTEqeCArIGIxKnkgPSBjMSBmb3IgbGluZSAoeDEsIHkxKSB0byAoeDIsIHkyKVxuICAgIC8vIGEyKnggKyBiMip5ID0gYzIgZm9yIGxpbmUgKHgzLCB5MykgdG8gKHg0LCB5NClcbiAgICB2YXIgYTEgPSBwMVsxXSAtIHAyWzFdOyAvLyB5MSAtIHkyXG4gICAgdmFyIGIxID0gcDFbMF0gLSBwMlswXTsgLy8geDEgLSB4MlxuICAgIHZhciBhMiA9IHAzWzFdIC0gcDRbMV07IC8vIHkzIC0geTRcbiAgICB2YXIgYjIgPSBwM1swXSAtIHA0WzBdOyAvLyB4MyAtIHg0XG4gICAgdmFyIGMxID0gKHAxWzBdICogcDJbMV0pIC0gKHAxWzFdICogcDJbMF0pOyAvLyB4MSp5MiAtIHkxKngyXG4gICAgdmFyIGMyID0gKHAzWzBdICogcDRbMV0pIC0gKHAzWzFdICogcDRbMF0pOyAvLyB4Myp5NCAtIHkzKng0XG4gICAgdmFyIGRlbm9tID0gKGIxICogYTIpIC0gKGExICogYjIpO1xuXG4gICAgaWYgKE1hdGguYWJzKGRlbm9tKSA+IHBhcmFsbGVsX3RvbGVyYW5jZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKChjMSAqIGIyKSAtIChiMSAqIGMyKSkgLyBkZW5vbSxcbiAgICAgICAgICAgICgoYzEgKiBhMikgLSAoYTEgKiBjMikpIC8gZGVub21cbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7IC8vIHJldHVybiBudWxsIGlmIGxpbmVzIGFyZSAoY2xvc2UgdG8pIHBhcmFsbGVsXG59O1xuIiwiaW1wb3J0IEdlbyBmcm9tICcuL2dlbyc7XG5pbXBvcnQgVGlsZSBmcm9tICcuL3RpbGUnO1xuaW1wb3J0IENhbWVyYSBmcm9tICcuL2NhbWVyYSc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy91dGlscyc7XG5pbXBvcnQgc3Vic2NyaWJlTWl4aW4gZnJvbSAnLi91dGlscy9zdWJzY3JpYmUnO1xuXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlldyB7XG5cbiAgICBjb25zdHJ1Y3RvciAoc2NlbmUsIG9wdGlvbnMpIHtcbiAgICAgICAgc3Vic2NyaWJlTWl4aW4odGhpcyk7XG5cbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLmNyZWF0ZU1hdHJpY2VzKCk7XG5cbiAgICAgICAgdGhpcy56b29tID0gbnVsbDtcbiAgICAgICAgdGhpcy5jZW50ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmJvdW5kcyA9IG51bGw7XG4gICAgICAgIHRoaXMubWV0ZXJzX3Blcl9waXhlbCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5wYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnpvb21fZGlyZWN0aW9uID0gMDtcblxuICAgICAgICAvLyBTaXplIG9mIHZpZXdwb3J0IGluIENTUyBwaXhlbHMsIGRldmljZSBwaXhlbHMsIGFuZCBtZXJjYXRvciBtZXRlcnNcbiAgICAgICAgdGhpcy5zaXplID0ge1xuICAgICAgICAgICAgY3NzOiB7fSxcbiAgICAgICAgICAgIGRldmljZToge30sXG4gICAgICAgICAgICBtZXRlcnM6IHt9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXNwZWN0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLmJ1ZmZlciA9IDA7XG4gICAgICAgIHRoaXMuY29udGludW91c196b29tID0gKHR5cGVvZiBvcHRpb25zLmNvbnRpbnVvdXNab29tID09PSAnYm9vbGVhbicpID8gb3B0aW9ucy5jb250aW51b3VzWm9vbSA6IHRydWU7XG4gICAgICAgIHRoaXMudGlsZV9zaW1wbGlmaWNhdGlvbl9sZXZlbCA9IDA7IC8vIGxldmVsLW9mLWRldGFpbCBkb3duc2FtcGxpbmcgdG8gYXBwbHkgdG8gdGlsZSBsb2FkaW5nXG4gICAgICAgIHRoaXMucHJlc2VydmVfdGlsZXNfd2l0aGluX3pvb20gPSAxO1xuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBzdGF0ZSBiZWZvcmUgc2NlbmUgY29uZmlnIGlzIHVwZGF0ZWRcbiAgICByZXNldCAoKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlQ2FtZXJhKCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGNhbWVyYVxuICAgIGNyZWF0ZUNhbWVyYSAoKSB7XG4gICAgICAgIGxldCBhY3RpdmVfY2FtZXJhID0gdGhpcy5nZXRBY3RpdmVDYW1lcmEoKTtcbiAgICAgICAgaWYgKGFjdGl2ZV9jYW1lcmEpIHtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhID0gQ2FtZXJhLmNyZWF0ZShhY3RpdmVfY2FtZXJhLCB0aGlzLCB0aGlzLnNjZW5lLmNvbmZpZy5jYW1lcmFzW2FjdGl2ZV9jYW1lcmFdKTtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVZpZXcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldCBhY3RpdmUgY2FtZXJhIC0gZm9yIHB1YmxpYyBBUElcbiAgICBnZXRBY3RpdmVDYW1lcmEgKCkge1xuICAgICAgICBpZiAodGhpcy5zY2VuZS5jb25maWcgJiYgdGhpcy5zY2VuZS5jb25maWcuY2FtZXJhcykge1xuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLnNjZW5lLmNvbmZpZy5jYW1lcmFzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmUuY29uZmlnLmNhbWVyYXNbbmFtZV0uYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBhY3RpdmUgY2FtZXJhIGFuZCByZWNvbXBpbGUgLSBmb3IgcHVibGljIEFQSVxuICAgIHNldEFjdGl2ZUNhbWVyYSAobmFtZSkge1xuICAgICAgICBsZXQgcHJldiA9IHRoaXMuZ2V0QWN0aXZlQ2FtZXJhKCk7XG4gICAgICAgIGlmICh0aGlzLnNjZW5lLmNvbmZpZy5jYW1lcmFzW25hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLnNjZW5lLmNvbmZpZy5jYW1lcmFzW25hbWVdLmFjdGl2ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIENsZWFyIHByZXZpb3VzbHkgYWN0aXZlIGNhbWVyYVxuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldiAhPT0gbmFtZSAmJiB0aGlzLnNjZW5lLmNvbmZpZy5jYW1lcmFzW3ByZXZdKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NlbmUuY29uZmlnLmNhbWVyYXNbcHJldl0uYWN0aXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY2VuZS51cGRhdGVDb25maWcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aXZlQ2FtZXJhKCk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIG1ldGhvZCBjYWxsZWQgb25jZSBwZXIgZnJhbWVcbiAgICB1cGRhdGUgKCkge1xuICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgbG9naWNhbCBwaXhlbCBzaXplIG9mIHZpZXdwb3J0XG4gICAgc2V0Vmlld3BvcnRTaXplICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuc2l6ZS5jc3MgPSB7IHdpZHRoLCBoZWlnaHQgfTtcbiAgICAgICAgdGhpcy5zaXplLmRldmljZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKHRoaXMuc2l6ZS5jc3Mud2lkdGggKiBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8pLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHRoaXMuc2l6ZS5jc3MuaGVpZ2h0ICogVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFzcGVjdCA9IHRoaXMuc2l6ZS5jc3Mud2lkdGggLyB0aGlzLnNpemUuY3NzLmhlaWdodDtcbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZHMoKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIG1hcCB2aWV3LCBjYW4gYmUgcGFzc2VkIGFuIG9iamVjdCB3aXRoIGxhdC9sbmcgYW5kL29yIHpvb21cbiAgICBzZXRWaWV3ICh7IGxuZywgbGF0LCB6b29tIH0gPSB7fSkge1xuICAgICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNldCBjZW50ZXJcbiAgICAgICAgaWYgKHR5cGVvZiBsbmcgPT09ICdudW1iZXInICYmIHR5cGVvZiBsYXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2VudGVyIHx8IGxuZyAhPT0gdGhpcy5jZW50ZXIubG5nIHx8IGxhdCAhPT0gdGhpcy5jZW50ZXIubGF0KSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jZW50ZXIgPSB7IGxuZzogR2VvLndyYXBMbmcobG5nKSwgbGF0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgem9vbVxuICAgICAgICBpZiAodHlwZW9mIHpvb20gPT09ICdudW1iZXInICYmIHpvb20gIT09IHRoaXMuem9vbSkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNldFpvb20oem9vbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCb3VuZHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG5cbiAgICBzZXRab29tICh6b29tKSB7XG4gICAgICAgIGlmICh0aGlzLnpvb21pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sYXN0X3pvb20gPSB0aGlzLnpvb207XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGFzdF90aWxlX3pvb20gPSB0aGlzLnRpbGVfem9vbTtcbiAgICAgICAgbGV0IHRpbGVfem9vbSA9IHRoaXMudGlsZVpvb20oem9vbSk7XG4gICAgICAgIGlmICghdGhpcy5jb250aW51b3VzX3pvb20pIHtcbiAgICAgICAgICAgIHpvb20gPSB0aWxlX3pvb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGlsZV96b29tICE9PSBsYXN0X3RpbGVfem9vbSkge1xuICAgICAgICAgICAgdGhpcy56b29tX2RpcmVjdGlvbiA9IHRpbGVfem9vbSA+IGxhc3RfdGlsZV96b29tID8gMSA6IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0X3pvb20gPSB0aGlzLnpvb207XG4gICAgICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgICAgIHRoaXMudGlsZV96b29tID0gdGlsZV96b29tO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRzKCk7XG4gICAgICAgIHRoaXMuc2NlbmUucmVxdWVzdFJlZHJhdygpO1xuICAgIH1cblxuICAgIHN0YXJ0Wm9vbSAoKSB7XG4gICAgICAgIHRoaXMubGFzdF96b29tID0gdGhpcy56b29tO1xuICAgICAgICB0aGlzLnpvb21pbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIENob29zZSB0aGUgYmFzZSB6b29tIGxldmVsIHRvIHVzZSBmb3IgYSBnaXZlbiBmcmFjdGlvbmFsIHpvb21cbiAgICBiYXNlWm9vbSAoem9vbSkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih6b29tKTtcbiAgICB9XG5cbiAgICAvLyBGb3IgYSBnaXZlbiB2aWV3IHpvb20sIHdoYXQgdGlsZSB6b29tIHNob3VsZCBiZSBsb2FkZWQ/XG4gICAgdGlsZVpvb20gKHZpZXdfem9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlWm9vbSh2aWV3X3pvb20pIC0gdGhpcy50aWxlX3NpbXBsaWZpY2F0aW9uX2xldmVsO1xuICAgIH1cblxuICAgIC8vIEZvciBhIGdpdmVuIHRpbGUgem9vbSwgd2hhdCBzdHlsZSB6b29tIHNob3VsZCBiZSB1c2VkP1xuICAgIHN0eWxlWm9vbSAodGlsZV96b29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2Vab29tKHRpbGVfem9vbSkgKyB0aGlzLnRpbGVfc2ltcGxpZmljYXRpb25fbGV2ZWw7XG4gICAgfVxuXG4gICAgcmVhZHkgKCkge1xuICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgY29uY2VwdCBvZiBcInJlYWRpbmVzc1wiIHN0YXRlP1xuICAgICAgICBpZiAodGhpcy5zaXplLmNzcyA9PSBudWxsIHx8IHRoaXMuY2VudGVyID09IG51bGwgfHwgdGhpcy56b29tID09IG51bGwpIHtcbiAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHZpZXdwb3J0IGJvdW5kcyBiYXNlZCBvbiBjdXJyZW50IGNlbnRlciBhbmQgem9vbVxuICAgIHVwZGF0ZUJvdW5kcyAoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1ldGVyc19wZXJfcGl4ZWwgPSBHZW8ubWV0ZXJzUGVyUGl4ZWwodGhpcy56b29tKTtcblxuICAgICAgICAvLyBTaXplIG9mIHRoZSBoYWxmLXZpZXdwb3J0IGluIG1ldGVycyBhdCBjdXJyZW50IHpvb21cbiAgICAgICAgdGhpcy5zaXplLm1ldGVycyA9IHtcbiAgICAgICAgICAgIHg6IHRoaXMuc2l6ZS5jc3Mud2lkdGggKiB0aGlzLm1ldGVyc19wZXJfcGl4ZWwsXG4gICAgICAgICAgICB5OiB0aGlzLnNpemUuY3NzLmhlaWdodCAqIHRoaXMubWV0ZXJzX3Blcl9waXhlbFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENlbnRlciBvZiB2aWV3cG9ydCBpbiBtZXRlcnMsIGFuZCB0aWxlXG4gICAgICAgIGxldCBbeCwgeV0gPSBHZW8ubGF0TG5nVG9NZXRlcnMoW3RoaXMuY2VudGVyLmxuZywgdGhpcy5jZW50ZXIubGF0XSk7XG4gICAgICAgIHRoaXMuY2VudGVyLm1ldGVycyA9IHsgeCwgeSB9O1xuXG4gICAgICAgIHRoaXMuY2VudGVyLnRpbGUgPSBHZW8udGlsZUZvck1ldGVycyhbdGhpcy5jZW50ZXIubWV0ZXJzLngsIHRoaXMuY2VudGVyLm1ldGVycy55XSwgdGhpcy50aWxlX3pvb20pO1xuXG4gICAgICAgIC8vIEJvdW5kcyBpbiBtZXRlcnNcbiAgICAgICAgdGhpcy5ib3VuZHMgPSB7XG4gICAgICAgICAgICBzdzoge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMuY2VudGVyLm1ldGVycy54IC0gdGhpcy5zaXplLm1ldGVycy54IC8gMixcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmNlbnRlci5tZXRlcnMueSAtIHRoaXMuc2l6ZS5tZXRlcnMueSAvIDJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZToge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMuY2VudGVyLm1ldGVycy54ICsgdGhpcy5zaXplLm1ldGVycy54IC8gMixcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmNlbnRlci5tZXRlcnMueSArIHRoaXMuc2l6ZS5tZXRlcnMueSAvIDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNjZW5lLnRpbGVfbWFuYWdlci51cGRhdGVUaWxlc0ZvclZpZXcodGhpcy52aWV3KTtcblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ21vdmUnKTtcbiAgICAgICAgdGhpcy5zY2VuZS5yZXF1ZXN0UmVkcmF3KCk7IC8vIFRPRE8gYXV0b21hdGUgdmlhIG1vdmUgZXZlbnQ/XG4gICAgfVxuXG4gICAgZmluZFZpc2libGVUaWxlQ29vcmRpbmF0ZXMgKCkge1xuICAgICAgICBpZiAoIXRoaXMuYm91bmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgeiA9IHRoaXMudGlsZV96b29tO1xuICAgICAgICBsZXQgc3cgPSBHZW8udGlsZUZvck1ldGVycyhbdGhpcy5ib3VuZHMuc3cueCwgdGhpcy5ib3VuZHMuc3cueV0sIHopO1xuICAgICAgICBsZXQgbmUgPSBHZW8udGlsZUZvck1ldGVycyhbdGhpcy5ib3VuZHMubmUueCwgdGhpcy5ib3VuZHMubmUueV0sIHopO1xuXG4gICAgICAgIGxldCBjb29yZHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IHN3LnggLSB0aGlzLmJ1ZmZlcjsgeCA8PSBuZS54ICsgdGhpcy5idWZmZXI7IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IG5lLnkgLSB0aGlzLmJ1ZmZlcjsgeSA8PSBzdy55ICsgdGhpcy5idWZmZXI7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKFRpbGUuY29vcmQoeyB4LCB5LCB6IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSB0aWxlcyB0b28gZmFyIG91dHNpZGUgb2Ygdmlld1xuICAgIHBydW5lVGlsZXNGb3JWaWV3ICgpIHtcbiAgICAgICAgLy8gVE9ETzogd2lsbCB0aGlzIGZ1bmN0aW9uIGV2ZXIgYmUgY2FsbGVkIHdoZW4gdmlldyBpc24ndCByZWFkeT9cbiAgICAgICAgaWYgKCF0aGlzLnJlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aWxlcyB0aGF0IGFyZSBhIHNwZWNpZmllZCAjIG9mIHRpbGVzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0IGJvcmRlclxuICAgICAgICBsZXQgYm9yZGVyX3RpbGVzID0gW1xuICAgICAgICAgICAgTWF0aC5jZWlsKChNYXRoLmZsb29yKHRoaXMuc2l6ZS5jc3Mud2lkdGggLyBHZW8udGlsZV9zaXplKSArIDIpIC8gMiksXG4gICAgICAgICAgICBNYXRoLmNlaWwoKE1hdGguZmxvb3IodGhpcy5zaXplLmNzcy5oZWlnaHQgLyBHZW8udGlsZV9zaXplKSArIDIpIC8gMilcbiAgICAgICAgXTtcblxuICAgICAgICB0aGlzLnNjZW5lLnRpbGVfbWFuYWdlci5yZW1vdmVUaWxlcyh0aWxlID0+IHtcbiAgICAgICAgICAgIC8vIElnbm9yZSB2aXNpYmxlIHRpbGVzXG4gICAgICAgICAgICBpZiAodGlsZS52aXNpYmxlIHx8IHRpbGUucHJveHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aWxlcyBvdXRzaWRlIGdpdmVuIHpvb20gdGhhdCBhcmUgc3RpbGwgbG9hZGluZ1xuICAgICAgICAgICAgaWYgKHRpbGUubG9hZGluZyAmJiB0aWxlLnN0eWxlX3pvb20gIT09IHRoaXMudGlsZV96b29tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc2NhcmQgaWYgdG9vIGZhciBmcm9tIGN1cnJlbnQgem9vbVxuICAgICAgICAgICAgbGV0IHpkaWZmID0gTWF0aC5hYnModGlsZS5zdHlsZV96b29tIC0gdGhpcy50aWxlX3pvb20pO1xuICAgICAgICAgICAgaWYgKHpkaWZmID4gdGhpcy5wcmVzZXJ2ZV90aWxlc193aXRoaW5fem9vbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYW5kbGUgdGlsZXMgYXQgZGlmZmVyZW50IHpvb21zXG4gICAgICAgICAgICBsZXQgY29vcmRzID0gVGlsZS5jb29yZGluYXRlQXRab29tKHRpbGUuY29vcmRzLCB0aGlzLnRpbGVfem9vbSk7XG5cbiAgICAgICAgICAgIC8vIERpc2NhcmQgdGlsZXMgb3V0c2lkZSBhbiBhcmVhIHN1cnJvdW5kaW5nIHRoZSB2aWV3cG9ydFxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGNvb3Jkcy54IC0gdGhpcy5jZW50ZXIudGlsZS54KSAtIGJvcmRlcl90aWxlc1swXSA+IHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgbG9nLnRyYWNlKGBWaWV3OiByZW1vdmUgdGlsZSAke3RpbGUua2V5fSAoYXMgJHtjb29yZHMueH0vJHtjb29yZHMueX0vJHt0aGlzLnRpbGVfem9vbX0pIGZvciBiZWluZyB0b28gZmFyIG91dCBvZiB2aXNpYmxlIGFyZWEgKioqYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhjb29yZHMueSAtIHRoaXMuY2VudGVyLnRpbGUueSkgLSBib3JkZXJfdGlsZXNbMV0gPiB0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGxvZy50cmFjZShgVmlldzogcmVtb3ZlIHRpbGUgJHt0aWxlLmtleX0gKGFzICR7Y29vcmRzLnh9LyR7Y29vcmRzLnl9LyR7dGhpcy50aWxlX3pvb219KSBmb3IgYmVpbmcgdG9vIGZhciBvdXQgb2YgdmlzaWJsZSBhcmVhICoqKmApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBbGxvY2F0ZSBtb2RlbC12aWV3IG1hdHJpY2VzXG4gICAgLy8gNjQtYml0IHZlcnNpb25zIGFyZSBmb3IgQ1BVIGNhbGN1YXRpb25zXG4gICAgLy8gMzItYml0IHZlcnNpb25zIGFyZSBkb3duc2FtcGxlZCBhbmQgc2VudCB0byBHUFVcbiAgICBjcmVhdGVNYXRyaWNlcyAoKSB7XG4gICAgICAgIHRoaXMubWF0cmljZXMgPSB7fTtcbiAgICAgICAgdGhpcy5tYXRyaWNlcy5tb2RlbCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICAgICAgICB0aGlzLm1hdHJpY2VzLm1vZGVsMzIgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICAgICAgdGhpcy5tYXRyaWNlcy5tb2RlbF92aWV3ID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG4gICAgICAgIHRoaXMubWF0cmljZXMubW9kZWxfdmlldzMyID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgICAgIHRoaXMubWF0cmljZXMubm9ybWFsID0gbmV3IEZsb2F0NjRBcnJheSg5KTtcbiAgICAgICAgdGhpcy5tYXRyaWNlcy5ub3JtYWwzMiA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7XG4gICAgICAgIHRoaXMubWF0cmljZXMuaW52ZXJzZV9ub3JtYWwzMiA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGFuZCBzZXQgbW9kZWwvdmlldyBhbmQgbm9ybWFsIG1hdHJpY2VzIGZvciBhIHRpbGVcbiAgICBzZXR1cFRpbGUgKHRpbGUsIHByb2dyYW0pIHtcbiAgICAgICAgLy8gVGlsZS1zcGVjaWZpYyBzdGF0ZVxuICAgICAgICAvLyBUT0RPOiBjYWxjIHRoZXNlIG9uY2UgcGVyIHRpbGUgKGN1cnJlbnRseSBiZWluZyBuZWVkbGVzc2x5IHJlLWNhbGN1bGF0ZWQgcGVyLXRpbGUtcGVyLXN0eWxlKVxuICAgICAgICB0aWxlLnNldHVwUHJvZ3JhbSh0aGlzLm1hdHJpY2VzLCBwcm9ncmFtKTtcblxuICAgICAgICAvLyBNb2RlbC12aWV3IGFuZCBub3JtYWwgbWF0cmljZXNcbiAgICAgICAgdGhpcy5jYW1lcmEuc2V0dXBNYXRyaWNlcyh0aGlzLm1hdHJpY2VzLCBwcm9ncmFtKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgZ2VuZXJhbCB1bmlmb3JtcyB0aGF0IG11c3QgYmUgdXBkYXRlZCBvbmNlIHBlciBwcm9ncmFtXG4gICAgc2V0dXBQcm9ncmFtIChwcm9ncmFtKSB7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnMmYnLCAndV9yZXNvbHV0aW9uJywgdGhpcy5zaXplLmRldmljZS53aWR0aCwgdGhpcy5zaXplLmRldmljZS5oZWlnaHQpO1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzNmJywgJ3VfbWFwX3Bvc2l0aW9uJywgdGhpcy5jZW50ZXIubWV0ZXJzLngsIHRoaXMuY2VudGVyLm1ldGVycy55LCB0aGlzLnpvb20pO1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzFmJywgJ3VfbWV0ZXJzX3Blcl9waXhlbCcsIHRoaXMubWV0ZXJzX3Blcl9waXhlbCk7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnMWYnLCAndV9kZXZpY2VfcGl4ZWxfcmF0aW8nLCBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8pO1xuXG4gICAgICAgIHRoaXMuY2FtZXJhLnNldHVwUHJvZ3JhbShwcm9ncmFtKTtcbiAgICB9XG5cbn1cbiJdfQ==

Tangram.debug.commit = 'f933c9b1f81dc9997f5d90f24126cb142d81adc3';
