(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":25}],2:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":26}],3:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/is-iterable"), __esModule: true };
},{"core-js/library/fn/is-iterable":27}],4:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/map"), __esModule: true };
},{"core-js/library/fn/map":28}],5:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/math/log2"), __esModule: true };
},{"core-js/library/fn/math/log2":29}],6:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":30}],7:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":31}],8:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/object/define-properties"), __esModule: true };
},{"core-js/library/fn/object/define-properties":32}],9:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":33}],10:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/object/get-own-property-descriptor"), __esModule: true };
},{"core-js/library/fn/object/get-own-property-descriptor":34}],11:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":35}],12:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":36}],13:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/promise"), __esModule: true };
},{"core-js/library/fn/promise":37}],14:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/set"), __esModule: true };
},{"core-js/library/fn/set":38}],15:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":39}],16:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":40}],17:[function(_dereq_,module,exports){
"use strict";

exports["default"] = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

exports.__esModule = true;
},{}],18:[function(_dereq_,module,exports){
"use strict";

var _Object$defineProperty = _dereq_("babel-runtime/core-js/object/define-property")["default"];

exports["default"] = (function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;

      _Object$defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
})();

exports.__esModule = true;
},{"babel-runtime/core-js/object/define-property":9}],19:[function(_dereq_,module,exports){
"use strict";

var _Object$defineProperty = _dereq_("babel-runtime/core-js/object/define-property")["default"];

exports["default"] = function (obj, key, value) {
  if (key in obj) {
    _Object$defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/define-property":9}],20:[function(_dereq_,module,exports){
"use strict";

var _Object$getOwnPropertyDescriptor = _dereq_("babel-runtime/core-js/object/get-own-property-descriptor")["default"];

exports["default"] = function get(_x, _x2, _x3) {
  var _again = true;

  _function: while (_again) {
    var object = _x,
        property = _x2,
        receiver = _x3;
    _again = false;
    if (object === null) object = Function.prototype;

    var desc = _Object$getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        _x = parent;
        _x2 = property;
        _x3 = receiver;
        _again = true;
        desc = parent = undefined;
        continue _function;
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  }
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/get-own-property-descriptor":10}],21:[function(_dereq_,module,exports){
"use strict";

var _Object$create = _dereq_("babel-runtime/core-js/object/create")["default"];

var _Object$setPrototypeOf = _dereq_("babel-runtime/core-js/object/set-prototype-of")["default"];

exports["default"] = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = _Object$create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/create":7,"babel-runtime/core-js/object/set-prototype-of":12}],22:[function(_dereq_,module,exports){
"use strict";

exports["default"] = function (obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
};

exports.__esModule = true;
},{}],23:[function(_dereq_,module,exports){
"use strict";

var _getIterator = _dereq_("babel-runtime/core-js/get-iterator")["default"];

var _isIterable = _dereq_("babel-runtime/core-js/is-iterable")["default"];

exports["default"] = (function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = _getIterator(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (_isIterable(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
})();

exports.__esModule = true;
},{"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/is-iterable":3}],24:[function(_dereq_,module,exports){
"use strict";

var _Array$from = _dereq_("babel-runtime/core-js/array/from")["default"];

exports["default"] = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return _Array$from(arr);
  }
};

exports.__esModule = true;
},{"babel-runtime/core-js/array/from":1}],25:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.string.iterator');
_dereq_('../../modules/es6.array.from');
module.exports = _dereq_('../../modules/$.core').Array.from;
},{"../../modules/$.core":49,"../../modules/es6.array.from":101,"../../modules/es6.string.iterator":112}],26:[function(_dereq_,module,exports){
_dereq_('../modules/web.dom.iterable');
_dereq_('../modules/es6.string.iterator');
module.exports = _dereq_('../modules/core.get-iterator');
},{"../modules/core.get-iterator":99,"../modules/es6.string.iterator":112,"../modules/web.dom.iterable":116}],27:[function(_dereq_,module,exports){
_dereq_('../modules/web.dom.iterable');
_dereq_('../modules/es6.string.iterator');
module.exports = _dereq_('../modules/core.is-iterable');
},{"../modules/core.is-iterable":100,"../modules/es6.string.iterator":112,"../modules/web.dom.iterable":116}],28:[function(_dereq_,module,exports){
_dereq_('../modules/es6.object.to-string');
_dereq_('../modules/es6.string.iterator');
_dereq_('../modules/web.dom.iterable');
_dereq_('../modules/es6.map');
_dereq_('../modules/es7.map.to-json');
module.exports = _dereq_('../modules/$.core').Map;
},{"../modules/$.core":49,"../modules/es6.map":103,"../modules/es6.object.to-string":109,"../modules/es6.string.iterator":112,"../modules/es7.map.to-json":114,"../modules/web.dom.iterable":116}],29:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.math.log2');
module.exports = _dereq_('../../modules/$.core').Math.log2;
},{"../../modules/$.core":49,"../../modules/es6.math.log2":104}],30:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.object.assign');
module.exports = _dereq_('../../modules/$.core').Object.assign;
},{"../../modules/$.core":49,"../../modules/es6.object.assign":105}],31:[function(_dereq_,module,exports){
var $ = _dereq_('../../modules/$');
module.exports = function create(P, D){
  return $.create(P, D);
};
},{"../../modules/$":74}],32:[function(_dereq_,module,exports){
var $ = _dereq_('../../modules/$');
module.exports = function defineProperties(T, D){
  return $.setDescs(T, D);
};
},{"../../modules/$":74}],33:[function(_dereq_,module,exports){
var $ = _dereq_('../../modules/$');
module.exports = function defineProperty(it, key, desc){
  return $.setDesc(it, key, desc);
};
},{"../../modules/$":74}],34:[function(_dereq_,module,exports){
var $ = _dereq_('../../modules/$');
_dereq_('../../modules/es6.object.get-own-property-descriptor');
module.exports = function getOwnPropertyDescriptor(it, key){
  return $.getDesc(it, key);
};
},{"../../modules/$":74,"../../modules/es6.object.get-own-property-descriptor":106}],35:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.object.keys');
module.exports = _dereq_('../../modules/$.core').Object.keys;
},{"../../modules/$.core":49,"../../modules/es6.object.keys":107}],36:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.object.set-prototype-of');
module.exports = _dereq_('../../modules/$.core').Object.setPrototypeOf;
},{"../../modules/$.core":49,"../../modules/es6.object.set-prototype-of":108}],37:[function(_dereq_,module,exports){
_dereq_('../modules/es6.object.to-string');
_dereq_('../modules/es6.string.iterator');
_dereq_('../modules/web.dom.iterable');
_dereq_('../modules/es6.promise');
module.exports = _dereq_('../modules/$.core').Promise;
},{"../modules/$.core":49,"../modules/es6.object.to-string":109,"../modules/es6.promise":110,"../modules/es6.string.iterator":112,"../modules/web.dom.iterable":116}],38:[function(_dereq_,module,exports){
_dereq_('../modules/es6.object.to-string');
_dereq_('../modules/es6.string.iterator');
_dereq_('../modules/web.dom.iterable');
_dereq_('../modules/es6.set');
_dereq_('../modules/es7.set.to-json');
module.exports = _dereq_('../modules/$.core').Set;
},{"../modules/$.core":49,"../modules/es6.object.to-string":109,"../modules/es6.set":111,"../modules/es6.string.iterator":112,"../modules/es7.set.to-json":115,"../modules/web.dom.iterable":116}],39:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.symbol');
_dereq_('../../modules/es6.object.to-string');
module.exports = _dereq_('../../modules/$.core').Symbol;
},{"../../modules/$.core":49,"../../modules/es6.object.to-string":109,"../../modules/es6.symbol":113}],40:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.string.iterator');
_dereq_('../../modules/web.dom.iterable');
module.exports = _dereq_('../../modules/$.wks')('iterator');
},{"../../modules/$.wks":97,"../../modules/es6.string.iterator":112,"../../modules/web.dom.iterable":116}],41:[function(_dereq_,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],42:[function(_dereq_,module,exports){
module.exports = function(){ /* empty */ };
},{}],43:[function(_dereq_,module,exports){
var isObject = _dereq_('./$.is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./$.is-object":67}],44:[function(_dereq_,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = _dereq_('./$.cof')
  , TAG = _dereq_('./$.wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./$.cof":45,"./$.wks":97}],45:[function(_dereq_,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],46:[function(_dereq_,module,exports){
'use strict';
var $            = _dereq_('./$')
  , hide         = _dereq_('./$.hide')
  , mix          = _dereq_('./$.mix')
  , ctx          = _dereq_('./$.ctx')
  , strictNew    = _dereq_('./$.strict-new')
  , defined      = _dereq_('./$.defined')
  , forOf        = _dereq_('./$.for-of')
  , $iterDefine  = _dereq_('./$.iter-define')
  , step         = _dereq_('./$.iter-step')
  , ID           = _dereq_('./$.uid')('id')
  , $has         = _dereq_('./$.has')
  , isObject     = _dereq_('./$.is-object')
  , setSpecies   = _dereq_('./$.set-species')
  , DESCRIPTORS  = _dereq_('./$.descriptors')
  , isExtensible = Object.isExtensible || isObject
  , SIZE         = DESCRIPTORS ? '_s' : 'size'
  , id           = 0;

var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!$has(it, ID)){
    // can't set id to frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add id
    if(!create)return 'E';
    // add missing object id
    hide(it, ID, ++id);
  // return object id with prefix
  } return 'O' + it[ID];
};

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      strictNew(that, C, NAME);
      that._i = $.create(null); // index
      that._f = undefined;      // first entry
      that._l = undefined;      // last entry
      that[SIZE] = 0;           // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    mix(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)$.setDesc(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};
},{"./$":74,"./$.ctx":50,"./$.defined":52,"./$.descriptors":53,"./$.for-of":57,"./$.has":60,"./$.hide":61,"./$.is-object":67,"./$.iter-define":70,"./$.iter-step":72,"./$.mix":78,"./$.set-species":85,"./$.strict-new":89,"./$.uid":96}],47:[function(_dereq_,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var forOf   = _dereq_('./$.for-of')
  , classof = _dereq_('./$.classof');
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    var arr = [];
    forOf(this, false, arr.push, arr);
    return arr;
  };
};
},{"./$.classof":44,"./$.for-of":57}],48:[function(_dereq_,module,exports){
'use strict';
var global         = _dereq_('./$.global')
  , $              = _dereq_('./$')
  , $def           = _dereq_('./$.def')
  , fails          = _dereq_('./$.fails')
  , hide           = _dereq_('./$.hide')
  , mix            = _dereq_('./$.mix')
  , forOf          = _dereq_('./$.for-of')
  , strictNew      = _dereq_('./$.strict-new')
  , isObject       = _dereq_('./$.is-object')
  , DESCRIPTORS    = _dereq_('./$.descriptors')
  , setToStringTag = _dereq_('./$.set-to-string-tag');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    mix(C.prototype, methods);
  } else {
    C = wrapper(function(target, iterable){
      strictNew(target, C, NAME);
      target._c = new Base;
      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
    });
    $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','),function(KEY){
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    if('size' in proto)$.setDesc(C.prototype, 'size', {
      get: function(){
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $def($def.G + $def.W + $def.F, O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./$":74,"./$.def":51,"./$.descriptors":53,"./$.fails":56,"./$.for-of":57,"./$.global":59,"./$.hide":61,"./$.is-object":67,"./$.mix":78,"./$.set-to-string-tag":86,"./$.strict-new":89}],49:[function(_dereq_,module,exports){
var core = module.exports = {version: '1.2.5'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],50:[function(_dereq_,module,exports){
// optional / simple context binding
var aFunction = _dereq_('./$.a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./$.a-function":41}],51:[function(_dereq_,module,exports){
var global    = _dereq_('./$.global')
  , core      = _dereq_('./$.core')
  , PROTOTYPE = 'prototype';
var ctx = function(fn, that){
  return function(){
    return fn.apply(that, arguments);
  };
};
var $def = function(type, name, source){
  var key, own, out, exp
    , isGlobal = type & $def.G
    , isProto  = type & $def.P
    , target   = isGlobal ? global : type & $def.S
        ? global[name] : (global[name] || {})[PROTOTYPE]
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // contains in native
    own = !(type & $def.F) && target && key in target;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    if(isGlobal && typeof target[key] != 'function')exp = source[key];
    // bind timers to global for call from export context
    else if(type & $def.B && own)exp = ctx(out, global);
    // wrap global constructors for prevent change them in library
    else if(type & $def.W && target[key] == out)!function(C){
      exp = function(param){
        return this instanceof C ? new C(param) : C(param);
      };
      exp[PROTOTYPE] = C[PROTOTYPE];
    }(out);
    else exp = isProto && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export
    exports[key] = exp;
    if(isProto)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
  }
};
// type bitmap
$def.F = 1;  // forced
$def.G = 2;  // global
$def.S = 4;  // static
$def.P = 8;  // proto
$def.B = 16; // bind
$def.W = 32; // wrap
module.exports = $def;
},{"./$.core":49,"./$.global":59}],52:[function(_dereq_,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],53:[function(_dereq_,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !_dereq_('./$.fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./$.fails":56}],54:[function(_dereq_,module,exports){
var isObject = _dereq_('./$.is-object')
  , document = _dereq_('./$.global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./$.global":59,"./$.is-object":67}],55:[function(_dereq_,module,exports){
// all enumerable object keys, includes symbols
var $ = _dereq_('./$');
module.exports = function(it){
  var keys       = $.getKeys(it)
    , getSymbols = $.getSymbols;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = $.isEnum
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
  }
  return keys;
};
},{"./$":74}],56:[function(_dereq_,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],57:[function(_dereq_,module,exports){
var ctx         = _dereq_('./$.ctx')
  , call        = _dereq_('./$.iter-call')
  , isArrayIter = _dereq_('./$.is-array-iter')
  , anObject    = _dereq_('./$.an-object')
  , toLength    = _dereq_('./$.to-length')
  , getIterFn   = _dereq_('./core.get-iterator-method');
module.exports = function(iterable, entries, fn, that){
  var iterFn = getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    call(iterator, f, step.value, entries);
  }
};
},{"./$.an-object":43,"./$.ctx":50,"./$.is-array-iter":65,"./$.iter-call":68,"./$.to-length":94,"./core.get-iterator-method":98}],58:[function(_dereq_,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toString  = {}.toString
  , toIObject = _dereq_('./$.to-iobject')
  , getNames  = _dereq_('./$').getNames;

var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return getNames(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.get = function getOwnPropertyNames(it){
  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
  return getNames(toIObject(it));
};
},{"./$":74,"./$.to-iobject":93}],59:[function(_dereq_,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],60:[function(_dereq_,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],61:[function(_dereq_,module,exports){
var $          = _dereq_('./$')
  , createDesc = _dereq_('./$.property-desc');
module.exports = _dereq_('./$.descriptors') ? function(object, key, value){
  return $.setDesc(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./$":74,"./$.descriptors":53,"./$.property-desc":81}],62:[function(_dereq_,module,exports){
module.exports = _dereq_('./$.global').document && document.documentElement;
},{"./$.global":59}],63:[function(_dereq_,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],64:[function(_dereq_,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = _dereq_('./$.cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./$.cof":45}],65:[function(_dereq_,module,exports){
// check on default Array iterator
var Iterators  = _dereq_('./$.iterators')
  , ITERATOR   = _dereq_('./$.wks')('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return (Iterators.Array || ArrayProto[ITERATOR]) === it;
};
},{"./$.iterators":73,"./$.wks":97}],66:[function(_dereq_,module,exports){
// 7.2.2 IsArray(argument)
var cof = _dereq_('./$.cof');
module.exports = Array.isArray || function(arg){
  return cof(arg) == 'Array';
};
},{"./$.cof":45}],67:[function(_dereq_,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],68:[function(_dereq_,module,exports){
// call something on iterator step with safe closing on error
var anObject = _dereq_('./$.an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./$.an-object":43}],69:[function(_dereq_,module,exports){
'use strict';
var $              = _dereq_('./$')
  , descriptor     = _dereq_('./$.property-desc')
  , setToStringTag = _dereq_('./$.set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
_dereq_('./$.hide')(IteratorPrototype, _dereq_('./$.wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./$":74,"./$.hide":61,"./$.property-desc":81,"./$.set-to-string-tag":86,"./$.wks":97}],70:[function(_dereq_,module,exports){
'use strict';
var LIBRARY         = _dereq_('./$.library')
  , $def            = _dereq_('./$.def')
  , $redef          = _dereq_('./$.redef')
  , hide            = _dereq_('./$.hide')
  , has             = _dereq_('./$.has')
  , SYMBOL_ITERATOR = _dereq_('./$.wks')('iterator')
  , Iterators       = _dereq_('./$.iterators')
  , $iterCreate     = _dereq_('./$.iter-create')
  , setToStringTag  = _dereq_('./$.set-to-string-tag')
  , getProto        = _dereq_('./$').getProto
  , BUGGY           = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR     = '@@iterator'
  , KEYS            = 'keys'
  , VALUES          = 'values';
var returnThis = function(){ return this; };
module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG      = NAME + ' Iterator'
    , proto    = Base.prototype
    , _native  = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , _default = _native || getMethod(DEFAULT)
    , methods, key;
  // Fix native
  if(_native){
    var IteratorPrototype = getProto(_default.call(new Base));
    // Set @@toStringTag to native iterators
    setToStringTag(IteratorPrototype, TAG, true);
    // FF fix
    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, SYMBOL_ITERATOR, returnThis);
  }
  // Define iterator
  if((!LIBRARY || FORCE) && (BUGGY || !(SYMBOL_ITERATOR in proto))){
    hide(proto, SYMBOL_ITERATOR, _default);
  }
  // Plug for library
  Iterators[NAME] = _default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEFAULT == VALUES ? _default : getMethod(VALUES),
      keys:    IS_SET            ? _default : getMethod(KEYS),
      entries: DEFAULT != VALUES ? _default : getMethod('entries')
    };
    if(FORCE)for(key in methods){
      if(!(key in proto))$redef(proto, key, methods[key]);
    } else $def($def.P + $def.F * BUGGY, NAME, methods);
  }
  return methods;
};
},{"./$":74,"./$.def":51,"./$.has":60,"./$.hide":61,"./$.iter-create":69,"./$.iterators":73,"./$.library":76,"./$.redef":82,"./$.set-to-string-tag":86,"./$.wks":97}],71:[function(_dereq_,module,exports){
var ITERATOR     = _dereq_('./$.wks')('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ safe = true; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./$.wks":97}],72:[function(_dereq_,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],73:[function(_dereq_,module,exports){
module.exports = {};
},{}],74:[function(_dereq_,module,exports){
var $Object = Object;
module.exports = {
  create:     $Object.create,
  getProto:   $Object.getPrototypeOf,
  isEnum:     {}.propertyIsEnumerable,
  getDesc:    $Object.getOwnPropertyDescriptor,
  setDesc:    $Object.defineProperty,
  setDescs:   $Object.defineProperties,
  getKeys:    $Object.keys,
  getNames:   $Object.getOwnPropertyNames,
  getSymbols: $Object.getOwnPropertySymbols,
  each:       [].forEach
};
},{}],75:[function(_dereq_,module,exports){
var $         = _dereq_('./$')
  , toIObject = _dereq_('./$.to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = $.getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./$":74,"./$.to-iobject":93}],76:[function(_dereq_,module,exports){
module.exports = true;
},{}],77:[function(_dereq_,module,exports){
var global    = _dereq_('./$.global')
  , macrotask = _dereq_('./$.task').set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , isNode    = _dereq_('./$.cof')(process) == 'process'
  , head, last, notify;

var flush = function(){
  var parent, domain;
  if(isNode && (parent = process.domain)){
    process.domain = null;
    parent.exit();
  }
  while(head){
    domain = head.domain;
    if(domain)domain.enter();
    head.fn.call(); // <- currently we use it only for Promise - try / catch not required
    if(domain)domain.exit();
    head = head.next;
  } last = undefined;
  if(parent)parent.enter();
};

// Node.js
if(isNode){
  notify = function(){
    process.nextTick(flush);
  };
// browsers with MutationObserver
} else if(Observer){
  var toggle = 1
    , node   = document.createTextNode('');
  new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
  notify = function(){
    node.data = toggle = -toggle;
  };
// for other environments - macrotask based on:
// - setImmediate
// - MessageChannel
// - window.postMessag
// - onreadystatechange
// - setTimeout
} else {
  notify = function(){
    // strange IE + webpack dev server bug - use .call(global)
    macrotask.call(global, flush);
  };
}

module.exports = function asap(fn){
  var task = {fn: fn, next: undefined, domain: isNode && process.domain};
  if(last)last.next = task;
  if(!head){
    head = task;
    notify();
  } last = task;
};
},{"./$.cof":45,"./$.global":59,"./$.task":91}],78:[function(_dereq_,module,exports){
var $redef = _dereq_('./$.redef');
module.exports = function(target, src){
  for(var key in src)$redef(target, key, src[key]);
  return target;
};
},{"./$.redef":82}],79:[function(_dereq_,module,exports){
// 19.1.2.1 Object.assign(target, source, ...)
var $        = _dereq_('./$')
  , toObject = _dereq_('./$.to-object')
  , IObject  = _dereq_('./$.iobject');

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = _dereq_('./$.fails')(function(){
  var a = Object.assign
    , A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , $$    = arguments
    , $$len = $$.length
    , index = 1
    , getKeys    = $.getKeys
    , getSymbols = $.getSymbols
    , isEnum     = $.isEnum;
  while($$len > index){
    var S      = IObject($$[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  }
  return T;
} : Object.assign;
},{"./$":74,"./$.fails":56,"./$.iobject":64,"./$.to-object":95}],80:[function(_dereq_,module,exports){
// most Object methods by ES6 should accept primitives
var $def  = _dereq_('./$.def')
  , core  = _dereq_('./$.core')
  , fails = _dereq_('./$.fails');
module.exports = function(KEY, exec){
  var $def = _dereq_('./$.def')
    , fn   = (core.Object || {})[KEY] || Object[KEY]
    , exp  = {};
  exp[KEY] = exec(fn);
  $def($def.S + $def.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./$.core":49,"./$.def":51,"./$.fails":56}],81:[function(_dereq_,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],82:[function(_dereq_,module,exports){
module.exports = _dereq_('./$.hide');
},{"./$.hide":61}],83:[function(_dereq_,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
},{}],84:[function(_dereq_,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var getDesc  = _dereq_('./$').getDesc
  , isObject = _dereq_('./$.is-object')
  , anObject = _dereq_('./$.an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = _dereq_('./$.ctx')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./$":74,"./$.an-object":43,"./$.ctx":50,"./$.is-object":67}],85:[function(_dereq_,module,exports){
'use strict';
var core        = _dereq_('./$.core')
  , $           = _dereq_('./$')
  , DESCRIPTORS = _dereq_('./$.descriptors')
  , SPECIES     = _dereq_('./$.wks')('species');

module.exports = function(KEY){
  var C = core[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])$.setDesc(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./$":74,"./$.core":49,"./$.descriptors":53,"./$.wks":97}],86:[function(_dereq_,module,exports){
var def = _dereq_('./$').setDesc
  , has = _dereq_('./$.has')
  , TAG = _dereq_('./$.wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./$":74,"./$.has":60,"./$.wks":97}],87:[function(_dereq_,module,exports){
var global = _dereq_('./$.global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./$.global":59}],88:[function(_dereq_,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = _dereq_('./$.an-object')
  , aFunction = _dereq_('./$.a-function')
  , SPECIES   = _dereq_('./$.wks')('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};
},{"./$.a-function":41,"./$.an-object":43,"./$.wks":97}],89:[function(_dereq_,module,exports){
module.exports = function(it, Constructor, name){
  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
  return it;
};
},{}],90:[function(_dereq_,module,exports){
var toInteger = _dereq_('./$.to-integer')
  , defined   = _dereq_('./$.defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l
      || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./$.defined":52,"./$.to-integer":92}],91:[function(_dereq_,module,exports){
'use strict';
var ctx                = _dereq_('./$.ctx')
  , invoke             = _dereq_('./$.invoke')
  , html               = _dereq_('./$.html')
  , cel                = _dereq_('./$.dom-create')
  , global             = _dereq_('./$.global')
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listner = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(_dereq_('./$.cof')(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listner, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./$.cof":45,"./$.ctx":50,"./$.dom-create":54,"./$.global":59,"./$.html":62,"./$.invoke":63}],92:[function(_dereq_,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],93:[function(_dereq_,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = _dereq_('./$.iobject')
  , defined = _dereq_('./$.defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./$.defined":52,"./$.iobject":64}],94:[function(_dereq_,module,exports){
// 7.1.15 ToLength
var toInteger = _dereq_('./$.to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./$.to-integer":92}],95:[function(_dereq_,module,exports){
// 7.1.13 ToObject(argument)
var defined = _dereq_('./$.defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./$.defined":52}],96:[function(_dereq_,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],97:[function(_dereq_,module,exports){
var store  = _dereq_('./$.shared')('wks')
  , uid    = _dereq_('./$.uid')
  , Symbol = _dereq_('./$.global').Symbol;
module.exports = function(name){
  return store[name] || (store[name] =
    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
};
},{"./$.global":59,"./$.shared":87,"./$.uid":96}],98:[function(_dereq_,module,exports){
var classof   = _dereq_('./$.classof')
  , ITERATOR  = _dereq_('./$.wks')('iterator')
  , Iterators = _dereq_('./$.iterators');
module.exports = _dereq_('./$.core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./$.classof":44,"./$.core":49,"./$.iterators":73,"./$.wks":97}],99:[function(_dereq_,module,exports){
var anObject = _dereq_('./$.an-object')
  , get      = _dereq_('./core.get-iterator-method');
module.exports = _dereq_('./$.core').getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};
},{"./$.an-object":43,"./$.core":49,"./core.get-iterator-method":98}],100:[function(_dereq_,module,exports){
var classof   = _dereq_('./$.classof')
  , ITERATOR  = _dereq_('./$.wks')('iterator')
  , Iterators = _dereq_('./$.iterators');
module.exports = _dereq_('./$.core').isIterable = function(it){
  var O = Object(it);
  return ITERATOR in O
    || '@@iterator' in O
    || Iterators.hasOwnProperty(classof(O));
};
},{"./$.classof":44,"./$.core":49,"./$.iterators":73,"./$.wks":97}],101:[function(_dereq_,module,exports){
'use strict';
var ctx         = _dereq_('./$.ctx')
  , $def        = _dereq_('./$.def')
  , toObject    = _dereq_('./$.to-object')
  , call        = _dereq_('./$.iter-call')
  , isArrayIter = _dereq_('./$.is-array-iter')
  , toLength    = _dereq_('./$.to-length')
  , getIterFn   = _dereq_('./core.get-iterator-method');
$def($def.S + $def.F * !_dereq_('./$.iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , $$      = arguments
      , $$len   = $$.length
      , mapfn   = $$len > 1 ? $$[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        result[index] = mapping ? mapfn(O[index], index) : O[index];
      }
    }
    result.length = index;
    return result;
  }
});

},{"./$.ctx":50,"./$.def":51,"./$.is-array-iter":65,"./$.iter-call":68,"./$.iter-detect":71,"./$.to-length":94,"./$.to-object":95,"./core.get-iterator-method":98}],102:[function(_dereq_,module,exports){
'use strict';
var addToUnscopables = _dereq_('./$.add-to-unscopables')
  , step             = _dereq_('./$.iter-step')
  , Iterators        = _dereq_('./$.iterators')
  , toIObject        = _dereq_('./$.to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = _dereq_('./$.iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
},{"./$.add-to-unscopables":42,"./$.iter-define":70,"./$.iter-step":72,"./$.iterators":73,"./$.to-iobject":93}],103:[function(_dereq_,module,exports){
'use strict';
var strong = _dereq_('./$.collection-strong');

// 23.1 Map Objects
_dereq_('./$.collection')('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
},{"./$.collection":48,"./$.collection-strong":46}],104:[function(_dereq_,module,exports){
// 20.2.2.22 Math.log2(x)
var $def = _dereq_('./$.def');

$def($def.S, 'Math', {
  log2: function log2(x){
    return Math.log(x) / Math.LN2;
  }
});
},{"./$.def":51}],105:[function(_dereq_,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $def = _dereq_('./$.def');

$def($def.S + $def.F, 'Object', {assign: _dereq_('./$.object-assign')});
},{"./$.def":51,"./$.object-assign":79}],106:[function(_dereq_,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = _dereq_('./$.to-iobject');

_dereq_('./$.object-sap')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor){
  return function getOwnPropertyDescriptor(it, key){
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});
},{"./$.object-sap":80,"./$.to-iobject":93}],107:[function(_dereq_,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = _dereq_('./$.to-object');

_dereq_('./$.object-sap')('keys', function($keys){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./$.object-sap":80,"./$.to-object":95}],108:[function(_dereq_,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $def = _dereq_('./$.def');
$def($def.S, 'Object', {setPrototypeOf: _dereq_('./$.set-proto').set});
},{"./$.def":51,"./$.set-proto":84}],109:[function(_dereq_,module,exports){

},{}],110:[function(_dereq_,module,exports){
'use strict';
var $          = _dereq_('./$')
  , LIBRARY    = _dereq_('./$.library')
  , global     = _dereq_('./$.global')
  , ctx        = _dereq_('./$.ctx')
  , classof    = _dereq_('./$.classof')
  , $def       = _dereq_('./$.def')
  , isObject   = _dereq_('./$.is-object')
  , anObject   = _dereq_('./$.an-object')
  , aFunction  = _dereq_('./$.a-function')
  , strictNew  = _dereq_('./$.strict-new')
  , forOf      = _dereq_('./$.for-of')
  , setProto   = _dereq_('./$.set-proto').set
  , same       = _dereq_('./$.same-value')
  , SPECIES    = _dereq_('./$.wks')('species')
  , speciesConstructor = _dereq_('./$.species-constructor')
  , RECORD     = _dereq_('./$.uid')('record')
  , asap       = _dereq_('./$.microtask')
  , PROMISE    = 'Promise'
  , process    = global.process
  , isNode     = classof(process) == 'process'
  , P          = global[PROMISE]
  , Wrapper;

var testResolve = function(sub){
  var test = new P(function(){});
  if(sub)test.constructor = Object;
  return P.resolve(test) === test;
};

var useNative = function(){
  var works = false;
  function P2(x){
    var self = new P(x);
    setProto(self, P2.prototype);
    return self;
  }
  try {
    works = P && P.resolve && testResolve();
    setProto(P2, P);
    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
    // actual Firefox has broken subclass support, test that
    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
      works = false;
    }
    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162
    if(works && _dereq_('./$.descriptors')){
      var thenableThenGotten = false;
      P.resolve($.setDesc({}, 'then', {
        get: function(){ thenableThenGotten = true; }
      }));
      works = thenableThenGotten;
    }
  } catch(e){ works = false; }
  return works;
}();

// helpers
var isPromise = function(it){
  return isObject(it) && (useNative ? classof(it) == 'Promise' : RECORD in it);
};
var sameConstructor = function(a, b){
  // library wrapper special case
  if(LIBRARY && a === P && b === Wrapper)return true;
  return same(a, b);
};
var getConstructor = function(C){
  var S = anObject(C)[SPECIES];
  return S != undefined ? S : C;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function(record, isReject){
  if(record.n)return;
  record.n = true;
  var chain = record.c;
  asap(function(){
    var value = record.v
      , ok    = record.s == 1
      , i     = 0;
    var run = function(react){
      var cb = ok ? react.ok : react.fail
        , ret, then;
      try {
        if(cb){
          if(!ok)record.h = true;
          ret = cb === true ? value : cb(value);
          if(ret === react.P){
            react.rej(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(ret)){
            then.call(ret, react.res, react.rej);
          } else react.res(ret);
        } else react.rej(value);
      } catch(err){
        react.rej(err);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    chain.length = 0;
    record.n = false;
    if(isReject)setTimeout(function(){
      var promise = record.p
        , handler, console;
      if(isUnhandled(promise)){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      } record.a = undefined;
    }, 1);
  });
};
var isUnhandled = function(promise){
  var record = promise[RECORD]
    , chain  = record.a || record.c
    , i      = 0
    , react;
  if(record.h)return false;
  while(chain.length > i){
    react = chain[i++];
    if(react.fail || !isUnhandled(react.P))return false;
  } return true;
};
var $reject = function(value){
  var record = this;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  record.v = value;
  record.s = 2;
  record.a = record.c.slice();
  notify(record, true);
};
var $resolve = function(value){
  var record = this
    , then;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  try {
    if(then = isThenable(value)){
      asap(function(){
        var wrapper = {r: record, d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      record.v = value;
      record.s = 1;
      notify(record, false);
    }
  } catch(e){
    $reject.call({r: record, d: false}, e); // wrap
  }
};

// constructor polyfill
if(!useNative){
  // 25.4.3.1 Promise(executor)
  P = function Promise(executor){
    aFunction(executor);
    var record = {
      p: strictNew(this, P, PROMISE),         // <- promise
      c: [],                                  // <- awaiting reactions
      a: undefined,                           // <- checked in isUnhandled reactions
      s: 0,                                   // <- state
      d: false,                               // <- done
      v: undefined,                           // <- value
      h: false,                               // <- handled rejection
      n: false                                // <- notify
    };
    this[RECORD] = record;
    try {
      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
    } catch(err){
      $reject.call(record, err);
    }
  };
  _dereq_('./$.mix')(P.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var react = {
        ok:   typeof onFulfilled == 'function' ? onFulfilled : true,
        fail: typeof onRejected == 'function'  ? onRejected  : false
      };
      var promise = react.P = new (speciesConstructor(this, P))(function(res, rej){
        react.res = res;
        react.rej = rej;
      });
      aFunction(react.res);
      aFunction(react.rej);
      var record = this[RECORD];
      record.c.push(react);
      if(record.a)record.a.push(react);
      if(record.s)notify(record, false);
      return promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
}

// export
$def($def.G + $def.W + $def.F * !useNative, {Promise: P});
_dereq_('./$.set-to-string-tag')(P, PROMISE);
_dereq_('./$.set-species')(PROMISE);
Wrapper = _dereq_('./$.core')[PROMISE];

// statics
$def($def.S + $def.F * !useNative, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    return new this(function(res, rej){ rej(r); });
  }
});
$def($def.S + $def.F * (!useNative || testResolve(true)), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    return isPromise(x) && sameConstructor(x.constructor, this)
      ? x : new this(function(res){ res(x); });
  }
});
$def($def.S + $def.F * !(useNative && _dereq_('./$.iter-detect')(function(iter){
  P.all(iter)['catch'](function(){});
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C      = getConstructor(this)
      , values = [];
    return new C(function(res, rej){
      forOf(iterable, false, values.push, values);
      var remaining = values.length
        , results   = Array(remaining);
      if(remaining)$.each.call(values, function(promise, index){
        C.resolve(promise).then(function(value){
          results[index] = value;
          --remaining || res(results);
        }, rej);
      });
      else res(results);
    });
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C = getConstructor(this);
    return new C(function(res, rej){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(res, rej);
      });
    });
  }
});
},{"./$":74,"./$.a-function":41,"./$.an-object":43,"./$.classof":44,"./$.core":49,"./$.ctx":50,"./$.def":51,"./$.descriptors":53,"./$.for-of":57,"./$.global":59,"./$.is-object":67,"./$.iter-detect":71,"./$.library":76,"./$.microtask":77,"./$.mix":78,"./$.same-value":83,"./$.set-proto":84,"./$.set-species":85,"./$.set-to-string-tag":86,"./$.species-constructor":88,"./$.strict-new":89,"./$.uid":96,"./$.wks":97}],111:[function(_dereq_,module,exports){
'use strict';
var strong = _dereq_('./$.collection-strong');

// 23.2 Set Objects
_dereq_('./$.collection')('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./$.collection":48,"./$.collection-strong":46}],112:[function(_dereq_,module,exports){
'use strict';
var $at  = _dereq_('./$.string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
_dereq_('./$.iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./$.iter-define":70,"./$.string-at":90}],113:[function(_dereq_,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var $              = _dereq_('./$')
  , global         = _dereq_('./$.global')
  , has            = _dereq_('./$.has')
  , DESCRIPTORS    = _dereq_('./$.descriptors')
  , $def           = _dereq_('./$.def')
  , $redef         = _dereq_('./$.redef')
  , $fails         = _dereq_('./$.fails')
  , shared         = _dereq_('./$.shared')
  , setToStringTag = _dereq_('./$.set-to-string-tag')
  , uid            = _dereq_('./$.uid')
  , wks            = _dereq_('./$.wks')
  , keyOf          = _dereq_('./$.keyof')
  , $names         = _dereq_('./$.get-names')
  , enumKeys       = _dereq_('./$.enum-keys')
  , isArray        = _dereq_('./$.is-array')
  , anObject       = _dereq_('./$.an-object')
  , toIObject      = _dereq_('./$.to-iobject')
  , createDesc     = _dereq_('./$.property-desc')
  , getDesc        = $.getDesc
  , setDesc        = $.setDesc
  , _create        = $.create
  , getNames       = $names.get
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , setter         = false
  , HIDDEN         = wks('_hidden')
  , isEnum         = $.isEnum
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , useNative      = typeof $Symbol == 'function'
  , ObjectProto    = Object.prototype;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(setDesc({}, 'a', {
    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = getDesc(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  setDesc(it, key, D);
  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
} : setDesc;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol.prototype);
  sym._k = tag;
  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
    configurable: true,
    set: function(value){
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    }
  });
  return sym;
};

var isSymbol = function(it){
  return typeof it == 'symbol';
};

var $defineProperty = function defineProperty(it, key, D){
  if(D && has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return setDesc(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key);
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
    ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  var D = getDesc(it = toIObject(it), key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
  return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
  return result;
};
var $stringify = function stringify(it){
  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
  var args = [it]
    , i    = 1
    , $$   = arguments
    , replacer, $replacer;
  while($$.length > i)args.push($$[i++]);
  replacer = args[1];
  if(typeof replacer == 'function')$replacer = replacer;
  if($replacer || !isArray(replacer))replacer = function(key, value){
    if($replacer)value = $replacer.call(this, key, value);
    if(!isSymbol(value))return value;
  };
  args[1] = replacer;
  return _stringify.apply($JSON, args);
};
var buggyJSON = $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
});

// 19.4.1.1 Symbol([description])
if(!useNative){
  $Symbol = function Symbol(){
    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
  };
  $redef($Symbol.prototype, 'toString', function toString(){
    return this._k;
  });

  isSymbol = function(it){
    return it instanceof $Symbol;
  };

  $.create     = $create;
  $.isEnum     = $propertyIsEnumerable;
  $.getDesc    = $getOwnPropertyDescriptor;
  $.setDesc    = $defineProperty;
  $.setDescs   = $defineProperties;
  $.getNames   = $names.get = $getOwnPropertyNames;
  $.getSymbols = $getOwnPropertySymbols;

  if(DESCRIPTORS && !_dereq_('./$.library')){
    $redef(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }
}

var symbolStatics = {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    return keyOf(SymbolRegistry, key);
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
};
// 19.4.2.2 Symbol.hasInstance
// 19.4.2.3 Symbol.isConcatSpreadable
// 19.4.2.4 Symbol.iterator
// 19.4.2.6 Symbol.match
// 19.4.2.8 Symbol.replace
// 19.4.2.9 Symbol.search
// 19.4.2.10 Symbol.species
// 19.4.2.11 Symbol.split
// 19.4.2.12 Symbol.toPrimitive
// 19.4.2.13 Symbol.toStringTag
// 19.4.2.14 Symbol.unscopables
$.each.call((
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
  'species,split,toPrimitive,toStringTag,unscopables'
).split(','), function(it){
  var sym = wks(it);
  symbolStatics[it] = useNative ? sym : wrap(sym);
});

setter = true;

$def($def.G + $def.W, {Symbol: $Symbol});

$def($def.S, 'Symbol', symbolStatics);

$def($def.S + $def.F * !useNative, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $def($def.S + $def.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});

// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);
},{"./$":74,"./$.an-object":43,"./$.def":51,"./$.descriptors":53,"./$.enum-keys":55,"./$.fails":56,"./$.get-names":58,"./$.global":59,"./$.has":60,"./$.is-array":66,"./$.keyof":75,"./$.library":76,"./$.property-desc":81,"./$.redef":82,"./$.set-to-string-tag":86,"./$.shared":87,"./$.to-iobject":93,"./$.uid":96,"./$.wks":97}],114:[function(_dereq_,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $def  = _dereq_('./$.def');

$def($def.P, 'Map', {toJSON: _dereq_('./$.collection-to-json')('Map')});
},{"./$.collection-to-json":47,"./$.def":51}],115:[function(_dereq_,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $def  = _dereq_('./$.def');

$def($def.P, 'Set', {toJSON: _dereq_('./$.collection-to-json')('Set')});
},{"./$.collection-to-json":47,"./$.def":51}],116:[function(_dereq_,module,exports){
_dereq_('./es6.array.iterator');
var Iterators = _dereq_('./$.iterators');
Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
},{"./$.iterators":73,"./es6.array.iterator":102}],117:[function(_dereq_,module,exports){
(function (global){
// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g =
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this;

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = _dereq_("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

module.exports = { "default": module.exports, __esModule: true };

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID1cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IG1vZHVsZS5leHBvcnRzLCBfX2VzTW9kdWxlOiB0cnVlIH07XG4iXX0=
},{"./runtime":118}],118:[function(_dereq_,module,exports){
(function (process,global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

"use strict";

var _Symbol = _dereq_("babel-runtime/core-js/symbol")["default"];

var _Symbol$iterator = _dereq_("babel-runtime/core-js/symbol/iterator")["default"];

var _Object$create = _dereq_("babel-runtime/core-js/object/create")["default"];

var _Promise = _dereq_("babel-runtime/core-js/promise")["default"];

!(function (global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var iteratorSymbol = typeof _Symbol === "function" && _Symbol$iterator || "@@iterator";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided, then outerFn.prototype instanceof Generator.
    var generator = _Object$create((outerFn || Generator).prototype);

    generator._invoke = makeInvokeMethod(innerFn, self || null, new Context(tryLocsList || []));

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction ||
    // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    genFun.__proto__ = GeneratorFunctionPrototype;
    genFun.prototype = _Object$create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `value instanceof AwaitArgument` to determine if the yielded value is
  // meant to be awaited. Some may consider the name of this method too
  // cutesy, but they are curmudgeons.
  runtime.awrap = function (arg) {
    return new AwaitArgument(arg);
  };

  function AwaitArgument(arg) {
    this.arg = arg;
  }

  function AsyncIterator(generator) {
    // This invoke function is written in a style that assumes some
    // calling function (or Promise) will handle exceptions.
    function invoke(method, arg) {
      var result = generator[method](arg);
      var value = result.value;
      return value instanceof AwaitArgument ? _Promise.resolve(value.arg).then(invokeNext, invokeThrow) : _Promise.resolve(value).then(function (unwrapped) {
        // When a yielded Promise is resolved, its final value becomes
        // the .value of the Promise<{value,done}> result for the
        // current iteration. If the Promise is rejected, however, the
        // result for this iteration will be rejected with the same
        // reason. Note that rejections of yielded Promises are not
        // thrown back into the generator function, as is the case
        // when an awaited Promise is rejected. This difference in
        // behavior between yield and await is important, because it
        // allows the consumer to decide what to do with the yielded
        // rejection (swallow it and continue, manually .throw it back
        // into the generator, abandon iteration, whatever). With
        // await, by contrast, there is no opportunity to examine the
        // rejection reason outside the generator function, so the
        // only option is to throw it from the await expression, and
        // let the generator function handle the exception.
        result.value = unwrapped;
        return result;
      });
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var invokeNext = invoke.bind(generator, "next");
    var invokeThrow = invoke.bind(generator, "throw");
    var invokeReturn = invoke.bind(generator, "return");
    var previousPromise;

    function enqueue(method, arg) {
      var enqueueResult =
      // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(function () {
        return invoke(method, arg);
      }) : new _Promise(function (resolve) {
        resolve(invoke(method, arg));
      });

      // Avoid propagating enqueueResult failures to Promises returned by
      // later invocations of the iterator.
      previousPromise = enqueueResult["catch"](function (ignored) {});

      return enqueueResult;
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            context.sent = undefined;
          }
        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }
        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }
        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function stop() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
// Among the various tricks for obtaining a reference to the global
// object, this seems to be the most reliable technique that does not
// use indirect eval (which violates Content Security Policy).
typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : undefined);
}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL3J1bnRpbWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX1N5bWJvbCA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9TeW1ib2wkaXRlcmF0b3IgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBfT2JqZWN0JGNyZWF0ZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBfUHJvbWlzZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiKVtcImRlZmF1bHRcIl07XG5cbiEoZnVuY3Rpb24gKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciBpdGVyYXRvclN5bWJvbCA9IHR5cGVvZiBfU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgX1N5bWJvbCRpdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBnZW5lcmF0b3IgPSBfT2JqZWN0JGNyZWF0ZSgob3V0ZXJGbiB8fCBHZW5lcmF0b3IpLnByb3RvdHlwZSk7XG5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiB8fCBudWxsLCBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSkpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3IgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICBnZW5GdW4ucHJvdG90eXBlID0gX09iamVjdCRjcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGB2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnRgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLiBTb21lIG1heSBjb25zaWRlciB0aGUgbmFtZSBvZiB0aGlzIG1ldGhvZCB0b29cbiAgLy8gY3V0ZXN5LCBidXQgdGhleSBhcmUgY3VybXVkZ2VvbnMuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIG5ldyBBd2FpdEFyZ3VtZW50KGFyZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQXdhaXRBcmd1bWVudChhcmcpIHtcbiAgICB0aGlzLmFyZyA9IGFyZztcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgLy8gVGhpcyBpbnZva2UgZnVuY3Rpb24gaXMgd3JpdHRlbiBpbiBhIHN0eWxlIHRoYXQgYXNzdW1lcyBzb21lXG4gICAgLy8gY2FsbGluZyBmdW5jdGlvbiAob3IgUHJvbWlzZSkgd2lsbCBoYW5kbGUgZXhjZXB0aW9ucy5cbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZW5lcmF0b3JbbWV0aG9kXShhcmcpO1xuICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudCA/IF9Qcm9taXNlLnJlc29sdmUodmFsdWUuYXJnKS50aGVuKGludm9rZU5leHQsIGludm9rZVRocm93KSA6IF9Qcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkge1xuICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBpbnZva2VOZXh0ID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcIm5leHRcIik7XG4gICAgdmFyIGludm9rZVRocm93ID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInRocm93XCIpO1xuICAgIHZhciBpbnZva2VSZXR1cm4gPSBpbnZva2UuYmluZChnZW5lcmF0b3IsIFwicmV0dXJuXCIpO1xuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICB2YXIgZW5xdWV1ZVJlc3VsdCA9XG4gICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pIDogbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHJlc29sdmUoaW52b2tlKG1ldGhvZCwgYXJnKSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZW5xdWV1ZVJlc3VsdCBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieVxuICAgICAgLy8gbGF0ZXIgaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgcHJldmlvdXNQcm9taXNlID0gZW5xdWV1ZVJlc3VsdFtcImNhdGNoXCJdKGZ1bmN0aW9uIChpZ25vcmVkKSB7fSk7XG5cbiAgICAgIHJldHVybiBlbnF1ZXVlUmVzdWx0O1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIgfHwgbWV0aG9kID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIExpa2UgcmV0dXJuaW5nIGdlbmVyYXRvci50aHJvdyh1bmNhdWdodCksIGJ1dCB3aXRob3V0IHRoZVxuICAgICAgICAgICAgLy8gb3ZlcmhlYWQgb2YgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCkge1xuICAgICAgICAgICAgY29udGV4dC5zZW50ID0gYXJnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IEdlblN0YXRlQ29tcGxldGVkIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlICYmIG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICB0aGlzLnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJiAodHlwZSA9PT0gXCJicmVha1wiIHx8IHR5cGUgPT09IFwiY29udGludWVcIikgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHwgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbi8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbi8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbnR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdW5kZWZpbmVkKTsiXX0=
},{"_process":135,"babel-runtime/core-js/object/create":7,"babel-runtime/core-js/promise":13,"babel-runtime/core-js/symbol":15,"babel-runtime/core-js/symbol/iterator":16}],119:[function(_dereq_,module,exports){
'use strict'

module.exports = boxIntersectWrapper

var pool = _dereq_('typedarray-pool')
var sweep = _dereq_('./lib/sweep')
var boxIntersectIter = _dereq_('./lib/intersect')

function boxEmpty(d, box) {
  for(var j=0; j<d; ++j) {
    if(!(box[j] <= box[j+d])) {
      return true
    }
  }
  return false
}

//Unpack boxes into a flat typed array, remove empty boxes
function convertBoxes(boxes, d, data, ids) {
  var ptr = 0
  var count = 0
  for(var i=0, n=boxes.length; i<n; ++i) {
    var b = boxes[i]
    if(boxEmpty(d, b)) {
      continue
    }
    for(var j=0; j<2*d; ++j) {
      data[ptr++] = b[j]
    }
    ids[count++] = i
  }
  return count
}

//Perform type conversions, check bounds
function boxIntersect(red, blue, visit, full) {
  var n = red.length
  var m = blue.length

  //If either array is empty, then we can skip this whole thing
  if(n <= 0 || m <= 0) {
    return
  }

  //Compute dimension, if it is 0 then we skip
  var d = (red[0].length)>>>1
  if(d <= 0) {
    return
  }

  var retval

  //Convert red boxes
  var redList  = pool.mallocDouble(2*d*n)
  var redIds   = pool.mallocInt32(n)
  n = convertBoxes(red, d, redList, redIds)

  if(n > 0) {
    if(d === 1 && full) {
      //Special case: 1d complete
      sweep.init(n)
      retval = sweep.sweepComplete(
        d, visit, 
        0, n, redList, redIds,
        0, n, redList, redIds)
    } else {

      //Convert blue boxes
      var blueList = pool.mallocDouble(2*d*m)
      var blueIds  = pool.mallocInt32(m)
      m = convertBoxes(blue, d, blueList, blueIds)

      if(m > 0) {
        sweep.init(n+m)

        if(d === 1) {
          //Special case: 1d bipartite
          retval = sweep.sweepBipartite(
            d, visit, 
            0, n, redList,  redIds,
            0, m, blueList, blueIds)
        } else {
          //General case:  d>1
          retval = boxIntersectIter(
            d, visit,    full,
            n, redList,  redIds,
            m, blueList, blueIds)
        }

        pool.free(blueList)
        pool.free(blueIds)
      }
    }

    pool.free(redList)
    pool.free(redIds)
  }

  return retval
}


var RESULT

function appendItem(i,j) {
  RESULT.push([i,j])
}

function intersectFullArray(x) {
  RESULT = []
  boxIntersect(x, x, appendItem, true)
  return RESULT
}

function intersectBipartiteArray(x, y) {
  RESULT = []
  boxIntersect(x, y, appendItem, false)
  return RESULT
}

//User-friendly wrapper, handle full input and no-visitor cases
function boxIntersectWrapper(arg0, arg1, arg2) {
  var result
  switch(arguments.length) {
    case 1:
      return intersectFullArray(arg0)
    case 2:
      if(typeof arg1 === 'function') {
        return boxIntersect(arg0, arg0, arg1, true)
      } else {
        return intersectBipartiteArray(arg0, arg1)
      }
    case 3:
      return boxIntersect(arg0, arg1, arg2, false)
    default:
      throw new Error('box-intersect: Invalid arguments')
  }
}
},{"./lib/intersect":121,"./lib/sweep":125,"typedarray-pool":128}],120:[function(_dereq_,module,exports){
'use strict'

var DIMENSION   = 'd'
var AXIS        = 'ax'
var VISIT       = 'vv'
var FLIP        = 'fp'

var ELEM_SIZE   = 'es'

var RED_START   = 'rs'
var RED_END     = 're'
var RED_BOXES   = 'rb'
var RED_INDEX   = 'ri'
var RED_PTR     = 'rp'

var BLUE_START  = 'bs'
var BLUE_END    = 'be'
var BLUE_BOXES  = 'bb'
var BLUE_INDEX  = 'bi'
var BLUE_PTR    = 'bp'

var RETVAL      = 'rv'

var INNER_LABEL = 'Q'

var ARGS = [
  DIMENSION,
  AXIS,
  VISIT,
  RED_START,
  RED_END,
  RED_BOXES,
  RED_INDEX,
  BLUE_START,
  BLUE_END,
  BLUE_BOXES,
  BLUE_INDEX
]

function generateBruteForce(redMajor, flip, full) {
  var funcName = 'bruteForce' + 
    (redMajor ? 'Red' : 'Blue') + 
    (flip ? 'Flip' : '') +
    (full ? 'Full' : '')

  var code = ['function ', funcName, '(', ARGS.join(), '){',
    'var ', ELEM_SIZE, '=2*', DIMENSION, ';']

  var redLoop = 
    'for(var i=' + RED_START + ',' + RED_PTR + '=' + ELEM_SIZE + '*' + RED_START + ';' +
        'i<' + RED_END +';' +
        '++i,' + RED_PTR + '+=' + ELEM_SIZE + '){' +
        'var x0=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '],' +
            'x1=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '+' + DIMENSION + '],' +
            'xi=' + RED_INDEX + '[i];'

  var blueLoop = 
    'for(var j=' + BLUE_START + ',' + BLUE_PTR + '=' + ELEM_SIZE + '*' + BLUE_START + ';' +
        'j<' + BLUE_END + ';' +
        '++j,' + BLUE_PTR + '+=' + ELEM_SIZE + '){' +
        'var y0=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '],' +
            (full ? 'y1=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '+' + DIMENSION + '],' : '') +
            'yi=' + BLUE_INDEX + '[j];'

  if(redMajor) {
    code.push(redLoop, INNER_LABEL, ':', blueLoop)
  } else {
    code.push(blueLoop, INNER_LABEL, ':', redLoop)
  }

  if(full) {
    code.push('if(y1<x0||x1<y0)continue;')
  } else if(flip) {
    code.push('if(y0<=x0||x1<y0)continue;')
  } else {
    code.push('if(y0<x0||x1<y0)continue;')
  }

  code.push('for(var k='+AXIS+'+1;k<'+DIMENSION+';++k){'+
    'var r0='+RED_BOXES+'[k+'+RED_PTR+'],'+
        'r1='+RED_BOXES+'[k+'+DIMENSION+'+'+RED_PTR+'],'+
        'b0='+BLUE_BOXES+'[k+'+BLUE_PTR+'],'+
        'b1='+BLUE_BOXES+'[k+'+DIMENSION+'+'+BLUE_PTR+'];'+
      'if(r1<b0||b1<r0)continue ' + INNER_LABEL + ';}' +
      'var ' + RETVAL + '=' + VISIT + '(')

  if(flip) {
    code.push('yi,xi')
  } else {
    code.push('xi,yi')
  }

  code.push(');if(' + RETVAL + '!==void 0)return ' + RETVAL + ';}}}')

  return {
    name: funcName, 
    code: code.join('')
  }
}

function bruteForcePlanner(full) {
  var funcName = 'bruteForce' + (full ? 'Full' : 'Partial')
  var prefix = []
  var fargs = ARGS.slice()
  if(!full) {
    fargs.splice(3, 0, FLIP)
  }

  var code = ['function ' + funcName + '(' + fargs.join() + '){']

  function invoke(redMajor, flip) {
    var res = generateBruteForce(redMajor, flip, full)
    prefix.push(res.code)
    code.push('return ' + res.name + '(' + ARGS.join() + ');')
  }

  code.push('if(' + RED_END + '-' + RED_START + '>' +
                    BLUE_END + '-' + BLUE_START + '){')

  if(full) {
    invoke(true, false)
    code.push('}else{')
    invoke(false, false)
  } else {
    code.push('if(' + FLIP + '){')
    invoke(true, true)
    code.push('}else{')
    invoke(true, false)
    code.push('}}else{if(' + FLIP + '){')
    invoke(false, true)
    code.push('}else{')
    invoke(false, false)
    code.push('}')
  }
  code.push('}}return ' + funcName)

  var codeStr = prefix.join('') + code.join('')
  var proc = new Function(codeStr)
  return proc()
}


exports.partial = bruteForcePlanner(false)
exports.full    = bruteForcePlanner(true)
},{}],121:[function(_dereq_,module,exports){
'use strict'

module.exports = boxIntersectIter

var pool = _dereq_('typedarray-pool')
var bits = _dereq_('bit-twiddle')
var bruteForce = _dereq_('./brute')
var bruteForcePartial = bruteForce.partial
var bruteForceFull = bruteForce.full
var sweep = _dereq_('./sweep')
var findMedian = _dereq_('./median')
var genPartition = _dereq_('./partition')

//Twiddle parameters
var BRUTE_FORCE_CUTOFF    = 128       //Cut off for brute force search
var SCAN_CUTOFF           = (1<<22)   //Cut off for two way scan
var SCAN_COMPLETE_CUTOFF  = (1<<22)  

//Partition functions
var partitionInteriorContainsInterval = genPartition(
  '!(lo>=p0)&&!(p1>=hi)', 
  ['p0', 'p1'])

var partitionStartEqual = genPartition(
  'lo===p0',
  ['p0'])

var partitionStartLessThan = genPartition(
  'lo<p0',
  ['p0'])

var partitionEndLessThanEqual = genPartition(
  'hi<=p0',
  ['p0'])

var partitionContainsPoint = genPartition(
  'lo<=p0&&p0<=hi',
  ['p0'])

var partitionContainsPointProper = genPartition(
  'lo<p0&&p0<=hi',
  ['p0'])

//Frame size for iterative loop
var IFRAME_SIZE = 6
var DFRAME_SIZE = 2

//Data for box statck
var INIT_CAPACITY = 1024
var BOX_ISTACK  = pool.mallocInt32(INIT_CAPACITY)
var BOX_DSTACK  = pool.mallocDouble(INIT_CAPACITY)

//Initialize iterative loop queue
function iterInit(d, count) {
  var levels = (8 * bits.log2(count+1) * (d+1))|0
  var maxInts = bits.nextPow2(IFRAME_SIZE*levels)
  if(BOX_ISTACK.length < maxInts) {
    pool.free(BOX_ISTACK)
    BOX_ISTACK = pool.mallocInt32(maxInts)
  }
  var maxDoubles = bits.nextPow2(DFRAME_SIZE*levels)
  if(BOX_DSTACK < maxDoubles) {
    pool.free(BOX_DSTACK)
    BOX_DSTACK = pool.mallocDouble(maxDoubles)
  }
}

//Append item to queue
function iterPush(ptr,
  axis, 
  redStart, redEnd, 
  blueStart, blueEnd, 
  state, 
  lo, hi) {

  var iptr = IFRAME_SIZE * ptr
  BOX_ISTACK[iptr]   = axis
  BOX_ISTACK[iptr+1] = redStart
  BOX_ISTACK[iptr+2] = redEnd
  BOX_ISTACK[iptr+3] = blueStart
  BOX_ISTACK[iptr+4] = blueEnd
  BOX_ISTACK[iptr+5] = state

  var dptr = DFRAME_SIZE * ptr
  BOX_DSTACK[dptr]   = lo
  BOX_DSTACK[dptr+1] = hi
}

//Special case:  Intersect single point with list of intervals
function onePointPartial(
  d, axis, visit, flip,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    if(flip && blueX === r0) {
      continue
    }
    var redId = redIndex[i]
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval
    if(flip) {
      retval = visit(blueId, redId)
    } else {
      retval = visit(redId, blueId)
    }
    if(retval !== void 0) {
      return retval
    }
  }
}

//Special case:  Intersect one point with list of intervals
function onePointFull(
  d, axis, visit,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var redId = redIndex[i]
    if(redId === blueId) {
      continue
    }
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval = visit(redId, blueId)
    if(retval !== void 0) {
      return retval
    }
  }
}

//The main box intersection routine
function boxIntersectIter(
  d, visit, initFull,
  xSize, xBoxes, xIndex,
  ySize, yBoxes, yIndex) {

  //Reserve memory for stack
  iterInit(d, xSize + ySize)

  var top  = 0
  var elemSize = 2 * d
  var retval

  iterPush(top++,
      0,
      0, xSize,
      0, ySize,
      initFull ? 16 : 0, 
      -Infinity, Infinity)
  if(!initFull) {
    iterPush(top++,
      0,
      0, ySize,
      0, xSize,
      1, 
      -Infinity, Infinity)
  }

  while(top > 0) {
    top  -= 1

    var iptr = top * IFRAME_SIZE
    var axis      = BOX_ISTACK[iptr]
    var redStart  = BOX_ISTACK[iptr+1]
    var redEnd    = BOX_ISTACK[iptr+2]
    var blueStart = BOX_ISTACK[iptr+3]
    var blueEnd   = BOX_ISTACK[iptr+4]
    var state     = BOX_ISTACK[iptr+5]

    var dptr = top * DFRAME_SIZE
    var lo        = BOX_DSTACK[dptr]
    var hi        = BOX_DSTACK[dptr+1]

    //Unpack state info
    var flip      = (state & 1)
    var full      = !!(state & 16)

    //Unpack indices
    var red       = xBoxes
    var redIndex  = xIndex
    var blue      = yBoxes
    var blueIndex = yIndex
    if(flip) {
      red         = yBoxes
      redIndex    = yIndex
      blue        = xBoxes
      blueIndex   = xIndex
    }

    if(state & 2) {
      redEnd = partitionStartLessThan(
        d, axis,
        redStart, redEnd, red, redIndex,
        hi)
      if(redStart >= redEnd) {
        continue
      }
    }
    if(state & 4) {
      redStart = partitionEndLessThanEqual(
        d, axis,
        redStart, redEnd, red, redIndex,
        lo)
      if(redStart >= redEnd) {
        continue
      }
    }
    
    var redCount  = redEnd  - redStart
    var blueCount = blueEnd - blueStart

    if(full) {
      if(d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {
        retval = sweep.scanComplete(
          d, axis, visit, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    } else {
      if(d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {
        //If input small, then use brute force
        retval = bruteForcePartial(
            d, axis, visit, flip,
            redStart,  redEnd,  red,  redIndex,
            blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      } else if(d * redCount * blueCount < SCAN_CUTOFF) {
        //If input medium sized, then use sweep and prune
        retval = sweep.scanBipartite(
          d, axis, visit, flip, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    }
    
    //First, find all red intervals whose interior contains (lo,hi)
    var red0 = partitionInteriorContainsInterval(
      d, axis, 
      redStart, redEnd, red, redIndex,
      lo, hi)

    //Lower dimensional case
    if(redStart < red0) {

      if(d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {
        //Special case for small inputs: use brute force
        retval = bruteForceFull(
          d, axis+1, visit,
          redStart, red0, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
      } else if(axis === d-2) {
        if(flip) {
          retval = sweep.sweepBipartite(
            d, visit,
            blueStart, blueEnd, blue, blueIndex,
            redStart, red0, red, redIndex)
        } else {
          retval = sweep.sweepBipartite(
            d, visit,
            redStart, red0, red, redIndex,
            blueStart, blueEnd, blue, blueIndex)
        }
        if(retval !== void 0) {
          return retval
        }
      } else {
        iterPush(top++,
          axis+1,
          redStart, red0,
          blueStart, blueEnd,
          flip,
          -Infinity, Infinity)
        iterPush(top++,
          axis+1,
          blueStart, blueEnd,
          redStart, red0,
          flip^1,
          -Infinity, Infinity)
      }
    }

    //Divide and conquer phase
    if(red0 < redEnd) {

      //Cut blue into 3 parts:
      //
      //  Points < mid point
      //  Points = mid point
      //  Points > mid point
      //
      var blue0 = findMedian(
        d, axis, 
        blueStart, blueEnd, blue, blueIndex)
      var mid = blue[elemSize * blue0 + axis]
      var blue1 = partitionStartEqual(
        d, axis,
        blue0, blueEnd, blue, blueIndex,
        mid)

      //Right case
      if(blue1 < blueEnd) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blue1, blueEnd,
          (flip|4) + (full ? 16 : 0),
          mid, hi)
      }

      //Left case
      if(blueStart < blue0) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blueStart, blue0,
          (flip|2) + (full ? 16 : 0),
          lo, mid)
      }

      //Center case (the hard part)
      if(blue0 + 1 === blue1) {
        //Optimization: Range with exactly 1 point, use a brute force scan
        if(full) {
          retval = onePointFull(
            d, axis, visit,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        } else {
          retval = onePointPartial(
            d, axis, visit, flip,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        }
        if(retval !== void 0) {
          return retval
        }
      } else if(blue0 < blue1) {
        var red1
        if(full) {
          //If full intersection, need to handle special case
          red1 = partitionContainsPoint(
            d, axis,
            red0, redEnd, red, redIndex,
            mid)
          if(red0 < red1) {
            var redX = partitionStartEqual(
              d, axis,
              red0, red1, red, redIndex,
              mid)
            if(axis === d-2) {
              //Degenerate sweep intersection:
              //  [red0, redX] with [blue0, blue1]
              if(red0 < redX) {
                retval = sweep.sweepComplete(
                  d, visit,
                  red0, redX, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }

              //Normal sweep intersection:
              //  [redX, red1] with [blue0, blue1]
              if(redX < red1) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  redX, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }
            } else {
              if(red0 < redX) {
                iterPush(top++,
                  axis+1,
                  red0, redX,
                  blue0, blue1,
                  16,
                  -Infinity, Infinity)
              }
              if(redX < red1) {
                iterPush(top++,
                  axis+1,
                  redX, red1,
                  blue0, blue1,
                  0,
                  -Infinity, Infinity)
                iterPush(top++,
                  axis+1,
                  blue0, blue1,
                  redX, red1,
                  1,
                  -Infinity, Infinity)
              }
            }
          }
        } else {
          if(flip) {
            red1 = partitionContainsPointProper(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          } else {
            red1 = partitionContainsPoint(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          }
          if(red0 < red1) {
            if(axis === d-2) {
              if(flip) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  blue0, blue1, blue, blueIndex,
                  red0, red1, red, redIndex)
              } else {
                retval = sweep.sweepBipartite(
                  d, visit,
                  red0, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
              }
            } else {
              iterPush(top++,
                axis+1,
                red0, red1,
                blue0, blue1,
                flip,
                -Infinity, Infinity)
              iterPush(top++,
                axis+1,
                blue0, blue1,
                red0, red1,
                flip^1,
                -Infinity, Infinity)
            }
          }
        }
      }
    }
  }
}
},{"./brute":120,"./median":122,"./partition":123,"./sweep":125,"bit-twiddle":126,"typedarray-pool":128}],122:[function(_dereq_,module,exports){
'use strict'

module.exports = findMedian

var genPartition = _dereq_('./partition')

var partitionStartLessThan = genPartition('lo<p0', ['p0'])

var PARTITION_THRESHOLD = 8   //Cut off for using insertion sort in findMedian

//Base case for median finding:  Use insertion sort
function insertionSort(d, axis, start, end, boxes, ids) {
  var elemSize = 2 * d
  var boxPtr = elemSize * (start+1) + axis
  for(var i=start+1; i<end; ++i, boxPtr+=elemSize) {
    var x = boxes[boxPtr]
    for(var j=i, ptr=elemSize*(i-1); 
        j>start && boxes[ptr+axis] > x; 
        --j, ptr-=elemSize) {
      //Swap
      var aPtr = ptr
      var bPtr = ptr+elemSize
      for(var k=0; k<elemSize; ++k, ++aPtr, ++bPtr) {
        var y = boxes[aPtr]
        boxes[aPtr] = boxes[bPtr]
        boxes[bPtr] = y
      }
      var tmp = ids[j]
      ids[j] = ids[j-1]
      ids[j-1] = tmp
    }
  }
}

//Find median using quick select algorithm
//  takes O(n) time with high probability
function findMedian(d, axis, start, end, boxes, ids) {
  if(end <= start+1) {
    return start
  }

  var lo       = start
  var hi       = end
  var mid      = ((end + start) >>> 1)
  var elemSize = 2*d
  var pivot    = mid
  var value    = boxes[elemSize*mid+axis]
  
  while(lo < hi) {
    if(hi - lo < PARTITION_THRESHOLD) {
      insertionSort(d, axis, lo, hi, boxes, ids)
      value = boxes[elemSize*mid+axis]
      break
    }
    
    //Select pivot using median-of-3
    var count  = hi - lo
    var pivot0 = (Math.random()*count+lo)|0
    var value0 = boxes[elemSize*pivot0 + axis]
    var pivot1 = (Math.random()*count+lo)|0
    var value1 = boxes[elemSize*pivot1 + axis]
    var pivot2 = (Math.random()*count+lo)|0
    var value2 = boxes[elemSize*pivot2 + axis]
    if(value0 <= value1) {
      if(value2 >= value1) {
        pivot = pivot1
        value = value1
      } else if(value0 >= value2) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    } else {
      if(value1 >= value2) {
        pivot = pivot1
        value = value1
      } else if(value2 >= value0) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    }

    //Swap pivot to end of array
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Partition using pivot
    pivot = partitionStartLessThan(
      d, axis, 
      lo, hi-1, boxes, ids,
      value)

    //Swap pivot back
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Swap pivot to last pivot
    if(mid < pivot) {
      hi = pivot-1
      while(lo < hi && 
        boxes[elemSize*(hi-1)+axis] === value) {
        hi -= 1
      }
      hi += 1
    } else if(pivot < mid) {
      lo = pivot + 1
      while(lo < hi &&
        boxes[elemSize*lo+axis] === value) {
        lo += 1
      }
    } else {
      break
    }
  }

  //Make sure pivot is at start
  return partitionStartLessThan(
    d, axis, 
    start, mid, boxes, ids,
    boxes[elemSize*mid+axis])
}
},{"./partition":123}],123:[function(_dereq_,module,exports){
'use strict'

module.exports = genPartition

var code = 'for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m'

function genPartition(predicate, args) {
  var fargs ='abcdef'.split('').concat(args)
  var reads = []
  if(predicate.indexOf('lo') >= 0) {
    reads.push('lo=e[k+n]')
  }
  if(predicate.indexOf('hi') >= 0) {
    reads.push('hi=e[k+o]')
  }
  fargs.push(
    code.replace('_', reads.join())
        .replace('$', predicate))
  return Function.apply(void 0, fargs)
}
},{}],124:[function(_dereq_,module,exports){
'use strict';

//This code is extracted from ndarray-sort
//It is inlined here as a temporary workaround

module.exports = wrapper;

var INSERT_SORT_CUTOFF = 32

function wrapper(data, n0) {
  if (n0 <= 4*INSERT_SORT_CUTOFF) {
    insertionSort(0, n0 - 1, data);
  } else {
    quickSort(0, n0 - 1, data);
  }
}

function insertionSort(left, right, data) {
  var ptr = 2*(left+1)
  for(var i=left+1; i<=right; ++i) {
    var a = data[ptr++]
    var b = data[ptr++]
    var j = i
    var jptr = ptr-2
    while(j-- > left) {
      var x = data[jptr-2]
      var y = data[jptr-1]
      if(x < a) {
        break
      } else if(x === a && y < b) {
        break
      }
      data[jptr]   = x
      data[jptr+1] = y
      jptr -= 2
    }
    data[jptr]   = a
    data[jptr+1] = b
  }
}

function swap(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = x
  data[j+1] = y
}

function move(i, j, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[i+1] = data[j+1]
}

function rotate(i, j, k, data) {
  i *= 2
  j *= 2
  k *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = data[k]
  data[j+1] = data[k+1]
  data[k] = x
  data[k+1] = y
}

function shufflePivot(i, j, px, py, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[j] = px
  data[i+1] = data[j+1]
  data[j+1] = py
}

function compare(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i],
      y = data[j]
  if(x < y) {
    return false
  } else if(x === y) {
    return data[i+1] > data[j+1]
  }
  return true
}

function comparePivot(i, y, b, data) {
  i *= 2
  var x = data[i]
  if(x < y) {
    return true
  } else if(x === y) {
    return data[i+1] < b
  }
  return false
}

function quickSort(left, right, data) {
  var sixth = (right - left + 1) / 6 | 0, 
      index1 = left + sixth, 
      index5 = right - sixth, 
      index3 = left + right >> 1, 
      index2 = index3 - sixth, 
      index4 = index3 + sixth, 
      el1 = index1, 
      el2 = index2, 
      el3 = index3, 
      el4 = index4, 
      el5 = index5, 
      less = left + 1, 
      great = right - 1, 
      tmp = 0
  if(compare(el1, el2, data)) {
    tmp = el1
    el1 = el2
    el2 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }
  if(compare(el1, el3, data)) {
    tmp = el1
    el1 = el3
    el3 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el1, el4, data)) {
    tmp = el1
    el1 = el4
    el4 = tmp
  }
  if(compare(el3, el4, data)) {
    tmp = el3
    el3 = el4
    el4 = tmp
  }
  if(compare(el2, el5, data)) {
    tmp = el2
    el2 = el5
    el5 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }

  var pivot1X = data[2*el2]
  var pivot1Y = data[2*el2+1]
  var pivot2X = data[2*el4]
  var pivot2Y = data[2*el4+1]

  var ptr0 = 2 * el1;
  var ptr2 = 2 * el3;
  var ptr4 = 2 * el5;
  var ptr5 = 2 * index1;
  var ptr6 = 2 * index3;
  var ptr7 = 2 * index5;
  for (var i1 = 0; i1 < 2; ++i1) {
    var x = data[ptr0+i1];
    var y = data[ptr2+i1];
    var z = data[ptr4+i1];
    data[ptr5+i1] = x;
    data[ptr6+i1] = y;
    data[ptr7+i1] = z;
  }

  move(index2, left, data)
  move(index4, right, data)
  for (var k = less; k <= great; ++k) {
    if (comparePivot(k, pivot1X, pivot1Y, data)) {
      if (k !== less) {
        swap(k, less, data)
      }
      ++less;
    } else {
      if (!comparePivot(k, pivot2X, pivot2Y, data)) {
        while (true) {
          if (!comparePivot(great, pivot2X, pivot2Y, data)) {
            if (--great < k) {
              break;
            }
            continue;
          } else {
            if (comparePivot(great, pivot1X, pivot1Y, data)) {
              rotate(k, less, great, data)
              ++less;
              --great;
            } else {
              swap(k, great, data)
              --great;
            }
            break;
          }
        }
      }
    }
  }
  shufflePivot(left, less-1, pivot1X, pivot1Y, data)
  shufflePivot(right, great+1, pivot2X, pivot2Y, data)
  if (less - 2 - left <= INSERT_SORT_CUTOFF) {
    insertionSort(left, less - 2, data);
  } else {
    quickSort(left, less - 2, data);
  }
  if (right - (great + 2) <= INSERT_SORT_CUTOFF) {
    insertionSort(great + 2, right, data);
  } else {
    quickSort(great + 2, right, data);
  }
  if (great - less <= INSERT_SORT_CUTOFF) {
    insertionSort(less, great, data);
  } else {
    quickSort(less, great, data);
  }
}
},{}],125:[function(_dereq_,module,exports){
'use strict'

module.exports = {
  init:           sqInit,
  sweepBipartite: sweepBipartite,
  sweepComplete:  sweepComplete,
  scanBipartite:  scanBipartite,
  scanComplete:   scanComplete
}

var pool  = _dereq_('typedarray-pool')
var bits  = _dereq_('bit-twiddle')
var isort = _dereq_('./sort')

//Flag for blue
var BLUE_FLAG = (1<<28)

//1D sweep event queue stuff (use pool to save space)
var INIT_CAPACITY      = 1024
var RED_SWEEP_QUEUE    = pool.mallocInt32(INIT_CAPACITY)
var RED_SWEEP_INDEX    = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_QUEUE   = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_INDEX   = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY)
var SWEEP_EVENTS       = pool.mallocDouble(INIT_CAPACITY * 8)

//Reserves memory for the 1D sweep data structures
function sqInit(count) {
  var rcount = bits.nextPow2(count)
  if(RED_SWEEP_QUEUE.length < rcount) {
    pool.free(RED_SWEEP_QUEUE)
    RED_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(RED_SWEEP_INDEX.length < rcount) {
    pool.free(RED_SWEEP_INDEX)
    RED_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_QUEUE.length < rcount) {
    pool.free(BLUE_SWEEP_QUEUE)
    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_INDEX.length < rcount) {
    pool.free(BLUE_SWEEP_INDEX)
    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_QUEUE.length < rcount) {
    pool.free(COMMON_SWEEP_QUEUE)
    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_INDEX.length < rcount) {
    pool.free(COMMON_SWEEP_INDEX)
    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  var eventLength = 8 * rcount
  if(SWEEP_EVENTS.length < eventLength) {
    pool.free(SWEEP_EVENTS)
    SWEEP_EVENTS = pool.mallocDouble(eventLength)
  }
}

//Remove an item from the active queue in O(1)
function sqPop(queue, index, count, item) {
  var idx = index[item]
  var top = queue[count-1]
  queue[idx] = top
  index[top] = idx
}

//Insert an item into the active queue in O(1)
function sqPush(queue, index, count, item) {
  queue[count] = item
  index[item]  = count
}

//Recursion base case: use 1D sweep algorithm
function sweepBipartite(
    d, visit,
    redStart,  redEnd, red, redIndex,
    blueStart, blueEnd, blue, blueIndex) {

  //store events as pairs [coordinate, idx]
  //
  //  red create:  -(idx+1)
  //  red destroy: idx
  //  blue create: -(idx+BLUE_FLAG)
  //  blue destroy: idx+BLUE_FLAG
  //
  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = redIndex[i]
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -(idx+1)
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = blueIndex[i]+BLUE_FLAG
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive  = 0
  var blueActive = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e >= BLUE_FLAG) {
      //blue destroy event
      e = (e-BLUE_FLAG)|0
      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e)
    } else if(e >= 0) {
      //red destroy event
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e)
    } else if(e <= -BLUE_FLAG) {
      //blue create event
      e = (-e-BLUE_FLAG)|0
      for(var j=0; j<redActive; ++j) {
        var retval = visit(RED_SWEEP_QUEUE[j], e)
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e)
    } else {
      //red create event
      e = (-e-1)|0
      for(var j=0; j<blueActive; ++j) {
        var retval = visit(e, BLUE_SWEEP_QUEUE[j])
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e)
    }
  }
}

//Complete sweep
function sweepComplete(d, visit, 
  redStart, redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = (redIndex[i]+1)<<1
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = (blueIndex[i]+1)<<1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = (-idx)|1
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx|1
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  var blueActive   = 0
  var commonActive = 0
  for(var i=0; i<n; ++i) {
    var e     = SWEEP_EVENTS[2*i+1]|0
    var color = e&1
    if(i < n-1 && (e>>1) === (SWEEP_EVENTS[2*i+3]>>1)) {
      color = 2
      i += 1
    }
    
    if(e < 0) {
      //Create event
      var id = -(e>>1) - 1

      //Intersect with common
      for(var j=0; j<commonActive; ++j) {
        var retval = visit(COMMON_SWEEP_QUEUE[j], id)
        if(retval !== void 0) {
          return retval
        }
      }

      if(color !== 0) {
        //Intersect with red
        for(var j=0; j<redActive; ++j) {
          var retval = visit(RED_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color !== 1) {
        //Intersect with blue
        for(var j=0; j<blueActive; ++j) {
          var retval = visit(BLUE_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color === 0) {
        //Red
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id)
      } else if(color === 1) {
        //Blue
        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id)
      } else if(color === 2) {
        //Both
        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id)
      }
    } else {
      //Destroy event
      var id = (e>>1) - 1
      if(color === 0) {
        //Red
        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id)
      } else if(color === 1) {
        //Blue
        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id)
      } else if(color === 2) {
        //Both
        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id)
      }
    }
  }
}

//Sweep and prune/scanline algorithm:
//  Scan along axis, detect intersections
//  Brute force all boxes along axis
function scanBipartite(
  d, axis, visit, flip,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {
  
  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  var redShift  = 1
  var blueShift = 1
  if(flip) {
    blueShift = BLUE_FLAG
  } else {
    redShift  = BLUE_FLAG
  }

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + redShift
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + blueShift
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      var isRed = false
      if(idx >= BLUE_FLAG) {
        isRed = !flip
        idx -= BLUE_FLAG 
      } else {
        isRed = !!flip
        idx -= 1
      }
      if(isRed) {
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx)
      } else {
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx
        
        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redPtr = elemSize * oidx

          if(b1 < red[redPtr+axis+1] || 
             red[redPtr+axis+1+d] < b0) {
            continue
          }

          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d] < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var redId  = redIndex[oidx]
          var retval
          if(flip) {
            retval = visit(blueId, redId)
          } else {
            retval = visit(redId, blueId)
          }
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift)
    }
  }
}

function scanComplete(
  d, axis, visit,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + BLUE_FLAG
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + 1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      if(idx >= BLUE_FLAG) {
        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG
      } else {
        idx -= 1
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx

        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redId  = redIndex[oidx]

          if(redId === blueId) {
            break
          }

          var redPtr = elemSize * oidx
          if(b1 < red[redPtr+axis+1] || 
            red[redPtr+axis+1+d] < b0) {
            continue
          }
          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d]   < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var retval = visit(redId, blueId)
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      var idx = e - BLUE_FLAG
      for(var j=redActive-1; j>=0; --j) {
        if(RED_SWEEP_QUEUE[j] === idx) {
          for(var k=j+1; k<redActive; ++k) {
            RED_SWEEP_QUEUE[k-1] = RED_SWEEP_QUEUE[k]
          }
          break
        }
      }
      --redActive
    }
  }
}
},{"./sort":124,"bit-twiddle":126,"typedarray-pool":128}],126:[function(_dereq_,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],127:[function(_dereq_,module,exports){
"use strict"

function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe
},{}],128:[function(_dereq_,module,exports){
(function (global,Buffer){
'use strict'

var bits = _dereq_('bit-twiddle')
var dup = _dereq_('dup')

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8   : dup([32, 0])
    , UINT16  : dup([32, 0])
    , UINT32  : dup([32, 0])
    , INT8    : dup([32, 0])
    , INT16   : dup([32, 0])
    , INT32   : dup([32, 0])
    , FLOAT   : dup([32, 0])
    , DOUBLE  : dup([32, 0])
    , DATA    : dup([32, 0])
    , UINT8C  : dup([32, 0])
    , BUFFER  : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},_dereq_("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L25vZGVfbW9kdWxlcy90eXBlZGFycmF5LXBvb2wvcG9vbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG52YXIgYml0cyA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJylcbnZhciBkdXAgPSByZXF1aXJlKCdkdXAnKVxuXG4vL0xlZ2FjeSBwb29sIHN1cHBvcnRcbmlmKCFnbG9iYWwuX19UWVBFREFSUkFZX1BPT0wpIHtcbiAgZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MID0ge1xuICAgICAgVUlOVDggICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDE2ICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDMyICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UOCAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UMTYgICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UMzIgICA6IGR1cChbMzIsIDBdKVxuICAgICwgRkxPQVQgICA6IGR1cChbMzIsIDBdKVxuICAgICwgRE9VQkxFICA6IGR1cChbMzIsIDBdKVxuICAgICwgREFUQSAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDhDICA6IGR1cChbMzIsIDBdKVxuICAgICwgQlVGRkVSICA6IGR1cChbMzIsIDBdKVxuICB9XG59XG5cbnZhciBoYXNVaW50OEMgPSAodHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSAhPT0gJ3VuZGVmaW5lZCdcbnZhciBQT09MID0gZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MXG5cbi8vVXBncmFkZSBwb29sXG5pZighUE9PTC5VSU5UOEMpIHtcbiAgUE9PTC5VSU5UOEMgPSBkdXAoWzMyLCAwXSlcbn1cbmlmKCFQT09MLkJVRkZFUikge1xuICBQT09MLkJVRkZFUiA9IGR1cChbMzIsIDBdKVxufVxuXG4vL05ldyB0ZWNobmlxdWU6IE9ubHkgYWxsb2NhdGUgZnJvbSBBcnJheUJ1ZmZlclZpZXcgYW5kIEJ1ZmZlclxudmFyIERBVEEgICAgPSBQT09MLkRBVEFcbiAgLCBCVUZGRVIgID0gUE9PTC5CVUZGRVJcblxuZXhwb3J0cy5mcmVlID0gZnVuY3Rpb24gZnJlZShhcnJheSkge1xuICBpZihCdWZmZXIuaXNCdWZmZXIoYXJyYXkpKSB7XG4gICAgQlVGRkVSW2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxuICB9IGVsc2Uge1xuICAgIGlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnJheSkgIT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIGFycmF5ID0gYXJyYXkuYnVmZmVyXG4gICAgfVxuICAgIGlmKCFhcnJheSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBuID0gYXJyYXkubGVuZ3RoIHx8IGFycmF5LmJ5dGVMZW5ndGhcbiAgICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobil8MFxuICAgIERBVEFbbG9nX25dLnB1c2goYXJyYXkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZnJlZUFycmF5QnVmZmVyKGJ1ZmZlcikge1xuICBpZighYnVmZmVyKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG4gPSBidWZmZXIubGVuZ3RoIHx8IGJ1ZmZlci5ieXRlTGVuZ3RoXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICBEQVRBW2xvZ19uXS5wdXNoKGJ1ZmZlcilcbn1cblxuZnVuY3Rpb24gZnJlZVR5cGVkQXJyYXkoYXJyYXkpIHtcbiAgZnJlZUFycmF5QnVmZmVyKGFycmF5LmJ1ZmZlcilcbn1cblxuZXhwb3J0cy5mcmVlVWludDggPVxuZXhwb3J0cy5mcmVlVWludDE2ID1cbmV4cG9ydHMuZnJlZVVpbnQzMiA9XG5leHBvcnRzLmZyZWVJbnQ4ID1cbmV4cG9ydHMuZnJlZUludDE2ID1cbmV4cG9ydHMuZnJlZUludDMyID1cbmV4cG9ydHMuZnJlZUZsb2F0MzIgPSBcbmV4cG9ydHMuZnJlZUZsb2F0ID1cbmV4cG9ydHMuZnJlZUZsb2F0NjQgPSBcbmV4cG9ydHMuZnJlZURvdWJsZSA9IFxuZXhwb3J0cy5mcmVlVWludDhDbGFtcGVkID0gXG5leHBvcnRzLmZyZWVEYXRhVmlldyA9IGZyZWVUeXBlZEFycmF5XG5cbmV4cG9ydHMuZnJlZUFycmF5QnVmZmVyID0gZnJlZUFycmF5QnVmZmVyXG5cbmV4cG9ydHMuZnJlZUJ1ZmZlciA9IGZ1bmN0aW9uIGZyZWVCdWZmZXIoYXJyYXkpIHtcbiAgQlVGRkVSW2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxufVxuXG5leHBvcnRzLm1hbGxvYyA9IGZ1bmN0aW9uIG1hbGxvYyhuLCBkdHlwZSkge1xuICBpZihkdHlwZSA9PT0gdW5kZWZpbmVkIHx8IGR0eXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgcmV0dXJuIG1hbGxvY0FycmF5QnVmZmVyKG4pXG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoKGR0eXBlKSB7XG4gICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OChuKVxuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQxNihuKVxuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQzMihuKVxuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQ4KG4pXG4gICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQxNihuKVxuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jSW50MzIobilcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jRmxvYXQobilcbiAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0RvdWJsZShuKVxuICAgICAgY2FzZSAndWludDhfY2xhbXBlZCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OENsYW1wZWQobilcbiAgICAgIGNhc2UgJ2J1ZmZlcic6XG4gICAgICAgIHJldHVybiBtYWxsb2NCdWZmZXIobilcbiAgICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgY2FzZSAnZGF0YXZpZXcnOlxuICAgICAgICByZXR1cm4gbWFsbG9jRGF0YVZpZXcobilcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gbWFsbG9jQXJyYXlCdWZmZXIobikge1xuICB2YXIgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBkID0gREFUQVtsb2dfbl1cbiAgaWYoZC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGQucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKG4pXG59XG5leHBvcnRzLm1hbGxvY0FycmF5QnVmZmVyID0gbWFsbG9jQXJyYXlCdWZmZXJcblxuZnVuY3Rpb24gbWFsbG9jVWludDgobikge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQ4ID0gbWFsbG9jVWludDhcblxuZnVuY3Rpb24gbWFsbG9jVWludDE2KG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShtYWxsb2NBcnJheUJ1ZmZlcigyKm4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50MTYgPSBtYWxsb2NVaW50MTZcblxuZnVuY3Rpb24gbWFsbG9jVWludDMyKG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50MzIgPSBtYWxsb2NVaW50MzJcblxuZnVuY3Rpb24gbWFsbG9jSW50OChuKSB7XG4gIHJldHVybiBuZXcgSW50OEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQ4ID0gbWFsbG9jSW50OFxuXG5mdW5jdGlvbiBtYWxsb2NJbnQxNihuKSB7XG4gIHJldHVybiBuZXcgSW50MTZBcnJheShtYWxsb2NBcnJheUJ1ZmZlcigyKm4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQxNiA9IG1hbGxvY0ludDE2XG5cbmZ1bmN0aW9uIG1hbGxvY0ludDMyKG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDMyID0gbWFsbG9jSW50MzJcblxuZnVuY3Rpb24gbWFsbG9jRmxvYXQobikge1xuICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NGbG9hdDMyID0gZXhwb3J0cy5tYWxsb2NGbG9hdCA9IG1hbGxvY0Zsb2F0XG5cbmZ1bmN0aW9uIG1hbGxvY0RvdWJsZShuKSB7XG4gIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDgqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0Zsb2F0NjQgPSBleHBvcnRzLm1hbGxvY0RvdWJsZSA9IG1hbGxvY0RvdWJsZVxuXG5mdW5jdGlvbiBtYWxsb2NVaW50OENsYW1wZWQobikge1xuICBpZihoYXNVaW50OEMpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYWxsb2NVaW50OChuKVxuICB9XG59XG5leHBvcnRzLm1hbGxvY1VpbnQ4Q2xhbXBlZCA9IG1hbGxvY1VpbnQ4Q2xhbXBlZFxuXG5mdW5jdGlvbiBtYWxsb2NEYXRhVmlldyhuKSB7XG4gIHJldHVybiBuZXcgRGF0YVZpZXcobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0RhdGFWaWV3ID0gbWFsbG9jRGF0YVZpZXdcblxuZnVuY3Rpb24gbWFsbG9jQnVmZmVyKG4pIHtcbiAgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBjYWNoZSA9IEJVRkZFUltsb2dfbl1cbiAgaWYoY2FjaGUubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBjYWNoZS5wb3AoKVxuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKG4pXG59XG5leHBvcnRzLm1hbGxvY0J1ZmZlciA9IG1hbGxvY0J1ZmZlclxuXG5leHBvcnRzLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICBmb3IodmFyIGk9MDsgaTwzMjsgKytpKSB7XG4gICAgUE9PTC5VSU5UOFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UMTZbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDMyW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDhbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UMTZbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UMzJbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuRkxPQVRbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuRE9VQkxFW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQ4Q1tpXS5sZW5ndGggPSAwXG4gICAgREFUQVtpXS5sZW5ndGggPSAwXG4gICAgQlVGRkVSW2ldLmxlbmd0aCA9IDBcbiAgfVxufSJdfQ==
},{"bit-twiddle":126,"buffer":130,"dup":127}],129:[function(_dereq_,module,exports){
module.exports=_dereq_(109)
},{"/Users/bcamper/Documents/dev/vector-map/node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.to-string.js":109}],130:[function(_dereq_,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = _dereq_('base64-js')
var ieee754 = _dereq_('ieee754')
var isArray = _dereq_('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length, unitSize) {
  if (unitSize) length -= length % unitSize;
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":131,"ieee754":132,"is-array":133}],131:[function(_dereq_,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],132:[function(_dereq_,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],133:[function(_dereq_,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],134:[function(_dereq_,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],135:[function(_dereq_,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canMutationObserver = typeof window !== 'undefined'
    && window.MutationObserver;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    var queue = [];

    if (canMutationObserver) {
        var hiddenDiv = document.createElement("div");
        var observer = new MutationObserver(function () {
            var queueList = queue.slice();
            queue.length = 0;
            queueList.forEach(function (fn) {
                fn();
            });
        });

        observer.observe(hiddenDiv, { attributes: true });

        return function nextTick(fn) {
            if (!queue.length) {
                hiddenDiv.setAttribute('yes', 'no');
            }
            queue.push(fn);
        };
    }

    if (canPost) {
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],136:[function(_dereq_,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],137:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = _dereq_('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = _dereq_('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiJdfQ==
},{"./support/isBuffer":136,"_process":135,"inherits":134}],138:[function(_dereq_,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor } catch(e) { }

},{}],139:[function(_dereq_,module,exports){
'use strict';

module.exports = earcut;

function earcut(points) {

    var outerNode = linkedList(points[0], true),
        node, minX, minY, maxX, maxY, x, y, size,
        len = 0,
        threshold = 80;

    for (var i = 0; len < threshold && i < points.length; i++) len += points[i].length;

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (len >= threshold) {
        node = outerNode.next;
        minX = maxX = node.p[0];
        minY = maxY = node.p[1];
        do {
            x = node.p[0];
            y = node.p[1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            node = node.next;
        } while (node !== outerNode);

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    if (points.length > 1) outerNode = eliminateHoles(points, outerNode);

    var triangles = [];
    if (outerNode) earcutLinked(outerNode, triangles, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(points, clockwise) {
    var sum = 0,
        len = points.length,
        i, j, last;

    // calculate original winding order of a polygon ring
    for (i = 0, j = len - 1; i < len; j = i++) {
        var p1 = points[i],
            p2 = points[j];
        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
    }

    // link points into circular doubly-linked list in the specified winding order
    if (clockwise === (sum > 0)) {
        for (i = 0; i < len; i++) last = insertNode(points[i], last);
    } else {
        for (i = len - 1; i >= 0; i--) last = insertNode(points[i], last);
    }

    return last;
}

function filterPoints(start) {
    // eliminate colinear or duplicate points
    var node = start,
        again;
    do {
        again = false;

        if (equals(node.p, node.next.p) || orient(node.prev.p, node.p, node.next.p) === 0) {

            node.prev.next = node.next;
            node.next.prev = node.prev;

            if (node.prevZ) node.prevZ.nextZ = node.nextZ;
            if (node.nextZ) node.nextZ.prevZ = node.prevZ;

            node = start = node.prev;

            if (node === node.next) return null;
            again = true;

        } else {
            node = node.next;
        }
    } while (again || node !== start);

    return start;
}

function earcutLinked(ear, triangles, minX, minY, size, secondPass) {
    ear = filterPoints(ear);
    if (!ear) return;

    if (!secondPass && minX !== undefined) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (isEar(ear, minX, minY, size)) {
            triangles.push(prev.p, ear.p, next.p);

            next.prev = prev;
            prev.next = next;

            if (ear.prevZ) ear.prevZ.nextZ = ear.nextZ;
            if (ear.nextZ) ear.nextZ.prevZ = ear.prevZ;

            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        if (ear === stop) {
            // if we can't find any more ears, try filtering points and cutting again
            if (!secondPass) earcutLinked(ear, triangles, minX, minY, size, true);
            // if this didn't work, try splitting the remaining polygon into two
            else splitEarcut(ear, triangles, minX, minY, size);
            break;
        }
    }
}

function isEar(ear, minX, minY, size) {

    var a = ear.prev.p,
        b = ear.p,
        c = ear.next.p,

        ax = a[0], bx = b[0], cx = c[0],
        ay = a[1], by = b[1], cy = c[1],

        abd = ax * by - ay * bx,
        acd = ax * cy - ay * cx,
        cbd = cx * by - cy * bx,
        A = abd - acd - cbd;

    if (A <= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear

    var cay = cy - ay,
        acx = ax - cx,
        aby = ay - by,
        bax = bx - ax,
        p, px, py, s, t, k, node;

    // if we use z-order curve hashing, iterate through the curve
    if (minX !== undefined) {

        // triangle bbox; min & max are calculated like this for speed
        var minTX = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
            minTY = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
            maxTX = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
            maxTY = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy),

            // z-order range for the current triangle bbox;
            minZ = zOrder(minTX, minTY, minX, minY, size),
            maxZ = zOrder(maxTX, maxTY, minX, minY, size);

        // first look for points inside the triangle in increasing z-order
        node = ear.nextZ;

        while (node && node.z <= maxZ) {
            p = node.p;
            node = node.nextZ;
            if (p === a || p === c) continue;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }

        // then look for points in decreasing z-order
        node = ear.prevZ;

        while (node && node.z >= minZ) {
            p = node.p;
            node = node.prevZ;
            if (p === a || p === c) continue;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }

    // if we don't use z-order curve hash, simply iterate through all other points
    } else {
        node = ear.next.next;

        while (node !== ear.prev) {
            p = node.p;
            node = node.next;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }
    }

    return true;
}

function splitEarcut(start, triangles, minX, minY, size) {
    // find a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // run earcut on each half
                earcutLinked(a, triangles, minX, minY, size);
                earcutLinked(c, triangles, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

function eliminateHoles(points, outerNode) {
    var len = points.length;

    var queue = [];
    for (var i = 1; i < len; i++) {
        var list = filterPoints(linkedList(points[i], false));
        if (list) queue.push(getLeftmost(list));
    }
    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode);
    }

    return outerNode;
}

function eliminateHole(holeNode, outerNode) {
    outerNode = findHoleBridge(holeNode, outerNode);
    if (outerNode) splitPolygon(holeNode, outerNode);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(holeNode, outerNode) {
    var node = outerNode,
        p = holeNode.p,
        px = p[0],
        py = p[1],
        qMax = -Infinity,
        mNode, a, b;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        a = node.p;
        b = node.next.p;

        if (py <= a[1] && py >= b[1]) {
            var qx = a[0] + (py - a[1]) * (b[0] - a[0]) / (b[1] - a[1]);
            if (qx <= px && qx > qMax) {
                qMax = qx;
                mNode = a[0] < b[0] ? node : node.next;
            }
        }
        node = node.next;
    } while (node !== outerNode);

    if (!mNode) return null;

    // look for points strictly inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var bx = mNode.p[0],
        by = mNode.p[1],
        pbd = px * by - py * bx,
        pcd = px * py - py * qMax,
        cpy = py - py,
        pcx = px - qMax,
        pby = py - by,
        bpx = bx - px,
        A = pbd - pcd - (qMax * by - py * bx),
        sign = A <= 0 ? -1 : 1,
        stop = mNode,
        tanMin = Infinity,
        mx, my, amx, s, t, tan;

    node = mNode.next;

    while (node !== stop) {

        mx = node.p[0];
        my = node.p[1];
        amx = px - mx;

        if (amx >= 0 && mx >= bx) {
            s = (cpy * mx + pcx * my - pcd) * sign;
            if (s >= 0) {
                t = (pby * mx + bpx * my + pbd) * sign;

                if (t >= 0 && A * sign - s - t >= 0) {
                    tan = Math.abs(py - my) / amx; // tangential
                    if (tan < tanMin && locallyInside(node, holeNode)) {
                        mNode = node;
                        tanMin = tan;
                    }
                }
            }
        }

        node = node.next;
    }

    return mNode;
}

function indexCurve(start, minX, minY, size) {
    var node = start;

    do {
        node.z = node.z || zOrder(node.p[0], node.p[1], minX, minY, size);
        node.prevZ = node.prev;
        node.nextZ = node.next;
        node = node.next;
    } while (node !== start);

    node.prevZ.nextZ = null;
    node.prevZ = null;

    sortLinked(node);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    while (true) {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }

            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize === 0) {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                } else if (qSize === 0 || !q) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else if (p.z <= q.z) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;

        if (numMerges <= 1) return list;

        inSize *= 2;
    }
}

// z-order of a point given coords and bbox
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into (0..1000) integer range
    x = 1000 * (x - minX) / size;
    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = 1000 * (y - minY) / size;
    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

function getLeftmost(start) {
    var node = start,
        leftmost = start;
    do {
        if (node.p[0] < leftmost.p[0]) leftmost = node;
        node = node.next;
    } while (node !== start);

    return leftmost;
}

function isValidDiagonal(a, b) {
    return !intersectsPolygon(a, a.p, b.p) &&
           locallyInside(a, b) && locallyInside(b, a) &&
           middleInside(a, a.p, b.p);
}

// winding order of triangle formed by 3 given points
function orient(p, q, r) {
    var o = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
    return o > 0 ? 1 :
           o < 0 ? -1 : 0;
}

function equals(p1, p2) {
    return p1[0] === p2[0] && p1[1] === p2[1];
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    return orient(p1, q1, p2) !== orient(p1, q1, q2) &&
           orient(p2, q2, p1) !== orient(p2, q2, q1);
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(start, a, b) {
    var node = start;
    do {
        var p1 = node.p,
            p2 = node.next.p;

        if (p1 !== a && p2 !== a && p1 !== b && p2 !== b && intersects(p1, p2, a, b)) return true;

        node = node.next;
    } while (node !== start);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return orient(a.prev.p, a.p, a.next.p) === -1 ?
        orient(a.p, b.p, a.next.p) !== -1 && orient(a.p, a.prev.p, b.p) !== -1 :
        orient(a.p, b.p, a.prev.p) === -1 || orient(a.p, a.next.p, b.p) === -1;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(start, a, b) {
    var node = start,
        inside = false,
        px = (a[0] + b[0]) / 2,
        py = (a[1] + b[1]) / 2;
    do {
        var p1 = node.p,
            p2 = node.next.p;

        if (((p1[1] > py) !== (p2[1] > py)) &&
            (px < (p2[0] - p1[0]) * (py - p1[1]) / (p2[1] - p1[1]) + p1[0])) inside = !inside;

        node = node.next;
    } while (node !== start);

    return inside;
}

function compareX(a, b) {
    return a.p[0] - b.p[0];
}

// split the polygon vertices circular doubly-linked linked list into two
function splitPolygon(a, b) {
    var a2 = new Node(a.p),
        b2 = new Node(b.p),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return a2;
}

function insertNode(point, last) {
    var node = new Node(point);

    if (!last) {
        node.prev = node;
        node.next = node;

    } else {
        node.next = last.next;
        node.prev = last;
        last.next.prev = node;
        last.next = node;
    }
    return node;
}

function Node(p) {
    this.p = p;
    this.prev = null;
    this.next = null;

    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
}

},{}],140:[function(_dereq_,module,exports){
'use strict';

module.exports = clip;

/* clip features between two axis-parallel lines:
 *     |        |
 *  ___|___     |     /
 * /   |   \____|____/
 *     |        |
 */

function clip(features, scale, k1, k2, axis, intersect, minAll, maxAll) {

    k1 /= scale;
    k2 /= scale;

    if (minAll >= k1 && maxAll <= k2) return features; // trivial accept
    else if (minAll > k2 || maxAll < k1) return null; // trivial reject

    var clipped = [];

    for (var i = 0; i < features.length; i++) {

        var feature = features[i],
            geometry = feature.geometry,
            type = feature.type,
            min, max;

        min = feature.min[axis];
        max = feature.max[axis];

        if (min >= k1 && max <= k2) { // trivial accept
            clipped.push(feature);
            continue;
        } else if (min > k2 || max < k1) continue; // trivial reject

        var slices = type === 1 ?
                clipPoints(geometry, k1, k2, axis) :
                clipGeometry(geometry, k1, k2, axis, intersect, type === 3);

        if (slices.length) {
            // if a feature got clipped, it will likely get clipped on the next zoom level as well,
            // so there's no need to recalculate bboxes
            clipped.push({
                geometry: slices,
                type: type,
                tags: features[i].tags || null,
                min: feature.min,
                max: feature.max
            });
        }
    }

    return clipped.length ? clipped : null;
}

function clipPoints(geometry, k1, k2, axis) {
    var slice = [];

    for (var i = 0; i < geometry.length; i++) {
        var a = geometry[i],
            ak = a[axis];

        if (ak >= k1 && ak <= k2) slice.push(a);
    }
    return slice;
}

function clipGeometry(geometry, k1, k2, axis, intersect, closed) {

    var slices = [];

    for (var i = 0; i < geometry.length; i++) {

        var ak = 0,
            bk = 0,
            b = null,
            points = geometry[i],
            area = points.area,
            dist = points.dist,
            len = points.length,
            a, j, last;

        var slice = [];

        for (j = 0; j < len - 1; j++) {
            a = b || points[j];
            b = points[j + 1];
            ak = bk || a[axis];
            bk = b[axis];

            if (ak < k1) {

                if ((bk > k2)) { // ---|-----|-->
                    slice.push(intersect(a, b, k1), intersect(a, b, k2));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk >= k1) slice.push(intersect(a, b, k1)); // ---|-->  |

            } else if (ak > k2) {

                if ((bk < k1)) { // <--|-----|---
                    slice.push(intersect(a, b, k2), intersect(a, b, k1));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk <= k2) slice.push(intersect(a, b, k2)); // |  <--|---

            } else {

                slice.push(a);

                if (bk < k1) { // <--|---  |
                    slice.push(intersect(a, b, k1));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk > k2) { // |  ---|-->
                    slice.push(intersect(a, b, k2));
                    if (!closed) slice = newSlice(slices, slice, area, dist);
                }
                // | --> |
            }
        }

        // add the last point
        a = points[len - 1];
        ak = a[axis];
        if (ak >= k1 && ak <= k2) slice.push(a);

        // close the polygon if its endpoints are not the same after clipping

        last = slice[slice.length - 1];
        if (closed && last && (slice[0][0] !== last[0] || slice[0][1] !== last[1])) slice.push(slice[0]);

        // add the final slice
        newSlice(slices, slice, area, dist);
    }

    return slices;
}

function newSlice(slices, slice, area, dist) {
    if (slice.length) {
        // we don't recalculate the area/length of the unclipped geometry because the case where it goes
        // below the visibility threshold as a result of clipping is rare, so we avoid doing unnecessary work
        slice.area = area;
        slice.dist = dist;

        slices.push(slice);
    }
    return [];
}

},{}],141:[function(_dereq_,module,exports){
'use strict';

module.exports = convert;

var simplify = _dereq_('./simplify');

// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data

function convert(data, tolerance) {
    var features = [];

    if (data.type === 'FeatureCollection') {
        for (var i = 0; i < data.features.length; i++) {
            convertFeature(features, data.features[i], tolerance);
        }
    } else if (data.type === 'Feature') {
        convertFeature(features, data, tolerance);

    } else {
        // single geometry or a geometry collection
        convertFeature(features, {geometry: data}, tolerance);
    }
    return features;
}

function convertFeature(features, feature, tolerance) {
    var geom = feature.geometry,
        type = geom.type,
        coords = geom.coordinates,
        tags = feature.properties,
        i, j, rings;

    if (type === 'Point') {
        features.push(create(tags, 1, [projectPoint(coords)]));

    } else if (type === 'MultiPoint') {
        features.push(create(tags, 1, project(coords)));

    } else if (type === 'LineString') {
        features.push(create(tags, 2, [project(coords, tolerance)]));

    } else if (type === 'MultiLineString' || type === 'Polygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            rings.push(project(coords[i], tolerance));
        }
        features.push(create(tags, type === 'Polygon' ? 3 : 2, rings));

    } else if (type === 'MultiPolygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
                rings.push(project(coords[i][j], tolerance));
            }
        }
        features.push(create(tags, 3, rings));

    } else if (type === 'GeometryCollection') {
        for (i = 0; i < geom.geometries.length; i++) {
            convertFeature(features, {
                geometry: geom.geometries[i],
                properties: tags
            }, tolerance);
        }

    } else {
        throw new Error('Input data is not a valid GeoJSON object.');
    }
}

function create(tags, type, geometry) {
    var feature = {
        geometry: geometry,
        type: type,
        tags: tags || null,
        min: [2, 1], // initial bbox values;
        max: [-1, 0]  // note that coords are usually in [0..1] range
    };
    calcBBox(feature);
    return feature;
}

function project(lonlats, tolerance) {
    var projected = [];
    for (var i = 0; i < lonlats.length; i++) {
        projected.push(projectPoint(lonlats[i]));
    }
    if (tolerance) {
        simplify(projected, tolerance);
        calcSize(projected);
    }
    return projected;
}

function projectPoint(p) {
    var sin = Math.sin(p[1] * Math.PI / 180),
        x = (p[0] / 360 + 0.5),
        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);

    y = y < -1 ? -1 :
        y > 1 ? 1 : y;

    return [x, y, 0];
}

// calculate area and length of the poly
function calcSize(points) {
    var area = 0,
        dist = 0;

    for (var i = 0, a, b; i < points.length - 1; i++) {
        a = b || points[i];
        b = points[i + 1];

        area += a[0] * b[1] - b[0] * a[1];

        // use Manhattan distance instead of Euclidian one to avoid expensive square root computation
        dist += Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]);
    }
    points.area = Math.abs(area / 2);
    points.dist = dist;
}

// calculate the feature bounding box for faster clipping later
function calcBBox(feature) {
    var geometry = feature.geometry,
        min = feature.min,
        max = feature.max;

    if (feature.type === 1) calcRingBBox(min, max, geometry);
    else for (var i = 0; i < geometry.length; i++) calcRingBBox(min, max, geometry[i]);

    return feature;
}

function calcRingBBox(min, max, points) {
    for (var i = 0, p; i < points.length; i++) {
        p = points[i];
        min[0] = Math.min(p[0], min[0]);
        max[0] = Math.max(p[0], max[0]);
        min[1] = Math.min(p[1], min[1]);
        max[1] = Math.max(p[1], max[1]);
    }
}

},{"./simplify":143}],142:[function(_dereq_,module,exports){
'use strict';

module.exports = geojsonvt;

var convert = _dereq_('./convert'), // GeoJSON conversion and preprocessing
    clip = _dereq_('./clip'),       // stripe clipping algorithm
    wrap = _dereq_('./wrap'),       // date line processing
    createTile = _dereq_('./tile'); // final simplified tile generation


function geojsonvt(data, options) {
    return new GeoJSONVT(data, options);
}

function GeoJSONVT(data, options) {
    options = this.options = extend(Object.create(this.options), options);

    var debug = options.debug;

    if (debug) console.time('preprocess data');

    var z2 = 1 << options.maxZoom, // 2^z
        features = convert(data, options.tolerance / (z2 * options.extent));

    this.tiles = {};
    this.tileCoords = [];

    if (debug) {
        console.timeEnd('preprocess data');
        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);
        console.time('generate tiles');
        this.stats = {};
        this.total = 0;
    }

    features = wrap(features, options.buffer / options.extent, intersectX);

    // start slicing from the top tile down
    if (features.length) this.splitTile(features, 0, 0, 0);

    if (debug) {
        if (features.length) console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);
        console.timeEnd('generate tiles');
        console.log('tiles generated:', this.total, JSON.stringify(this.stats));
    }
}

GeoJSONVT.prototype.options = {
    maxZoom: 14,            // max zoom to preserve detail on
    indexMaxZoom: 5,        // max zoom in the tile index
    indexMaxPoints: 100000, // max number of points per tile in the tile index
    solidChildren: false,   // whether to tile solid square tiles further
    tolerance: 3,           // simplification tolerance (higher means simpler)
    extent: 4096,           // tile extent
    buffer: 64,             // tile buffer on each side
    debug: 0                // logging level (0, 1 or 2)
};

GeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {

    var stack = [features, z, x, y],
        options = this.options,
        debug = options.debug;

    // avoid recursion by using a processing queue
    while (stack.length) {
        y = stack.pop();
        x = stack.pop();
        z = stack.pop();
        features = stack.pop();

        var z2 = 1 << z,
            id = toID(z, x, y),
            tile = this.tiles[id],
            tileTolerance = z === options.maxZoom ? 0 : options.tolerance / (z2 * options.extent);

        if (!tile) {
            if (debug > 1) console.time('creation');

            tile = this.tiles[id] = createTile(features, z2, x, y, tileTolerance, z === options.maxZoom);
            this.tileCoords.push({z: z, x: x, y: y});

            if (debug) {
                if (debug > 1) {
                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',
                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);
                    console.timeEnd('creation');
                }
                var key = 'z' + z;
                this.stats[key] = (this.stats[key] || 0) + 1;
                this.total++;
            }
        }

        // save reference to original geometry in tile so that we can drill down later if we stop now
        tile.source = features;

        // stop tiling if the tile is solid clipped square
        if (!options.solidChildren && isClippedSquare(tile, options.extent, options.buffer)) continue;

        // if it's the first-pass tiling
        if (!cz) {
            // stop tiling if we reached max zoom, or if the tile is too simple
            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;

        // if a drilldown to a specific tile
        } else {
            // stop tiling if we reached base zoom or our target tile zoom
            if (z === options.maxZoom || z === cz) continue;

            // stop tiling if it's not an ancestor of the target tile
            var m = 1 << (cz - z);
            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) continue;
        }

        // if we slice further down, no need to keep source geometry
        tile.source = null;

        if (debug > 1) console.time('clipping');

        // values we'll use for clipping
        var k1 = 0.5 * options.buffer / options.extent,
            k2 = 0.5 - k1,
            k3 = 0.5 + k1,
            k4 = 1 + k1,
            tl, bl, tr, br, left, right;

        tl = bl = tr = br = null;

        left  = clip(features, z2, x - k1, x + k3, 0, intersectX, tile.min[0], tile.max[0]);
        right = clip(features, z2, x + k2, x + k4, 0, intersectX, tile.min[0], tile.max[0]);

        if (left) {
            tl = clip(left, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            bl = clip(left, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (right) {
            tr = clip(right, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            br = clip(right, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (debug > 1) console.timeEnd('clipping');

        if (tl) stack.push(tl, z + 1, x * 2,     y * 2);
        if (bl) stack.push(bl, z + 1, x * 2,     y * 2 + 1);
        if (tr) stack.push(tr, z + 1, x * 2 + 1, y * 2);
        if (br) stack.push(br, z + 1, x * 2 + 1, y * 2 + 1);
    }
};

GeoJSONVT.prototype.getTile = function (z, x, y) {
    var options = this.options,
        extent = options.extent,
        debug = options.debug;

    var z2 = 1 << z;
    x = ((x % z2) + z2) % z2; // wrap tile x coordinate

    var id = toID(z, x, y);
    if (this.tiles[id]) return transformTile(this.tiles[id], extent);

    if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);

    var z0 = z,
        x0 = x,
        y0 = y,
        parent;

    while (!parent && z0 > 0) {
        z0--;
        x0 = Math.floor(x0 / 2);
        y0 = Math.floor(y0 / 2);
        parent = this.tiles[toID(z0, x0, y0)];
    }

    if (!parent) return null;

    if (debug > 1) console.log('found parent tile z%d-%d-%d', z0, x0, y0);

    // if we found a parent tile containing the original geometry, we can drill down from it
    if (parent.source) {
        if (isClippedSquare(parent, extent, options.buffer)) return transformTile(parent, extent);

        if (debug > 1) console.time('drilling down');
        this.splitTile(parent.source, z0, x0, y0, z, x, y);
        if (debug > 1) console.timeEnd('drilling down');
    }

    if (!this.tiles[id]) return null;

    return transformTile(this.tiles[id], extent);
};

function transformTile(tile, extent) {
    if (tile.transformed) return tile;

    var z2 = tile.z2,
        tx = tile.x,
        ty = tile.y,
        i, j, k;

    for (i = 0; i < tile.features.length; i++) {
        var feature = tile.features[i],
            geom = feature.geometry,
            type = feature.type;

        if (type === 1) {
            for (j = 0; j < geom.length; j++) geom[j] = transformPoint(geom[j], extent, z2, tx, ty);

        } else {
            for (j = 0; j < geom.length; j++) {
                var ring = geom[j];
                for (k = 0; k < ring.length; k++) ring[k] = transformPoint(ring[k], extent, z2, tx, ty);
            }
        }
    }

    tile.transformed = true;

    return tile;
}

function transformPoint(p, extent, z2, tx, ty) {
    var x = Math.round(extent * (p[0] * z2 - tx)),
        y = Math.round(extent * (p[1] * z2 - ty));
    return [x, y];
}

function toID(z, x, y) {
    return (((1 << z) * y + x) * 32) + z;
}

function intersectX(a, b, x) {
    return [x, (x - a[0]) * (b[1] - a[1]) / (b[0] - a[0]) + a[1], 1];
}
function intersectY(a, b, y) {
    return [(y - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0], y, 1];
}

function extend(dest, src) {
    for (var i in src) dest[i] = src[i];
    return dest;
}

// checks whether a tile is a whole-area fill after clipping; if it is, there's no sense slicing it further
function isClippedSquare(tile, extent, buffer) {

    var features = tile.source;
    if (features.length !== 1) return false;

    var feature = features[0];
    if (feature.type !== 3 || feature.geometry.length > 1) return false;

    var len = feature.geometry[0].length;
    if (len !== 5) return false;

    for (var i = 0; i < len; i++) {
        var p = transformPoint(feature.geometry[0][i], extent, tile.z2, tile.x, tile.y);
        if ((p[0] !== -buffer && p[0] !== extent + buffer) ||
            (p[1] !== -buffer && p[1] !== extent + buffer)) return false;
    }

    return true;
}

},{"./clip":140,"./convert":141,"./tile":144,"./wrap":145}],143:[function(_dereq_,module,exports){
'use strict';

module.exports = simplify;

// calculate simplification data using optimized Douglas-Peucker algorithm

function simplify(points, tolerance) {

    var sqTolerance = tolerance * tolerance,
        len = points.length,
        first = 0,
        last = len - 1,
        stack = [],
        i, maxSqDist, sqDist, index;

    // always retain the endpoints (1 is the max value)
    points[first][2] = 1;
    points[last][2] = 1;

    // avoid recursion by using a stack
    while (last) {

        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSqSegDist(points[i], points[first], points[last]);

            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            points[index][2] = maxSqDist; // save the point importance in squared pixels as a z coordinate
            stack.push(first);
            stack.push(index);
            first = index;

        } else {
            last = stack.pop();
            first = stack.pop();
        }
    }
}

// square distance from a point to a segment
function getSqSegDist(p, a, b) {

    var x = a[0], y = a[1],
        bx = b[0], by = b[1],
        px = p[0], py = p[1],
        dx = bx - x,
        dy = by - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = bx;
            y = by;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = px - x;
    dy = py - y;

    return dx * dx + dy * dy;
}

},{}],144:[function(_dereq_,module,exports){
'use strict';

module.exports = createTile;

function createTile(features, z2, tx, ty, tolerance, noSimplify) {
    var tile = {
        features: [],
        numPoints: 0,
        numSimplified: 0,
        numFeatures: 0,
        source: null,
        x: tx,
        y: ty,
        z2: z2,
        transformed: false,
        min: [2, 1],
        max: [-1, 0]
    };
    for (var i = 0; i < features.length; i++) {
        tile.numFeatures++;
        addFeature(tile, features[i], tolerance, noSimplify);

        var min = features[i].min,
            max = features[i].max;

        if (min[0] < tile.min[0]) tile.min[0] = min[0];
        if (min[1] < tile.min[1]) tile.min[1] = min[1];
        if (max[0] > tile.max[0]) tile.max[0] = max[0];
        if (max[1] > tile.max[1]) tile.max[1] = max[1];
    }
    return tile;
}

function addFeature(tile, feature, tolerance, noSimplify) {

    var geom = feature.geometry,
        type = feature.type,
        simplified = [],
        sqTolerance = tolerance * tolerance,
        i, j, ring, p;

    if (type === 1) {
        for (i = 0; i < geom.length; i++) {
            simplified.push(geom[i]);
            tile.numPoints++;
            tile.numSimplified++;
        }

    } else {

        // simplify and transform projected coordinates for tile geometry
        for (i = 0; i < geom.length; i++) {
            ring = geom[i];

            // filter out tiny polylines & polygons
            if (!noSimplify && ((type === 2 && ring.dist < tolerance) ||
                                (type === 3 && ring.area < sqTolerance))) {
                tile.numPoints += ring.length;
                continue;
            }

            var simplifiedRing = [];

            for (j = 0; j < ring.length; j++) {
                p = ring[j];
                // keep points with importance > tolerance
                if (noSimplify || p[2] > sqTolerance) {
                    simplifiedRing.push(p);
                    tile.numSimplified++;
                }
                tile.numPoints++;
            }

            simplified.push(simplifiedRing);
        }
    }

    if (simplified.length) {
        tile.features.push({
            geometry: simplified,
            type: type,
            tags: feature.tags || null
        });
    }
}

},{}],145:[function(_dereq_,module,exports){
'use strict';

var clip = _dereq_('./clip');

module.exports = wrap;

function wrap(features, buffer, intersectX) {
    var merged = features,
        left  = clip(features, 1, -1 - buffer, buffer,     0, intersectX, -1, 2), // left world copy
        right = clip(features, 1,  1 - buffer, 2 + buffer, 0, intersectX, -1, 2); // right world copy

    if (left || right) {
        merged = clip(features, 1, -buffer, 1 + buffer, 0, intersectX, -1, 2); // center world copy

        if (left) merged = shiftFeatureCoords(left, 1).concat(merged); // merge left into center
        if (right) merged = merged.concat(shiftFeatureCoords(right, -1)); // merge right into center
    }

    return merged;
}

function shiftFeatureCoords(features, offset) {
    var newFeatures = [];

    for (var i = 0; i < features.length; i++) {
        var feature = features[i],
            type = feature.type;

        var newGeometry;

        if (type === 1) {
            newGeometry = shiftCoords(feature.geometry, offset);
        } else {
            newGeometry = [];
            for (var j = 0; j < feature.geometry.length; j++) {
                newGeometry.push(shiftCoords(feature.geometry[j], offset));
            }
        }

        newFeatures.push({
            geometry: newGeometry,
            type: type,
            tags: feature.tags,
            min: [feature.min[0] + offset, feature.min[1]],
            max: [feature.max[0] + offset, feature.max[1]]
        });
    }

    return newFeatures;
}

function shiftCoords(points, offset) {
    var newPoints = [];
    newPoints.area = points.area;
    newPoints.dist = points.dist;

    for (var i = 0; i < points.length; i++) {
        newPoints.push([points[i][0] + offset, points[i][1], points[i][2]]);
    }
    return newPoints;
}

},{"./clip":140}],146:[function(_dereq_,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.2.1
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


(function(_global) {
  "use strict";

  var shim = {};
  if (typeof(exports) === 'undefined') {
    if(typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      shim.exports = {};
      define(function() {
        return shim.exports;
      });
    } else {
      // gl-matrix lives in a browser, define its namespaces in global
      shim.exports = typeof(window) !== 'undefined' ? window : _global;
    }
  }
  else {
    // gl-matrix lives in commonjs, define its namespaces in exports
    shim.exports = exports;
  }

  (function(exports) {
    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}

if(!GLMAT_ARRAY_TYPE) {
    var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
}

if(!GLMAT_RANDOM) {
    var GLMAT_RANDOM = Math.random;
}

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

/**
 * Sets the type of array used when creating new vectors and matricies
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    GLMAT_ARRAY_TYPE = type;
}

if(typeof(exports) !== 'undefined') {
    exports.glMatrix = glMatrix;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */

var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec2 = vec2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */

var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    var z = (GLMAT_RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/*
* Rotate a 3D vector around the x-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/*
* Rotate a 3D vector around the y-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/*
* Rotate a 3D vector around the z-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec3 = vec3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */

var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
        out[3] = a[3] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = GLMAT_RANDOM();
    out[1] = GLMAT_RANDOM();
    out[2] = GLMAT_RANDOM();
    out[3] = GLMAT_RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec4 = vec4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x2 Matrix
 * @name mat2
 */

var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2 = mat2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;


/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2d = mat2d;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3x3 Matrix
 * @name mat3
 */

var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};


if(typeof(exports) !== 'undefined') {
    exports.mat3 = mat3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4x4 Matrix
 * @name mat4
 */

var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < GLMAT_EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < GLMAT_EPSILON &&
        Math.abs(eyey - centery) < GLMAT_EPSILON &&
        Math.abs(eyez - centerz) < GLMAT_EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};


if(typeof(exports) !== 'undefined') {
    exports.mat4 = mat4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class Quaternion
 * @name quat
 */

var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[7]-m[5])*fRoot;
        out[1] = (m[2]-m[6])*fRoot;
        out[2] = (m[3]-m[1])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[k*3+j] - m[j*3+k]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.quat = quat;
}
;













  })(shim.exports);
})(this);

},{}],147:[function(_dereq_,module,exports){
module.exports = parseErrors

function parseErrors(log) {
  log = String(log)

  var logs = []
  var result

  while (result = log.match(/ERROR\:([^\n]+)/)) {
    log = log.slice(result.index + 1)

    var line = result[1].trim()
    var seps = line.split(':')
    var emsg = seps.slice(2).join(':').trim()
    var file = parseInt(seps[0], 10)
    var line = parseInt(seps[1], 10)

    logs.push({
        message: emsg
      , file: file
      , line: line
    })
  }

  return logs
}

},{}],148:[function(_dereq_,module,exports){
'use strict';


var yaml = _dereq_('./lib/js-yaml.js');


module.exports = yaml;

},{"./lib/js-yaml.js":149}],149:[function(_dereq_,module,exports){
'use strict';


var loader = _dereq_('./js-yaml/loader');
var dumper = _dereq_('./js-yaml/dumper');


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = _dereq_('./js-yaml/type');
module.exports.Schema              = _dereq_('./js-yaml/schema');
module.exports.FAILSAFE_SCHEMA     = _dereq_('./js-yaml/schema/failsafe');
module.exports.JSON_SCHEMA         = _dereq_('./js-yaml/schema/json');
module.exports.CORE_SCHEMA         = _dereq_('./js-yaml/schema/core');
module.exports.DEFAULT_SAFE_SCHEMA = _dereq_('./js-yaml/schema/default_safe');
module.exports.DEFAULT_FULL_SCHEMA = _dereq_('./js-yaml/schema/default_full');
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = _dereq_('./js-yaml/exception');

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = _dereq_('./js-yaml/schema/failsafe');
module.exports.SAFE_SCHEMA    = _dereq_('./js-yaml/schema/default_safe');
module.exports.DEFAULT_SCHEMA = _dereq_('./js-yaml/schema/default_full');

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');

},{"./js-yaml/dumper":151,"./js-yaml/exception":152,"./js-yaml/loader":153,"./js-yaml/schema":155,"./js-yaml/schema/core":156,"./js-yaml/schema/default_full":157,"./js-yaml/schema/default_safe":158,"./js-yaml/schema/failsafe":159,"./js-yaml/schema/json":160,"./js-yaml/type":161}],150:[function(_dereq_,module,exports){
'use strict';


function isNothing(subject) {
  return (typeof subject === 'undefined') || (null === subject);
}


function isObject(subject) {
  return (typeof subject === 'object') && (null !== subject);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) {
    return sequence;
  } else if (isNothing(sequence)) {
    return [];
  }
  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (0 === number) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;

},{}],151:[function(_dereq_,module,exports){
'use strict';

/*eslint-disable no-use-before-define*/

var common              = _dereq_('./common');
var YAMLException       = _dereq_('./exception');
var DEFAULT_FULL_SCHEMA = _dereq_('./schema/default_full');
var DEFAULT_SAFE_SCHEMA = _dereq_('./schema/default_safe');

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (null === map) {
    return {};
  }

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if ('!!' === tag.slice(0, 2)) {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }

    type = schema.compiledTypeMap[tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema      = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent      = Math.max(1, (options['indent'] || 2));
  this.skipInvalid = options['skipInvalid'] || false;
  this.flowLevel   = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap    = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys    = options['sortKeys'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== '\n') {
      result += ind;
    }
    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

function StringBuilder(source) {
  this.source = source;
  this.result = '';
  this.checkpoint = 0;
}

StringBuilder.prototype.takeUpTo = function (position) {
  var er;

  if (position < this.checkpoint) {
    er = new Error('position should be > checkpoint');
    er.position = position;
    er.checkpoint = this.checkpoint;
    throw er;
  }

  this.result += this.source.slice(this.checkpoint, position);
  this.checkpoint = position;
  return this;
};

StringBuilder.prototype.escapeChar = function () {
  var character, esc;

  character = this.source.charCodeAt(this.checkpoint);
  esc = ESCAPE_SEQUENCES[character] || encodeHex(character);
  this.result += esc;
  this.checkpoint += 1;

  return this;
};

StringBuilder.prototype.finish = function () {
  if (this.source.length > this.checkpoint) {
    this.takeUpTo(this.source.length);
  }
};

function writeScalar(state, object, level, iskey) {
  var simple, first, spaceWrap, folded, literal, single, double,
      sawLineFeed, linePosition, longestLine, indent, max, character,
      position, escapeSeq, hexEsc, previous, lineLength, modifier,
      trailingLineBreaks, result;

  if (0 === object.length) {
    state.dump = "''";
    return;
  }

  if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
    state.dump = "'" + object + "'";
    return;
  }

  simple = true;
  first = object.length ? object.charCodeAt(0) : 0;
  spaceWrap = (CHAR_SPACE === first ||
               CHAR_SPACE === object.charCodeAt(object.length - 1));

  // Simplified check for restricted first characters
  // http://www.yaml.org/spec/1.2/spec.html#ns-plain-first%28c%29
  if (CHAR_MINUS         === first ||
      CHAR_QUESTION      === first ||
      CHAR_COMMERCIAL_AT === first ||
      CHAR_GRAVE_ACCENT  === first) {
    simple = false;
  }

  // can only use > and | if not wrapped in spaces or is not a key.
  if (spaceWrap) {
    simple = false;
    folded = false;
    literal = false;
  } else {
    folded = !iskey;
    literal = !iskey;
  }

  single = true;
  double = new StringBuilder(object);

  sawLineFeed = false;
  linePosition = 0;
  longestLine = 0;

  indent = state.indent * level;
  max = 80;
  if (indent < 40) {
    max -= indent;
  } else {
    max = 40;
  }

  for (position = 0; position < object.length; position++) {
    character = object.charCodeAt(position);
    if (simple) {
      // Characters that can never appear in the simple scalar
      if (!simpleChar(character)) {
        simple = false;
      } else {
        // Still simple.  If we make it all the way through like
        // this, then we can just dump the string as-is.
        continue;
      }
    }

    if (single && character === CHAR_SINGLE_QUOTE) {
      single = false;
    }

    escapeSeq = ESCAPE_SEQUENCES[character];
    hexEsc = needsHexEscape(character);

    if (!escapeSeq && !hexEsc) {
      continue;
    }

    if (character !== CHAR_LINE_FEED &&
        character !== CHAR_DOUBLE_QUOTE &&
        character !== CHAR_SINGLE_QUOTE) {
      folded = false;
      literal = false;
    } else if (character === CHAR_LINE_FEED) {
      sawLineFeed = true;
      single = false;
      if (position > 0) {
        previous = object.charCodeAt(position - 1);
        if (previous === CHAR_SPACE) {
          literal = false;
          folded = false;
        }
      }
      if (folded) {
        lineLength = position - linePosition;
        linePosition = position;
        if (lineLength > longestLine) {
          longestLine = lineLength;
        }
      }
    }

    if (character !== CHAR_DOUBLE_QUOTE) {
      single = false;
    }

    double.takeUpTo(position);
    double.escapeChar();
  }

  if (simple && testImplicitResolving(state, object)) {
    simple = false;
  }

  modifier = '';
  if (folded || literal) {
    trailingLineBreaks = 0;
    if (object.charCodeAt(object.length - 1) === CHAR_LINE_FEED) {
      trailingLineBreaks += 1;
      if (object.charCodeAt(object.length - 2) === CHAR_LINE_FEED) {
        trailingLineBreaks += 1;
      }
    }

    if (trailingLineBreaks === 0) {
      modifier = '-';
    } else if (trailingLineBreaks === 2) {
      modifier = '+';
    }
  }

  if (literal && longestLine < max) {
    folded = false;
  }

  // If it's literally one line, then don't bother with the literal.
  // We may still want to do a fold, though, if it's a super long line.
  if (!sawLineFeed) {
    literal = false;
  }

  if (simple) {
    state.dump = object;
  } else if (single) {
    state.dump = '\'' + object + '\'';
  } else if (folded) {
    result = fold(object, max);
    state.dump = '>' + modifier + '\n' + indentString(result, indent);
  } else if (literal) {
    if (!modifier) {
      object = object.replace(/\n$/, '');
    }
    state.dump = '|' + modifier + '\n' + indentString(object, indent);
  } else if (double) {
    double.finish();
    state.dump = '"' + double.result + '"';
  } else {
    throw new Error('Failed to dump scalar value');
  }

  return;
}

// The `trailing` var is a regexp match of any trailing `\n` characters.
//
// There are three cases we care about:
//
// 1. One trailing `\n` on the string.  Just use `|` or `>`.
//    This is the assumed default. (trailing = null)
// 2. No trailing `\n` on the string.  Use `|-` or `>-` to "chomp" the end.
// 3. More than one trailing `\n` on the string.  Use `|+` or `>+`.
//
// In the case of `>+`, these line breaks are *not* doubled (like the line
// breaks within the string), so it's important to only end with the exact
// same number as we started.
function fold(object, max) {
  var result = '',
      position = 0,
      length = object.length,
      trailing = /\n+$/.exec(object),
      newLine;

  if (trailing) {
    length = trailing.index + 1;
  }

  while (position < length) {
    newLine = object.indexOf('\n', position);
    if (newLine > length || newLine === -1) {
      if (result) {
        result += '\n\n';
      }
      result += foldLine(object.slice(position, length), max);
      position = length;
    } else {
      if (result) {
        result += '\n\n';
      }
      result += foldLine(object.slice(position, newLine), max);
      position = newLine + 1;
    }
  }
  if (trailing && trailing[0] !== '\n') {
    result += trailing[0];
  }

  return result;
}

function foldLine(line, max) {
  if (line === '') {
    return line;
  }

  var foldRe = /[^\s] [^\s]/g,
      result = '',
      prevMatch = 0,
      foldStart = 0,
      match = foldRe.exec(line),
      index,
      foldEnd,
      folded;

  while (match) {
    index = match.index;

    // when we cross the max len, if the previous match would've
    // been ok, use that one, and carry on.  If there was no previous
    // match on this fold section, then just have a long line.
    if (index - foldStart > max) {
      if (prevMatch !== foldStart) {
        foldEnd = prevMatch;
      } else {
        foldEnd = index;
      }

      if (result) {
        result += '\n';
      }
      folded = line.slice(foldStart, foldEnd);
      result += folded;
      foldStart = foldEnd + 1;
    }
    prevMatch = index + 1;
    match = foldRe.exec(line);
  }

  if (result) {
    result += '\n';
  }

  // if we end up with one last word at the end, then the last bit might
  // be slightly bigger than we wanted, because we exited out of the loop.
  if (foldStart !== prevMatch && line.length - foldStart > max) {
    result += line.slice(foldStart, prevMatch) + '\n' +
              line.slice(prevMatch + 1);
  } else {
    result += line.slice(foldStart);
  }

  return result;
}

// Returns true if character can be found in a simple scalar
function simpleChar(character) {
  return CHAR_TAB                  !== character &&
         CHAR_LINE_FEED            !== character &&
         CHAR_CARRIAGE_RETURN      !== character &&
         CHAR_COMMA                !== character &&
         CHAR_LEFT_SQUARE_BRACKET  !== character &&
         CHAR_RIGHT_SQUARE_BRACKET !== character &&
         CHAR_LEFT_CURLY_BRACKET   !== character &&
         CHAR_RIGHT_CURLY_BRACKET  !== character &&
         CHAR_SHARP                !== character &&
         CHAR_AMPERSAND            !== character &&
         CHAR_ASTERISK             !== character &&
         CHAR_EXCLAMATION          !== character &&
         CHAR_VERTICAL_LINE        !== character &&
         CHAR_GREATER_THAN         !== character &&
         CHAR_SINGLE_QUOTE         !== character &&
         CHAR_DOUBLE_QUOTE         !== character &&
         CHAR_PERCENT              !== character &&
         CHAR_COLON                !== character &&
         !ESCAPE_SEQUENCES[character]            &&
         !needsHexEscape(character);
}

// Returns true if the character code needs to be escaped.
function needsHexEscape(character) {
  return !((0x00020 <= character && character <= 0x00007E) ||
           (0x00085 === character)                         ||
           (0x000A0 <= character && character <= 0x00D7FF) ||
           (0x0E000 <= character && character <= 0x00FFFD) ||
           (0x10000 <= character && character <= 0x10FFFF));
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (0 !== index) {
        _result += ', ';
      }
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || 0 !== index) {
        _result += generateNextLine(state, level);
      }
      _result += '- ' + state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (0 !== index) {
      pairBuffer += ', ';
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) {
      pairBuffer += '? ';
    }

    pairBuffer += state.dump + ': ';

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || 0 !== index) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (null !== state.tag && '?' !== state.tag) ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || (('object' === typeof object) && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if ('[object Function]' === _toString.call(type.represent)) {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (0 > state.flowLevel || state.flowLevel > level);
  }

  var objectOrArray = '[object Object]' === type || '[object Array]' === type,
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((null !== state.tag && '?' !== state.tag) || duplicate || (2 !== state.indent && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if ('[object Object]' === type) {
      if (block && (0 !== Object.keys(state.dump).length)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object Array]' === type) {
      if (block && (0 !== state.dump.length)) {
        writeBlockSequence(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object String]' === type) {
      if ('?' !== state.tag) {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) {
        return false;
      }
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (null !== state.tag && '?' !== state.tag) {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (null !== object && 'object' === typeof object) {
    index = objects.indexOf(object);
    if (-1 !== index) {
      if (-1 === duplicatesIndexes.indexOf(index)) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) {
    return state.dump + '\n';
  }
  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;

},{"./common":150,"./exception":152,"./schema/default_full":157,"./schema/default_safe":158}],152:[function(_dereq_,module,exports){
// YAML error class. http://stackoverflow.com/questions/8458984
//
'use strict';


var inherits = _dereq_('util').inherits;


function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');
}


// Inherit from Error
inherits(YAMLException, Error);


YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;

},{"util":137}],153:[function(_dereq_,module,exports){
'use strict';

/*eslint-disable max-len,no-use-before-define*/

var common              = _dereq_('./common');
var YAMLException       = _dereq_('./exception');
var Mark                = _dereq_('./mark');
var DEFAULT_SAFE_SCHEMA = _dereq_('./schema/default_safe');
var DEFAULT_FULL_SCHEMA = _dereq_('./schema/default_full');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return 0x2C/* , */ === c ||
         0x5B/* [ */ === c ||
         0x5D/* ] */ === c ||
         0x7B/* { */ === c ||
         0x7D/* } */ === c;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(((c - 0x010000) >> 10) + 0xD800,
                             ((c - 0x010000) & 0x03FF) + 0xDC00);
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

      var match, major, minor;

      if (null !== state.version) {
        throwError(state, 'duplication of %YAML directive');
      }

      if (1 !== args.length) {
        throwError(state, 'YAML directive accepts exactly one argument');
      }

      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

      if (null === match) {
        throwError(state, 'ill-formed argument of the YAML directive');
      }

      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);

      if (1 !== major) {
        throwError(state, 'unacceptable YAML version of the document');
      }

      state.version = args[0];
      state.checkLineBreaks = (minor < 2);

      if (1 !== minor && 2 !== minor) {
        throwWarning(state, 'unsupported YAML version of the document');
      }
    },

  TAG: function handleTagDirective(state, name, args) {

      var handle, prefix;

      if (2 !== args.length) {
        throwError(state, 'TAG directive accepts exactly two arguments');
      }

      handle = args[0];
      prefix = args[1];

      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
      }

      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }

      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
      }

      state.tagMap[handle] = prefix;
    }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length;
           _position < _length;
           _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(0x09 === _character ||
              0x20 <= _character && _character <= 0x10FFFF)) {
          throwError(state, 'expected valid JSON character');
        }
      }
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
    }
  }
}

function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
  var index, quantity;

  keyNode = String(keyNode);

  if (null === _result) {
    _result = {};
  }

  if ('tag:yaml.org,2002:merge' === keyTag) {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index]);
      }
    } else {
      mergeMappings(state, _result, valueNode);
    }
  } else {
    _result[keyNode] = valueNode;
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (0x0A/* LF */ === ch) {
    state.position++;
  } else if (0x0D/* CR */ === ch) {
    state.position++;
    if (0x0A/* LF */ === state.input.charCodeAt(state.position)) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && 0x23/* # */ === ch) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && 0 !== ch);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (0x20/* Space */ === ch) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (-1 !== checkIndent && 0 !== lineBreaks && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((0x2D/* - */ === ch || 0x2E/* . */ === ch) &&
      state.input.charCodeAt(_position + 1) === ch &&
      state.input.charCodeAt(_position + 2) === ch) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (1 === count) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)             ||
      is_FLOW_INDICATOR(ch)        ||
      0x23/* # */           === ch ||
      0x26/* & */           === ch ||
      0x2A/* * */           === ch ||
      0x21/* ! */           === ch ||
      0x7C/* | */           === ch ||
      0x3E/* > */           === ch ||
      0x27/* ' */           === ch ||
      0x22/* " */           === ch ||
      0x25/* % */           === ch ||
      0x40/* @ */           === ch ||
      0x60/* ` */           === ch) {
    return false;
  }

  if (0x3F/* ? */ === ch || 0x2D/* - */ === ch) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (0 !== ch) {
    if (0x3A/* : */ === ch) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (0x23/* # */ === ch) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (0x27/* ' */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x27/* ' */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (0x27/* ' */ === ch) {
        captureStart = captureEnd = state.position;
        state.position++;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x22/* " */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x22/* " */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (0x5C/* \ */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (0 !== ch) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (0x3F/* ? */ === ch) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && 0x3A/* : */ === ch) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (0x2C/* , */ === ch) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (0 !== ch) {
    ch = state.input.charCodeAt(++state.position);

    if (0x2B/* + */ === ch || 0x2D/* - */ === ch) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (0x2B/* + */ === ch) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (0x23/* # */ === ch) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (0 !== ch));
    }
  }

  while (0 !== ch) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (0x20/* Space */ === ch)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (detectedIndent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat('\n', emptyLines + 1);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (0 === emptyLines) {
        if (detectedIndent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else if (detectedIndent) {
      // If current line isn't the first one - count line break from the last content line.
      state.result += common.repeat('\n', emptyLines + 1);
    } else {
      // In case of the first content line - count only empty lines.
      state.result += common.repeat('\n', emptyLines);
    }

    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (0 !== ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {

    if (0x2D/* - */ !== ch) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (0 !== ch)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((0x3F/* ? */ === ch || 0x3A/* : */  === ch) && is_WS_OR_EOL(following)) {

      if (0x3F/* ? */ === ch) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (0x3A/* : */ === ch) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, keyTag, keyNode, valueNode);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (0 !== ch)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x21/* ! */ !== ch) {
    return false;
  }

  if (null !== state.tag) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (0x3C/* < */ === ch) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (0x21/* ! */ === ch) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (0 !== ch && 0x3E/* > */ !== ch);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (0 !== ch && !is_WS_OR_EOL(ch)) {

      if (0x21/* ! */ === ch) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if ('!' === tagHandle) {
    state.tag = '!' + tagName;

  } else if ('!!' === tagHandle) {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x26/* & */ !== ch) {
    return false;
  }

  if (null !== state.anchor) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x2A/* * */ !== ch) {
    return false;
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (1 === indentStatus) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (1 === indentStatus) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (null !== state.tag || null !== state.anchor) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (null === state.tag) {
            state.tag = '?';
          }
        }

        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (0 === indentStatus) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (null !== state.tag && '!' !== state.tag) {
    if ('?' === state.tag) {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length;
           typeIndex < typeQuantity;
           typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (null !== state.anchor) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
      type = state.typeMap[state.tag];

      if (null !== state.result && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  return null !== state.tag || null !== state.anchor || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || 0x25/* % */ !== ch) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (0 !== ch && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (0 !== ch) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (0x23/* # */ === ch) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (0 !== ch && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) {
        break;
      }

      _position = state.position;

      while (0 !== ch && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (0 !== ch) {
      readLineBreak(state);
    }

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (0 === state.lineIndent &&
      0x2D/* - */ === state.input.charCodeAt(state.position) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 1) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 2)) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (0x2E/* . */ === state.input.charCodeAt(state.position)) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (0x0A/* LF */ !== input.charCodeAt(input.length - 1) &&
        0x0D/* CR */ !== input.charCodeAt(input.length - 1)) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  if (PATTERN_NON_PRINTABLE.test(state.input)) {
    throwError(state, 'the stream contains non-printable characters');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (0x20/* Space */ === state.input.charCodeAt(state.position)) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (0 === documents.length) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (1 === documents.length) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


function safeLoadAll(input, output, options) {
  loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;

},{"./common":150,"./exception":152,"./mark":154,"./schema/default_full":157,"./schema/default_safe":158}],154:[function(_dereq_,module,exports){
'use strict';


var common = _dereq_('./common');


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) {
    return null;
  }

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1))) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end))) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;

},{"./common":150}],155:[function(_dereq_,module,exports){
'use strict';

/*eslint-disable max-len*/

var common        = _dereq_('./common');
var YAMLException = _dereq_('./exception');
var Type          = _dereq_('./type');


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return -1 === exclude.indexOf(index);
  });
}


function compileMap(/* lists... */) {
  var result = {}, index, length;

  function collectType(type) {
    result[type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }

  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && 'scalar' !== type.loadKind) {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
  case 1:
    schemas = Schema.DEFAULT;
    types = arguments[0];
    break;

  case 2:
    schemas = arguments[0];
    types = arguments[1];
    break;

  default:
    throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;

},{"./common":150,"./exception":152,"./type":161}],156:[function(_dereq_,module,exports){
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.


'use strict';


var Schema = _dereq_('../schema');


module.exports = new Schema({
  include: [
    _dereq_('./json')
  ]
});

},{"../schema":155,"./json":160}],157:[function(_dereq_,module,exports){
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.


'use strict';


var Schema = _dereq_('../schema');


module.exports = Schema.DEFAULT = new Schema({
  include: [
    _dereq_('./default_safe')
  ],
  explicit: [
    _dereq_('../type/js/undefined'),
    _dereq_('../type/js/regexp'),
    _dereq_('../type/js/function')
  ]
});

},{"../schema":155,"../type/js/function":166,"../type/js/regexp":167,"../type/js/undefined":168,"./default_safe":158}],158:[function(_dereq_,module,exports){
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)


'use strict';


var Schema = _dereq_('../schema');


module.exports = new Schema({
  include: [
    _dereq_('./core')
  ],
  implicit: [
    _dereq_('../type/timestamp'),
    _dereq_('../type/merge')
  ],
  explicit: [
    _dereq_('../type/binary'),
    _dereq_('../type/omap'),
    _dereq_('../type/pairs'),
    _dereq_('../type/set')
  ]
});

},{"../schema":155,"../type/binary":162,"../type/merge":170,"../type/omap":172,"../type/pairs":173,"../type/set":175,"../type/timestamp":177,"./core":156}],159:[function(_dereq_,module,exports){
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346


'use strict';


var Schema = _dereq_('../schema');


module.exports = new Schema({
  explicit: [
    _dereq_('../type/str'),
    _dereq_('../type/seq'),
    _dereq_('../type/map')
  ]
});

},{"../schema":155,"../type/map":169,"../type/seq":174,"../type/str":176}],160:[function(_dereq_,module,exports){
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.


'use strict';


var Schema = _dereq_('../schema');


module.exports = new Schema({
  include: [
    _dereq_('./failsafe')
  ],
  implicit: [
    _dereq_('../type/null'),
    _dereq_('../type/bool'),
    _dereq_('../type/int'),
    _dereq_('../type/float')
  ]
});

},{"../schema":155,"../type/bool":163,"../type/float":164,"../type/int":165,"../type/null":171,"./failsafe":159}],161:[function(_dereq_,module,exports){
'use strict';

var YAMLException = _dereq_('./exception');

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (null !== map) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;

},{"./exception":152}],162:[function(_dereq_,module,exports){
'use strict';

/*eslint-disable no-bitwise*/

// A trick for browserified version.
// Since we make browserifier to ignore `buffer` module, NodeBuffer will be undefined
var NodeBuffer = _dereq_('buffer').Buffer;
var Type       = _dereq_('../type');


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (null === data) {
    return false;
  }

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) { continue; }

    // Fail on illegal characters
    if (code < 0) { return false; }

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    return new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

},{"../type":161,"buffer":129}],163:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

function resolveYamlBoolean(data) {
  if (null === data) {
    return false;
  }

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return '[object Boolean]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":161}],164:[function(_dereq_,module,exports){
'use strict';

var common = _dereq_('../common');
var Type   = _dereq_('../type');

var YAML_FLOAT_PATTERN = new RegExp(
  '^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' +
  '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' +
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  '|[-+]?\\.(?:inf|Inf|INF)' +
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (null === data) {
    return false;
  }

  if (!YAML_FLOAT_PATTERN.test(data)) {
    return false;
  }
  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = '-' === value[0] ? -1 : 1;
  digits = [];

  if (0 <= '+-'.indexOf(value[0])) {
    value = value.slice(1);
  }

  if ('.inf' === value) {
    return (1 === sign) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if ('.nan' === value) {
    return NaN;

  } else if (0 <= value.indexOf(':')) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}

function representYamlFloat(object, style) {
  if (isNaN(object)) {
    switch (style) {
    case 'lowercase':
      return '.nan';
    case 'uppercase':
      return '.NAN';
    case 'camelcase':
      return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '.inf';
    case 'uppercase':
      return '.INF';
    case 'camelcase':
      return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '-.inf';
    case 'uppercase':
      return '-.INF';
    case 'camelcase':
      return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }
  return object.toString(10);
}

function isFloat(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 !== object % 1 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

},{"../common":150,"../type":161}],165:[function(_dereq_,module,exports){
'use strict';

var common = _dereq_('../common');
var Type   = _dereq_('../type');

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (null === data) {
    return false;
  }

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) { return false; }

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) { return true; }
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (ch !== '0' && ch !== '1') {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (!isHexCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') { continue; }
      if (!isOctCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    return hasDigits;
  }

  // base 10 (except 0) or base 60

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') { continue; }
    if (ch === ':') { break; }
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  if (!hasDigits) { return false; }

  // if !base60 - done;
  if (ch !== ':') { return true; }

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') { sign = -1; }
    value = value.slice(1);
    ch = value[0];
  }

  if ('0' === value) {
    return 0;
  }

  if (ch === '0') {
    if (value[1] === 'b') {
      return sign * parseInt(value.slice(2), 2);
    }
    if (value[1] === 'x') {
      return sign * parseInt(value, 16);
    }
    return sign * parseInt(value, 8);

  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 === object % 1 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (object) { return '0b' + object.toString(2); },
    octal:       function (object) { return '0'  + object.toString(8); },
    decimal:     function (object) { return        object.toString(10); },
    hexadecimal: function (object) { return '0x' + object.toString(16).toUpperCase(); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

},{"../common":150,"../type":161}],166:[function(_dereq_,module,exports){
'use strict';

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  esprima = _dereq_('esprima');
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') { esprima = window.esprima; }
}

var Type = _dereq_('../../type');

function resolveJavascriptFunction(data) {
  if (null === data) {
    return false;
  }

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true });

    if ('Program'             !== ast.type         ||
        1                     !== ast.body.length  ||
        'ExpressionStatement' !== ast.body[0].type ||
        'FunctionExpression'  !== ast.body[0].expression.type) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if ('Program'             !== ast.type         ||
      1                     !== ast.body.length  ||
      'ExpressionStatement' !== ast.body[0].type ||
      'FunctionExpression'  !== ast.body[0].expression.type) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  /*eslint-disable no-new-func*/
  return new Function(params, source.slice(body[0] + 1, body[1] - 1));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return '[object Function]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

},{"../../type":161,"esprima":178}],167:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../../type');

function resolveJavascriptRegExp(data) {
  if (null === data) {
    return false;
  }

  if (0 === data.length) {
    return false;
  }

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }

    if (modifiers.length > 3) { return false; }
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') { return false; }

    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  try {
    return true;
  } catch (error) {
    return false;
  }
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) {
    result += 'g';
  }

  if (object.multiline) {
    result += 'm';
  }

  if (object.ignoreCase) {
    result += 'i';
  }

  return result;
}

function isRegExp(object) {
  return '[object RegExp]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

},{"../../type":161}],168:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../../type');

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return 'undefined' === typeof object;
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

},{"../../type":161}],169:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return null !== data ? data : {}; }
});

},{"../type":161}],170:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

function resolveYamlMerge(data) {
  return '<<' === data || null === data;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

},{"../type":161}],171:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

function resolveYamlNull(data) {
  if (null === data) {
    return true;
  }

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return null === object;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":161}],172:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (null === data) {
    return true;
  }

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) {
          pairHasKey = true;
        } else {
          return false;
        }
      }
    }

    if (!pairHasKey) {
      return false;
    }

    if (-1 === objectKeys.indexOf(pairKey)) {
      objectKeys.push(pairKey);
    } else {
      return false;
    }
  }

  return true;
}

function constructYamlOmap(data) {
  return null !== data ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

},{"../type":161}],173:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (null === data) {
    return true;
  }

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    keys = Object.keys(pair);

    if (1 !== keys.length) {
      return false;
    }

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (null === data) {
    return [];
  }

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

},{"../type":161}],174:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return null !== data ? data : []; }
});

},{"../type":161}],175:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (null === data) {
    return true;
  }

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (null !== object[key]) {
        return false;
      }
    }
  }

  return true;
}

function constructYamlSet(data) {
  return null !== data ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

},{"../type":161}],176:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return null !== data ? data : ''; }
});

},{"../type":161}],177:[function(_dereq_,module,exports){
'use strict';

var Type = _dereq_('../type');

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:(?:[Tt]|[ \\t]+)'              + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?)?$');         // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (null === data) {
    return false;
  }

  if (YAML_TIMESTAMP_REGEXP.exec(data) === null) {
    return false;
  }

  return true;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (null === match) {
    throw new Error('Date resolve error');
  }

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if ('-' === match[9]) {
      delta = -delta;
    }
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) {
    date.setTime(date.getTime() - delta);
  }

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

},{"../type":161}],178:[function(_dereq_,module,exports){
/*
  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.

    /* istanbul ignore next */
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PlaceHolders,
        Messages,
        Regex,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        hasLineTerminator,
        lastIndex,
        lastLineNumber,
        lastLineStart,
        startIndex,
        startLineNumber,
        startLineStart,
        scanning,
        length,
        lookahead,
        state,
        extra,
        isBindingElement,
        isAssignmentTarget,
        firstCoverInitializedNameError;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9,
        Template: 10
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.RegularExpression] = 'RegularExpression';
    TokenName[Token.Template] = 'Template';

    // A function following one of those tokens is an expression.
    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                    'return', 'case', 'delete', 'throw', 'void',
                    // assignment operators
                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                    '&=', '|=', '^=', ',',
                    // binary/unary operators
                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                    '<=', '<', '>', '!=', '!=='];

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForOfStatement: 'ForOfStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchCase: 'SwitchCase',
        SwitchStatement: 'SwitchStatement',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    PlaceHolders = {
        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnexpectedNumber: 'Unexpected number',
        UnexpectedString: 'Unexpected string',
        UnexpectedIdentifier: 'Unexpected identifier',
        UnexpectedReserved: 'Unexpected reserved word',
        UnexpectedTemplate: 'Unexpected quasi %0',
        UnexpectedEOS: 'Unexpected end of input',
        NewlineAfterThrow: 'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp: 'Invalid regular expression: missing /',
        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
        InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally: 'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith: 'Strict mode code may not include a with statement',
        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord: 'Use of future reserved word in strict mode',
        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
        DefaultRestParameter: 'Unexpected token =',
        ObjectPatternAsRestParameter: 'Unexpected token {',
        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
        ConstructorSpecialMethod: 'Class constructor may not be an accessor',
        DuplicateConstructor: 'A class may only have one constructor',
        StaticPrototype: 'Classes may not have static property named prototype',
        MissingFromClause: 'Unexpected token',
        NoAsAfterImportNamespace: 'Unexpected token',
        InvalidModuleSpecifier: 'Unexpected token',
        IllegalImportDeclaration: 'Unexpected token',
        IllegalExportDeclaration: 'Unexpected token',
        DuplicateBinding: 'Duplicate binding %0'
    };

    // See also tools/generate-unicode-regex.js.
    Regex = {
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,

        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        /* istanbul ignore if */
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 0x30 && ch <= 0x39);   // 0..9
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }

    function octalToDecimal(ch) {
        // \0 is not octal escape sequence
        var octal = (ch !== '0'), code = '01234567'.indexOf(ch);

        if (index < length && isOctalDigit(source[index])) {
            octal = true;
            code = code * 8 + '01234567'.indexOf(source[index++]);

            // 3 digits are only allowed when string starts
            // with 0, 1, 2, 3
            if ('0123'.indexOf(ch) >= 0 &&
                    index < length &&
                    isOctalDigit(source[index])) {
                code = code * 8 + '01234567'.indexOf(source[index++]);
            }
        }

        return {
            code: code,
            octal: octal
        };
    }

    // ECMA-262 11.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // ECMA-262 11.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // ECMA-262 11.6 Identifier Names and Identifiers

    function fromCodePoint(cp) {
        return (cp < 0x10000) ? String.fromCharCode(cp) :
            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
            String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
    }

    function isIdentifierStart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch)));
    }

    // ECMA-262 11.6.2.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {
        case 'enum':
        case 'export':
        case 'import':
        case 'super':
            return true;
        default:
            return false;
        }
    }

    function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // ECMA-262 11.6.2.1 Keywords

    function isKeyword(id) {
        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    // ECMA-262 11.4 Comments

    function addComment(type, value, start, end, loc) {
        var comment;

        assert(typeof start === 'number', 'Comment must have valid position');

        state.lastCommentStart = start;

        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [start, end];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
        if (extra.tokenize) {
            comment.type = comment.type + 'Comment';
            if (extra.delegate) {
                comment = extra.delegate(comment);
            }
            extra.tokens.push(comment);
        }
    }

    function skipSingleLineComment(offset) {
        var start, loc, ch, comment;

        start = index - offset;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - offset
            }
        };

        while (index < length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                hasLineTerminator = true;
                if (extra.comments) {
                    comment = source.slice(start + offset, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment('Line', comment, start, index - 1, loc);
                }
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }

        if (extra.comments) {
            comment = source.slice(start + offset, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment('Line', comment, start, index, loc);
        }
    }

    function skipMultiLineComment() {
        var start, loc, ch, comment;

        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
                    ++index;
                }
                hasLineTerminator = true;
                ++lineNumber;
                ++index;
                lineStart = index;
            } else if (ch === 0x2A) {
                // Block comment ends with '*/'.
                if (source.charCodeAt(index + 1) === 0x2F) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Block', comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            } else {
                ++index;
            }
        }

        // Ran off the end of the file - the whole thing is a comment
        if (extra.comments) {
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            comment = source.slice(start + 2, index);
            addComment('Block', comment, start, index, loc);
        }
        tolerateUnexpectedToken();
    }

    function skipComment() {
        var ch, start;
        hasLineTerminator = false;

        start = (index === 0);
        while (index < length) {
            ch = source.charCodeAt(index);

            if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                hasLineTerminator = true;
                ++index;
                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                start = true;
            } else if (ch === 0x2F) { // U+002F is '/'
                ch = source.charCodeAt(index + 1);
                if (ch === 0x2F) {
                    ++index;
                    ++index;
                    skipSingleLineComment(2);
                    start = true;
                } else if (ch === 0x2A) {  // U+002A is '*'
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } else {
                    break;
                }
            } else if (start && ch === 0x2D) { // U+002D is '-'
                // U+003E is '>'
                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
                    // '-->' is a single-line comment
                    index += 3;
                    skipSingleLineComment(3);
                } else {
                    break;
                }
            } else if (ch === 0x3C) { // U+003C is '<'
                if (source.slice(index + 1, index + 4) === '!--') {
                    ++index; // `<`
                    ++index; // `!`
                    ++index; // `-`
                    ++index; // `-`
                    skipSingleLineComment(4);
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanUnicodeCodePointEscape() {
        var ch, code;

        ch = source[index];
        code = 0;

        // At least, one hex digit is required.
        if (ch === '}') {
            throwUnexpectedToken();
        }

        while (index < length) {
            ch = source[index++];
            if (!isHexDigit(ch)) {
                break;
            }
            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
        }

        if (code > 0x10FFFF || ch !== '}') {
            throwUnexpectedToken();
        }

        return fromCodePoint(code);
    }

    function codePointAt(i) {
        var cp, first, second;

        cp = source.charCodeAt(i);
        if (cp >= 0xD800 && cp <= 0xDBFF) {
            second = source.charCodeAt(i + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) {
                first = cp;
                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            }
        }

        return cp;
    }

    function getComplexIdentifier() {
        var cp, ch, id;

        cp = codePointAt(index);
        id = fromCodePoint(cp);
        index += id.length;

        // '\u' (U+005C, U+0075) denotes an escaped character.
        if (cp === 0x5C) {
            if (source.charCodeAt(index) !== 0x75) {
                throwUnexpectedToken();
            }
            ++index;
            if (source[index] === '{') {
                ++index;
                ch = scanUnicodeCodePointEscape();
            } else {
                ch = scanHexEscape('u');
                cp = ch.charCodeAt(0);
                if (!ch || ch === '\\' || !isIdentifierStart(cp)) {
                    throwUnexpectedToken();
                }
            }
            id = ch;
        }

        while (index < length) {
            cp = codePointAt(index);
            if (!isIdentifierPart(cp)) {
                break;
            }
            ch = fromCodePoint(cp);
            id += ch;
            index += ch.length;

            // '\u' (U+005C, U+0075) denotes an escaped character.
            if (cp === 0x5C) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 0x75) {
                    throwUnexpectedToken();
                }
                ++index;
                if (source[index] === '{') {
                    ++index;
                    ch = scanUnicodeCodePointEscape();
                } else {
                    ch = scanHexEscape('u');
                    cp = ch.charCodeAt(0);
                    if (!ch || ch === '\\' || !isIdentifierPart(cp)) {
                        throwUnexpectedToken();
                    }
                }
                id += ch;
            }
        }

        return id;
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 0x5C) {
                // Blackslash (U+005C) marks Unicode escape sequence.
                index = start;
                return getComplexIdentifier();
            } else if (ch >= 0xD800 && ch < 0xDFFF) {
                // Need to handle surrogate pairs.
                index = start;
                return getComplexIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (U+005C) starts an escaped character.
        id = (source.charCodeAt(index) === 0x5C) ? getComplexIdentifier() : getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }


    // ECMA-262 11.7 Punctuators

    function scanPunctuator() {
        var token, str;

        token = {
            type: Token.Punctuator,
            value: '',
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: index,
            end: index
        };

        // Check for most common single-character punctuators.
        str = source[index];
        switch (str) {

        case '(':
            if (extra.tokenize) {
                extra.openParenToken = extra.tokenValues.length;
            }
            ++index;
            break;

        case '{':
            if (extra.tokenize) {
                extra.openCurlyToken = extra.tokenValues.length;
            }
            state.curlyStack.push('{');
            ++index;
            break;

        case '.':
            ++index;
            if (source[index] === '.' && source[index + 1] === '.') {
                // Spread operator: ...
                index += 2;
                str = '...';
            }
            break;

        case '}':
            ++index;
            state.curlyStack.pop();
            break;
        case ')':
        case ';':
        case ',':
        case '[':
        case ']':
        case ':':
        case '?':
        case '~':
            ++index;
            break;

        default:
            // 4-character punctuator.
            str = source.substr(index, 4);
            if (str === '>>>=') {
                index += 4;
            } else {

                // 3-character punctuators.
                str = str.substr(0, 3);
                if (str === '===' || str === '!==' || str === '>>>' ||
                    str === '<<=' || str === '>>=') {
                    index += 3;
                } else {

                    // 2-character punctuators.
                    str = str.substr(0, 2);
                    if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
                        str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
                        str === '++' || str === '--' || str === '<<' || str === '>>' ||
                        str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
                        str === '<=' || str === '>=' || str === '=>') {
                        index += 2;
                    } else {

                        // 1-character punctuators.
                        str = source[index];
                        if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
                            ++index;
                        }
                    }
                }
            }
        }

        if (index === token.start) {
            throwUnexpectedToken();
        }

        token.end = index;
        token.value = str;
        return token;
    }

    // ECMA-262 11.8.3 Numeric Literals

    function scanHexLiteral(start) {
        var number = '';

        while (index < length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanBinaryLiteral(start) {
        var ch, number;

        number = '';

        while (index < length) {
            ch = source[index];
            if (ch !== '0' && ch !== '1') {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            // only 0b or 0B
            throwUnexpectedToken();
        }

        if (index < length) {
            ch = source.charCodeAt(index);
            /* istanbul ignore else */
            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                throwUnexpectedToken();
            }
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 2),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanOctalLiteral(prefix, start) {
        var number, octal;

        if (isOctalDigit(prefix)) {
            octal = true;
            number = '0' + source[index++];
        } else {
            octal = false;
            ++index;
            number = '';
        }

        while (index < length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (!octal && number.length === 0) {
            // only 0o or 0O
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function isImplicitOctalLiteral() {
        var i, ch;

        // Implicit octal, unless there is a non-octal digit.
        // (Annex B.1.1 on Numeric Literals)
        for (i = index + 1; i < length; ++i) {
            ch = source[i];
            if (ch === '8' || ch === '9') {
                return false;
            }
            if (!isOctalDigit(ch)) {
                return true;
            }
        }

        return true;
    }

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            // Octal number in ES6 starts with '0o'.
            // Binary number in ES6 starts with '0b'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (ch === 'b' || ch === 'B') {
                    ++index;
                    return scanBinaryLiteral(start);
                }
                if (ch === 'o' || ch === 'O') {
                    return scanOctalLiteral(ch, start);
                }

                if (isOctalDigit(ch)) {
                    if (isImplicitOctalLiteral()) {
                        return scanOctalLiteral(ch, start);
                    }
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwUnexpectedToken();
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // ECMA-262 11.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, unescaped, octToDec, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            str += scanUnicodeCodePointEscape();
                        } else {
                            unescaped = scanHexEscape(ch);
                            if (!unescaped) {
                                throw throwUnexpectedToken();
                            }
                            str += unescaped;
                        }
                        break;
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;
                    case '8':
                    case '9':
                        str += ch;
                        tolerateUnexpectedToken();
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            octToDec = octalToDecimal(ch);

                            octal = octToDec.octal || octal;
                            str += String.fromCharCode(octToDec.code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwUnexpectedToken();
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: startLineNumber,
            lineStart: startLineStart,
            start: start,
            end: index
        };
    }

    // ECMA-262 11.8.6 Template Literal Lexical Components

    function scanTemplate() {
        var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;

        terminated = false;
        tail = false;
        start = index;
        head = (source[index] === '`');
        rawOffset = 2;

        ++index;

        while (index < length) {
            ch = source[index++];
            if (ch === '`') {
                rawOffset = 1;
                tail = true;
                terminated = true;
                break;
            } else if (ch === '$') {
                if (source[index] === '{') {
                    state.curlyStack.push('${');
                    ++index;
                    terminated = true;
                    break;
                }
                cooked += ch;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'n':
                        cooked += '\n';
                        break;
                    case 'r':
                        cooked += '\r';
                        break;
                    case 't':
                        cooked += '\t';
                        break;
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            cooked += scanUnicodeCodePointEscape();
                        } else {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                cooked += unescaped;
                            } else {
                                index = restore;
                                cooked += ch;
                            }
                        }
                        break;
                    case 'b':
                        cooked += '\b';
                        break;
                    case 'f':
                        cooked += '\f';
                        break;
                    case 'v':
                        cooked += '\v';
                        break;

                    default:
                        if (ch === '0') {
                            if (isDecimalDigit(source.charCodeAt(index))) {
                                // Illegal: \01 \02 and so on
                                throwError(Messages.TemplateOctalLiteral);
                            }
                            cooked += '\0';
                        } else if (isOctalDigit(ch)) {
                            // Illegal: \1 \2
                            throwError(Messages.TemplateOctalLiteral);
                        } else {
                            cooked += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                ++lineNumber;
                if (ch === '\r' && source[index] === '\n') {
                    ++index;
                }
                lineStart = index;
                cooked += '\n';
            } else {
                cooked += ch;
            }
        }

        if (!terminated) {
            throwUnexpectedToken();
        }

        if (!head) {
            state.curlyStack.pop();
        }

        return {
            type: Token.Template,
            value: {
                cooked: cooked,
                raw: source.slice(start + 1, index - rawOffset)
            },
            head: head,
            tail: tail,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // ECMA-262 11.8.5 Regular Expression Literals

    function testRegExp(pattern, flags) {
        // The BMP character to use as a replacement for astral symbols when
        // translating an ES6 "u"-flagged pattern to an ES5-compatible
        // approximation.
        // Note: replacing with '\uFFFF' enables false positives in unlikely
        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
        // pattern that would not be detected by this substitution.
        var astralSubstitute = '\uFFFF',
            tmp = pattern;

        if (flags.indexOf('u') >= 0) {
            tmp = tmp
                // Replace every Unicode escape sequence with the equivalent
                // BMP character or a constant ASCII code point in the case of
                // astral symbols. (See the above note on `astralSubstitute`
                // for more information.)
                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
                    var codePoint = parseInt($1 || $2, 16);
                    if (codePoint > 0x10FFFF) {
                        throwUnexpectedToken(null, Messages.InvalidRegExp);
                    }
                    if (codePoint <= 0xFFFF) {
                        return String.fromCharCode(codePoint);
                    }
                    return astralSubstitute;
                })
                // Replace each paired surrogate with a single ASCII symbol to
                // avoid throwing on regular expressions that are only valid in
                // combination with the "u" flag.
                .replace(
                    /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                    astralSubstitute
                );
        }

        // First, detect invalid regular expressions.
        try {
            RegExp(tmp);
        } catch (e) {
            throwUnexpectedToken(null, Messages.InvalidRegExp);
        }

        // Return a regular expression object for this pattern-flag pair, or
        // `null` in case the current environment doesn't support the flags it
        // uses.
        try {
            return new RegExp(pattern, flags);
        } catch (exception) {
            return null;
        }
    }

    function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;

        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        classMarker = false;
        terminated = false;
        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                throwUnexpectedToken(null, Messages.UnterminatedRegExp);
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                }
            }
        }

        if (!terminated) {
            throwUnexpectedToken(null, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        body = str.substr(1, str.length - 2);
        return {
            value: body,
            literal: str
        };
    }

    function scanRegExpFlags() {
        var ch, str, flags, restore;

        str = '';
        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for (str += '\\u'; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                    tolerateUnexpectedToken();
                } else {
                    str += '\\';
                    tolerateUnexpectedToken();
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        return {
            value: flags,
            literal: str
        };
    }

    function scanRegExp() {
        var start, body, flags, value;
        scanning = true;

        lookahead = null;
        skipComment();
        start = index;

        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);
        scanning = false;
        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                regex: {
                    pattern: body.value,
                    flags: flags.value
                },
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        return {
            literal: body.literal + flags.literal,
            value: value,
            regex: {
                pattern: body.value,
                flags: flags.value
            },
            start: start,
            end: index
        };
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = scanRegExp();

        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        /* istanbul ignore next */
        if (!extra.tokenize) {
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                regex: regex.regex,
                range: [pos, index],
                loc: loc
            });
        }

        return regex;
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    // Using the following algorithm:
    // https://github.com/mozilla/sweet.js/wiki/design

    function advanceSlash() {
        var regex, previous, check;

        function testKeyword(value) {
            return value && (value.length > 1) && (value[0] >= 'a') && (value[0] <= 'z');
        }

        previous = extra.tokenValues[extra.tokens.length - 1];
        regex = (previous !== null);

        switch (previous) {
        case 'this':
        case ']':
            regex = false;
            break;

        case ')':
            check = extra.tokenValues[extra.openParenToken - 1];
            regex = (check === 'if' || check === 'while' || check === 'for' || check === 'with');
            break;

        case '}':
            // Dividing a function by anything makes little sense,
            // but we have to check for that.
            regex = false;
            if (testKeyword(extra.tokenValues[extra.openCurlyToken - 3])) {
                // Anonymous function, e.g. function(){} /42
                check = extra.tokenValues[extra.openCurlyToken - 4];
                regex = check ? (FnExprTokens.indexOf(check) < 0) : false;
            } else if (testKeyword(extra.tokenValues[extra.openCurlyToken - 4])) {
                // Named function, e.g. function f(){} /42/
                check = extra.tokenValues[extra.openCurlyToken - 5];
                regex = check ? (FnExprTokens.indexOf(check) < 0) : true;
            }
        }

        return regex ? collectRegex() : scanPunctuator();
    }

    function advance() {
        var cp, token;

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: index,
                end: index
            };
        }

        cp = source.charCodeAt(index);

        if (isIdentifierStart(cp)) {
            token = scanIdentifier();
            if (strict && isStrictModeReservedWord(token.value)) {
                token.type = Token.Keyword;
            }
            return token;
        }

        // Very common: ( and ) and ;
        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
            return scanPunctuator();
        }

        // String literal starts with single quote (U+0027) or double quote (U+0022).
        if (cp === 0x27 || cp === 0x22) {
            return scanStringLiteral();
        }

        // Dot (.) U+002E can also start a floating-point number, hence the need
        // to check the next character.
        if (cp === 0x2E) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(cp)) {
            return scanNumericLiteral();
        }

        // Slash (/) U+002F can also start a regex.
        if (extra.tokenize && cp === 0x2F) {
            return advanceSlash();
        }

        // Template literals start with ` (U+0060) for template head
        // or } (U+007D) for template middle or template tail.
        if (cp === 0x60 || (cp === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {
            return scanTemplate();
        }

        // Possible identifier start in a surrogate pair.
        if (cp >= 0xD800 && cp < 0xDFFF) {
            cp = codePointAt(index);
            if (isIdentifierStart(cp)) {
                return scanIdentifier();
            }
        }

        return scanPunctuator();
    }

    function collectToken() {
        var loc, token, value, entry;

        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            value = source.slice(token.start, token.end);
            entry = {
                type: TokenName[token.type],
                value: value,
                range: [token.start, token.end],
                loc: loc
            };
            if (token.regex) {
                entry.regex = {
                    pattern: token.regex.pattern,
                    flags: token.regex.flags
                };
            }
            if (extra.tokenValues) {
                extra.tokenValues.push((entry.type === 'Punctuator' || entry.type === 'Keyword') ? entry.value : null);
            }
            if (extra.tokenize) {
                if (!extra.range) {
                    delete entry.range;
                }
                if (!extra.loc) {
                    delete entry.loc;
                }
                if (extra.delegate) {
                    entry = extra.delegate(entry);
                }
            }
            extra.tokens.push(entry);
        }

        return token;
    }

    function lex() {
        var token;
        scanning = true;

        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;

        skipComment();

        token = lookahead;

        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        scanning = false;
        return token;
    }

    function peek() {
        scanning = true;

        skipComment();

        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;

        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        scanning = false;
    }

    function Position() {
        this.line = startLineNumber;
        this.column = startIndex - startLineStart;
    }

    function SourceLocation() {
        this.start = new Position();
        this.end = null;
    }

    function WrappingSourceLocation(startToken) {
        this.start = {
            line: startToken.lineNumber,
            column: startToken.start - startToken.lineStart
        };
        this.end = null;
    }

    function Node() {
        if (extra.range) {
            this.range = [startIndex, 0];
        }
        if (extra.loc) {
            this.loc = new SourceLocation();
        }
    }

    function WrappingNode(startToken) {
        if (extra.range) {
            this.range = [startToken.start, 0];
        }
        if (extra.loc) {
            this.loc = new WrappingSourceLocation(startToken);
        }
    }

    WrappingNode.prototype = Node.prototype = {

        processComment: function () {
            var lastChild,
                innerComments,
                leadingComments,
                trailingComments,
                bottomRight = extra.bottomRightStack,
                i,
                comment,
                last = bottomRight[bottomRight.length - 1];

            if (this.type === Syntax.Program) {
                if (this.body.length > 0) {
                    return;
                }
            }
            /**
             * patch innnerComments for properties empty block
             * `function a() {/** comments **\/}`
             */

            if (this.type === Syntax.BlockStatement && this.body.length === 0) {
                innerComments = [];
                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
                    comment = extra.leadingComments[i];
                    if (this.range[1] >= comment.range[1]) {
                        innerComments.unshift(comment);
                        extra.leadingComments.splice(i, 1);
                        extra.trailingComments.splice(i, 1);
                    }
                }
                if (innerComments.length) {
                    this.innerComments = innerComments;
                    //bottomRight.push(this);
                    return;
                }
            }

            if (extra.trailingComments.length > 0) {
                trailingComments = [];
                for (i = extra.trailingComments.length - 1; i >= 0; --i) {
                    comment = extra.trailingComments[i];
                    if (comment.range[0] >= this.range[1]) {
                        trailingComments.unshift(comment);
                        extra.trailingComments.splice(i, 1);
                    }
                }
                extra.trailingComments = [];
            } else {
                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
                    trailingComments = last.trailingComments;
                    delete last.trailingComments;
                }
            }

            // Eating the stack.
            while (last && last.range[0] >= this.range[0]) {
                lastChild = bottomRight.pop();
                last = bottomRight[bottomRight.length - 1];
            }

            if (lastChild) {
                if (lastChild.leadingComments) {
                    leadingComments = [];
                    for (i = lastChild.leadingComments.length - 1; i >= 0; --i) {
                        comment = lastChild.leadingComments[i];
                        if (comment.range[1] <= this.range[0]) {
                            leadingComments.unshift(comment);
                            lastChild.leadingComments.splice(i, 1);
                        }
                    }

                    if (!lastChild.leadingComments.length) {
                        lastChild.leadingComments = undefined;
                    }
                }
            } else if (extra.leadingComments.length > 0) {
                leadingComments = [];
                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
                    comment = extra.leadingComments[i];
                    if (comment.range[1] <= this.range[0]) {
                        leadingComments.unshift(comment);
                        extra.leadingComments.splice(i, 1);
                    }
                }
            }


            if (leadingComments && leadingComments.length > 0) {
                this.leadingComments = leadingComments;
            }
            if (trailingComments && trailingComments.length > 0) {
                this.trailingComments = trailingComments;
            }

            bottomRight.push(this);
        },

        finish: function () {
            if (extra.range) {
                this.range[1] = lastIndex;
            }
            if (extra.loc) {
                this.loc.end = {
                    line: lastLineNumber,
                    column: lastIndex - lastLineStart
                };
                if (extra.source) {
                    this.loc.source = extra.source;
                }
            }

            if (extra.attachComment) {
                this.processComment();
            }
        },

        finishArrayExpression: function (elements) {
            this.type = Syntax.ArrayExpression;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrayPattern: function (elements) {
            this.type = Syntax.ArrayPattern;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrowFunctionExpression: function (params, defaults, body, expression) {
            this.type = Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = false;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishAssignmentExpression: function (operator, left, right) {
            this.type = Syntax.AssignmentExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishAssignmentPattern: function (left, right) {
            this.type = Syntax.AssignmentPattern;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBinaryExpression: function (operator, left, right) {
            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBlockStatement: function (body) {
            this.type = Syntax.BlockStatement;
            this.body = body;
            this.finish();
            return this;
        },

        finishBreakStatement: function (label) {
            this.type = Syntax.BreakStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishCallExpression: function (callee, args) {
            this.type = Syntax.CallExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishCatchClause: function (param, body) {
            this.type = Syntax.CatchClause;
            this.param = param;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassBody: function (body) {
            this.type = Syntax.ClassBody;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassDeclaration: function (id, superClass, body) {
            this.type = Syntax.ClassDeclaration;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassExpression: function (id, superClass, body) {
            this.type = Syntax.ClassExpression;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
            this.finish();
            return this;
        },

        finishConditionalExpression: function (test, consequent, alternate) {
            this.type = Syntax.ConditionalExpression;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishContinueStatement: function (label) {
            this.type = Syntax.ContinueStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishDebuggerStatement: function () {
            this.type = Syntax.DebuggerStatement;
            this.finish();
            return this;
        },

        finishDoWhileStatement: function (body, test) {
            this.type = Syntax.DoWhileStatement;
            this.body = body;
            this.test = test;
            this.finish();
            return this;
        },

        finishEmptyStatement: function () {
            this.type = Syntax.EmptyStatement;
            this.finish();
            return this;
        },

        finishExpressionStatement: function (expression) {
            this.type = Syntax.ExpressionStatement;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishForStatement: function (init, test, update, body) {
            this.type = Syntax.ForStatement;
            this.init = init;
            this.test = test;
            this.update = update;
            this.body = body;
            this.finish();
            return this;
        },

        finishForOfStatement: function (left, right, body) {
            this.type = Syntax.ForOfStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.finish();
            return this;
        },

        finishForInStatement: function (left, right, body) {
            this.type = Syntax.ForInStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.each = false;
            this.finish();
            return this;
        },

        finishFunctionDeclaration: function (id, params, defaults, body, generator) {
            this.type = Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.finish();
            return this;
        },

        finishFunctionExpression: function (id, params, defaults, body, generator) {
            this.type = Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.finish();
            return this;
        },

        finishIdentifier: function (name) {
            this.type = Syntax.Identifier;
            this.name = name;
            this.finish();
            return this;
        },

        finishIfStatement: function (test, consequent, alternate) {
            this.type = Syntax.IfStatement;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishLabeledStatement: function (label, body) {
            this.type = Syntax.LabeledStatement;
            this.label = label;
            this.body = body;
            this.finish();
            return this;
        },

        finishLiteral: function (token) {
            this.type = Syntax.Literal;
            this.value = token.value;
            this.raw = source.slice(token.start, token.end);
            if (token.regex) {
                this.regex = token.regex;
            }
            this.finish();
            return this;
        },

        finishMemberExpression: function (accessor, object, property) {
            this.type = Syntax.MemberExpression;
            this.computed = accessor === '[';
            this.object = object;
            this.property = property;
            this.finish();
            return this;
        },

        finishMetaProperty: function (meta, property) {
            this.type = Syntax.MetaProperty;
            this.meta = meta;
            this.property = property;
            this.finish();
            return this;
        },

        finishNewExpression: function (callee, args) {
            this.type = Syntax.NewExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishObjectExpression: function (properties) {
            this.type = Syntax.ObjectExpression;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishObjectPattern: function (properties) {
            this.type = Syntax.ObjectPattern;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishPostfixExpression: function (operator, argument) {
            this.type = Syntax.UpdateExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = false;
            this.finish();
            return this;
        },

        finishProgram: function (body, sourceType) {
            this.type = Syntax.Program;
            this.body = body;
            this.sourceType = sourceType;
            this.finish();
            return this;
        },

        finishProperty: function (kind, key, computed, value, method, shorthand) {
            this.type = Syntax.Property;
            this.key = key;
            this.computed = computed;
            this.value = value;
            this.kind = kind;
            this.method = method;
            this.shorthand = shorthand;
            this.finish();
            return this;
        },

        finishRestElement: function (argument) {
            this.type = Syntax.RestElement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishReturnStatement: function (argument) {
            this.type = Syntax.ReturnStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSequenceExpression: function (expressions) {
            this.type = Syntax.SequenceExpression;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishSpreadElement: function (argument) {
            this.type = Syntax.SpreadElement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSwitchCase: function (test, consequent) {
            this.type = Syntax.SwitchCase;
            this.test = test;
            this.consequent = consequent;
            this.finish();
            return this;
        },

        finishSuper: function () {
            this.type = Syntax.Super;
            this.finish();
            return this;
        },

        finishSwitchStatement: function (discriminant, cases) {
            this.type = Syntax.SwitchStatement;
            this.discriminant = discriminant;
            this.cases = cases;
            this.finish();
            return this;
        },

        finishTaggedTemplateExpression: function (tag, quasi) {
            this.type = Syntax.TaggedTemplateExpression;
            this.tag = tag;
            this.quasi = quasi;
            this.finish();
            return this;
        },

        finishTemplateElement: function (value, tail) {
            this.type = Syntax.TemplateElement;
            this.value = value;
            this.tail = tail;
            this.finish();
            return this;
        },

        finishTemplateLiteral: function (quasis, expressions) {
            this.type = Syntax.TemplateLiteral;
            this.quasis = quasis;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishThisExpression: function () {
            this.type = Syntax.ThisExpression;
            this.finish();
            return this;
        },

        finishThrowStatement: function (argument) {
            this.type = Syntax.ThrowStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishTryStatement: function (block, handler, finalizer) {
            this.type = Syntax.TryStatement;
            this.block = block;
            this.guardedHandlers = [];
            this.handlers = handler ? [handler] : [];
            this.handler = handler;
            this.finalizer = finalizer;
            this.finish();
            return this;
        },

        finishUnaryExpression: function (operator, argument) {
            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = true;
            this.finish();
            return this;
        },

        finishVariableDeclaration: function (declarations) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = 'var';
            this.finish();
            return this;
        },

        finishLexicalDeclaration: function (declarations, kind) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = kind;
            this.finish();
            return this;
        },

        finishVariableDeclarator: function (id, init) {
            this.type = Syntax.VariableDeclarator;
            this.id = id;
            this.init = init;
            this.finish();
            return this;
        },

        finishWhileStatement: function (test, body) {
            this.type = Syntax.WhileStatement;
            this.test = test;
            this.body = body;
            this.finish();
            return this;
        },

        finishWithStatement: function (object, body) {
            this.type = Syntax.WithStatement;
            this.object = object;
            this.body = body;
            this.finish();
            return this;
        },

        finishExportSpecifier: function (local, exported) {
            this.type = Syntax.ExportSpecifier;
            this.exported = exported || local;
            this.local = local;
            this.finish();
            return this;
        },

        finishImportDefaultSpecifier: function (local) {
            this.type = Syntax.ImportDefaultSpecifier;
            this.local = local;
            this.finish();
            return this;
        },

        finishImportNamespaceSpecifier: function (local) {
            this.type = Syntax.ImportNamespaceSpecifier;
            this.local = local;
            this.finish();
            return this;
        },

        finishExportNamedDeclaration: function (declaration, specifiers, src) {
            this.type = Syntax.ExportNamedDeclaration;
            this.declaration = declaration;
            this.specifiers = specifiers;
            this.source = src;
            this.finish();
            return this;
        },

        finishExportDefaultDeclaration: function (declaration) {
            this.type = Syntax.ExportDefaultDeclaration;
            this.declaration = declaration;
            this.finish();
            return this;
        },

        finishExportAllDeclaration: function (src) {
            this.type = Syntax.ExportAllDeclaration;
            this.source = src;
            this.finish();
            return this;
        },

        finishImportSpecifier: function (local, imported) {
            this.type = Syntax.ImportSpecifier;
            this.local = local || imported;
            this.imported = imported;
            this.finish();
            return this;
        },

        finishImportDeclaration: function (specifiers, src) {
            this.type = Syntax.ImportDeclaration;
            this.specifiers = specifiers;
            this.source = src;
            this.finish();
            return this;
        },

        finishYieldExpression: function (argument, delegate) {
            this.type = Syntax.YieldExpression;
            this.argument = argument;
            this.delegate = delegate;
            this.finish();
            return this;
        }
    };


    function recordError(error) {
        var e, existing;

        for (e = 0; e < extra.errors.length; e++) {
            existing = extra.errors[e];
            // Prevent duplicated error.
            /* istanbul ignore next */
            if (existing.index === error.index && existing.message === error.message) {
                return;
            }
        }

        extra.errors.push(error);
    }

    function constructError(msg, column) {
        var error = new Error(msg);
        try {
            throw error;
        } catch (base) {
            /* istanbul ignore else */
            if (Object.create && Object.defineProperty) {
                error = Object.create(base);
                Object.defineProperty(error, 'column', { value: column });
            }
        } finally {
            return error;
        }
    }

    function createError(line, pos, description) {
        var msg, column, error;

        msg = 'Line ' + line + ': ' + description;
        column = pos - (scanning ? lineStart : lastLineStart) + 1;
        error = constructError(msg, column);
        error.lineNumber = line;
        error.description = description;
        error.index = pos;
        return error;
    }

    // Throw an exception

    function throwError(messageFormat) {
        var args, msg;

        args = Array.prototype.slice.call(arguments, 1);
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        throw createError(lastLineNumber, lastIndex, msg);
    }

    function tolerateError(messageFormat) {
        var args, msg, error;

        args = Array.prototype.slice.call(arguments, 1);
        /* istanbul ignore next */
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        error = createError(lineNumber, lastIndex, msg);
        if (extra.errors) {
            recordError(error);
        } else {
            throw error;
        }
    }

    // Throw an exception because of the token.

    function unexpectedTokenError(token, message) {
        var value, msg = message || Messages.UnexpectedToken;

        if (token) {
            if (!message) {
                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :
                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :
                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :
                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :
                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :
                    Messages.UnexpectedToken;

                if (token.type === Token.Keyword) {
                    if (isFutureReservedWord(token.value)) {
                        msg = Messages.UnexpectedReserved;
                    } else if (strict && isStrictModeReservedWord(token.value)) {
                        msg = Messages.StrictReservedWord;
                    }
                }
            }

            value = (token.type === Token.Template) ? token.value.raw : token.value;
        } else {
            value = 'ILLEGAL';
        }

        msg = msg.replace('%0', value);

        return (token && typeof token.lineNumber === 'number') ?
            createError(token.lineNumber, token.start, msg) :
            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);
    }

    function throwUnexpectedToken(token, message) {
        throw unexpectedTokenError(token, message);
    }

    function tolerateUnexpectedToken(token, message) {
        var error = unexpectedTokenError(token, message);
        if (extra.errors) {
            recordError(error);
        } else {
            throw error;
        }
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpectedToken(token);
        }
    }

    /**
     * @name expectCommaSeparator
     * @description Quietly expect a comma when in tolerant mode, otherwise delegates
     * to <code>expect(value)</code>
     * @since 2.0
     */
    function expectCommaSeparator() {
        var token;

        if (extra.errors) {
            token = lookahead;
            if (token.type === Token.Punctuator && token.value === ',') {
                lex();
            } else if (token.type === Token.Punctuator && token.value === ';') {
                lex();
                tolerateUnexpectedToken(token);
            } else {
                tolerateUnexpectedToken(token, Messages.UnexpectedToken);
            }
        } else {
            expect(',');
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpectedToken(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    // Return true if the next token matches the specified contextual keyword
    // (where an identifier is sometimes a keyword depending on the context)

    function matchContextualKeyword(keyword) {
        return lookahead.type === Token.Identifier && lookahead.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {
            lex();
            return;
        }

        if (hasLineTerminator) {
            return;
        }

        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.
        lastIndex = startIndex;
        lastLineNumber = startLineNumber;
        lastLineStart = startLineStart;

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpectedToken(lookahead);
        }
    }

    // Cover grammar support.
    //
    // When an assignment expression position starts with an left parenthesis, the determination of the type
    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
    //
    // There are three productions that can be parsed in a parentheses pair that needs to be determined
    // after the outermost pair is closed. They are:
    //
    //   1. AssignmentExpression
    //   2. BindingElements
    //   3. AssignmentTargets
    //
    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
    // binding element or assignment target.
    //
    // The three productions have the relationship:
    //
    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
    //
    // with a single exception that CoverInitializedName when used directly in an Expression, generates
    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
    //
    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
    // the CoverInitializedName check is conducted.
    //
    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
    // pattern. The CoverInitializedName check is deferred.
    function isolateCoverGrammar(parser) {
        var oldIsBindingElement = isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = true;
        isAssignmentTarget = true;
        firstCoverInitializedNameError = null;
        result = parser();
        if (firstCoverInitializedNameError !== null) {
            throwUnexpectedToken(firstCoverInitializedNameError);
        }
        isBindingElement = oldIsBindingElement;
        isAssignmentTarget = oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;
        return result;
    }

    function inheritCoverGrammar(parser) {
        var oldIsBindingElement = isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = true;
        isAssignmentTarget = true;
        firstCoverInitializedNameError = null;
        result = parser();
        isBindingElement = isBindingElement && oldIsBindingElement;
        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;
        return result;
    }

    // ECMA-262 13.3.3 Destructuring Binding Patterns

    function parseArrayPattern(params, kind) {
        var node = new Node(), elements = [], rest, restNode;
        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                if (match('...')) {
                    restNode = new Node();
                    lex();
                    params.push(lookahead);
                    rest = parseVariableIdentifier(kind);
                    elements.push(restNode.finishRestElement(rest));
                    break;
                } else {
                    elements.push(parsePatternWithDefault(params, kind));
                }
                if (!match(']')) {
                    expect(',');
                }
            }

        }

        expect(']');

        return node.finishArrayPattern(elements);
    }

    function parsePropertyPattern(params, kind) {
        var node = new Node(), key, keyToken, computed = match('['), init;
        if (lookahead.type === Token.Identifier) {
            keyToken = lookahead;
            key = parseVariableIdentifier();
            if (match('=')) {
                params.push(keyToken);
                lex();
                init = parseAssignmentExpression();

                return node.finishProperty(
                    'init', key, false,
                    new WrappingNode(keyToken).finishAssignmentPattern(key, init), false, false);
            } else if (!match(':')) {
                params.push(keyToken);
                return node.finishProperty('init', key, false, key, false, true);
            }
        } else {
            key = parseObjectPropertyKey();
        }
        expect(':');
        init = parsePatternWithDefault(params, kind);
        return node.finishProperty('init', key, computed, init, false, false);
    }

    function parseObjectPattern(params, kind) {
        var node = new Node(), properties = [];

        expect('{');

        while (!match('}')) {
            properties.push(parsePropertyPattern(params, kind));
            if (!match('}')) {
                expect(',');
            }
        }

        lex();

        return node.finishObjectPattern(properties);
    }

    function parsePattern(params, kind) {
        if (match('[')) {
            return parseArrayPattern(params, kind);
        } else if (match('{')) {
            return parseObjectPattern(params, kind);
        } else if (matchKeyword('let')) {
            if (kind === 'const' || kind === 'let') {
                tolerateUnexpectedToken(lookahead, Messages.UnexpectedToken);
            }
        }

        params.push(lookahead);
        return parseVariableIdentifier(kind);
    }

    function parsePatternWithDefault(params, kind) {
        var startToken = lookahead, pattern, previousAllowYield, right;
        pattern = parsePattern(params, kind);
        if (match('=')) {
            lex();
            previousAllowYield = state.allowYield;
            state.allowYield = true;
            right = isolateCoverGrammar(parseAssignmentExpression);
            state.allowYield = previousAllowYield;
            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);
        }
        return pattern;
    }

    // ECMA-262 12.2.5 Array Initializer

    function parseArrayInitializer() {
        var elements = [], node = new Node(), restSpread;

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else if (match('...')) {
                restSpread = new Node();
                lex();
                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));

                if (!match(']')) {
                    isAssignmentTarget = isBindingElement = false;
                    expect(',');
                }
                elements.push(restSpread);
            } else {
                elements.push(inheritCoverGrammar(parseAssignmentExpression));

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        lex();

        return node.finishArrayExpression(elements);
    }

    // ECMA-262 12.2.6 Object Initializer

    function parsePropertyFunction(node, paramInfo, isGenerator) {
        var previousStrict, body;

        isAssignmentTarget = isBindingElement = false;

        previousStrict = strict;
        body = isolateCoverGrammar(parseFunctionSourceElements);

        if (strict && paramInfo.firstRestricted) {
            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);
        }
        if (strict && paramInfo.stricted) {
            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);
        }

        strict = previousStrict;
        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body, isGenerator);
    }

    function parsePropertyMethodFunction() {
        var params, method, node = new Node(),
            previousAllowYield = state.allowYield;

        state.allowYield = false;
        params = parseParams();
        state.allowYield = previousAllowYield;

        state.allowYield = false;
        method = parsePropertyFunction(node, params, false);
        state.allowYield = previousAllowYield;

        return method;
    }

    function parseObjectPropertyKey() {
        var token, node = new Node(), expr;

        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        switch (token.type) {
        case Token.StringLiteral:
        case Token.NumericLiteral:
            if (strict && token.octal) {
                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
            }
            return node.finishLiteral(token);
        case Token.Identifier:
        case Token.BooleanLiteral:
        case Token.NullLiteral:
        case Token.Keyword:
            return node.finishIdentifier(token.value);
        case Token.Punctuator:
            if (token.value === '[') {
                expr = isolateCoverGrammar(parseAssignmentExpression);
                expect(']');
                return expr;
            }
            break;
        }
        throwUnexpectedToken(token);
    }

    function lookaheadPropertyName() {
        switch (lookahead.type) {
        case Token.Identifier:
        case Token.StringLiteral:
        case Token.BooleanLiteral:
        case Token.NullLiteral:
        case Token.NumericLiteral:
        case Token.Keyword:
            return true;
        case Token.Punctuator:
            return lookahead.value === '[';
        }
        return false;
    }

    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,
    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.
    // This can only be determined after we consumed up to the left parentheses.
    //
    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller
    // is responsible to visit other options.
    function tryParseMethodDefinition(token, key, computed, node) {
        var value, options, methodNode, params,
            previousAllowYield = state.allowYield;

        if (token.type === Token.Identifier) {
            // check for `get` and `set`;

            if (token.value === 'get' && lookaheadPropertyName()) {
                computed = match('[');
                key = parseObjectPropertyKey();
                methodNode = new Node();
                expect('(');
                expect(')');

                state.allowYield = false;
                value = parsePropertyFunction(methodNode, {
                    params: [],
                    defaults: [],
                    stricted: null,
                    firstRestricted: null,
                    message: null
                }, false);
                state.allowYield = previousAllowYield;

                return node.finishProperty('get', key, computed, value, false, false);
            } else if (token.value === 'set' && lookaheadPropertyName()) {
                computed = match('[');
                key = parseObjectPropertyKey();
                methodNode = new Node();
                expect('(');

                options = {
                    params: [],
                    defaultCount: 0,
                    defaults: [],
                    firstRestricted: null,
                    paramSet: {}
                };
                if (match(')')) {
                    tolerateUnexpectedToken(lookahead);
                } else {
                    state.allowYield = false;
                    parseParam(options);
                    state.allowYield = previousAllowYield;
                    if (options.defaultCount === 0) {
                        options.defaults = [];
                    }
                }
                expect(')');

                state.allowYield = false;
                value = parsePropertyFunction(methodNode, options, false);
                state.allowYield = previousAllowYield;

                return node.finishProperty('set', key, computed, value, false, false);
            }
        } else if (token.type === Token.Punctuator && token.value === '*' && lookaheadPropertyName()) {
            computed = match('[');
            key = parseObjectPropertyKey();
            methodNode = new Node();

            state.allowYield = true;
            params = parseParams();
            state.allowYield = previousAllowYield;

            state.allowYield = false;
            value = parsePropertyFunction(methodNode, params, true);
            state.allowYield = previousAllowYield;

            return node.finishProperty('init', key, computed, value, true, false);
        }

        if (key && match('(')) {
            value = parsePropertyMethodFunction();
            return node.finishProperty('init', key, computed, value, true, false);
        }

        // Not a MethodDefinition.
        return null;
    }

    function parseObjectProperty(hasProto) {
        var token = lookahead, node = new Node(), computed, key, maybeMethod, proto, value;

        computed = match('[');
        if (match('*')) {
            lex();
        } else {
            key = parseObjectPropertyKey();
        }
        maybeMethod = tryParseMethodDefinition(token, key, computed, node);
        if (maybeMethod) {
            return maybeMethod;
        }

        if (!key) {
            throwUnexpectedToken(lookahead);
        }

        // Check for duplicated __proto__
        if (!computed) {
            proto = (key.type === Syntax.Identifier && key.name === '__proto__') ||
                (key.type === Syntax.Literal && key.value === '__proto__');
            if (hasProto.value && proto) {
                tolerateError(Messages.DuplicateProtoProperty);
            }
            hasProto.value |= proto;
        }

        if (match(':')) {
            lex();
            value = inheritCoverGrammar(parseAssignmentExpression);
            return node.finishProperty('init', key, computed, value, false, false);
        }

        if (token.type === Token.Identifier) {
            if (match('=')) {
                firstCoverInitializedNameError = lookahead;
                lex();
                value = isolateCoverGrammar(parseAssignmentExpression);
                return node.finishProperty('init', key, computed,
                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);
            }
            return node.finishProperty('init', key, computed, key, false, true);
        }

        throwUnexpectedToken(lookahead);
    }

    function parseObjectInitializer() {
        var properties = [], hasProto = {value: false}, node = new Node();

        expect('{');

        while (!match('}')) {
            properties.push(parseObjectProperty(hasProto));

            if (!match('}')) {
                expectCommaSeparator();
            }
        }

        expect('}');

        return node.finishObjectExpression(properties);
    }

    function reinterpretExpressionAsPattern(expr) {
        var i;
        switch (expr.type) {
        case Syntax.Identifier:
        case Syntax.MemberExpression:
        case Syntax.RestElement:
        case Syntax.AssignmentPattern:
            break;
        case Syntax.SpreadElement:
            expr.type = Syntax.RestElement;
            reinterpretExpressionAsPattern(expr.argument);
            break;
        case Syntax.ArrayExpression:
            expr.type = Syntax.ArrayPattern;
            for (i = 0; i < expr.elements.length; i++) {
                if (expr.elements[i] !== null) {
                    reinterpretExpressionAsPattern(expr.elements[i]);
                }
            }
            break;
        case Syntax.ObjectExpression:
            expr.type = Syntax.ObjectPattern;
            for (i = 0; i < expr.properties.length; i++) {
                reinterpretExpressionAsPattern(expr.properties[i].value);
            }
            break;
        case Syntax.AssignmentExpression:
            expr.type = Syntax.AssignmentPattern;
            reinterpretExpressionAsPattern(expr.left);
            break;
        default:
            // Allow other node type for tolerant parsing.
            break;
        }
    }

    // ECMA-262 12.2.9 Template Literals

    function parseTemplateElement(option) {
        var node, token;

        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {
            throwUnexpectedToken();
        }

        node = new Node();
        token = lex();

        return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);
    }

    function parseTemplateLiteral() {
        var quasi, quasis, expressions, node = new Node();

        quasi = parseTemplateElement({ head: true });
        quasis = [quasi];
        expressions = [];

        while (!quasi.tail) {
            expressions.push(parseExpression());
            quasi = parseTemplateElement({ head: false });
            quasis.push(quasi);
        }

        return node.finishTemplateLiteral(quasis, expressions);
    }

    // ECMA-262 12.2.10 The Grouping Operator

    function parseGroupExpression() {
        var expr, expressions, startToken, i, params = [];

        expect('(');

        if (match(')')) {
            lex();
            if (!match('=>')) {
                expect('=>');
            }
            return {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: [],
                rawParams: []
            };
        }

        startToken = lookahead;
        if (match('...')) {
            expr = parseRestElement(params);
            expect(')');
            if (!match('=>')) {
                expect('=>');
            }
            return {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: [expr]
            };
        }

        isBindingElement = true;
        expr = inheritCoverGrammar(parseAssignmentExpression);

        if (match(',')) {
            isAssignmentTarget = false;
            expressions = [expr];

            while (startIndex < length) {
                if (!match(',')) {
                    break;
                }
                lex();

                if (match('...')) {
                    if (!isBindingElement) {
                        throwUnexpectedToken(lookahead);
                    }
                    expressions.push(parseRestElement(params));
                    expect(')');
                    if (!match('=>')) {
                        expect('=>');
                    }
                    isBindingElement = false;
                    for (i = 0; i < expressions.length; i++) {
                        reinterpretExpressionAsPattern(expressions[i]);
                    }
                    return {
                        type: PlaceHolders.ArrowParameterPlaceHolder,
                        params: expressions
                    };
                }

                expressions.push(inheritCoverGrammar(parseAssignmentExpression));
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }


        expect(')');

        if (match('=>')) {
            if (expr.type === Syntax.Identifier && expr.name === 'yield') {
                return {
                    type: PlaceHolders.ArrowParameterPlaceHolder,
                    params: [expr]
                };
            }

            if (!isBindingElement) {
                throwUnexpectedToken(lookahead);
            }

            if (expr.type === Syntax.SequenceExpression) {
                for (i = 0; i < expr.expressions.length; i++) {
                    reinterpretExpressionAsPattern(expr.expressions[i]);
                }
            } else {
                reinterpretExpressionAsPattern(expr);
            }

            expr = {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]
            };
        }
        isBindingElement = false;
        return expr;
    }


    // ECMA-262 12.2 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr, node;

        if (match('(')) {
            isBindingElement = false;
            return inheritCoverGrammar(parseGroupExpression);
        }

        if (match('[')) {
            return inheritCoverGrammar(parseArrayInitializer);
        }

        if (match('{')) {
            return inheritCoverGrammar(parseObjectInitializer);
        }

        type = lookahead.type;
        node = new Node();

        if (type === Token.Identifier) {
            if (state.sourceType === 'module' && lookahead.value === 'await') {
                tolerateUnexpectedToken(lookahead);
            }
            expr = node.finishIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            isAssignmentTarget = isBindingElement = false;
            if (strict && lookahead.octal) {
                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
            }
            expr = node.finishLiteral(lex());
        } else if (type === Token.Keyword) {
            if (!strict && state.allowYield && matchKeyword('yield')) {
                return parseNonComputedProperty();
            }
            isAssignmentTarget = isBindingElement = false;
            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
            if (matchKeyword('this')) {
                lex();
                return node.finishThisExpression();
            }
            if (matchKeyword('class')) {
                return parseClassExpression();
            }
            if (!strict && matchKeyword('let')) {
                return node.finishIdentifier(lex().value);
            }
            throwUnexpectedToken(lex());
        } else if (type === Token.BooleanLiteral) {
            isAssignmentTarget = isBindingElement = false;
            token = lex();
            token.value = (token.value === 'true');
            expr = node.finishLiteral(token);
        } else if (type === Token.NullLiteral) {
            isAssignmentTarget = isBindingElement = false;
            token = lex();
            token.value = null;
            expr = node.finishLiteral(token);
        } else if (match('/') || match('/=')) {
            isAssignmentTarget = isBindingElement = false;
            index = startIndex;

            if (typeof extra.tokens !== 'undefined') {
                token = collectRegex();
            } else {
                token = scanRegExp();
            }
            lex();
            expr = node.finishLiteral(token);
        } else if (type === Token.Template) {
            expr = parseTemplateLiteral();
        } else {
            throwUnexpectedToken(lex());
        }

        return expr;
    }

    // ECMA-262 12.3 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [], expr;

        expect('(');

        if (!match(')')) {
            while (startIndex < length) {
                if (match('...')) {
                    expr = new Node();
                    lex();
                    expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));
                } else {
                    expr = isolateCoverGrammar(parseAssignmentExpression);
                }
                args.push(expr);
                if (match(')')) {
                    break;
                }
                expectCommaSeparator();
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token, node = new Node();

        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpectedToken(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = isolateCoverGrammar(parseExpression);

        expect(']');

        return expr;
    }

    // ECMA-262 12.3.3 The new Operator

    function parseNewExpression() {
        var callee, args, node = new Node();

        expectKeyword('new');

        if (match('.')) {
            lex();
            if (lookahead.type === Token.Identifier && lookahead.value === 'target') {
                if (state.inFunctionBody) {
                    lex();
                    return node.finishMetaProperty('new', 'target');
                }
            }
            throwUnexpectedToken(lookahead);
        }

        callee = isolateCoverGrammar(parseLeftHandSideExpression);
        args = match('(') ? parseArguments() : [];

        isAssignmentTarget = isBindingElement = false;

        return node.finishNewExpression(callee, args);
    }

    // ECMA-262 12.3.4 Function Calls

    function parseLeftHandSideExpressionAllowCall() {
        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;

        startToken = lookahead;
        state.allowIn = true;

        if (matchKeyword('super') && state.inFunctionBody) {
            expr = new Node();
            lex();
            expr = expr.finishSuper();
            if (!match('(') && !match('.') && !match('[')) {
                throwUnexpectedToken(lookahead);
            }
        } else {
            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
        }

        for (;;) {
            if (match('.')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (match('(')) {
                isBindingElement = false;
                isAssignmentTarget = false;
                args = parseArguments();
                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
            } else if (match('[')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (lookahead.type === Token.Template && lookahead.head) {
                quasi = parseTemplateLiteral();
                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
            } else {
                break;
            }
        }
        state.allowIn = previousAllowIn;

        return expr;
    }

    // ECMA-262 12.3 Left-Hand-Side Expressions

    function parseLeftHandSideExpression() {
        var quasi, expr, property, startToken;
        assert(state.allowIn, 'callee of new expression always allow in keyword.');

        startToken = lookahead;

        if (matchKeyword('super') && state.inFunctionBody) {
            expr = new Node();
            lex();
            expr = expr.finishSuper();
            if (!match('[') && !match('.')) {
                throwUnexpectedToken(lookahead);
            }
        } else {
            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
        }

        for (;;) {
            if (match('[')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (match('.')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (lookahead.type === Token.Template && lookahead.head) {
                quasi = parseTemplateLiteral();
                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
            } else {
                break;
            }
        }
        return expr;
    }

    // ECMA-262 12.4 Postfix Expressions

    function parsePostfixExpression() {
        var expr, token, startToken = lookahead;

        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);

        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {
            if (match('++') || match('--')) {
                // ECMA-262 11.3.1, 11.3.2
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    tolerateError(Messages.StrictLHSPostfix);
                }

                if (!isAssignmentTarget) {
                    tolerateError(Messages.InvalidLHSInAssignment);
                }

                isAssignmentTarget = isBindingElement = false;

                token = lex();
                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
            }
        }

        return expr;
    }

    // ECMA-262 12.5 Unary Operators

    function parseUnaryExpression() {
        var token, expr, startToken;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('++') || match('--')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            // ECMA-262 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                tolerateError(Messages.StrictLHSPrefix);
            }

            if (!isAssignmentTarget) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            isAssignmentTarget = isBindingElement = false;
        } else if (match('+') || match('-') || match('~') || match('!')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            isAssignmentTarget = isBindingElement = false;
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                tolerateError(Messages.StrictDelete);
            }
            isAssignmentTarget = isBindingElement = false;
        } else {
            expr = parsePostfixExpression();
        }

        return expr;
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '|':
            prec = 3;
            break;

        case '^':
            prec = 4;
            break;

        case '&':
            prec = 5;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = allowIn ? 7 : 0;
            break;

        case '<<':
        case '>>':
        case '>>>':
            prec = 8;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // ECMA-262 12.6 Multiplicative Operators
    // ECMA-262 12.7 Additive Operators
    // ECMA-262 12.8 Bitwise Shift Operators
    // ECMA-262 12.9 Relational Operators
    // ECMA-262 12.10 Equality Operators
    // ECMA-262 12.11 Binary Bitwise Operators
    // ECMA-262 12.12 Binary Logical Operators

    function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack, right, operator, left, i;

        marker = lookahead;
        left = inheritCoverGrammar(parseUnaryExpression);

        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
            return left;
        }
        isAssignmentTarget = isBindingElement = false;
        token.prec = prec;
        lex();

        markers = [marker, lookahead];
        right = isolateCoverGrammar(parseUnaryExpression);

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                markers.pop();
                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
                stack.push(expr);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(lookahead);
            expr = isolateCoverGrammar(parseUnaryExpression);
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }

        return expr;
    }


    // ECMA-262 12.13 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, startToken;

        startToken = lookahead;

        expr = inheritCoverGrammar(parseBinaryExpression);
        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = isolateCoverGrammar(parseAssignmentExpression);
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = isolateCoverGrammar(parseAssignmentExpression);

            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
            isAssignmentTarget = isBindingElement = false;
        }

        return expr;
    }

    // ECMA-262 14.2 Arrow Function Definitions

    function parseConciseBody() {
        if (match('{')) {
            return parseFunctionSourceElements();
        }
        return isolateCoverGrammar(parseAssignmentExpression);
    }

    function checkPatternParam(options, param) {
        var i;
        switch (param.type) {
        case Syntax.Identifier:
            validateParam(options, param, param.name);
            break;
        case Syntax.RestElement:
            checkPatternParam(options, param.argument);
            break;
        case Syntax.AssignmentPattern:
            checkPatternParam(options, param.left);
            break;
        case Syntax.ArrayPattern:
            for (i = 0; i < param.elements.length; i++) {
                if (param.elements[i] !== null) {
                    checkPatternParam(options, param.elements[i]);
                }
            }
            break;
        case Syntax.YieldExpression:
            break;
        default:
            assert(param.type === Syntax.ObjectPattern, 'Invalid type');
            for (i = 0; i < param.properties.length; i++) {
                checkPatternParam(options, param.properties[i].value);
            }
            break;
        }
    }
    function reinterpretAsCoverFormalsList(expr) {
        var i, len, param, params, defaults, defaultCount, options, token;

        defaults = [];
        defaultCount = 0;
        params = [expr];

        switch (expr.type) {
        case Syntax.Identifier:
            break;
        case PlaceHolders.ArrowParameterPlaceHolder:
            params = expr.params;
            break;
        default:
            return null;
        }

        options = {
            paramSet: {}
        };

        for (i = 0, len = params.length; i < len; i += 1) {
            param = params[i];
            switch (param.type) {
            case Syntax.AssignmentPattern:
                params[i] = param.left;
                if (param.right.type === Syntax.YieldExpression) {
                    if (param.right.argument) {
                        throwUnexpectedToken(lookahead);
                    }
                    param.right.type = Syntax.Identifier;
                    param.right.name = 'yield';
                    delete param.right.argument;
                    delete param.right.delegate;
                }
                defaults.push(param.right);
                ++defaultCount;
                checkPatternParam(options, param.left);
                break;
            default:
                checkPatternParam(options, param);
                params[i] = param;
                defaults.push(null);
                break;
            }
        }

        if (strict || !state.allowYield) {
            for (i = 0, len = params.length; i < len; i += 1) {
                param = params[i];
                if (param.type === Syntax.YieldExpression) {
                    throwUnexpectedToken(lookahead);
                }
            }
        }

        if (options.message === Messages.StrictParamDupe) {
            token = strict ? options.stricted : options.firstRestricted;
            throwUnexpectedToken(token, options.message);
        }

        if (defaultCount === 0) {
            defaults = [];
        }

        return {
            params: params,
            defaults: defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseArrowFunctionExpression(options, node) {
        var previousStrict, previousAllowYield, body;

        if (hasLineTerminator) {
            tolerateUnexpectedToken(lookahead);
        }
        expect('=>');

        previousStrict = strict;
        previousAllowYield = state.allowYield;
        state.allowYield = true;

        body = parseConciseBody();

        if (strict && options.firstRestricted) {
            throwUnexpectedToken(options.firstRestricted, options.message);
        }
        if (strict && options.stricted) {
            tolerateUnexpectedToken(options.stricted, options.message);
        }

        strict = previousStrict;
        state.allowYield = previousAllowYield;

        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
    }

    // ECMA-262 14.4 Yield expression

    function parseYieldExpression() {
        var argument, expr, delegate, previousAllowYield;

        argument = null;
        expr = new Node();

        expectKeyword('yield');

        if (!hasLineTerminator) {
            previousAllowYield = state.allowYield;
            state.allowYield = false;
            delegate = match('*');
            if (delegate) {
                lex();
                argument = parseAssignmentExpression();
            } else {
                if (!match(';') && !match('}') && !match(')') && lookahead.type !== Token.EOF) {
                    argument = parseAssignmentExpression();
                }
            }
            state.allowYield = previousAllowYield;
        }

        return expr.finishYieldExpression(argument, delegate);
    }

    // ECMA-262 12.14 Assignment Operators

    function parseAssignmentExpression() {
        var token, expr, right, list, startToken;

        startToken = lookahead;
        token = lookahead;

        if (!state.allowYield && matchKeyword('yield')) {
            return parseYieldExpression();
        }

        expr = parseConditionalExpression();

        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
            isAssignmentTarget = isBindingElement = false;
            list = reinterpretAsCoverFormalsList(expr);

            if (list) {
                firstCoverInitializedNameError = null;
                return parseArrowFunctionExpression(list, new WrappingNode(startToken));
            }

            return expr;
        }

        if (matchAssign()) {
            if (!isAssignmentTarget) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }

            // ECMA-262 12.1.1
            if (strict && expr.type === Syntax.Identifier) {
                if (isRestrictedWord(expr.name)) {
                    tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
                }
                if (isStrictModeReservedWord(expr.name)) {
                    tolerateUnexpectedToken(token, Messages.StrictReservedWord);
                }
            }

            if (!match('=')) {
                isAssignmentTarget = isBindingElement = false;
            } else {
                reinterpretExpressionAsPattern(expr);
            }

            token = lex();
            right = isolateCoverGrammar(parseAssignmentExpression);
            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
            firstCoverInitializedNameError = null;
        }

        return expr;
    }

    // ECMA-262 12.15 Comma Operator

    function parseExpression() {
        var expr, startToken = lookahead, expressions;

        expr = isolateCoverGrammar(parseAssignmentExpression);

        if (match(',')) {
            expressions = [expr];

            while (startIndex < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expressions.push(isolateCoverGrammar(parseAssignmentExpression));
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }

        return expr;
    }

    // ECMA-262 13.2 Block

    function parseStatementListItem() {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'export':
                if (state.sourceType !== 'module') {
                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);
                }
                return parseExportDeclaration();
            case 'import':
                if (state.sourceType !== 'module') {
                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);
                }
                return parseImportDeclaration();
            case 'const':
                return parseLexicalDeclaration({inFor: false});
            case 'function':
                return parseFunctionDeclaration(new Node());
            case 'class':
                return parseClassDeclaration();
            }
        }

        if (matchKeyword('let') && isLexicalDeclaration()) {
            return parseLexicalDeclaration({inFor: false});
        }

        return parseStatement();
    }

    function parseStatementList() {
        var list = [];
        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            list.push(parseStatementListItem());
        }

        return list;
    }

    function parseBlock() {
        var block, node = new Node();

        expect('{');

        block = parseStatementList();

        expect('}');

        return node.finishBlockStatement(block);
    }

    // ECMA-262 13.3.2 Variable Statement

    function parseVariableIdentifier(kind) {
        var token, node = new Node();

        token = lex();

        if (token.type === Token.Keyword && token.value === 'yield') {
            if (strict) {
                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            } if (!state.allowYield) {
                throwUnexpectedToken(token);
            }
        } else if (token.type !== Token.Identifier) {
            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {
                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            } else {
                if (strict || token.value !== 'let' || kind !== 'var') {
                    throwUnexpectedToken(token);
                }
            }
        } else if (state.sourceType === 'module' && token.type === Token.Identifier && token.value === 'await') {
            tolerateUnexpectedToken(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseVariableDeclaration(options) {
        var init = null, id, node = new Node(), params = [];

        id = parsePattern(params, 'var');

        // ECMA-262 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        if (match('=')) {
            lex();
            init = isolateCoverGrammar(parseAssignmentExpression);
        } else if (id.type !== Syntax.Identifier && !options.inFor) {
            expect('=');
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseVariableDeclarationList(options) {
        var list = [];

        do {
            list.push(parseVariableDeclaration({ inFor: options.inFor }));
            if (!match(',')) {
                break;
            }
            lex();
        } while (startIndex < length);

        return list;
    }

    function parseVariableStatement(node) {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList({ inFor: false });

        consumeSemicolon();

        return node.finishVariableDeclaration(declarations);
    }

    // ECMA-262 13.3.1 Let and Const Declarations

    function parseLexicalBinding(kind, options) {
        var init = null, id, node = new Node(), params = [];

        id = parsePattern(params, kind);

        // ECMA-262 12.2.1
        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        if (kind === 'const') {
            if (!matchKeyword('in') && !matchContextualKeyword('of')) {
                expect('=');
                init = isolateCoverGrammar(parseAssignmentExpression);
            }
        } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {
            expect('=');
            init = isolateCoverGrammar(parseAssignmentExpression);
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseBindingList(kind, options) {
        var list = [];

        do {
            list.push(parseLexicalBinding(kind, options));
            if (!match(',')) {
                break;
            }
            lex();
        } while (startIndex < length);

        return list;
    }


    function tokenizerState() {
        return {
            index: index,
            lineNumber: lineNumber,
            lineStart: lineStart,
            hasLineTerminator: hasLineTerminator,
            lastIndex: lastIndex,
            lastLineNumber: lastLineNumber,
            lastLineStart: lastLineStart,
            startIndex: startIndex,
            startLineNumber: startLineNumber,
            startLineStart: startLineStart,
            lookahead: lookahead,
            tokenCount: extra.tokens ? extra.tokens.length : 0
        };
    }

    function resetTokenizerState(ts) {
        index = ts.index;
        lineNumber = ts.lineNumber;
        lineStart = ts.lineStart;
        hasLineTerminator = ts.hasLineTerminator;
        lastIndex = ts.lastIndex;
        lastLineNumber = ts.lastLineNumber;
        lastLineStart = ts.lastLineStart;
        startIndex = ts.startIndex;
        startLineNumber = ts.startLineNumber;
        startLineStart = ts.startLineStart;
        lookahead = ts.lookahead;
        if (extra.tokens) {
            extra.tokens.splice(ts.tokenCount, extra.tokens.length);
        }
    }

    function isLexicalDeclaration() {
        var lexical, ts;

        ts = tokenizerState();

        lex();
        lexical = (lookahead.type === Token.Identifier) || match('[') || match('{') ||
            matchKeyword('let') || matchKeyword('yield');

        resetTokenizerState(ts);

        return lexical;
    }

    function parseLexicalDeclaration(options) {
        var kind, declarations, node = new Node();

        kind = lex().value;
        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');

        declarations = parseBindingList(kind, options);

        consumeSemicolon();

        return node.finishLexicalDeclaration(declarations, kind);
    }

    function parseRestElement(params) {
        var param, node = new Node();

        lex();

        if (match('{')) {
            throwError(Messages.ObjectPatternAsRestParameter);
        }

        params.push(lookahead);

        param = parseVariableIdentifier();

        if (match('=')) {
            throwError(Messages.DefaultRestParameter);
        }

        if (!match(')')) {
            throwError(Messages.ParameterAfterRestParameter);
        }

        return node.finishRestElement(param);
    }

    // ECMA-262 13.4 Empty Statement

    function parseEmptyStatement(node) {
        expect(';');
        return node.finishEmptyStatement();
    }

    // ECMA-262 12.4 Expression Statement

    function parseExpressionStatement(node) {
        var expr = parseExpression();
        consumeSemicolon();
        return node.finishExpressionStatement(expr);
    }

    // ECMA-262 13.6 If statement

    function parseIfStatement(node) {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return node.finishIfStatement(test, consequent, alternate);
    }

    // ECMA-262 13.7 Iteration Statements

    function parseDoWhileStatement(node) {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return node.finishDoWhileStatement(body, test);
    }

    function parseWhileStatement(node) {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return node.finishWhileStatement(test, body);
    }

    function parseForStatement(node) {
        var init, forIn, initSeq, initStartToken, test, update, left, right, kind, declarations,
            body, oldInIteration, previousAllowIn = state.allowIn;

        init = test = update = null;
        forIn = true;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var')) {
                init = new Node();
                lex();

                state.allowIn = false;
                declarations = parseVariableDeclarationList({ inFor: true });
                state.allowIn = previousAllowIn;

                if (declarations.length === 1 && matchKeyword('in')) {
                    init = init.finishVariableDeclaration(declarations);
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
                    init = init.finishVariableDeclaration(declarations);
                    lex();
                    left = init;
                    right = parseAssignmentExpression();
                    init = null;
                    forIn = false;
                } else {
                    init = init.finishVariableDeclaration(declarations);
                    expect(';');
                }
            } else if (matchKeyword('const') || matchKeyword('let')) {
                init = new Node();
                kind = lex().value;

                if (!strict && lookahead.value === 'in') {
                    init = init.finishIdentifier(kind);
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                } else {
                    state.allowIn = false;
                    declarations = parseBindingList(kind, {inFor: true});
                    state.allowIn = previousAllowIn;

                    if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {
                        init = init.finishLexicalDeclaration(declarations, kind);
                        lex();
                        left = init;
                        right = parseExpression();
                        init = null;
                    } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
                        init = init.finishLexicalDeclaration(declarations, kind);
                        lex();
                        left = init;
                        right = parseAssignmentExpression();
                        init = null;
                        forIn = false;
                    } else {
                        consumeSemicolon();
                        init = init.finishLexicalDeclaration(declarations, kind);
                    }
                }
            } else {
                initStartToken = lookahead;
                state.allowIn = false;
                init = inheritCoverGrammar(parseAssignmentExpression);
                state.allowIn = previousAllowIn;

                if (matchKeyword('in')) {
                    if (!isAssignmentTarget) {
                        tolerateError(Messages.InvalidLHSInForIn);
                    }

                    lex();
                    reinterpretExpressionAsPattern(init);
                    left = init;
                    right = parseExpression();
                    init = null;
                } else if (matchContextualKeyword('of')) {
                    if (!isAssignmentTarget) {
                        tolerateError(Messages.InvalidLHSInForLoop);
                    }

                    lex();
                    reinterpretExpressionAsPattern(init);
                    left = init;
                    right = parseAssignmentExpression();
                    init = null;
                    forIn = false;
                } else {
                    if (match(',')) {
                        initSeq = [init];
                        while (match(',')) {
                            lex();
                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));
                        }
                        init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);
                    }
                    expect(';');
                }
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = isolateCoverGrammar(parseStatement);

        state.inIteration = oldInIteration;

        return (typeof left === 'undefined') ?
                node.finishForStatement(init, test, update, body) :
                forIn ? node.finishForInStatement(left, right, body) :
                    node.finishForOfStatement(left, right, body);
    }

    // ECMA-262 13.8 The continue statement

    function parseContinueStatement(node) {
        var label = null, key;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(startIndex) === 0x3B) {
            lex();

            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (hasLineTerminator) {
            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError(Messages.IllegalContinue);
        }

        return node.finishContinueStatement(label);
    }

    // ECMA-262 13.9 The break statement

    function parseBreakStatement(node) {
        var label = null, key;

        expectKeyword('break');

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(lastIndex) === 0x3B) {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (hasLineTerminator) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }
        } else if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError(Messages.IllegalBreak);
        }

        return node.finishBreakStatement(label);
    }

    // ECMA-262 13.10 The return statement

    function parseReturnStatement(node) {
        var argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            tolerateError(Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(lastIndex) === 0x20) {
            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return node.finishReturnStatement(argument);
            }
        }

        if (hasLineTerminator) {
            // HACK
            return node.finishReturnStatement(null);
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return node.finishReturnStatement(argument);
    }

    // ECMA-262 13.11 The with statement

    function parseWithStatement(node) {
        var object, body;

        if (strict) {
            tolerateError(Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return node.finishWithStatement(object, body);
    }

    // ECMA-262 13.12 The switch statement

    function parseSwitchCase() {
        var test, consequent = [], statement, node = new Node();

        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (startIndex < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatementListItem();
            consequent.push(statement);
        }

        return node.finishSwitchCase(test, consequent);
    }

    function parseSwitchStatement(node) {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return node.finishSwitchStatement(discriminant, cases);
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError(Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return node.finishSwitchStatement(discriminant, cases);
    }

    // ECMA-262 13.14 The throw statement

    function parseThrowStatement(node) {
        var argument;

        expectKeyword('throw');

        if (hasLineTerminator) {
            throwError(Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return node.finishThrowStatement(argument);
    }

    // ECMA-262 13.15 The try statement

    function parseCatchClause() {
        var param, params = [], paramMap = {}, key, i, body, node = new Node();

        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpectedToken(lookahead);
        }

        param = parsePattern(params);
        for (i = 0; i < params.length; i++) {
            key = '$' + params[i].value;
            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                tolerateError(Messages.DuplicateBinding, params[i].value);
            }
            paramMap[key] = true;
        }

        // ECMA-262 12.14.1
        if (strict && isRestrictedWord(param.name)) {
            tolerateError(Messages.StrictCatchVariable);
        }

        expect(')');
        body = parseBlock();
        return node.finishCatchClause(param, body);
    }

    function parseTryStatement(node) {
        var block, handler = null, finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handler = parseCatchClause();
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (!handler && !finalizer) {
            throwError(Messages.NoCatchOrFinally);
        }

        return node.finishTryStatement(block, handler, finalizer);
    }

    // ECMA-262 13.16 The debugger statement

    function parseDebuggerStatement(node) {
        expectKeyword('debugger');

        consumeSemicolon();

        return node.finishDebuggerStatement();
    }

    // 13 Statements

    function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key,
            node;

        if (type === Token.EOF) {
            throwUnexpectedToken(lookahead);
        }

        if (type === Token.Punctuator && lookahead.value === '{') {
            return parseBlock();
        }
        isAssignmentTarget = isBindingElement = true;
        node = new Node();

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
            case ';':
                return parseEmptyStatement(node);
            case '(':
                return parseExpressionStatement(node);
            default:
                break;
            }
        } else if (type === Token.Keyword) {
            switch (lookahead.value) {
            case 'break':
                return parseBreakStatement(node);
            case 'continue':
                return parseContinueStatement(node);
            case 'debugger':
                return parseDebuggerStatement(node);
            case 'do':
                return parseDoWhileStatement(node);
            case 'for':
                return parseForStatement(node);
            case 'function':
                return parseFunctionDeclaration(node);
            case 'if':
                return parseIfStatement(node);
            case 'return':
                return parseReturnStatement(node);
            case 'switch':
                return parseSwitchStatement(node);
            case 'throw':
                return parseThrowStatement(node);
            case 'try':
                return parseTryStatement(node);
            case 'var':
                return parseVariableStatement(node);
            case 'while':
                return parseWhileStatement(node);
            case 'with':
                return parseWithStatement(node);
            default:
                break;
            }
        }

        expr = parseExpression();

        // ECMA-262 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            key = '$' + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return node.finishLabeledStatement(expr, labeledBody);
        }

        consumeSemicolon();

        return node.finishExpressionStatement(expr);
    }

    // ECMA-262 14.1 Function Definition

    function parseFunctionSourceElements() {
        var statement, body = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,
            node = new Node();

        expect('{');

        while (startIndex < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            statement = parseStatementListItem();
            body.push(statement);
            if (statement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        oldParenthesisCount = state.parenthesizedCount;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        state.parenthesizedCount = 0;

        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            body.push(parseStatementListItem());
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;
        state.parenthesizedCount = oldParenthesisCount;

        return node.finishBlockStatement(body);
    }

    function validateParam(options, param, name) {
        var key = '$' + name;
        if (strict) {
            if (isRestrictedWord(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamName;
            }
            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        } else if (!options.firstRestricted) {
            if (isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamName;
            } else if (isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictReservedWord;
            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        }
        options.paramSet[key] = true;
    }

    function parseParam(options) {
        var token, param, params = [], i, def;

        token = lookahead;
        if (token.value === '...') {
            param = parseRestElement(params);
            validateParam(options, param.argument, param.argument.name);
            options.params.push(param);
            options.defaults.push(null);
            return false;
        }

        param = parsePatternWithDefault(params);
        for (i = 0; i < params.length; i++) {
            validateParam(options, params[i], params[i].value);
        }

        if (param.type === Syntax.AssignmentPattern) {
            def = param.right;
            param = param.left;
            ++options.defaultCount;
        }

        options.params.push(param);
        options.defaults.push(def);

        return !match(')');
    }

    function parseParams(firstRestricted) {
        var options;

        options = {
            params: [],
            defaultCount: 0,
            defaults: [],
            firstRestricted: firstRestricted
        };

        expect('(');

        if (!match(')')) {
            options.paramSet = {};
            while (startIndex < length) {
                if (!parseParam(options)) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        if (options.defaultCount === 0) {
            options.defaults = [];
        }

        return {
            params: options.params,
            defaults: options.defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseFunctionDeclaration(node, identifierIsOptional) {
        var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict,
            isGenerator, previousAllowYield;

        previousAllowYield = state.allowYield;

        expectKeyword('function');

        isGenerator = match('*');
        if (isGenerator) {
            lex();
        }

        if (!identifierIsOptional || !match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        state.allowYield = !isGenerator;
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }


        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }

        strict = previousStrict;
        state.allowYield = previousAllowYield;

        return node.finishFunctionDeclaration(id, params, defaults, body, isGenerator);
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp,
            params = [], defaults = [], body, previousStrict, node = new Node(),
            isGenerator, previousAllowYield;

        previousAllowYield = state.allowYield;

        expectKeyword('function');

        isGenerator = match('*');
        if (isGenerator) {
            lex();
        }

        state.allowYield = !isGenerator;
        if (!match('(')) {
            token = lookahead;
            id = (!strict && !isGenerator && matchKeyword('yield')) ? parseNonComputedProperty() : parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;
        state.allowYield = previousAllowYield;

        return node.finishFunctionExpression(id, params, defaults, body, isGenerator);
    }

    // ECMA-262 14.5 Class Definitions

    function parseClassBody() {
        var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;

        classBody = new Node();

        expect('{');
        body = [];
        while (!match('}')) {
            if (match(';')) {
                lex();
            } else {
                method = new Node();
                token = lookahead;
                isStatic = false;
                computed = match('[');
                if (match('*')) {
                    lex();
                } else {
                    key = parseObjectPropertyKey();
                    if (key.name === 'static' && (lookaheadPropertyName() || match('*'))) {
                        token = lookahead;
                        isStatic = true;
                        computed = match('[');
                        if (match('*')) {
                            lex();
                        } else {
                            key = parseObjectPropertyKey();
                        }
                    }
                }
                method = tryParseMethodDefinition(token, key, computed, method);
                if (method) {
                    method['static'] = isStatic; // jscs:ignore requireDotNotation
                    if (method.kind === 'init') {
                        method.kind = 'method';
                    }
                    if (!isStatic) {
                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {
                            if (method.kind !== 'method' || !method.method || method.value.generator) {
                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);
                            }
                            if (hasConstructor) {
                                throwUnexpectedToken(token, Messages.DuplicateConstructor);
                            } else {
                                hasConstructor = true;
                            }
                            method.kind = 'constructor';
                        }
                    } else {
                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {
                            throwUnexpectedToken(token, Messages.StaticPrototype);
                        }
                    }
                    method.type = Syntax.MethodDefinition;
                    delete method.method;
                    delete method.shorthand;
                    body.push(method);
                } else {
                    throwUnexpectedToken(lookahead);
                }
            }
        }
        lex();
        return classBody.finishClassBody(body);
    }

    function parseClassDeclaration(identifierIsOptional) {
        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
        strict = true;

        expectKeyword('class');

        if (!identifierIsOptional || lookahead.type === Token.Identifier) {
            id = parseVariableIdentifier();
        }

        if (matchKeyword('extends')) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
        }
        classBody = parseClassBody();
        strict = previousStrict;

        return classNode.finishClassDeclaration(id, superClass, classBody);
    }

    function parseClassExpression() {
        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
        strict = true;

        expectKeyword('class');

        if (lookahead.type === Token.Identifier) {
            id = parseVariableIdentifier();
        }

        if (matchKeyword('extends')) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
        }
        classBody = parseClassBody();
        strict = previousStrict;

        return classNode.finishClassExpression(id, superClass, classBody);
    }

    // ECMA-262 15.2 Modules

    function parseModuleSpecifier() {
        var node = new Node();

        if (lookahead.type !== Token.StringLiteral) {
            throwError(Messages.InvalidModuleSpecifier);
        }
        return node.finishLiteral(lex());
    }

    // ECMA-262 15.2.3 Exports

    function parseExportSpecifier() {
        var exported, local, node = new Node(), def;
        if (matchKeyword('default')) {
            // export {default} from 'something';
            def = new Node();
            lex();
            local = def.finishIdentifier('default');
        } else {
            local = parseVariableIdentifier();
        }
        if (matchContextualKeyword('as')) {
            lex();
            exported = parseNonComputedProperty();
        }
        return node.finishExportSpecifier(local, exported);
    }

    function parseExportNamedDeclaration(node) {
        var declaration = null,
            isExportFromIdentifier,
            src = null, specifiers = [];

        // non-default export
        if (lookahead.type === Token.Keyword) {
            // covers:
            // export var f = 1;
            switch (lookahead.value) {
                case 'let':
                case 'const':
                    declaration = parseLexicalDeclaration({inFor: false});
                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
                case 'var':
                case 'class':
                case 'function':
                    declaration = parseStatementListItem();
                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
            }
        }

        expect('{');
        while (!match('}')) {
            isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');
            specifiers.push(parseExportSpecifier());
            if (!match('}')) {
                expect(',');
                if (match('}')) {
                    break;
                }
            }
        }
        expect('}');

        if (matchContextualKeyword('from')) {
            // covering:
            // export {default} from 'foo';
            // export {foo} from 'foo';
            lex();
            src = parseModuleSpecifier();
            consumeSemicolon();
        } else if (isExportFromIdentifier) {
            // covering:
            // export {default}; // missing fromClause
            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        } else {
            // cover
            // export {foo};
            consumeSemicolon();
        }
        return node.finishExportNamedDeclaration(declaration, specifiers, src);
    }

    function parseExportDefaultDeclaration(node) {
        var declaration = null,
            expression = null;

        // covers:
        // export default ...
        expectKeyword('default');

        if (matchKeyword('function')) {
            // covers:
            // export default function foo () {}
            // export default function () {}
            declaration = parseFunctionDeclaration(new Node(), true);
            return node.finishExportDefaultDeclaration(declaration);
        }
        if (matchKeyword('class')) {
            declaration = parseClassDeclaration(true);
            return node.finishExportDefaultDeclaration(declaration);
        }

        if (matchContextualKeyword('from')) {
            throwError(Messages.UnexpectedToken, lookahead.value);
        }

        // covers:
        // export default {};
        // export default [];
        // export default (1 + 2);
        if (match('{')) {
            expression = parseObjectInitializer();
        } else if (match('[')) {
            expression = parseArrayInitializer();
        } else {
            expression = parseAssignmentExpression();
        }
        consumeSemicolon();
        return node.finishExportDefaultDeclaration(expression);
    }

    function parseExportAllDeclaration(node) {
        var src;

        // covers:
        // export * from 'foo';
        expect('*');
        if (!matchContextualKeyword('from')) {
            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        }
        lex();
        src = parseModuleSpecifier();
        consumeSemicolon();

        return node.finishExportAllDeclaration(src);
    }

    function parseExportDeclaration() {
        var node = new Node();
        if (state.inFunctionBody) {
            throwError(Messages.IllegalExportDeclaration);
        }

        expectKeyword('export');

        if (matchKeyword('default')) {
            return parseExportDefaultDeclaration(node);
        }
        if (match('*')) {
            return parseExportAllDeclaration(node);
        }
        return parseExportNamedDeclaration(node);
    }

    // ECMA-262 15.2.2 Imports

    function parseImportSpecifier() {
        // import {<foo as bar>} ...;
        var local, imported, node = new Node();

        imported = parseNonComputedProperty();
        if (matchContextualKeyword('as')) {
            lex();
            local = parseVariableIdentifier();
        }

        return node.finishImportSpecifier(local, imported);
    }

    function parseNamedImports() {
        var specifiers = [];
        // {foo, bar as bas}
        expect('{');
        while (!match('}')) {
            specifiers.push(parseImportSpecifier());
            if (!match('}')) {
                expect(',');
                if (match('}')) {
                    break;
                }
            }
        }
        expect('}');
        return specifiers;
    }

    function parseImportDefaultSpecifier() {
        // import <foo> ...;
        var local, node = new Node();

        local = parseNonComputedProperty();

        return node.finishImportDefaultSpecifier(local);
    }

    function parseImportNamespaceSpecifier() {
        // import <* as foo> ...;
        var local, node = new Node();

        expect('*');
        if (!matchContextualKeyword('as')) {
            throwError(Messages.NoAsAfterImportNamespace);
        }
        lex();
        local = parseNonComputedProperty();

        return node.finishImportNamespaceSpecifier(local);
    }

    function parseImportDeclaration() {
        var specifiers = [], src, node = new Node();

        if (state.inFunctionBody) {
            throwError(Messages.IllegalImportDeclaration);
        }

        expectKeyword('import');

        if (lookahead.type === Token.StringLiteral) {
            // import 'foo';
            src = parseModuleSpecifier();
        } else {

            if (match('{')) {
                // import {bar}
                specifiers = specifiers.concat(parseNamedImports());
            } else if (match('*')) {
                // import * as foo
                specifiers.push(parseImportNamespaceSpecifier());
            } else if (isIdentifierName(lookahead) && !matchKeyword('default')) {
                // import foo
                specifiers.push(parseImportDefaultSpecifier());
                if (match(',')) {
                    lex();
                    if (match('*')) {
                        // import foo, * as foo
                        specifiers.push(parseImportNamespaceSpecifier());
                    } else if (match('{')) {
                        // import foo, {bar}
                        specifiers = specifiers.concat(parseNamedImports());
                    } else {
                        throwUnexpectedToken(lookahead);
                    }
                }
            } else {
                throwUnexpectedToken(lex());
            }

            if (!matchContextualKeyword('from')) {
                throwError(lookahead.value ?
                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
            }
            lex();
            src = parseModuleSpecifier();
        }

        consumeSemicolon();
        return node.finishImportDeclaration(specifiers, src);
    }

    // ECMA-262 15.1 Scripts

    function parseScriptBody() {
        var statement, body = [], token, directive, firstRestricted;

        while (startIndex < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            statement = parseStatementListItem();
            body.push(statement);
            if (statement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (startIndex < length) {
            statement = parseStatementListItem();
            /* istanbul ignore if */
            if (typeof statement === 'undefined') {
                break;
            }
            body.push(statement);
        }
        return body;
    }

    function parseProgram() {
        var body, node;

        peek();
        node = new Node();

        body = parseScriptBody();
        return node.finishProgram(body, state.sourceType);
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (entry.regex) {
                token.regex = {
                    pattern: entry.regex.pattern,
                    flags: entry.regex.flags
                };
            }
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function tokenize(code, options, delegate) {
        var toString,
            tokens;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            allowYield: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1,
            curlyStack: []
        };

        extra = {};

        // Options matching.
        options = options || {};

        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenValues = [];
        extra.tokenize = true;
        extra.delegate = delegate;

        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;

        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;

        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }

        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }

            lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    lex();
                } catch (lexError) {
                    if (extra.errors) {
                        recordError(lexError);
                        // We have to break on the first error
                        // to avoid infinite loops.
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }

            tokens = extra.tokens;
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }
        return tokens;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            allowYield: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1,
            curlyStack: [],
            sourceType: 'script'
        };
        strict = false;

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                extra.source = toString(options.source);
            }

            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
            if (options.sourceType === 'module') {
                // very restrictive condition for now
                state.sourceType = options.sourceType;
                strict = true;
            }
        }

        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }

        return program;
    }

    // Sync with *.json manifests.
    exports.version = '2.7.0';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
    /* istanbul ignore next */
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],179:[function(_dereq_,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    if (typeof module === 'object' && module.exports && typeof _dereq_ === 'function') {
        module.exports = definition();
    } else if (typeof define === 'function' && typeof define.amd === 'object') {
        define(definition);
    } else {
        root.log = definition();
    }
}(this, function () {
    var self = {};
    var noop = function() {};
    var undefinedType = "undefined";

    function realMethod(methodName) {
        if (typeof console === undefinedType) {
            return false; // We can't build a real method without a console to log to
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    function enableLoggingWhenConsoleArrives(methodName, level) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods(level);
                self[methodName].apply(self, arguments);
            }
        };
    }

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    function replaceLoggingMethods(level) {
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            self[methodName] = (i < level) ? noop : self.methodFactory(methodName, level);
        }
    }

    function persistLevelIfPossible(levelNum) {
        var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

        // Use localStorage if available
        try {
            window.localStorage['loglevel'] = levelName;
            return;
        } catch (ignore) {}

        // Use session cookie as fallback
        try {
            window.document.cookie = "loglevel=" + levelName + ";";
        } catch (ignore) {}
    }

    function loadPersistedLevel() {
        var storedLevel;

        try {
            storedLevel = window.localStorage['loglevel'];
        } catch (ignore) {}

        if (typeof storedLevel === undefinedType) {
            try {
                storedLevel = /loglevel=([^;]+)/.exec(window.document.cookie)[1];
            } catch (ignore) {}
        }
        
        if (self.levels[storedLevel] === undefined) {
            storedLevel = "WARN";
        }

        self.setLevel(self.levels[storedLevel]);
    }

    /*
     *
     * Public API
     *
     */

    self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
        "ERROR": 4, "SILENT": 5};

    self.methodFactory = function (methodName, level) {
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives(methodName, level);
    };

    self.setLevel = function (level) {
        if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
            level = self.levels[level.toUpperCase()];
        }
        if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
            persistLevelIfPossible(level);
            replaceLoggingMethods(level);
            if (typeof console === undefinedType && level < self.levels.SILENT) {
                return "No console available for logging";
            }
        } else {
            throw "log.setLevel() called with invalid level: " + level;
        }
    };

    self.enableAll = function() {
        self.setLevel(self.levels.TRACE);
    };

    self.disableAll = function() {
        self.setLevel(self.levels.SILENT);
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    self.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === self) {
            window.log = _log;
        }

        return self;
    };

    loadPersistedLevel();
    return self;
}));

},{}],180:[function(_dereq_,module,exports){
'use strict';

var whiteList = ['not', 'any', 'all', 'none'];


function notNull(x)  { return x != null; }
function toString(x) { return x.toString(); }
function wrap(x)     { return '(' + x + ')';}

function maybeQuote(value) {
    if (typeof value === 'string') {
        return '"' + value + '"';
    }
    return value;
}

function lookUp(key) {
    if (key.lastIndexOf('$') === 0) {
        return 'context.' + key.substring(1);
    }
    return 'context.feature.properties.' + key;
}

function nullValue(key, value) {
    return {
        type: 'nullValue',
        key: key,
        toString: function () {
            return ' true ';
        }
    };
}

function propertyEqual(key, value) {
    return {
        type: 'propertyEqual',
        opt: '===' ,
        key: key,
        value: value,
        toString: function () {
            return wrap(maybeQuote(this.value) + ' ' + this.opt + ' ' + lookUp(key));
        }
    };
}

function propertyOr(key, values) {
    return {
        type: 'propertyOr',
        key: key,
        values: values.map(function (x) { return propertyEqual(key, x); }),
        toString: function () {
            return wrap(this.values.map(toString).join(' || '));
        }
    };
}

function not(key, value) {
    return {
        type: 'notProperty',
        key: key,
        value: parseFilter(value),
        toString: function () {
            return '!' + wrap(this.value.toString());
        }
    };
}

function none(key, values) {
    return {
        type: 'none',
        values: any(null, values),
        toString: function () {
            return '!' + wrap(this.values.toString());
        }
    };
}

function printNested(values, joiner) {
    return wrap(values.filter(notNull).map(function (x) {
        return wrap(x.join(' && '));
    }).join(' ' + joiner + ' '));
}

function any(_, values) {
    return {
        type: 'any',
        values: values.map(parseFilter),
        toString: function () {
            return printNested(this.values, '||');
        }
    };
}

function all(_, values) {
    return {
        type: 'all',
        values: values.filter(notNull).map(parseFilter),
        toString: function () {
            return printNested(this.values, '&&');
        }
    };
}

function propertyMatchesBoolean(key, value) {
    return {
        type: 'propertyMatchesBoolean',
        key: key,
        value: value,
        toString: function () {
            return wrap(lookUp(this.key) + (this.value ? ' != ' : ' == ')  + 'null');
        }
    };
}

function rangeMatch(key, values) {
    return {
        type: 'rangeMatch',
        key: key,
        values: values,
        toString: function () {
            var expressions = [];

            if (this.values.max) {
                expressions.push('' + lookUp(key) + ' < ' + this.values.max);
            }

            if (this.values.min) {
                expressions.push('' + lookUp(key) + ' >= ' + this.values.min);
            }

            return wrap(expressions.join(' && '));
        }
    };
}

function parseFilter(filter) {
    var filterAST = [];

    // Function filter
    if (typeof filter === 'function') {
        filterAST.push(wrap(filter.toString() + '(context)'));
        return filterAST;
    }
    // Array filter, implicit 'any'
    else if (Array.isArray(filter)) {
        filterAST.push(any(null, filter));
        return filterAST;
    }

    // Object filter, e.g. implicit 'all'
    var keys = Object.keys(filter);
    keys.forEach(function (key, idx) {

        var value = filter[key],
            type  = typeof value;
        if (type === 'string' || type === 'number') {
            filterAST.push(propertyEqual(key, value));
        } else if (type === 'boolean') {
            filterAST.push(propertyMatchesBoolean(key, value));
        } else if (value == null) {
            filterAST.push(nullValue(key, value));
        } else if (whiteList.indexOf(key) >= 0) {
            switch (key) {
            case 'not':
                filterAST.push(not(key, value));
                break;
            case 'any':
                filterAST.push(any(key, value));
                break;
            case 'all':
                filterAST.push(all(key, value));
                break;
            case 'none':
                filterAST.push(none(key, value));
                break;
            default:
                throw new Error('Unhandled WhiteListed property: ' + key);
            }
        } else if (Array.isArray(value)) {
            filterAST.push(propertyOr(key, value));
        } else if (type === 'object' && value != null) {
            if (value.max || value.min) {
                filterAST.push(rangeMatch(key, value));
            }
        } else {
            throw new Error('Unknown Query sytnax: ' + value);
        }
    });

    return keys.length === 0 ? ['true'] : filterAST;
}

function filterToString(filterAST) {
    return wrap(filterAST.join(' && '));
}

function match(filter) {
    if (filter == null) { return function () { return true; }; }
    // jshint evil: true
    return new Function('context', 'return ' + filterToString(parseFilter(filter)) + ';');
}

module.exports = {
    match: match,
    filterToString: filterToString,
    parseFilter: parseFilter
};

},{}],181:[function(_dereq_,module,exports){
'use strict';

// lightweight Buffer shim for pbf browser build
// based on code from github.com/feross/buffer (MIT-licensed)

module.exports = Buffer;

var ieee754 = _dereq_('ieee754');

var BufferMethods;

function Buffer(length) {
    var arr;
    if (length && length.length) {
        arr = length;
        length = arr.length;
    }
    var buf = new Uint8Array(length || 0);
    if (arr) buf.set(arr);

    buf.readUInt32LE = BufferMethods.readUInt32LE;
    buf.writeUInt32LE = BufferMethods.writeUInt32LE;
    buf.readInt32LE = BufferMethods.readInt32LE;
    buf.writeInt32LE = BufferMethods.writeInt32LE;
    buf.readFloatLE = BufferMethods.readFloatLE;
    buf.writeFloatLE = BufferMethods.writeFloatLE;
    buf.readDoubleLE = BufferMethods.readDoubleLE;
    buf.writeDoubleLE = BufferMethods.writeDoubleLE;
    buf.toString = BufferMethods.toString;
    buf.write = BufferMethods.write;
    buf.slice = BufferMethods.slice;
    buf.copy = BufferMethods.copy;

    buf._isBuffer = true;
    return buf;
}

var lastStr, lastStrEncoded;

BufferMethods = {
    readUInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] * 0x1000000);
    },

    writeUInt32LE: function(val, pos) {
        this[pos] = val;
        this[pos + 1] = (val >>> 8);
        this[pos + 2] = (val >>> 16);
        this[pos + 3] = (val >>> 24);
    },

    readInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] << 24);
    },

    readFloatLE:  function(pos) { return ieee754.read(this, pos, true, 23, 4); },
    readDoubleLE: function(pos) { return ieee754.read(this, pos, true, 52, 8); },

    writeFloatLE:  function(val, pos) { return ieee754.write(this, val, pos, true, 23, 4); },
    writeDoubleLE: function(val, pos) { return ieee754.write(this, val, pos, true, 52, 8); },

    toString: function(encoding, start, end) {
        var str = '',
            tmp = '';

        start = start || 0;
        end = Math.min(this.length, end || this.length);

        for (var i = start; i < end; i++) {
            var ch = this[i];
            if (ch <= 0x7F) {
                str += decodeURIComponent(tmp) + String.fromCharCode(ch);
                tmp = '';
            } else {
                tmp += '%' + ch.toString(16);
            }
        }

        str += decodeURIComponent(tmp);

        return str;
    },

    write: function(str, pos) {
        var bytes = str === lastStr ? lastStrEncoded : encodeString(str);
        for (var i = 0; i < bytes.length; i++) {
            this[pos + i] = bytes[i];
        }
    },

    slice: function(start, end) {
        return this.subarray(start, end);
    },

    copy: function(buf, pos) {
        pos = pos || 0;
        for (var i = 0; i < this.length; i++) {
            buf[pos + i] = this[i];
        }
    }
};

BufferMethods.writeInt32LE = BufferMethods.writeUInt32LE;

Buffer.byteLength = function(str) {
    lastStr = str;
    lastStrEncoded = encodeString(str);
    return lastStrEncoded.length;
};

Buffer.isBuffer = function(buf) {
    return !!(buf && buf._isBuffer);
};

function encodeString(str) {
    var length = str.length,
        bytes = [];

    for (var i = 0, c, lead; i < length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {

            if (lead) {
                if (c < 0xDC00) {
                    bytes.push(0xEF, 0xBF, 0xBD);
                    lead = c;
                    continue;

                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }

            } else {
                if (c > 0xDBFF || (i + 1 === length)) bytes.push(0xEF, 0xBF, 0xBD);
                else lead = c;

                continue;
            }

        } else if (lead) {
            bytes.push(0xEF, 0xBF, 0xBD);
            lead = null;
        }

        if (c < 0x80) bytes.push(c);
        else if (c < 0x800) bytes.push(c >> 0x6 | 0xC0, c & 0x3F | 0x80);
        else if (c < 0x10000) bytes.push(c >> 0xC | 0xE0, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
        else bytes.push(c >> 0x12 | 0xF0, c >> 0xC & 0x3F | 0x80, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
    }
    return bytes;
}

},{"ieee754":183}],182:[function(_dereq_,module,exports){
(function (global){
'use strict';

module.exports = Pbf;

var Buffer = global.Buffer || _dereq_('./buffer');

function Pbf(buf) {
    this.buf = !Buffer.isBuffer(buf) ? new Buffer(buf || 0) : buf;
    this.pos = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32,
    POW_2_63 = Math.pow(2, 63);

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = this.buf.readUInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = this.buf.readInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readUInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = this.buf.readFloatLE(this.pos);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = this.buf.readDoubleLE(this.pos);
        this.pos += 8;
        return val;
    },

    readVarint: function() {
        var buf = this.buf,
            val, b, b0, b1, b2, b3;

        b0 = buf[this.pos++]; if (b0 < 0x80) return b0;                 b0 = b0 & 0x7f;
        b1 = buf[this.pos++]; if (b1 < 0x80) return b0 | b1 << 7;       b1 = (b1 & 0x7f) << 7;
        b2 = buf[this.pos++]; if (b2 < 0x80) return b0 | b1 | b2 << 14; b2 = (b2 & 0x7f) << 14;
        b3 = buf[this.pos++]; if (b3 < 0x80) return b0 | b1 | b2 | b3 << 21;

        val = b0 | b1 | b2 | (b3 & 0x7f) << 21;

        b = buf[this.pos++]; val += (b & 0x7f) * 0x10000000;         if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x800000000;        if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x40000000000;      if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x2000000000000;    if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x100000000000000;  if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x8000000000000000; if (b < 0x80) return val;

        throw new Error('Expected varint not more than 10 bytes');
    },

    readVarint64: function() {
        var startPos = this.pos,
            val = this.readVarint();

        if (val < POW_2_63) return val;

        var pos = this.pos - 2;
        while (this.buf[pos] === 0xff) pos--;
        if (pos < startPos) pos = startPos;

        val = 0;
        for (var i = 0; i < pos - startPos + 1; i++) {
            var b = ~this.buf[startPos + i] & 0x7f;
            val += i < 4 ? b << i * 7 : b * Math.pow(2, i * 7);
        }

        return -val - 1;
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos,
            str = this.buf.toString('utf8', this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.slice(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readVarint());
        return arr;
    },
    readPackedSVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            var buf = new Buffer(length);
            this.buf.copy(buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.slice(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        this.buf.writeUInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        this.buf.writeInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val;

        if (val <= 0x7f) {
            this.realloc(1);
            this.buf[this.pos++] = val;

        } else if (val <= 0x3fff) {
            this.realloc(2);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f);

        } else if (val <= 0x1fffff) {
            this.realloc(3);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 14) & 0x7f);

        } else if (val <= 0xfffffff) {
            this.realloc(4);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 14) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 21) & 0x7f);

        } else {
            var pos = this.pos;
            while (val >= 0x80) {
                this.realloc(1);
                this.buf[this.pos++] = (val & 0xff) | 0x80;
                val /= 0x80;
            }
            this.realloc(1);
            this.buf[this.pos++] = val | 0;
            if (this.pos - pos > 10) throw new Error('Given varint doesn\'t fit into 10 bytes');
        }
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        var bytes = Buffer.byteLength(str);
        this.writeVarint(bytes);
        this.realloc(bytes);
        this.buf.write(str, this.pos);
        this.pos += bytes;
    },

    writeFloat: function(val) {
        this.realloc(4);
        this.buf.writeFloatLE(val, this.pos);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        this.buf.writeDoubleLE(val, this.pos);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);

        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        var varintLen =
            len <= 0x7f ? 1 :
            len <= 0x3fff ? 2 :
            len <= 0x1fffff ? 3 :
            len <= 0xfffffff ? 4 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

        // if 1 byte isn't enough for encoding message length, shift the data to the right
        if (varintLen > 1) {
            this.realloc(varintLen - 1);
            for (var i = this.pos - 1; i >= startPos; i--) this.buf[i + varintLen - 1] = this.buf[i];
        }

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9wYmYvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGJmO1xuXG52YXIgQnVmZmVyID0gZ2xvYmFsLkJ1ZmZlciB8fCByZXF1aXJlKCcuL2J1ZmZlcicpO1xuXG5mdW5jdGlvbiBQYmYoYnVmKSB7XG4gICAgdGhpcy5idWYgPSAhQnVmZmVyLmlzQnVmZmVyKGJ1ZikgPyBuZXcgQnVmZmVyKGJ1ZiB8fCAwKSA6IGJ1ZjtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmJ1Zi5sZW5ndGg7XG59XG5cblBiZi5WYXJpbnQgID0gMDsgLy8gdmFyaW50OiBpbnQzMiwgaW50NjQsIHVpbnQzMiwgdWludDY0LCBzaW50MzIsIHNpbnQ2NCwgYm9vbCwgZW51bVxuUGJmLkZpeGVkNjQgPSAxOyAvLyA2NC1iaXQ6IGRvdWJsZSwgZml4ZWQ2NCwgc2ZpeGVkNjRcblBiZi5CeXRlcyAgID0gMjsgLy8gbGVuZ3RoLWRlbGltaXRlZDogc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHNcblBiZi5GaXhlZDMyID0gNTsgLy8gMzItYml0OiBmbG9hdCwgZml4ZWQzMiwgc2ZpeGVkMzJcblxudmFyIFNISUZUX0xFRlRfMzIgPSAoMSA8PCAxNikgKiAoMSA8PCAxNiksXG4gICAgU0hJRlRfUklHSFRfMzIgPSAxIC8gU0hJRlRfTEVGVF8zMixcbiAgICBQT1dfMl82MyA9IE1hdGgucG93KDIsIDYzKTtcblxuUGJmLnByb3RvdHlwZSA9IHtcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJ1ZiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8vID09PSBSRUFESU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICByZWFkRmllbGRzOiBmdW5jdGlvbihyZWFkRmllbGQsIHJlc3VsdCwgZW5kKSB7XG4gICAgICAgIGVuZCA9IGVuZCB8fCB0aGlzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLnJlYWRWYXJpbnQoKSxcbiAgICAgICAgICAgICAgICB0YWcgPSB2YWwgPj4gMyxcbiAgICAgICAgICAgICAgICBzdGFydFBvcyA9IHRoaXMucG9zO1xuXG4gICAgICAgICAgICByZWFkRmllbGQodGFnLCByZXN1bHQsIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0UG9zKSB0aGlzLnNraXAodmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICByZWFkTWVzc2FnZTogZnVuY3Rpb24ocmVhZEZpZWxkLCByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZpZWxkcyhyZWFkRmllbGQsIHJlc3VsdCwgdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcyk7XG4gICAgfSxcblxuICAgIHJlYWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRTRml4ZWQzMjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIC8vIDY0LWJpdCBpbnQgaGFuZGxpbmcgaXMgYmFzZWQgb24gZ2l0aHViLmNvbS9kcHcvbm9kZS1idWZmZXItbW9yZS1pbnRzIChNSVQtbGljZW5zZWQpXG5cbiAgICByZWFkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpICsgdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkU0ZpeGVkNjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zKSArIHRoaXMuYnVmLnJlYWRJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZEZsb2F0TEUodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWREb3VibGVMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYnVmID0gdGhpcy5idWYsXG4gICAgICAgICAgICB2YWwsIGIsIGIwLCBiMSwgYjIsIGIzO1xuXG4gICAgICAgIGIwID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjAgPCAweDgwKSByZXR1cm4gYjA7ICAgICAgICAgICAgICAgICBiMCA9IGIwICYgMHg3ZjtcbiAgICAgICAgYjEgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMSA8IDB4ODApIHJldHVybiBiMCB8IGIxIDw8IDc7ICAgICAgIGIxID0gKGIxICYgMHg3ZikgPDwgNztcbiAgICAgICAgYjIgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMiA8IDB4ODApIHJldHVybiBiMCB8IGIxIHwgYjIgPDwgMTQ7IGIyID0gKGIyICYgMHg3ZikgPDwgMTQ7XG4gICAgICAgIGIzID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjMgPCAweDgwKSByZXR1cm4gYjAgfCBiMSB8IGIyIHwgYjMgPDwgMjE7XG5cbiAgICAgICAgdmFsID0gYjAgfCBiMSB8IGIyIHwgKGIzICYgMHg3ZikgPDwgMjE7XG5cbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwOyAgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDsgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDQwMDAwMDAwMDAwOyAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDIwMDAwMDAwMDAwMDA7ICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwMDAwMDAwMDsgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDAwMDAwMDA7IGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhcmludCBub3QgbW9yZSB0aGFuIDEwIGJ5dGVzJyk7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zLFxuICAgICAgICAgICAgdmFsID0gdGhpcy5yZWFkVmFyaW50KCk7XG5cbiAgICAgICAgaWYgKHZhbCA8IFBPV18yXzYzKSByZXR1cm4gdmFsO1xuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcyAtIDI7XG4gICAgICAgIHdoaWxlICh0aGlzLmJ1Zltwb3NdID09PSAweGZmKSBwb3MtLTtcbiAgICAgICAgaWYgKHBvcyA8IHN0YXJ0UG9zKSBwb3MgPSBzdGFydFBvcztcblxuICAgICAgICB2YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvcyAtIHN0YXJ0UG9zICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYiA9IH50aGlzLmJ1ZltzdGFydFBvcyArIGldICYgMHg3ZjtcbiAgICAgICAgICAgIHZhbCArPSBpIDwgNCA/IGIgPDwgaSAqIDcgOiBiICogTWF0aC5wb3coMiwgaSAqIDcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC12YWwgLSAxO1xuICAgIH0sXG5cbiAgICByZWFkU1ZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBudW0gPSB0aGlzLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgcmV0dXJuIG51bSAlIDIgPT09IDEgPyAobnVtICsgMSkgLyAtMiA6IG51bSAvIDI7IC8vIHppZ3phZyBlbmNvZGluZ1xuICAgIH0sXG5cbiAgICByZWFkQm9vbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMucmVhZFZhcmludCgpKTtcbiAgICB9LFxuXG4gICAgcmVhZFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgc3RyID0gdGhpcy5idWYudG9TdHJpbmcoJ3V0ZjgnLCB0aGlzLnBvcywgZW5kKTtcbiAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIHJlYWRCeXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgYnVmZmVyID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIGVuZCk7XG4gICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH0sXG5cbiAgICAvLyB2ZXJib3NlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOyBkb2Vzbid0IGFmZmVjdCBnemlwcGVkIHNpemVcblxuICAgIHJlYWRQYWNrZWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkVmFyaW50KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU1ZhcmludCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRCb29sZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEJvb2xlYW4oKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRmxvYXQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU0ZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZFNGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG5cbiAgICBza2lwOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB2YWwgJiAweDc7XG4gICAgICAgIGlmICh0eXBlID09PSBQYmYuVmFyaW50KSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gPiAweDdmKSB7fVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuQnl0ZXMpIHRoaXMucG9zID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcztcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gUGJmLkZpeGVkMzIpIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBiZi5GaXhlZDY0KSB0aGlzLnBvcyArPSA4O1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCB0eXBlOiAnICsgdHlwZSk7XG4gICAgfSxcblxuICAgIC8vID09PSBXUklUSU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICB3cml0ZVRhZzogZnVuY3Rpb24odGFnLCB0eXBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoKHRhZyA8PCAzKSB8IHR5cGUpO1xuICAgIH0sXG5cbiAgICByZWFsbG9jOiBmdW5jdGlvbihtaW4pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDE2O1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGggPCB0aGlzLnBvcyArIG1pbikgbGVuZ3RoICo9IDI7XG5cbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5jb3B5KGJ1Zik7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgd3JpdGVGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQzMkxFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZVNGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgfSxcblxuICAgIHdyaXRlRml4ZWQ2NDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlU0ZpeGVkNjQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFsID0gK3ZhbDtcblxuICAgICAgICBpZiAodmFsIDw9IDB4N2YpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gdmFsO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4M2ZmZikge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDIpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMCkgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiA3KSAmIDB4N2YpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4MWZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMyk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMTQpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPD0gMHhmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMTQpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMjEpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHdoaWxlICh2YWwgPj0gMHg4MCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICh2YWwgJiAweGZmKSB8IDB4ODA7XG4gICAgICAgICAgICAgICAgdmFsIC89IDB4ODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMSk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IHZhbCB8IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgLSBwb3MgPiAxMCkgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiB2YXJpbnQgZG9lc25cXCd0IGZpdCBpbnRvIDEwIGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd3JpdGVTVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwgPCAwID8gLXZhbCAqIDIgLSAxIDogdmFsICogMik7XG4gICAgfSxcblxuICAgIHdyaXRlQm9vbGVhbjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoQm9vbGVhbih2YWwpKTtcbiAgICB9LFxuXG4gICAgd3JpdGVTdHJpbmc6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgdmFyIGJ5dGVzID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyKTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChieXRlcyk7XG4gICAgICAgIHRoaXMucmVhbGxvYyhieXRlcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlKHN0ciwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSBieXRlcztcbiAgICB9LFxuXG4gICAgd3JpdGVGbG9hdDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVGbG9hdExFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZURvdWJsZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVEb3VibGVMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICB9LFxuXG4gICAgd3JpdGVCeXRlczogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucmVhbGxvYyhsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IGJ1ZmZlcltpXTtcbiAgICB9LFxuXG4gICAgd3JpdGVNZXNzYWdlOiBmdW5jdGlvbih0YWcsIGZuLCBvYmopIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5CeXRlcyk7XG5cbiAgICAgICAgdGhpcy5wb3MrKzsgLy8gcmVzZXJ2ZSAxIGJ5dGUgZm9yIHNob3J0IG1lc3NhZ2UgbGVuZ3RoXG5cbiAgICAgICAgLy8gd3JpdGUgdGhlIG1lc3NhZ2UgZGlyZWN0bHkgdG8gdGhlIGJ1ZmZlciBhbmQgc2VlIGhvdyBtdWNoIHdhcyB3cml0dGVuXG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zO1xuICAgICAgICBmbihvYmosIHRoaXMpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5wb3MgLSBzdGFydFBvcztcblxuICAgICAgICB2YXIgdmFyaW50TGVuID1cbiAgICAgICAgICAgIGxlbiA8PSAweDdmID8gMSA6XG4gICAgICAgICAgICBsZW4gPD0gMHgzZmZmID8gMiA6XG4gICAgICAgICAgICBsZW4gPD0gMHgxZmZmZmYgPyAzIDpcbiAgICAgICAgICAgIGxlbiA8PSAweGZmZmZmZmYgPyA0IDogTWF0aC5jZWlsKE1hdGgubG9nKGxlbikgLyAoTWF0aC5MTjIgKiA3KSk7XG5cbiAgICAgICAgLy8gaWYgMSBieXRlIGlzbid0IGVub3VnaCBmb3IgZW5jb2RpbmcgbWVzc2FnZSBsZW5ndGgsIHNoaWZ0IHRoZSBkYXRhIHRvIHRoZSByaWdodFxuICAgICAgICBpZiAodmFyaW50TGVuID4gMSkge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKHZhcmludExlbiAtIDEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucG9zIC0gMTsgaSA+PSBzdGFydFBvczsgaS0tKSB0aGlzLmJ1ZltpICsgdmFyaW50TGVuIC0gMV0gPSB0aGlzLmJ1ZltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsbHksIHdyaXRlIHRoZSBtZXNzYWdlIGxlbmd0aCBpbiB0aGUgcmVzZXJ2ZWQgcGxhY2UgYW5kIHJlc3RvcmUgdGhlIHBvc2l0aW9uXG4gICAgICAgIHRoaXMucG9zID0gc3RhcnRQb3MgLSAxO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICB9LFxuXG4gICAgd3JpdGVQYWNrZWRWYXJpbnQ6ICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFZhcmludCwgYXJyKTsgICB9LFxuICAgIHdyaXRlUGFja2VkU1ZhcmludDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRTVmFyaW50LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZEJvb2xlYW46ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkQm9vbGVhbiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRGbG9hdDogICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZsb2F0LCBhcnIpOyAgICB9LFxuICAgIHdyaXRlUGFja2VkRG91YmxlOiAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWREb3VibGUsIGFycik7ICAgfSxcbiAgICB3cml0ZVBhY2tlZEZpeGVkMzI6ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRml4ZWQzMiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRTRml4ZWQzMjogZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNGaXhlZDMyLCBhcnIpOyB9LFxuICAgIHdyaXRlUGFja2VkRml4ZWQ2NDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRGaXhlZDY0LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU0ZpeGVkNjQsIGFycik7IH0sXG5cbiAgICB3cml0ZUJ5dGVzRmllbGQ6IGZ1bmN0aW9uKHRhZywgYnVmZmVyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlQnl0ZXMoYnVmZmVyKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQzMih2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkMzIodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQ2NCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkNjQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVNWYXJpbnQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU3RyaW5nRmllbGQ6IGZ1bmN0aW9uKHRhZywgc3RyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlU3RyaW5nKHN0cik7XG4gICAgfSxcbiAgICB3cml0ZUZsb2F0RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQzMik7XG4gICAgICAgIHRoaXMud3JpdGVGbG9hdCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVEb3VibGVGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcbiAgICAgICAgdGhpcy53cml0ZURvdWJsZSh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVCb29sZWFuRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnRGaWVsZCh0YWcsIEJvb2xlYW4odmFsKSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVQYWNrZWRWYXJpbnQoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlVmFyaW50KGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTVmFyaW50KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU1ZhcmludChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGbG9hdChhcnIsIHBiZikgICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRmxvYXQoYXJyW2ldKTsgICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWREb3VibGUoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRG91YmxlKGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRCb29sZWFuKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlQm9vbGVhbihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDMyKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQzMihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQzMihhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkMzIoYXJyW2ldKTsgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDY0KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQ2NChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQ2NChhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkNjQoYXJyW2ldKTsgfVxuIl19
},{"./buffer":181}],183:[function(_dereq_,module,exports){
module.exports=_dereq_(132)
},{"/Users/bcamper/Documents/dev/vector-map/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js":132}],184:[function(_dereq_,module,exports){
/*!
 * strip-comments <https://github.com/jonschlinkert/strip-comments>
 *
 * Copyright (c) 2014-2015 Jon Schlinkert.
 * Licensed under the MIT license.
 */

'use strict';

var reBlock = /\/\*(?!\/)(.|[\r\n]|\n)+?\*\/\n?\n?/gm;
var reBlockIgnore = /\/\*(?!(\*?\/|\*?\!))(.|[\r\n]|\n)+?\*\/\n?\n?/gm;
var reLine = /(^|[^\S\n])(?:\/\/)([\s\S]+?)$/gm;
var reLineIgnore = /(^|[^\S\n])(?:\/\/[^!])([\s\S]+?)$/gm;

/**
 * Strip all comments
 *
 * @param   {String} `str`  file contents or string to strip.
 * @param   {Object} `opts`  options are passed to `.block`, and `.line`
 * @return  {String} String without comments.
 * @api public
 */

function strip(str, opts) {
  return str ? strip.block(strip.line(str, opts), opts) : '';
}

/**
 * Strip only block comments, optionally leaving protected comments
 * (e.g. `/*!`) intact.
 *
 * @param   {String} `str`  file content or string to strip to
 * @param   {Object} `opts`  if `safe:true`, strip only comments that do not start with `/*!` or `/**!`
 * @return  {String} String without block comments.
 * @api public
 */

strip.block = function(str, opts) {
  opts = opts || {};
  var re = reBlock; //new RegExp(reBlock + reBlockEnd, 'gm');
  if(opts.safe) {
    re = reBlockIgnore; //new RegExp(reBlockIgnore + reBlockEnd, 'gm');
  }
  return str ? str.replace(re, '') : '';
};


/**
 * Strip only line comments
 *
 * @param   {String} `str`  file content or string to strip to
 * @param   {Object} `opts`  if `safe:true`, strip all that not starts with `//!`
 * @return  {String} String without line comments.
 * @api public
 */

strip.line = function(str, opts) {
  opts = opts || {};
  var re = reLine;
  if(opts.safe) {
    re = reLineIgnore;
  }
  return str ? str.replace(re, '') : '';
};

/**
 * Expose `strip`
 */

module.exports = strip;
},{}],185:[function(_dereq_,module,exports){
!function() {
  var topojson = {
    version: "1.6.19",
    mesh: function(topology) { return object(topology, meshArcs.apply(this, arguments)); },
    meshArcs: meshArcs,
    merge: function(topology) { return object(topology, mergeArcs.apply(this, arguments)); },
    mergeArcs: mergeArcs,
    feature: featureOrCollection,
    neighbors: neighbors,
    presimplify: presimplify
  };

  function stitchArcs(topology, arcs) {
    var stitchedArcs = {},
        fragmentByStart = {},
        fragmentByEnd = {},
        fragments = [],
        emptyIndex = -1;

    // Stitch empty arcs first, since they may be subsumed by other arcs.
    arcs.forEach(function(i, j) {
      var arc = topology.arcs[i < 0 ? ~i : i], t;
      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
      }
    });

    arcs.forEach(function(i) {
      var e = ends(i),
          start = e[0],
          end = e[1],
          f, g;

      if (f = fragmentByEnd[start]) {
        delete fragmentByEnd[f.end];
        f.push(i);
        f.end = end;
        if (g = fragmentByStart[end]) {
          delete fragmentByStart[g.start];
          var fg = g === f ? f : f.concat(g);
          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else if (f = fragmentByStart[end]) {
        delete fragmentByStart[f.start];
        f.unshift(i);
        f.start = start;
        if (g = fragmentByEnd[start]) {
          delete fragmentByEnd[g.end];
          var gf = g === f ? f : g.concat(f);
          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else {
        f = [i];
        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
      }
    });

    function ends(i) {
      var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
      if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
      else p1 = arc[arc.length - 1];
      return i < 0 ? [p1, p0] : [p0, p1];
    }

    function flush(fragmentByEnd, fragmentByStart) {
      for (var k in fragmentByEnd) {
        var f = fragmentByEnd[k];
        delete fragmentByStart[f.start];
        delete f.start;
        delete f.end;
        f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
        fragments.push(f);
      }
    }

    flush(fragmentByEnd, fragmentByStart);
    flush(fragmentByStart, fragmentByEnd);
    arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

    return fragments;
  }

  function meshArcs(topology, o, filter) {
    var arcs = [];

    if (arguments.length > 1) {
      var geomsByArc = [],
          geom;

      function arc(i) {
        var j = i < 0 ? ~i : i;
        (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
      }

      function line(arcs) {
        arcs.forEach(arc);
      }

      function polygon(arcs) {
        arcs.forEach(line);
      }

      function geometry(o) {
        if (o.type === "GeometryCollection") o.geometries.forEach(geometry);
        else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);
      }

      var geometryType = {
        LineString: line,
        MultiLineString: polygon,
        Polygon: polygon,
        MultiPolygon: function(arcs) { arcs.forEach(polygon); }
      };

      geometry(o);

      geomsByArc.forEach(arguments.length < 3
          ? function(geoms) { arcs.push(geoms[0].i); }
          : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });
    } else {
      for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);
    }

    return {type: "MultiLineString", arcs: stitchArcs(topology, arcs)};
  }

  function mergeArcs(topology, objects) {
    var polygonsByArc = {},
        polygons = [],
        components = [];

    objects.forEach(function(o) {
      if (o.type === "Polygon") register(o.arcs);
      else if (o.type === "MultiPolygon") o.arcs.forEach(register);
    });

    function register(polygon) {
      polygon.forEach(function(ring) {
        ring.forEach(function(arc) {
          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
        });
      });
      polygons.push(polygon);
    }

    function exterior(ring) {
      return cartesianRingArea(object(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]) > 0; // TODO allow spherical?
    }

    polygons.forEach(function(polygon) {
      if (!polygon._) {
        var component = [],
            neighbors = [polygon];
        polygon._ = 1;
        components.push(component);
        while (polygon = neighbors.pop()) {
          component.push(polygon);
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
                if (!polygon._) {
                  polygon._ = 1;
                  neighbors.push(polygon);
                }
              });
            });
          });
        }
      }
    });

    polygons.forEach(function(polygon) {
      delete polygon._;
    });

    return {
      type: "MultiPolygon",
      arcs: components.map(function(polygons) {
        var arcs = [];

        // Extract the exterior (unique) arcs.
        polygons.forEach(function(polygon) {
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                arcs.push(arc);
              }
            });
          });
        });

        // Stitch the arcs into one or more rings.
        arcs = stitchArcs(topology, arcs);

        // If more than one ring is returned,
        // at most one of these rings can be the exterior;
        // this exterior ring has the same winding order
        // as any exterior ring in the original polygons.
        if ((n = arcs.length) > 1) {
          var sgn = exterior(polygons[0][0]);
          for (var i = 0, t; i < n; ++i) {
            if (sgn === exterior(arcs[i])) {
              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t;
              break;
            }
          }
        }

        return arcs;
      })
    };
  }

  function featureOrCollection(topology, o) {
    return o.type === "GeometryCollection" ? {
      type: "FeatureCollection",
      features: o.geometries.map(function(o) { return feature(topology, o); })
    } : feature(topology, o);
  }

  function feature(topology, o) {
    var f = {
      type: "Feature",
      id: o.id,
      properties: o.properties || {},
      geometry: object(topology, o)
    };
    if (o.id == null) delete f.id;
    return f;
  }

  function object(topology, o) {
    var absolute = transformAbsolute(topology.transform),
        arcs = topology.arcs;

    function arc(i, points) {
      if (points.length) points.pop();
      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {
        points.push(p = a[k].slice());
        absolute(p, k);
      }
      if (i < 0) reverse(points, n);
    }

    function point(p) {
      p = p.slice();
      absolute(p, 0);
      return p;
    }

    function line(arcs) {
      var points = [];
      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
      if (points.length < 2) points.push(points[0].slice());
      return points;
    }

    function ring(arcs) {
      var points = line(arcs);
      while (points.length < 4) points.push(points[0].slice());
      return points;
    }

    function polygon(arcs) {
      return arcs.map(ring);
    }

    function geometry(o) {
      var t = o.type;
      return t === "GeometryCollection" ? {type: t, geometries: o.geometries.map(geometry)}
          : t in geometryType ? {type: t, coordinates: geometryType[t](o)}
          : null;
    }

    var geometryType = {
      Point: function(o) { return point(o.coordinates); },
      MultiPoint: function(o) { return o.coordinates.map(point); },
      LineString: function(o) { return line(o.arcs); },
      MultiLineString: function(o) { return o.arcs.map(line); },
      Polygon: function(o) { return polygon(o.arcs); },
      MultiPolygon: function(o) { return o.arcs.map(polygon); }
    };

    return geometry(o);
  }

  function reverse(array, n) {
    var t, j = array.length, i = j - n; while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
  }

  function bisect(a, x) {
    var lo = 0, hi = a.length;
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (a[mid] < x) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }

  function neighbors(objects) {
    var indexesByArc = {}, // arc index -> array of object indexes
        neighbors = objects.map(function() { return []; });

    function line(arcs, i) {
      arcs.forEach(function(a) {
        if (a < 0) a = ~a;
        var o = indexesByArc[a];
        if (o) o.push(i);
        else indexesByArc[a] = [i];
      });
    }

    function polygon(arcs, i) {
      arcs.forEach(function(arc) { line(arc, i); });
    }

    function geometry(o, i) {
      if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
      else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
    }

    var geometryType = {
      LineString: line,
      MultiLineString: polygon,
      Polygon: polygon,
      MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
    };

    objects.forEach(geometry);

    for (var i in indexesByArc) {
      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
        for (var k = j + 1; k < m; ++k) {
          var ij = indexes[j], ik = indexes[k], n;
          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
        }
      }
    }

    return neighbors;
  }

  function presimplify(topology, triangleArea) {
    var absolute = transformAbsolute(topology.transform),
        relative = transformRelative(topology.transform),
        heap = minAreaHeap();

    if (!triangleArea) triangleArea = cartesianTriangleArea;

    topology.arcs.forEach(function(arc) {
      var triangles = [],
          maxArea = 0,
          triangle;

      // To store each point’s effective area, we create a new array rather than
      // extending the passed-in point to workaround a Chrome/V8 bug (getting
      // stuck in smi mode). For midpoints, the initial effective area of
      // Infinity will be computed in the next step.
      for (var i = 0, n = arc.length, p; i < n; ++i) {
        p = arc[i];
        absolute(arc[i] = [p[0], p[1], Infinity], i);
      }

      for (var i = 1, n = arc.length - 1; i < n; ++i) {
        triangle = arc.slice(i - 1, i + 2);
        triangle[1][2] = triangleArea(triangle);
        triangles.push(triangle);
        heap.push(triangle);
      }

      for (var i = 0, n = triangles.length; i < n; ++i) {
        triangle = triangles[i];
        triangle.previous = triangles[i - 1];
        triangle.next = triangles[i + 1];
      }

      while (triangle = heap.pop()) {
        var previous = triangle.previous,
            next = triangle.next;

        // If the area of the current point is less than that of the previous point
        // to be eliminated, use the latter's area instead. This ensures that the
        // current point cannot be eliminated without eliminating previously-
        // eliminated points.
        if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;
        else maxArea = triangle[1][2];

        if (previous) {
          previous.next = next;
          previous[2] = triangle[2];
          update(previous);
        }

        if (next) {
          next.previous = previous;
          next[0] = triangle[0];
          update(next);
        }
      }

      arc.forEach(relative);
    });

    function update(triangle) {
      heap.remove(triangle);
      triangle[1][2] = triangleArea(triangle);
      heap.push(triangle);
    }

    return topology;
  };

  function cartesianRingArea(ring) {
    var i = -1,
        n = ring.length,
        a,
        b = ring[n - 1],
        area = 0;

    while (++i < n) {
      a = b;
      b = ring[i];
      area += a[0] * b[1] - a[1] * b[0];
    }

    return area * .5;
  }

  function cartesianTriangleArea(triangle) {
    var a = triangle[0], b = triangle[1], c = triangle[2];
    return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));
  }

  function compareArea(a, b) {
    return a[1][2] - b[1][2];
  }

  function minAreaHeap() {
    var heap = {},
        array = [],
        size = 0;

    heap.push = function(object) {
      up(array[object._ = size] = object, size++);
      return size;
    };

    heap.pop = function() {
      if (size <= 0) return;
      var removed = array[0], object;
      if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);
      return removed;
    };

    heap.remove = function(removed) {
      var i = removed._, object;
      if (array[i] !== removed) return; // invalid request
      if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);
      return i;
    };

    function up(object, i) {
      while (i > 0) {
        var j = ((i + 1) >> 1) - 1,
            parent = array[j];
        if (compareArea(object, parent) >= 0) break;
        array[parent._ = i] = parent;
        array[object._ = i = j] = object;
      }
    }

    function down(object, i) {
      while (true) {
        var r = (i + 1) << 1,
            l = r - 1,
            j = i,
            child = array[j];
        if (l < size && compareArea(array[l], child) < 0) child = array[j = l];
        if (r < size && compareArea(array[r], child) < 0) child = array[j = r];
        if (j === i) break;
        array[child._ = i] = child;
        array[object._ = i = j] = object;
      }
    }

    return heap;
  }

  function transformAbsolute(transform) {
    if (!transform) return noop;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(point, i) {
      if (!i) x0 = y0 = 0;
      point[0] = (x0 += point[0]) * kx + dx;
      point[1] = (y0 += point[1]) * ky + dy;
    };
  }

  function transformRelative(transform) {
    if (!transform) return noop;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(point, i) {
      if (!i) x0 = y0 = 0;
      var x1 = (point[0] - dx) / kx | 0,
          y1 = (point[1] - dy) / ky | 0;
      point[0] = x1 - x0;
      point[1] = y1 - y0;
      x0 = x1;
      y0 = y1;
    };
  }

  function noop() {}

  if (typeof define === "function" && define.amd) define(topojson);
  else if (typeof module === "object" && module.exports) module.exports = topojson;
  else this.topojson = topojson;
}();

},{}],186:[function(_dereq_,module,exports){
module.exports.VectorTile = _dereq_('./lib/vectortile.js');
module.exports.VectorTileFeature = _dereq_('./lib/vectortilefeature.js');
module.exports.VectorTileLayer = _dereq_('./lib/vectortilelayer.js');

},{"./lib/vectortile.js":187,"./lib/vectortilefeature.js":188,"./lib/vectortilelayer.js":189}],187:[function(_dereq_,module,exports){
'use strict';

var VectorTileLayer = _dereq_('./vectortilelayer');

module.exports = VectorTile;

function VectorTile(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
    if (tag === 3) {
        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length) layers[layer.name] = layer;
    }
}


},{"./vectortilelayer":189}],188:[function(_dereq_,module,exports){
'use strict';

var Point = _dereq_('point-geometry');

module.exports = VectorTileFeature;

function VectorTileFeature(pbf, end, extent, keys, values) {
    // Public
    this.properties = {};
    this.extent = extent;
    this.type = 0;

    // Private
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;

    pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
    if (tag == 1) feature._id = pbf.readVarint();
    else if (tag == 2) readTag(pbf, feature);
    else if (tag == 3) feature.type = pbf.readVarint();
    else if (tag == 4) feature._geometry = pbf.pos;
}

function readTag(pbf, feature) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()],
            value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();

            if (cmd === 1) { // moveTo
                if (line) lines.push(line);
                line = [];
            }

            line.push(new Point(x, y));

        } else if (cmd === 7) {
            line.push(line[0].clone()); // closePolygon

        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) lines.push(line);

    return lines;
};

VectorTileFeature.prototype.bbox = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (x < x1) x1 = x;
            if (x > x2) x2 = x;
            if (y < y1) y1 = y;
            if (y > y2) y2 = y;

        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

VectorTileFeature.prototype.toGeoJSON = function(x, y, z) {
    var size = this.extent * Math.pow(2, z),
        x0 = this.extent * x,
        y0 = this.extent * y,
        coords = this.loadGeometry(),
        type = VectorTileFeature.types[this.type];

    for (var i = 0; i < coords.length; i++) {
        var line = coords[i];
        for (var j = 0; j < line.length; j++) {
            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [
                (p.x + x0) * 360 / size - 180,
                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
            ];
        }
    }

    if (type === 'Point' && coords.length === 1) {
        coords = coords[0][0];
    } else if (type === 'Point') {
        coords = coords[0];
        type = 'MultiPoint';
    } else if (type === 'LineString' && coords.length === 1) {
        coords = coords[0];
    } else if (type === 'LineString') {
        type = 'MultiLineString';
    }

    return {
        type: "Feature",
        geometry: {
            type: type,
            coordinates: coords
        },
        properties: this.properties
    };
};

},{"point-geometry":190}],189:[function(_dereq_,module,exports){
'use strict';

var VectorTileFeature = _dereq_('./vectortilefeature.js');

module.exports = VectorTileLayer;

function VectorTileLayer(pbf, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];

    pbf.readFields(readLayer, this, end);

    this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
    if (tag === 15) layer.version = pbf.readVarint();
    else if (tag === 1) layer.name = pbf.readString();
    else if (tag === 5) layer.extent = pbf.readVarint();
    else if (tag === 2) layer._features.push(pbf.pos);
    else if (tag === 3) layer._keys.push(pbf.readString());
    else if (tag === 4) layer._values.push(readValueMessage(pbf));
}

function readValueMessage(pbf) {
    var value = null,
        end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;

        value = tag === 1 ? pbf.readString() :
            tag === 2 ? pbf.readFloat() :
            tag === 3 ? pbf.readDouble() :
            tag === 4 ? pbf.readVarint64() :
            tag === 5 ? pbf.readVarint() :
            tag === 6 ? pbf.readSVarint() :
            tag === 7 ? pbf.readBoolean() : null;
    }

    return value;
}

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

    this._pbf.pos = this._features[i];

    var end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
};

},{"./vectortilefeature.js":188}],190:[function(_dereq_,module,exports){
'use strict';

module.exports = Point;

function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {
    clone: function() { return new Point(this.x, this.y); },

    add:     function(p) { return this.clone()._add(p);     },
    sub:     function(p) { return this.clone()._sub(p);     },
    mult:    function(k) { return this.clone()._mult(k);    },
    div:     function(k) { return this.clone()._div(k);     },
    rotate:  function(a) { return this.clone()._rotate(a);  },
    matMult: function(m) { return this.clone()._matMult(m); },
    unit:    function() { return this.clone()._unit(); },
    perp:    function() { return this.clone()._perp(); },
    round:   function() { return this.clone()._round(); },

    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    equals: function(p) {
        return this.x === p.x &&
               this.y === p.y;
    },

    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

// constructs Point from an array if necessary
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};

},{}],191:[function(_dereq_,module,exports){
/*global Camera */
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _geo = _dereq_('./geo');

var _geo2 = _interopRequireDefault(_geo);

var _utilsUtils = _dereq_('./utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _glShader_program = _dereq_('./gl/shader_program');

var _glShader_program2 = _interopRequireDefault(_glShader_program);

var _glMatrix = _dereq_('gl-matrix');

var _glMatrix2 = _interopRequireDefault(_glMatrix);

var mat4 = _glMatrix2['default'].mat4;
var vec3 = _glMatrix2['default'].vec3;

// Abstract base class

var Camera = (function () {
    function Camera(name, scene) {
        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, Camera);

        this.scene = scene;
        this.position = options.position;
        this.zoom = options.zoom;
        // this.updateScene();
    }

    /**
        Perspective matrix projection
    
        This is a specialized perspective camera that, given a desired camera focal length (which can also vary by zoom level),
        constrains the camera height above the ground plane such that the displayed ground area of the map matches that of
        a traditional web mercator map. This means you can set the camera location by [lat, lng, zoom] as you would a typical
        web mercator map, then adjust the focal length as needed.
    
        Vanishing point can also be adjusted to achieve different "viewing angles", e.g. instead of looking straight down into
        the center of the viewport, the camera appears to be tilted at an angle. For example:
    
        [0, 0] = looking towards center of viewport
        [-250, -250] = looking 250 pixels from the viewport center to the lower-left corner
        [400, 0] = looking 400 pixels to the right of the viewport center
    */

    // Create a camera by type name, factory-style

    _createClass(Camera, [{
        key: 'update',

        // Update method called once per frame
        value: function update() {}
        // this.updateScene();

        // Called once per frame per program (e.g. for main render pass, then for each additional pass for feature selection, etc.)

    }, {
        key: 'setupProgram',
        value: function setupProgram(program) {}

        /**
            Sync camera position and/or zoom to scene
            position: [lat, lng] or [lat, lng, zoom]
            zoom: zoom
        */
    }, {
        key: 'updateScene',
        value: function updateScene() {
            if (this.position || this.zoom) {
                var view = {};
                if (this.position) {
                    view = { lng: this.position[0], lat: this.position[1], zoom: this.position[2] };
                }
                if (this.zoom) {
                    view.zoom = this.zoom;
                }
                this.scene.setView(view);
            }
        }
    }], [{
        key: 'create',
        value: function create(name, scene, config) {
            switch (config.type) {
                case 'isometric':
                    return new IsometricCamera(name, scene, config);
                case 'flat':
                    return new FlatCamera(name, scene, config);
                case 'perspective':
                /* falls through */
                default:
                    return new PerspectiveCamera(name, scene, config);
            }
        }
    }]);

    return Camera;
})();

exports['default'] = Camera;

var PerspectiveCamera = (function (_Camera) {
    _inherits(PerspectiveCamera, _Camera);

    function PerspectiveCamera(name, scene) {
        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, PerspectiveCamera);

        _get(Object.getPrototypeOf(PerspectiveCamera.prototype), 'constructor', this).call(this, name, scene, options);
        this.type = 'perspective';

        // a single scalar, or pairs of stops mapping zoom levels, e.g. [zoom, focal length]
        this.focal_length = options.focal_length;
        this.fov = options.fov;
        if (!this.focal_length && !this.fov) {
            // Default focal length ranges by zoom
            this.focal_length = [[16, 2], [17, 2.5], [18, 3], [19, 4], [20, 6]];
        }

        this.vanishing_point = options.vanishing_point || [0, 0]; // [x, y]
        this.vanishing_point = this.vanishing_point.map(parseFloat); // we implicitly only support px units here
        this.vanishing_point_skew = [];

        this.position_meters = null;
        this.viewMatrix = new Float64Array(16);
        this.projectionMatrix = new Float32Array(16);

        // 'camera' is the name of the shader block, e.g. determines where in the shader this code is injected
        _glShader_program2['default'].replaceBlock('camera', '\n            uniform mat4 u_projection;\n            uniform vec3 u_eye;\n            uniform vec2 u_vanishing_point;\n\n            void cameraProjection (inout vec4 position) {\n                position = u_projection * position;\n            }');
    }

    // Isometric-style projection
    // Note: this is actually an "axonometric" projection, but I'm using the colloquial term isometric because it is more recognizable.
    // An isometric projection is a specific subset of axonometric projections.
    // 'axis' determines the xy skew applied to a vertex based on its z coordinate, e.g. [0, 1] axis causes buildings to be drawn
    // straight upwards on screen at their true height, [0, .5] would draw them up at half-height, [1, 0] would be sideways, etc.

    // Constrains the camera so that the viewable area matches given the viewport height
    // (in world space, e.g. meters), given either a camera focal length or field-of-view
    // (focal length is used if both are passed).

    _createClass(PerspectiveCamera, [{
        key: 'constrainCamera',
        value: function constrainCamera(_ref) {
            var view_height = _ref.view_height;
            var height = _ref.height;
            var focal_length = _ref.focal_length;
            var fov = _ref.fov;

            // Solve for camera height
            if (!height) {
                // We have focal length, calculate FOV
                if (focal_length) {
                    fov = Math.atan(1 / focal_length) * 2;
                }
                // We have FOV, calculate focal length
                else if (fov) {
                        fov = fov * Math.PI / 180; // convert FOV degrees to radians
                        focal_length = 1 / Math.tan(fov / 2);
                    }

                // Distance that camera should be from ground such that it fits the field of view expected
                // for a conventional web mercator map at the current zoom level and camera focal length
                height = view_height / 2 * focal_length;
            }
            // Solve for camera focal length / field-of-view
            else {
                    focal_length = 2 * height / view_height;
                    fov = Math.atan(1 / focal_length) * 2;
                }

            return { view_height: view_height, height: height, focal_length: focal_length, fov: fov };
        }
    }, {
        key: 'updateMatrices',
        value: function updateMatrices() {
            // TODO: only re-calculate these vars when necessary

            // Height of the viewport in meters at current zoom
            var viewport_height = this.scene.css_size.height * _geo2['default'].metersPerPixel(this.scene.zoom);

            // Compute camera properties to fit desired view

            var _constrainCamera = this.constrainCamera({
                view_height: viewport_height,
                focal_length: _utilsUtils2['default'].interpolate(this.scene.zoom, this.focal_length),
                fov: _utilsUtils2['default'].interpolate(this.scene.zoom, this.fov)
            });

            var height = _constrainCamera.height;
            var fov = _constrainCamera.fov;

            // View matrix
            var position = [this.scene.center_meters.x, this.scene.center_meters.y, height];
            this.position_meters = position;

            // mat4.lookAt(this.viewMatrix,
            //     vec3.fromValues(...position),
            //     vec3.fromValues(position[0], position[1], height - 1),
            //     vec3.fromValues(0, 1, 0));
            // Exclude camera height from view matrix
            mat4.lookAt(this.viewMatrix, vec3.fromValues(position[0], position[1], 0), vec3.fromValues(position[0], position[1], -1), vec3.fromValues(0, 1, 0));

            // Projection matrix
            mat4.perspective(this.projectionMatrix, fov, this.scene.view_aspect, 1, height * 2);

            // Convert vanishing point from pixels to viewport space
            this.vanishing_point_skew[0] = this.vanishing_point[0] / this.scene.css_size.width;
            this.vanishing_point_skew[1] = this.vanishing_point[1] / this.scene.css_size.height;

            // Adjust projection matrix to include vanishing point skew
            this.projectionMatrix[8] = -this.vanishing_point_skew[0]; // z column of x row, e.g. amount z skews x
            this.projectionMatrix[9] = -this.vanishing_point_skew[1]; // z column of y row, e.g. amount z skews y

            // Translate geometry into the distance so that camera is appropriate height above ground
            // Additionally, adjust xy to compensate for any vanishing point skew, e.g. move geometry so that the displayed g
            // plane of the map matches that expected by a traditional web mercator map at this [lat, lng, zoom].
            mat4.translate(this.projectionMatrix, this.projectionMatrix, vec3.fromValues(viewport_height / 2 * this.scene.view_aspect * -this.vanishing_point_skew[0], viewport_height / 2 * -this.vanishing_point_skew[1], 0));

            // Include camera height in projection matrix
            mat4.translate(this.projectionMatrix, this.projectionMatrix, vec3.fromValues(0, 0, -height));
        }
    }, {
        key: 'update',
        value: function update() {
            _get(Object.getPrototypeOf(PerspectiveCamera.prototype), 'update', this).call(this);
            this.updateMatrices();
        }
    }, {
        key: 'setupProgram',
        value: function setupProgram(program) {
            program.uniform('Matrix4fv', 'u_projection', false, this.projectionMatrix);
            program.uniform('3f', 'u_eye', 0, 0, this.position_meters[2]);
            program.uniform('2fv', 'u_vanishing_point', this.vanishing_point_skew);
        }
    }]);

    return PerspectiveCamera;
})(Camera);

var IsometricCamera = (function (_Camera2) {
    _inherits(IsometricCamera, _Camera2);

    function IsometricCamera(name, scene) {
        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, IsometricCamera);

        _get(Object.getPrototypeOf(IsometricCamera.prototype), 'constructor', this).call(this, name, scene, options);
        this.type = 'isometric';
        this.axis = options.axis || { x: 0, y: 1 };
        if (this.axis.length === 2) {
            this.axis = { x: this.axis[0], y: this.axis[1] }; // allow axis to also be passed as 2-elem array
        }

        this.position_meters = null;
        this.viewport_height = null;

        this.viewMatrix = new Float64Array(16);
        this.projectionMatrix = new Float32Array(16);

        // 'camera' is the name of the shader block, e.g. determines where in the shader this code is injected
        _glShader_program2['default'].replaceBlock('camera', '\n            uniform mat4 u_projection;\n            uniform vec3 u_eye;\n            uniform vec2 u_vanishing_point;\n\n            void cameraProjection (inout vec4 position) {\n                position = u_projection * position;\n                // position.xy += position.z * u_isometric_axis;\n\n                // Reverse z for depth buffer so up is negative,\n                // and scale down values so objects higher than one screen height will not get clipped\n                // pull forward slightly to avoid going past far clipping plane\n                position.z = -position.z / 100. + 1. - 0.001;\n            }');
    }

    // Flat projection (e.g. just top-down, no perspective) - a degenerate isometric camera

    _createClass(IsometricCamera, [{
        key: 'update',
        value: function update() {
            _get(Object.getPrototypeOf(IsometricCamera.prototype), 'update', this).call(this);

            this.viewport_height = this.scene.css_size.height * _geo2['default'].metersPerPixel(this.scene.zoom);
            var position = [this.scene.center_meters.x, this.scene.center_meters.y, this.viewport_height];
            this.position_meters = position;

            // View
            mat4.identity(this.viewMatrix);
            mat4.translate(this.viewMatrix, this.viewMatrix, vec3.fromValues(-position[0], -position[1], 0));

            // Projection
            mat4.identity(this.projectionMatrix);

            // apply isometric skew
            this.projectionMatrix[8] = this.axis.x / this.scene.view_aspect; // z column of x row, e.g. amount z skews x
            this.projectionMatrix[9] = this.axis.y; // z column of x row, e.g. amount z skews y

            // convert meters to viewport
            mat4.scale(this.projectionMatrix, this.projectionMatrix, vec3.fromValues(2 / this.scene.viewport_meters.x, 2 / this.scene.viewport_meters.y, 2 / this.scene.viewport_meters.y));
        }
    }, {
        key: 'setupProgram',
        value: function setupProgram(program) {
            program.uniform('Matrix4fv', 'u_projection', false, this.projectionMatrix);

            program.uniform('3f', 'u_eye', 0, 0, this.viewport_height);
            // program.uniform('3f', 'u_eye', this.viewport_height * this.axis.x, this.viewport_height * this.axis.y, this.viewport_height);
            program.uniform('2f', 'u_vanishing_point', 0, 0);
        }
    }]);

    return IsometricCamera;
})(Camera);

var FlatCamera = (function (_IsometricCamera) {
    _inherits(FlatCamera, _IsometricCamera);

    function FlatCamera(name, scene) {
        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, FlatCamera);

        _get(Object.getPrototypeOf(FlatCamera.prototype), 'constructor', this).call(this, name, scene, options);
        this.type = 'flat';
    }

    _createClass(FlatCamera, [{
        key: 'update',
        value: function update() {
            // Axis is fixed to (0, 0) for flat camera
            this.axis.x = 0;
            this.axis.y = 0;

            _get(Object.getPrototypeOf(FlatCamera.prototype), 'update', this).call(this);
        }
    }]);

    return FlatCamera;
})(IsometricCamera);

module.exports = exports['default'];

},{"./geo":192,"./gl/shader_program":198,"./utils/utils":241,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/get":20,"babel-runtime/helpers/inherits":21,"babel-runtime/helpers/interop-require-default":22,"gl-matrix":146}],192:[function(_dereq_,module,exports){
// Miscellaneous geo functions

'use strict';

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});
var Geo;
exports['default'] = Geo = {};

// Projection constants
Geo.tile_size = 256;
Geo.half_circumference_meters = 20037508.342789244;
Geo.circumference_meters = Geo.half_circumference_meters * 2;
Geo.min_zoom_meters_per_pixel = Geo.circumference_meters / Geo.tile_size; // min zoom draws world as 2 tiles wide
Geo.meters_per_pixel = [];
Geo.meters_per_tile = [];
Geo.max_zoom = 18;
for (var z = 0; z <= Geo.max_zoom; z++) {
    Geo.meters_per_pixel[z] = Geo.min_zoom_meters_per_pixel / Math.pow(2, z);
    Geo.meters_per_tile[z] = Geo.circumference_meters / Math.pow(2, z);
}

Geo.metersPerPixel = function (zoom) {
    return Geo.min_zoom_meters_per_pixel / Math.pow(2, zoom);
};

// Conversion functions based on an defined tile scale
Geo.units_per_meter = [];
Geo.tile_scale = 4096; // coordinates are locally scaled to the range [0, tile_scale]
Geo.units_per_pixel = Geo.tile_scale / Geo.tile_size;

for (var _z = 0; _z <= Geo.max_zoom; _z++) {
    Geo.units_per_meter[_z] = Geo.tile_scale / (Geo.tile_size * Geo.meters_per_pixel[_z]);
}

// Convert tile location to mercator meters - multiply by pixels per tile, then by meters per pixel, adjust for map origin
Geo.metersForTile = function (tile) {
    return {
        x: tile.x * Geo.circumference_meters / Math.pow(2, tile.z) - Geo.half_circumference_meters,
        y: -(tile.y * Geo.circumference_meters / Math.pow(2, tile.z) - Geo.half_circumference_meters)
    };
};

/**
   Given a point in mercator meters and a zoom level, return the tile X/Y/Z that the point lies in
*/
Geo.tileForMeters = function (_ref, zoom) {
    var _ref2 = _slicedToArray(_ref, 2);

    var x = _ref2[0];
    var y = _ref2[1];

    return {
        x: Math.floor((x + Geo.half_circumference_meters) / (Geo.circumference_meters / Math.pow(2, zoom))),
        y: Math.floor((-y + Geo.half_circumference_meters) / (Geo.circumference_meters / Math.pow(2, zoom))),
        z: zoom
    };
};

// Wrap a tile to positive #s for zoom
// Optionally specify the axes to wrap
Geo.wrapTile = function (_ref3) {
    var x = _ref3.x;
    var y = _ref3.y;
    var z = _ref3.z;
    var mask = arguments.length <= 1 || arguments[1] === undefined ? { x: true, y: false } : arguments[1];

    var m = (1 << z) - 1;
    if (mask.x) {
        x = x & m;
    }
    if (mask.y) {
        y = y & m;
    }
    return { x: x, y: y, z: z };
};

/**
   Convert mercator meters to lat-lng
*/
Geo.metersToLatLng = function (_ref4) {
    var _ref42 = _slicedToArray(_ref4, 2);

    var x = _ref42[0];
    var y = _ref42[1];

    x /= Geo.half_circumference_meters;
    y /= Geo.half_circumference_meters;

    y = (2 * Math.atan(Math.exp(y * Math.PI)) - Math.PI / 2) / Math.PI;

    x *= 180;
    y *= 180;

    return [x, y];
};

/**
  Convert lat-lng to mercator meters
*/
Geo.latLngToMeters = function (_ref5) {
    var _ref52 = _slicedToArray(_ref5, 2);

    var x = _ref52[0];
    var y = _ref52[1];

    // Latitude
    y = Math.log(Math.tan(y * Math.PI / 360 + Math.PI / 4)) / Math.PI;
    y *= Geo.half_circumference_meters;

    // Longitude
    x *= Geo.half_circumference_meters / 180;

    return [x, y];
};

Geo.wrapLng = function (x) {
    if (x > 180 || x < -180) {
        x = ((x + 180) % 360 + 360) % 360 - 180;
    }
    return x;
};

// Run an in-place transform function on each cooordinate in a GeoJSON geometry
Geo.transformGeometry = function (geometry, transform) {
    if (geometry == null) {
        return; // skip if missing geometry (valid GeoJSON)
    }

    if (geometry.type === 'Point') {
        transform(geometry.coordinates);
    } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {
        geometry.coordinates.forEach(transform);
    } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {
        geometry.coordinates.forEach(function (coordinates) {
            return coordinates.forEach(transform);
        });
    } else if (geometry.type === 'MultiPolygon') {
        geometry.coordinates.forEach(function (polygon) {
            polygon.forEach(function (coordinates) {
                return coordinates.forEach(transform);
            });
        });
    }
    // TODO: support GeometryCollection
};

Geo.boxIntersect = function (b1, b2) {
    return !(b2.sw.x > b1.ne.x || b2.ne.x < b1.sw.x || b2.sw.y > b1.ne.y || b2.ne.y < b1.sw.y);
};

// Finds the axis-aligned bounding box for a polygon
Geo.findBoundingBox = function (polygon) {
    var min_x = Infinity,
        max_x = -Infinity,
        min_y = Infinity,
        max_y = -Infinity;

    // Only need to examine outer ring (polygon[0])
    var num_coords = polygon[0].length;
    for (var c = 0; c < num_coords; c++) {
        var coord = polygon[0][c];

        if (coord[0] < min_x) {
            min_x = coord[0];
        }
        if (coord[1] < min_y) {
            min_y = coord[1];
        }
        if (coord[0] > max_x) {
            max_x = coord[0];
        }
        if (coord[1] > max_y) {
            max_y = coord[1];
        }
    }

    return [min_x, min_y, max_x, max_y];
};

// Convert geometry type to one of: 'point', 'line', 'polygon'
Geo.geometryType = function (type) {
    if (type === 'Polygon' || type === 'MultiPolygon') {
        return 'polygon';
    } else if (type === 'LineString' || type === 'MultiLineString') {
        return 'line';
    }
    if (type === 'Point' || type === 'MultiPoint') {
        return 'point';
    }
};

Geo.centroid = function (polygon) {
    var n = polygon.length;
    var centroid = [0, 0];

    for (var p = 0; p < polygon.length; p++) {
        centroid[0] += polygon[p][0];
        centroid[1] += polygon[p][1];
    }

    centroid[0] /= n;
    centroid[1] /= n;

    return centroid;
};

Geo.multiCentroid = function (polygons) {
    var n = polygons.length;
    var centroid = [0, 0];

    for (var p = 0; p < polygons.length; p++) {
        var polygon = polygons[p][0];
        var c = Geo.centroid(polygon);
        centroid[0] += c[0];
        centroid[1] += c[1];
    }

    centroid[0] /= n;
    centroid[1] /= n;

    return centroid;
};

Geo.signedPolygonAreaSum = function (polygon) {
    var area = 0;
    var n = polygon.length;

    for (var i = 0; i < n - 1; i++) {
        var p0 = polygon[i];
        var p1 = polygon[i + 1];

        area += p0[0] * p1[1] - p1[0] * p0[1];
    }

    area += polygon[n - 1][0] * polygon[0][1] - polygon[0][0] * polygon[n - 1][1];
    return area;
};

// TODO: subtract inner ring areas
Geo.polygonArea = function (polygon) {
    return Math.abs(Geo.signedPolygonAreaSum(polygon)) / 2;
};

Geo.multiPolygonArea = function (polygons) {
    var area = 0;

    for (var p = 0; p < polygons.length; p++) {
        var polygon = polygons[p][0];
        area += Geo.polygonArea(polygon);
    }

    return area;
};

Geo.ringWinding = function (ring) {
    return Geo.signedPolygonAreaSum(ring) > 0 ? 'CW' : 'CCW';
};

// Enforce winding order on outer/inner rings
// winding: 'CW' or 'CCW'
Geo.enforceWinding = function (geom, winding) {
    var polys = undefined;
    if (geom.type === 'Polygon') {
        polys = [geom.coordinates];
    } else if (geom.type === 'MultiPolygon') {
        polys = geom.coordinates;
    } else {
        return geom;
    }

    for (var p = 0; p < polys.length; p++) {
        var poly = polys[p];

        // If first ring winding doesn't match, reverse all rings
        // NOTE: assumes ring winding orders already alternate as expected
        if (Geo.ringWinding(poly[0]) !== winding) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = _getIterator(poly), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var ring = _step.value;

                    ring.reverse();
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator['return']) {
                        _iterator['return']();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }
    return geom;
};
module.exports = exports['default'];

},{"babel-runtime/core-js/get-iterator":2,"babel-runtime/helpers/sliced-to-array":23}],193:[function(_dereq_,module,exports){
// WebGL constants - need to import these separately to make them available in the web worker

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var gl;
exports["default"] = gl = {};

/* DataType */
gl.BYTE = 0x1400;
gl.UNSIGNED_BYTE = 0x1401;
gl.SHORT = 0x1402;
gl.UNSIGNED_SHORT = 0x1403;
gl.INT = 0x1404;
gl.UNSIGNED_INT = 0x1405;
gl.FLOAT = 0x1406;
module.exports = exports["default"];

},{}],194:[function(_dereq_,module,exports){
// WebGL context wrapper

'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});
var Context;
exports['default'] = Context = {};

// Setup a WebGL context
// If no canvas element is provided, one is created and added to the document body
Context.getContext = function getContext(canvas, options) {
    var fullscreen = false;
    if (canvas == null) {
        canvas = document.createElement('canvas');
        canvas.style.position = 'absolute';
        canvas.style.top = 0;
        canvas.style.left = 0;
        canvas.style.zIndex = -1;
        document.body.appendChild(canvas);
        fullscreen = true;
    }

    var gl = canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);
    if (!gl) {
        throw new Error("Couldn't create WebGL context.");
    }

    Context.resize(gl, window.innerWidth, window.innerHeight, options.device_pixel_ratio);
    if (fullscreen === true) {
        window.addEventListener('resize', function () {
            Context.resize(gl, window.innerWidth, window.innerHeight);
        });
    }

    return gl;
};

Context.resize = function (gl, width, height, device_pixel_ratio) {
    device_pixel_ratio = device_pixel_ratio || window.devicePixelRatio || 1;
    gl.canvas.style.width = width + 'px';
    gl.canvas.style.height = height + 'px';
    gl.canvas.width = Math.round(gl.canvas.style.width * device_pixel_ratio);
    gl.canvas.height = Math.round(gl.canvas.style.width * device_pixel_ratio);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
};
module.exports = exports['default'];

},{}],195:[function(_dereq_,module,exports){
// WebGL extension wrapper
// Stores extensions by name and GL context

"use strict";

var _Map = _dereq_("babel-runtime/core-js/map")["default"];

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports["default"] = getExtension;
var extensions = new _Map(); // map of extensions by GL context

function getExtension(gl, name) {
    var exts = extensions.get(gl);
    if (!exts) {
        extensions.set(gl, new _Map());
        exts = extensions.get(gl);
    }

    if (!exts.get(name)) {
        exts.set(name, gl.getExtension(name));
    }
    return exts.get(name);
}

module.exports = exports["default"];

},{"babel-runtime/core-js/map":4}],196:[function(_dereq_,module,exports){
'use strict';

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});
var GLSL = {};
exports['default'] = GLSL;

/**
    Parse uniforms from a JS object, infers types and returns an array of objects with the
    necessary information to set uniform values on a GL program. Each object in the returned
    array has the form:
    { type, method, name, value }

    type: the GL uniform type, such as 'vec3', 'float', etc.
    method: the GL uniform setter method to use, such as '1f', '3fv', etc.
    name: the fully qualified name of the GL uniform location, e.g. 'array[0].field', etc.
    value: the value to be passed to the GL uniform setter for that type, e.g. [1, 2, 3] for a vec3

    Textures have special behavior: uniforms with string values are treated as textures, and
    the string is used as a unique texture 'key' to be interpreted by the caller (which is responsible
    for actually setting the uniforms). For example, this could be used as a key into a dictionary of
    known texture names, or it could simply be used as a URL to dynamically load the texture from.
*/
GLSL.parseUniforms = function (uniforms) {
    var prefix = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    var parsed = [];

    for (var name in uniforms) {
        var key = name; // save the original name
        var uniform = uniforms[name];
        var u;

        if (prefix) {
            name = prefix + '.' + name;
        }

        // Single float
        if (typeof uniform === 'number') {
            parsed.push({
                type: 'float',
                method: '1f',
                name: name,
                value: uniform,
                key: key,
                uniforms: uniforms
            });
        }
        // Array: vector, array of floats, array of textures, or array of structs
        else if (Array.isArray(uniform)) {
                // Numeric values
                if (typeof uniform[0] === 'number') {
                    // float vectors (vec2, vec3, vec4)
                    if (uniform.length >= 2 && uniform.length <= 4) {
                        parsed.push({
                            type: 'vec' + uniform.length,
                            method: uniform.length + 'fv',
                            name: name,
                            value: uniform,
                            key: key,
                            uniforms: uniforms
                        });
                    }
                    // float array
                    else if (uniform.length > 4) {
                            parsed.push({
                                type: 'float[]',
                                method: '1fv',
                                name: name + '[0]',
                                value: uniform,
                                key: key,
                                uniforms: uniforms
                            });
                        }
                    // TODO: assume matrix for (typeof == Float32Array && length == 16)?
                }
                // Array of textures
                else if (typeof uniform[0] === 'string') {
                        for (u = 0; u < uniform.length; u++) {
                            parsed.push({
                                type: 'sampler2D',
                                method: '1i',
                                name: name + '[' + u + ']',
                                value: uniform[u],
                                key: u,
                                uniforms: uniform
                            });
                        }
                    }
                    // Array of arrays - but only arrays of vectors are allowed in this case
                    else if (Array.isArray(uniform[0]) && typeof uniform[0][0] === 'number') {
                            // float vectors (vec2, vec3, vec4)
                            if (uniform[0].length >= 2 && uniform[0].length <= 4) {
                                // Set each vector in the array
                                for (u = 0; u < uniform.length; u++) {
                                    parsed.push({
                                        type: 'vec' + uniform[0].length,
                                        method: uniform[u].length + 'fv',
                                        name: name + '[' + u + ']',
                                        value: uniform[u],
                                        key: u,
                                        uniforms: uniform
                                    });
                                }
                            }
                            // else error?
                        }
                        // Array of structures
                        else if (typeof uniform[0] === 'object') {
                                for (u = 0; u < uniform.length; u++) {
                                    // Set each struct in the array
                                    parsed.push.apply(parsed, _toConsumableArray(GLSL.parseUniforms(uniform[u], name + '[' + u + ']')));
                                }
                            }
            }
            // Boolean
            else if (typeof uniform === 'boolean') {
                    parsed.push({
                        type: 'bool',
                        method: '1i',
                        name: name,
                        value: uniform,
                        key: key,
                        uniforms: uniforms
                    });
                }
                // Texture
                else if (typeof uniform === 'string') {
                        parsed.push({
                            type: 'sampler2D',
                            method: '1i',
                            name: name,
                            value: uniform,
                            key: key,
                            uniforms: uniforms
                        });
                    }
                    // Structure
                    else if (typeof uniform === 'object') {
                            // Set each field in the struct
                            parsed.push.apply(parsed, _toConsumableArray(GLSL.parseUniforms(uniform, name)));
                        }

        // TODO: support other non-float types? (int, etc.)
    }

    return parsed;
};

/**
    Generate a GLSL variable definition from a JS object
*/
GLSL.defineVariable = function (name, value) {
    var prefix = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

    var type, array;
    var structs = '';
    prefix = prefix ? prefix + '_' + name : name;

    // Single float
    if (typeof value === 'number') {
        type = 'float';
    }
    // Multiple floats - vector or array
    else if (Array.isArray(value)) {
            // Numeric values
            if (typeof value[0] === 'number') {
                // float vectors (vec2, vec3, vec4)
                if (value.length >= 2 && value.length <= 4) {
                    type = 'vec' + value.length;
                }
                // float array
                else {
                        //if (value.length > 4) {
                        type = 'float';
                        array = value.length;
                    }
                // TODO: assume matrix for (typeof == Float32Array && length == 16)?
            }
            // Array of textures
            else if (typeof value[0] === 'string') {
                    type = 'sampler2D';
                    array = value.length;
                }
                // Array of arrays - but only arrays of vectors are allowed in this case
                else if (Array.isArray(value[0]) && typeof value[0][0] === 'number') {
                        // float vectors (vec2, vec3, vec4)
                        if (value[0].length >= 2 && value[0].length <= 4) {
                            type = 'vec' + value[0].length;
                        }
                        // else error?
                        array = value[0].length;
                    }
                    // Array of structures
                    else if (typeof value[0] === 'object') {
                            type = '_type_' + prefix; // custom struct name
                            array = value.length;
                            structs += GLSL.defineStruct(type, value[0], prefix) + '\n'; // build & add to list of dependent structs
                        }
        }
        // Boolean
        else if (typeof value === 'boolean') {
                type = 'bool';
            }
            // Texture
            else if (typeof value === 'string') {
                    type = 'sampler2D';
                }
                // Structure
                else if (typeof value === 'object') {
                        type = '_type_' + prefix; // custom struct name
                        structs += GLSL.defineStruct(type, value, prefix) + '\n'; // build & add to list of dependent structs
                    }

    // Construct variable definition
    var variable = '';
    variable += type + ' ' + name;
    if (array) {
        variable += '[' + array + ']';
    }
    variable += ';\n';

    // Return the variable definition itself, and any dependent struct definitions
    return { variable: variable, structs: structs };
};

/**
    Generate a GLSL structure definition from a JS object
*/
GLSL.defineStruct = function (type, value) {
    var prefix = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

    var struct = 'struct ' + type + ' {\n';
    var dependents = '';
    for (var field in value) {
        var subvar = GLSL.defineVariable(field, value[field], prefix);
        struct += '    ' + subvar.variable;
        dependents += subvar.structs;
    }
    struct += '};\n';
    struct = dependents + struct;
    return struct;
};

/**
    Generate a GLSL uniform definition from a JS object
*/
GLSL.defineUniform = function (name, value) {
    var def = GLSL.defineVariable(name, value);
    def = def.structs + 'uniform ' + def.variable;
    return def;
};

/**
    Check for a uniform definition of 'name' in the provided GLSL source
    Simple regex check for 'uniform' keyword and var name, does not attempt to parse/extract GLSL
    NOTE: assumes comments have been stripped from source
*/
GLSL.isUniformDefined = function (name, source) {
    // Match, in order:
    // - the keyword 'uniform'
    // - at least one character that is anything except a semicolon, ;
    // - optionally, anything enclosed in curly braces, { ... } (an inline structure definition can go here)
    // - optionally, any # of characters that is not a semicolon, ;
    // - the name of the uniform

    var re = new RegExp('uniform[^;]+(?:{[\\s\\S]*})?[^;]*\\b' + name + '\\b', 'g');
    if (source.match(re)) {
        return true;
    }
    return false;
};

/**
    Check that a symbol is referenced in the GLSL source
    NOTE: assumes comments have been stripped from source
*/
GLSL.isSymbolReferenced = function (name, source) {
    var re = new RegExp('\\b' + name + '\\b', 'g');
    if (source.search(re) >= 0) {
        return true;
    }
    return false;
};

/**
    Expand a single value or 2-element array into a 3-element array, with the last ( z )
    coordinate defaulting to 1 (with option to specify). Also runs parseFloat to try to maintain
    data integrity. Returns null if input couldn't be parsed.
*/
GLSL.expandVec3 = function (v) {
    var z = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

    var x = undefined;
    if (Array.isArray(v) && v.length === 2) {
        x = [].concat(_toConsumableArray(v), [z]).map(parseFloat);
    } else {
        x = [v, v, v].map(parseFloat);
    }

    if (x && x.every(function (n) {
        return typeof n === 'number' && !isNaN(n);
    })) {
        return x;
    }
};

/**
    Expand a single value or 3-element array into a 4-element array, with the last (e.g. w or a)
    coordinate defaulting to 1 (with option to specify). Also runs parseFloat to try to maintain
    data integrity. Returns null if input couldn't be parsed.
*/
GLSL.expandVec4 = function (v) {
    var w = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

    var x = undefined;
    if (Array.isArray(v) && v.length === 3) {
        x = [].concat(_toConsumableArray(v), [w]).map(parseFloat);
    } else {
        x = [v, v, v, w].map(parseFloat);
    }

    if (x && x.every(function (n) {
        return typeof n === 'number' && !isNaN(n);
    })) {
        return x;
    }
};
module.exports = exports['default'];

},{"babel-runtime/helpers/to-consumable-array":24}],197:[function(_dereq_,module,exports){
"use strict";

var _createClass = _dereq_("babel-runtime/helpers/create-class")["default"];

var _classCallCheck = _dereq_("babel-runtime/helpers/class-call-check")["default"];

Object.defineProperty(exports, "__esModule", {
        value: true
});

var RenderState = (function () {
        function RenderState(value, setup) {
                _classCallCheck(this, RenderState);

                setup(value);
                this.value = value;
                this.setup = setup;
        }

        _createClass(RenderState, [{
                key: "set",
                value: function set(value) {
                        // if the states are different, call the GL context for a state change
                        if (JSON.stringify(this.value) !== JSON.stringify(value)) {
                                this.setup(value);
                                this.value = value;
                        }
                }
        }], [{
                key: "initialize",
                value: function initialize(gl) {
                        // Culling
                        RenderState.culling = new RenderState({ cull: true, face: gl.BACK }, function (value) {
                                if (value.cull) {
                                        gl.enable(gl.CULL_FACE);
                                        gl.cullFace(value.face);
                                } else {
                                        gl.disable(gl.CULL_FACE);
                                }
                        });

                        // Blending mode
                        RenderState.blending = new RenderState({ blend: false, src: gl.SRC_ALPHA, dst: gl.ONE_MINUS_SRC_ALPHA, src_alpha: gl.ONE, dst_alpha: gl.ONE_MINUS_SRC_ALPHA }, function (value) {
                                if (value.blend) {
                                        gl.enable(gl.BLEND);

                                        if (value.src_alpha && value.dst_alpha) {
                                                gl.blendFuncSeparate(value.src, value.dst, value.src_alpha, value.dst_alpha);
                                        } else {
                                                gl.blendFunc(value.src, value.dst);
                                        }
                                } else {
                                        gl.disable(gl.BLEND);
                                }
                        });

                        // Depth write
                        RenderState.depth_write = new RenderState({ depth_write: true }, function (value) {
                                gl.depthMask(value.depth_write);
                        });

                        // Depth test
                        RenderState.depth_test = new RenderState({ depth_test: true, depth_func: gl.LEQUAL }, function (value) {
                                if (value.depth_test) {
                                        gl.enable(gl.DEPTH_TEST);
                                        gl.depthFunc(value.depth_func);
                                } else {
                                        gl.disable(gl.DEPTH_TEST);
                                }
                        });
                }
        }]);

        return RenderState;
})();

exports["default"] = RenderState;
module.exports = exports["default"];

},{"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18}],198:[function(_dereq_,module,exports){
/* global ShaderProgram */
// GL program wrapper to cache uniform locations/values, do compile-time pre-processing
// (injecting #defines and #pragma blocks into shaders), etc.

'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _glsl = _dereq_('./glsl');

var _glsl2 = _interopRequireDefault(_glsl);

var _texture = _dereq_('./texture');

var _texture2 = _interopRequireDefault(_texture);

var _extensions = _dereq_('./extensions');

var _extensions2 = _interopRequireDefault(_extensions);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var _stripComments = _dereq_('strip-comments');

var _stripComments2 = _interopRequireDefault(_stripComments);

var _glShaderErrors = _dereq_('gl-shader-errors');

var _glShaderErrors2 = _interopRequireDefault(_glShaderErrors);

var ShaderProgram = (function () {
    function ShaderProgram(gl, vertex_source, fragment_source, options) {
        _classCallCheck(this, ShaderProgram);

        options = options || {};

        this.gl = gl;
        this.program = null;
        this.compiled = false;
        this.compiling = false;
        this.error = null;

        // key/values inserted as #defines into shaders at compile-time
        this.defines = _Object$assign({}, options.defines || {});

        // key/values for blocks that can be injected into shaders at compile-time
        this.blocks = _Object$assign({}, options.blocks || {});
        this.block_scopes = _Object$assign({}, options.block_scopes || {});

        // list of extensions to activate
        this.extensions = options.extensions || [];

        // JS-object uniforms that are expected by this program
        // If they are not found in the existing shader source, their types will be inferred and definitions
        // for each will be injected.
        this.dependent_uniforms = options.uniforms;

        this.uniforms = {}; // program locations of uniforms, lazily added as each uniform is set
        this.attribs = {}; // program locations of vertex attributes, lazily added as each attribute is accessed

        this.vertex_source = vertex_source;
        this.fragment_source = fragment_source;

        this.id = ShaderProgram.id++;
        ShaderProgram.programs[this.id] = this;
        this.name = options.name; // can provide a program name (useful for debugging)
    }

    // Static methods and state

    _createClass(ShaderProgram, [{
        key: 'destroy',
        value: function destroy() {
            this.gl.useProgram(null);
            this.gl.deleteProgram(this.program);
            this.program = null;
            this.uniforms = {};
            this.attribs = {};
            delete ShaderProgram.programs[this.id];
            this.compiled = false;
        }

        // Use program wrapper with simple state cache
    }, {
        key: 'use',
        value: function use() {
            if (!this.compiled) {
                return;
            }

            if (ShaderProgram.current !== this) {
                this.gl.useProgram(this.program);
            }
            ShaderProgram.current = this;
        }
    }, {
        key: 'compile',
        value: function compile() {
            if (this.compiling) {
                throw new Error('ShaderProgram.compile(): skipping for ' + this.id + ' (' + this.name + ') because already compiling');
            }
            this.compiling = true;
            this.compiled = false;
            this.error = null;

            // Copy sources from pre-modified template
            this.computed_vertex_source = this.vertex_source;
            this.computed_fragment_source = this.fragment_source;

            // Check for extension availability
            var extensions = this.checkExtensions();

            // Make list of defines to be injected later
            var defines = this.buildDefineList();

            // Inject user-defined blocks (arbitrary code points matching named #pragmas)
            // Replace according to this pattern:
            // #pragma tangram: [key]
            // e.g. #pragma tangram: global

            // Gather all block code snippets
            var blocks = this.buildShaderBlockList();
            var regexp;

            for (var key in blocks) {
                var block = blocks[key];
                if (!block || Array.isArray(block) && block.length === 0) {
                    continue;
                }

                // First find code replace points in shaders
                regexp = new RegExp('^\\s*#pragma\\s+tangram:\\s+' + key + '\\s*$', 'm');
                var inject_vertex = this.computed_vertex_source.match(regexp);
                var inject_fragment = this.computed_fragment_source.match(regexp);

                // Avoid network request if nothing to replace
                if (inject_vertex == null && inject_fragment == null) {
                    continue;
                }

                // Combine all blocks into one string
                var source = '';
                block.forEach(function (val) {
                    // Mark start and end of each block with metadata (which can be extracted from
                    // final source for error handling, debugging, etc.)
                    var mark = val.scope + ', ' + val.key + ', ' + val.num;
                    source += '\n// tangram-block-start: ' + mark + '\n';
                    source += val.source;
                    source += '\n// tangram-block-end: ' + mark + '\n';
                });

                // Inject
                if (inject_vertex != null) {
                    this.computed_vertex_source = this.computed_vertex_source.replace(regexp, source);
                }
                if (inject_fragment != null) {
                    this.computed_fragment_source = this.computed_fragment_source.replace(regexp, source);
                }

                // Add a #define for this injection point
                defines['TANGRAM_BLOCK_' + key.replace(/[\s-]+/g, '_').toUpperCase()] = true;
            }

            // Clean-up any #pragmas that weren't replaced (to prevent compiler warnings)
            regexp = new RegExp('^\\s*#pragma.*$', 'gm');
            this.computed_vertex_source = this.computed_vertex_source.replace(regexp, '');
            this.computed_fragment_source = this.computed_fragment_source.replace(regexp, '');

            // Detect uniform definitions, inject any missing ones
            this.ensureUniforms(this.dependent_uniforms);

            // Build & inject extensions & defines
            // This is done *after* code injection so that we can add defines for which code points were injected
            var info = this.name ? this.name + ' / id ' + this.id : 'id ' + this.id;
            var header = '// Program: ' + info + '\n' + ShaderProgram.buildExtensionString(extensions);

            defines['TANGRAM_VERTEX_SHADER'] = true;
            defines['TANGRAM_FRAGMENT_SHADER'] = false;
            this.computed_vertex_source = header + ShaderProgram.buildDefineString(defines) + this.computed_vertex_source;

            defines['TANGRAM_VERTEX_SHADER'] = false;
            defines['TANGRAM_FRAGMENT_SHADER'] = true;
            this.computed_fragment_source = header + ShaderProgram.buildDefineString(defines) + this.computed_fragment_source;

            // Add precision qualifier
            this.computed_fragment_source = '#ifdef GL_ES\nprecision highp float;\n#endif\n\n' + this.computed_fragment_source;

            // Compile & set uniforms to cached values
            try {
                this.program = ShaderProgram.updateProgram(this.gl, this.program, this.computed_vertex_source, this.computed_fragment_source);
                this.compiled = true;
                this.compiling = false;
            } catch (error) {
                this.program = null;
                this.compiled = false;
                this.compiling = false;
                this.error = error;

                // shader error info
                if (error.type === 'vertex' || error.type === 'fragment') {
                    this.shader_errors = error.errors;
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = _getIterator(this.shader_errors), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var e = _step.value;

                            e.type = error.type;
                            e.block = this.block(error.type, e.line);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator['return']) {
                                _iterator['return']();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }

                throw new Error('ShaderProgram.compile(): program ' + this.id + ' (' + this.name + ') error:', error);
            }

            this.use();
            this.refreshUniforms();
            this.refreshAttributes();
        }

        // Make list of defines (global, then program-specific)
    }, {
        key: 'buildDefineList',
        value: function buildDefineList() {
            var d,
                defines = {};
            for (d in ShaderProgram.defines) {
                defines[d] = ShaderProgram.defines[d];
            }
            for (d in this.defines) {
                defines[d] = this.defines[d];
            }
            return defines;
        }

        // Make list of shader blocks (global, then program-specific)
    }, {
        key: 'buildShaderBlockList',
        value: function buildShaderBlockList() {
            var key = undefined,
                blocks = {};

            // Global blocks
            for (key in ShaderProgram.blocks) {
                blocks[key] = [];

                if (Array.isArray(ShaderProgram.blocks[key])) {
                    var _blocks$key;

                    (_blocks$key = blocks[key]).push.apply(_blocks$key, _toConsumableArray(ShaderProgram.blocks[key].map(function (source, num) {
                        return { key: key, source: source, num: num, scope: 'ShaderProgram' };
                    })));
                } else {
                    blocks[key] = [{ key: key, source: ShaderProgram.blocks[key], num: 0, scope: 'ShaderProgram' }];
                }
            }

            // Program-specific blocks
            for (key in this.blocks) {
                blocks[key] = blocks[key] || [];

                if (Array.isArray(this.blocks[key])) {
                    var scopes = this.block_scopes && this.block_scopes[key] || [];
                    var cur_scope = null,
                        num = 0;

                    for (var b = 0; b < this.blocks[key].length; b++) {
                        // Count blocks relative to current scope
                        if (scopes[b] !== cur_scope) {
                            cur_scope = scopes[b];
                            num = 0;
                        }

                        blocks[key].push({
                            key: key,
                            source: this.blocks[key][b],
                            num: num,
                            scope: cur_scope || this.name
                        });

                        num++;
                    }
                } else {
                    // TODO: address discrepancy in array vs. single-value blocks
                    // styles assume array when tracking block scopes
                    blocks[key].push({ key: key, source: this.blocks[key], num: 0, scope: this.name });
                }
            }
            return blocks;
        }

        // Detect uniform definitions, inject any missing ones
    }, {
        key: 'ensureUniforms',
        value: function ensureUniforms(uniforms) {
            if (!uniforms) {
                return;
            }

            var vs = (0, _stripComments2['default'])(this.computed_vertex_source);
            var fs = (0, _stripComments2['default'])(this.computed_fragment_source);
            var inject,
                vs_injections = [],
                fs_injections = [];

            // Check for missing uniform definitions
            for (var name in uniforms) {
                inject = null;

                // Check vertex shader
                if (!_glsl2['default'].isUniformDefined(name, vs) && _glsl2['default'].isSymbolReferenced(name, vs)) {
                    if (!inject) {
                        inject = _glsl2['default'].defineUniform(name, uniforms[name]);
                    }
                    _loglevel2['default'].trace('Program ' + this.name + ': ' + name + ' not defined in vertex shader, injecting: \'' + inject + '\'');
                    vs_injections.push(inject);
                }
                // Check fragment shader
                if (!_glsl2['default'].isUniformDefined(name, fs) && _glsl2['default'].isSymbolReferenced(name, fs)) {
                    if (!inject) {
                        inject = _glsl2['default'].defineUniform(name, uniforms[name]);
                    }
                    _loglevel2['default'].trace('Program ' + this.name + ': ' + name + ' not defined in fragment shader, injecting: \'' + inject + '\'');
                    fs_injections.push(inject);
                }
            }

            // Inject missing uniforms
            // NOTE: these are injected at the very top of the shaders, even before any #defines or #pragmas are added
            // this could cause some issues with certain #pragmas, or other functions that might expect #defines
            if (vs_injections.length > 0) {
                this.computed_vertex_source = vs_injections.join('\n') + this.computed_vertex_source;
            }

            if (fs_injections.length > 0) {
                this.computed_fragment_source = fs_injections.join('\n') + this.computed_fragment_source;
            }
        }

        // Set uniforms from a JS object, with inferred types
    }, {
        key: 'setUniforms',
        value: function setUniforms(uniforms) {
            var reset_texture_unit = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

            if (!this.compiled) {
                return;
            }

            // TODO: only update uniforms when changed

            // Texture units must be tracked and incremented each time a texture sampler uniform is set.
            // By default, the texture unit is reset to 0 each time setUniforms is called, but they can
            // also be preserved, for example in cases where multiple calls to setUniforms are expected
            // (e.g. program-specific uniforms followed by mesh-specific ones).
            if (reset_texture_unit) {
                this.texture_unit = 0;
            }

            // Parse uniform types and values from the JS object
            var parsed = _glsl2['default'].parseUniforms(uniforms);

            // Set each uniform
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = _getIterator(parsed), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var uniform = _step2.value;

                    if (uniform.type === 'sampler2D') {
                        // For textures, we need to track texture units, so we have a special setter
                        this.setTextureUniform(uniform.name, uniform.value);
                    } else {
                        this.uniform(uniform.method, uniform.name, uniform.value);
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                        _iterator2['return']();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
        }

        // Cache some or all uniform values so they can be restored
    }, {
        key: 'saveUniforms',
        value: function saveUniforms(subset) {
            var uniforms = subset || this.uniforms;
            for (var u in uniforms) {
                var uniform = this.uniforms[u];
                if (uniform) {
                    uniform.saved_value = uniform.value;
                }
            }
            this.saved_texture_unit = this.texture_unit || 0;
        }

        // Restore some or all uniforms to saved values
    }, {
        key: 'restoreUniforms',
        value: function restoreUniforms(subset) {
            var uniforms = subset || this.uniforms;
            for (var u in uniforms) {
                var uniform = this.uniforms[u];
                if (uniform && uniform.saved_value) {
                    uniform.value = uniform.saved_value;
                    this.updateUniform(u);
                }
            }
            this.texture_unit = this.saved_texture_unit || 0;
        }

        // Set a texture uniform, finds texture by name or creates a new one
    }, {
        key: 'setTextureUniform',
        value: function setTextureUniform(uniform_name, texture_name) {
            var texture = _texture2['default'].textures[texture_name];
            if (texture == null) {
                texture = new _texture2['default'](this.gl, texture_name);
                texture.load(texture_name);
            }

            texture.bind(this.texture_unit);
            this.uniform('1i', uniform_name, this.texture_unit);
            this.texture_unit++; // TODO: track max texture units and log/throw errors
        }

        // ex: program.uniform('3f', 'position', x, y, z);
        // TODO: only update uniforms when changed
    }, {
        key: 'uniform',
        value: function uniform(method, name) {
            // 'value' is a method-appropriate arguments list
            if (!this.compiled) {
                return;
            }

            this.uniforms[name] = this.uniforms[name] || {};
            var uniform = this.uniforms[name];
            uniform.name = name;
            if (uniform.location === undefined) {
                uniform.location = this.gl.getUniformLocation(this.program, name);
            }
            uniform.method = 'uniform' + method;

            for (var _len = arguments.length, value = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                value[_key - 2] = arguments[_key];
            }

            uniform.value = value;
            this.updateUniform(name);
        }

        // Set a single uniform
    }, {
        key: 'updateUniform',
        value: function updateUniform(name) {
            if (!this.compiled) {
                return;
            }

            var uniform = this.uniforms[name];
            if (!uniform || uniform.location == null) {
                return;
            }

            this.use();
            this.gl[uniform.method].apply(this.gl, [uniform.location].concat(uniform.value)); // call appropriate GL uniform method and pass through arguments
        }

        // Refresh uniform locations and set to last cached values
    }, {
        key: 'refreshUniforms',
        value: function refreshUniforms() {
            if (!this.compiled) {
                return;
            }

            for (var u in this.uniforms) {
                this.uniforms[u].location = this.gl.getUniformLocation(this.program, u);
                this.updateUniform(u);
            }
        }
    }, {
        key: 'refreshAttributes',
        value: function refreshAttributes() {
            // var len = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES);
            // for (var i=0; i < len; i++) {
            //     var a = this.gl.getActiveAttrib(this.program, i);
            // }
            this.attribs = {};
        }

        // Get the location of a vertex attribute
    }, {
        key: 'attribute',
        value: function attribute(name) {
            if (!this.compiled) {
                return;
            }

            var attrib = this.attribs[name] = this.attribs[name] || {};
            if (attrib.location != null) {
                return attrib;
            }

            attrib.name = name;
            attrib.location = this.gl.getAttribLocation(this.program, name);

            // var info = this.gl.getActiveAttrib(this.program, attrib.location);
            // attrib.type = info.type;
            // attrib.size = info.size;

            return attrib;
        }

        // Get shader source as string
    }, {
        key: 'source',
        value: function source(type) {
            if (type === 'vertex') {
                return this.computed_vertex_source;
            } else if (type === 'fragment') {
                return this.computed_fragment_source;
            }
        }

        // Get shader source as array of line strings
    }, {
        key: 'lines',
        value: function lines(type) {
            var source = this.source(type);
            if (source) {
                return source.split('\n');
            }
            return [];
        }

        // Get a specific line from shader source
    }, {
        key: 'line',
        value: function line(type, num) {
            var source = this.lines(type);
            if (source) {
                return source[num];
            }
        }

        // Get info on which shader block (if any) a particular line number in a shader is in
        // Returns an object with the following info if a block is found: { name, line, source }
        //  scope: where the shader block originated, either a style name, or global such as ShaderProgram
        //  name: shader block name (e.g. 'color', 'position', 'global')
        //  num: the block number *within* local scope (e.g. if a style has multiple 'color' blocks)
        //  line: line number *within* the shader block (not the whole shader program), useful for error highlighting
        //  source: the code for the line
        // NOTE: this does a bruteforce loop over the shader source and looks for shader block start/end markers
        // We could track line ranges for shader blocks as they are inserted, but as this code is only used for
        // error handling on compilation failure, it was simpler to keep it separate than to burden the core
        // compilation path.
    }, {
        key: 'block',
        value: function block(type, num) {
            var lines = this.lines(type);
            var block = undefined;
            for (var i = 0; i < num && i < lines.length; i++) {
                var line = lines[i];
                var match = line.match(/\/\/ tangram-block-start: ([A-Za-z0-9_-]+), ([A-Za-z0-9_-]+), (\d+)/);
                if (match && match.length > 1) {
                    // mark current block
                    block = {
                        scope: match[1],
                        name: match[2],
                        num: match[3]
                    };
                } else {
                    match = line.match(/\/\/ tangram-block-end: ([A-Za-z0-9_-]+), ([A-Za-z0-9_-]+), (\d+)/);
                    if (match && match.length > 1) {
                        block = null; // clear current block
                    }
                }

                // update line # and content
                if (block) {
                    // init to -1 so that line 0 is first actual line of block code, after comment marker
                    block.line = block.line == null ? -1 : block.line + 1;
                    block.source = line;
                }
            }
            return block;
        }

        // Returns list of available extensions from those requested
        // Sets internal #defines indicating availability of each requested extension
    }, {
        key: 'checkExtensions',
        value: function checkExtensions() {
            var exts = [];
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = _getIterator(this.extensions), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var _name = _step3.value;

                    var ext = (0, _extensions2['default'])(this.gl, _name);
                    var def = 'TANGRAM_EXTENSION_' + _name;

                    this.defines[def] = ext != null;

                    if (ext) {
                        exts.push(_name);
                    } else {
                        _loglevel2['default'].debug('Could not enable extension \'' + _name + '\'');
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                        _iterator3['return']();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            return exts;
        }
    }]);

    return ShaderProgram;
})();

exports['default'] = ShaderProgram;
ShaderProgram.id = 0; // assign each program a unique id
ShaderProgram.programs = {}; // programs, by id
ShaderProgram.current = null; // currently bound program

// Global config applied to all programs (duplicate properties for a specific program will take precedence)
ShaderProgram.defines = {};
ShaderProgram.blocks = {};

// Turn an object of key/value pairs into single string of #define statements
ShaderProgram.buildDefineString = function (defines) {
    var define_str = "";
    for (var d in defines) {
        if (defines[d] === false) {
            continue;
        } else if (typeof defines[d] === 'boolean' && defines[d] === true) {
            // booleans are simple defines with no value
            define_str += "#define " + d + "\n";
        } else if (typeof defines[d] === 'number' && Math.floor(defines[d]) === defines[d]) {
            // int to float conversion to satisfy GLSL floats
            define_str += "#define " + d + " " + defines[d].toFixed(1) + "\n";
        } else {
            // any other float or string value
            define_str += "#define " + d + " " + defines[d] + "\n";
        }
    }
    return define_str;
};

// Turn a list of extension names into single string of #extension statements
ShaderProgram.buildExtensionString = function (extensions) {
    extensions = extensions || [];
    var str = "";
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
        for (var _iterator4 = _getIterator(extensions), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var ext = _step4.value;

            str += '#extension GL_' + ext + ' : enable\n';
        }
    } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                _iterator4['return']();
            }
        } finally {
            if (_didIteratorError4) {
                throw _iteratorError4;
            }
        }
    }

    return str;
};

ShaderProgram.addBlock = function (key) {
    var _ShaderProgram$blocks$key;

    ShaderProgram.blocks[key] = ShaderProgram.blocks[key] || [];

    for (var _len2 = arguments.length, blocks = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        blocks[_key2 - 1] = arguments[_key2];
    }

    (_ShaderProgram$blocks$key = ShaderProgram.blocks[key]).push.apply(_ShaderProgram$blocks$key, blocks);
};

// Remove all global shader blocks for a given key
ShaderProgram.removeBlock = function (key) {
    ShaderProgram.blocks[key] = [];
};

ShaderProgram.replaceBlock = function (key) {
    ShaderProgram.removeBlock(key);

    for (var _len3 = arguments.length, blocks = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        blocks[_key3 - 1] = arguments[_key3];
    }

    ShaderProgram.addBlock.apply(ShaderProgram, [key].concat(blocks));
};

// Compile & link a WebGL program from provided vertex and fragment shader sources
// update a program if one is passed in. Create one if not. Alert and don't update anything if the shaders don't compile.
ShaderProgram.updateProgram = function (gl, program, vertex_shader_source, fragment_shader_source) {
    try {
        var vertex_shader = ShaderProgram.createShader(gl, vertex_shader_source, gl.VERTEX_SHADER);
        var fragment_shader = ShaderProgram.createShader(gl, fragment_shader_source, gl.FRAGMENT_SHADER);
    } catch (err) {
        _loglevel2['default'].error(err.message);
        throw err;
    }

    gl.useProgram(null);
    if (program != null) {
        var old_shaders = gl.getAttachedShaders(program);
        for (var i = 0; i < old_shaders.length; i++) {
            gl.detachShader(program, old_shaders[i]);
        }
    } else {
        program = gl.createProgram();
    }

    if (vertex_shader == null || fragment_shader == null) {
        return program;
    }

    gl.attachShader(program, vertex_shader);
    gl.attachShader(program, fragment_shader);

    gl.deleteShader(vertex_shader);
    gl.deleteShader(fragment_shader);

    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        var message = new Error('WebGL program error:\n            VALIDATE_STATUS: ' + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + '\n            ERROR: ' + gl.getError() + '\n            --- Vertex Shader ---\n            ' + vertex_shader_source + '\n            --- Fragment Shader ---\n            ' + fragment_shader_source);

        var error = { type: 'program', message: message };
        _loglevel2['default'].error(error.message);
        throw error;
    }

    return program;
};

// Compile a vertex or fragment shader from provided source
ShaderProgram.createShader = function (gl, source, stype) {
    var shader = gl.createShader(stype);

    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        var type = stype === gl.VERTEX_SHADER ? 'vertex' : 'fragment';
        var message = gl.getShaderInfoLog(shader);
        var errors = (0, _glShaderErrors2['default'])(message);
        throw { type: type, message: message, errors: errors };
    }

    return shader;
};
module.exports = exports['default'];

},{"./extensions":195,"./glsl":196,"./texture":200,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/assign":6,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/interop-require-default":22,"babel-runtime/helpers/to-consumable-array":24,"gl-shader-errors":147,"loglevel":179,"strip-comments":184}],199:[function(_dereq_,module,exports){
// Generated from GLSL files, don't edit!
"use strict";

var shaderSources = {};

shaderSources['gl/shaders/accessors'] = "// Vertex position in model space: [0, 1] range over the local tile\n" + "// Note positions can be outside that range due to unclipped geometry, geometry higher than a unit cube, etc.\n" + "#ifdef TANGRAM_VERTEX_SHADER\n" + "\n" + "vec4 modelPosition() {\n" + "    return vec4(SHORT(a_position.xyz) / TANGRAM_TILE_SCALE, 1.);\n" + "}\n" + "\n" + "#endif\n" + "\n" + "// Vertex position in world coordinates, useful for 3d procedural textures, etc.\n" + "vec4 worldPosition() {\n" + "    return v_world_position;\n" + "}\n" + "\n" + "// Optionally wrap world coordinates (allows more precision at higher zooms)\n" + "// e.g. at wrap 1000, the world space will wrap every 1000 meters\n" + "#ifdef TANGRAM_VERTEX_SHADER\n" + "\n" + "vec4 wrapWorldPosition(vec4 world_position) {\n" + "    #if defined(TANGRAM_WORLD_POSITION_WRAP)\n" + "    vec2 anchor = u_tile_origin.xy - mod(u_tile_origin.xy, TANGRAM_WORLD_POSITION_WRAP);\n" + "        world_position.xy -= anchor;\n" + "    #endif\n" + "    return world_position;\n" + "}\n" + "\n" + "#endif\n" + "\n" + "// Normal in world space\n" + "#if defined(TANGRAM_VERTEX_SHADER)\n" + "\n" + "vec3 worldNormal() {\n" + "    return TANGRAM_NORMAL;\n" + "}\n" + "\n" + "#elif defined(TANGRAM_FRAGMENT_SHADER)\n" + "\n" + "vec3 worldNormal() {\n" + "    return u_inverseNormalMatrix * TANGRAM_NORMAL;\n" + "}\n" + "\n" + "#endif\n" + "";

shaderSources['gl/shaders/ambientLight'] = "/*\n" + "\n" + "Expected globals:\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct AmbientLight {\n" + "    vec4 ambient;\n" + "};\n" + "\n" + "void calculateLight(in AmbientLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "    light_accumulator_ambient += _light.ambient;\n" + "}\n" + "";

shaderSources['gl/shaders/directionalLight'] = "/*\n" + "\n" + "Expected globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct DirectionalLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec3 direction;\n" + "};\n" + "\n" + "void calculateLight(in DirectionalLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "\n" + "    light_accumulator_ambient += _light.ambient;\n" + "\n" + "    float nDotVP = clamp(dot(_normal, -normalize(_light.direction)), 0.0, 1.0);\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        light_accumulator_diffuse += _light.diffuse * nDotVP;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        float pf = 0.0;\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(normalize(_light.direction), _normal);\n" + "            float eyeDotR = max(dot(normalize(_eyeToPoint), reflectVector), 0.0);\n" + "            pf = pow(eyeDotR, material.shininess);\n" + "        }\n" + "        light_accumulator_specular += _light.specular * pf;\n" + "    #endif\n" + "}\n" + "";

shaderSources['gl/shaders/layer_order'] = "// Apply layer ordering to avoid z-fighting\n" + "void applyLayerOrder (float layer, inout vec4 position) {\n" + "    position.z -= layer * TANGRAM_LAYER_DELTA * position.w;\n" + "}\n" + "";

shaderSources['gl/shaders/material'] = "/*\n" + "\n" + "Defines globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "\n" + "// MATERIALS\n" + "//\n" + "struct Material {\n" + "    #ifdef TANGRAM_MATERIAL_EMISSION\n" + "        vec4 emission;\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE\n" + "            vec3 emissionScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_AMBIENT\n" + "        vec4 ambient;\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE\n" + "            vec3 ambientScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        vec4 diffuse;\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE\n" + "            vec3 diffuseScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        vec4 specular;\n" + "        float shininess;\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE\n" + "            vec3 specularScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "        vec3 normalScale;\n" + "        float normalAmount;\n" + "    #endif\n" + "};\n" + "\n" + "// Note: uniform is copied to a global instance to allow modification\n" + "uniform Material u_material;\n" + "Material material;\n" + "\n" + "#ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE\n" + "uniform sampler2D u_material_emission_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE\n" + "uniform sampler2D u_material_ambient_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE\n" + "uniform sampler2D u_material_diffuse_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE\n" + "uniform sampler2D u_material_specular_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "uniform sampler2D u_material_normal_texture;\n" + "#endif\n" + "\n" + "// Global light accumulators for each property\n" + "vec4 light_accumulator_ambient = vec4(0.0);\n" + "vec4 light_accumulator_diffuse = vec4(0.0);\n" + "#ifdef TANGRAM_MATERIAL_SPECULAR\n" + "    vec4 light_accumulator_specular = vec4(0.0);\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_TEXTURE_SPHEREMAP\n" + "vec4 getSphereMap (in sampler2D _tex, in vec3 _eyeToPoint, in vec3 _normal, in vec2 _skew) {\n" + "    vec3 eye = normalize(_eyeToPoint);\n" + "    eye.xy -= _skew;\n" + "    eye = normalize(eye);\n" + "\n" + "    vec3 r = reflect(eye, _normal);\n" + "    r.z += 1.0;\n" + "    float m = 2. * length(r);\n" + "    vec2 uv = r.xy / m + .5;\n" + "    return texture2D(_tex, uv);\n" + "}\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_TEXTURE_TRIPLANAR\n" + "vec3 getTriPlanarBlend (in vec3 _normal) {\n" + "    vec3 blending = abs(_normal);\n" + "    blending = normalize(max(blending, 0.00001));\n" + "    float b = (blending.x + blending.y + blending.z);\n" + "    return blending / b;\n" + "}\n" + "\n" + "vec4 getTriPlanar (in sampler2D _tex, in vec3 _pos, in vec3 _normal, in vec3 _scale) {\n" + "    vec3 blending = getTriPlanarBlend(_normal);\n" + "    vec4 xaxis = texture2D(_tex, fract(_pos.yz * _scale.x));\n" + "    vec4 yaxis = texture2D(_tex, fract(_pos.xz * _scale.y));\n" + "    vec4 zaxis = texture2D(_tex, fract(_pos.xy * _scale.z));\n" + "    return  xaxis * blending.x + yaxis * blending.y + zaxis * blending.z;\n" + "}\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_TEXTURE_PLANAR\n" + "vec4 getPlanar (in sampler2D _tex, in vec3 _pos, in vec2 _scale) {\n" + "    return texture2D( _tex, fract(_pos.xy * _scale.x) );\n" + "}\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "void calculateNormal (inout vec3 _normal) {\n" + "    // Get NORMALMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE_UV\n" + "    _normal += texture2D(u_material_normal_texture, fract(v_texcoord*material.normalScale.xy)).rgb*2.0-1.0;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE_PLANAR\n" + "    vec3 normalTex = getPlanar(u_material_normal_texture, v_world_position.xyz, material.normalScale.xy).rgb*2.0-1.0;\n" + "    _normal += normalTex;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE_TRIPLANAR\n" + "    vec3 normalTex = getTriPlanar(u_material_normal_texture, v_world_position.xyz, _normal, material.normalScale).rgb*2.0-1.0;\n" + "    _normal += normalTex;\n" + "    #endif\n" + "\n" + "    _normal = normalize(_normal);\n" + "}\n" + "#endif\n" + "\n" + "void calculateMaterial (in vec3 _eyeToPoint, inout vec3 _normal) {\n" + "    // get EMISSION TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_UV\n" + "        material.emission *= texture2D(u_material_emission_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_PLANAR\n" + "        material.emission *= getPlanar(u_material_emission_texture, v_world_position.xyz, material.emissionScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_TRIPLANAR\n" + "        material.emission *= getTriPlanar(u_material_emission_texture, v_world_position.xyz, _normal, material.emissionScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_SPHEREMAP\n" + "        material.emission *= getSphereMap(u_material_emission_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // get AMBIENT TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_UV\n" + "        material.ambient *= texture2D(u_material_ambient_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_PLANAR\n" + "        material.ambient *= getPlanar(u_material_ambient_texture, v_world_position.xyz, material.ambientScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_TRIPLANAR\n" + "        material.ambient *= getTriPlanar(u_material_ambient_texture, v_world_position.xyz, _normal, material.ambientScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_SPHEREMAP\n" + "        material.ambient *= getSphereMap(u_material_ambient_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // get DIFFUSE TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_UV\n" + "        material.diffuse *= texture2D(u_material_diffuse_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_PLANAR\n" + "        material.diffuse *= getPlanar(u_material_diffuse_texture, v_world_position.xyz, material.diffuseScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_TRIPLANAR\n" + "        material.diffuse *= getTriPlanar(u_material_diffuse_texture, v_world_position.xyz, _normal, material.diffuseScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_SPHEREMAP\n" + "        material.diffuse *= getSphereMap(u_material_diffuse_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // get SPECULAR TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_UV\n" + "        material.specular *= texture2D(u_material_specular_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_PLANAR\n" + "        material.specular *= getPlanar(u_material_specular_texture, v_world_position.xyz, material.specularScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_TRIPLANAR\n" + "        material.specular *= getTriPlanar(u_material_specular_texture, v_world_position.xyz, _normal, material.specularScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_SPHEREMAP\n" + "        material.specular *= getSphereMap(u_material_specular_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "}\n" + "";

shaderSources['gl/shaders/pointLight'] = "/*\n" + "\n" + "Expected globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct PointLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec4 position;\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "    float attenuationExponent;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "    float innerRadius;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "    float outerRadius;\n" + "#endif\n" + "};\n" + "\n" + "void calculateLight(in PointLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "\n" + "    float dist = length(_light.position.xyz - _eyeToPoint);\n" + "\n" + "    // Compute vector from surface to light position\n" + "    vec3 VP = (_light.position.xyz - _eyeToPoint) / dist;\n" + "\n" + "    // Normalize the vector from surface to light position\n" + "    float nDotVP = clamp(dot(VP, _normal), 0.0, 1.0);\n" + "\n" + "    // Attenuation defaults\n" + "    float attenuation = 1.0;\n" + "    #ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "        float Rin = 1.0;\n" + "        float e = _light.attenuationExponent;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "            float Rdiff = _light.outerRadius-Rin;\n" + "            float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "            attenuation = 1.0-(pow(d,e));\n" + "        #else\n" + "            // If no outer is provide behaves like:\n" + "            // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "            float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "            attenuation = clamp(1.0/(pow(d,e)), 0.0, 1.0);\n" + "        #endif\n" + "    #else\n" + "        float Rin = 0.0;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float Rdiff = _light.outerRadius-Rin;\n" + "                float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                // If no outer is provide behaves like:\n" + "                // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "                float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "                attenuation = clamp(1.0/d, 0.0, 1.0);\n" + "            #endif\n" + "        #else\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float d = clamp(dist/_light.outerRadius, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                attenuation = 1.0;\n" + "            #endif\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // Computer accumulators\n" + "    light_accumulator_ambient += _light.ambient * attenuation;\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        light_accumulator_diffuse += _light.diffuse * nDotVP * attenuation;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        float pf = 0.0; // power factor for shiny speculars\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(-VP, _normal);\n" + "            float eyeDotR = max(0.0, dot(-normalize(_eyeToPoint), reflectVector));\n" + "            pf = pow(eyeDotR, material.shininess);\n" + "        }\n" + "\n" + "        light_accumulator_specular += _light.specular * pf * attenuation;\n" + "    #endif\n" + "}\n" + "";

shaderSources['gl/shaders/selection_fragment'] = "// Fragment shader for feature selection passes\n" + "// Renders in silhouette according to selection (picking) color, or black if none defined\n" + "\n" + "#ifdef TANGRAM_FEATURE_SELECTION\n" + "    varying vec4 v_selection_color;\n" + "#endif\n" + "\n" + "void main (void) {\n" + "    #ifdef TANGRAM_FEATURE_SELECTION\n" + "        gl_FragColor = v_selection_color;\n" + "    #else\n" + "        gl_FragColor = vec4(0., 0., 0., 1.);\n" + "    #endif\n" + "}\n" + "";

shaderSources['gl/shaders/selection_globals'] = "// Vertex attribute + varying for feature selection\n" + "#if defined(TANGRAM_FEATURE_SELECTION) && defined(TANGRAM_VERTEX_SHADER)\n" + "    attribute vec4 a_selection_color;\n" + "    varying vec4 v_selection_color;\n" + "#endif\n" + "";

shaderSources['gl/shaders/selection_vertex'] = "// Selection pass-specific rendering\n" + "#if defined(TANGRAM_FEATURE_SELECTION) && defined(TANGRAM_VERTEX_SHADER)\n" + "    if (a_selection_color.rgb == vec3(0.)) {\n" + "        // Discard by forcing invalid triangle if we\'re in the feature\n" + "        // selection pass but have no selection info\n" + "        // TODO: in some cases we may actually want non-selectable features to occlude selectable ones?\n" + "        gl_Position = vec4(0., 0., 0., 1.);\n" + "        return;\n" + "    }\n" + "    v_selection_color = a_selection_color;\n" + "#endif\n" + "";

shaderSources['gl/shaders/spherical_environment_map'] = "// Spherical environment map\n" + "// Based on: http://www.clicktorelease.com/blog/creating-spherical-environment-mapping-shader\n" + "\n" + "// view: location of camera\n" + "// position: location of current point on surface\n" + "// normal: normal of current point on surface\n" + "// skew: skewing factor (used to compensate for altered vanishing point)\n" + "// envmap: spherical environment map texture\n" + "\n" + "vec4 sphericalEnvironmentMap(vec3 view, vec3 position, vec3 normal, vec2 skew, sampler2D envmap) {\n" + "    // Normalized vector from camera to surface\n" + "    vec3 eye = normalize(position.xyz - view.xyz);\n" + "\n" + "    // Skew\n" + "    eye.xy -= skew;\n" + "    eye = normalize(eye);\n" + "\n" + "    // Reflection of eye off of surface normal\n" + "    vec3 r = reflect(eye, normal);\n" + "\n" + "    // Map reflected vector onto the surface of a sphere\n" + "    r.z += 1.;\n" + "    float m = 2. * length(r);\n" + "\n" + "    // Adjust xy to account for spherical shape, and center in middle of texture\n" + "    vec2 uv = r.xy / m + .5;\n" + "\n" + "    // Sample the environment map\n" + "    return texture2D(envmap, uv);\n" + "}\n" + "";

shaderSources['gl/shaders/spotLight'] = "/*\n" + "\n" + "Expected globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct SpotLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec4 position;\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "    float attenuationExponent;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "    float innerRadius;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "    float outerRadius;\n" + "#endif\n" + "\n" + "    vec3 direction;\n" + "    float spotCosCutoff;\n" + "    float spotExponent;\n" + "};\n" + "\n" + "void calculateLight(in SpotLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "\n" + "    float dist = length(_light.position.xyz - _eyeToPoint);\n" + "\n" + "    // Compute vector from surface to light position\n" + "    vec3 VP = (_light.position.xyz - _eyeToPoint) / dist;\n" + "\n" + "    // normal . light direction\n" + "    float nDotVP = clamp(dot(_normal, VP), 0.0, 1.0);\n" + "\n" + "    // Attenuation defaults\n" + "    float attenuation = 1.0;\n" + "    #ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "        float Rin = 1.0;\n" + "        float e = _light.attenuationExponent;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "            float Rdiff = _light.outerRadius-Rin;\n" + "            float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "            attenuation = 1.0-(pow(d,e));\n" + "        #else\n" + "            // If no outer is provide behaves like:\n" + "            // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "            float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "            attenuation = clamp(1.0/(pow(d,e)), 0.0, 1.0);\n" + "        #endif\n" + "    #else\n" + "        float Rin = 0.0;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float Rdiff = _light.outerRadius-Rin;\n" + "                float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                // If no outer is provide behaves like:\n" + "                // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "                float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "                attenuation = clamp(1.0/d, 0.0, 1.0);\n" + "            #endif\n" + "        #else\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float d = clamp(dist/_light.outerRadius, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                attenuation = 1.0;\n" + "            #endif\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // spotlight attenuation factor\n" + "    float spotAttenuation = 0.0;\n" + "\n" + "    // See if point on surface is inside cone of illumination\n" + "    float spotDot = clamp(dot(-VP, normalize(_light.direction)), 0.0, 1.0);\n" + "\n" + "    if (spotDot >= _light.spotCosCutoff) {\n" + "        spotAttenuation = pow(spotDot, _light.spotExponent);\n" + "    }\n" + "\n" + "    light_accumulator_ambient += _light.ambient * attenuation * spotAttenuation;\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        light_accumulator_diffuse += _light.diffuse * nDotVP * attenuation * spotAttenuation;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        // Power factor for shiny speculars\n" + "        float pf = 0.0;\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(-VP, _normal);\n" + "            float eyeDotR = max(dot(-normalize(_eyeToPoint), reflectVector), 0.0);\n" + "            pf = pow(eyeDotR, material.shininess);\n" + "        }\n" + "        light_accumulator_specular += _light.specular * pf * attenuation * spotAttenuation;\n" + "    #endif\n" + "}\n" + "";

shaderSources['gl/shaders/unpack'] = "\n" + "// Unpack normalized shorts back to their original integer values\n" + "#define SHORT(x) (x * 32767.)\n" + "#define UNSIGNED_SHORT(x) (x * 65535.)\n" + "\n" + "// Used for cases where an attribute is stored as a normalized int type,\n" + "// but is a floating point value that needs a range greater than [0, 1] or [-1, 1].\n" + "// The integer value is \"scaled\" to an 8.8 fixed point style integer before it is\n" + "// normalized in the VBO. Used for cases where low precision is suitable for both\n" + "// the integer and fractional portions of the number.\n" + "// Examples are extrusion vectors for dynamic lines, and screen-space size for point sprites.\n" + "#define SCALE_8(x) (x * 256.)\n" + "";

shaderSources['styles/points/points_fragment'] = "uniform vec2 u_resolution;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec3 u_tile_origin;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_device_pixel_ratio;\n" + "\n" + "uniform mat3 u_normalMatrix;\n" + "uniform mat3 u_inverseNormalMatrix;\n" + "\n" + "uniform sampler2D u_texture;\n" + "\n" + "varying vec4 v_color;\n" + "varying vec2 v_texcoord;\n" + "varying vec4 v_world_position;\n" + "\n" + "#define TANGRAM_NORMAL vec3(0., 0., 1.)\n" + "\n" + "// Alpha discard threshold (substitute for alpha blending)\n" + "#ifndef TANGRAM_ALPHA_DISCARD\n" + "#define TANGRAM_ALPHA_DISCARD 0.5\n" + "#endif\n" + "\n" + "// Alpha fade range for edges of points\n" + "#ifndef TANGRAM_FADE_RANGE\n" + "#define TANGRAM_FADE_RANGE .15\n" + "#endif\n" + "#define TANGRAM_FADE_START (1. - TANGRAM_FADE_RANGE)\n" + "\n" + "#pragma tangram: camera\n" + "#pragma tangram: material\n" + "#pragma tangram: lighting\n" + "#pragma tangram: global\n" + "\n" + "void main (void) {\n" + "    // Initialize globals\n" + "    #pragma tangram: setup\n" + "\n" + "    vec4 color = v_color;\n" + "\n" + "    // Apply a texture\n" + "    #ifdef TANGRAM_POINT_TEXTURE\n" + "        color *= texture2D(u_texture, v_texcoord);\n" + "    // Draw a point\n" + "    #else\n" + "        // Fade alpha near circle edge\n" + "        vec2 uv = v_texcoord * 2. - 1.;\n" + "        float point_dist = length(uv);\n" + "        color.a = clamp(1. - (smoothstep(0., TANGRAM_FADE_RANGE, (point_dist - TANGRAM_FADE_START)) / TANGRAM_FADE_RANGE), 0., 1.);\n" + "    #endif\n" + "\n" + "    // If blending is off, use alpha discard as a lower-quality substitute\n" + "    #if !defined(TANGRAM_BLEND_OVERLAY) && !defined(TANGRAM_BLEND_INLAY)\n" + "        if (color.a < TANGRAM_ALPHA_DISCARD) {\n" + "            discard;\n" + "        }\n" + "    #endif\n" + "\n" + "    // Manually un-multiply alpha, for cases where texture has pre-multiplied alpha\n" + "    #ifdef TANGRAM_UNMULTIPLY_ALPHA\n" + "        color.rgb /= max(color.a, 0.001);\n" + "    #endif\n" + "\n" + "    #pragma tangram: color\n" + "    #pragma tangram: filter\n" + "\n" + "    gl_FragColor = color;\n" + "}\n" + "";

shaderSources['styles/points/points_vertex'] = "uniform vec2 u_resolution;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec3 u_tile_origin;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_device_pixel_ratio;\n" + "\n" + "uniform mat4 u_model;\n" + "uniform mat4 u_modelView;\n" + "uniform mat3 u_normalMatrix;\n" + "uniform mat3 u_inverseNormalMatrix;\n" + "\n" + "attribute vec4 a_position;\n" + "attribute vec4 a_shape;\n" + "attribute vec4 a_color;\n" + "attribute vec2 a_texcoord;\n" + "attribute vec2 a_offset;\n" + "\n" + "#define TANGRAM_NORMAL vec3(0., 0., 1.)\n" + "\n" + "varying vec4 v_color;\n" + "varying vec2 v_texcoord;\n" + "varying vec4 v_world_position;\n" + "\n" + "#pragma tangram: camera\n" + "#pragma tangram: material\n" + "#pragma tangram: lighting\n" + "#pragma tangram: global\n" + "\n" + "vec2 rotate2D(vec2 _st, float _angle) {\n" + "    return mat2(cos(_angle),-sin(_angle),\n" + "                sin(_angle),cos(_angle)) * _st;\n" + "}\n" + "\n" + "void main() {\n" + "    // Initialize globals\n" + "    #pragma tangram: setup\n" + "\n" + "    v_color = a_color;\n" + "    v_texcoord = a_texcoord;\n" + "\n" + "    // Position\n" + "    vec4 position = u_modelView * vec4(SHORT(a_position.xyz), 1.);\n" + "\n" + "    // Apply positioning and scaling in screen space\n" + "    float zscale = fract(u_map_position.z) * (SCALE_8(a_shape.w) - 1.) + 1.;\n" + "    // float zscale = log(fract(u_map_position.z) + 1.) / log(2.) * (a_shape.w - 1.) + 1.;\n" + "    vec2 shape = SCALE_8(a_shape.xy) * zscale;     //\n" + "    vec2 offset = vec2(a_offset.x, -a_offset.y); // flip y to make it point down\n" + "    float theta = radians(a_shape.z * 360.);\n" + "\n" + "    shape = rotate2D(shape, theta);             // apply rotation to vertex\n" + "    shape += rotate2D(SHORT(offset), theta);  // apply offset on rotated axis (e.g. so line labels follow text axis)\n" + "\n" + "    // World coordinates for 3d procedural textures\n" + "    v_world_position = u_model * position;\n" + "    v_world_position.xy += shape * u_meters_per_pixel;\n" + "    v_world_position = wrapWorldPosition(v_world_position);\n" + "\n" + "    // Modify position before camera projection\n" + "    #pragma tangram: position\n" + "\n" + "    cameraProjection(position);\n" + "\n" + "    #ifdef TANGRAM_LAYER_ORDER\n" + "        applyLayerOrder(SHORT(a_position.w), position);\n" + "    #endif\n" + "\n" + "    // Apply pixel offset in screen-space\n" + "    // Multiply by 2 is because screen is 2 units wide Normalized Device Coords (and u_resolution device pixels wide)\n" + "    // Device pixel ratio adjustment is because shape is in logical pixels\n" + "    position.xy += shape * position.w * 2. * u_device_pixel_ratio / u_resolution;\n" + "\n" + "    gl_Position = position;\n" + "}\n" + "";

shaderSources['styles/polygons/polygons_fragment'] = "uniform vec2 u_resolution;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec3 u_tile_origin;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_device_pixel_ratio;\n" + "\n" + "uniform mat3 u_normalMatrix;\n" + "uniform mat3 u_inverseNormalMatrix;\n" + "\n" + "varying vec4 v_position;\n" + "varying vec3 v_normal;\n" + "varying vec4 v_color;\n" + "varying vec4 v_world_position;\n" + "\n" + "#define TANGRAM_NORMAL v_normal\n" + "\n" + "#ifdef TANGRAM_TEXTURE_COORDS\n" + "    varying vec2 v_texcoord;\n" + "#endif\n" + "\n" + "#if defined(TANGRAM_LIGHTING_VERTEX)\n" + "    varying vec4 v_lighting;\n" + "#endif\n" + "\n" + "#pragma tangram: camera\n" + "#pragma tangram: material\n" + "#pragma tangram: lighting\n" + "#pragma tangram: global\n" + "\n" + "void main (void) {\n" + "    // Initialize globals\n" + "    #pragma tangram: setup\n" + "    \n" + "    vec4 color = v_color;\n" + "    vec3 normal = TANGRAM_NORMAL;\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "        calculateNormal(normal);\n" + "    #endif\n" + "\n" + "    // Modify normal before lighting\n" + "    #pragma tangram: normal\n" + "\n" + "    // Modify color and material properties before lighting\n" + "    #if !defined(TANGRAM_LIGHTING_VERTEX)\n" + "    #pragma tangram: color\n" + "    #endif\n" + "\n" + "    #if defined(TANGRAM_LIGHTING_FRAGMENT)\n" + "        color = calculateLighting(v_position.xyz - u_eye, normal, color);\n" + "    #elif defined(TANGRAM_LIGHTING_VERTEX)\n" + "        color = v_lighting;\n" + "    #endif\n" + "\n" + "    // Modify color after lighting (filter-like effects that don\'t require a additional render passes)\n" + "    #pragma tangram: filter\n" + "\n" + "    gl_FragColor = color;\n" + "}\n" + "";

shaderSources['styles/polygons/polygons_vertex'] = "uniform vec2 u_resolution;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec3 u_tile_origin;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_device_pixel_ratio;\n" + "\n" + "uniform mat4 u_model;\n" + "uniform mat4 u_modelView;\n" + "uniform mat3 u_normalMatrix;\n" + "uniform mat3 u_inverseNormalMatrix;\n" + "\n" + "attribute vec4 a_position;\n" + "attribute vec4 a_color;\n" + "\n" + "// Optional normal attribute, otherwise default to up\n" + "#ifdef TANGRAM_NORMAL_ATTRIBUTE\n" + "    attribute vec3 a_normal;\n" + "    #define TANGRAM_NORMAL a_normal\n" + "#else\n" + "    #define TANGRAM_NORMAL vec3(0., 0., 1.)\n" + "#endif\n" + "\n" + "// Optional dynamic line extrusion\n" + "#ifdef TANGRAM_EXTRUDE_LINES\n" + "    // xy: extrusion direction in xy plane\n" + "    // z:  half-width of line (amount to extrude)\n" + "    // w:  scaling factor for interpolating width between zooms\n" + "    attribute vec4 a_extrude;\n" + "#endif\n" + "\n" + "varying vec4 v_position;\n" + "varying vec3 v_normal;\n" + "varying vec4 v_color;\n" + "varying vec4 v_world_position;\n" + "\n" + "// Optional texture UVs\n" + "#ifdef TANGRAM_TEXTURE_COORDS\n" + "    attribute vec2 a_texcoord;\n" + "    varying vec2 v_texcoord;\n" + "#endif\n" + "\n" + "#if defined(TANGRAM_LIGHTING_VERTEX)\n" + "    varying vec4 v_lighting;\n" + "#endif\n" + "\n" + "#pragma tangram: camera\n" + "#pragma tangram: material\n" + "#pragma tangram: lighting\n" + "#pragma tangram: global\n" + "\n" + "void main() {\n" + "    // Initialize globals\n" + "    #pragma tangram: setup\n" + "\n" + "    // Texture UVs\n" + "    #ifdef TANGRAM_TEXTURE_COORDS\n" + "        v_texcoord = a_texcoord;\n" + "    #endif\n" + "\n" + "    // Position\n" + "    vec4 position = vec4(SHORT(a_position.xyz), 1.);\n" + "\n" + "    #ifdef TANGRAM_EXTRUDE_LINES\n" + "        vec2 extrude = SCALE_8(a_extrude.xy);\n" + "        float width = SHORT(a_extrude.z);\n" + "        float dwdz = SHORT(a_extrude.w);\n" + "        float dz = clamp(u_map_position.z - abs(u_tile_origin.z), 0.0, 1.0);\n" + "\n" + "        // Interpolate between zoom levels\n" + "        width += dwdz * dz;\n" + "\n" + "        // Scale pixel dimensions to be consistent in screen space\n" + "        width *= exp2(-dz);\n" + "\n" + "        // Modify line width before extrusion\n" + "        #pragma tangram: width\n" + "\n" + "        position.xy += extrude * width;\n" + "    #endif\n" + "\n" + "    // World coordinates for 3d procedural textures\n" + "    v_world_position = wrapWorldPosition(u_model * position);\n" + "\n" + "    // Adjust for tile and view position\n" + "    position = u_modelView * position;\n" + "\n" + "    // Modify position before camera projection\n" + "    #pragma tangram: position\n" + "\n" + "    // Setup varyings\n" + "    v_position = position;\n" + "    v_normal = normalize(u_normalMatrix * TANGRAM_NORMAL);\n" + "    v_color = a_color;\n" + "\n" + "    // Vertex lighting\n" + "    #if defined(TANGRAM_LIGHTING_VERTEX)\n" + "        vec4 color = a_color;\n" + "        vec3 normal = TANGRAM_NORMAL;\n" + "\n" + "        // Modify normal before lighting\n" + "        #pragma tangram: normal\n" + "\n" + "        // Modify color and material properties before lighting\n" + "        #pragma tangram: color\n" + "\n" + "        v_lighting = calculateLighting(position.xyz, normal, color);\n" + "        v_color = color;\n" + "    #endif\n" + "\n" + "    // Camera\n" + "    cameraProjection(position);\n" + "    applyLayerOrder(SHORT(a_position.w), position);\n" + "\n" + "    gl_Position = position;\n" + "}\n" + "";

module.exports = shaderSources;

},{}],200:[function(_dereq_,module,exports){
/*global Texture */
// Texture management
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsUtils = _dereq_('../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _utilsSubscribe = _dereq_('../utils/subscribe');

var _utilsSubscribe2 = _interopRequireDefault(_utilsSubscribe);

var _utilsWorker_broker = _dereq_('../utils/worker_broker');

var _utilsWorker_broker2 = _interopRequireDefault(_utilsWorker_broker);

var _stylesBuilders = _dereq_('../styles/builders');

var _stylesBuilders2 = _interopRequireDefault(_stylesBuilders);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

// GL texture wrapper object for keeping track of a global set of textures, keyed by a unique user-defined name

var Texture = (function () {
    function Texture(gl, name) {
        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, Texture);

        this.gl = gl;
        this.texture = gl.createTexture();
        if (this.texture) {
            this.valid = true;
        }
        this.bind();
        this.image = null; // an Image object/element that is the source for this texture
        this.canvas = null; // a Canvas object/element that is the source for this texture
        this.loading = null; // a Promise object to track the loading state of this texture

        // Default to a 1-pixel black texture so we can safely render while we wait for an image to load
        // See: http://stackoverflow.com/questions/19722247/webgl-wait-for-texture-to-load
        this.setData(1, 1, new Uint8Array([0, 0, 0, 255]), { filtering: 'nearest' });

        // TODO: better support for non-URL sources: canvas/video elements, raw pixel buffers

        this.name = name;
        this.filtering = options.filtering;

        // Destroy previous texture if present
        if (Texture.textures[this.name]) {
            Texture.textures[this.name].destroy();
        }

        // Cache texture instance and definition
        Texture.textures[this.name] = this;
        Texture.texture_configs[this.name] = _Object$assign({ name: name }, options);

        this.sprites = options.sprites;
        this.texcoords = {}; // sprite UVs ([0, 1] range)
        this.sizes = {}; // sprite sizes (pixel size)
        _loglevel2['default'].trace('creating Texture ' + this.name);
    }

    // Static/class methods and state

    // Destroy all texture instances for a given GL context

    // Destroy a single texture instance

    _createClass(Texture, [{
        key: 'destroy',
        value: function destroy() {
            if (!this.valid) {
                return;
            }
            this.gl.deleteTexture(this.texture);
            this.texture = null;
            delete this.data;
            this.data = null;
            delete Texture.textures[this.name];
            this.valid = false;
            _loglevel2['default'].trace('destroying Texture ' + this.name);
        }
    }, {
        key: 'bind',
        value: function bind(unit) {
            if (!this.valid) {
                return;
            }
            if (typeof unit === 'number') {
                if (Texture.activeUnit !== unit) {
                    this.gl.activeTexture(this.gl.TEXTURE0 + unit);
                    Texture.activeUnit = unit;
                }
            }
            if (Texture.activeTexture !== this.texture) {
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                Texture.activeTexture = this.texture;
            }
        }

        // Loads a texture from a URL
    }, {
        key: 'load',
        value: function load(url) {
            var _this = this;

            var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            if (!this.valid) {
                return;
            }

            if (Texture.base_url) {
                url = _utilsUtils2['default'].addBaseURL(url, Texture.base_url);
            }

            url = _utilsUtils2['default'].cacheBusterForUrl(url);

            this.loading = new _Promise(function (resolve, reject) {
                _this.image = new Image();
                _this.image.onload = function () {
                    try {
                        _this.update(options);
                        _this.setTextureFiltering(options);
                        _this.calculateSprites();

                        _this.canvas = null; // mutually exclusive with other types
                        _this.data = null;
                    } catch (e) {
                        _loglevel2['default'].warn('Texture: failed to load url: \'' + url + '\'', e, options);
                        Texture.trigger('warning', { message: 'Failed to load texture from ' + url, error: e, texture: options });
                    }

                    resolve(_this);
                };
                _this.image.onerror = function (e) {
                    // Warn and resolve on error
                    _loglevel2['default'].warn('Texture: failed to load url: \'' + url + '\'', e, options);
                    Texture.trigger('warning', { message: 'Failed to load texture from ' + url, error: e, texture: options });
                    resolve(_this);
                };
                _this.image.crossOrigin = 'anonymous';
                _this.image.src = url;
            });
            return this.loading;
        }

        // Sets texture to a raw image buffer
    }, {
        key: 'setData',
        value: function setData(width, height, data) {
            var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

            this.width = width;
            this.height = height;
            this.data = data;

            this.image = null; // mutually exclusive with other types
            this.canvas = null;

            this.update(options);
            this.setTextureFiltering(options);
        }

        // Sets the texture to track a canvas element
    }, {
        key: 'setCanvas',
        value: function setCanvas(canvas, options) {
            this.canvas = canvas;
            this.update(options);
            this.setTextureFiltering(options);

            this.image = null; // mutually exclusive with other types
            this.data = null;
        }

        // Uploads current image or buffer to the GPU (can be used to update animated textures on the fly)
    }, {
        key: 'update',
        value: function update() {
            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            if (!this.valid) {
                return;
            }

            this.bind();
            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, options.UNPACK_FLIP_Y_WEBGL === false ? false : true);
            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.UNPACK_PREMULTIPLY_ALPHA_WEBGL || false);

            // Image element
            if (this.image && this.image.complete) {
                this.width = this.image.width;
                this.height = this.image.height;
                this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image);
            }
            // Canvas element
            else if (this.canvas) {
                    this.width = this.canvas.width;
                    this.height = this.canvas.height;
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.canvas);
                }
                // Raw image buffer
                else if (this.width && this.height) {
                        // NOTE: this.data can be null, to zero out texture
                        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.width, this.height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.data);
                    }

            Texture.trigger('update', this);
        }

        // Determines appropriate filtering mode
    }, {
        key: 'setTextureFiltering',
        value: function setTextureFiltering() {
            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            if (!this.valid) {
                return;
            }

            options.filtering = options.filtering || this.filtering || 'linear';

            var gl = this.gl;
            this.bind();

            // For power-of-2 textures, the following presets are available:
            // mipmap: linear blend from nearest mip
            // linear: linear blend from original image (no mips)
            // nearest: nearest pixel from original image (no mips, 'blocky' look)
            if (_utilsUtils2['default'].isPowerOf2(this.width) && _utilsUtils2['default'].isPowerOf2(this.height)) {
                this.power_of_2 = true;
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.TEXTURE_WRAP_S || options.repeat && gl.REPEAT || gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.TEXTURE_WRAP_T || options.repeat && gl.REPEAT || gl.CLAMP_TO_EDGE);

                // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.TEXTURE_WRAP_S || gl.REPEAT);
                // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.TEXTURE_WRAP_T || gl.REPEAT);

                if (options.filtering === 'mipmap') {
                    this.filtering = 'mipmap';
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR); // TODO: use trilinear filtering by defualt instead?
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.generateMipmap(gl.TEXTURE_2D);
                } else if (options.filtering === 'linear') {
                    this.filtering = 'linear';
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                } else if (options.filtering === 'nearest') {
                    this.filtering = 'nearest';
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                }
            } else {
                // WebGL has strict requirements on non-power-of-2 textures:
                // No mipmaps and must clamp to edge
                this.power_of_2 = false;
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                if (options.filtering === 'nearest') {
                    this.filtering = 'nearest';
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                } else {
                    // default to linear for non-power-of-2 textures
                    this.filtering = 'linear';
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                }
            }

            Texture.trigger('update', this);
        }

        // Pre-calc sprite regions for a texture sprite in UV [0, 1] space
    }, {
        key: 'calculateSprites',
        value: function calculateSprites() {
            if (this.sprites) {
                for (var s in this.sprites) {
                    var sprite = this.sprites[s];

                    // Map [0, 0] to [1, 1] coords to the appropriate sprite sub-area of the texture
                    this.texcoords[s] = _stylesBuilders2['default'].getTexcoordsForSprite([sprite[0], sprite[1]], [sprite[2], sprite[3]], [this.width, this.height]);

                    // Pixel size of sprite
                    this.sizes[s] = [sprite[2], sprite[3]];
                }
            }
        }
    }]);

    return Texture;
})();

exports['default'] = Texture;
Texture.destroy = function (gl) {
    var textures = _Object$keys(Texture.textures);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = _getIterator(textures), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var t = _step.value;

            var texture = Texture.textures[t];
            if (texture.gl === gl) {
                texture.destroy();
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
                _iterator['return']();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
};

// Get sprite pixel size and UVs
Texture.getSpriteInfo = function (texname, sprite) {
    var texture = Texture.textures[texname];
    return texture && { size: texture.sizes[sprite], texcoords: texture.texcoords[sprite] };
};

// Create a set of textures keyed in an object
// Optionally load each if it has a URL specified
Texture.createFromObject = function (gl, textures) {
    var loading = [];
    if (textures) {
        for (var texname in textures) {
            var config = textures[texname];

            // If texture already exists and definition hasn't changed, no need to re-create
            // Note: to avoid flicker when other textures/scene items change
            if (!Texture.changed(texname, config)) {
                continue;
            }

            var texture = new Texture(gl, texname, config);
            if (config.url) {
                loading.push(texture.load(config.url, config));
            }
        }
    }
    return _Promise.all(loading);
};

// Indicate if a texture definition would be a change from the current cache
Texture.changed = function (name, config) {
    if (Texture.textures[name]) {
        // cached texture
        // compare definitions
        if (JSON.stringify(Texture.texture_configs[name]) === JSON.stringify(_Object$assign({ name: name }, config))) {
            return false;
        }
    }
    return true;
};

// Get metadata for a texture by name
// Returns via promise, in case texture is still loading
// Can be called on main thread from worker, to sync texture info to worker
Texture.getInfo = function (name) {
    // Get info for all textures by default
    if (!name) {
        name = _Object$keys(Texture.textures);
    }

    // Get multiple textures
    if (Array.isArray(name)) {
        return _Promise.all(name.map(function (n) {
            return Texture.getInfo(n);
        }));
    }

    // Get single texture
    var tex = Texture.textures[name];
    if (tex) {
        // Wait for this texture to finish loading, or return immediately
        var loading = tex.loading || _Promise.resolve(tex);
        return loading.then(function () {
            // Return a subset of texture info
            // (compatible w/structured cloning, suitable for passing to a worker)
            return {
                name: tex.name,
                width: tex.width,
                height: tex.height,
                sprites: tex.sprites,
                texcoords: tex.texcoords,
                sizes: tex.sizes,
                filtering: tex.filtering,
                power_of_2: tex.power_of_2,
                valid: tex.valid
            };
        });
    } else {
        // No texture found
        return _Promise.resolve(null);
    }
};

// Sync texture info to worker
// Called from worker, gets info on one or more textures info from main thread via remote call, then stores it
// locally in worker. 'textures' can be an array of texture names to sync, or if null, all textures are synced.
Texture.syncTexturesToWorker = function (names) {
    return _utilsWorker_broker2['default'].postMessage('Texture.getInfo', names).then(function (textures) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = _getIterator(textures), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var tex = _step2.value;

                Texture.textures[tex.name] = tex;
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                    _iterator2['return']();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }

        return Texture.textures;
    });
};

// Global set of textures, by name
Texture.textures = {};
Texture.texture_configs = {};
Texture.boundTexture = -1;
Texture.activeUnit = -1;

Texture.base_url = null; // optional base URL to add to textures

_utilsWorker_broker2['default'].addTarget('Texture', Texture);
(0, _utilsSubscribe2['default'])(Texture);
module.exports = exports['default'];

},{"../styles/builders":217,"../utils/subscribe":240,"../utils/utils":241,"../utils/worker_broker":243,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/keys":11,"babel-runtime/core-js/promise":13,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/interop-require-default":22,"loglevel":179}],201:[function(_dereq_,module,exports){
// Creates a Vertex Array Object if the extension is available, or falls back on standard attribute calls

'use strict';

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var VertexArrayObject;
exports['default'] = VertexArrayObject = {};

VertexArrayObject.disabled = false; // set to true to disable VAOs even if extension is available
VertexArrayObject.bound_vao = null; // currently bound VAO

VertexArrayObject.init = function (gl) {
    if (VertexArrayObject.ext == null) {
        if (VertexArrayObject.disabled !== true) {
            VertexArrayObject.ext = gl.getExtension("OES_vertex_array_object");
        }

        if (VertexArrayObject.ext != null) {
            _loglevel2['default'].info('Vertex Array Object extension available');
        } else if (VertexArrayObject.disabled !== true) {
            _loglevel2['default'].warn('Vertex Array Object extension NOT available');
        } else {
            _loglevel2['default'].warn('Vertex Array Object extension force disabled');
        }
    }
};

VertexArrayObject.create = function (setup, teardown) {
    var vao = {};
    vao.setup = setup;
    vao.teardown = teardown;

    var ext = VertexArrayObject.ext;
    if (ext != null) {
        vao._vao = ext.createVertexArrayOES();
        ext.bindVertexArrayOES(vao._vao);
    }

    vao.setup(true);

    return vao;
};

VertexArrayObject.bind = function (vao) {
    var ext = VertexArrayObject.ext;
    if (vao != null) {
        if (ext != null && vao._vao != null) {
            ext.bindVertexArrayOES(vao._vao);
            VertexArrayObject.bound_vao = vao;
        } else {
            vao.setup(false);
        }
    } else {
        if (ext != null) {
            ext.bindVertexArrayOES(null);
        } else if (VertexArrayObject.bound_vao != null && typeof VertexArrayObject.bound_vao.teardown === 'function') {
            VertexArrayObject.bound_vao.teardown();
        }
        VertexArrayObject.bound_vao = null;
    }
};
module.exports = exports['default'];

},{"babel-runtime/helpers/interop-require-default":22,"loglevel":179}],202:[function(_dereq_,module,exports){
/* global VBOMesh */
// Manage rendering for primitives
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _Map = _dereq_('babel-runtime/core-js/map')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _shader_program = _dereq_('./shader_program');

var _shader_program2 = _interopRequireDefault(_shader_program);

var _vao = _dereq_('./vao');

var _vao2 = _interopRequireDefault(_vao);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

// A single mesh/VBO, described by a vertex layout, that can be drawn with one or more programs

var VBOMesh = (function () {
    function VBOMesh(gl, vertex_data, vertex_layout, options) {
        _classCallCheck(this, VBOMesh);

        options = options || {};

        this.gl = gl;
        this.vertex_data = vertex_data; // typed array
        this.vertex_layout = vertex_layout;
        this.buffer = this.gl.createBuffer();
        this.draw_mode = options.draw_mode || this.gl.TRIANGLES;
        this.data_usage = options.data_usage || this.gl.STATIC_DRAW;
        this.vertices_per_geometry = 3; // TODO: support lines, strip, fan, etc.
        this.uniforms = options.uniforms;
        this.retain = options.retain || false; // whether to retain mesh data in CPU after uploading to GPU

        this.vertex_count = this.vertex_data.byteLength / this.vertex_layout.stride;
        this.geometry_count = this.vertex_count / this.vertices_per_geometry;
        this.vaos = new _Map(); // map of VertexArrayObjects, keyed by program

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vertex_data, this.data_usage);

        if (!this.retain) {
            delete this.vertex_data;
        }
        this.valid = true;
    }

    // Render, by default with currently bound program, or otherwise with optionally provided one

    _createClass(VBOMesh, [{
        key: 'render',
        value: function render() {
            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            if (!this.valid) {
                return false;
            }

            if (typeof this._render_setup === 'function') {
                this._render_setup();
            }

            var program = options.program || _shader_program2['default'].current;
            program.use();

            if (this.uniforms) {
                program.saveUniforms(this.uniforms);
                program.setUniforms(this.uniforms, false); // don't reset texture unit
            }

            this.bind(program);

            // TODO: support element array mode
            this.gl.drawArrays(this.draw_mode, 0, this.vertex_count);
            _vao2['default'].bind(null);

            if (this.uniforms) {
                program.restoreUniforms(this.uniforms);
            }

            return true;
        }

        // Bind buffers and vertex attributes to prepare for rendering
    }, {
        key: 'bind',
        value: function bind(program) {
            var _this = this;

            // Bind VAO for this progam, or create one
            var vao = this.vaos.get(program);
            if (vao) {
                _vao2['default'].bind(vao);
            } else {
                this.vaos.set(program, _vao2['default'].create(function (force) {
                    _this.gl.bindBuffer(_this.gl.ARRAY_BUFFER, _this.buffer);
                    _this.vertex_layout.enable(_this.gl, program, force);
                }));
            }
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            if (!this.valid) {
                return false;
            }
            this.valid = false;

            _loglevel2['default'].trace('VBOMesh.destroy: delete buffer' + (this.vertex_data ? ' of size ' + this.vertex_data.byteLength : ''));

            this.gl.deleteBuffer(this.buffer);
            this.buffer = null;
            delete this.vertex_data;

            return true;
        }
    }]);

    return VBOMesh;
})();

exports['default'] = VBOMesh;
module.exports = exports['default'];

},{"./shader_program":198,"./vao":201,"babel-runtime/core-js/map":4,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/interop-require-default":22,"loglevel":179}],203:[function(_dereq_,module,exports){
/* global VertexData */

'use strict';

var _defineProperty = _dereq_('babel-runtime/helpers/define-property')['default'];

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _array_types;

var _constants = _dereq_('./constants');

var _constants2 = _interopRequireDefault(_constants);

// web workers don't have access to GL context, so import all GL constants

var _utilsUtils = _dereq_('../utils/utils');

// Maps GL types to JS array types
var array_types = (_array_types = {}, _defineProperty(_array_types, _constants2['default'].FLOAT, Float32Array), _defineProperty(_array_types, _constants2['default'].BYTE, Int8Array), _defineProperty(_array_types, _constants2['default'].UNSIGNED_BYTE, Uint8Array), _defineProperty(_array_types, _constants2['default'].INT, Int32Array), _defineProperty(_array_types, _constants2['default'].UNSIGNED_INT, Uint32Array), _defineProperty(_array_types, _constants2['default'].SHORT, Int16Array), _defineProperty(_array_types, _constants2['default'].UNSIGNED_SHORT, Uint16Array), _array_types);

// An intermediary object that holds vertex data in typed arrays, according to a given vertex layout
// Used to construct a mesh/VBO for rendering

var VertexData = (function () {
    function VertexData(vertex_layout) {
        var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        var prealloc = _ref.prealloc;

        _classCallCheck(this, VertexData);

        this.vertex_layout = vertex_layout;

        if (VertexData.array_pool.length > 0) {
            this.buffer = VertexData.array_pool.pop();
            this.buffer_length = this.buffer.byteLength;
            this.buffer_size = Math.floor(this.buffer_length / this.vertex_layout.stride);
            (0, _utilsUtils.log)('trace', 'VertexData: reused buffer of bytes ' + this.buffer_length + ', ' + this.buffer_size + ' vertices');
        } else {
            this.buffer_size = prealloc || 500; // # of vertices to allocate
            this.buffer_length = this.vertex_layout.stride * this.buffer_size;
            this.buffer = new Uint8Array(this.buffer_length);
        }
        this.buffer_offset = 0; // byte offset into currently allocated buffer

        this.components = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = _getIterator(this.vertex_layout.components), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var component = _step.value;

                this.components.push([].concat(_toConsumableArray(component)));
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                    _iterator['return']();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        this.vertex_count = 0;
        this.realloc_count = 0;
        this.setBufferViews();
    }

    // (Re-)allocate typed views into the main buffer - only create the types we need for this layout

    _createClass(VertexData, [{
        key: 'setBufferViews',
        value: function setBufferViews() {
            this.buffer_views = {};
            this.buffer_views[_constants2['default'].UNSIGNED_BYTE] = this.buffer;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = _getIterator(this.vertex_layout.attribs), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var attrib = _step2.value;

                    // Need view for this type?
                    if (this.buffer_views[attrib.type] == null) {
                        var array_type = array_types[attrib.type];
                        this.buffer_views[attrib.type] = new array_type(this.buffer.buffer);
                    }
                }

                // Update component buffer pointers
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                        _iterator2['return']();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = _getIterator(this.components), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var component = _step3.value;

                    component[1] = this.buffer_views[component[0]];
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                        _iterator3['return']();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }
        }

        // Check allocated buffer size, expand/realloc buffer if needed
    }, {
        key: 'checkBufferSize',
        value: function checkBufferSize() {
            if (this.buffer_offset + this.vertex_layout.stride > this.buffer_length) {
                this.buffer_size = Math.floor(this.buffer_size * 1.5);
                this.buffer_size -= this.buffer_size % 4;
                this.buffer_length = this.vertex_layout.stride * this.buffer_size;
                var new_view = new Uint8Array(this.buffer_length);
                new_view.set(this.buffer); // copy existing data to new buffer
                VertexData.array_pool.push(this.buffer); // save previous buffer for use by next tile
                this.buffer = new_view;
                this.setBufferViews();
                this.realloc_count++;
                // log.info(`VertexData: expanded vertex block to ${this.buffer_size} vertices`);
            }
        }

        // Add a vertex, copied from a plain JS array of elements matching the order of the vertex layout.
        // Note: uses pre-calculated info about each attribute, including pointer to appropriate typed array
        // view and offset into it. This was the fastest method profiled so far for filling a mixed-type
        // vertex layout (though still slower than the previous method that only supported Float32Array attributes).
    }, {
        key: 'addVertex',
        value: function addVertex(vertex) {
            this.checkBufferSize();
            var i = 0;

            var clen = this.components.length;
            for (var c = 0; c < clen; c++) {
                var component = this.components[c];
                component[1][(this.buffer_offset >> component[2]) + component[3]] = vertex[i++];
            }

            this.buffer_offset += this.vertex_layout.stride;
            this.vertex_count++;
        }

        // Finalize vertex buffer for use in constructing a mesh
    }, {
        key: 'end',
        value: function end() {
            // Clip the buffer to size used for this VBO
            this.buffer = this.buffer.subarray(0, this.buffer_offset);
            (0, _utilsUtils.log)('trace', 'VertexData: ' + this.buffer_size + ' vertices total, realloc count ' + this.realloc_count);
            return this;
        }
    }]);

    return VertexData;
})();

exports['default'] = VertexData;

VertexData.array_pool = []; // pool of currently available (previously used) buffers (uint8)
module.exports = exports['default'];

},{"../utils/utils":241,"./constants":193,"babel-runtime/core-js/get-iterator":2,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/define-property":19,"babel-runtime/helpers/interop-require-default":22,"babel-runtime/helpers/to-consumable-array":24}],204:[function(_dereq_,module,exports){
/* global VertexLayout */

'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _constants = _dereq_('./constants');

var _constants2 = _interopRequireDefault(_constants);

// web workers don't have access to GL context, so import all GL constants

var _vertex_data = _dereq_('./vertex_data');

var _vertex_data2 = _interopRequireDefault(_vertex_data);

// Describes a vertex layout that can be used with many different GL programs.

var VertexLayout = (function () {
    // Attribs are an array, in layout order, of: name, size, type, normalized
    // ex: { name: 'position', size: 3, type: gl.FLOAT, normalized: false }

    function VertexLayout(attribs) {
        _classCallCheck(this, VertexLayout);

        this.attribs = attribs; // dictionary of attributes, specified as standard GL attrib options
        this.components = []; // list of type and offset info about each attribute component
        this.index = {}; // linear buffer index of each attribute component, e.g. this.index.position.x

        // Calc vertex stride
        this.stride = 0;

        var count = 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = _getIterator(this.attribs), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var attrib = _step.value;

                attrib.offset = this.stride;
                attrib.byte_size = attrib.size;
                var shift = 0;

                switch (attrib.type) {
                    case _constants2['default'].FLOAT:
                    case _constants2['default'].INT:
                    case _constants2['default'].UNSIGNED_INT:
                        attrib.byte_size *= 4;
                        shift = 2;
                        break;
                    case _constants2['default'].SHORT:
                    case _constants2['default'].UNSIGNED_SHORT:
                        attrib.byte_size *= 2;
                        shift = 1;
                        break;
                }

                // Force 4-byte alignment on attributes
                this.stride += attrib.byte_size;
                if (this.stride & 3) {
                    // pad to multiple of 4 bytes
                    this.stride += 4 - (this.stride & 3);
                }

                // Add info to list of attribute components
                // Used to build the vertex data, provides pointers and offsets into each typed array view
                // Each component is an array of:
                // [GL attrib type, pointer to typed array view, bits to shift right to determine buffer offset, additional buffer offset for the component]
                var offset_typed = attrib.offset >> shift;
                if (attrib.size > 1) {
                    for (var a = 0; a < attrib.size; a++) {
                        this.components.push([attrib.type, null, shift, offset_typed++]);
                    }
                } else {
                    this.components.push([attrib.type, null, shift, offset_typed]);
                }

                // Provide an index into the vertex data buffer for each attribute component
                this.index[attrib.name] = count;
                count += attrib.size;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                    _iterator['return']();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }

    // Track currently enabled attribs, by the program they are bound to
    // Static class property to reflect global GL state

    // Setup a vertex layout for a specific GL program
    // Assumes that the desired vertex buffer (VBO) is already bound
    // If a given program doesn't include all attributes, it can still use the vertex layout
    // to read those attribs that it does recognize, using the attrib offsets to skip others.

    _createClass(VertexLayout, [{
        key: 'enable',
        value: function enable(gl, program, force) {
            var attrib, location;

            // Enable all attributes for this layout
            for (var a = 0; a < this.attribs.length; a++) {
                attrib = this.attribs[a];
                location = program.attribute(attrib.name).location;

                if (location !== -1) {
                    if (!VertexLayout.enabled_attribs[location] || force) {
                        gl.enableVertexAttribArray(location);
                    }
                    gl.vertexAttribPointer(location, attrib.size, attrib.type, attrib.normalized, this.stride, attrib.offset);
                    VertexLayout.enabled_attribs[location] = program;
                }
            }

            // Disable any previously bound attributes that aren't for this layout
            for (location in VertexLayout.enabled_attribs) {
                this.disableUnusedAttribute(gl, location, program);
            }
        }

        // Disable an attribute if it was not enabled for the specified program
        // NOTE: this was moved out of the inner loop in enable() to assist w/VM optimization
    }, {
        key: 'disableUnusedAttribute',
        value: function disableUnusedAttribute(gl, location, program) {
            if (VertexLayout.enabled_attribs[location] !== program) {
                gl.disableVertexAttribArray(location);
                delete VertexLayout.enabled_attribs[location];
            }
        }
    }, {
        key: 'createVertexData',
        value: function createVertexData() {
            return new _vertex_data2['default'](this);
        }
    }]);

    return VertexLayout;
})();

exports['default'] = VertexLayout;
VertexLayout.enabled_attribs = {};
module.exports = exports['default'];

},{"./constants":193,"./vertex_data":203,"babel-runtime/core-js/get-iterator":2,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/interop-require-default":22}],205:[function(_dereq_,module,exports){
'use strict';

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.leafletLayer = leafletLayer;

var _utilsUtils = _dereq_('./utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _scene = _dereq_('./scene');

var _scene2 = _interopRequireDefault(_scene);

var _geo = _dereq_('./geo');

var _geo2 = _interopRequireDefault(_geo);

// Exports must appear outside a function, but will only be defined in main thread (below)
var LeafletLayer;
exports.LeafletLayer = LeafletLayer;

function leafletLayer(options) {
    return extendLeaflet(options);
}

function extendLeaflet(options) {

    // If LeafletLayer is already defined when this is called just return that immediately
    // e.g. if you call leafletLayer multiple times (which is valid)
    if (typeof LeafletLayer !== 'undefined') {
        return new LeafletLayer(options);
    }

    // Leaflet layer functionality is only defined in main thread
    if (_utilsUtils2['default'].isMainThread) {
        var _ret = (function () {

            var L = options.leaflet || window.L;

            // Determine if we are extending the leaflet 0.7.x TileLayer class, or the newer
            // leaflet 1.x GridLayer class.
            var layerBaseClass = L.GridLayer ? L.GridLayer : L.TileLayer;
            var leafletVersion = layerBaseClass === L.GridLayer ? '1.x' : '0.7.x';
            var layerClassConfig = {};

            // If extending leaflet 0.7.x TileLayer, make add/remove tile no ops
            if (layerBaseClass === L.TileLayer) {
                layerClassConfig._addTile = function () {};
                layerClassConfig._removeTile = function () {};
            }

            // Define custom layer methods
            _Object$assign(layerClassConfig, {

                initialize: function initialize(options) {
                    var _this = this;

                    // Defaults
                    options.showDebug = !options.showDebug ? false : true;
                    options.wheelDebounceTime = options.wheelDebounceTime || 40;

                    L.setOptions(this, options);
                    this.createScene();
                    this.hooks = {};
                    this._updating_tangram = false;

                    // Force leaflet zoom animations off
                    this._zoomAnimated = false;

                    this.debounceViewReset = _utilsUtils2['default'].debounce(function () {
                        _this._map.fire('zoomend');
                        _this._map.fire('moveend');
                    }, this.options.wheelDebounceTime);
                },

                createScene: function createScene() {
                    this.scene = _scene2['default'].create(this.options.scene, {
                        numWorkers: this.options.numWorkers,
                        preUpdate: this.options.preUpdate,
                        postUpdate: this.options.postUpdate,
                        continuousZoom: LeafletLayer.leafletVersion === '1.x',
                        highDensityDisplay: this.options.highDensityDisplay,
                        logLevel: this.options.logLevel,
                        // advanced option, app will have to manually called scene.update() per frame
                        disableRenderLoop: this.options.disableRenderLoop,
                        // advanced option, will require library to be served as same host as page
                        allowCrossDomainWorkers: this.options.allowCrossDomainWorkers
                    });
                },

                // Finish initializing scene and setup events when layer is added to map
                onAdd: function onAdd(map) {
                    var _this2 = this;

                    if (!this.scene) {
                        this.createScene();
                    }

                    layerBaseClass.prototype.onAdd.apply(this, arguments);

                    this.hooks.resize = function () {
                        _this2._updating_tangram = true;
                        _this2.updateSize();
                        _this2._updating_tangram = false;
                    };
                    map.on('resize', this.hooks.resize);

                    this.hooks.move = function () {
                        if (_this2._updating_tangram) {
                            return;
                        }

                        _this2._updating_tangram = true;
                        var view = map.getCenter();
                        view.zoom = Math.min(map.getZoom(), map.getMaxZoom() || _geo2['default'].max_zoom);

                        _this2.scene.setView(view);
                        _this2.scene.immediateRedraw();
                        _this2.reverseTransform();
                        _this2._updating_tangram = false;
                    };
                    map.on('move', this.hooks.move);

                    this.hooks.zoomstart = function () {
                        if (_this2._updating_tangram) {
                            return;
                        }

                        _this2._updating_tangram = true;
                        _this2.scene.startZoom();
                        _this2._updating_tangram = false;
                    };
                    map.on('zoomstart', this.hooks.zoomstart);

                    this.hooks.dragstart = function () {
                        _this2.scene.panning = true;
                    };
                    map.on('dragstart', this.hooks.dragstart);

                    this.hooks.dragend = function () {
                        _this2.scene.panning = false;
                    };
                    map.on('dragend', this.hooks.dragend);

                    // Force leaflet zoom animations off
                    map._zoomAnimated = false;

                    // Modify default leaflet scroll wheel behavior
                    this.modifyScrollWheelBehavior(map);

                    // Add GL canvas to layer container
                    this.scene.container = this.getContainer();

                    // Initial view
                    this.updateView();

                    // Subscribe to tangram events
                    this.scene.subscribe({
                        move: this.onTangramViewUpdate.bind(this)
                    });

                    // Use leaflet's existing event system as the callback mechanism
                    this.scene.load().then(function () {
                        _this2._updating_tangram = true;

                        _this2.updateSize();
                        _this2.updateView();
                        _this2.reverseTransform();

                        _this2._updating_tangram = false;

                        _this2.fire('init');
                    })['catch'](function (error) {
                        _this2.fire('error', error);
                    });
                },

                onRemove: function onRemove(map) {
                    layerBaseClass.prototype.onRemove.apply(this, arguments);

                    map.off('resize', this.hooks.resize);
                    map.off('move', this.hooks.move);
                    map.off('zoomstart', this.hooks.zoomstart);
                    map.off('dragstart', this.hooks.dragstart);
                    map.off('dragend', this.hooks.dragend);
                    this.hooks = {};

                    if (this.scene) {
                        this.scene.destroy();
                        this.scene = null;
                    }
                },

                createTile: function createTile(coords) {
                    var key = coords.x + '/' + coords.y + '/' + coords.z;
                    var div = document.createElement('div');
                    div.setAttribute('data-tile-key', key);
                    div.style.width = '256px';
                    div.style.height = '256px';

                    if (this.options.showDebug) {
                        var debug_overlay = document.createElement('div');
                        debug_overlay.textContent = key;
                        debug_overlay.style.position = 'absolute';
                        debug_overlay.style.left = 0;
                        debug_overlay.style.top = 0;
                        debug_overlay.style.color = 'white';
                        debug_overlay.style.fontSize = '16px';
                        debug_overlay.style.textOutline = '1px #000000';
                        debug_overlay.style.padding = '8px';

                        div.appendChild(debug_overlay);
                        div.style.borderStyle = 'solid';
                        div.style.borderColor = 'white';
                        div.style.borderWidth = '1px';
                    }

                    return div;
                },

                // Modify leaflet's default scroll wheel behavior to have a much more sensitve/continuous zoom
                // Note: this should be deprecated once leaflet continuous zoom is more widely used and the
                // default behavior is presumably improved
                modifyScrollWheelBehavior: function modifyScrollWheelBehavior(map) {
                    var _this3 = this;

                    if (this.scene.continuous_zoom && map.scrollWheelZoom && this.options.modifyScrollWheel !== false) {
                        (function () {
                            var layer = _this3;
                            var enabled = map.scrollWheelZoom.enabled();
                            if (enabled) {
                                map.scrollWheelZoom.disable(); // disable before modifying
                            }

                            // modify prototype and current instance, so add/remove hooks work on existing references
                            L.Map.ScrollWheelZoom._onWheelScroll = map.scrollWheelZoom._onWheelScroll = function (e) {
                                // modify to skip debounce, as it seems to cause animation-sync issues in Chrome
                                // with Tangram continuous rendering
                                this._delta += L.DomEvent.getWheelDelta(e);
                                this._lastMousePos = this._map.mouseEventToContainerPoint(e);
                                this._performZoom();
                                L.DomEvent.stop(e);
                            };

                            L.Map.ScrollWheelZoom._performZoom = map.scrollWheelZoom._performZoom = function () {
                                var map = this._map,
                                    delta = this._delta,
                                    zoom = map.getZoom();

                                map.stop(); // stop panning and fly animations if any

                                // NOTE: this is the only real modification to default leaflet behavior
                                delta /= 40;

                                delta = Math.max(Math.min(delta, 4), -4);
                                delta = map._limitZoom(zoom + delta) - zoom;

                                this._delta = 0;
                                this._startTime = null;

                                if (!delta) {
                                    return;
                                }

                                if (map.options.scrollWheelZoom === 'center') {
                                    map.setZoom(zoom + delta);
                                } else {
                                    map.setZoomAround(this._lastMousePos, zoom + delta);
                                }

                                layer.debounceViewReset();
                            };

                            if (enabled) {
                                map.scrollWheelZoom.enable(); // re-enable after modifying
                            }
                        })();
                    }
                },

                updateView: function updateView() {
                    var view = this._map.getCenter();
                    view.zoom = Math.min(this._map.getZoom(), this._map.getMaxZoom() || _geo2['default'].max_zoom);
                    this.scene.setView(view);
                },

                updateSize: function updateSize() {
                    var size = this._map.getSize();
                    this.scene.resizeMap(size.x, size.y);
                },

                onTangramViewUpdate: function onTangramViewUpdate() {
                    if (!this._map || this._updating_tangram) {
                        return;
                    }
                    this._updating_tangram = true;
                    this._map.setView([this.scene.center.lat, this.scene.center.lng], this.scene.zoom, { animate: false });
                    this.reverseTransform();
                    this._updating_tangram = false;
                },

                render: function render() {
                    if (!this.scene) {
                        return;
                    }
                    this.scene.update();
                },

                // Reverse the CSS positioning Leaflet applies to the layer, since Tangram's WebGL canvas
                // is expected to be 'absolutely' positioned.
                reverseTransform: function reverseTransform() {
                    if (!this._map || !this.scene || !this.scene.container) {
                        return;
                    }

                    var top_left = this._map.containerPointToLayerPoint([0, 0]);
                    L.DomUtil.setPosition(this.scene.container, top_left);
                }

            });

            // Create the layer class
            exports.LeafletLayer = LeafletLayer = layerBaseClass.extend(layerClassConfig);

            // Polyfill some 1.0 methods
            if (typeof LeafletLayer.remove !== 'function') {
                LeafletLayer.prototype.remove = function () {
                    if (this._map) {
                        this._map.removeLayer(this);
                    }
                    this.fire('remove');
                };
            }

            LeafletLayer.layerBaseClass = layerBaseClass;
            LeafletLayer.leafletVersion = leafletVersion;

            return {
                v: new LeafletLayer(options)
            };
        })();

        if (typeof _ret === 'object') return _ret.v;
    }
}

},{"./geo":192,"./scene":209,"./utils/utils":241,"babel-runtime/core-js/object/assign":6,"babel-runtime/helpers/interop-require-default":22}],206:[function(_dereq_,module,exports){
/*global Light */
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _glShader_program = _dereq_('./gl/shader_program');

var _glShader_program2 = _interopRequireDefault(_glShader_program);

var _glShader_sources = _dereq_('./gl/shader_sources');

var _glShader_sources2 = _interopRequireDefault(_glShader_sources);

// built-in shaders

var _glGlsl = _dereq_('./gl/glsl');

var _glGlsl2 = _interopRequireDefault(_glGlsl);

var _geo = _dereq_('./geo');

var _geo2 = _interopRequireDefault(_geo);

var _stylesStyle_parser = _dereq_('./styles/style_parser');

// Abstract light

var Light = (function () {
    function Light(scene, config) {
        _classCallCheck(this, Light);

        this.name = config.name;
        this.scene = scene;

        if (config.ambient == null || typeof config.ambient === 'number') {
            this.ambient = _glGlsl2['default'].expandVec4(config.ambient || 0);
        } else {
            this.ambient = _stylesStyle_parser.StyleParser.parseColor(config.ambient);
        }

        if (config.diffuse == null || typeof config.diffuse === 'number') {
            this.diffuse = _glGlsl2['default'].expandVec4(config.diffuse != null ? config.diffuse : 1);
        } else {
            this.diffuse = _stylesStyle_parser.StyleParser.parseColor(config.diffuse);
        }

        if (config.specular == null || typeof config.specular === 'number') {
            this.specular = _glGlsl2['default'].expandVec4(config.specular || 0);
        } else {
            this.specular = _stylesStyle_parser.StyleParser.parseColor(config.specular);
        }
    }

    // Create a light by type name, factory-style
    // 'config' must include 'name' and 'type', along with any other type-specific properties

    _createClass(Light, [{
        key: 'inject',

        // Common instance definition
        value: function inject() {
            var instance = '\n            uniform ' + this.struct_name + ' u_' + this.name + ';\n            ' + this.struct_name + ' ' + this.name + ';\n            ';
            var assign = '\n            ' + this.name + ' = u_' + this.name + ';\n\n        ';

            _glShader_program2['default'].addBlock(Light.block, instance);
            _glShader_program2['default'].addBlock('setup', assign);
        }

        // Update method called once per frame
    }, {
        key: 'update',
        value: function update() {}

        // Called once per frame per program (e.g. for main render pass, then for each additional
        // pass for feature selection, etc.)
    }, {
        key: 'setupProgram',
        value: function setupProgram(_program) {
            //  Three common light properties
            _program.uniform('4fv', 'u_' + this.name + '.ambient', this.ambient);
            _program.uniform('4fv', 'u_' + this.name + '.diffuse', this.diffuse);
            _program.uniform('4fv', 'u_' + this.name + '.specular', this.specular);
        }
    }], [{
        key: 'create',
        value: function create(scene, config) {
            if (Light.types[config.type]) {
                return new Light.types[config.type](scene, config);
            }
        }

        // Set light for a style: fragment lighting, vertex lighting, or none
    }, {
        key: 'setMode',
        value: function setMode(mode, style) {
            if (mode === true) {
                mode = 'fragment';
            }
            mode = Light.enabled && (mode != null ? mode : 'fragment'); // default to fragment lighting
            style.defines['TANGRAM_LIGHTING_FRAGMENT'] = mode === 'fragment';
            style.defines['TANGRAM_LIGHTING_VERTEX'] = mode === 'vertex';
        }

        // Inject all provided light definitions, and calculate cumulative light function
    }, {
        key: 'inject',
        value: function inject(lights) {
            // Clear previous injections
            _glShader_program2['default'].removeBlock(Light.block);

            // If lighting is globally disabled, nothing is injected (mostly for debugging or live editing)
            if (!Light.enabled) {
                return;
            }

            // Construct code to calculate each light instance
            var calculateLights = "";
            if (lights && _Object$keys(lights).length > 0) {
                // Collect uniques types of lights
                var types = {};
                for (var light_name in lights) {
                    types[lights[light_name].type] = true;
                }

                // Inject each type of light
                for (var type in types) {
                    Light.types[type].inject();
                }

                // Inject per-instance blocks and construct the list of functions to calculate each light
                for (var light_name in lights) {
                    // Define instance
                    lights[light_name].inject();

                    // Add the calculation function to the list
                    calculateLights += 'calculateLight(' + light_name + ', _eyeToPoint, _normal);\n';
                }
            } else {
                // If no light is defined, use 100% omnidirectional diffuse light
                calculateLights = '\n                #ifdef TANGRAM_MATERIAL_DIFFUSE\n                    light_accumulator_diffuse = vec4(1.);\n                #endif\n            ';
            }

            // Glue together the final lighting function that sums all the lights
            var calculateFunction = '\n            vec4 calculateLighting(in vec3 _eyeToPoint, in vec3 _normal, in vec4 _color) {\n\n                // Do initial material calculations over normal, emission, ambient, diffuse and specular values\n                calculateMaterial(_eyeToPoint,_normal);\n\n                // Un roll the loop of individual ligths to calculate\n                ' + calculateLights + '\n\n                //  Final light intensity calculation\n                vec4 color = vec4(0.0);\n\n                #ifdef TANGRAM_MATERIAL_EMISSION\n                    color = material.emission;\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_AMBIENT\n                    color += light_accumulator_ambient * _color * material.ambient;\n                #else\n                    #ifdef TANGRAM_MATERIAL_DIFFUSE\n                        color += light_accumulator_ambient * _color * material.diffuse;\n                    #endif\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_DIFFUSE\n                    color += light_accumulator_diffuse * _color * material.diffuse;\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_SPECULAR\n                    color += light_accumulator_specular * material.specular;\n                #endif\n\n                // Clamp final color\n                color = clamp(color, 0.0, 1.0);\n\n                return color;\n            }';

            _glShader_program2['default'].addBlock(Light.block, calculateFunction);
        }
    }]);

    return Light;
})();

exports['default'] = Light;

Light.types = {}; // references to subclasses by short name
Light.block = 'lighting'; // shader block name
Light.enabled = true; // lighting can be globally enabled/disabled

// Light subclasses

var AmbientLight = (function (_Light) {
    _inherits(AmbientLight, _Light);

    function AmbientLight(scene, config) {
        _classCallCheck(this, AmbientLight);

        _get(Object.getPrototypeOf(AmbientLight.prototype), 'constructor', this).call(this, scene, config);
        this.type = 'ambient';
        this.struct_name = 'AmbientLight';
    }

    // Inject struct and calculate function

    _createClass(AmbientLight, [{
        key: 'setupProgram',
        value: function setupProgram(_program) {
            _program.uniform('4fv', 'u_' + this.name + '.ambient', this.ambient);
        }
    }], [{
        key: 'inject',
        value: function inject() {
            _glShader_program2['default'].addBlock(Light.block, _glShader_sources2['default']['gl/shaders/ambientLight']);
        }
    }]);

    return AmbientLight;
})(Light);

Light.types['ambient'] = AmbientLight;

var DirectionalLight = (function (_Light2) {
    _inherits(DirectionalLight, _Light2);

    function DirectionalLight(scene, config) {
        _classCallCheck(this, DirectionalLight);

        _get(Object.getPrototypeOf(DirectionalLight.prototype), 'constructor', this).call(this, scene, config);
        this.type = 'directional';
        this.struct_name = 'DirectionalLight';

        this.direction = (config.direction || [0.2, 0.7, -0.5]).map(parseFloat); // [x, y, z]
    }

    // Inject struct and calculate function

    _createClass(DirectionalLight, [{
        key: 'setupProgram',
        value: function setupProgram(_program) {
            _get(Object.getPrototypeOf(DirectionalLight.prototype), 'setupProgram', this).call(this, _program);
            _program.uniform('3fv', 'u_' + this.name + '.direction', this.direction);
        }
    }], [{
        key: 'inject',
        value: function inject() {
            _glShader_program2['default'].addBlock(Light.block, _glShader_sources2['default']['gl/shaders/directionalLight']);
        }
    }]);

    return DirectionalLight;
})(Light);

Light.types['directional'] = DirectionalLight;

var PointLight = (function (_Light3) {
    _inherits(PointLight, _Light3);

    function PointLight(scene, config) {
        _classCallCheck(this, PointLight);

        _get(Object.getPrototypeOf(PointLight.prototype), 'constructor', this).call(this, scene, config);
        this.type = 'point';
        this.struct_name = 'PointLight';

        this.position = config.position || [0, 0, 0];
        this.position_eye = []; // position in eyespace
        this.origin = config.origin || 'world';
        this.attenuation = !isNaN(parseFloat(config.attenuation)) ? parseFloat(config.attenuation) : 0;

        if (config.radius) {
            if (Array.isArray(config.radius) && config.radius.length === 2) {
                this.radius = config.radius;
            } else {
                this.radius = [null, config.radius];
            }
        } else {
            this.radius = null;
        }
    }

    // Inject struct and calculate function

    _createClass(PointLight, [{
        key: 'inject',

        // Inject isntance-specific settings
        value: function inject() {
            _get(Object.getPrototypeOf(PointLight.prototype), 'inject', this).call(this);

            _glShader_program2['default'].defines['TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT'] = this.attenuation !== 0;
            _glShader_program2['default'].defines['TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS'] = this.radius != null && this.radius[0] != null;
            _glShader_program2['default'].defines['TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS'] = this.radius != null;
        }
    }, {
        key: 'update',
        value: function update() {
            this.updateEyePosition();
        }
    }, {
        key: 'updateEyePosition',
        value: function updateEyePosition() {
            if (this.origin === 'world') {
                // For world origin, format is: [longitude, latitude, meters (default) or pixels w/px units]

                var _Geo$latLngToMeters = _geo2['default'].latLngToMeters(this.position);

                var _Geo$latLngToMeters2 = _slicedToArray(_Geo$latLngToMeters, 2);

                var x = _Geo$latLngToMeters2[0];
                var y = _Geo$latLngToMeters2[1];

                this.position_eye[0] = x - this.scene.camera.position_meters[0];
                this.position_eye[1] = y - this.scene.camera.position_meters[1];

                this.position_eye[2] = _stylesStyle_parser.StyleParser.convertUnits(this.position[2], { zoom: this.scene.zoom });
                this.position_eye[2] = this.position_eye[2] - this.scene.camera.position_meters[2];
            }
            if (this.origin === 'ground' || this.origin === 'camera') {
                // For camera or ground origin, format is: [x, y, z] in meters (default) or pixels w/px units

                // Light is in camera space by default
                this.position_eye = _stylesStyle_parser.StyleParser.convertUnits(this.position, { zoom: this.scene.zoom });

                if (this.origin === 'ground') {
                    // Leave light's xy in camera space, but z needs to be moved relative to ground plane
                    this.position_eye[2] = this.position_eye[2] - this.scene.camera.position_meters[2];
                }
            }
        }
    }, {
        key: 'setupProgram',
        value: function setupProgram(_program) {
            _get(Object.getPrototypeOf(PointLight.prototype), 'setupProgram', this).call(this, _program);

            _program.uniform('4f', 'u_' + this.name + '.position', this.position_eye[0], this.position_eye[1], this.position_eye[2], 1);

            if (_glShader_program2['default'].defines['TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT']) {
                _program.uniform('1f', 'u_' + this.name + '.attenuationExponent', this.attenuation);
            }

            if (_glShader_program2['default'].defines['TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS']) {
                _program.uniform('1f', 'u_' + this.name + '.innerRadius', _stylesStyle_parser.StyleParser.convertUnits(this.radius[0], { zoom: this.scene.zoom }));
            }

            if (_glShader_program2['default'].defines['TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS']) {
                _program.uniform('1f', 'u_' + this.name + '.outerRadius', _stylesStyle_parser.StyleParser.convertUnits(this.radius[1], { zoom: this.scene.zoom }));
            }
        }
    }], [{
        key: 'inject',
        value: function inject() {
            _glShader_program2['default'].addBlock(Light.block, _glShader_sources2['default']['gl/shaders/pointLight']);
        }
    }]);

    return PointLight;
})(Light);

Light.types['point'] = PointLight;

var SpotLight = (function (_PointLight) {
    _inherits(SpotLight, _PointLight);

    function SpotLight(scene, config) {
        _classCallCheck(this, SpotLight);

        _get(Object.getPrototypeOf(SpotLight.prototype), 'constructor', this).call(this, scene, config);
        this.type = 'spotlight';
        this.struct_name = 'SpotLight';

        this.direction = (config.direction || [0, 0, -1]).map(parseFloat); // [x, y, z]
        this.exponent = config.exponent ? parseFloat(config.exponent) : 0.2;
        this.angle = config.angle ? parseFloat(config.angle) : 20;
    }

    // Inject struct and calculate function

    _createClass(SpotLight, [{
        key: 'setupProgram',
        value: function setupProgram(_program) {
            _get(Object.getPrototypeOf(SpotLight.prototype), 'setupProgram', this).call(this, _program);

            _program.uniform('3fv', 'u_' + this.name + '.direction', this.direction);
            _program.uniform('1f', 'u_' + this.name + '.spotCosCutoff', Math.cos(this.angle * 3.14159 / 180));
            _program.uniform('1f', 'u_' + this.name + '.spotExponent', this.exponent);
        }
    }], [{
        key: 'inject',
        value: function inject() {
            _glShader_program2['default'].addBlock(Light.block, _glShader_sources2['default']['gl/shaders/spotLight']);
        }
    }]);

    return SpotLight;
})(PointLight);

Light.types['spotlight'] = SpotLight;
module.exports = exports['default'];
// Move light's world position into camera space

},{"./geo":192,"./gl/glsl":196,"./gl/shader_program":198,"./gl/shader_sources":199,"./styles/style_parser":225,"babel-runtime/core-js/object/keys":11,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/get":20,"babel-runtime/helpers/inherits":21,"babel-runtime/helpers/interop-require-default":22,"babel-runtime/helpers/sliced-to-array":23}],207:[function(_dereq_,module,exports){
/*global Material */
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _glShader_sources = _dereq_('./gl/shader_sources');

var _glShader_sources2 = _interopRequireDefault(_glShader_sources);

// built-in shaders

var _glGlsl = _dereq_('./gl/glsl');

var _glGlsl2 = _interopRequireDefault(_glGlsl);

var _stylesStyle_parser = _dereq_('./styles/style_parser');

var Material = (function () {
    function Material(config) {
        _classCallCheck(this, Material);

        config = config || {};

        // These properties all have the same defaults, so they can be set in bulk
        var _arr = ['emission', 'ambient', 'diffuse', 'specular'];
        for (var _i = 0; _i < _arr.length; _i++) {
            var prop = _arr[_i];
            if (config[prop] != null) {
                if (config[prop].texture) {
                    this[prop] = {
                        texture: config[prop].texture,
                        mapping: config[prop].mapping || 'spheremap',
                        scale: _glGlsl2['default'].expandVec3(config[prop].scale != null ? config[prop].scale : 1),
                        amount: _glGlsl2['default'].expandVec4(config[prop].amount != null ? config[prop].amount : 1)
                    };
                } else if (typeof config[prop] === 'number') {
                    this[prop] = { amount: _glGlsl2['default'].expandVec4(config[prop]) };
                } else if (typeof config[prop] === 'string') {
                    this[prop] = { amount: _stylesStyle_parser.StyleParser.parseColor(config[prop]) };
                } else {
                    this[prop] = config[prop];
                }
            }
        }

        // Extra specular props
        if (this.specular) {
            this.specular.shininess = config.shininess ? parseFloat(config.shininess) : 0.2;
        }

        // Normal mapping
        if (config.normal != null) {
            this.normal = {
                texture: config.normal.texture,
                mapping: config.normal.mapping || 'triplanar',
                scale: _glGlsl2['default'].expandVec3(config.normal.scale != null ? config.normal.scale : 1),
                amount: config.normal.amount != null ? config.normal.amount : 1
            };
        }
    }

    // Determine if a material config block has sufficient properties to create a material

    _createClass(Material, [{
        key: 'inject',
        value: function inject(style) {
            // For each property, sets defines to configure texture mapping, with a pattern like:
            //   TANGRAM_MATERIAL_DIFFUSE, TANGRAM_MATERIAL_DIFFUSE_TEXTURE, TANGRAM_MATERIAL_DIFFUSE_TEXTURE_SPHEREMAP
            // Also sets flags to keep track of each unique mapping type being used, e.g.:
            //   TANGRAM_MATERIAL_TEXTURE_SPHEREMAP
            // Enables texture coordinates if needed and not already on
            var _arr2 = ['emission', 'ambient', 'diffuse', 'specular'];
            for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                var prop = _arr2[_i2];
                var def = 'TANGRAM_MATERIAL_' + prop.toUpperCase();
                var texdef = def + '_TEXTURE';
                style.defines[def] = this[prop] != null;
                if (this[prop] && this[prop].texture) {
                    style.defines[texdef] = true;
                    style.defines[texdef + '_' + this[prop].mapping.toUpperCase()] = true;
                    style.defines['TANGRAM_MATERIAL_TEXTURE_' + this[prop].mapping.toUpperCase()] = true;
                    style.texcoords = style.texcoords || this[prop].mapping === 'uv';
                }
            }

            // Normal mapping
            // As anove, sets flags to keep track of each unique mapping type being used, e.g.:
            //   TANGRAM_MATERIAL_TEXTURE_SPHEREMAP
            if (this.normal && this.normal.texture) {
                style.defines['TANGRAM_MATERIAL_NORMAL_TEXTURE'] = true;
                style.defines['TANGRAM_MATERIAL_NORMAL_TEXTURE_' + this.normal.mapping.toUpperCase()] = true;
                style.defines['TANGRAM_MATERIAL_TEXTURE_' + this.normal.mapping.toUpperCase()] = true;
                style.texcoords = style.texcoords || this.normal.mapping === 'uv';
            }

            style.replaceShaderBlock(Material.block, _glShader_sources2['default']['gl/shaders/material'], 'Material');
            style.addShaderBlock('setup', '\nmaterial = u_material;\n', 'Material');
        }
    }, {
        key: 'setupProgram',
        value: function setupProgram(_program) {
            // For each property, sets uniforms in the pattern:
            // u_material.diffuse, u_material.diffuseScale u_material_diffuse_texture
            var _arr3 = ['emission', 'ambient', 'diffuse', 'specular'];
            for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
                var prop = _arr3[_i3];
                if (this[prop]) {
                    if (this[prop].texture) {
                        _program.setTextureUniform('u_material_' + prop + '_texture', this[prop].texture);
                        _program.uniform('3fv', 'u_material.' + prop + 'Scale', this[prop].scale);
                        _program.uniform('4fv', 'u_material.' + prop, this[prop].amount);
                    } else if (this[prop].amount) {
                        _program.uniform('4fv', 'u_material.' + prop, this[prop].amount);
                    }
                }
            }

            // Extra specular props
            if (this.specular) {
                _program.uniform('1f', 'u_material.shininess', this.specular.shininess);
            }

            // Normal mapping
            if (this.normal && this.normal.texture) {
                _program.setTextureUniform('u_material_normal_texture', this.normal.texture);
                _program.uniform('3fv', 'u_material.normalScale', this.normal.scale);
                _program.uniform('1f', 'u_material.normalAmount', this.normal.amount);
            }
        }
    }], [{
        key: 'isValid',
        value: function isValid(config) {
            if (config == null) {
                return false;
            }

            if (config.emission == null && config.ambient == null && config.diffuse == null && config.specular == null) {
                return false;
            }

            return true;
        }
    }]);

    return Material;
})();

exports['default'] = Material;

Material.block = 'material';
module.exports = exports['default'];

},{"./gl/glsl":196,"./gl/shader_sources":199,"./styles/style_parser":225,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/interop-require-default":22}],208:[function(_dereq_,module,exports){
/*jshint worker: true*/

// Modules and dependencies to expose in the public Tangram module
'use strict';

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

var _utilsUtils = _dereq_('./utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

// The leaflet layer plugin is currently the primary public API

var _leaflet_layer = _dereq_('./leaflet_layer');

// The scene worker is only activated when a worker thread is instantiated, but must always be loaded

var _srcScene_worker = _dereq_('../src/scene_worker');

// Additional modules are exposed for debugging

var _utilsVersion = _dereq_('./utils/version');

var _utilsVersion2 = _interopRequireDefault(_utilsVersion);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var _geo = _dereq_('./geo');

var _geo2 = _interopRequireDefault(_geo);

var _sourcesData_source = _dereq_('./sources/data_source');

var _sourcesData_source2 = _interopRequireDefault(_sourcesData_source);

_dereq_('./sources/geojson');

_dereq_('./sources/topojson');

_dereq_('./sources/mvt');

var _tile_manager = _dereq_('./tile_manager');

var _tile_manager2 = _interopRequireDefault(_tile_manager);

var _glGlsl = _dereq_('./gl/glsl');

var _glGlsl2 = _interopRequireDefault(_glGlsl);

var _glShader_program = _dereq_('./gl/shader_program');

var _glShader_program2 = _interopRequireDefault(_glShader_program);

var _glVertex_data = _dereq_('./gl/vertex_data');

var _glVertex_data2 = _interopRequireDefault(_glVertex_data);

var _glTexture = _dereq_('./gl/texture');

var _glTexture2 = _interopRequireDefault(_glTexture);

var _material = _dereq_('./material');

var _material2 = _interopRequireDefault(_material);

var _light = _dereq_('./light');

var _light2 = _interopRequireDefault(_light);

var _utilsWorker_broker = _dereq_('./utils/worker_broker');

var _utilsWorker_broker2 = _interopRequireDefault(_utilsWorker_broker);

var _stylesRule = _dereq_('./styles/rule');

var _stylesStyle_manager = _dereq_('./styles/style_manager');

var _stylesStyle_parser = _dereq_('./styles/style_parser');

var _selection = _dereq_('./selection');

var _selection2 = _interopRequireDefault(_selection);

var _jsYaml = _dereq_('js-yaml');

var _jsYaml2 = _interopRequireDefault(_jsYaml);

var _glMatrix = _dereq_('gl-matrix');

var _glMatrix2 = _interopRequireDefault(_glMatrix);

// Default to 64-bit because we need the extra precision when multiplying matrices w/mercator projected values
_glMatrix2['default'].glMatrix.setMatrixArrayType(Float64Array);

// Make some modules accessible for debugging
var debug = {
    log: _loglevel2['default'],
    yaml: _jsYaml2['default'],
    Utils: _utilsUtils2['default'],
    Geo: _geo2['default'],
    DataSource: _sourcesData_source2['default'],
    TileManager: _tile_manager2['default'],
    GLSL: _glGlsl2['default'],
    ShaderProgram: _glShader_program2['default'],
    VertexData: _glVertex_data2['default'],
    Texture: _glTexture2['default'],
    Material: _material2['default'],
    Light: _light2['default'],
    SceneWorker: _srcScene_worker.SceneWorker,
    WorkerBroker: _utilsWorker_broker2['default'],
    ruleCache: _stylesRule.ruleCache,
    StyleManager: _stylesStyle_manager.StyleManager,
    StyleParser: _stylesStyle_parser.StyleParser,
    FeatureSelection: _selection2['default']
};

// Window can only be set in main thread
if (_utilsUtils2['default'].isMainThread) {

    window.Tangram = module.exports = {
        leafletLayer: _leaflet_layer.leafletLayer,
        debug: debug,
        version: _utilsVersion2['default'].string
    };
}

if (_utilsUtils2['default'].isWorkerThread) {
    self.Tangram = {
        debug: debug,
        version: _utilsVersion2['default'].string
    };
}

if (_utilsUtils2['default'].isMainThread) {
    _utilsUtils2['default'].requestAnimationFramePolyfill();
}

// Setup logging to prefix with Tangram version
var originalFactory = _loglevel2['default'].methodFactory;
_loglevel2['default'].methodFactory = function (methodName, logLevel) {
    var rawMethod = originalFactory(methodName, logLevel);
    return function () {
        for (var _len = arguments.length, message = Array(_len), _key = 0; _key < _len; _key++) {
            message[_key] = arguments[_key];
        }

        rawMethod.apply(undefined, ['Tangram ' + _utilsVersion2['default'].string + ':'].concat(message));
    };
};

},{"../src/scene_worker":211,"./geo":192,"./gl/glsl":196,"./gl/shader_program":198,"./gl/texture":200,"./gl/vertex_data":203,"./leaflet_layer":205,"./light":206,"./material":207,"./selection":212,"./sources/data_source":213,"./sources/geojson":214,"./sources/mvt":215,"./sources/topojson":216,"./styles/rule":222,"./styles/style_manager":224,"./styles/style_parser":225,"./tile_manager":236,"./utils/utils":241,"./utils/version":242,"./utils/worker_broker":243,"babel-runtime/helpers/interop-require-default":22,"gl-matrix":146,"js-yaml":148,"loglevel":179}],209:[function(_dereq_,module,exports){
/*global Scene */
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _geo = _dereq_('./geo');

var _geo2 = _interopRequireDefault(_geo);

var _utilsUtils = _dereq_('./utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _utilsWorker_broker = _dereq_('./utils/worker_broker');

var _utilsWorker_broker2 = _interopRequireDefault(_utilsWorker_broker);

var _utilsSubscribe = _dereq_('./utils/subscribe');

var _utilsSubscribe2 = _interopRequireDefault(_utilsSubscribe);

var _glContext = _dereq_('./gl/context');

var _glContext2 = _interopRequireDefault(_glContext);

var _glTexture = _dereq_('./gl/texture');

var _glTexture2 = _interopRequireDefault(_glTexture);

var _glVao = _dereq_('./gl/vao');

var _glVao2 = _interopRequireDefault(_glVao);

var _stylesStyle = _dereq_('./styles/style');

var _stylesStyle_manager = _dereq_('./styles/style_manager');

var _stylesStyle_parser = _dereq_('./styles/style_parser');

var _scene_loader = _dereq_('./scene_loader');

var _scene_loader2 = _interopRequireDefault(_scene_loader);

var _camera = _dereq_('./camera');

var _camera2 = _interopRequireDefault(_camera);

var _light = _dereq_('./light');

var _light2 = _interopRequireDefault(_light);

var _tile_manager = _dereq_('./tile_manager');

var _tile_manager2 = _interopRequireDefault(_tile_manager);

var _sourcesData_source = _dereq_('./sources/data_source');

var _sourcesData_source2 = _interopRequireDefault(_sourcesData_source);

var _selection = _dereq_('./selection');

var _selection2 = _interopRequireDefault(_selection);

var _glRender_state = _dereq_('./gl/render_state');

var _glRender_state2 = _interopRequireDefault(_glRender_state);

var _stylesPolygonsPolygons = _dereq_('./styles/polygons/polygons');

var _stylesLinesLines = _dereq_('./styles/lines/lines');

var _stylesPointsPoints = _dereq_('./styles/points/points');

var _stylesTextText = _dereq_('./styles/text/text');

// Add built-in rendering styles

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var _glMatrix = _dereq_('gl-matrix');

var _glMatrix2 = _interopRequireDefault(_glMatrix);

_stylesStyle_manager.StyleManager.register(_stylesPolygonsPolygons.Polygons);
_stylesStyle_manager.StyleManager.register(_stylesLinesLines.Lines);
_stylesStyle_manager.StyleManager.register(_stylesPointsPoints.Points);
_stylesStyle_manager.StyleManager.register(_stylesTextText.TextStyle);

var mat4 = _glMatrix2['default'].mat4;
var mat3 = _glMatrix2['default'].mat3;
var vec3 = _glMatrix2['default'].vec3;

// Load scene definition: pass an object directly, or a URL as string to load remotely

var Scene = (function () {
    function Scene(config_source, options) {
        var _this = this;

        _classCallCheck(this, Scene);

        options = options || {};
        (0, _utilsSubscribe2['default'])(this);

        this.initialized = false;
        this.initializing = false;
        this.sources = {};

        this.tile_manager = _tile_manager2['default'];
        this.tile_manager.init(this);
        this.num_workers = options.numWorkers || 2;
        this.continuous_zoom = typeof options.continuousZoom === 'boolean' ? options.continuousZoom : true;
        this.tile_simplification_level = 0; // level-of-detail downsampling to apply to tile loading
        this.allow_cross_domain_workers = options.allowCrossDomainWorkers === false ? false : true;
        this.worker_url = options.workerUrl;
        if (options.disableVertexArrayObjects === true) {
            _glVao2['default'].disabled = true;
        }

        _utilsUtils2['default'].use_high_density_display = options.highDensityDisplay !== undefined ? options.highDensityDisplay : true;
        _utilsUtils2['default'].updateDevicePixelRatio();

        this.config = null;
        this.config_source = config_source;
        this.config_serialized = null;
        this.last_valid_config_source = null;

        this.styles = null;
        this.active_styles = {};

        this.building = null; // tracks current scene building state (tiles being built, etc.)
        this.dirty = true; // request a redraw
        this.animated = false; // request redraw every frame
        this.preUpdate = options.preUpdate; // optional pre-render loop hook
        this.postUpdate = options.postUpdate; // optional post-render loop hook
        this.render_loop = !options.disableRenderLoop; // disable render loop - app will have to manually call Scene.render() per frame
        this.render_loop_active = false;
        this.render_loop_stop = false;
        this.frame = 0;
        this.resetTime();

        this.zoom = null;
        this.center = null;

        this.zooming = false;
        this.preserve_tiles_within_zoom = 1;
        this.panning = false;
        this.container = options.container;

        this.camera = null;
        this.lights = null;
        this.background = null;

        // Model-view matrices
        // 64-bit versions are for CPU calcuations
        // 32-bit versions are downsampled and sent to GPU
        this.modelMatrix = new Float64Array(16);
        this.modelMatrix32 = new Float32Array(16);
        this.modelViewMatrix = new Float64Array(16);
        this.modelViewMatrix32 = new Float32Array(16);
        this.normalMatrix = new Float64Array(9);
        this.normalMatrix32 = new Float32Array(9);
        this.inverseNormalMatrix32 = new Float32Array(9);

        this.selection = null;
        this.texture_listener = null;

        // Debug config
        this.debug = {
            profile: {
                geometry_build: false
            },
            timeRebuild: function timeRebuild(n) {
                return _this._timeRebuild(n);
            }
        };

        this.updating = 0;
        this.generation = 0; // an id that is incremented each time the scene config is invalidated

        this.logLevel = options.logLevel || 'warn';
        _loglevel2['default'].setLevel(this.logLevel);
    }

    // Static methods/state

    // Load (or reload) scene config
    // Optionally specify new scene file URL

    _createClass(Scene, [{
        key: 'load',
        value: function load() {
            var _this2 = this;

            var config_source = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
            var config_path = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

            if (this.initializing) {
                return _Promise.resolve();
            }

            this.updating++;
            this.initialized = false;
            this.initializing = true;

            // Load scene definition (sources, styles, etc.), then create styles & workers
            return this.loadScene(config_source, config_path).then(function () {
                return _this2.createWorkers();
            }).then(function () {
                _this2.createCanvas();
                _this2.resetFeatureSelection();

                if (!_this2.texture_listener) {
                    _this2.texture_listener = {
                        update: function update() {
                            return _this2.dirty = true;
                        },
                        warning: function warning(data) {
                            return _this2.trigger('warning', _Object$assign({ type: 'textures' }, data));
                        }
                    };
                    _glTexture2['default'].subscribe(_this2.texture_listener);
                }

                // Remove tiles before rebuilding
                _this2.tile_manager.removeTiles(function (tile) {
                    return !tile.visible;
                });
                return _this2.updateConfig({ rebuild: true });
            }).then(function () {
                _this2.updating--;
                _this2.initializing = false;
                _this2.initialized = true;
                _this2.last_valid_config_source = _this2.config_source;
                _this2.last_valid_config_path = _this2.config_path;

                if (_this2.render_loop !== false) {
                    _this2.setupRenderLoop();
                }
                _this2.requestRedraw();
            })['catch'](function (error) {
                _this2.initializing = false;
                _this2.updating = 0;

                // Report and revert to last valid config if available
                var type = undefined,
                    message = undefined;
                if (error.name === 'YAMLException') {
                    type = 'yaml';
                    message = 'Error parsing scene YAML';
                } else {
                    // TODO: more error types
                    message = 'Error initializing scene';
                }
                _this2.trigger('error', { type: type, message: message, error: error, url: _this2.config_source });

                message = 'Scene.load() failed to load ' + _this2.config_source + ': ' + error.message;
                if (_this2.last_valid_config_source) {
                    _loglevel2['default'].warn(message, error);
                    _loglevel2['default'].info('Scene.load() reverting to last valid configuration');
                    return _this2.load(_this2.last_valid_config_source, _this2.last_valid_config_path);
                }
                _loglevel2['default'].error(message, error);
                throw error;
            });
        }

        // For API compatibility
    }, {
        key: 'reload',
        value: function reload() {
            var config_source = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
            var config_path = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

            return this.load(config_source, config_path);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.initialized = false;
            this.render_loop_stop = true; // schedule render loop to stop

            this.unsubscribeAll(); // clear all event listeners

            _glTexture2['default'].unsubscribe(this.texture_listener);
            this.texture_listener = null;

            if (this.canvas && this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
                this.canvas = null;
            }
            this.container = null;

            if (this.selection) {
                this.selection.destroy();
            }

            if (this.gl) {
                _glTexture2['default'].destroy(this.gl);
                _stylesStyle_manager.StyleManager.destroy(this.gl);
                this.styles = {};

                this.gl = null;
            }

            this.sources = {};

            if (Array.isArray(this.workers)) {
                this.workers.forEach(function (worker) {
                    worker.terminate();
                });
                this.workers = null;
            }

            this.tile_manager.destroy();
        }
    }, {
        key: 'createCanvas',
        value: function createCanvas() {
            if (this.canvas) {
                return;
            }

            this.container = this.container || document.body;
            this.canvas = document.createElement('canvas');
            this.canvas.style.position = 'absolute';
            this.canvas.style.top = 0;
            this.canvas.style.left = 0;

            // Force tangram canvas underneath all leaflet layers, and set background to transparent
            this.container.style.backgroundColor = 'transparent';
            this.container.appendChild(this.canvas);

            try {
                this.gl = _glContext2['default'].getContext(this.canvas, {
                    alpha: true, premultipliedAlpha: true, // TODO: vary w/scene alpha
                    device_pixel_ratio: _utilsUtils2['default'].device_pixel_ratio
                });
            } catch (e) {
                throw new Error("Couldn't create WebGL context. " + "Your browser may not support WebGL, or it's turned off? " + "Visit http://webglreport.com/ for more info.");
            }

            this.resizeMap(this.container.clientWidth, this.container.clientHeight);
            _glVao2['default'].init(this.gl);
            _glRender_state2['default'].initialize(this.gl);
        }

        // Get the URL to load the web worker from
    }, {
        key: 'getWorkerUrl',
        value: function getWorkerUrl() {
            var worker_url = this.worker_url || _utilsUtils2['default'].findCurrentURL('tangram.debug.js', 'tangram.min.js');

            if (!worker_url) {
                throw new Error("Can't load worker because couldn't find base URL that library was loaded from");
            }

            if (this.allow_cross_domain_workers) {
                var body = 'importScripts(\'' + worker_url + '\');';
                return _utilsUtils2['default'].createObjectURL(new Blob([body], { type: 'application/javascript' }));
            }
            return worker_url;
        }

        // Web workers handle heavy duty tile construction: networking, geometry processing, etc.
    }, {
        key: 'createWorkers',
        value: function createWorkers() {
            if (!this.workers) {
                return this.makeWorkers(this.getWorkerUrl());
            }
            return _Promise.resolve();
        }

        // Instantiate workers from URL, init event handlers
    }, {
        key: 'makeWorkers',
        value: function makeWorkers(url) {
            var _this3 = this;

            var queue = [];

            this.workers = [];

            var _loop = function () {
                worker = new Worker(url);

                _this3.workers[id] = worker;

                worker.addEventListener('message', _this3.workerLogMessage.bind(_this3));
                _utilsWorker_broker2['default'].addWorker(worker);

                _loglevel2['default'].debug('Scene.makeWorkers: initializing worker ' + id);
                var _id = id;
                queue.push(_utilsWorker_broker2['default'].postMessage(worker, 'self.init', id, _this3.num_workers, _utilsUtils2['default'].device_pixel_ratio).then(function (id) {
                    _loglevel2['default'].debug('Scene.makeWorkers: initialized worker ' + id);
                    return id;
                }, function (error) {
                    _loglevel2['default'].error('Scene.makeWorkers: failed to initialize worker ' + _id + ':', error);
                    return _Promise.reject(error);
                }));
            };

            for (var id = 0; id < this.num_workers; id++) {
                var worker;

                _loop();
            }

            this.next_worker = 0;
            return _Promise.all(queue);
        }

        // Round robin selection of next worker
    }, {
        key: 'nextWorker',
        value: function nextWorker() {
            var worker = this.workers[this.next_worker];
            this.next_worker = (this.next_worker + 1) % this.workers.length;
            return worker;
        }

        /**
            Set the map view, can be passed an object with lat/lng and/or zoom
        */
    }, {
        key: 'setView',
        value: function setView() {
            var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            var lng = _ref.lng;
            var lat = _ref.lat;
            var zoom = _ref.zoom;

            var changed = false;

            // Set center
            if (typeof lng === 'number' && typeof lat === 'number') {
                if (!this.center || lng !== this.center.lng || lat !== this.center.lat) {
                    changed = true;
                    this.center = { lng: _geo2['default'].wrapLng(lng), lat: lat };
                }
            }

            // Set zoom
            if (typeof zoom === 'number' && zoom !== this.zoom) {
                changed = true;
                this.setZoom(zoom);
            }

            if (changed) {
                this.updateBounds();
            }
            return changed;
        }
    }, {
        key: 'startZoom',
        value: function startZoom() {
            this.last_zoom = this.zoom;
            this.zooming = true;
        }

        // Choose the base zoom level to use for a given fractional zoom
    }, {
        key: 'baseZoom',
        value: function baseZoom(zoom) {
            return Math.floor(zoom);
        }

        // For a given view zoom, what tile zoom should be loaded?
    }, {
        key: 'tileZoom',
        value: function tileZoom(view_zoom) {
            return this.baseZoom(view_zoom) - this.tile_simplification_level;
        }

        // For a given tile zoom, what style zoom should be used?
    }, {
        key: 'styleZoom',
        value: function styleZoom(tile_zoom) {
            return this.baseZoom(tile_zoom) + this.tile_simplification_level;
        }
    }, {
        key: 'setZoom',
        value: function setZoom(zoom) {
            var _this4 = this;

            this.zooming = false;
            var tile_zoom = this.tileZoom(zoom);

            if (!this.continuous_zoom) {
                zoom = tile_zoom;
            }

            if (tile_zoom !== this.tileZoom(this.last_zoom)) {
                // Remove tiles outside current zoom that are still loading
                this.tile_manager.removeTiles(function (tile) {
                    if (tile.loading && _this4.tileZoom(tile.coords.z) !== tile_zoom) {
                        _loglevel2['default'].trace('removed ' + tile.key + ' (was loading, but outside current zoom)');
                        return true;
                    }
                });
            }

            this.last_zoom = this.zoom;
            this.zoom = zoom;
            this.tile_zoom = tile_zoom;

            this.updateBounds();

            this.dirty = true;
        }
    }, {
        key: 'viewReady',
        value: function viewReady() {
            if (this.css_size == null || this.center == null || this.zoom == null || _Object$keys(this.sources).length === 0) {
                return false;
            }
            return true;
        }

        // Calculate viewport bounds based on current center and zoom
    }, {
        key: 'updateBounds',
        value: function updateBounds() {
            // TODO: better concept of "readiness" state?
            if (!this.viewReady()) {
                return;
            }

            this.meters_per_pixel = _geo2['default'].metersPerPixel(this.zoom);

            // Size of the half-viewport in meters at current zoom
            this.viewport_meters = {
                x: this.css_size.width * this.meters_per_pixel,
                y: this.css_size.height * this.meters_per_pixel
            };

            // Center of viewport in meters, and tile

            var _Geo$latLngToMeters = _geo2['default'].latLngToMeters([this.center.lng, this.center.lat]);

            var _Geo$latLngToMeters2 = _slicedToArray(_Geo$latLngToMeters, 2);

            var x = _Geo$latLngToMeters2[0];
            var y = _Geo$latLngToMeters2[1];

            this.center_meters = { x: x, y: y };

            var z = this.tileZoom(this.zoom);
            this.center_tile = _geo2['default'].tileForMeters([this.center_meters.x, this.center_meters.y], z);

            this.bounds_meters = {
                sw: {
                    x: this.center_meters.x - this.viewport_meters.x / 2,
                    y: this.center_meters.y - this.viewport_meters.y / 2
                },
                ne: {
                    x: this.center_meters.x + this.viewport_meters.x / 2,
                    y: this.center_meters.y + this.viewport_meters.y / 2
                }
            };

            this.tile_manager.updateTilesForView();

            this.trigger('move');
            this.dirty = true;
        }
    }, {
        key: 'findVisibleTileCoordinates',
        value: function findVisibleTileCoordinates() {
            var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            var buffer = _ref2.buffer;

            if (!this.bounds_meters) {
                return [];
            }

            var z = this.tileZoom(this.zoom);
            var sw = _geo2['default'].tileForMeters([this.bounds_meters.sw.x, this.bounds_meters.sw.y], z);
            var ne = _geo2['default'].tileForMeters([this.bounds_meters.ne.x, this.bounds_meters.ne.y], z);
            buffer = buffer || 0;

            var coords = [];
            for (var x = sw.x - buffer; x <= ne.x + buffer; x++) {
                for (var y = ne.y - buffer; y <= sw.y + buffer; y++) {
                    coords.push({ x: x, y: y, z: z });
                }
            }
            return coords;
        }

        // Remove tiles too far outside of view
    }, {
        key: 'pruneTileCoordinatesForView',
        value: function pruneTileCoordinatesForView() {
            var _this5 = this;

            var border_buffer = arguments.length <= 0 || arguments[0] === undefined ? 2 : arguments[0];

            if (!this.viewReady()) {
                return;
            }

            // Remove tiles that are a specified # of tiles outside of the viewport border
            var border_tiles = [Math.ceil((Math.floor(this.css_size.width / _geo2['default'].tile_size) + 2) / 2), Math.ceil((Math.floor(this.css_size.height / _geo2['default'].tile_size) + 2) / 2)];
            var style_zoom = this.tileZoom(this.zoom);

            this.tile_manager.removeTiles(function (tile) {
                // Ignore visible tiles
                if (tile.visible) {
                    return false;
                }

                // Discard if too far from current zoom
                var zdiff = tile.coords.z - style_zoom;
                if (Math.abs(zdiff) > _this5.preserve_tiles_within_zoom) {
                    return true;
                }

                // Handle tiles at different zooms
                var ztrans = Math.pow(2, zdiff);
                var coords = {
                    x: Math.floor(tile.coords.x / ztrans),
                    y: Math.floor(tile.coords.y / ztrans)
                };

                // Discard tiles outside an area surrounding the viewport
                if (Math.abs(coords.x - _this5.center_tile.x) - border_tiles[0] > border_buffer) {
                    _loglevel2['default'].trace('Scene: remove tile ' + tile.key + ' (as ' + coords.x + '/' + coords.y + '/' + style_zoom + ') for being too far out of visible area ***');
                    return true;
                } else if (Math.abs(coords.y - _this5.center_tile.y) - border_tiles[1] > border_buffer) {
                    _loglevel2['default'].trace('Scene: remove tile ' + tile.key + ' (as ' + coords.x + '/' + coords.y + '/' + style_zoom + ') for being too far out of visible area ***');
                    return true;
                }
                return false;
            });
        }

        // Resize the map when device pixel ratio changes, e.g. when switching between displays
    }, {
        key: 'updateDevicePixelRatio',
        value: function updateDevicePixelRatio() {
            var _this6 = this;

            if (_utilsUtils2['default'].updateDevicePixelRatio()) {
                _utilsWorker_broker2['default'].postMessage(this.workers, 'self.updateDevicePixelRatio', _utilsUtils2['default'].device_pixel_ratio).then(function () {
                    return _this6.rebuild();
                }).then(function () {
                    return _this6.resizeMap(_this6.css_size.width, _this6.css_size.height);
                });
            }
        }
    }, {
        key: 'resizeMap',
        value: function resizeMap(width, height) {
            this.dirty = true;

            this.css_size = { width: width, height: height };
            this.device_size = {
                width: Math.round(this.css_size.width * _utilsUtils2['default'].device_pixel_ratio),
                height: Math.round(this.css_size.height * _utilsUtils2['default'].device_pixel_ratio)
            };
            this.view_aspect = this.css_size.width / this.css_size.height;
            this.updateBounds();

            if (this.canvas) {
                this.canvas.style.width = this.css_size.width + 'px';
                this.canvas.style.height = this.css_size.height + 'px';
                this.canvas.width = this.device_size.width;
                this.canvas.height = this.device_size.height;

                if (this.gl) {
                    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                }
            }
        }

        // Request scene be redrawn at next animation loop
    }, {
        key: 'requestRedraw',
        value: function requestRedraw() {
            this.dirty = true;
        }

        // Redraw scene immediately - don't wait for animation loop
        // Use sparingly, but for cases where you need the closest possible sync with other UI elements,
        // such as other, non-WebGL map layers (e.g. Leaflet raster layers, markers, etc.)
    }, {
        key: 'immediateRedraw',
        value: function immediateRedraw() {
            this.dirty = true;
            this.update();
        }
    }, {
        key: 'renderLoop',
        value: function renderLoop() {
            this.render_loop_active = true; // only let the render loop instantiate once

            if (this.initialized) {
                // Render the scene
                this.update();
            }

            // Request the next frame if not scheduled to stop
            if (!this.render_loop_stop) {
                window.requestAnimationFrame(this.renderLoop.bind(this));
            } else {
                this.render_loop_stop = false;
                this.render_loop_active = false;
            }
        }

        // Setup the render loop
    }, {
        key: 'setupRenderLoop',
        value: function setupRenderLoop() {
            var _this7 = this;

            if (!this.render_loop_active) {
                setTimeout(function () {
                    _this7.renderLoop();
                }, 0); // delay start by one tick
            }
        }
    }, {
        key: 'update',
        value: function update() {
            this.tile_manager.loadQueuedCoordinates();

            // Render on demand
            var will_render = !(this.dirty === false || this.initialized === false || this.updating > 0 || this.viewReady() === false);

            // Pre-render loop hook
            if (typeof this.preUpdate === 'function') {
                this.preUpdate(will_render);
            }

            // Bail if no need to render
            if (!will_render) {
                return false;
            }
            this.dirty = false; // subclasses can set this back to true when animation is needed

            // Render the scene
            this.updateDevicePixelRatio();
            this.render();

            // Post-render loop hook
            if (typeof this.postUpdate === 'function') {
                this.postUpdate(will_render);
            }

            // Redraw every frame if animating
            if (this.animated === true) {
                this.dirty = true;
            }

            this.frame++;
            _loglevel2['default'].trace('Scene.render()');
            return true;
        }
    }, {
        key: 'render',
        value: function render() {
            var _this8 = this;

            var gl = this.gl;

            // Map transforms
            if (!this.center_meters) {
                return;
            }

            // Update styles, camera, lights
            this.camera.update();
            _Object$keys(this.active_styles).forEach(function (i) {
                return _this8.styles[i].update();
            });
            _Object$keys(this.lights).forEach(function (i) {
                return _this8.lights[i].update();
            });

            // Renderable tile list
            this.renderable_tiles = this.tile_manager.getRenderableTiles();
            this.renderable_tiles_count = this.renderable_tiles.length;

            // Render main pass
            this.render_count = this.renderPass();

            // Render selection pass (if needed)
            if (this.selection.pendingRequests()) {
                if (this.panning) {
                    this.selection.clearPendingRequests();
                    return;
                }

                this.selection.bind(); // switch to FBO
                this.renderPass('selection_program', // render w/alternate program
                { allow_blend: false });
                this.selection.read(); // read results from selection buffer

                // Reset to screen buffer
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            if (this.render_count !== this.last_render_count) {
                this.getFeatureSelectionMapSize().then(function (size) {
                    _loglevel2['default'].info('Scene: rendered ' + _this8.render_count + ' primitives (' + size + ' features in selection map)');
                }, function () {}); // no op when promise rejects (only print last response)
            }
            this.last_render_count = this.render_count;

            return true;
        }

        // Render all active styles, grouped by blend/depth type (opaque, overlay, etc.) and by program (style)
        // Called both for main render pass, and for secondary passes like selection buffer
    }, {
        key: 'renderPass',
        value: function renderPass() {
            var _this9 = this;

            var program_key = arguments.length <= 0 || arguments[0] === undefined ? 'program' : arguments[0];

            var _ref3 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            var allow_blend = _ref3.allow_blend;

            // optionally force alpha off (e.g. for selection pass)
            allow_blend = allow_blend == null ? true : allow_blend;

            this.clearFrame({ clear_color: true, clear_depth: true });

            // Sort styles by blend order
            var styles = _Object$keys(this.active_styles).map(function (s) {
                return _this9.styles[s];
            }).sort(_stylesStyle.Style.blendOrderSort);

            // Render styles
            var count = 0; // how many primitives were rendered
            var last_blend = undefined;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = _getIterator(styles), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var style = _step.value;

                    // Only update render state when blend mode changes
                    if (style.blend !== last_blend) {
                        var state = _Object$assign({}, _stylesStyle.Style.render_states[style.blend], // render state for blend mode
                        { blend: allow_blend && style.blend } // enable/disable blending (e.g. no blend for selection)
                        );
                        this.setRenderState(state);
                    }
                    count += this.renderStyle(style.name, program_key);
                    last_blend = style.blend;
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator['return']) {
                        _iterator['return']();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return count;
        }
    }, {
        key: 'renderStyle',
        value: function renderStyle(style, program_key) {
            var first_for_style = true;
            var render_count = 0;

            var program = this.styles[style][program_key];
            if (!program || !program.compiled) {
                return 0;
            }

            // Render tile GL geometries
            for (var t in this.renderable_tiles) {
                var tile = this.renderable_tiles[t];

                if (tile.meshes[style] == null) {
                    continue;
                }

                // Style-specific state
                // Only setup style if rendering for first time this frame
                // (lazy init, not all styles will be used in all screen views; some styles might be defined but never used)
                if (first_for_style === true) {
                    first_for_style = false;

                    program.use();
                    this.styles[style].setup();

                    // TODO: don't set uniforms when they haven't changed
                    program.uniform('2f', 'u_resolution', this.device_size.width, this.device_size.height);
                    program.uniform('1f', 'u_time', (+new Date() - this.start_time) / 1000);
                    program.uniform('3f', 'u_map_position', this.center_meters.x, this.center_meters.y, this.zoom);
                    program.uniform('1f', 'u_meters_per_pixel', this.meters_per_pixel);
                    program.uniform('1f', 'u_device_pixel_ratio', _utilsUtils2['default'].device_pixel_ratio);

                    this.camera.setupProgram(program);
                    for (var i in this.lights) {
                        this.lights[i].setupProgram(program);
                    }
                }

                // Tile-specific state
                // TODO: calc these once per tile (currently being needlessly re-calculated per-tile-per-style)

                // Tile origin
                program.uniform('3f', 'u_tile_origin', tile.min.x, tile.min.y, tile.style_zoom);

                // Model matrix - transform tile space into world space (meters, absolute mercator position)
                mat4.identity(this.modelMatrix);
                mat4.translate(this.modelMatrix, this.modelMatrix, vec3.fromValues(tile.min.x, tile.min.y, 0));
                mat4.scale(this.modelMatrix, this.modelMatrix, vec3.fromValues(tile.span.x / _geo2['default'].tile_scale, -1 * tile.span.y / _geo2['default'].tile_scale, 1)); // scale tile local coords to meters
                mat4.copy(this.modelMatrix32, this.modelMatrix);
                program.uniform('Matrix4fv', 'u_model', false, this.modelMatrix32);

                // Model view matrix - transform tile space into view space (meters, relative to camera)
                mat4.multiply(this.modelViewMatrix32, this.camera.viewMatrix, this.modelMatrix);
                program.uniform('Matrix4fv', 'u_modelView', false, this.modelViewMatrix32);

                // Normal matrices - transforms surface normals into view space
                mat3.normalFromMat4(this.normalMatrix32, this.modelViewMatrix32);
                mat3.invert(this.inverseNormalMatrix32, this.normalMatrix32);
                program.uniform('Matrix3fv', 'u_normalMatrix', false, this.normalMatrix32);
                program.uniform('Matrix3fv', 'u_inverseNormalMatrix', false, this.inverseNormalMatrix32);

                // Render tile
                tile.meshes[style].render();
                render_count += tile.meshes[style].geometry_count;
            }

            return render_count;
        }
    }, {
        key: 'clearFrame',
        value: function clearFrame() {
            var _ref4 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            var clear_color = _ref4.clear_color;
            var clear_depth = _ref4.clear_depth;

            if (!this.initialized) {
                return;
            }

            // Defaults
            clear_color = clear_color === false ? false : true; // default true
            clear_depth = clear_depth === false ? false : true; // default true

            // Reset frame state
            var gl = this.gl;

            if (clear_color) {
                gl.clearColor.apply(gl, _toConsumableArray(this.background.color));
            }

            if (clear_depth) {
                gl.depthMask(true); // always clear depth if requested, even if depth write will be turned off
            }

            if (clear_color || clear_depth) {
                var mask = (clear_color && gl.COLOR_BUFFER_BIT) | (clear_depth && gl.DEPTH_BUFFER_BIT);
                gl.clear(mask);
            }
        }
    }, {
        key: 'setRenderState',
        value: function setRenderState() {
            var _ref5 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            var depth_test = _ref5.depth_test;
            var depth_write = _ref5.depth_write;
            var cull_face = _ref5.cull_face;
            var blend = _ref5.blend;

            if (!this.initialized) {
                return;
            }

            // Defaults
            // TODO: when we abstract out support for multiple render passes, these can be per-pass config options
            depth_test = depth_test === false ? false : true; // default true
            depth_write = depth_write === false ? false : true; // default true
            cull_face = cull_face === false ? false : true; // default true
            blend = blend != null ? blend : false; // default false

            // Reset frame state
            var gl = this.gl;

            _glRender_state2['default'].depth_test.set({ depth_test: depth_test, depth_func: gl.LEQUAL });
            _glRender_state2['default'].depth_write.set({ depth_write: depth_write });
            _glRender_state2['default'].culling.set({ cull: cull_face, face: gl.BACK });

            // Blending of alpha channel is modified to account for WebGL alpha behavior, see:
            // http://webglfundamentals.org/webgl/lessons/webgl-and-alpha.html
            // http://stackoverflow.com/a/11533416
            if (blend) {
                // Opaque: all source, no destination
                if (blend === 'opaque') {
                    _glRender_state2['default'].blending.set({
                        blend: true,
                        src: gl.SRC_ALPHA, dst: gl.ZERO
                    });
                }
                // Traditional alpha blending
                else if (blend === 'overlay' || blend === 'inlay') {
                        _glRender_state2['default'].blending.set({
                            blend: true,
                            src: gl.SRC_ALPHA, dst: gl.ONE_MINUS_SRC_ALPHA,
                            src_alpha: gl.ONE, dst_alpha: gl.ONE_MINUS_SRC_ALPHA
                        });
                    }
                    // Additive blending
                    else if (blend === 'add') {
                            _glRender_state2['default'].blending.set({
                                blend: true,
                                src: gl.ONE, dst: gl.ONE,
                                src_alpha: gl.ONE, dst_alpha: gl.ONE_MINUS_SRC_ALPHA
                            });
                        }
                        // Multiplicative blending
                        else if (blend === 'multiply') {
                                _glRender_state2['default'].blending.set({
                                    blend: true,
                                    src: gl.ZERO, dst: gl.SRC_COLOR,
                                    src_alpha: gl.ONE, dst_alpha: gl.ONE_MINUS_SRC_ALPHA
                                });
                            }
            } else {
                _glRender_state2['default'].blending.set({ blend: false });
            }
        }

        // Request feature selection at given pixel. Runs async and returns results via a promise.
    }, {
        key: 'getFeatureAt',
        value: function getFeatureAt(pixel) {
            if (!this.initialized) {
                _loglevel2['default'].debug("Scene.getFeatureAt() called before scene was initialized");
                return _Promise.resolve();
            }

            // Point scaled to [0..1] range
            var point = {
                x: pixel.x * _utilsUtils2['default'].device_pixel_ratio / this.device_size.width,
                y: pixel.y * _utilsUtils2['default'].device_pixel_ratio / this.device_size.height
            };

            this.dirty = true; // need to make sure the scene re-renders for these to be processed
            return this.selection.getFeatureAt(point)['catch'](function (r) {
                return _Promise.resolve(r);
            });
        }

        // Rebuild geometry, without re-parsing the config or re-compiling styles
        // TODO: detect which elements need to be refreshed/rebuilt (stylesheet changes, etc.)
    }, {
        key: 'rebuild',
        value: function rebuild() {
            return this.rebuildGeometry();
        }

        // Rebuild all tiles
    }, {
        key: 'rebuildGeometry',
        value: function rebuildGeometry() {
            var _this10 = this;

            return new _Promise(function (resolve, reject) {
                // Skip rebuild if already in progress
                if (_this10.building) {
                    // Queue up to one rebuild call at a time, only save last request
                    if (_this10.building.queued && _this10.building.queued.reject) {
                        // notify previous request that it did not complete
                        _loglevel2['default'].debug('Scene.rebuildGeometry: request superceded by a newer call');
                        _this10.building.queued.resolve(false); // false flag indicates rebuild request was superceded
                    }

                    // Save queued request
                    _this10.building.queued = { resolve: resolve, reject: reject };
                    _loglevel2['default'].trace('Scene.rebuildGeometry(): queuing request');
                    return;
                }

                // Track tile build state
                _this10.building = { resolve: resolve, reject: reject };

                // Profiling
                if (_this10.debug.profile.geometry_build) {
                    _this10._profile('rebuildGeometry');
                }

                // Update config (in case JS objects were manipulated directly)
                _this10.syncConfigToWorker();
                _stylesStyle_manager.StyleManager.compile(_this10.updateActiveStyles(), _this10); // only recompile newly active styles
                _this10.resetFeatureSelection();
                _this10.resetTime();

                // Rebuild visible tiles, sorted from center
                var build = [];
                _this10.tile_manager.forEachTile(function (tile) {
                    if (tile.visible) {
                        build.push(tile);
                    } else {
                        _this10.tile_manager.removeTile(tile.key);
                    }
                });
                _this10.tile_manager.buildTiles(build);
            }).then(function () {
                // Profiling
                if (_this10.debug.profile.geometry_build) {
                    _this10._profileEnd('rebuildGeometry');
                }
            });
        }

        // Tile manager finished building tiles
    }, {
        key: 'tileManagerBuildDone',
        value: function tileManagerBuildDone() {
            if (this.building) {
                _loglevel2['default'].info('Scene: build geometry finished');
                if (this.building.resolve) {
                    this.building.resolve(true);
                }

                // Another rebuild queued?
                var queued = this.building.queued;
                this.building = null;
                if (queued) {
                    _loglevel2['default'].debug('Scene: starting queued rebuildGeometry() request');
                    this.rebuildGeometry().then(queued.resolve, queued.reject);
                }
            }
        }

        /**
           Load (or reload) the scene config
           @return {Promise}
        */
    }, {
        key: 'loadScene',
        value: function loadScene() {
            var _this11 = this;

            var config_source = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
            var config_path = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

            this.config_source = config_source || this.config_source;

            if (typeof this.config_source === 'string') {
                this.config_path = _utilsUtils2['default'].pathForURL(config_path || this.config_source);
            } else {
                this.config_path = _utilsUtils2['default'].pathForURL(config_path);
            }

            return _scene_loader2['default'].loadScene(this.config_source, this.config_path).then(function (config) {
                _this11.config = config;
                _this11.trigger('load', { config: _this11.config });
                return _this11.config;
            });
        }
    }, {
        key: 'loadDataSources',
        value: function loadDataSources() {
            for (var name in this.config.sources) {
                var source = this.config.sources[name];
                this.sources[name] = _sourcesData_source2['default'].create(_Object$assign({}, source, { name: name }));

                if (!this.sources[name]) {
                    delete this.sources[name];
                    _loglevel2['default'].warn('Scene: could not create data source', source);
                    this.trigger('warning', { type: 'sources', source: source, message: 'Could not create data source' });
                }
            }
        }

        // Load all textures in the scene definition
    }, {
        key: 'loadTextures',
        value: function loadTextures() {
            return _glTexture2['default'].createFromObject(this.gl, this.config.textures);
        }

        // Called (currently manually) after styles are updated in stylesheet
    }, {
        key: 'updateStyles',
        value: function updateStyles() {
            if (!this.initialized && !this.initializing) {
                throw new Error('Scene.updateStyles() called before scene was initialized');
            }

            // (Re)build styles from config
            this.styles = _stylesStyle_manager.StyleManager.build(this.config.styles, this);

            // Optionally set GL context (used when initializing or re-initializing GL resources)
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = _getIterator(_utilsUtils2['default'].values(this.styles)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var style = _step2.value;

                    style.setGL(this.gl);
                }

                // Find & compile active styles
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                        _iterator2['return']();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            this.updateActiveStyles();
            _stylesStyle_manager.StyleManager.compile(_Object$keys(this.active_styles), this);

            this.dirty = true;
        }
    }, {
        key: 'updateActiveStyles',
        value: function updateActiveStyles() {
            var _this12 = this;

            // Make a set of currently active styles (used in a draw rule)
            // Note: doesn't actually check if any geometry matches the rule, just that the style is potentially renderable
            var prev_styles = _Object$keys(this.active_styles || {});
            this.active_styles = {};
            var animated = false; // is any active style animated?
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = _getIterator(_utilsUtils2['default'].recurseValues(this.config.layers)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var rule = _step3.value;

                    if (rule && rule.draw) {
                        var _iteratorNormalCompletion4 = true;
                        var _didIteratorError4 = false;
                        var _iteratorError4 = undefined;

                        try {
                            for (var _iterator4 = _getIterator(_utilsUtils2['default'].entries(rule.draw)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                                var _step4$value = _slicedToArray(_step4.value, 2);

                                var _name = _step4$value[0];
                                var group = _step4$value[1];

                                // TODO: warn on non-object draw group
                                if (group != null && typeof group === 'object' && group.visible !== false) {
                                    var style_name = group.style || _name;
                                    var styles = [style_name];

                                    // optional additional outline style
                                    if (group.outline && group.outline.style) {
                                        styles.push(group.outline.style);
                                    }

                                    styles = styles.filter(function (x) {
                                        return _this12.styles[x];
                                    }).forEach(function (style_name) {
                                        var style = _this12.styles[style_name];
                                        if (style) {
                                            _this12.active_styles[style_name] = true;
                                            if (style.animated) {
                                                animated = true;
                                            }
                                        }
                                    });
                                }
                            }
                        } catch (err) {
                            _didIteratorError4 = true;
                            _iteratorError4 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                                    _iterator4['return']();
                                }
                            } finally {
                                if (_didIteratorError4) {
                                    throw _iteratorError4;
                                }
                            }
                        }
                    }
                }

                // Use explicitly set scene animation flag if defined, otherwise turn on animation
                // if there are any animated styles
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                        _iterator3['return']();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            this.animated = this.config.scene.animated !== undefined ? this.config.scene.animated : animated;

            // Compile newly active styles
            return _Object$keys(this.active_styles).filter(function (s) {
                return prev_styles.indexOf(s) === -1;
            });
        }

        // Create camera
    }, {
        key: 'createCamera',
        value: function createCamera() {
            var active_camera = this._active_camera;
            if (active_camera) {
                this.camera = _camera2['default'].create(active_camera, this, this.config.cameras[this._active_camera]);

                // TODO: replace this and move all position info to camera
                this.camera.updateScene();
            }
        }

        // Get active camera - for public API
    }, {
        key: 'getActiveCamera',
        value: function getActiveCamera() {
            return this._active_camera;
        }

        // Set active camera and recompile - for public API
    }, {
        key: 'setActiveCamera',
        value: function setActiveCamera(name) {
            this._active_camera = name;
            this.updateConfig();
            return this._active_camera;
        }

        // Internal management of active camera
    }, {
        key: 'createLights',

        // Create lighting
        value: function createLights() {
            this.lights = {};
            for (var i in this.config.lights) {
                if (!this.config.lights[i] || typeof this.config.lights[i] !== 'object') {
                    continue;
                }
                var light = this.config.lights[i];
                light.name = i.replace('-', '_'); // light names are injected in shaders, can't have hyphens
                light.visible = light.visible === false ? false : true;
                if (light.visible) {
                    this.lights[light.name] = _light2['default'].create(this, light);
                }
            }
            _light2['default'].inject(this.lights);
        }

        // Set background color
    }, {
        key: 'setBackground',
        value: function setBackground() {
            var bg = this.config.scene.background;
            this.background = {};
            if (bg && bg.color) {
                this.background.color = _stylesStyle_parser.StyleParser.parseColor(bg.color);
            }
            if (!this.background.color) {
                this.background.color = [0, 0, 0, 0]; // default background TODO: vary w/scene alpha
            }

            // if background is fully opaque, set canvas background to match
            if (this.background.color[3] === 1) {
                this.canvas.style.backgroundColor = 'rgba(' + this.background.color.map(function (c) {
                    return Math.floor(c * 255);
                }).join(', ') + ')';
            } else {
                this.canvas.style.backgroundColor = 'transparent';
            }
        }

        // Update scene config, and optionally rebuild geometry
    }, {
        key: 'updateConfig',
        value: function updateConfig() {
            var _this13 = this;

            var _ref6 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            var rebuild = _ref6.rebuild;

            this.generation++;
            this.updating++;
            this.config.scene = this.config.scene || {};

            _stylesStyle_manager.StyleManager.init();
            this.createCamera();
            this.createLights();
            this.loadDataSources();
            this.loadTextures();
            this.setBackground();
            this.updateBounds();

            // TODO: detect changes to styles? already (currently) need to recompile anyway when camera or lights change
            this.updateStyles();
            this.syncConfigToWorker();
            if (rebuild) {
                return this.rebuildGeometry().then(function () {
                    _this13.updating--;_this13.requestRedraw();
                });
            } else {
                this.updating--;
                this.requestRedraw();
                return _Promise.resolve();
            }
        }

        // Serialize config and send to worker
    }, {
        key: 'syncConfigToWorker',
        value: function syncConfigToWorker() {
            // Tell workers we're about to rebuild (so they can update styles, etc.)
            this.config_serialized = _utilsUtils2['default'].serializeWithFunctions(this.config);
            _utilsWorker_broker2['default'].postMessage(this.workers, 'self.updateConfig', {
                config: this.config_serialized,
                generation: this.generation
            });
        }
    }, {
        key: 'resetFeatureSelection',
        value: function resetFeatureSelection() {
            if (!this.selection) {
                this.selection = new _selection2['default'](this.gl, this.workers);
            } else if (this.workers) {
                _utilsWorker_broker2['default'].postMessage(this.workers, 'self.resetFeatureSelection');
            }
        }

        // Gets the current feature selection map size across all workers. Returns a promise.
    }, {
        key: 'getFeatureSelectionMapSize',
        value: function getFeatureSelectionMapSize() {
            var _this14 = this;

            if (this.fetching_selection_map) {
                return _Promise.reject();
            }
            this.fetching_selection_map = true;

            return _utilsWorker_broker2['default'].postMessage(this.workers, 'self.getFeatureSelectionMapSize').then(function (sizes) {
                _this14.fetching_selection_map = false;
                return sizes.reduce(function (a, b) {
                    return a + b;
                });
            });
        }

        // Reset internal clock, mostly useful for consistent experience when changing styles/debugging
    }, {
        key: 'resetTime',
        value: function resetTime() {
            this.start_time = +new Date();
        }

        // Stats/debug/profiling methods

        // Log messages pass through from web workers
    }, {
        key: 'workerLogMessage',
        value: function workerLogMessage(event) {
            if (event.data.type !== 'log') {
                return;
            }

            var _event$data = event.data;
            var worker_id = _event$data.worker_id;
            var level = _event$data.level;
            var msg = _event$data.msg;

            if (_loglevel2['default'][level]) {
                _loglevel2['default'][level].apply(_loglevel2['default'], ['worker ' + worker_id + ':'].concat(_toConsumableArray(msg)));
            } else {
                _loglevel2['default'].error('Scene.workerLogMessage: unrecognized log level ' + level);
            }
        }

        // Profile helpers, issues a profile on main thread & all workers
    }, {
        key: '_profile',
        value: function _profile(name) {
            console.profile('main thread: ' + name);
            _utilsWorker_broker2['default'].postMessage(this.workers, 'self.profile', name);
        }
    }, {
        key: '_profileEnd',
        value: function _profileEnd(name) {
            console.profileEnd('main thread: ' + name);
            _utilsWorker_broker2['default'].postMessage(this.workers, 'self.profileEnd', name);
        }

        // Rebuild geometry a given # of times and print average, min, max timings
    }, {
        key: '_timeRebuild',
        value: function _timeRebuild() {
            var _this15 = this;

            var num = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

            var times = [];
            var cycle = function cycle() {
                var start = +new Date();
                _this15.rebuild().then(function () {
                    times.push(+new Date() - start);

                    if (times.length < num) {
                        cycle();
                    } else {
                        var avg = ~ ~(times.reduce(function (a, b) {
                            return a + b;
                        }) / times.length);
                        _loglevel2['default'].info('Profiled rebuild ' + num + ' times: ' + avg + ' avg (' + Math.min.apply(Math, times) + ' min, ' + Math.max.apply(Math, times) + ' max)');
                    }
                });
            };
            cycle();
        }
    }, {
        key: '_active_camera',
        get: function get() {
            if (this.config && this.config.cameras) {
                for (var name in this.config.cameras) {
                    if (this.config.cameras[name].active) {
                        return name;
                    }
                }
            }
        },
        set: function set(name) {
            var prev = this._active_camera;

            // Set new active camera
            if (this.config.cameras[name]) {
                this.config.cameras[name].active = true;

                // Clear previously active camera
                if (prev && prev !== name && this.config.cameras[prev]) {
                    delete this.config.cameras[prev].active;
                }
            }
        }
    }]);

    return Scene;
})();

exports['default'] = Scene;
Scene.create = function (config) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    return new Scene(config, options);
};
module.exports = exports['default'];

},{"./camera":191,"./geo":192,"./gl/context":194,"./gl/render_state":197,"./gl/texture":200,"./gl/vao":201,"./light":206,"./scene_loader":210,"./selection":212,"./sources/data_source":213,"./styles/lines/lines":218,"./styles/points/points":220,"./styles/polygons/polygons":221,"./styles/style":223,"./styles/style_manager":224,"./styles/style_parser":225,"./styles/text/text":233,"./tile_manager":236,"./utils/subscribe":240,"./utils/utils":241,"./utils/worker_broker":243,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/keys":11,"babel-runtime/core-js/promise":13,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/interop-require-default":22,"babel-runtime/helpers/sliced-to-array":23,"babel-runtime/helpers/to-consumable-array":24,"gl-matrix":146,"loglevel":179}],210:[function(_dereq_,module,exports){
'use strict';

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsUtils = _dereq_('./utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _glGlsl = _dereq_('./gl/glsl');

var _glGlsl2 = _interopRequireDefault(_glGlsl);

// import mergeObjects from './utils/merge';

var _stylesStyle_manager = _dereq_('./styles/style_manager');

var SceneLoader;

exports['default'] = SceneLoader = {

    // Load scenes definitions from URL & proprocess
    loadScene: function loadScene(url) {
        var path = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

        return SceneLoader.loadSceneRecursive(url, path).then(SceneLoader.finalize);
    },

    // Loads scene files from URL, recursively loading 'included' scenes
    // Optional *initial* path only (won't be passed to recursive 'include' calls)
    // Useful for loading resources in base scene file from a separate location
    // (e.g. in Tangram Play, when modified local scene should still refer to original resource URLs)
    loadSceneRecursive: function loadSceneRecursive(url) {
        var path = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

        if (!url) {
            return _Promise.resolve({});
        }

        if (typeof url === 'string') {
            path = path || _utilsUtils2['default'].pathForURL(url);
        }

        return _utilsUtils2['default'].loadResource(url).then(function (config) {
            return _stylesStyle_manager.StyleManager.loadRemoteStyles(config.styles, path).then(function (styles) {
                return _stylesStyle_manager.StyleManager.loadShaderBlocks(styles, path);
            }). // TODO: deprecate remote shader blocks?
            then(function () {
                // accept single-string or array
                // if (typeof config.include === 'string') {
                //     config.include = [config.include];
                // }

                // if (!Array.isArray(config.include)) {
                SceneLoader.normalize(config, path);
                return config;
                // }

                // Collect URLs of scenes to include
                // let includes = [];
                // for (let url of config.include) {
                //     includes.push(Utils.addBaseURL(url, path));
                // }
                // delete config.include; // don't want to merge this property

                // return Promise.
                //     all(includes.map(url => SceneLoader.loadSceneRecursive(url))).
                //     then(configs => {
                //         config = mergeObjects({}, ...configs, config);
                //         SceneLoader.normalize(config, path);
                //         return config;
                //     });
            });
        });
    },

    // Normalize properties that should be adjust within each local scene file (usually by path)
    normalize: function normalize(config, path) {
        SceneLoader.normalizeDataSources(config, path);
        SceneLoader.normalizeTextures(config, path);
        return config;
    },

    // Expand paths for data source
    normalizeDataSources: function normalizeDataSources(config, path) {
        config.sources = config.sources || {};

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = _getIterator(_utilsUtils2['default'].values(config.sources)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var source = _step.value;

                source.url = _utilsUtils2['default'].addBaseURL(source.url, path);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                    _iterator['return']();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        return config;
    },

    // Expand paths and centralize texture definitions for a scene object
    normalizeTextures: function normalizeTextures(config, path) {
        config.textures = config.textures || {};

        if (config.styles) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = _getIterator(_utilsUtils2['default'].entries(config.styles)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var _step2$value = _slicedToArray(_step2.value, 2);

                    var style_name = _step2$value[0];
                    var style = _step2$value[1];

                    if (style.texture) {
                        var tex = style.texture;

                        // Texture by URL, expand relative to scene file
                        if (typeof tex === 'string' && !config.textures[tex]) {
                            style.texture = _utilsUtils2['default'].addBaseURL(tex, path);
                        }
                        // Texture by object, move it to the global scene texture set and give it a default name
                        else if (typeof tex === 'object') {
                                var texture_name = '__' + style_name;
                                config.textures[texture_name] = tex;
                                style.texture = texture_name; // point style to location of texture
                            }
                    }

                    // If style has texture uniforms, expand texture URLs relative to scene file
                    if (style.shaders && style.shaders.uniforms) {
                        var _iteratorNormalCompletion3 = true;
                        var _didIteratorError3 = false;
                        var _iteratorError3 = undefined;

                        try {
                            for (var _iterator3 = _getIterator(_glGlsl2['default'].parseUniforms(style.shaders.uniforms)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                var _step3$value = _step3.value;
                                var type = _step3$value.type;
                                var value = _step3$value.value;
                                var key = _step3$value.key;
                                var uniforms = _step3$value.uniforms;

                                if (type === 'sampler2D' && !config.textures[value]) {
                                    uniforms[key] = _utilsUtils2['default'].addBaseURL(value, path);
                                }
                            }
                        } catch (err) {
                            _didIteratorError3 = true;
                            _iteratorError3 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                                    _iterator3['return']();
                                }
                            } finally {
                                if (_didIteratorError3) {
                                    throw _iteratorError3;
                                }
                            }
                        }
                    }

                    // If style has material, expand texture URLs relative to scene file
                    if (style.material) {
                        var _arr = ['emission', 'ambient', 'diffuse', 'specular', 'normal'];

                        for (var _i = 0; _i < _arr.length; _i++) {
                            var prop = _arr[_i];
                            // Material property has a texture
                            if (style.material[prop] != null && style.material[prop].texture) {
                                var tex = style.material[prop].texture;

                                // Texture by URL, expand relative to scene file
                                if (typeof tex === 'string' && !config.textures[tex]) {
                                    style.material[prop].texture = _utilsUtils2['default'].addBaseURL(tex, path);
                                }
                                // Texture by object, move it to the global scene texture set and give it a default name
                                else if (typeof tex === 'object') {
                                        var texture_name = '__' + style_name;
                                        config.textures[texture_name] = tex;
                                        style.material[prop].texture = texture_name; // point style to location of texture
                                    }
                            }
                        }
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                        _iterator2['return']();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
        }

        // Add path to textures
        if (config.textures) {
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
                for (var _iterator4 = _getIterator(_utilsUtils2['default'].values(config.textures)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var texture = _step4.value;

                    texture.url = _utilsUtils2['default'].addBaseURL(texture.url, path);
                }
            } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                        _iterator4['return']();
                    }
                } finally {
                    if (_didIteratorError4) {
                        throw _iteratorError4;
                    }
                }
            }
        }

        return config;
    },

    // Normalize some scene-wide settings that apply to the final, merged scene
    finalize: function finalize(config) {
        // Assign ids to data sources
        var source_id = 0;
        for (var source in config.sources) {
            config.sources[source].id = source_id++;
        }

        // If only one camera specified, set it as default
        config.cameras = config.cameras || {};
        if (config.camera) {
            config.cameras['default'] = config.camera;
        }

        // If no cameras specified, create one
        if (_Object$keys(config.cameras).length === 0) {
            config.cameras['default'] = {};
        }

        // If no camera set as active, use first one
        var active = false;
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
            for (var _iterator5 = _getIterator(_utilsUtils2['default'].values(config.cameras)), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var camera = _step5.value;

                if (camera.active) {
                    active = true;
                    break;
                }
            }
        } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion5 && _iterator5['return']) {
                    _iterator5['return']();
                }
            } finally {
                if (_didIteratorError5) {
                    throw _iteratorError5;
                }
            }
        }

        if (!active) {
            config.cameras[_Object$keys(config.cameras)[0]].active = true;
        }

        // Ensure top-level properties
        config.lights = config.lights || {};
        config.styles = config.styles || {};

        return config;
    }

};
module.exports = exports['default'];

},{"./gl/glsl":196,"./styles/style_manager":224,"./utils/utils":241,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/keys":11,"babel-runtime/core-js/promise":13,"babel-runtime/helpers/interop-require-default":22,"babel-runtime/helpers/sliced-to-array":23}],211:[function(_dereq_,module,exports){
/*jshint worker: true*/
'use strict';

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsUtils = _dereq_('./utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _utilsWorker_broker = _dereq_('./utils/worker_broker');

var _utilsWorker_broker2 = _interopRequireDefault(_utilsWorker_broker);

// jshint ignore:line

var _utilsMerge = _dereq_('./utils/merge');

var _utilsMerge2 = _interopRequireDefault(_utilsMerge);

var _tile = _dereq_('./tile');

var _tile2 = _interopRequireDefault(_tile);

var _sourcesData_source = _dereq_('./sources/data_source');

var _sourcesData_source2 = _interopRequireDefault(_sourcesData_source);

var _selection = _dereq_('./selection');

var _selection2 = _interopRequireDefault(_selection);

var _stylesStyle_parser = _dereq_('./styles/style_parser');

var _stylesStyle_manager = _dereq_('./styles/style_manager');

var _stylesRule = _dereq_('./styles/rule');

var _glTexture = _dereq_('./gl/texture');

var _glTexture2 = _interopRequireDefault(_glTexture);

var SceneWorker = self;

exports.SceneWorker = SceneWorker;
// Worker functionality will only be defined in worker thread
if (_utilsUtils2['default'].isWorkerThread) {

    _Object$assign(self, {

        FeatureSelection: _selection2['default'],

        sources: {
            tiles: {},
            objects: {}
        },
        styles: {},
        rules: {},
        layers: {},
        tiles: {},
        objects: {},
        config: {}, // raw config (e.g. functions, macros, etc. not expanded)

        // Initialize worker
        init: function init(worker_id, num_workers, device_pixel_ratio) {
            self._worker_id = worker_id;
            self.num_workers = num_workers;
            _utilsUtils2['default'].device_pixel_ratio = device_pixel_ratio;
            _selection2['default'].setPrefix(self._worker_id);
            return worker_id;
        },

        // Starts a config refresh
        updateConfig: function updateConfig(_ref) {
            var config = _ref.config;
            var generation = _ref.generation;

            config = JSON.parse(config);

            self.last_config = (0, _utilsMerge2['default'])({}, self.config);
            self.config = (0, _utilsMerge2['default'])({}, config);
            self.generation = generation;

            // Data block functions are not macro'ed and wrapped like the rest of the style functions are
            // TODO: probably want a cleaner way to exclude these
            for (var layer in config.layers) {
                if (config.layers[layer]) {
                    config.layers[layer].data = _utilsUtils2['default'].stringsToFunctions(config.layers[layer].data);
                }
            }

            // Create data sources
            config.sources = _utilsUtils2['default'].stringsToFunctions(_stylesStyle_parser.StyleParser.expandMacros(config.sources)); // parse new sources
            self.sources.tiles = {}; // clear previous sources
            for (var _name in config.sources) {
                var source = _sourcesData_source2['default'].create(_Object$assign({}, config.sources[_name], { name: _name }));
                if (!source) {
                    continue;
                }

                if (source.tiled) {
                    self.sources.tiles[_name] = source;
                } else {
                    // Distribute object sources across workers
                    if (source.id % self.num_workers === self._worker_id) {
                        // Load source if not cached
                        self.sources.objects[_name] = source;
                        if (!self.objects[source.name]) {
                            self.objects[source.name] = {};
                            source.load(self.objects[source.name]);
                        }
                    }
                }
            }

            // Clear tile cache if data source config changed
            if (!self.config.sources || !self.last_config.sources || _Object$keys(self.config.sources).some(function (s) {
                return JSON.stringify(self.config.sources[s]) !== JSON.stringify(self.last_config.sources[s]);
            })) {
                self.tiles = {};
            }

            // Expand styles
            config = _utilsUtils2['default'].stringsToFunctions(_stylesStyle_parser.StyleParser.expandMacros(config), _stylesStyle_parser.StyleParser.wrapFunction);
            self.styles = _stylesStyle_manager.StyleManager.build(config.styles, { generation: self.generation });

            // Parse each top-level layer as a separate rule tree
            self.layers = config.layers;
            self.rules = (0, _stylesRule.parseRules)(self.layers);

            // Sync tetxure info from main thread
            self.syncing_textures = self.syncTextures(config.textures);

            // Return promise for when config refresh finishes
            self.configuring = self.syncing_textures.then(function () {
                _utilsUtils2['default'].log('debug', 'updated config');
            });
        },

        // Returns a promise that fulfills when config refresh is finished
        awaitConfiguration: function awaitConfiguration() {
            return self.configuring;
        },

        // Build a tile: load from tile source if building for first time, otherwise rebuild with existing data
        buildTile: function buildTile(_ref2) {
            var tile = _ref2.tile;

            // Tile cached?
            if (self.tiles[tile.key] != null) {
                // Already loading?
                if (self.tiles[tile.key].loading === true) {
                    return;
                }
            }

            // Update tile cache
            tile = self.tiles[tile.key] = _Object$assign(self.tiles[tile.key] || {}, tile);

            // Update config (styles, etc.), then build tile
            return self.awaitConfiguration().then(function () {
                // First time building the tile
                if (tile.loaded !== true) {

                    return new _Promise(function (resolve, reject) {

                        tile.loading = true;
                        tile.loaded = false;
                        tile.error = null;

                        self.loadTileSourceData(tile).then(function () {
                            // Warn and continue on data source error
                            if (tile.source_data.error) {
                                _utilsUtils2['default'].log('warn', 'tile load error(s) for ' + tile.key + ': ' + tile.source_data.error);
                            }

                            tile.loading = false;
                            tile.loaded = true;
                            _tile2['default'].buildGeometry(tile, self.layers, self.rules, self.styles).then(function (keys) {
                                resolve({ tile: _tile2['default'].slice(tile, keys) });
                            });
                        })['catch'](function (error) {
                            tile.loading = false;
                            tile.loaded = false;
                            tile.error = error.toString();
                            _utilsUtils2['default'].log('error', 'tile load error for ' + tile.key + ': ' + tile.error + ' at: ' + error.stack);

                            resolve({ tile: _tile2['default'].slice(tile) });
                        });
                    });
                }
                // Tile already loaded, just rebuild
                else {
                        _utilsUtils2['default'].log('trace', 'used worker cache for tile ' + tile.key);

                        // Build geometry
                        return _tile2['default'].buildGeometry(tile, self.layers, self.rules, self.styles).then(function (keys) {
                            return { tile: _tile2['default'].slice(tile, keys) };
                        });
                    }
            });
        },

        // Load this tile's data source
        loadTileSourceData: function loadTileSourceData(tile) {
            return self.sources.tiles[tile.source].load(tile);
        },

        // Remove tile
        removeTile: function removeTile(key) {
            var tile = self.tiles[key];

            if (tile != null) {
                // Cancel if loading
                if (tile.loading === true) {
                    _utilsUtils2['default'].log('trace', 'cancel tile load for ' + key);
                    tile.loading = false;
                }

                _tile2['default'].cancel(tile);

                // Remove from cache
                _selection2['default'].clearTile(key);
                delete self.tiles[key];
                _utilsUtils2['default'].log('trace', 'remove tile from cache for ' + key);
            }
        },

        // Get a feature from the selection map
        getFeatureSelection: function getFeatureSelection() {
            var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            var id = _ref3.id;
            var key = _ref3.key;

            var selection = _selection2['default'].map[key];

            return {
                id: id,
                feature: selection && selection.feature
            };
        },

        // Resets the feature selection state
        resetFeatureSelection: function resetFeatureSelection() {
            _selection2['default'].reset();
        },

        // Selection map size for this worker
        getFeatureSelectionMapSize: function getFeatureSelectionMapSize() {
            return _selection2['default'].getMapSize();
        },

        // Texture info needs to be synced from main thread
        syncTextures: function syncTextures(tex_config) {
            // We're only syncing the textures that have sprites defined, since these are (currently) the only ones we
            // need info about for geometry construction (e.g. width/height, which we only know after the texture loads)
            var textures = [];
            if (tex_config) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = _getIterator(_utilsUtils2['default'].entries(tex_config)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _step$value = _slicedToArray(_step.value, 2);

                        var texname = _step$value[0];
                        var texture = _step$value[1];

                        if (texture.sprites) {
                            textures.push(texname);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator['return']) {
                            _iterator['return']();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }

            _utilsUtils2['default'].log('trace', 'sync textures to worker:', textures);
            if (textures.length > 0) {
                return _glTexture2['default'].syncTexturesToWorker(textures);
            }
            return _Promise.resolve();
        },

        // Sync device pixel ratio from main thread
        updateDevicePixelRatio: function updateDevicePixelRatio(device_pixel_ratio) {
            _utilsUtils2['default'].device_pixel_ratio = device_pixel_ratio;
        },

        // Profiling helpers
        profile: function profile(name) {
            console.profile('worker ' + self._worker_id + ': ' + name);
        },

        profileEnd: function profileEnd(name) {
            console.profileEnd('worker ' + self._worker_id + ': ' + name);
        }

    });

    _utilsWorker_broker2['default'].addTarget('self', self);
}

},{"./gl/texture":200,"./selection":212,"./sources/data_source":213,"./styles/rule":222,"./styles/style_manager":224,"./styles/style_parser":225,"./tile":235,"./utils/merge":238,"./utils/utils":241,"./utils/worker_broker":243,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/keys":11,"babel-runtime/core-js/promise":13,"babel-runtime/helpers/interop-require-default":22,"babel-runtime/helpers/sliced-to-array":23}],212:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _glTexture = _dereq_('./gl/texture');

var _glTexture2 = _interopRequireDefault(_glTexture);

var _utilsWorker_broker = _dereq_('./utils/worker_broker');

var _utilsWorker_broker2 = _interopRequireDefault(_utilsWorker_broker);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var FeatureSelection = (function () {
    function FeatureSelection(gl, workers) {
        _classCallCheck(this, FeatureSelection);

        this.gl = gl;
        this.workers = workers; // pool of workers to request feature look-ups from, keyed by id
        this.init();
    }

    // Static properties

    _createClass(FeatureSelection, [{
        key: 'init',
        value: function init() {
            // Selection state tracking
            this.requests = {}; // pending selection requests
            this.feature = null; // currently selected feature
            this.read_delay = 5; // delay time from selection render to framebuffer sample, to avoid CPU/GPU sync lock
            this.read_delay_timer = null; // current timer (setTimeout) for delayed selection reads

            this.pixel = new Uint8Array(4);
            this.pixel32 = new Float32Array(this.pixel.buffer);

            // Frame buffer for selection
            // TODO: initiate lazily in case we don't need to do any selection
            this.fbo = this.gl.createFramebuffer();
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
            this.fbo_size = { width: 256, height: 256 }; // TODO: make configurable / adaptive based on canvas size
            this.fbo_size.aspect = this.fbo_size.width / this.fbo_size.height;

            // Texture for the FBO color attachment
            var fbo_texture = new _glTexture2['default'](this.gl, 'selection_fbo');
            fbo_texture.setData(this.fbo_size.width, this.fbo_size.height, null, { filtering: 'nearest' });
            this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, fbo_texture.texture, 0);

            // Renderbuffer for the FBO depth attachment
            var fbo_depth_rb = this.gl.createRenderbuffer();
            this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, fbo_depth_rb);
            this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, this.fbo_size.width, this.fbo_size.height);
            this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, fbo_depth_rb);

            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            if (this.gl && this.fbo) {
                this.gl.deleteFramebuffer(this.fbo);
                this.fbo = null;
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
            }

            // TODO: free texture?
        }
    }, {
        key: 'bind',
        value: function bind() {
            // Switch to FBO
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
            this.gl.viewport(0, 0, this.fbo_size.width, this.fbo_size.height);
        }

        // Request feature selection
        // Runs asynchronously, schedules selection buffer to be updated
    }, {
        key: 'getFeatureAt',
        value: function getFeatureAt(point) {
            var _this = this;

            return new _Promise(function (resolve, reject) {
                // Queue requests for feature selection, and they will be picked up by the render loop
                _this.selection_request_id = _this.selection_request_id + 1 || 0;
                _this.requests[_this.selection_request_id] = {
                    type: 'point',
                    id: _this.selection_request_id,
                    point: point,
                    resolve: resolve,
                    reject: reject
                };
            });
        }

        // Any pending selection requests
    }, {
        key: 'pendingRequests',
        value: function pendingRequests() {
            return this.requests;
        }
    }, {
        key: 'clearPendingRequests',
        value: function clearPendingRequests() {
            for (var r in this.requests) {
                var request = this.requests[r];

                // This request was already sent to the worker, we're just awaiting its reply
                if (request.sent) {
                    continue;
                }

                // Reject request since it will never be fulfilled
                // TODO: pass a reason for rejection?
                request.reject({ request: request });
                delete this.requests[r];
            }
        }

        // Read pending results from the selection buffer. Called after rendering to selection buffer.
    }, {
        key: 'read',
        value: function read() {
            var _this2 = this;

            // Delay reading the pixel result from the selection buffer to avoid CPU/GPU sync lock.
            // Calling readPixels synchronously caused a massive performance hit, presumably since it
            // forced this function to wait for the GPU to finish rendering and retrieve the texture contents.
            if (this.read_delay_timer != null) {
                clearTimeout(this.read_delay_timer);
            }
            this.read_delay_timer = setTimeout(function () {
                var gl = _this2.gl;

                gl.bindFramebuffer(gl.FRAMEBUFFER, _this2.fbo);

                for (var r in _this2.requests) {
                    var request = _this2.requests[r];

                    // This request was already sent to the worker, we're just awaiting its reply
                    if (request.sent) {
                        continue;
                    }

                    // TODO: support other selection types, such as features within a box
                    if (request.type !== 'point') {
                        continue;
                    }

                    // Check selection map against FBO
                    gl.readPixels(Math.floor(request.point.x * _this2.fbo_size.width), Math.floor((1 - request.point.y) * _this2.fbo_size.height), 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, _this2.pixel);
                    var feature_key = _this2.pixel[0] + (_this2.pixel[1] << 8) + (_this2.pixel[2] << 16) + (_this2.pixel[3] << 24) >>> 0;

                    // If feature found, ask appropriate web worker to lookup feature
                    var worker_id = _this2.pixel[3];
                    if (worker_id !== 255) {
                        // 255 indicates an empty selection buffer pixel
                        if (_this2.workers[worker_id] != null) {
                            _utilsWorker_broker2['default'].postMessage(_this2.workers[worker_id], 'self.getFeatureSelection', { id: request.id, key: feature_key }).then(function (message) {
                                _this2.finishRead(message);
                            });
                        }
                    }
                    // No feature found, but still need to resolve promise
                    else {
                            _this2.finishRead({ id: request.id, feature: null });
                        }

                    request.sent = true;
                }

                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }, this.read_delay);
        }

        // Called on main thread when a web worker finds a feature in the selection buffer
    }, {
        key: 'finishRead',
        value: function finishRead(message) {
            var request = this.requests[message.id];
            if (!request) {
                _loglevel2['default'].error("FeatureSelection.finishRead(): could not find message", message);
                return; // request was cleared before it returned
            }

            var feature = message.feature;
            var changed = false;
            if (feature != null && this.feature == null || feature == null && this.feature != null || feature != null && this.feature != null && JSON.stringify(feature) !== JSON.stringify(this.feature)) {
                changed = true;
            }

            this.feature = feature; // store the most recently selected feature

            // Resolve the request
            request.resolve({ feature: feature, changed: changed, request: request });
            delete this.requests[message.id]; // done processing this request
        }

        // Selection map generation
        // Each worker will create its own independent, 'local' selection map

        // Create a unique 32-bit color to identify a feature
        // Workers independently create/modify selection colors in their own threads, but we also
        // need the main thread to know where each feature color originated. To accomplish this,
        // we partition the map by setting the 4th component (alpha channel) to the worker's id.
    }], [{
        key: 'makeEntry',
        value: function makeEntry(tile) {
            // 32-bit color key
            this.map_entry++;
            var ir = this.map_entry & 255;
            var ig = this.map_entry >> 8 & 255;
            var ib = this.map_entry >> 16 & 255;
            var ia = this.map_prefix;
            var r = ir / 255;
            var g = ig / 255;
            var b = ib / 255;
            var a = ia / 255;
            var key = ir + (ig << 8) + (ib << 16) + (ia << 24) >>> 0; // need unsigned right shift to convert to positive #

            this.map[key] = {
                color: [r, g, b, a]
            };
            this.map_size++;

            this.tiles[tile.key] = this.tiles[tile.key] || [];
            this.tiles[tile.key].push(key);

            return this.map[key];
        }
    }, {
        key: 'makeColor',
        value: function makeColor(feature, tile) {
            var selector = this.makeEntry(tile);
            selector.feature = {
                id: feature.id,
                properties: feature.properties,
                tile: tile.key
            };

            return selector.color;
        }
    }, {
        key: 'reset',
        value: function reset() {
            this.tiles = {};
            this.map = {};
            this.map_size = 0;
            this.map_entry = 0;
        }
    }, {
        key: 'clearTile',
        value: function clearTile(key) {
            var _this3 = this;

            if (Array.isArray(this.tiles[key])) {
                this.tiles[key].forEach(function (k) {
                    return delete _this3.map[k];
                });
                this.map_size -= this.tiles[key].length;
                delete this.tiles[key];
            }
        }
    }, {
        key: 'getMapSize',
        value: function getMapSize() {
            return this.map_size;
        }
    }, {
        key: 'setPrefix',
        value: function setPrefix(prefix) {
            this.map_prefix = prefix;
        }
    }]);

    return FeatureSelection;
})();

exports['default'] = FeatureSelection;
FeatureSelection.map = {}; // this will be unique per module instance (so unique per worker)
FeatureSelection.tiles = {}; // selection keys, by tile
FeatureSelection.map_size = 0;
FeatureSelection.map_entry = 0;
FeatureSelection.map_prefix = 0; // set by worker to worker id #
FeatureSelection.defaultColor = [0, 0, 0, 1];
module.exports = exports['default'];

},{"./gl/texture":200,"./utils/worker_broker":243,"babel-runtime/core-js/promise":13,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/interop-require-default":22,"loglevel":179}],213:[function(_dereq_,module,exports){
/*jshint worker: true */
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _geo = _dereq_('../geo');

var _geo2 = _interopRequireDefault(_geo);

var _utilsErrors = _dereq_('../utils/errors');

var _utilsUtils = _dereq_('../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var DataSource = (function () {
    function DataSource(source) {
        _classCallCheck(this, DataSource);

        this.id = source.id;
        this.name = source.name;
        this.url = source.url;
        this.pad_scale = source.pad_scale || 0.0005; // scale tile up by small factor to cover seams
        this.enforce_winding = source.enforce_winding || false; // whether to enforce winding order

        // Optional function to transform source data
        this.transform = source.transform;
        if (typeof this.transform === 'function') {
            this.transform.bind(this);
        }

        // Optional additional data to pass to the transform function
        this.extra_data = source.extra_data;

        // Optional additional scripts made available to the transform function
        if (typeof importScripts === 'function' && source.scripts) {
            source.scripts.forEach(function (s, si) {
                try {
                    importScripts(s);
                    _utilsUtils2['default'].log('info', 'DataSource: loaded library: ' + s);
                } catch (e) {
                    _utilsUtils2['default'].log('error', 'DataSource: failed to load library: ' + s);
                    _utilsUtils2['default'].log('error', e);
                }
            });
        }

        // overzoom will apply for zooms higher than this
        this.max_zoom = Math.min(source.max_zoom || _geo2['default'].max_zoom, _geo2['default'].max_zoom);
    }

    // Create a tile source by type, factory-style

    _createClass(DataSource, [{
        key: 'load',
        // flip coords positive
        value: function load(dest) {
            var _this = this;

            dest.source_data = {};
            dest.source_data.layers = {};
            dest.pad_scale = this.pad_scale;

            return this._load(dest).then(function (dest) {
                // Post-processing
                for (var layer in dest.source_data.layers) {
                    var data = dest.source_data.layers[layer];
                    if (data && data.features) {
                        data.features.forEach(function (feature) {
                            _geo2['default'].transformGeometry(feature.geometry, function (coord) {
                                // Flip Y coords
                                coord[1] = -coord[1];

                                // Slightly scale up tile to cover seams
                                if (_this.pad_scale) {
                                    coord[0] = Math.round(coord[0] * (1 + _this.pad_scale) - _geo2['default'].tile_scale * _this.pad_scale / 2);
                                    coord[1] = Math.round(coord[1] * (1 + _this.pad_scale) - _geo2['default'].tile_scale * _this.pad_scale / 2);
                                }
                            });

                            // Optionally enforce winding order since not all data sources guarantee it
                            if (_this.enforce_winding) {
                                _geo2['default'].enforceWinding(feature.geometry, 'CCW');
                            }
                        });
                    }
                }
            });
        }

        // Sub-classes must implement
    }, {
        key: '_load',
        value: function _load(dest) {
            throw new _utilsErrors.MethodNotImplemented('_load');
        }

        // Register a new data source type, under a type name
    }], [{
        key: 'create',
        value: function create(source) {
            if (DataSource.types[source.type]) {
                return new DataSource.types[source.type](source);
            }
        }

        // Mercator projection
    }, {
        key: 'projectData',
        value: function projectData(source) {
            var timer = +new Date();
            for (var t in source.layers) {
                var num_features = source.layers[t].features.length;
                for (var f = 0; f < num_features; f++) {
                    var feature = source.layers[t].features[f];
                    _geo2['default'].transformGeometry(feature.geometry, function (coord) {
                        var _Geo$latLngToMeters = _geo2['default'].latLngToMeters(coord);

                        var _Geo$latLngToMeters2 = _slicedToArray(_Geo$latLngToMeters, 2);

                        var x = _Geo$latLngToMeters2[0];
                        var y = _Geo$latLngToMeters2[1];

                        coord[0] = x;
                        coord[1] = y;
                    });
                }
            }

            if (source.debug !== undefined) {
                source.debug.projection = +new Date() - timer;
            }
        }

        /**
         Re-scale geometries within each source to internal tile units
        */
    }, {
        key: 'scaleData',
        value: function scaleData(source, _ref) {
            var z = _ref.coords.z;
            var min = _ref.min;
            var max = _ref.max;

            for (var t in source.layers) {
                var num_features = source.layers[t].features.length;
                for (var f = 0; f < num_features; f++) {
                    var feature = source.layers[t].features[f];
                    _geo2['default'].transformGeometry(feature.geometry, function (coord) {
                        coord[0] = (coord[0] - min.x) * _geo2['default'].units_per_meter[z];
                        coord[1] = (coord[1] - min.y) * _geo2['default'].units_per_meter[z] * -1;
                    });
                }
            }
        }
    }, {
        key: 'register',
        value: function register(type_class, type_name) {
            if (!type_class || !type_name) {
                return;
            }

            DataSource.types[type_name] = type_class;
        }
    }]);

    return DataSource;
})();

exports['default'] = DataSource;

DataSource.types = {}; // set of supported data source classes, referenced by type name

/*** Generic network loading source - abstract class ***/

var NetworkSource = (function (_DataSource) {
    _inherits(NetworkSource, _DataSource);

    function NetworkSource(source) {
        _classCallCheck(this, NetworkSource);

        _get(Object.getPrototypeOf(NetworkSource.prototype), 'constructor', this).call(this, source);
        this.response_type = ""; // use to set explicit XHR type
    }

    /*** Generic network tile loading - abstract class ***/

    _createClass(NetworkSource, [{
        key: '_load',
        value: function _load(dest) {
            var _this2 = this;

            // super.load(dest);

            var url = this.formatUrl(dest);

            var source_data = dest.source_data;
            source_data.url = url;
            dest.debug = dest.debug || {};
            dest.debug.network = +new Date();

            return new _Promise(function (resolve, reject) {
                source_data.error = null;
                // For testing network errors
                // var promise = Utils.io(url, 60 * 100, this.response_type);
                // if (Math.random() < .7) {
                //     promise = Promise.reject(Error('fake data source error'));
                // }
                // promise.then((body) => {
                var promise = _utilsUtils2['default'].io(url, 60 * 1000, _this2.response_type);
                source_data.request = promise.request;

                promise.then(function (body) {
                    dest.debug.response_size = body.length || body.byteLength;
                    dest.debug.network = +new Date() - dest.debug.network;
                    dest.debug.parsing = +new Date();
                    _this2.parseSourceData(dest, source_data, body);
                    dest.debug.parsing = +new Date() - dest.debug.parsing;
                    resolve(dest);
                })['catch'](function (error) {
                    source_data.error = error.toString();
                    resolve(dest); // resolve request but pass along error
                });
            });
        }

        // Sub-classes must implement:

    }, {
        key: 'formatUrl',
        value: function formatUrl(dest) {
            throw new _utilsErrors.MethodNotImplemented('formatUrl');
        }
    }, {
        key: 'parseSourceData',
        value: function parseSourceData(dest, source, reponse) {
            throw new _utilsErrors.MethodNotImplemented('parseSourceData');
        }
    }]);

    return NetworkSource;
})(DataSource);

exports.NetworkSource = NetworkSource;

var NetworkTileSource = (function (_NetworkSource) {
    _inherits(NetworkTileSource, _NetworkSource);

    function NetworkTileSource(source) {
        _classCallCheck(this, NetworkTileSource);

        _get(Object.getPrototypeOf(NetworkTileSource.prototype), 'constructor', this).call(this, source);

        this.tiled = true;
        this.url_hosts = null;
        var host_match = this.url.match(/{s:\[([^}+]+)\]}/);
        if (host_match != null && host_match.length > 1) {
            this.url_hosts = host_match[1].split(',');
            this.next_host = 0;
        }
    }

    _createClass(NetworkTileSource, [{
        key: 'formatUrl',
        value: function formatUrl(tile) {
            var coords = _geo2['default'].wrapTile(tile.coords, { x: true });
            var url = this.url.replace('{x}', coords.x).replace('{y}', coords.y).replace('{z}', coords.z);

            if (this.url_hosts != null) {
                url = url.replace(/{s:\[([^}+]+)\]}/, this.url_hosts[this.next_host]);
                this.next_host = (this.next_host + 1) % this.url_hosts.length;
            }
            return url;
        }

        // Checks for the x/y/z tile pattern in URL template
    }, {
        key: 'urlHasTilePattern',
        value: function urlHasTilePattern(url) {
            return url && url.search('{x}') > -1 && url.search('{y}') > -1 && url.search('{z}') > -1;
        }
    }]);

    return NetworkTileSource;
})(NetworkSource);

exports.NetworkTileSource = NetworkTileSource;

},{"../geo":192,"../utils/errors":237,"../utils/utils":241,"babel-runtime/core-js/promise":13,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/get":20,"babel-runtime/helpers/inherits":21,"babel-runtime/helpers/interop-require-default":22,"babel-runtime/helpers/sliced-to-array":23}],214:[function(_dereq_,module,exports){
'use strict';

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _data_source = _dereq_('./data_source');

var _data_source2 = _interopRequireDefault(_data_source);

var _mvt = _dereq_('./mvt');

var _geo = _dereq_('../geo');

var _geo2 = _interopRequireDefault(_geo);

// For tiling GeoJSON client-side

var _geojsonVt = _dereq_('geojson-vt');

var _geojsonVt2 = _interopRequireDefault(_geojsonVt);

/**
 Mapzen/OSM.US-style GeoJSON vector tiles
 @class GeoJSONTileSource
*/

var GeoJSONTileSource = (function (_NetworkTileSource) {
    _inherits(GeoJSONTileSource, _NetworkTileSource);

    function GeoJSONTileSource(source) {
        _classCallCheck(this, GeoJSONTileSource);

        _get(Object.getPrototypeOf(GeoJSONTileSource.prototype), 'constructor', this).call(this, source);

        // Check for URL tile pattern, if not found, treat as standalone GeoJSON/TopoJSON object
        if (!this.urlHasTilePattern(this.url)) {
            // Check instance type from parent class
            if (this instanceof GeoJSONTileSource) {
                // Replace instance type
                return new GeoJSONSource(source);
            } else {
                // Pass back to parent class to instantiate
                return null;
            }
        }
        return this;
    }

    /**
     GeoJSON standalone (non-tiled) source
     Uses geojson-vt split into tiles client-side
    */

    _createClass(GeoJSONTileSource, [{
        key: 'parseSourceData',
        value: function parseSourceData(tile, source, response) {
            var data = JSON.parse(response);
            this.prepareGeoJSON(data, tile, source);
        }
    }, {
        key: 'prepareGeoJSON',
        value: function prepareGeoJSON(data, tile, source) {
            // Apply optional data transform
            if (typeof this.transform === 'function') {
                data = this.transform(data, this.extra_data);
            }

            source.layers = GeoJSONSource.prototype.getLayers(data);

            // A "synthetic" tile that adjusts the tile min anchor to account for tile longitude wrapping
            var anchor = {
                coords: tile.coords,
                min: _geo2['default'].metersForTile(_geo2['default'].wrapTile(tile.coords, { x: true }))
            };

            _data_source2['default'].projectData(source); // mercator projection
            _data_source2['default'].scaleData(source, anchor); // re-scale from meters to local tile coords
        }
    }]);

    return GeoJSONTileSource;
})(_data_source.NetworkTileSource);

exports.GeoJSONTileSource = GeoJSONTileSource;

var GeoJSONSource = (function (_NetworkSource) {
    _inherits(GeoJSONSource, _NetworkSource);

    function GeoJSONSource(source) {
        _classCallCheck(this, GeoJSONSource);

        _get(Object.getPrototypeOf(GeoJSONSource.prototype), 'constructor', this).call(this, source);
        this.tiled = true;
        this.load_data = null;
        this.tile_indexes = {}; // geojson-vt tile indices, by layer name
        this.max_zoom = Math.max(this.max_zoom || 0, 15); // TODO: max zoom < 15 causes artifacts/no-draw at 20, investigate
        this.pad_scale = 0; // we don't want padding on auto-tiled sources
        this.enforce_winding = source.enforce_winding === false ? false : true; // default on, can be forced off
    }

    _createClass(GeoJSONSource, [{
        key: '_load',
        value: function _load(dest) {
            var _this = this;

            if (!this.load_data) {
                this.load_data = _get(Object.getPrototypeOf(GeoJSONSource.prototype), '_load', this).call(this, { source_data: { layers: {} } }).then(function (data) {
                    var layers = data.source_data.layers;
                    for (var layer_name in layers) {
                        _this.tile_indexes[layer_name] = (0, _geojsonVt2['default'])(layers[layer_name], {
                            maxZoom: _this.max_zoom, // max zoom to preserve detail on
                            tolerance: 3, // simplification tolerance (higher means simpler)
                            extent: _geo2['default'].tile_scale, // tile extent (both width and height)
                            buffer: 0 // tile buffer on each side
                        });
                    }

                    _this.loaded = true;
                    return data;
                });
            }

            return this.load_data.then(function () {
                for (var layer_name in _this.tile_indexes) {
                    dest.source_data.layers[layer_name] = _this.getTileFeatures(dest, layer_name);
                }
                return dest;
            });
        }
    }, {
        key: 'getTileFeatures',
        value: function getTileFeatures(tile, layer_name) {
            var coords = _geo2['default'].wrapTile(tile.coords, { x: true });

            // request a particular tile
            var t = this.tile_indexes[layer_name].getTile(coords.z, coords.x, coords.y);

            // Convert from MVT-style JSON struct to GeoJSON
            var collection = undefined;
            if (t && t.features) {
                collection = {
                    type: 'FeatureCollection',
                    features: []
                };

                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = _getIterator(t.features), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var feature = _step.value;

                        // GeoJSON feature
                        var f = {
                            type: 'Feature',
                            geometry: {},
                            properties: feature.tags
                        };

                        if (feature.type === 1) {
                            f.geometry.coordinates = feature.geometry.map(function (coord) {
                                return [coord[0], coord[1]];
                            });
                            f.geometry.type = 'MultiPoint';
                        } else if (feature.type === 2 || feature.type === 3) {
                            f.geometry.coordinates = feature.geometry.map(function (ring) {
                                return ring.map(function (coord) {
                                    return [coord[0], coord[1]];
                                });
                            });

                            if (feature.type === 2) {
                                f.geometry.type = 'MultiLineString';
                            } else {
                                f.geometry = _mvt.MVTSource.decodeMultiPolygon(f.geometry); // un-flatten rings
                            }
                        } else {
                                continue;
                            }

                        collection.features.push(f);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator['return']) {
                            _iterator['return']();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }

            return collection;
        }
    }, {
        key: 'formatUrl',
        value: function formatUrl(dest) {
            return this.url;
        }
    }, {
        key: 'parseSourceData',
        value: function parseSourceData(tile, source, response) {
            source.layers = this.getLayers(JSON.parse(response));
        }

        // Detect single or multiple layers in returned data
    }, {
        key: 'getLayers',
        value: function getLayers(data) {
            if (data.type === 'Feature' || data.type === 'FeatureCollection') {
                return { _default: data };
            } else {
                return data;
            }
        }
    }]);

    return GeoJSONSource;
})(_data_source.NetworkSource);

exports.GeoJSONSource = GeoJSONSource;

_data_source2['default'].register(GeoJSONTileSource, 'GeoJSON'); // prefered shorter name
_data_source2['default'].register(GeoJSONTileSource, 'GeoJSONTiles'); // for backwards-compatibility

},{"../geo":192,"./data_source":213,"./mvt":215,"babel-runtime/core-js/get-iterator":2,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/get":20,"babel-runtime/helpers/inherits":21,"babel-runtime/helpers/interop-require-default":22,"geojson-vt":142}],215:[function(_dereq_,module,exports){
'use strict';

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _data_source = _dereq_('./data_source');

var _data_source2 = _interopRequireDefault(_data_source);

var _geo = _dereq_('../geo');

var _geo2 = _interopRequireDefault(_geo);

var _pbf = _dereq_('pbf');

var _pbf2 = _interopRequireDefault(_pbf);

var _vectorTile = _dereq_('vector-tile');

/**
 Mapbox Vector Tile format
 @class MVTSource
*/

var MVTSource = (function (_NetworkTileSource) {
    _inherits(MVTSource, _NetworkTileSource);

    function MVTSource(source) {
        _classCallCheck(this, MVTSource);

        _get(Object.getPrototypeOf(MVTSource.prototype), 'constructor', this).call(this, source);
        this.response_type = "arraybuffer"; // binary data
    }

    _createClass(MVTSource, [{
        key: 'parseSourceData',
        value: function parseSourceData(tile, source, response) {
            // Convert Mapbox vector tile to GeoJSON
            var data = new Uint8Array(response);
            var buffer = new _pbf2['default'](data);
            source.data = new _vectorTile.VectorTile(buffer);
            source.layers = this.toGeoJSON(source.data);
            delete source.data; // comment out to save raw data for debugging
        }

        // Loop through layers/features using Mapbox lib API, convert to GeoJSON features
        // Returns an object with keys for each layer, e.g. { layer: geojson }
    }, {
        key: 'toGeoJSON',
        value: function toGeoJSON(tile) {
            var layers = {};
            for (var l in tile.layers) {
                var layer = tile.layers[l];
                var layer_geojson = {
                    type: 'FeatureCollection',
                    features: []
                };

                for (var f = 0; f < layer.length; f++) {
                    var feature = layer.feature(f);
                    var feature_geojson = {
                        type: 'Feature',
                        geometry: {},
                        properties: feature.properties
                    };

                    var geometry = feature_geojson.geometry;
                    var coordinates = feature.loadGeometry();
                    for (var r = 0; r < coordinates.length; r++) {
                        var ring = coordinates[r];
                        for (var c = 0; c < ring.length; c++) {
                            ring[c] = [ring[c].x, ring[c].y];
                        }
                    }
                    geometry.coordinates = coordinates;

                    if (_vectorTile.VectorTileFeature.types[feature.type] === 'Point') {
                        geometry.type = 'Point';
                        geometry.coordinates = geometry.coordinates[0][0];
                    } else if (_vectorTile.VectorTileFeature.types[feature.type] === 'LineString') {
                        if (coordinates.length === 1) {
                            geometry.type = 'LineString';
                            geometry.coordinates = geometry.coordinates[0];
                        } else {
                            geometry.type = 'MultiLineString';
                        }
                    } else if (_vectorTile.VectorTileFeature.types[feature.type] === 'Polygon') {
                        geometry = MVTSource.decodeMultiPolygon(geometry); // un-flatten rings
                    }

                    layer_geojson.features.push(feature_geojson);
                }
                layers[l] = layer_geojson;
            }
            return layers;
        }

        // Decode multipolygons, which are encoded as a single set of rings
        // Outer rings are wound CW, inner are CCW
        // A CW ring indicates the start of a new polygon
    }], [{
        key: 'decodeMultiPolygon',
        value: function decodeMultiPolygon(geom) {
            var polys = [];
            var poly = [];
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = _getIterator(geom.coordinates), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var ring = _step.value;

                    var winding = _geo2['default'].ringWinding(ring);
                    if (winding === 'CW' && poly.length > 0) {
                        polys.push(poly);
                        poly = [];
                    }
                    poly.push(ring);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator['return']) {
                        _iterator['return']();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            if (poly.length > 0) {
                polys.push(poly);
            }

            // Single or multi?
            if (polys.length === 1) {
                geom.type = 'Polygon';
                geom.coordinates = polys[0];
            } else {
                geom.type = 'MultiPolygon';
                geom.coordinates = polys;
            }

            return geom;
        }
    }]);

    return MVTSource;
})(_data_source.NetworkTileSource);

exports.MVTSource = MVTSource;

_data_source2['default'].register(MVTSource, 'MVT');

},{"../geo":192,"./data_source":213,"babel-runtime/core-js/get-iterator":2,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/get":20,"babel-runtime/helpers/inherits":21,"babel-runtime/helpers/interop-require-default":22,"pbf":182,"vector-tile":186}],216:[function(_dereq_,module,exports){
'use strict';

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _data_source = _dereq_('./data_source');

var _data_source2 = _interopRequireDefault(_data_source);

var _geojson = _dereq_('./geojson');

var _topojson = _dereq_('topojson');

var _topojson2 = _interopRequireDefault(_topojson);

/**
 Mapzen/OSM.US-style TopoJSON vector tiles
 @class TopoJSONTileSource
*/

var TopoJSONTileSource = (function (_GeoJSONTileSource) {
    _inherits(TopoJSONTileSource, _GeoJSONTileSource);

    function TopoJSONTileSource(source) {
        _classCallCheck(this, TopoJSONTileSource);

        var _this = _get(Object.getPrototypeOf(TopoJSONTileSource.prototype), 'constructor', this).call(this, source);

        // Replace with non-tiled source if tiled source failed to instantiate
        if (_this !== this) {
            return new TopoJSONSource(source);
        }
    }

    /**
     TopoJSON standalone (non-tiled) source
     Uses geojson-vt split into tiles client-side
    */

    _createClass(TopoJSONTileSource, [{
        key: 'parseSourceData',
        value: function parseSourceData(tile, source, response) {
            var data = JSON.parse(response);
            data = TopoJSONSource.prototype.toGeoJSON(data);
            this.prepareGeoJSON(data, tile, source);
        }
    }]);

    return TopoJSONTileSource;
})(_geojson.GeoJSONTileSource);

exports.TopoJSONTileSource = TopoJSONTileSource;

var TopoJSONSource = (function (_GeoJSONSource) {
    _inherits(TopoJSONSource, _GeoJSONSource);

    function TopoJSONSource() {
        _classCallCheck(this, TopoJSONSource);

        _get(Object.getPrototypeOf(TopoJSONSource.prototype), 'constructor', this).apply(this, arguments);
    }

    _createClass(TopoJSONSource, [{
        key: 'parseSourceData',
        value: function parseSourceData(tile, source, response) {
            var data = JSON.parse(response);
            data = this.toGeoJSON(data);
            source.layers = this.getLayers(data);
        }
    }, {
        key: 'toGeoJSON',
        value: function toGeoJSON(data) {
            // Single layer
            if (data.objects && _Object$keys(data.objects).length === 1) {
                var layer = _Object$keys(data.objects)[0];
                data = _topojson2['default'].feature(data, data.objects[layer]);
            }
            // Multiple layers
            else {
                    var layers = {};
                    for (var key in data.objects) {
                        layers[key] = _topojson2['default'].feature(data, data.objects[key]);
                    }
                    data = layers;
                }
            return data;
        }
    }]);

    return TopoJSONSource;
})(_geojson.GeoJSONSource);

exports.TopoJSONSource = TopoJSONSource;

_data_source2['default'].register(TopoJSONTileSource, 'TopoJSON'); // prefered shorter name
_data_source2['default'].register(TopoJSONTileSource, 'TopoJSONTiles'); // for backwards-compatibility

},{"./data_source":213,"./geojson":214,"babel-runtime/core-js/object/keys":11,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/get":20,"babel-runtime/helpers/inherits":21,"babel-runtime/helpers/interop-require-default":22,"topojson":185}],217:[function(_dereq_,module,exports){
// Geometry building functions

'use strict';

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _vector = _dereq_('../vector');

var _vector2 = _interopRequireDefault(_vector);

var _geo = _dereq_('../geo');

var _geo2 = _interopRequireDefault(_geo);

var _earcut = _dereq_('earcut');

var _earcut2 = _interopRequireDefault(_earcut);

var Builders;
exports['default'] = Builders = {};

Builders.debug = false;

Builders.tile_bounds = [{ x: 0, y: 0 }, { x: _geo2['default'].tile_scale, y: -_geo2['default'].tile_scale } // TODO: correct for flipped y-axis?
];

// Re-scale UVs from [0, 1] range to a smaller area within the image
Builders.scaleTexcoordsToSprite = function (uv, area_origin, area_size, tex_size) {
    var area_origin_y = tex_size[1] - area_origin[1] - area_size[1];
    var suv = [];
    suv[0] = (uv[0] * area_size[0] + area_origin[0]) / tex_size[0];
    suv[1] = (uv[1] * area_size[1] + area_origin_y) / tex_size[1];
    return suv;
};

Builders.getTexcoordsForSprite = function (area_origin, area_size, tex_size) {
    return [Builders.scaleTexcoordsToSprite([0, 0], area_origin, area_size, tex_size), Builders.scaleTexcoordsToSprite([1, 1], area_origin, area_size, tex_size)];
};

// Tesselate a flat 2D polygon
// x & y coordinates will be set as first two elements of provided vertex_template
Builders.buildPolygons = function (polygons, vertex_data, vertex_template, _ref) {
    var texcoord_index = _ref.texcoord_index;
    var texcoord_scale = _ref.texcoord_scale;
    var texcoord_normalize = _ref.texcoord_normalize;

    if (texcoord_index) {
        texcoord_normalize = texcoord_normalize || 1;

        var _ref2 = texcoord_scale || [[0, 0], [1, 1]];

        var _ref22 = _slicedToArray(_ref2, 2);

        var _ref22$0 = _slicedToArray(_ref22[0], 2);

        var min_u = _ref22$0[0];
        var min_v = _ref22$0[1];

        var _ref22$1 = _slicedToArray(_ref22[1], 2);

        var max_u = _ref22$1[0];
        var max_v = _ref22$1[1];
    }

    var num_polygons = polygons.length;
    for (var p = 0; p < num_polygons; p++) {
        var polygon = polygons[p];

        // Find polygon extents to calculate UVs, fit them to the axis-aligned bounding box
        if (texcoord_index) {
            var _Geo$findBoundingBox = _geo2['default'].findBoundingBox(polygon);

            var _Geo$findBoundingBox2 = _slicedToArray(_Geo$findBoundingBox, 4);

            var min_x = _Geo$findBoundingBox2[0];
            var min_y = _Geo$findBoundingBox2[1];
            var max_x = _Geo$findBoundingBox2[2];
            var max_y = _Geo$findBoundingBox2[3];

            var span_x = max_x - min_x;
            var span_y = max_y - min_y;
            var scale_u = (max_u - min_u) / span_x;
            var scale_v = (max_v - min_v) / span_y;
        }

        // Tessellate
        var vertices = Builders.triangulatePolygon(polygon);

        // Add vertex data
        var num_vertices = vertices.length;
        for (var v = 0; v < num_vertices; v++) {
            var vertex = vertices[v];
            vertex_template[0] = vertex[0];
            vertex_template[1] = vertex[1];

            // Add UVs
            if (texcoord_index) {
                vertex_template[texcoord_index + 0] = ((vertex[0] - min_x) * scale_u + min_u) * texcoord_normalize;
                vertex_template[texcoord_index + 1] = ((vertex[1] - min_y) * scale_v + min_v) * texcoord_normalize;
            }

            vertex_data.addVertex(vertex_template);
        }
    }
};

// Tesselate and extrude a flat 2D polygon into a simple 3D model with fixed height and add to GL vertex buffer
Builders.buildExtrudedPolygons = function (polygons, z, height, min_height, vertex_data, vertex_template, normal_index, normal_normalize, _ref3) {
    var remove_tile_edges = _ref3.remove_tile_edges;
    var tile_edge_tolerance = _ref3.tile_edge_tolerance;
    var texcoord_index = _ref3.texcoord_index;
    var texcoord_scale = _ref3.texcoord_scale;
    var texcoord_normalize = _ref3.texcoord_normalize;

    // Top
    var min_z = z + (min_height || 0);
    var max_z = z + height;
    vertex_template[2] = max_z;
    Builders.buildPolygons(polygons, vertex_data, vertex_template, { texcoord_index: texcoord_index, texcoord_scale: texcoord_scale, texcoord_normalize: texcoord_normalize });

    // Walls
    // Fit UVs to wall quad
    if (texcoord_index) {
        texcoord_normalize = texcoord_normalize || 1;

        var _ref4 = texcoord_scale || [[0, 0], [1, 1]];

        var _ref42 = _slicedToArray(_ref4, 2);

        var _ref42$0 = _slicedToArray(_ref42[0], 2);

        var min_u = _ref42$0[0];
        var min_v = _ref42$0[1];

        var _ref42$1 = _slicedToArray(_ref42[1], 2);

        var max_u = _ref42$1[0];
        var max_v = _ref42$1[1];

        var texcoords = [[min_u, max_v], [min_u, min_v], [max_u, min_v], [max_u, min_v], [max_u, max_v], [min_u, max_v]];
    }

    var num_polygons = polygons.length;
    for (var p = 0; p < num_polygons; p++) {
        var polygon = polygons[p];

        for (var q = 0; q < polygon.length; q++) {
            var contour = polygon[q];

            for (var w = 0; w < contour.length - 1; w++) {
                if (remove_tile_edges && Builders.isOnTileEdge(contour[w], contour[w + 1], { tolerance: tile_edge_tolerance })) {
                    continue; // don't extrude tile edges
                }

                // Two triangles for the quad formed by each vertex pair, going from bottom to top height
                var wall_vertices = [
                // Triangle
                [contour[w + 1][0], contour[w + 1][1], max_z], [contour[w + 1][0], contour[w + 1][1], min_z], [contour[w][0], contour[w][1], min_z],
                // Triangle
                [contour[w][0], contour[w][1], min_z], [contour[w][0], contour[w][1], max_z], [contour[w + 1][0], contour[w + 1][1], max_z]];

                // Calc the normal of the wall from up vector and one segment of the wall triangles
                var normal = _vector2['default'].cross([0, 0, 1], _vector2['default'].normalize([contour[w + 1][0] - contour[w][0], contour[w + 1][1] - contour[w][1], 0]));

                // Update vertex template with current surface normal
                vertex_template[normal_index + 0] = normal[0] * normal_normalize;
                vertex_template[normal_index + 1] = normal[1] * normal_normalize;
                vertex_template[normal_index + 2] = normal[2] * normal_normalize;

                for (var wv = 0; wv < wall_vertices.length; wv++) {
                    vertex_template[0] = wall_vertices[wv][0];
                    vertex_template[1] = wall_vertices[wv][1];
                    vertex_template[2] = wall_vertices[wv][2];

                    if (texcoord_index) {
                        vertex_template[texcoord_index + 0] = texcoords[wv][0] * texcoord_normalize;
                        vertex_template[texcoord_index + 1] = texcoords[wv][1] * texcoord_normalize;
                    }

                    vertex_data.addVertex(vertex_template);
                }
            }
        }
    }
};

// Build tessellated triangles for a polyline
Builders.buildPolylines = function (lines, width, vertex_data, vertex_template, _ref5) {
    var closed_polygon = _ref5.closed_polygon;
    var remove_tile_edges = _ref5.remove_tile_edges;
    var tile_edge_tolerance = _ref5.tile_edge_tolerance;
    var texcoord_index = _ref5.texcoord_index;
    var texcoord_scale = _ref5.texcoord_scale;
    var texcoord_normalize = _ref5.texcoord_normalize;
    var scaling_index = _ref5.scaling_index;
    var scaling_normalize = _ref5.scaling_normalize;
    var join = _ref5.join;
    var cap = _ref5.cap;

    var cornersOnCap = cap === "square" ? 2 : cap === "round" ? 3 : 0; // Butt is the implicit default
    var trianglesOnJoin = join === "bevel" ? 1 : join === "round" ? 3 : 0; // Miter is the implicit default

    // Build variables
    texcoord_normalize = texcoord_normalize || 1;

    var _ref6 = texcoord_scale || [[0, 0], [1, 1]];

    var _ref62 = _slicedToArray(_ref6, 2);

    var _ref62$0 = _slicedToArray(_ref62[0], 2);

    var min_u = _ref62$0[0];
    var min_v = _ref62$0[1];

    var _ref62$1 = _slicedToArray(_ref62[1], 2);

    var max_u = _ref62$1[0];
    var max_v = _ref62$1[1];

    // Values that are constant for each line and are passed to helper functions
    var constants = {
        vertex_data: vertex_data,
        vertex_template: vertex_template,
        halfWidth: width / 2,
        vertices: [],
        scaling_index: scaling_index,
        scaling_normalize: scaling_normalize,
        scalingVecs: scaling_index && [],
        texcoord_index: texcoord_index,
        texcoords: texcoord_index && [],
        texcoord_normalize: texcoord_normalize,
        min_u: min_u, min_v: min_v, max_u: max_u, max_v: max_v,
        nPairs: 0
    };

    for (var ln = 0; ln < lines.length; ln++) {
        var line = lines[ln];
        var lineSize = line.length;

        // Ignore non-lines
        if (lineSize < 2) {
            continue;
        }

        //  Initialize variables
        var coordPrev = [0, 0],
            // Previous point coordinates
        coordCurr = [0, 0],
            // Current point coordinates
        coordNext = [0, 0]; // Next point coordinates

        var normPrev = [0, 0],
            // Right normal to segment between previous and current m_points
        normCurr = [0, 0],
            // Right normal at current point, scaled for miter joint
        normNext = [0, 0]; // Right normal to segment between current and next m_points

        var isPrev = false,
            isNext = true;

        // Add vertices to buffer according to their index
        indexPairs(constants);

        // Do this with the rest (except the last one)
        for (var i = 0; i < lineSize; i++) {

            // There is a next one?
            isNext = i + 1 < lineSize;

            if (isPrev) {
                // If there is a previous one, copy the current (previous) values on *Prev
                coordPrev = coordCurr;
                normPrev = _vector2['default'].normalize(_vector2['default'].perp(coordPrev, line[i]));
            } else if (i === 0 && closed_polygon === true) {
                // If it's the first point and is a closed polygon

                var needToClose = true;
                if (remove_tile_edges) {
                    if (Builders.isOnTileEdge(line[i], line[lineSize - 2], { tolerance: tile_edge_tolerance })) {
                        needToClose = false;
                    }
                }

                if (needToClose) {
                    coordPrev = line[lineSize - 2];
                    normPrev = _vector2['default'].normalize(_vector2['default'].perp(coordPrev, line[i]));
                    isPrev = true;
                }
            }

            // Assign current coordinate
            coordCurr = line[i];

            if (isNext) {
                coordNext = line[i + 1];
            } else if (closed_polygon === true) {
                // If it's the last point in a closed polygon
                coordNext = line[1];
                isNext = true;
            }

            if (isNext) {
                // If it's not the last one get next coordinates and calculate the right normal

                normNext = _vector2['default'].normalize(_vector2['default'].perp(coordCurr, coordNext));
                if (remove_tile_edges) {
                    if (Builders.isOnTileEdge(coordCurr, coordNext, { tolerance: tile_edge_tolerance })) {
                        normCurr = _vector2['default'].normalize(_vector2['default'].perp(coordPrev, coordCurr));
                        if (isPrev) {
                            addVertexPair(coordCurr, normCurr, i / lineSize, constants);
                            constants.nPairs++;

                            // Add vertices to buffer acording their index
                            indexPairs(constants);
                        }
                        isPrev = false;
                        continue;
                    }
                }
            }

            //  Compute current normal
            if (isPrev) {
                //  If there is a PREVIOUS ...
                if (isNext) {
                    // ... and a NEXT ONE, compute previous and next normals (scaled by the angle with the last prev)
                    normCurr = _vector2['default'].normalize(_vector2['default'].add(normPrev, normNext));
                    var scale = 2 / (1 + Math.abs(_vector2['default'].dot(normPrev, normCurr)));
                    normCurr = _vector2['default'].mult(normCurr, scale * scale);
                } else {
                    // ... and there is NOT a NEXT ONE, copy the previous next one (which is the current one)
                    normCurr = _vector2['default'].normalize(_vector2['default'].perp(coordPrev, coordCurr));
                }
            } else {
                // If there is NO PREVIOUS ...
                if (isNext) {
                    // ... and a NEXT ONE,
                    normNext = _vector2['default'].normalize(_vector2['default'].perp(coordCurr, coordNext));
                    normCurr = normNext;
                } else {
                    // ... and NO NEXT ONE, nothing to do (without prev or next one this is just a point)
                    continue;
                }
            }

            if (isPrev || isNext) {
                // If it's the BEGINNING of a LINE
                if (i === 0 && !isPrev && !closed_polygon) {
                    addCap(coordCurr, normCurr, cornersOnCap, true, constants);
                }

                // If it's a JOIN
                if (trianglesOnJoin !== 0 && isPrev && isNext) {
                    addJoin([coordPrev, coordCurr, coordNext], [normPrev, normCurr, normNext], i / lineSize, trianglesOnJoin, constants);
                } else {
                    addVertexPair(coordCurr, normCurr, i / (lineSize - 1), constants);
                }

                if (isNext) {
                    constants.nPairs++;
                }

                isPrev = true;
            }
        }

        // Add vertices to buffer according to their index
        indexPairs(constants);

        // If it's the END of a LINE
        if (!closed_polygon) {
            addCap(coordCurr, normCurr, cornersOnCap, false, constants);
        }
    }
};

// Add to equidistant pairs of vertices (internal method for polyline builder)
function addVertex(coord, normal, uv, _ref7) {
    var halfWidth = _ref7.halfWidth;
    var vertices = _ref7.vertices;
    var scalingVecs = _ref7.scalingVecs;
    var texcoords = _ref7.texcoords;

    if (scalingVecs) {
        //  a. If scaling is on add the vertex (the currCoord) and the scaling Vecs (normals pointing where to extrude the vertices)
        vertices.push(coord);
        scalingVecs.push(normal);
    } else {
        //  b. Add the extruded vertices
        vertices.push([coord[0] + normal[0] * halfWidth, coord[1] + normal[1] * halfWidth]);
    }

    // c) Add UVs if they are enabled
    if (texcoords) {
        texcoords.push(uv);
    }
}

//  Add to equidistant pairs of vertices (internal method for polyline builder)
function addVertexPair(coord, normal, v_pct, constants) {
    addVertex(coord, normal, [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v], constants);
    addVertex(coord, _vector2['default'].neg(normal), [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v], constants);
}

//  Tessalate a FAN geometry between points A       B
//  using their normals from a center        \ . . /
//  and interpolating their UVs               \ p /
//                                             \./
//                                              C
function addFan(coord, nA, nC, nB, uA, uC, uB, signed, numTriangles, constants) {

    if (numTriangles < 1) {
        return;
    }

    // Add previous vertices to buffer and clear the buffers and index pairs
    // because we are going to add more triangles.
    indexPairs(constants);

    var normCurr = _vector2['default'].set(nA);
    var normPrev = [0, 0];

    var angle_delta = _vector2['default'].dot(nA, nB);
    if (angle_delta < -1) {
        angle_delta = -1;
    }
    angle_delta = Math.acos(angle_delta) / numTriangles;

    if (!signed) {
        angle_delta *= -1;
    }

    var uvCurr = _vector2['default'].set(uA);
    var uv_delta = _vector2['default'].div(_vector2['default'].sub(uB, uA), numTriangles);

    //  Add the FIRST and CENTER vertex
    //  The triangles will be composed in a FAN style around it
    addVertex(coord, nC, uC, constants);

    //  Add first corner
    addVertex(coord, normCurr, uA, constants);

    // Iterate through the rest of the corners
    for (var t = 0; t < numTriangles; t++) {
        normPrev = _vector2['default'].normalize(normCurr);
        normCurr = _vector2['default'].rot(_vector2['default'].normalize(normCurr), angle_delta); //  Rotate the extrusion normal

        if (numTriangles === 4 && (t === 0 || t === numTriangles - 2)) {
            var scale = 2 / (1 + Math.abs(_vector2['default'].dot(normPrev, normCurr)));
            normCurr = _vector2['default'].mult(normCurr, scale * scale);
        }

        uvCurr = _vector2['default'].add(uvCurr, uv_delta);

        addVertex(coord, normCurr, uvCurr, constants); //  Add computed corner
    }

    for (var i = 0; i < numTriangles; i++) {
        if (signed) {
            addIndex(i + 2, constants);
            addIndex(0, constants);
            addIndex(i + 1, constants);
        } else {
            addIndex(i + 1, constants);
            addIndex(0, constants);
            addIndex(i + 2, constants);
        }
    }

    // Clear the buffer
    constants.vertices = [];
    if (constants.scalingVecs) {
        constants.scalingVecs = [];
    }
    if (constants.texcoords) {
        constants.texcoords = [];
    }
}

//  Add special joins (not miter) types that require FAN tessellations
//  Using http://www.codeproject.com/Articles/226569/Drawing-polylines-by-tessellation as reference
function addJoin(coords, normals, v_pct, nTriangles, constants) {

    var T = [_vector2['default'].set(normals[0]), _vector2['default'].set(normals[1]), _vector2['default'].set(normals[2])];
    var signed = _vector2['default'].signed_area(coords[0], coords[1], coords[2]) > 0;

    var nA = T[0],
        // normal to point A (aT)
    nC = _vector2['default'].neg(T[1]),
        // normal to center (-vP)
    nB = T[2]; // normal to point B (bT)

    var uA = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v],
        uC = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v],
        uB = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];

    if (signed) {
        addVertex(coords[1], nA, uA, constants);
        addVertex(coords[1], nC, uC, constants);
    } else {
        nA = _vector2['default'].neg(T[0]);
        nC = T[1];
        nB = _vector2['default'].neg(T[2]);
        uA = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
        uC = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
        uB = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
        addVertex(coords[1], nC, uC, constants);
        addVertex(coords[1], nA, uA, constants);
    }

    addFan(coords[1], nA, nC, nB, uA, uC, uB, signed, nTriangles, constants);

    if (signed) {
        addVertex(coords[1], nB, uB, constants);
        addVertex(coords[1], nC, uC, constants);
    } else {
        addVertex(coords[1], nC, uC, constants);
        addVertex(coords[1], nB, uB, constants);
    }
}

//  Function to add the vertex need for line caps,
//  because re-use the buffers needs to be at the end
function addCap(coord, normal, numCorners, isBeginning, constants) {

    if (numCorners < 1) {
        return;
    }

    // UVs
    var uvA = [constants.min_u, constants.min_v],
        // Beginning angle UVs
    uvC = [constants.min_u + (constants.max_u - constants.min_u) / 2, constants.min_v],
        // center point UVs
    uvB = [constants.max_u, constants.min_v]; // Ending angle UVs

    if (!isBeginning) {
        uvA = [constants.min_u, constants.max_v], // Begining angle UVs
        uvC = [constants.min_u + (constants.max_u - constants.min_u) / 2, constants.max_v], // center point UVs
        uvB = [constants.max_u, constants.max_v];
    }

    addFan(coord, _vector2['default'].neg(normal), [0, 0], normal, uvA, uvC, uvB, isBeginning, numCorners * 2, constants);
}

// Add a vertex based on the index position into the VBO (internal method for polyline builder)
function addIndex(index, _ref8) {
    var vertex_data = _ref8.vertex_data;
    var vertex_template = _ref8.vertex_template;
    var halfWidth = _ref8.halfWidth;
    var vertices = _ref8.vertices;
    var scaling_index = _ref8.scaling_index;
    var scaling_normalize = _ref8.scaling_normalize;
    var scalingVecs = _ref8.scalingVecs;
    var texcoord_index = _ref8.texcoord_index;
    var texcoords = _ref8.texcoords;
    var texcoord_normalize = _ref8.texcoord_normalize;

    // Prevent access to undefined vertices
    if (index >= vertices.length) {
        return;
    }

    // set vertex position
    vertex_template[0] = vertices[index][0];
    vertex_template[1] = vertices[index][1];

    // set UVs
    if (texcoord_index) {
        vertex_template[texcoord_index + 0] = texcoords[index][0] * texcoord_normalize;
        vertex_template[texcoord_index + 1] = texcoords[index][1] * texcoord_normalize;
    }

    // set Scaling vertex (X, Y normal direction + Z halfwidth as attribute)
    if (scaling_index) {
        vertex_template[scaling_index + 0] = scalingVecs[index][0] * scaling_normalize;
        vertex_template[scaling_index + 1] = scalingVecs[index][1] * scaling_normalize;
        vertex_template[scaling_index + 2] = halfWidth;
    }

    //  Add vertex to VBO
    vertex_data.addVertex(vertex_template);
}

// Add the index vertex to the VBO and clean the buffers
function indexPairs(constants) {
    // Add vertices to buffer acording their index
    for (var i = 0; i < constants.nPairs; i++) {
        addIndex(2 * i + 2, constants);
        addIndex(2 * i + 1, constants);
        addIndex(2 * i + 0, constants);

        addIndex(2 * i + 2, constants);
        addIndex(2 * i + 3, constants);
        addIndex(2 * i + 1, constants);
    }

    constants.nPairs = 0;

    // Clean the buffer
    constants.vertices = [];
    if (constants.scalingVecs) {
        constants.scalingVecs = [];
    }
    if (constants.texcoords) {
        constants.texcoords = [];
    }
}

// Build a billboard sprite quad centered on a point. Sprites are intended to be drawn in screenspace, and have
// properties for width, height, angle, and a scale factor that can be used to interpolate the screenspace size
// of a sprite between two zoom levels.
Builders.buildQuadsForPoints = function (points, vertex_data, vertex_template, _ref9, _ref10) {
    var texcoord_index = _ref9.texcoord_index;
    var position_index = _ref9.position_index;
    var shape_index = _ref9.shape_index;
    var offset_index = _ref9.offset_index;
    var quad = _ref10.quad;
    var quad_scale = _ref10.quad_scale;
    var offset = _ref10.offset;
    var angle = _ref10.angle;
    var texcoord_scale = _ref10.texcoord_scale;
    var texcoord_normalize = _ref10.texcoord_normalize;

    var w2 = quad[0] / 2;
    var h2 = quad[1] / 2;
    var scaling = [[-w2, -h2], [w2, -h2], [w2, h2], [-w2, -h2], [w2, h2], [-w2, h2]];

    var texcoords = undefined;
    if (texcoord_index) {
        texcoord_normalize = texcoord_normalize || 1;

        var _ref11 = texcoord_scale || [[0, 0], [1, 1]];

        var _ref112 = _slicedToArray(_ref11, 2);

        var _ref112$0 = _slicedToArray(_ref112[0], 2);

        var min_u = _ref112$0[0];
        var min_v = _ref112$0[1];

        var _ref112$1 = _slicedToArray(_ref112[1], 2);

        var max_u = _ref112$1[0];
        var max_v = _ref112$1[1];

        texcoords = [[min_u, min_v], [max_u, min_v], [max_u, max_v], [min_u, min_v], [max_u, max_v], [min_u, max_v]];
    }

    var num_points = points.length;
    for (var p = 0; p < num_points; p++) {
        var point = points[p];

        for (var pos = 0; pos < 6; pos++) {
            // Add texcoords
            if (texcoord_index) {
                vertex_template[texcoord_index + 0] = texcoords[pos][0] * texcoord_normalize;
                vertex_template[texcoord_index + 1] = texcoords[pos][1] * texcoord_normalize;
            }

            vertex_template[position_index + 0] = point[0];
            vertex_template[position_index + 1] = point[1];

            vertex_template[shape_index + 0] = scaling[pos][0];
            vertex_template[shape_index + 1] = scaling[pos][1];
            vertex_template[shape_index + 2] = angle;
            vertex_template[shape_index + 3] = quad_scale;

            vertex_template[offset_index + 0] = offset[0];
            vertex_template[offset_index + 1] = offset[1];

            vertex_data.addVertex(vertex_template);
        }
    }
};

/* Utility functions */

// Triangulation using earcut
// https://github.com/mapbox/earcut
Builders.triangulatePolygon = function (contours) {
    return (0, _earcut2['default'])(contours);
};

// Tests if a line segment (from point A to B) is nearly coincident with the edge of a tile
Builders.isOnTileEdge = function (pa, pb, options) {
    options = options || {};

    var tolerance_function = options.tolerance_function || Builders.valuesWithinTolerance;
    var tolerance = options.tolerance || 1;
    var tile_min = Builders.tile_bounds[0];
    var tile_max = Builders.tile_bounds[1];
    var edge = null;

    if (tolerance_function(pa[0], tile_min.x, tolerance) && tolerance_function(pb[0], tile_min.x, tolerance)) {
        edge = 'left';
    } else if (tolerance_function(pa[0], tile_max.x, tolerance) && tolerance_function(pb[0], tile_max.x, tolerance)) {
        edge = 'right';
    } else if (tolerance_function(pa[1], tile_min.y, tolerance) && tolerance_function(pb[1], tile_min.y, tolerance)) {
        edge = 'top';
    } else if (tolerance_function(pa[1], tile_max.y, tolerance) && tolerance_function(pb[1], tile_max.y, tolerance)) {
        edge = 'bottom';
    }
    return edge;
};

Builders.valuesWithinTolerance = function (a, b, tolerance) {
    tolerance = tolerance || 1;
    return Math.abs(a - b) < tolerance;
};
module.exports = exports['default'];

},{"../geo":192,"../vector":244,"babel-runtime/helpers/interop-require-default":22,"babel-runtime/helpers/sliced-to-array":23,"earcut":139}],218:[function(_dereq_,module,exports){
// Line rendering style

'use strict';

var _Object$create = _dereq_('babel-runtime/core-js/object/create')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _style = _dereq_('../style');

var _style_parser = _dereq_('../style_parser');

var _style_manager = _dereq_('../style_manager');

var _glConstants = _dereq_('../../gl/constants');

var _glConstants2 = _interopRequireDefault(_glConstants);

// web workers don't have access to GL context, so import all GL constants

var _glVertex_layout = _dereq_('../../gl/vertex_layout');

var _glVertex_layout2 = _interopRequireDefault(_glVertex_layout);

var _builders = _dereq_('../builders');

var _builders2 = _interopRequireDefault(_builders);

var _geo = _dereq_('../../geo');

var _geo2 = _interopRequireDefault(_geo);

var _utilsUtils = _dereq_('../../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var Lines = _Object$create(_style.Style);

exports.Lines = Lines;
_Object$assign(Lines, {
    name: 'lines',
    built_in: true,
    vertex_shader_key: 'styles/polygons/polygons_vertex', // re-use polygon shaders
    fragment_shader_key: 'styles/polygons/polygons_fragment',
    selection: true, // turn feature selection on

    init: function init() {
        _style.Style.init.apply(this, arguments);

        // Basic attributes, others can be added (see texture UVs below)
        var attribs = [{ name: 'a_position', size: 4, type: _glConstants2['default'].SHORT, normalized: true }, { name: 'a_extrude', size: 4, type: _glConstants2['default'].SHORT, normalized: true }, { name: 'a_color', size: 4, type: _glConstants2['default'].UNSIGNED_BYTE, normalized: true }];

        // Tell the shader we want a order in vertex attributes, and to extrude lines
        this.defines.TANGRAM_LAYER_ORDER = true;
        this.defines.TANGRAM_EXTRUDE_LINES = true;

        // Optional feature selection
        if (this.selection) {
            attribs.push({ name: 'a_selection_color', size: 4, type: _glConstants2['default'].UNSIGNED_BYTE, normalized: true });
        }

        // Optional texture UVs
        if (this.texcoords) {
            this.defines.TANGRAM_TEXTURE_COORDS = true;

            // Add vertex attribute for UVs only when needed
            attribs.push({ name: 'a_texcoord', size: 2, type: _glConstants2['default'].UNSIGNED_SHORT, normalized: true });
        }

        this.vertex_layout = new _glVertex_layout2['default'](attribs);
    },

    // Calculate width at zoom given in `context`
    calcWidth: function calcWidth(width, context) {
        return width && _style_parser.StyleParser.cacheDistance(width, context) || 0;
    },

    // Calculate width at next zoom (used for line width interpolation)
    calcWidthNextZoom: function calcWidthNextZoom(width, context) {
        context.zoom++;
        var val = this.calcWidth(width, context);
        context.zoom--;
        return val;
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        var style = this.feature_style;

        // line width in meters
        var width = this.calcWidth(rule_style.width, context);
        if (width < 0) {
            return; // skip lines with negative width
        }
        var next_width = this.calcWidthNextZoom(rule_style.next_width, context);

        if (width === 0 && next_width === 0 || next_width < 0) {
            return; // skip lines that don't interpolate to a positive value at next zoom
        }

        // convert to units and relative change from previous zoom
        // NB: multiply by 2 because a given width is twice as big in screen space at the next zoom
        style.width = width * context.units_per_meter;
        style.next_width = next_width * 2 - width;
        style.next_width *= context.units_per_meter;
        style.next_width /= 2; // NB: divide by 2 because extrusion width is halved in builder - remove?

        style.color = this.parseColor(rule_style.color, context);
        if (!style.color) {
            return;
        }

        // height defaults to feature height, but extrude style can dynamically adjust height by returning a number or array (instead of a boolean)
        style.z = rule_style.z && _style_parser.StyleParser.cacheDistance(rule_style.z || 0, context) || _style_parser.StyleParser.defaults.z;
        style.height = feature.properties.height || _style_parser.StyleParser.defaults.height;
        style.extrude = rule_style.extrude;
        if (style.extrude) {
            if (typeof style.extrude === 'function') {
                style.extrude = style.extrude(context);
            }

            if (typeof style.extrude === 'number') {
                style.height = style.extrude;
            } else if (Array.isArray(style.extrude)) {
                style.height = style.extrude[1];
            }
        }

        // Raise line height if extruded
        if (style.extrude && style.height) {
            style.z += style.height;
        }

        style.cap = rule_style.cap;
        style.join = rule_style.join;
        style.tile_edges = rule_style.tile_edges; // usually activated for debugging, or rare visualization needs

        // Construct an outline style
        style.outline = style.outline || {};
        if (rule_style.outline && rule_style.outline.color && rule_style.outline.width) {
            // outline width in meters
            // NB: multiply by 2 because outline is applied on both sides of line
            var outline_width = this.calcWidth(rule_style.outline.width, context) * 2;
            var outline_next_width = this.calcWidthNextZoom(rule_style.outline.next_width, context) * 2;

            // Maintain consistent outline width around the line fill
            style.outline.width = { value: outline_width + width };
            style.outline.next_width = { value: outline_next_width + next_width };

            style.outline.color = rule_style.outline.color;
            style.outline.cap = rule_style.outline.cap || rule_style.cap;
            style.outline.join = rule_style.outline.join || rule_style.join;
            style.outline.style = rule_style.outline.style || this.name;

            // Explicitly defined outline order, or inherited from inner line
            if (rule_style.outline.order) {
                style.outline.order = this.parseOrder(rule_style.outline.order, context);
            } else {
                style.outline.order = style.order;
            }

            // Don't let outline be above inner line
            if (style.outline.order > style.order) {
                style.outline.order = style.order;
            }

            // Outlines are always at half-layer intervals to avoid conflicting with inner lines
            style.outline.order -= 0.5;

            style.outline.preprocessed = true; // signal that we've already wrapped properties in cache objects
        } else {
                style.outline.width = null;
                style.outline.color = null;
            }

        return style;
    },

    _preprocess: function _preprocess(draw) {
        draw.color = _style_parser.StyleParser.cacheObject(draw.color);
        draw.width = _style_parser.StyleParser.cacheObject(draw.width);
        draw.next_width = _style_parser.StyleParser.cacheObject(draw.width); // width will be computed for next zoom
        draw.z = _style_parser.StyleParser.cacheObject(draw.z);

        if (draw.outline) {
            draw.outline.color = _style_parser.StyleParser.cacheObject(draw.outline.color);
            draw.outline.width = _style_parser.StyleParser.cacheObject(draw.outline.width);
            draw.outline.next_width = _style_parser.StyleParser.cacheObject(draw.outline.width); // width re-computed for next zoom
        }
        return draw;
    },

    /**
     * A "template" that sets constant attibutes for each vertex, which is then modified per vertex or per feature.
     * A plain JS array matching the order of the vertex layout.
     */
    makeVertexTemplate: function makeVertexTemplate(style) {
        var i = 0;

        // position - x & y coords will be filled in per-vertex below
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = style.z || 0;

        // layer order - w coord of 'position' attribute (for packing efficiency)
        this.vertex_template[i++] = style.order;

        // extrusion vector
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;

        // scaling to previous and next zoom
        this.vertex_template[i++] = style.next_width;

        // color
        this.vertex_template[i++] = style.color[0] * 255;
        this.vertex_template[i++] = style.color[1] * 255;
        this.vertex_template[i++] = style.color[2] * 255;
        this.vertex_template[i++] = style.color[3] * 255;

        // selection color
        if (this.selection) {
            this.vertex_template[i++] = style.selection_color[0] * 255;
            this.vertex_template[i++] = style.selection_color[1] * 255;
            this.vertex_template[i++] = style.selection_color[2] * 255;
            this.vertex_template[i++] = style.selection_color[3] * 255;
        }

        // Add texture UVs to template only if needed
        if (this.texcoords) {
            this.vertex_template[i++] = 0;
            this.vertex_template[i++] = 0;
        }

        return this.vertex_template;
    },

    buildLines: function buildLines(lines, style, vertex_data, context, options) {
        var vertex_template = this.makeVertexTemplate(style);

        // Main line
        _builders2['default'].buildPolylines(lines, style.width, vertex_data, vertex_template, {
            cap: style.cap,
            join: style.join,
            scaling_index: this.vertex_layout.index.a_extrude,
            scaling_normalize: _utilsUtils2['default'].scaleInt16(1, 256), // scale extrusion normals to signed shorts w/256 unit basis
            texcoord_index: this.vertex_layout.index.a_texcoord,
            texcoord_scale: this.texcoord_scale,
            texcoord_normalize: 65535, // scale UVs to unsigned shorts
            closed_polygon: options && options.closed_polygon,
            remove_tile_edges: !style.tile_edges && options && options.remove_tile_edges,
            tile_edge_tolerance: _geo2['default'].tile_scale * context.tile.pad_scale * 4
        });

        // Outline
        if (style.outline && style.outline.color != null && style.outline.width != null) {
            var outline_style = _style_manager.StyleManager.styles[style.outline.style];
            if (outline_style) {
                outline_style.addFeature(context.feature, style.outline, context);
            }
        }
    },

    buildPolygons: function buildPolygons(polygons, style, vertex_data, context) {
        // Render polygons as individual lines
        for (var p = 0; p < polygons.length; p++) {
            this.buildLines(polygons[p], style, vertex_data, context, { closed_polygon: true, remove_tile_edges: true });
        }
    }

});

},{"../../geo":192,"../../gl/constants":193,"../../gl/vertex_layout":204,"../../utils/utils":241,"../builders":217,"../style":223,"../style_manager":224,"../style_parser":225,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/create":7,"babel-runtime/helpers/interop-require-default":22}],219:[function(_dereq_,module,exports){
// Sets of values to match for directional and corner anchors
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});
var lefts = ['left', 'top-left', 'bottom-left'];
var rights = ['right', 'top-right', 'bottom-right'];
var tops = ['top', 'top-left', 'top-right'];
var bottoms = ['bottom', 'bottom-left', 'bottom-right'];

var PointAnchor;

exports['default'] = PointAnchor = {

    computeOffset: function computeOffset(offset, size, anchor) {
        if (!anchor || anchor === 'center') {
            return offset;
        }

        var offset2 = [offset[0], offset[1]];

        // An optional left/right offset
        if (this.isLeftAnchor(anchor)) {
            offset2[0] -= size[0] / 2;
        } else if (this.isRightAnchor(anchor)) {
            offset2[0] += size[0] / 2;
        }

        // An optional top/bottom offset
        if (this.isTopAnchor(anchor)) {
            offset2[1] -= size[1] / 2;
        } else if (this.isBottomAnchor(anchor)) {
            offset2[1] += size[1] / 2;
        }

        return offset2;
    },

    isLeftAnchor: function isLeftAnchor(anchor) {
        return lefts.indexOf(anchor) > -1;
    },

    isRightAnchor: function isRightAnchor(anchor) {
        return rights.indexOf(anchor) > -1;
    },

    isTopAnchor: function isTopAnchor(anchor) {
        return tops.indexOf(anchor) > -1;
    },

    isBottomAnchor: function isBottomAnchor(anchor) {
        return bottoms.indexOf(anchor) > -1;
    }

};
module.exports = exports['default'];

},{}],220:[function(_dereq_,module,exports){
// Point rendering style

'use strict';

var _Object$create = _dereq_('babel-runtime/core-js/object/create')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _style = _dereq_('../style');

var _style_parser = _dereq_('../style_parser');

var _glConstants = _dereq_('../../gl/constants');

var _glConstants2 = _interopRequireDefault(_glConstants);

// web workers don't have access to GL context, so import all GL constants

var _glVertex_layout = _dereq_('../../gl/vertex_layout');

var _glVertex_layout2 = _interopRequireDefault(_glVertex_layout);

var _builders = _dereq_('../builders');

var _builders2 = _interopRequireDefault(_builders);

var _glTexture = _dereq_('../../gl/texture');

var _glTexture2 = _interopRequireDefault(_glTexture);

var _geo = _dereq_('../../geo');

var _geo2 = _interopRequireDefault(_geo);

var _utilsUtils = _dereq_('../../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _vector = _dereq_('../../vector');

var _vector2 = _interopRequireDefault(_vector);

var _point_anchor = _dereq_('./point_anchor');

var _point_anchor2 = _interopRequireDefault(_point_anchor);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var Points = _Object$create(_style.Style);

exports.Points = Points;
_Object$assign(Points, {
    name: 'points',
    built_in: true,
    selection: true, // turn feature selection on
    blend: 'overlay', // overlays drawn on top of all other styles, with blending

    init: function init() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        _style.Style.init.apply(this, arguments);

        // Base shaders
        this.vertex_shader_key = 'styles/points/points_vertex';
        this.fragment_shader_key = 'styles/points/points_fragment';

        var attribs = [{ name: 'a_position', size: 4, type: _glConstants2['default'].SHORT, normalized: true }, { name: 'a_shape', size: 4, type: _glConstants2['default'].SHORT, normalized: true }, { name: 'a_texcoord', size: 2, type: _glConstants2['default'].UNSIGNED_SHORT, normalized: true }, { name: 'a_offset', size: 2, type: _glConstants2['default'].SHORT, normalized: true }, { name: 'a_color', size: 4, type: _glConstants2['default'].UNSIGNED_BYTE, normalized: true }];

        // Optional feature selection
        if (this.selection) {
            attribs.push({ name: 'a_selection_color', size: 4, type: _glConstants2['default'].UNSIGNED_BYTE, normalized: true });
        }

        // If we're not rendering as overlay, we need a layer attribute
        if (this.blend !== 'overlay') {
            this.defines.TANGRAM_LAYER_ORDER = true;
        }

        this.vertex_layout = new _glVertex_layout2['default'](attribs);

        if (this.texture) {
            this.defines.TANGRAM_POINT_TEXTURE = true;
            this.shaders.uniforms = this.shaders.uniforms || {};
            this.shaders.uniforms.u_texture = this.texture;
        }
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        var style = this.feature_style;
        var tile = context.tile.key;

        style.color = this.parseColor(rule_style.color, context);

        // require color or texture
        if (!style.color && !this.texture) {
            return null;
        }

        var sprite = style.sprite = rule_style.sprite;
        if (typeof sprite === 'function') {
            sprite = sprite(context);
        }
        style.sprite_default = rule_style.sprite_default; // optional fallback if 'sprite' not found

        // if point has texture and sprites, require a valid sprite to draw
        if (this.texture && _glTexture2['default'].textures[this.texture] && _glTexture2['default'].textures[this.texture].sprites) {
            if (!sprite && !style.sprite_default) {
                return;
            } else if (!_glTexture2['default'].textures[this.texture].sprites[sprite]) {
                // If sprite not found, check for default sprite
                if (style.sprite_default) {
                    sprite = style.sprite_default;
                    if (!_glTexture2['default'].textures[this.texture].sprites[sprite]) {
                        _loglevel2['default'].warn('Style: in style \'' + this.name + '\', could not find default sprite \'' + sprite + '\' for texture \'' + this.texture + '\'');
                        return;
                    }
                } else {
                    _loglevel2['default'].warn('Style: in style \'' + this.name + '\', could not find sprite \'' + sprite + '\' for texture \'' + this.texture + '\'');
                    return;
                }
            }
        }

        // Sets texcoord scale if needed (e.g. for sprite sub-area)
        var sprite_info = undefined;
        if (this.texture && sprite) {
            sprite_info = _glTexture2['default'].getSpriteInfo(this.texture, sprite);
            this.texcoord_scale = sprite_info.texcoords;
        } else {
            this.texcoord_scale = null;
        }

        // points can be placed off the ground
        style.z = rule_style.z && _style_parser.StyleParser.cacheDistance(rule_style.z, context) || _style_parser.StyleParser.defaults.z;

        // point size defined explicitly, or defaults to sprite size, or generic fallback
        style.size = rule_style.size;
        if (!style.size) {
            if (sprite_info) {
                style.size = { value: sprite_info.size };
            } else {
                style.size = { value: [16, 16] };
            }
        }

        // point style only supports sizes in pixel units, so unit conversion flag is off
        style.size = _style_parser.StyleParser.cacheDistance(style.size, context, 'pixels');

        // scale size to 16-bit signed int, with a max allowed width + height of 128 pixels
        style.size = [Math.min(style.size[0] || style.size, 256), Math.min(style.size[1] || style.size, 256)];

        style.angle = rule_style.angle || 0;
        if (typeof style.angle === 'function') {
            style.angle = style.angle(context);
        }

        // factor by which point scales from current zoom level to next zoom level
        style.scale = rule_style.scale || 1;

        // to store bbox by tiles
        style.tile = tile;

        // polygons rendering as points will render each individual polygon point by default, but
        // rendering a single point at the polygon's centroid can be enabled
        style.centroid = rule_style.centroid;

        // Offset applied to point in screen space
        style.offset = Array.isArray(rule_style.offset) && rule_style.offset.map(parseFloat) || [0, 0];

        // anchor
        style.offset = _point_anchor2['default'].computeOffset(style.offset, style.size, rule_style.anchor);

        return style;
    },

    _preprocess: function _preprocess(draw) {
        draw.color = _style_parser.StyleParser.cacheObject(draw.color);
        draw.z = _style_parser.StyleParser.cacheObject(draw.z);
        draw.size = _style_parser.StyleParser.cacheObject(draw.size);
        return draw;
    },

    /**
     * A "template" that sets constant attibutes for each vertex, which is then modified per vertex or per feature.
     * A plain JS array matching the order of the vertex layout.
     */
    makeVertexTemplate: function makeVertexTemplate(style) {
        var color = style.color || _style_parser.StyleParser.defaults.color;

        // position - x & y coords will be filled in per-vertex below
        this.fillVertexTemplate('a_position', 0, { size: 2 });
        this.fillVertexTemplate('a_position', style.z || 0, { size: 1, offset: 2 });
        // layer order - w coord of 'position' attribute (for packing efficiency)
        this.fillVertexTemplate('a_position', style.order || 0, { size: 1, offset: 3 });

        // scaling vector - (x, y) components per pixel, z = angle, w = scaling factor
        this.fillVertexTemplate('a_shape', 0, { size: 4 });

        // texture coords
        this.fillVertexTemplate('a_texcoord', 0, { size: 2 });

        // offsets
        this.fillVertexTemplate('a_offset', 0, { size: 2 });

        // color
        this.fillVertexTemplate('a_color', _vector2['default'].mult(color, 255), { size: 4 });

        // selection color
        if (this.selection) {
            this.fillVertexTemplate('a_selection_color', _vector2['default'].mult(style.selection_color, 255), { size: 4 });
        }

        return this.vertex_template;
    },

    buildQuad: function buildQuad(points, size, angle, vertex_data, vertex_template, offset) {
        _builders2['default'].buildQuadsForPoints(points, vertex_data, vertex_template, {
            texcoord_index: this.vertex_layout.index.a_texcoord,
            position_index: this.vertex_layout.index.a_position,
            shape_index: this.vertex_layout.index.a_shape,
            offset_index: this.vertex_layout.index.a_offset
        }, {
            quad: [_utilsUtils2['default'].scaleInt16(size[0], 256), _utilsUtils2['default'].scaleInt16(size[1], 256)],
            quad_scale: _utilsUtils2['default'].scaleInt16(1, 256),
            offset: offset,
            angle: _utilsUtils2['default'].scaleInt16(angle, 360),
            texcoord_scale: this.texcoord_scale,
            texcoord_normalize: 65535
        });
    },

    buildPoints: function buildPoints(points, style, vertex_data) {
        if (!style.size) {
            return;
        }

        this.buildQuad(points, style.size, style.angle, vertex_data, this.makeVertexTemplate(style), style.offset);
    },

    buildPolygons: function buildPolygons(polygons, style, vertex_data) {
        // Render polygons as individual points, or centroid
        if (!style.centroid) {
            for (var poly = 0; poly < polygons.length; poly++) {
                var polygon = polygons[poly];
                for (var r = 0; r < polygon.length; r++) {
                    this.buildPoints(polygon[r], style, vertex_data);
                }
            }
        } else {
            var centroid = _geo2['default'].multiCentroid(polygons);
            this.buildPoints([centroid], style, vertex_data);
        }
    },

    buildLines: function buildLines(lines, style, vertex_data) {
        // Render lines as individual points
        for (var ln = 0; ln < lines.length; ln++) {
            this.buildPoints(lines[ln], style, vertex_data);
        }
    }

});

},{"../../geo":192,"../../gl/constants":193,"../../gl/texture":200,"../../gl/vertex_layout":204,"../../utils/utils":241,"../../vector":244,"../builders":217,"../style":223,"../style_parser":225,"./point_anchor":219,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/create":7,"babel-runtime/helpers/interop-require-default":22,"loglevel":179}],221:[function(_dereq_,module,exports){
// Polygon rendering style

'use strict';

var _Object$create = _dereq_('babel-runtime/core-js/object/create')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _style = _dereq_('../style');

var _style_parser = _dereq_('../style_parser');

var _glConstants = _dereq_('../../gl/constants');

var _glConstants2 = _interopRequireDefault(_glConstants);

// web workers don't have access to GL context, so import all GL constants

var _glVertex_layout = _dereq_('../../gl/vertex_layout');

var _glVertex_layout2 = _interopRequireDefault(_glVertex_layout);

var _builders = _dereq_('../builders');

var _builders2 = _interopRequireDefault(_builders);

var _geo = _dereq_('../../geo');

var _geo2 = _interopRequireDefault(_geo);

var Polygons = _Object$create(_style.Style);

exports.Polygons = Polygons;
_Object$assign(Polygons, {
    name: 'polygons',
    built_in: true,
    vertex_shader_key: 'styles/polygons/polygons_vertex',
    fragment_shader_key: 'styles/polygons/polygons_fragment',
    selection: true, // turn feature selection on

    init: function init() {
        _style.Style.init.apply(this, arguments);

        // Basic attributes, others can be added (see texture UVs below)
        var attribs = [{ name: 'a_position', size: 4, type: _glConstants2['default'].SHORT, normalized: true }, { name: 'a_normal', size: 3, type: _glConstants2['default'].BYTE, normalized: true }, // gets padded to 4-bytes
        { name: 'a_color', size: 4, type: _glConstants2['default'].UNSIGNED_BYTE, normalized: true }];

        // Tell the shader we have a normal and order attributes
        this.defines.TANGRAM_NORMAL_ATTRIBUTE = true;
        this.defines.TANGRAM_LAYER_ORDER = true;

        // Optional feature selection
        if (this.selection) {
            attribs.push({ name: 'a_selection_color', size: 4, type: _glConstants2['default'].UNSIGNED_BYTE, normalized: true });
        }

        // Optional texture UVs
        if (this.texcoords) {
            this.defines.TANGRAM_TEXTURE_COORDS = true;

            // Add vertex attribute for UVs only when needed
            attribs.push({ name: 'a_texcoord', size: 2, type: _glConstants2['default'].UNSIGNED_SHORT, normalized: true });
        }

        this.vertex_layout = new _glVertex_layout2['default'](attribs);
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        var style = this.feature_style;

        style.color = this.parseColor(rule_style.color, context);
        if (!style.color) {
            return null;
        }

        // height defaults to feature height, but extrude style can dynamically adjust height by returning a number or array (instead of a boolean)
        style.z = rule_style.z && _style_parser.StyleParser.cacheDistance(rule_style.z, context) || _style_parser.StyleParser.defaults.z;
        style.height = feature.properties.height || _style_parser.StyleParser.defaults.height;
        style.min_height = feature.properties.min_height || _style_parser.StyleParser.defaults.min_height;
        style.extrude = rule_style.extrude;
        if (style.extrude) {
            if (typeof style.extrude === 'function') {
                style.extrude = style.extrude(context);
            }

            if (typeof style.extrude === 'number') {
                style.height = style.extrude;
            } else if (Array.isArray(style.extrude)) {
                style.min_height = style.extrude[0];
                style.height = style.extrude[1];
            }
        }

        style.tile_edges = rule_style.tile_edges; // usually activated for debugging, or rare visualization needs

        // style.outline = style.outline || {};
        // if (rule_style.outline) {
        //     style.outline.color = StyleParser.parseColor(rule_style.outline.color, context);
        //     style.outline.width = StyleParser.parseDistance(rule_style.outline.width, context);
        //     style.outline.tile_edges = rule_style.outline.tile_edges;
        //     style.outline.cap = rule_style.outline.cap || rule_style.cap;
        //     style.outline.join = rule_style.outline.join || rule_style.join;
        // }
        // else {
        //     style.outline.color = null;
        //     style.outline.width = null;
        //     style.outline.tile_edges = false;
        // }

        return style;
    },

    _preprocess: function _preprocess(draw) {
        draw.color = _style_parser.StyleParser.cacheObject(draw.color);
        draw.z = _style_parser.StyleParser.cacheObject(draw.z);
        return draw;
    },

    /**
     * A "template" that sets constant attibutes for each vertex, which is then modified per vertex or per feature.
     * A plain JS array matching the order of the vertex layout.
     */
    makeVertexTemplate: function makeVertexTemplate(style) {
        var i = 0;

        // position - x & y coords will be filled in per-vertex below
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = style.z || 0;

        // layer order - w coord of 'position' attribute (for packing efficiency)
        this.vertex_template[i++] = style.order;

        // normal
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 1 * 127;

        // color
        this.vertex_template[i++] = style.color[0] * 255;
        this.vertex_template[i++] = style.color[1] * 255;
        this.vertex_template[i++] = style.color[2] * 255;
        this.vertex_template[i++] = style.color[3] * 255;

        // selection color
        if (this.selection) {
            this.vertex_template[i++] = style.selection_color[0] * 255;
            this.vertex_template[i++] = style.selection_color[1] * 255;
            this.vertex_template[i++] = style.selection_color[2] * 255;
            this.vertex_template[i++] = style.selection_color[3] * 255;
        }

        // Add texture UVs to template only if needed
        if (this.texcoords) {
            this.vertex_template[i++] = 0;
            this.vertex_template[i++] = 0;
        }

        return this.vertex_template;
    },

    buildPolygons: function buildPolygons(polygons, style, vertex_data, context) {
        var vertex_template = this.makeVertexTemplate(style);
        var options = {
            texcoord_index: this.vertex_layout.index.a_texcoord,
            texcoord_scale: this.texcoord_scale,
            texcoord_normalize: 65535, // scale UVs to unsigned shorts
            remove_tile_edges: !style.tile_edges,
            tile_edge_tolerance: _geo2['default'].tile_scale * context.tile.pad_scale * 4
        };

        // Extruded polygons (e.g. 3D buildings)
        if (style.extrude && style.height) {
            _builders2['default'].buildExtrudedPolygons(polygons, style.z, style.height, style.min_height, vertex_data, vertex_template, this.vertex_layout.index.a_normal, 127, // scale normals to signed bytes
            options);
        }
        // Regular polygons
        else {
                _builders2['default'].buildPolygons(polygons, vertex_data, vertex_template, options);
            }
    }

});

},{"../../geo":192,"../../gl/constants":193,"../../gl/vertex_layout":204,"../builders":217,"../style":223,"../style_parser":225,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/create":7,"babel-runtime/helpers/interop-require-default":22}],222:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.mergeTrees = mergeTrees;
exports.walkUp = walkUp;
exports.walkDown = walkDown;
exports.groupProps = groupProps;
exports.calculateDraw = calculateDraw;
exports.parseRuleTree = parseRuleTree;
exports.parseRules = parseRules;
exports.matchFeature = matchFeature;

var _style_manager = _dereq_('./style_manager');

var _utilsMerge = _dereq_('../utils/merge');

var _utilsMerge2 = _interopRequireDefault(_utilsMerge);

var _matchFeature = _dereq_('match-feature');

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var whiteList = ['filter', 'draw', 'visible', 'data', 'properties'];

exports.whiteList = whiteList;
var ruleCache = {};

exports.ruleCache = ruleCache;
function cacheKey(rules) {
    rules = rules.sort(function (a, b) {
        return a - b;
    });
    var k = rules[0].id;
    for (var i = 1; i < rules.length; i++) {
        k += '/' + rules[i].id;
    }
    return k;
}

// Merge matching layer rule trees into a final draw group

function mergeTrees(matchingTrees, group) {
    var draws = undefined,
        treeDepth = 0;

    var draw = {
        visible: true // visible by default
    };

    // Find deepest tree
    for (var t = 0; t < matchingTrees.length; t++) {
        if (matchingTrees[t].length > treeDepth) {
            treeDepth = matchingTrees[t].length;
        }
    }

    // No rules to parse
    if (treeDepth === 0) {
        return null;
    }

    // Iterate trees in parallel

    var _loop = function (x) {
        // Pull out the requested draw group, for each tree, at this depth
        draws = matchingTrees.map(function (tree) {
            return tree[x] && tree[x][group];
        });
        if (draws.length === 0) {
            return 'continue';
        }

        // Sort by layer name before merging, so rules are applied deterministically
        // when multiple rules modify the same properties
        draws.sort(function (a, b) {
            return (a && a.layer_name) > (b && b.layer_name) ? 1 : -1;
        });

        // Merge draw objects
        _utilsMerge2['default'].apply(undefined, [draw].concat(_toConsumableArray(draws)));

        // Remove layer names, they were only used transiently to sort and calculate final layer
        // (final merged names will not be accurate since only one tree can win)
        delete draw.layer_name;
    };

    for (var x = 0; x < treeDepth; x++) {
        var _ret = _loop(x);

        if (_ret === 'continue') continue;
    }

    // Short-circuit if not visible
    if (draw.visible === false) {
        return null;
    }

    return draw;
}

var Rule = (function () {
    function Rule(_ref) {
        var name = _ref.name;
        var parent = _ref.parent;
        var draw = _ref.draw;
        var visible = _ref.visible;
        var filter = _ref.filter;
        var properties = _ref.properties;

        _classCallCheck(this, Rule);

        this.id = Rule.id++;
        this.parent = parent;
        this.name = name;
        this.full_name = this.parent ? this.parent.full_name + ':' + this.name : this.name;
        this.draw = draw;
        this.filter = filter;
        this.visible = visible !== undefined ? visible : this.parent && this.parent.visible;
        this.properties = properties !== undefined ? properties : this.parent && this.parent.properties;

        // Denormalize layer name & properties to draw groups
        if (this.draw) {
            for (var group in this.draw) {
                this.draw[group].layer_name = this.full_name;

                if (this.properties !== undefined) {
                    this.draw[group].properties = this.properties;
                }
            }
        }

        this.buildFilter();
        this.buildDraw();
    }

    _createClass(Rule, [{
        key: 'buildDraw',
        value: function buildDraw() {
            this.calculatedDraw = calculateDraw(this);
        }
    }, {
        key: 'buildFilter',
        value: function buildFilter() {
            try {
                var type = typeof this.filter;
                if (type === 'object') {
                    this.filter = (0, _matchFeature.match)(this.filter);
                }
            } catch (e) {
                debugger;
            }
        }
    }, {
        key: 'toJSON',
        value: function toJSON() {
            return {
                name: this.name,
                draw: this.draw
            };
        }
    }]);

    return Rule;
})();

Rule.id = 0;

var RuleLeaf = (function (_Rule) {
    _inherits(RuleLeaf, _Rule);

    function RuleLeaf(_ref2) {
        var name = _ref2.name;
        var parent = _ref2.parent;
        var draw = _ref2.draw;
        var visible = _ref2.visible;
        var filter = _ref2.filter;
        var properties = _ref2.properties;

        _classCallCheck(this, RuleLeaf);

        _get(Object.getPrototypeOf(RuleLeaf.prototype), 'constructor', this).call(this, { name: name, parent: parent, draw: draw, visible: visible, filter: filter, properties: properties });
    }

    return RuleLeaf;
})(Rule);

exports.RuleLeaf = RuleLeaf;

var RuleTree = (function (_Rule2) {
    _inherits(RuleTree, _Rule2);

    function RuleTree(_ref3) {
        var name = _ref3.name;
        var parent = _ref3.parent;
        var draw = _ref3.draw;
        var visible = _ref3.visible;
        var rules = _ref3.rules;
        var filter = _ref3.filter;
        var properties = _ref3.properties;

        _classCallCheck(this, RuleTree);

        _get(Object.getPrototypeOf(RuleTree.prototype), 'constructor', this).call(this, { name: name, parent: parent, draw: draw, visible: visible, filter: filter, properties: properties });
        this.rules = rules || [];
    }

    _createClass(RuleTree, [{
        key: 'addRule',
        value: function addRule(rule) {
            this.rules.push(rule);
        }
    }, {
        key: 'buildDrawGroups',
        value: function buildDrawGroups(context) {
            var rules = [];
            //TODO, should this function take a RuleTree
            matchFeature(context, [this], rules);

            if (rules.length > 0) {
                var cache_key = cacheKey(rules);

                // Only evaluate each rule combination once (undefined means not yet evaluated,
                // null means evaluated with no draw object)
                if (ruleCache[cache_key] === undefined) {
                    // Visible?
                    if (rules.some(function (x) {
                        return x.visible === false;
                    })) {
                        ruleCache[cache_key] = null;
                    } else {
                        // Find all the unique draw blocks for this rule tree
                        var draw_rules = rules.map(function (x) {
                            return x && x.calculatedDraw;
                        });
                        var draw_keys = {};

                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = _getIterator(draw_rules), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var rule = _step.value;

                                if (!rule) {
                                    continue;
                                }
                                var _iteratorNormalCompletion2 = true;
                                var _didIteratorError2 = false;
                                var _iteratorError2 = undefined;

                                try {
                                    for (var _iterator2 = _getIterator(rule), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                        var group = _step2.value;

                                        for (var key in group) {
                                            draw_keys[key] = true;
                                        }
                                    }
                                } catch (err) {
                                    _didIteratorError2 = true;
                                    _iteratorError2 = err;
                                } finally {
                                    try {
                                        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                                            _iterator2['return']();
                                        }
                                    } finally {
                                        if (_didIteratorError2) {
                                            throw _iteratorError2;
                                        }
                                    }
                                }
                            }

                            // Calculate each draw group
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator['return']) {
                                    _iterator['return']();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        for (var draw_key in draw_keys) {
                            ruleCache[cache_key] = ruleCache[cache_key] || {};
                            ruleCache[cache_key][draw_key] = mergeTrees(draw_rules, draw_key);

                            // Only save the ones that weren't null
                            if (!ruleCache[cache_key][draw_key]) {
                                delete ruleCache[cache_key][draw_key];
                            } else {
                                ruleCache[cache_key][draw_key].key = cache_key + '/' + draw_key;
                                ruleCache[cache_key][draw_key].layers = rules.map(function (x) {
                                    return x && x.full_name;
                                });
                            }
                        }

                        // No rules evaluated
                        if (ruleCache[cache_key] && _Object$keys(ruleCache[cache_key]).length === 0) {
                            ruleCache[cache_key] = null;
                        }
                    }
                }
                return ruleCache[cache_key];
            }
        }
    }]);

    return RuleTree;
})(Rule);

exports.RuleTree = RuleTree;

function isWhiteListed(key) {
    return whiteList.indexOf(key) > -1;
}

function isEmpty(obj) {
    return _Object$keys(obj).length === 0;
}

function walkUp(rule, cb) {

    if (rule.parent) {
        walkUp(rule.parent, cb);
    }

    cb(rule);
}

function walkDown(rule, cb) {

    if (rule.rules) {
        rule.rules.forEach(function (r) {
            walkDown(r, cb);
        });
    }

    cb(rule);
}

function groupProps(obj) {
    var whiteListed = {},
        nonWhiteListed = {};

    for (var key in obj) {
        if (isWhiteListed(key)) {
            whiteListed[key] = obj[key];
        } else {
            nonWhiteListed[key] = obj[key];
        }
    }
    return [whiteListed, nonWhiteListed];
}

function calculateDraw(rule) {

    var draw = [];

    if (rule.parent) {
        var cs = rule.parent.calculatedDraw || [];
        draw.push.apply(draw, _toConsumableArray(cs));
    }

    draw.push(rule.draw);
    return draw;
}

function parseRuleTree(name, rule, parent) {

    var properties = { name: name, parent: parent };

    var _groupProps = groupProps(rule);

    var _groupProps2 = _slicedToArray(_groupProps, 2);

    var whiteListed = _groupProps2[0];
    var nonWhiteListed = _groupProps2[1];

    var empty = isEmpty(nonWhiteListed);
    var Create = undefined;

    if (empty && parent != null) {
        Create = RuleLeaf;
    } else {
        Create = RuleTree;
    }

    var r = new Create(_Object$assign(properties, whiteListed));

    if (parent) {
        parent.addRule(r);
    }

    if (!empty) {
        for (var key in nonWhiteListed) {
            var property = nonWhiteListed[key];
            if (typeof property === 'object' && !Array.isArray(property)) {
                parseRuleTree(key, property, r);
            } else {
                // Invalid layer
                var msg = 'Layer value must be an object: can\'t create layer \'' + key + ': ' + JSON.stringify(property) + '\'';
                msg += ', under parent layer \'' + r.full_name + '\'.';

                // If the parent is a style name, this may be an incorrectly nested layer
                if (_style_manager.Styles[r.name]) {
                    msg += ' The parent \'' + r.name + '\' is also the name of a style, did you mean to create a \'draw\' group';
                    if (parent) {
                        msg += ' under \'' + parent.name + '\'';
                    }
                    msg += ' instead?';
                }
                _loglevel2['default'].warn(msg);
            }
        }
    }

    return r;
}

function parseRules(rules) {
    var ruleTrees = {};

    for (var key in rules) {
        var rule = rules[key];
        if (rule) {
            ruleTrees[key] = parseRuleTree(key, rule);
        }
    }

    return ruleTrees;
}

function doesMatch(filter, context) {
    return typeof filter === 'function' && filter(context) || filter == null;
}

function matchFeature(context, rules, collectedRules) {
    var matched = false;
    var childMatched = false;

    if (rules.length === 0) {
        return;
    }

    for (var r = 0; r < rules.length; r++) {
        var current = rules[r];
        context.properties = current.properties;

        if (current instanceof RuleLeaf) {

            if (doesMatch(current.filter, context)) {
                matched = true;
                collectedRules.push(current);
            }
        } else if (current instanceof RuleTree) {
            if (doesMatch(current.filter, context)) {
                matched = true;

                childMatched = matchFeature(context, current.rules, collectedRules);

                if (!childMatched) {
                    collectedRules.push(current);
                }
            }
        }

        context.properties = null;
    }

    return matched;
}

},{"../utils/merge":238,"./style_manager":224,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/keys":11,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/get":20,"babel-runtime/helpers/inherits":21,"babel-runtime/helpers/interop-require-default":22,"babel-runtime/helpers/sliced-to-array":23,"babel-runtime/helpers/to-consumable-array":24,"loglevel":179,"match-feature":180}],223:[function(_dereq_,module,exports){
// Rendering styles

'use strict';

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _style_parser = _dereq_('./style_parser');

var _selection = _dereq_('../selection');

var _selection2 = _interopRequireDefault(_selection);

var _glShader_program = _dereq_('../gl/shader_program');

var _glShader_program2 = _interopRequireDefault(_glShader_program);

var _glVbo_mesh = _dereq_('../gl/vbo_mesh');

var _glVbo_mesh2 = _interopRequireDefault(_glVbo_mesh);

var _material = _dereq_('../material');

var _material2 = _interopRequireDefault(_material);

var _light = _dereq_('../light');

var _light2 = _interopRequireDefault(_light);

var _utilsErrors = _dereq_('../utils/errors');

var _glShader_sources = _dereq_('../gl/shader_sources');

var _glShader_sources2 = _interopRequireDefault(_glShader_sources);

// built-in shaders

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

// Base class

var Style = {
    init: function init() {
        var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        var generation = _ref.generation;

        if (!this.isBuiltIn()) {
            this.built_in = false; // explicitly set to false to avoid any confusion
        }

        this.generation = generation; // scene generation id this style was created for
        this.defines = this.hasOwnProperty('defines') && this.defines || {}; // #defines to be injected into the shaders
        this.shaders = this.hasOwnProperty('shaders') && this.shaders || {}; // shader customization (uniforms, defines, blocks, etc.)
        this.selection = this.selection || false; // flag indicating if this style supports feature selection
        this.compiling = false; // programs are currently compiling
        this.compiled = false; // programs are finished compiling
        this.program = null; // GL program reference (for main render pass)
        this.selection_program = null; // GL program reference for feature selection render pass
        this.feature_style = {}; // style for feature currently being parsed, shared to lessen GC/memory thrash
        this.vertex_template = []; // shared single-vertex template, filled out by each style
        this.tile_data = {};
        this.feature_options = {};

        // Default world coords to wrap every 100,000 meters, can turn off by setting this to 'false'
        this.defines.TANGRAM_WORLD_POSITION_WRAP = 100000;

        // Blending
        this.blend = this.blend || 'opaque'; // default: opaque styles are drawn first, without blending
        this.defines['TANGRAM_BLEND_' + this.blend.toUpperCase()] = true;
        if (this.blend_order == null) {
            // controls order of rendering for styles w/non-opaque blending
            this.blend_order = -1; // defaults to first
        }

        // If the style defines its own material, replace the inherited material instance
        if (!(this.material instanceof _material2['default'])) {
            if (!_material2['default'].isValid(this.material)) {
                this.material = _style_parser.StyleParser.defaults.material;
            }
            this.material = new _material2['default'](this.material);
        }
        this.material.inject(this);

        // Set lighting mode: fragment, vertex, or none (specified as 'false')
        _light2['default'].setMode(this.lighting, this);

        this.initialized = true;
    },

    destroy: function destroy() {
        if (this.program) {
            this.program.destroy();
            this.program = null;
        }

        if (this.selection_program) {
            this.selection_program.destroy();
            this.selection_program = null;
        }

        this.gl = null;
        this.initialized = false;
    },

    reset: function reset() {},

    isBuiltIn: function isBuiltIn() {
        return this.hasOwnProperty('built_in') && this.built_in;
    },

    fillVertexTemplate: function fillVertexTemplate(attribute, value, _ref2) {
        var size = _ref2.size;
        var offset = _ref2.offset;

        offset = offset === undefined ? 0 : offset;

        var index = this.vertex_layout.index[attribute];
        if (index === undefined) {
            _loglevel2['default'].warn('Style: in style \'' + this.name + '\', no index found in vertex layout for attribute \'' + attribute + '\'');
            return;
        }

        for (var i = 0; i < size; ++i) {
            var v = value.length > i ? value[i] : value;
            this.vertex_template[index + i + offset] = v;
        }
    },

    /*** Style parsing and geometry construction ***/

    // Returns an object to hold feature data (for a tile or other object)
    startData: function startData(tile) {
        this.tile_data[tile] = {
            vertex_data: null,
            uniforms: null
        };
        return this.tile_data[tile];
    },

    // Finalizes an object holding feature data (for a tile or other object)
    endData: function endData(tile) {
        var tile_data = this.tile_data[tile];
        if (tile_data && tile_data.vertex_data) {
            // Only keep final byte buffer
            tile_data.vertex_data.end();
            tile_data.vertex_data = tile_data.vertex_data.buffer;
        }
        this.tile_data[tile] = null;
        return _Promise.resolve(tile_data);
    },

    // Has mesh data for a given tile?
    hasDataForTile: function hasDataForTile(tile) {
        return this.tile_data[tile] != null;
    },

    addFeature: function addFeature(feature, rule, context) {
        var tile = context.tile;
        if (tile.generation !== this.generation) {
            return;
        }

        if (!this.tile_data[tile.key]) {
            this.startData(tile.key);
        }

        var style = this.parseFeature.apply(this, arguments); // allow subclasses to pass extra args

        // Skip feature?
        if (!style) {
            return;
        }

        // First feature in this render style?
        if (!this.tile_data[tile.key].vertex_data) {
            this.tile_data[tile.key].vertex_data = this.vertex_layout.createVertexData();
        }

        this.buildGeometry(feature.geometry, style, this.tile_data[tile.key].vertex_data, context);
    },

    buildGeometry: function buildGeometry(geometry, style, vertex_data, context) {
        if (geometry.type === 'Polygon') {
            this.buildPolygons([geometry.coordinates], style, vertex_data, context);
        } else if (geometry.type === 'MultiPolygon') {
            this.buildPolygons(geometry.coordinates, style, vertex_data, context);
        } else if (geometry.type === 'LineString') {
            this.buildLines([geometry.coordinates], style, vertex_data, context);
        } else if (geometry.type === 'MultiLineString') {
            this.buildLines(geometry.coordinates, style, vertex_data, context);
        } else if (geometry.type === 'Point') {
            this.buildPoints([geometry.coordinates], style, vertex_data, context);
        } else if (geometry.type === 'MultiPoint') {
            this.buildPoints(geometry.coordinates, style, vertex_data, context);
        }
    },

    parseFeature: function parseFeature(feature, rule_style, context) {
        try {
            var style = this.feature_style;

            rule_style = this.preprocess(rule_style);
            if (!rule_style) {
                return;
            }

            // Calculate order if it was not cached
            style.order = this.parseOrder(rule_style.order, context);

            // Feature selection (only if style supports it)
            var selectable = false;
            style.interactive = rule_style.interactive;
            if (this.selection) {
                if (typeof style.interactive === 'function') {
                    selectable = style.interactive(context);
                } else {
                    selectable = style.interactive;
                }
            }

            // If feature is marked as selectable
            if (selectable) {
                style.selection_color = _selection2['default'].makeColor(feature, context.tile);
            } else {
                style.selection_color = _selection2['default'].defaultColor;
            }

            // Subclass implementation
            style = this._parseFeature.apply(this, arguments); // allow subclasses to pass extra args

            return style;
        } catch (error) {
            _loglevel2['default'].error('Style.parseFeature: style parsing error', feature, style, error);
        }
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        throw new _utilsErrors.MethodNotImplemented('_parseFeature');
    },

    preprocess: function preprocess(rule_style) {
        // Preprocess first time
        if (!rule_style.preprocessed) {
            rule_style = this._preprocess(rule_style); // optional subclass implementation
            if (!rule_style) {
                return;
            }
            rule_style.preprocessed = true;
        }
        return rule_style;
    },

    // optionally implemented by subclass
    _preprocess: function _preprocess(rule_style) {
        return rule_style;
    },

    // Parse an order value
    parseOrder: function parseOrder(order, context) {
        // Calculate order if it was not cached
        if (typeof order !== 'number') {
            return _style_parser.StyleParser.calculateOrder(order, context);
        }
        return order;
    },

    // Parse a color of choose a default if acceptable, return undefined if color missing
    parseColor: function parseColor(color, context) {
        // Need either a color, or a shader block for 'color' or 'filter'
        if (color) {
            return _style_parser.StyleParser.cacheColor(color, context);
        } else if (this.shaders.blocks.color || this.shaders.blocks.filter) {
            return _style_parser.StyleParser.defaults.color;
        }
    },

    // Build functions are no-ops until overriden
    buildPolygons: function buildPolygons() {},
    buildLines: function buildLines() {},
    buildPoints: function buildPoints() {},

    /*** GL state and rendering ***/

    setGL: function setGL(gl) {
        this.gl = gl;
    },

    makeMesh: function makeMesh(vertex_data) {
        var _ref3 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        var uniforms = _ref3.uniforms;

        return new _glVbo_mesh2['default'](this.gl, vertex_data, this.vertex_layout, { uniforms: uniforms });
    },

    compile: function compile() {
        if (!this.gl) {
            throw new Error('style.compile(): skipping for ' + this.name + ' because no GL context');
        }

        if (this.compiling) {
            throw new Error('style.compile(): skipping for ' + this.name + ' because style is already compiling');
        }
        this.compiling = true;
        this.compiled = false;

        // Build defines & for selection (need to create a new object since the first is stored as a reference by the program)
        var defines = this.buildDefineList();
        if (this.selection) {
            var selection_defines = _Object$assign({}, defines);
            selection_defines.TANGRAM_FEATURE_SELECTION = true;
        }

        // Get any custom code blocks, uniform dependencies, etc.
        var blocks = this.shaders && this.shaders.blocks;
        var block_scopes = this.shaders && this.shaders.block_scopes;
        var uniforms = this.shaders && this.shaders.uniforms;

        // accept a single extension, or an array of extensions
        var extensions = this.shaders && this.shaders.extensions;
        if (typeof extensions === 'string') {
            extensions = [extensions];
        }

        // Create shaders
        try {
            this.program = new _glShader_program2['default'](this.gl, _glShader_sources2['default'][this.vertex_shader_key], _glShader_sources2['default'][this.fragment_shader_key], {
                name: this.name,
                defines: defines,
                uniforms: uniforms,
                blocks: blocks,
                block_scopes: block_scopes,
                extensions: extensions
            });
            this.program.compile();

            if (this.selection) {
                this.selection_program = new _glShader_program2['default'](this.gl, _glShader_sources2['default'][this.vertex_shader_key], _glShader_sources2['default']['gl/shaders/selection_fragment'], {
                    name: this.name + ' (selection)',
                    defines: selection_defines,
                    uniforms: uniforms,
                    blocks: blocks,
                    block_scopes: block_scopes,
                    extensions: extensions
                });
                this.selection_program.compile();
            } else {
                this.selection_program = null;
            }
        } catch (error) {
            this.compiling = false;
            this.compiled = false;
            throw new Error('style.compile(): style ' + this.name + ' error:', error);
        }

        this.compiling = false;
        this.compiled = true;
    },

    // Add a shader block
    addShaderBlock: function addShaderBlock(key, block) {
        var scope = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

        this.shaders.blocks = this.shaders.blocks || {};
        this.shaders.blocks[key] = this.shaders.blocks[key] || [];
        this.shaders.blocks[key].push(block);

        this.shaders.block_scopes = this.shaders.block_scopes || {};
        this.shaders.block_scopes[key] = this.shaders.block_scopes[key] || [];
        this.shaders.block_scopes[key].push(scope);
    },

    // Remove all shader blocks for key
    removeShaderBlock: function removeShaderBlock(key) {
        if (this.shaders.blocks) {
            this.shaders.blocks[key] = null;
        }
    },

    replaceShaderBlock: function replaceShaderBlock(key, block) {
        var scope = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

        this.removeShaderBlock(key);
        this.addShaderBlock(key, block, scope);
    },

    /** TODO: could probably combine and generalize this with similar method in ShaderProgram
     * (list of define objects that inherit from each other)
     */
    buildDefineList: function buildDefineList() {
        // Add any custom defines to built-in style defines
        var defines = {}; // create a new object to avoid mutating a prototype value that may be shared with other styles
        if (this.defines != null) {
            for (var d in this.defines) {
                defines[d] = this.defines[d];
            }
        }
        if (this.shaders != null && this.shaders.defines != null) {
            for (d in this.shaders.defines) {
                defines[d] = this.shaders.defines[d];
            }
        }
        return defines;
    },

    // Setup any GL state for rendering
    setup: function setup() {
        this.setUniforms();
        this.material.setupProgram(_glShader_program2['default'].current);
    },

    // Set style uniforms on currently bound program
    setUniforms: function setUniforms() {
        var program = _glShader_program2['default'].current;
        if (!program) {
            return;
        }

        program.setUniforms(this.shaders && this.shaders.uniforms, true); // reset texture unit to 0
    },

    // Render state settings by blend mode
    render_states: {
        opaque: { depth_test: true, depth_write: true },
        add: { depth_test: true, depth_write: false },
        multiply: { depth_test: true, depth_write: false },
        inlay: { depth_test: true, depth_write: false },
        overlay: { depth_test: false, depth_write: false }
    },

    // Default sort order for blend modes
    default_blend_orders: {
        opaque: 0,
        add: 1,
        multiply: 2,
        inlay: 3,
        overlay: 4
    },

    // Comparison function for sorting styles by blend
    blendOrderSort: function blendOrderSort(a, b) {
        // opaque always comes first
        if (a.blend === 'opaque' || b.blend === 'opaque') {
            if (a.blend === 'opaque' && b.blend === 'opaque') {
                // if both are opaque
                return a.name < b.name ? -1 : 1; // use name as tie breaker
            } else if (a.blend === 'opaque') {
                    return -1; // only `a` was opaque
                } else {
                        return 1; // only `b` was opaque
                    }
        }

        // use explicit blend order if possible
        if (a.blend_order < b.blend_order) {
            return -1;
        } else if (a.blend_order > b.blend_order) {
            return 1;
        }

        // if blend orders are equal, use default order by blend mode
        if (Style.default_blend_orders[a.blend] < Style.default_blend_orders[b.blend]) {
            return -1;
        } else if (Style.default_blend_orders[a.blend] > Style.default_blend_orders[b.blend]) {
            return 1;
        }

        return a.name < b.name ? -1 : 1; // use name as tie breaker
    },

    update: function update() {
        // Style-specific animation
        // if (typeof this.animation === 'function') {
        //     this.animation();
        // }
    }

};
exports.Style = Style;

},{"../gl/shader_program":198,"../gl/shader_sources":199,"../gl/vbo_mesh":202,"../light":206,"../material":207,"../selection":212,"../utils/errors":237,"./style_parser":225,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/promise":13,"babel-runtime/helpers/interop-require-default":22,"loglevel":179}],224:[function(_dereq_,module,exports){
// Manage rendering styles

'use strict';

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _Object$defineProperty = _dereq_('babel-runtime/core-js/object/define-property')['default'];

var _Object$create = _dereq_('babel-runtime/core-js/object/create')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsUtils = _dereq_('../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _glShader_program = _dereq_('../gl/shader_program');

var _glShader_program2 = _interopRequireDefault(_glShader_program);

var _glShader_sources = _dereq_('../gl/shader_sources');

var _glShader_sources2 = _interopRequireDefault(_glShader_sources);

// built-in shaders

var _style = _dereq_('./style');

var _utilsMerge = _dereq_('../utils/merge');

var _utilsMerge2 = _interopRequireDefault(_utilsMerge);

var _geo = _dereq_('../geo');

var _geo2 = _interopRequireDefault(_geo);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var StyleManager = {};
exports.StyleManager = StyleManager;
var Styles = {};
exports.Styles = Styles;
var BaseStyles = {};

exports.BaseStyles = BaseStyles;
StyleManager.styles = Styles;

// Set the base object used to instantiate styles
StyleManager.baseStyle = _style.Style;

// Global configuration for all styles
StyleManager.init = function () {
    _glShader_program2['default'].removeBlock('global');
    _glShader_program2['default'].removeBlock('setup');

    // Unpacking functions (for normalized vertex attributes)
    _glShader_program2['default'].addBlock('global', _glShader_sources2['default']['gl/shaders/unpack']);

    // Model and world position accessors
    _glShader_program2['default'].addBlock('global', _glShader_sources2['default']['gl/shaders/accessors']);

    // Layer re-ordering function
    _glShader_program2['default'].addBlock('global', _glShader_sources2['default']['gl/shaders/layer_order']);

    // Feature selection global
    _glShader_program2['default'].addBlock('global', _glShader_sources2['default']['gl/shaders/selection_globals']);

    // Feature selection vertex shader support
    _glShader_program2['default'].replaceBlock('setup', _glShader_sources2['default']['gl/shaders/selection_vertex']);

    // Minimum value for float comparisons
    _glShader_program2['default'].defines.TANGRAM_EPSILON = 0.00001;

    // assume min 16-bit depth buffer, in practice uses 14-bits, 1 extra bit to handle virtual half-layers
    // for outlines (inserted in between layers), another extra bit to prevent precision loss
    _glShader_program2['default'].defines.TANGRAM_LAYER_DELTA = 1 / (1 << 14);

    // Internal tile scale
    _glShader_program2['default'].defines.TANGRAM_TILE_SCALE = 'vec3(' + _geo2['default'].tile_scale + '., ' + _geo2['default'].tile_scale + '., u_meters_per_pixel * ' + _geo2['default'].tile_size + '.)';
};

// Destroy all styles for a given GL context
StyleManager.destroy = function (gl) {
    _Object$keys(Styles).forEach(function (_name) {
        var style = Styles[_name];
        if (style.gl === gl) {
            _loglevel2['default'].trace('StyleManager.destroy: destroying render style ' + style.name);

            if (!style.isBuiltIn()) {
                StyleManager.remove(style.name);
            }
            style.destroy();
        }
    });
};

// Register a style
StyleManager.register = function (style) {
    Styles[style.name] = style;
    BaseStyles[style.name] = style;
};

// Remove a style
StyleManager.remove = function (name) {
    delete Styles[name];
};

// Load style definitions from external URLs
StyleManager.loadRemoteStyles = function (styles, base) {
    var _this = this;

    // Collect URLs and modes to import from them
    // This is done as a separate step becuase it is possible to import multiple modes from a single
    // URL, and we want to avoid duplicate calls for the same file.
    var urls = {};
    for (var name in styles) {
        var style = styles[name];
        if (style.url) {
            var url = style.url;
            if (base) {
                url = _utilsUtils2['default'].addBaseURL(url, base);
            }

            if (!urls[url]) {
                urls[url] = [];
            }

            // Make a list of the styles to import for this URL
            urls[url].push({
                target_name: name,
                source_name: style.name || name
            });
        }
    }

    // As each URL finishes loading, replace the target style(s)
    return _Promise.all(_Object$keys(urls).map(function (url) {
        return new _Promise(function (resolve, reject) {
            _utilsUtils2['default'].loadResource(url).then(function (data) {
                // Mixin remote styles, within each remote file
                // TODO: may not handle multiple levels of mixins, and will not handle nested remote files
                for (var source_name in data) {
                    var source_import = urls[url] && urls[url].find(function (s) {
                        return s.source_name === source_name;
                    });
                    if (source_import) {
                        // use imported name if different from name in source file
                        data[source_name].name = source_import.target_name;
                    } else {
                        data[source_name].name = source_name;
                    }

                    data[source_name] = StyleManager.mix(data[source_name], data);
                }

                // Add remote styles to local styles
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = _getIterator(urls[url]), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var target = _step.value;

                        if (data && data[target.source_name]) {
                            styles[target.target_name] = data[target.source_name];
                        } else {
                            delete styles[target.target_name];
                            return reject(new Error('StyleManager.loadRemoteStyles: error importing style ' + target.target_name + ', could not find source style ' + target.source_name + ' in ' + url));
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator['return']) {
                            _iterator['return']();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                resolve();

                _this.selection = false;
            })['catch'](function (error) {
                _loglevel2['default'].error('StyleManager.loadRemoteStyles: error importing style(s) ' + JSON.stringify(urls[url]) + ' from ' + url, error);
            });
        });
    })).then(function () {
        return _Promise.resolve(styles);
    });
};

// Preload shader blocks from external URLs
StyleManager.loadShaderBlocks = function (styles, base) {
    if (!styles) {
        return _Promise.resolve({});
    }
    var queue = [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = _getIterator(_utilsUtils2['default'].values(styles)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var style = _step2.value;

            if (style.shaders && style.shaders.blocks) {
                var _iteratorNormalCompletion3;

                var _didIteratorError3;

                var _iteratorError3;

                var _iterator3, _step3;

                (function () {
                    var _blocks = style.shaders.blocks;

                    _iteratorNormalCompletion3 = true;
                    _didIteratorError3 = false;
                    _iteratorError3 = undefined;

                    try {
                        var _loop = function () {
                            var _step3$value = _slicedToArray(_step3.value, 2);

                            var key = _step3$value[0];
                            var block = _step3$value[1];

                            var _key = key;

                            // Array of blocks
                            if (Array.isArray(block)) {
                                for (var b = 0; b < block.length; b++) {
                                    if (typeof block[b] === 'object' && block[b].url) {
                                        (function () {
                                            var _index = b;
                                            var url = block[b].url;
                                            if (base) {
                                                url = _utilsUtils2['default'].addBaseURL(url, base);
                                            }

                                            queue.push(_utilsUtils2['default'].io(_utilsUtils2['default'].cacheBusterForUrl(url)).then(function (data) {
                                                _blocks[_key][_index] = data;
                                            })['catch'](function (error) {
                                                _loglevel2['default'].error('StyleManager.loadShaderBlocks: error loading shader block', _blocks, _key, _index, error);
                                            }));
                                        })();
                                    }
                                }
                            }
                            // Single block
                            else if (typeof block === 'object' && block.url) {
                                    var url = block.url;
                                    if (base) {
                                        url = _utilsUtils2['default'].addBaseURL(url, base);
                                    }

                                    queue.push(_utilsUtils2['default'].io(_utilsUtils2['default'].cacheBusterForUrl(url)).then(function (data) {
                                        _blocks[_key] = data;
                                    })['catch'](function (error) {
                                        _loglevel2['default'].error('StyleManager.loadShaderBlocks: error loading shader block', _blocks, _key, error);
                                    }));
                                }
                        };

                        for (_iterator3 = _getIterator(_utilsUtils2['default'].entries(style.shaders.blocks)); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                            _loop();
                        }
                    } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                                _iterator3['return']();
                            }
                        } finally {
                            if (_didIteratorError3) {
                                throw _iteratorError3;
                            }
                        }
                    }
                })();
            }
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                _iterator2['return']();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    return _Promise.all(queue).then(function () {
        return _Promise.resolve(styles);
    }); // TODO: add error
};

StyleManager.mix = function (style, styles) {
    // Exit early if we have already applied mixins to this style
    if (style.mixed) {
        return style;
    }
    style.mixed = {};

    // Mixin sources, in order
    var sources = [];
    if (style.mix) {
        if (Array.isArray(style.mix)) {
            var _sources;

            (_sources = sources).push.apply(_sources, _toConsumableArray(style.mix));
        } else {
            sources.push(style.mix);
        }
        sources = sources.map(function (x) {
            return styles[x];
        }).filter(function (x) {
            return x && x !== style;
        }); // TODO: warning on trying to mix into self

        // Track which styles were mixed into this one
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
            for (var _iterator4 = _getIterator(sources), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var s = _step4.value;

                style.mixed[s] = true;
            }
        } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                    _iterator4['return']();
                }
            } finally {
                if (_didIteratorError4) {
                    throw _iteratorError4;
                }
            }
        }
    }
    sources.push(style);

    // Flags - OR'd, true if any style has it set
    style.animated = sources.some(function (x) {
        return x && x.animated;
    });
    style.texcoords = sources.some(function (x) {
        return x && x.texcoords;
    });

    // Overwrites - last definition wins
    style.base = sources.map(function (x) {
        return x.base;
    }).filter(function (x) {
        return x;
    }).pop();
    style.lighting = sources.map(function (x) {
        return x.lighting;
    }).filter(function (x) {
        return x != null;
    }).pop();
    style.texture = sources.map(function (x) {
        return x.texture;
    }).filter(function (x) {
        return x;
    }).pop();
    if (sources.some(function (x) {
        return x.hasOwnProperty('blend') && x.blend;
    })) {
        // only mix blend if explicitly set, otherwise let base style choose blending mode
        // hasOwnProperty check gives preference to base style prototype
        style.blend = sources.map(function (x) {
            return x.hasOwnProperty('blend') && x.blend;
        }).filter(function (x) {
            return x;
        }).pop();
    }
    style.blend_order = sources.map(function (x) {
        return x.blend_order;
    }).filter(function (x) {
        return x != null;
    }).pop();

    // Merges - property-specific rules for merging values
    style.defines = _Object$assign.apply(Object, [{}].concat(_toConsumableArray(sources.map(function (x) {
        return x.defines;
    }).filter(function (x) {
        return x;
    })))); // internal defines (not user-defined)
    style.material = _Object$assign.apply(Object, [{}].concat(_toConsumableArray(sources.map(function (x) {
        return x.material;
    }).filter(function (x) {
        return x;
    }))));

    // Mix shader properties
    StyleManager.mixShaders(style, styles, sources);
    return style;
};

// Mix the propertes in the "shaders" block
StyleManager.mixShaders = function (style, styles, sources) {
    var shaders = {}; // newly mixed shaders properties
    var shader_merges = sources.map(function (x) {
        return x.shaders;
    }).filter(function (x) {
        return x;
    }); // just the source styles with shader properties

    // Defines
    shaders.defines = _Object$assign.apply(Object, [{}].concat(_toConsumableArray(shader_merges.map(function (x) {
        return x.defines;
    }).filter(function (x) {
        return x;
    }))));

    // Uniforms
    shaders.uniforms = {}; // uniforms for this style, both explicitly defined, and mixed from other styles
    shaders._uniforms = style.shaders && style.shaders.uniforms || {}; // uniforms explicitly defined by *this* style
    shaders._uniform_scopes = {}; // tracks which style each uniform originated from (this one, or ancestor)

    // Mix in uniforms from ancestors, providing means to access
    sources.filter(function (x) {
        return x.shaders && x.shaders.uniforms;
    }).forEach(function (x) {
        var _loop2 = function (u) {
            shaders._uniform_scopes[u] = x.name;

            // Define getter and setter for this uniform
            // Getter returns value for this style if present, otherwise asks appropriate ancestor for it
            // Setter sets the value for this style (whether previously present in this style or not)
            // Mimics JS prototype/hasOwnProperty behavior, but with multiple ancestors (via mixins)
            _Object$defineProperty(shaders.uniforms, u, {
                enumerable: true,
                configurable: true,
                get: function get() {
                    // Uniform is explicitly defined on this style
                    if (shaders._uniforms[u] !== undefined) {
                        return shaders._uniforms[u];
                    }
                    // Uniform was mixed from another style, forward request there
                    // Identify check is needed to prevent infinite recursion if a previously defined uniform
                    // is set to undefined
                    else if (styles[shaders._uniform_scopes[u]].shaders.uniforms !== shaders.uniforms) {
                            return styles[shaders._uniform_scopes[u]].shaders.uniforms[u];
                        }
                },
                set: function set(v) {
                    shaders._uniforms[u] = v;
                }
            });
        };

        for (var u in x.shaders.uniforms) {
            _loop2(u);
        }
    });

    // Extensions: build a list of unique extensions
    shaders.extensions = _Object$keys(shader_merges.map(function (x) {
        return x.extensions;
    }).filter(function (x) {
        return x;
    }).reduce(function (prev, cur) {
        // single extension
        if (typeof cur === 'string') {
            prev[cur] = true;
        }
        // array of extensions
        else {
                cur.forEach(function (x) {
                    return prev[x] = true;
                });
            }
        return prev;
    }, {}) || {});

    // Shader blocks
    // Mark all shader blocks for the target style as originating with its own name
    if (style.shaders && style.shaders.blocks) {
        style.shaders.block_scopes = style.shaders.block_scopes || {};
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
            for (var _iterator5 = _getIterator(_utilsUtils2['default'].entries(style.shaders.blocks)), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var _step5$value = _slicedToArray(_step5.value, 2);

                var k = _step5$value[0];
                var block = _step5$value[1];

                style.shaders.block_scopes[k] = style.shaders.block_scopes[k] || [];
                if (Array.isArray(block)) {
                    var _style$shaders$block_scopes$k;

                    (_style$shaders$block_scopes$k = style.shaders.block_scopes[k]).push.apply(_style$shaders$block_scopes$k, _toConsumableArray(block.map(function () {
                        return style.name;
                    })));
                } else {
                    style.shaders.block_scopes[k].push(style.name);
                }
            }
        } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion5 && _iterator5['return']) {
                    _iterator5['return']();
                }
            } finally {
                if (_didIteratorError5) {
                    throw _iteratorError5;
                }
            }
        }
    }

    // Merge shader blocks, keeping track of which style each block originated from
    var mixed = {}; // all scopes mixed so far
    var _iteratorNormalCompletion6 = true;
    var _didIteratorError6 = false;
    var _iteratorError6 = undefined;

    try {
        for (var _iterator6 = _getIterator(shader_merges), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var source = _step6.value;

            if (!source.blocks) {
                continue;
            }

            shaders.blocks = shaders.blocks || {};
            shaders.block_scopes = shaders.block_scopes || {};
            var mixed_source = {}; // scopes mixed for this source style

            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
                for (var _iterator7 = _getIterator(_utilsUtils2['default'].entries(source.blocks)), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                    var _step7$value = _slicedToArray(_step7.value, 2);

                    var t = _step7$value[0];
                    var block = _step7$value[1];

                    var block_scope = source.block_scopes[t];

                    shaders.blocks[t] = shaders.blocks[t] || [];
                    shaders.block_scopes[t] = shaders.block_scopes[t] || [];

                    // standardize on arrays (block can be single or multi-value)
                    block = Array.isArray(block) ? block : [block];
                    block_scope = Array.isArray(block_scope) ? block_scope : [block_scope];

                    for (var b = 0; b < block.length; b++) {
                        // Skip blocks we've already mixed in from the same scope
                        // Repeating scope indicates a diamond pattern where a style is being mixed multiple times
                        if (mixed[block_scope[b]]) {
                            continue;
                        }
                        mixed_source[block_scope[b]] = true;

                        shaders.blocks[t].push(block[b]);
                        shaders.block_scopes[t].push(block_scope[b]);
                    }
                }

                // Add styles mixed in from this source - they could be multi-level ancestors,
                // beyond the first-level "parents" defined in this style's `mix` list
            } catch (err) {
                _didIteratorError7 = true;
                _iteratorError7 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion7 && _iterator7['return']) {
                        _iterator7['return']();
                    }
                } finally {
                    if (_didIteratorError7) {
                        throw _iteratorError7;
                    }
                }
            }

            _Object$assign(style.mixed, mixed_source);
        }
    } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion6 && _iterator6['return']) {
                _iterator6['return']();
            }
        } finally {
            if (_didIteratorError6) {
                throw _iteratorError6;
            }
        }
    }

    style.shaders = shaders; // assign back to style
    return style;
};

// Create a new style
// name: name of new style
// config: properties of new style
// styles: working set of styles being built (used for mixing in existing styles)
StyleManager.create = function (name, config) {
    var styles = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var style = (0, _utilsMerge2['default'])({}, config); // deep copy
    style.name = name;

    // Style mixins
    style = StyleManager.mix(style, styles);

    // Has base style?
    // Only renderable (instantiated) styles should be included for run-time use
    // Others are intermediary/abstract, used during style composition but not execution
    if (style.base && BaseStyles[style.base]) {
        Styles[name] = style = _Object$assign(_Object$create(BaseStyles[style.base]), style);
    }

    return style;
};

// Called to create and initialize styles
StyleManager.build = function (styles) {
    var scene = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    // Sort styles by dependency, then build them
    var style_deps = _Object$keys(styles).sort(function (a, b) {
        return StyleManager.inheritanceDepth(a, styles) - StyleManager.inheritanceDepth(b, styles);
    });

    // Only keep built-in base styles
    for (var sname in Styles) {
        if (!BaseStyles[sname]) {
            delete Styles[sname];
        } else {
            Styles[sname].reset();
        }
    }

    // Working set of styles being built
    var ws = {};
    var _iteratorNormalCompletion8 = true;
    var _didIteratorError8 = false;
    var _iteratorError8 = undefined;

    try {
        for (var _iterator8 = _getIterator(style_deps), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var sname = _step8.value;

            ws[sname] = StyleManager.create(sname, styles[sname], ws);
        }
    } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion8 && _iterator8['return']) {
                _iterator8['return']();
            }
        } finally {
            if (_didIteratorError8) {
                throw _iteratorError8;
            }
        }
    }

    StyleManager.initStyles(scene);
    return Styles;
};

// Initialize all styles
StyleManager.initStyles = function (scene) {
    // Initialize all
    for (var sname in Styles) {
        Styles[sname].init(scene);
    }
};

// Given a style key in a set of styles to add, count the length of the inheritance chain
// TODO: remove current (Styles) and future (styles) duplication, confusing
StyleManager.inheritanceDepth = function (key, styles) {
    var parents = 0;

    while (true) {
        var style = styles[key];
        if (!style) {
            // this is a scene def error, trying to extend a style that doesn't exist
            break;
        }

        // Dependency chain ends when this style isn't mixing in any others
        if (!style.mix) {
            break;
        }

        // Traverse next parent style
        parents++;

        if (Array.isArray(style.mix)) {
            // If multiple mixins, find the deepest one
            parents += Math.max.apply(Math, _toConsumableArray(style.mix.map(function (s) {
                // Trying to mix into itself!
                if (key === s) {
                    return;
                }

                return StyleManager.inheritanceDepth(s, styles);
            })));
            break;
        } else {
            // Trying to mix into itself!
            if (key === style.mix) {
                break;
            }

            // If single mixin, continue loop up the tree
            key = style.mix;
        }
    }
    return parents;
};

// Compile all styles
StyleManager.compile = function (keys, scene) {
    keys = keys || _Object$keys(Styles);
    var _iteratorNormalCompletion9 = true;
    var _didIteratorError9 = false;
    var _iteratorError9 = undefined;

    try {
        for (var _iterator9 = _getIterator(keys), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var key = _step9.value;

            var style = Styles[key];
            try {
                style.compile();
                _loglevel2['default'].trace('StyleManager.compile(): compiled style ' + key);
            } catch (error) {
                _loglevel2['default'].error('StyleManager.compile(): error compiling style ' + key + ':', error);

                scene.trigger('warning', {
                    type: 'styles',
                    message: 'Error compiling style ' + key,
                    style: style,
                    shader_errors: style.program && style.program.shader_errors
                });
            }
        }
    } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion9 && _iterator9['return']) {
                _iterator9['return']();
            }
        } finally {
            if (_didIteratorError9) {
                throw _iteratorError9;
            }
        }
    }

    _loglevel2['default'].debug('StyleManager.compile(): compiled all styles');
};

// Get all styles with mesh data for a given tile
StyleManager.stylesForTile = function (tile) {
    var styles = [];
    for (var s in Styles) {
        if (Styles[s].hasDataForTile(tile)) {
            styles.push(s);
        }
    }
    return styles;
};

},{"../geo":192,"../gl/shader_program":198,"../gl/shader_sources":199,"../utils/merge":238,"../utils/utils":241,"./style":223,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/create":7,"babel-runtime/core-js/object/define-property":9,"babel-runtime/core-js/object/keys":11,"babel-runtime/core-js/promise":13,"babel-runtime/helpers/interop-require-default":22,"babel-runtime/helpers/sliced-to-array":23,"babel-runtime/helpers/to-consumable-array":24,"loglevel":179}],225:[function(_dereq_,module,exports){
'use strict';

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsUtils = _dereq_('../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _geo = _dereq_('../geo');

var _geo2 = _interopRequireDefault(_geo);

var _csscolorparser = _dereq_('csscolorparser');

var _csscolorparser2 = _interopRequireDefault(_csscolorparser);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var StyleParser = {};

exports.StyleParser = StyleParser;
// Style macros

StyleParser.expandMacros = function expandMacros(obj) {
    for (var p in obj) {
        var val = obj[p];

        // Loop through object properties
        if (typeof val === 'object') {
            obj[p] = expandMacros(val);
        }
        // Convert strings back into functions
        else if (typeof val === 'string') {
                for (var m in StyleParser.macros) {
                    if (val.match(StyleParser.macros[m])) {
                        var f;
                        try {
                            /*jshint ignore:start */
                            eval('f = ' + val);
                            /*jshint ignore:end */
                            obj[p] = f;
                            _loglevel2['default'].trace('expanded macro ' + val + ' to ' + f);
                            break;
                        } catch (e) {
                            // fall-back to original value if parsing failed
                            obj[p] = val;
                            _loglevel2['default'].trace('failed to expand macro ' + val);
                        }
                    }
                }
            }
    }

    return obj;
};

// List of macros
StyleParser.macros = ['Style.color.pseudoRandomColor', 'Style.color.randomColor'];

var Style = {};

Style.color = {
    // pseudo-random grayscale by geometry id
    pseudoRandomGrayscale: function pseudoRandomGrayscale() {
        var func = 'function() {\n            var c = Math.max((parseInt(feature.id, 16) % 100) / 100, 0.4);\n            return [0.7 * c, 0.7 * c, 0.7 * c];\n        }';
        return func;
    },

    // pseudo-random color by geometry id
    pseudoRandomColor: function pseudoRandomColor() {
        var func = 'function() {\n            return [\n                0.7 * (parseInt(feature.id, 16) / 100 % 1),\n                0.7 * (parseInt(feature.id, 16) / 10000 % 1),\n                0.7 * (parseInt(feature.id, 16) / 1000000 % 1)\n            ];\n        }';
        return func;
        // return `function() { return [0.7 * (parseInt(feature.id, 16) / 100 % 1), 0.7 * (parseInt(feature.id, 16) / 10000 % 1), 0.7 * (parseInt(feature.id, 16) / 1000000 % 1)]; }`;
    },

    // random color
    randomColor: function randomColor() {
        var func = 'function() {\n            return [0.7 * Math.random(), 0.7 * Math.random(), 0.7 * Math.random()];\n        }';
        return func;
    }
};

// Wraps style functions and provides a scope of commonly accessible data:
// - feature: the 'properties' of the feature, e.g. accessed as 'feature.name'
// - $zoom: the current map zoom level
// - $geometry: the type of geometry, 'point', 'line', or 'polygon'
// - $meters_per_pixel: conversion for meters/pixels at current map zoom
// - properties: user-defined properties on the style-rule object in the stylesheet
StyleParser.wrapFunction = function (func) {
    var f = 'function(context) {\n                var feature = context.feature.properties;\n                var $zoom = context.zoom;\n                var $layer = context.layer;\n                var $geometry = context.geometry;\n                var $meters_per_pixel = context.meters_per_pixel;\n                var properties = context.properties;\n\n                var val = (' + func + '());\n\n                if (typeof val === \'number\' && isNaN(val)) {\n                    val = null; // convert NaNs to nulls\n                }\n\n                return val;\n            }';
    return f;
};

// Style parsing

// Style defaults
StyleParser.defaults = {
    color: [1, 1, 1, 1],
    width: 1,
    size: 1,
    extrude: false,
    height: 20,
    min_height: 0,
    order: 0,
    z: 0,
    material: {
        ambient: 1,
        diffuse: 1
    }
};

// A context object that is passed to style parsing functions to provide a scope of commonly used values
StyleParser.getFeatureParseContext = function (feature, tile) {
    return {
        feature: feature,
        tile: tile,
        zoom: tile.style_zoom,
        geometry: _geo2['default'].geometryType(feature.geometry.type),
        meters_per_pixel: _geo2['default'].metersPerPixel(tile.coords.z),
        units_per_meter: _geo2['default'].units_per_meter[tile.coords.z]
    };
};

// Build a style param cache object
// `value` is raw value, cache methods will add other properties as needed
// `transform` is optional transform function to run on values (except function values)
StyleParser.cacheObject = function (obj) {
    var transform = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (obj == null) {
        return;
    }

    if (obj.value) {
        return { value: obj.value }; // clone existing cache object
    }

    if (typeof transform === 'function') {
        if (Array.isArray(obj) && Array.isArray(obj[0])) {
            // zoom stops
            obj = obj.map(function (v) {
                return [v[0], transform(v[1])];
            });
        } else if (typeof obj !== 'function') {
            // don't transform functions
            obj = transform(obj); // single value
        }
    }

    return { value: obj };
};

// Interpolation and caching for a generic property (not a color or distance)
// { value: original, static: val, zoom: { 1: val1, 2: val2, ... }, dynamic: function(){...} }
StyleParser.cacheProperty = function (val, context) {
    if (val == null) {
        return;
    } else if (val.dynamic) {
        // function, compute each time (no caching)
        var v = val.dynamic(context);
        return v;
    } else if (val['static']) {
        // single static value
        return val['static'];
    } else if (val.zoom && val.zoom[context.zoom]) {
        // interpolated, cached
        return val.zoom[context.zoom];
    } else {
        // not yet evaulated for cache
        // Dynamic function-based
        if (typeof val.value === 'function') {
            val.dynamic = val.value;
            var v = val.dynamic(context);
            return v;
        }
        // Array of zoom-interpolated stops, e.g. [zoom, value] pairs
        else if (Array.isArray(val.value) && Array.isArray(val.value[0])) {
                // Calculate value for current zoom
                val.zoom = val.zoom || {};
                val.zoom = {};
                val.zoom[context.zoom] = _utilsUtils2['default'].interpolate(context.zoom, val.value);
                return val.zoom[context.zoom];
            }
            // Single static value
            else {
                    val['static'] = val.value;
                    return val['static'];
                }
    }
};

StyleParser.convertUnits = function (val, context) {
    var convert = arguments.length <= 2 || arguments[2] === undefined ? 'meters' : arguments[2];

    if (typeof val === 'string') {
        var units = val.match(/([0-9.-]+)([a-z]+)/);
        if (units && units.length === 3) {
            val = parseFloat(units[1]);
            units = units[2];
        }

        // Convert to meters
        if (convert === 'meters') {
            // Convert from pixels
            if (units === 'px') {
                val *= _geo2['default'].metersPerPixel(context.zoom);
            }
            // Convert from kilometers
            else if (units === 'km') {
                    val *= 1000;
                }
        }
    } else if (Array.isArray(val)) {
        // Array of arrays, e.g. zoom-interpolated stops
        if (Array.isArray(val[0])) {
            return val.map(function (v) {
                return [v[0], StyleParser.convertUnits(v[1], context, convert)];
            });
        }
        // Array of values
        else {
                return val.map(function (v) {
                    return StyleParser.convertUnits(v, context, convert);
                });
            }
    }
    return val;
};

// Takes a distance cache object and returns a distance value for this zoom
// (caching the result for future use)
// { value: original, zoom: { z: meters }, dynamic: function(){...} }
StyleParser.cacheDistance = function (val, context) {
    var convert = arguments.length <= 2 || arguments[2] === undefined ? 'meters' : arguments[2];

    if (val.dynamic) {
        var v = val.dynamic(context);
        return v;
    } else if (val.zoom && val.zoom[convert] && val.zoom[convert][context.zoom]) {
        return val.zoom[convert][context.zoom];
    } else {
        // Dynamic function-based
        if (typeof val.value === 'function') {
            val.dynamic = val.value;
            var v = val.dynamic(context);
            return v;
        }
        // Array of zoom-interpolated stops, e.g. [zoom, value] pairs
        else {
                // Calculate value for current zoom
                val.zoom = val.zoom || {};
                var zunits = val.zoom[convert] = val.zoom[convert] || {};

                zunits[context.zoom] = StyleParser.convertUnits(val.value, context, convert === 'meters' && 'meters'); // convert to meters
                zunits[context.zoom] = _utilsUtils2['default'].interpolate(context.zoom, zunits[context.zoom]);

                return zunits[context.zoom];
            }
    }
};

// Cache previously parsed color strings
StyleParser.string_colors = {};
StyleParser.colorForString = function (string) {
    // Cached
    if (StyleParser.string_colors[string]) {
        return StyleParser.string_colors[string];
    }

    // Calculate and cache
    var color = _csscolorparser2['default'].parseCSSColor(string);
    if (color && color.length === 4) {
        color[0] /= 255;
        color[1] /= 255;
        color[2] /= 255;
        color[3] = 1;
    } else {
        color = StyleParser.defaults.color;
    }
    StyleParser.string_colors[string] = color;
    return color;
};

// Takes a color cache object and returns a color value for this zoom
// (caching the result for future use)
// { value: original, static: [r,g,b,a], zoom: { z: [r,g,b,a] }, dynamic: function(){...} }
StyleParser.cacheColor = function (val) {
    var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    if (val.dynamic) {
        var v = val.dynamic(context);
        if (v && v[3] == null) {
            v[3] = 1; // default alpha
        }
        return v;
    } else if (val['static']) {
        return val['static'];
    } else if (val.zoom && val.zoom[context.zoom]) {
        return val.zoom[context.zoom];
    } else {
        // Dynamic function-based color
        if (typeof val.value === 'function') {
            val.dynamic = val.value;
            var v = val.dynamic(context);
            if (v && v[3] == null) {
                v[3] = 1; // default alpha
            }
            return v;
        }
        // Single string color
        else if (typeof val.value === 'string') {
                val['static'] = StyleParser.colorForString(val.value);
                return val['static'];
            }
            // Array of zoom-interpolated stops, e.g. [zoom, color] pairs
            else if (Array.isArray(val.value) && Array.isArray(val.value[0])) {
                    if (!val.zoom) {
                        val.zoom = {};
                        // Parse any string colors inside stops
                        for (var i = 0; i < val.value.length; i++) {
                            var v = val.value[i];
                            if (v && typeof v[1] === 'string') {
                                v[1] = StyleParser.colorForString(v[1]);
                            }
                        }
                    }

                    // Calculate color for current zoom
                    val.zoom[context.zoom] = _utilsUtils2['default'].interpolate(context.zoom, val.value);
                    val.zoom[context.zoom][3] = val.zoom[context.zoom][3] || 1; // default alpha
                    return val.zoom[context.zoom];
                }
                // Single array color
                else {
                        val['static'] = val.value;
                        if (val['static'] && val['static'][3] == null) {
                            val['static'][3] = 1; // default alpha
                        }
                        return val['static'];
                    }
    }
};

StyleParser.parseColor = function (val) {
    var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    if (typeof val === 'function') {
        val = val(context);
    }

    // Parse CSS-style colors
    // TODO: change all colors to use 0-255 range internally to avoid dividing and then re-multiplying in geom builder
    if (typeof val === 'string') {
        val = StyleParser.colorForString(val);
    } else if (Array.isArray(val) && Array.isArray(val[0])) {
        // Array of zoom-interpolated stops, e.g. [zoom, color] pairs
        for (var i = 0; i < val.length; i++) {
            var v = val[i];
            if (typeof v[1] === 'string') {
                v[1] = StyleParser.colorForString(v[1]);
            }
        }

        if (context.zoom) {
            val = _utilsUtils2['default'].interpolate(context.zoom, val);
        }
    }

    // Defaults
    if (val) {
        // alpha
        if (val[3] == null) {
            val[3] = 1;
        }
    } else {
        val = [0, 0, 0, 1];
    }

    return val;
};

StyleParser.calculateOrder = function (order, context) {
    // Computed order
    if (typeof order === 'function') {
        order = order(context);
    } else if (typeof order === 'string') {
        // Order tied to feature property
        if (context.feature.properties[order]) {
            order = context.feature.properties[order];
        }
        // Explicit order value
        else {
                order = parseFloat(order);
            }
    }

    return order;
};

},{"../geo":192,"../utils/utils":241,"babel-runtime/helpers/interop-require-default":22,"csscolorparser":138,"loglevel":179}],226:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsUtils = _dereq_('../../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _builders = _dereq_('../builders');

var _builders2 = _interopRequireDefault(_builders);

var CanvasText = (function () {
    function CanvasText() {
        _classCallCheck(this, CanvasText);

        this.canvas = document.createElement('canvas');
        this.canvas.style.backgroundColor = 'transparent'; // render text on transparent background
        this.context = this.canvas.getContext('2d');
    }

    // Extract font size and units

    _createClass(CanvasText, [{
        key: 'resize',
        value: function resize(width, height) {
            this.canvas.width = width;
            this.canvas.height = height;
            this.context.clearRect(0, 0, width, height);
        }

        // Set font style params for canvas drawing
    }, {
        key: 'setFont',
        value: function setFont(tile, _ref) {
            var font_css = _ref.font_css;
            var fill = _ref.fill;
            var stroke = _ref.stroke;
            var stroke_width = _ref.stroke_width;
            var px_size = _ref.px_size;

            this.px_size = px_size;
            this.text_buffer = 8; // pixel padding around text
            var ctx = this.context;

            ctx.font = font_css;
            if (stroke) {
                ctx.strokeStyle = stroke;
                ctx.lineWidth = stroke_width;
            } else {
                ctx.strokeStyle = null;
                ctx.lineWidth = 0;
            }
            ctx.fillStyle = fill;
            ctx.miterLimit = 2;
        }
    }, {
        key: 'textSizes',
        value: function textSizes(tile, texts) {
            for (var style in texts) {
                var text_infos = texts[style];

                for (var text in text_infos) {
                    var text_settings = text_infos[text].text_settings;
                    // update text sizes
                    this.setFont(tile, text_settings); // TODO: only set once above
                    _Object$assign(text_infos[text], this.textSize(text, tile, text_settings.transform, text_settings.text_wrap));
                }
            }

            return texts;
        }

        // Computes width and height of text based on current font style
        // Includes word wrapping, returns size info for whole text block and individual lines
    }, {
        key: 'textSize',
        value: function textSize(text, tile, transform, text_wrap) {
            var str = this.applyTextTransform(text, transform);
            var ctx = this.context;
            var buffer = this.text_buffer * _utilsUtils2['default'].device_pixel_ratio;
            var leading = 2 * _utilsUtils2['default'].device_pixel_ratio; // make configurable and/or use Canvas TextMetrics when available
            var line_height = this.px_size + leading; // px_size already in device pixels

            // Word wrapping
            // Line breaks can be caused by:
            //  - implicit line break when a maximum character threshold is exceeded per line (text_wrap)
            //  - explicit line break in the label text (\n)
            var words = undefined;
            if (typeof text_wrap === 'number') {
                words = str.split(' '); // split words on spaces
            } else {
                    words = [str]; // no max line word wrapping (but new lines will still be in effect)
                }
            var new_line_template = { width: 0, chars: 0, text: '' };
            var line = _Object$assign({}, new_line_template); // current line
            var lines = []; // completed lines
            var max_width = 0; // max width to fit all lines

            // add current line buffer to completed lines, optionally start new line
            function addLine(new_line) {
                line.text = line.text.trim();
                if (line.text.length > 0) {
                    line.width = ctx.measureText(line.text).width;
                    max_width = Math.max(max_width, Math.ceil(line.width));
                    lines.push(line);
                }
                if (new_line) {
                    line = _Object$assign({}, new_line_template);
                }
            }

            // First iterate on space-break groups (will be one if max line length off), then iterate on line-break groups
            for (var w = 0; w < words.length; w++) {
                var breaks = words[w].split('\n'); // split on line breaks

                for (var n = 0; n < breaks.length; n++) {
                    var word = breaks[n];

                    // if adding current word would overflow, add a new line instead
                    if (line.chars + word.length > text_wrap && line.chars > 0) {
                        addLine(true);
                    }

                    // add current word (plus space)
                    line.chars += word.length + 1;
                    line.text += word + ' ';

                    // if line breaks present, add new line (unless on last line)
                    if (breaks.length > 1 && n < breaks.length - 1) {
                        addLine(true);
                    }
                }
            }
            addLine(false);

            // Final dimensions of text
            var height = lines.length * line_height;

            var collision_size = [max_width / _utilsUtils2['default'].device_pixel_ratio, height / _utilsUtils2['default'].device_pixel_ratio];

            var texture_size = [max_width + buffer * 2, height + buffer * 2];

            var logical_size = texture_size.map(function (v) {
                return v / _utilsUtils2['default'].device_pixel_ratio;
            });

            // Returns lines (w/per-line info for drawing) and text's overall bounding box + canvas size
            return {
                lines: lines,
                size: { collision_size: collision_size, texture_size: texture_size, logical_size: logical_size, line_height: line_height }
            };
        }

        // Draw one or more lines of text at specified location, adjusting for buffer and baseline
    }, {
        key: 'drawText',
        value: function drawText(lines, _ref2, size, tile, _ref3) {
            var _ref22 = _slicedToArray(_ref2, 2);

            var x = _ref22[0];
            var y = _ref22[1];
            var stroke = _ref3.stroke;
            var transform = _ref3.transform;
            var align = _ref3.align;

            align = align || 'center';

            for (var line_num = 0; line_num < lines.length; line_num++) {
                var line = lines[line_num];
                var str = this.applyTextTransform(line.text, transform);
                var buffer = this.text_buffer * _utilsUtils2['default'].device_pixel_ratio;
                var texture_size = size.texture_size;
                var line_height = size.line_height;

                // Text alignment
                var tx = undefined;
                if (align === 'left') {
                    tx = x + buffer;
                } else if (align === 'center') {
                    tx = x + texture_size[0] / 2 - line.width / 2;
                } else if (align === 'right') {
                    tx = x + texture_size[0] - line.width - buffer;
                }

                // In the absence of better Canvas TextMetrics (not supported by browsers yet),
                // 0.75 buffer produces a better approximate vertical centering of text
                var ty = y + buffer * 0.75 + (line_num + 1) * line_height;

                if (stroke) {
                    this.context.strokeText(str, tx, ty);
                }
                this.context.fillText(str, tx, ty);
            }
        }
    }, {
        key: 'rasterize',
        value: function rasterize(tile, texts, texture_size) {
            for (var style in texts) {
                var text_infos = texts[style];

                for (var text in text_infos) {
                    var info = text_infos[text];

                    this.setFont(tile, info.text_settings); // TODO: only set once above
                    this.drawText(info.lines, info.position, info.size, tile, {
                        stroke: info.text_settings.stroke,
                        transform: info.text_settings.transform,
                        align: info.text_settings.align
                    });

                    info.texcoords = _builders2['default'].getTexcoordsForSprite(info.position, info.size.texture_size, texture_size);
                }
            }
        }
    }, {
        key: 'setTextureTextPositions',
        value: function setTextureTextPositions(texts) {
            // Find widest label and sum of all label heights
            var widest = 0,
                height = 0;

            for (var style in texts) {
                var text_infos = texts[style];

                for (var text in text_infos) {
                    var text_info = text_infos[text];
                    var size = text_info.size.texture_size;

                    text_info.position = [0, height];

                    if (size[0] > widest) {
                        widest = size[0];
                    }

                    height += size[1];
                }
            }

            return [widest, height];
        }

        // Called before rasterization
    }, {
        key: 'applyTextTransform',
        value: function applyTextTransform(text, transform) {
            if (transform === 'capitalize') {
                return text.replace(/\w\S*/g, function (txt) {
                    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                });
            } else if (transform === 'uppercase') {
                return text.toUpperCase();
            } else if (transform === 'lowercase') {
                return text.toLowerCase();
            }
            return text;
        }

        // Convert font CSS-style size ('12px', '14pt', '1.5em', etc.) to pixel size (adjusted for device pixel ratio)
        // Defaults units to pixels if not specified
    }], [{
        key: 'fontPixelSize',
        value: function fontPixelSize(size) {
            if (size == null) {
                return;
            }
            size = typeof size === 'string' ? size : String(size); // need a string for regex

            var _ref4 = size.match(CanvasText.font_size_re) || [];

            var _ref42 = _slicedToArray(_ref4, 3);

            var px_size = _ref42[1];
            var units = _ref42[2];

            units = units || 'px';

            if (units === "em") {
                px_size *= 16;
            } else if (units === "pt") {
                px_size /= 0.75;
            } else if (units === "%") {
                px_size /= 6.25;
            }

            px_size = parseFloat(px_size);
            px_size *= _utilsUtils2['default'].device_pixel_ratio;
            return px_size;
        }
    }]);

    return CanvasText;
})();

exports['default'] = CanvasText;
CanvasText.font_size_re = /((?:[0-9]*\.)?[0-9]+)\s*(px|pt|em|%)?/;
module.exports = exports['default'];

},{"../../utils/utils":241,"../builders":217,"babel-runtime/core-js/object/assign":6,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/interop-require-default":22,"babel-runtime/helpers/sliced-to-array":23}],227:[function(_dereq_,module,exports){
/*global Label */

'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _boxIntersect = _dereq_('box-intersect');

var _boxIntersect2 = _interopRequireDefault(_boxIntersect);

// https://github.com/mikolalysenko/box-intersect

var _utilsUtils = _dereq_('../../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _utilsObb = _dereq_('../../utils/obb');

var _utilsObb2 = _interopRequireDefault(_utilsObb);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var Label = (function () {
    function Label(text, size, options) {
        _classCallCheck(this, Label);

        _Object$assign(this, {
            text: text,
            size: size,
            options: options,
            position: null,
            aabb: null
        });
    }

    // check for overlaps with other labels in the tile

    _createClass(Label, [{
        key: 'occluded',
        value: function occluded(aabbs) {
            var _this = this;

            var intersect = false;

            // Broadphase
            if (aabbs.length > 0) {
                (0, _boxIntersect2['default'])([this.aabb], aabbs, function (i, j) {
                    _loglevel2['default'].trace(_this.text + ' broad phase collide', _this, _this.aabb, aabbs[j]);

                    // Narrow phase
                    if (_utilsObb2['default'].intersect(_this.aabb.obb, aabbs[j].obb)) {
                        _loglevel2['default'].trace(_this.text + ' narrow phase collide', _this, _this.aabb.obb, aabbs[j].obb);
                        intersect = true;
                        return true;
                    }
                });
            }
            return intersect;
        }

        // Add this label's bounding box to the provided set
    }, {
        key: 'add',
        value: function add(aabbs) {
            aabbs.push(this.aabb);
        }

        // checks whether the label is within the tile boundaries
    }, {
        key: 'inTileBounds',
        value: function inTileBounds() {
            var min = [this.aabb[0], this.aabb[1]];
            var max = [this.aabb[2], this.aabb[3]];

            if (!_utilsUtils2['default'].pointInTile(min) || !_utilsUtils2['default'].pointInTile(max)) {
                return false;
            }

            return true;
        }

        // Whether the label should be discarded
        // Depends on whether label must fit in the tile bounds, and if so, can it be moved to fit there
    }, {
        key: 'discard',
        value: function discard(aabbs) {
            // Should the label be culled if it can't fit inside the tile bounds?
            if (this.options.cull_from_tile) {
                var in_tile = this.inTileBounds();

                // If it doesn't fit, should we try to move it into the tile bounds?
                if (!in_tile && this.options.move_into_tile) {
                    // Can we fit the label into the tile?
                    if (!this.moveIntoTile()) {
                        return true; // can't fit in tile, discard
                    }
                } else if (!in_tile) {
                        return true; // out of tile bounds, discard
                    }
            }

            // If the label hasn't been discarded yet, check to see if it's occluded by other labels
            return this.occluded(aabbs);
        }
    }]);

    return Label;
})();

exports['default'] = Label;
module.exports = exports['default'];

},{"../../utils/obb":239,"../../utils/utils":241,"babel-runtime/core-js/object/assign":6,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/interop-require-default":22,"box-intersect":119,"loglevel":179}],228:[function(_dereq_,module,exports){
'use strict';

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _label_point = _dereq_('./label_point');

var _label_point2 = _interopRequireDefault(_label_point);

var _label_line = _dereq_('./label_line');

var _label_line2 = _interopRequireDefault(_label_line);

var _geo = _dereq_('../../geo');

var _geo2 = _interopRequireDefault(_geo);

var LabelBuilder;
exports['default'] = LabelBuilder = {};

LabelBuilder.buildFromGeometry = function (text, size, geometry, options) {
    var labels = [];

    if (geometry.type === "LineString") {
        var lines = geometry.coordinates;

        labels.push(new _label_line2['default'](text, size, lines, options));
    } else if (geometry.type === "MultiLineString") {
        var lines = geometry.coordinates;

        for (var i = 0; i < lines.length; ++i) {
            var line = lines[i];
            labels.push(new _label_line2['default'](text, size, line, options));
        }
    } else if (geometry.type === "Point") {
        labels.push(new _label_point2['default'](text, geometry.coordinates, size, options));
    } else if (geometry.type === "MultiPoint") {
        var points = geometry.coordinates;

        for (var i = 0; i < points.length; ++i) {
            var point = points[i];
            labels.push(new _label_point2['default'](text, point, size, options));
        }
    } else if (geometry.type === "Polygon") {
        var centroid = _geo2['default'].centroid(geometry.coordinates[0]);
        labels.push(new _label_point2['default'](text, centroid, size, options));
    } else if (geometry.type === "MultiPolygon") {
        var centroid = _geo2['default'].multiCentroid(geometry.coordinates);
        labels.push(new _label_point2['default'](text, centroid, size, options));
    }

    return labels;
};
module.exports = exports['default'];

},{"../../geo":192,"./label_line":229,"./label_point":230,"babel-runtime/helpers/interop-require-default":22}],229:[function(_dereq_,module,exports){
'use strict';

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _vector = _dereq_('../../vector');

var _vector2 = _interopRequireDefault(_vector);

var _label = _dereq_('./label');

var _label2 = _interopRequireDefault(_label);

var _utilsObb = _dereq_('../../utils/obb');

var _utilsObb2 = _interopRequireDefault(_utilsObb);

var LabelLine = (function (_Label) {
    _inherits(LabelLine, _Label);

    function LabelLine(text, size, lines, options) {
        _classCallCheck(this, LabelLine);

        _get(Object.getPrototypeOf(LabelLine.prototype), 'constructor', this).call(this, text, size, options);

        this.segment_index = 0;
        this.lines = lines;
        this.update();
    }

    _createClass(LabelLine, [{
        key: 'update',
        value: function update() {
            var segment = this.currentSegment();
            this.angle = this.computeAngle();
            this.position = [(segment[0][0] + segment[1][0]) / 2, (segment[0][1] + segment[1][1]) / 2];
            this.aabb = this.computeAABB();
        }
    }, {
        key: 'moveNextSegment',
        value: function moveNextSegment() {
            if (this.segment_index + 1 >= this.lines.length - 1) {
                return false;
            }

            this.segment_index++;
            this.update();

            return true;
        }
    }, {
        key: 'computeAngle',
        value: function computeAngle() {
            var segment = this.currentSegment();
            var p0p1 = _vector2['default'].sub(segment[0], segment[1]);

            p0p1 = _vector2['default'].normalize(p0p1);

            var PI_2 = Math.PI / 2;
            var theta = Math.atan2(p0p1[0], p0p1[1]) + PI_2;

            if (theta > PI_2 || theta < -PI_2) {
                theta += Math.PI;
            }
            theta %= Math.PI * 2;

            return theta;
        }
    }, {
        key: 'fitToSegment',
        value: function fitToSegment() {
            var segment = this.currentSegment();
            var p0p1 = _vector2['default'].sub(segment[0], segment[1]);
            var length = _vector2['default'].length(p0p1);

            var label_length = this.size.collision_size[0] * this.options.units_per_pixel;

            if (label_length > length) {
                // an exceed heurestic of 100% would let the label fit in any cases
                var exceed = (1 - length / label_length) * 100;
                return exceed < this.options.line_exceed;
            }

            return label_length <= length;
        }
    }, {
        key: 'currentSegment',
        value: function currentSegment() {
            var p1 = this.lines[this.segment_index];
            var p2 = this.lines[this.segment_index + 1];

            return [p1, p2];
        }
    }, {
        key: 'computeAABB',
        value: function computeAABB() {
            var upp = this.options.units_per_pixel;
            var width = (this.size.collision_size[0] + this.options.buffer[0] * 2) * upp;
            var height = (this.size.collision_size[1] + this.options.buffer[1] * 2) * upp;

            // apply offset, x positive, y pointing down
            var offset = _vector2['default'].rot(this.options.offset, this.angle);
            var p = [this.position[0] + offset[0] * upp, this.position[1] - offset[1] * upp];

            // the angle of the obb is negative since it's the tile system y axis is pointing down
            var obb = new _utilsObb2['default'](p[0], p[1], -this.angle, width, height);
            var aabb = obb.getExtent();
            aabb.obb = obb;

            return aabb;
        }

        // Try to move the label into the tile bounds
        // Returns true if label was moved into tile, false if it couldn't be moved
    }, {
        key: 'moveIntoTile',
        value: function moveIntoTile() {
            var in_tile = false;
            var fits_to_segment = this.fitToSegment();

            // Try line segments until we find one that fits the label (and is inside the tile)
            while (!in_tile || !fits_to_segment) {
                if (!this.moveNextSegment()) {
                    break; // we can't move further in this line
                }

                in_tile = this.inTileBounds();
                fits_to_segment = this.fitToSegment();
            }

            return in_tile && fits_to_segment;
        }
    }, {
        key: 'discard',
        value: function discard(aabbs) {
            // First find a line segment that fits the label
            if (this.lines && !this.fitToSegment()) {
                while (!this.fitToSegment()) {
                    if (!this.moveNextSegment()) {
                        return true;
                    }
                }
            }

            // If label fits in line, run standard discard tests
            return _get(Object.getPrototypeOf(LabelLine.prototype), 'discard', this).call(this, aabbs);
        }
    }]);

    return LabelLine;
})(_label2['default']);

exports['default'] = LabelLine;
module.exports = exports['default'];

},{"../../utils/obb":239,"../../vector":244,"./label":227,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/get":20,"babel-runtime/helpers/inherits":21,"babel-runtime/helpers/interop-require-default":22}],230:[function(_dereq_,module,exports){
'use strict';

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _label = _dereq_('./label');

var _label2 = _interopRequireDefault(_label);

var _geo = _dereq_('../../geo');

var _geo2 = _interopRequireDefault(_geo);

var _utilsObb = _dereq_('../../utils/obb');

var _utilsObb2 = _interopRequireDefault(_utilsObb);

var _pointsPoint_anchor = _dereq_('../points/point_anchor');

var _pointsPoint_anchor2 = _interopRequireDefault(_pointsPoint_anchor);

var LabelPoint = (function (_Label) {
    _inherits(LabelPoint, _Label);

    function LabelPoint(text, position, size, options) {
        _classCallCheck(this, LabelPoint);

        _get(Object.getPrototypeOf(LabelPoint.prototype), 'constructor', this).call(this, text, size, options);
        this.position = position;
        this.update();
    }

    _createClass(LabelPoint, [{
        key: 'update',
        value: function update() {
            this.options.offset = this.computeOffset();
            this.aabb = this.computeAABB();
        }
    }, {
        key: 'computeOffset',
        value: function computeOffset() {
            return _pointsPoint_anchor2['default'].computeOffset(this.options.offset, this.size.collision_size, this.options.anchor);
        }
    }, {
        key: 'computeAABB',
        value: function computeAABB() {
            var width = (this.size.collision_size[0] + this.options.buffer[0] * 2) * this.options.units_per_pixel;
            var height = (this.size.collision_size[1] + this.options.buffer[1] * 2) * this.options.units_per_pixel;

            var p = [this.position[0] + this.options.offset[0] * this.options.units_per_pixel, this.position[1] - this.options.offset[1] * this.options.units_per_pixel];

            var obb = new _utilsObb2['default'](p[0], p[1], 0, width, height);
            var aabb = obb.getExtent();
            aabb.obb = obb;

            return aabb;
        }

        // Try to move the label into the tile bounds
        // Returns true if label was moved into tile, false if it couldn't be moved
    }, {
        key: 'moveIntoTile',
        value: function moveIntoTile() {
            var updated = false;

            if (this.aabb[0] < 0) {
                this.position[0] += -this.aabb[0];
                updated = true;
            }

            if (this.aabb[2] >= _geo2['default'].tile_scale) {
                this.position[0] -= this.aabb[2] - _geo2['default'].tile_scale + 1;
                updated = true;
            }

            if (this.aabb[3] > 0) {
                this.position[1] -= this.aabb[3];
                updated = true;
            }

            if (this.aabb[1] <= -_geo2['default'].tile_scale) {
                this.position[1] -= this.aabb[1] + _geo2['default'].tile_scale - 1;
                updated = true;
            }

            if (updated) {
                this.aabb = this.computeAABB();
            }

            return this.inTileBounds();
        }
    }]);

    return LabelPoint;
})(_label2['default']);

exports['default'] = LabelPoint;
module.exports = exports['default'];

},{"../../geo":192,"../../utils/obb":239,"../points/point_anchor":219,"./label":227,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/get":20,"babel-runtime/helpers/inherits":21,"babel-runtime/helpers/interop-require-default":22}],231:[function(_dereq_,module,exports){
'use strict';

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _geo = _dereq_('../../geo');

var _geo2 = _interopRequireDefault(_geo);

var _style_parser = _dereq_('../style_parser');

var LayoutSettings;

exports['default'] = LayoutSettings = {

    compute: function compute(feature, draw, text, context, tile) {
        var layout = {};
        layout.units_per_pixel = tile.units_per_pixel || 1;

        // label anchors (point labels only)
        // label will be adjusted in the given direction, relatove to its original point
        // one of: left, right, top, bottom, top-left, top-right, bottom-left, bottom-right
        layout.anchor = draw.anchor;

        // label offset in pixel (applied in screen space)
        layout.offset = _style_parser.StyleParser.cacheProperty(draw.offset, context) || [0, 0];

        // label buffer in pixel
        var buffer = draw.buffer;
        if (buffer != null) {
            if (!Array.isArray(buffer)) {
                buffer = [buffer, buffer]; // buffer can be 1D or 2D
            }

            buffer[0] = parseFloat(buffer[0]);
            buffer[1] = parseFloat(buffer[1]);
        }
        layout.buffer = buffer || [0, 0];

        // label priority (lower is higher)
        var priority = draw.priority;
        if (priority != null) {
            if (typeof priority === 'function') {
                priority = priority(context);
            }
        } else {
            priority = -1 >>> 0; // default to max priority value if none set
        }
        layout.priority = priority;

        // label line exceed percentage
        if (draw.line_exceed && draw.line_exceed.substr(-1) === '%') {
            layout.line_exceed = parseFloat(draw.line_exceed.substr(0, draw.line_exceed.length - 1));
        } else {
            layout.line_exceed = 80;
        }

        // repeat minimum distance
        layout.repeat_distance = _style_parser.StyleParser.cacheProperty(draw.repeat_distance, context);
        if (layout.repeat_distance == null) {
            layout.repeat_distance = _geo2['default'].tile_size;
        }
        layout.repeat_distance *= layout.units_per_pixel;

        // repeat group key
        if (typeof draw.repeat_group === 'function') {
            layout.repeat_group = draw.repeat_group(context);
        } else if (typeof draw.repeat_group === 'string') {
            layout.repeat_group = draw.repeat_group;
        } else {
            layout.repeat_group = draw.key; // default to unique set of matching layers
        }
        layout.repeat_group += '/' + text;

        // collision flag
        layout.collide = draw.collide === false ? false : true;

        // tile boundary handling
        layout.cull_from_tile = draw.cull_from_tile != null ? draw.cull_from_tile : true;
        layout.move_into_tile = draw.move_into_tile != null ? draw.move_into_tile : true;

        return layout;
    }

};
module.exports = exports['default'];

},{"../../geo":192,"../style_parser":225,"babel-runtime/helpers/interop-require-default":22}],232:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _geo = _dereq_('../../geo');

var _geo2 = _interopRequireDefault(_geo);

var RepeatGroup = (function () {
    function RepeatGroup(key, repeat_dist, max_repeat_dist) {
        _classCallCheck(this, RepeatGroup);

        this.key = key;
        this.repeat_dist = repeat_dist;
        this.repeat_dist_sq = this.repeat_dist * this.repeat_dist;
        this.max_repeat_dist_sq = max_repeat_dist * max_repeat_dist;
        this.one_per_group = this.repeat_dist_sq >= this.max_repeat_dist_sq ? true : false;
        this.positions = [];
    }

    // Current set of repeat groups, grouped and keyed by tile

    // Check an object to see if it's a repeat in this group

    _createClass(RepeatGroup, [{
        key: 'check',
        value: function check(obj) {
            // If only one object allowed per group, shortcut distance logic
            if (this.one_per_group) {
                if (this.positions.length > 0) {
                    // reported distance maxes out at threshold in this case
                    // (not true dist value since we skipped calculating it)
                    return {
                        dist_sq: this.max_repeat_dist_sq,
                        repeat_dist_sq: this.repeat_dist_sq,
                        one_per_group: this.one_per_group
                    };
                }
                return; // no object for this group yet
            }

            // Check distance from new object to objects already in group
            var p1 = obj.position;
            for (var i = 0; i < this.positions.length; i++) {
                var p2 = this.positions[i];
                var dx = p1[0] - p2[0];
                var dy = p1[1] - p2[1];
                var dist_sq = dx * dx + dy * dy;

                // Found an existing object within allowed distance
                if (dist_sq < this.repeat_dist_sq) {
                    return {
                        dist_sq: dist_sq,
                        repeat_dist_sq: this.repeat_dist_sq
                    };
                }
            }
        }

        // Add object to this group
    }, {
        key: 'add',
        value: function add(obj) {
            // only store object's position, to save space / prevent unnecessary references
            if (obj && obj.position) {
                this.positions.push(obj.position);
            }
        }

        // Static methods are used to manage repeat groups, within and across tiles

        // Reset all groups for this tile
    }], [{
        key: 'clear',
        value: function clear(tile) {
            this.groups[tile] = {};
        }

        // Check an object to see if it's a repeat within its designated group
    }, {
        key: 'check',
        value: function check(obj, layout, tile) {
            if (layout.repeat_distance && this.groups[tile][layout.repeat_group]) {
                return this.groups[tile][layout.repeat_group].check(obj);
            }
        }

        // Add an object to its designated group
    }, {
        key: 'add',
        value: function add(obj, layout, tile) {
            if (layout.repeat_distance) {
                if (this.groups[tile][layout.repeat_group] == null) {
                    this.groups[tile][layout.repeat_group] = new RepeatGroup(layout.repeat_group, layout.repeat_distance, RepeatGroup.max_repeat_dist * layout.units_per_pixel);
                }
                this.groups[tile][layout.repeat_group].add(obj);
            }
        }
    }]);

    return RepeatGroup;
})();

exports['default'] = RepeatGroup;
RepeatGroup.groups = {};

// Max repeat dist: for groups with a repeat dist beyond this threshold, only one label
// will be allowed per group, e.g. set to tile size for one-label-per-tile
RepeatGroup.max_repeat_dist = _geo2['default'].tile_size;
module.exports = exports['default'];

},{"../../geo":192,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/interop-require-default":22}],233:[function(_dereq_,module,exports){
// Text rendering style

'use strict';

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

var _Object$create = _dereq_('babel-runtime/core-js/object/create')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _glTexture = _dereq_('../../gl/texture');

var _glTexture2 = _interopRequireDefault(_glTexture);

var _utilsWorker_broker = _dereq_('../../utils/worker_broker');

var _utilsWorker_broker2 = _interopRequireDefault(_utilsWorker_broker);

var _utilsUtils = _dereq_('../../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _pointsPoints = _dereq_('../points/points');

var _canvas_text = _dereq_('./canvas_text');

var _canvas_text2 = _interopRequireDefault(_canvas_text);

var _label_builder = _dereq_('./label_builder');

var _label_builder2 = _interopRequireDefault(_label_builder);

var _text_settings = _dereq_('./text_settings');

var _text_settings2 = _interopRequireDefault(_text_settings);

var _layout_settings = _dereq_('./layout_settings');

var _layout_settings2 = _interopRequireDefault(_layout_settings);

var _repeat_group = _dereq_('./repeat_group');

var _repeat_group2 = _interopRequireDefault(_repeat_group);

var _style_parser = _dereq_('../style_parser');

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var TextStyle = _Object$create(_pointsPoints.Points);

exports.TextStyle = TextStyle;
_Object$assign(TextStyle, {
    name: 'text',
    'super': _pointsPoints.Points,
    built_in: true,
    selection: false, // no feature selection for text by default

    init: function init() {

        this['super'].init.apply(this, arguments);

        // Provide a hook for this object to be called from worker threads
        this.main_thread_target = 'TextStyle-' + this.name;
        if (_utilsUtils2['default'].isMainThread) {
            _utilsWorker_broker2['default'].addTarget(this.main_thread_target, this);
        }

        // Point style (parent class) requires texturing to be turned on
        // (labels are always drawn with textures)
        this.defines.TANGRAM_POINT_TEXTURE = true;

        // Manually un-multiply alpha, because Canvas text rasterization is pre-multiplied
        this.defines.TANGRAM_UNMULTIPLY_ALPHA = true;

        this.reset();
    },

    reset: function reset() {
        this['super'].reset.call(this);
        if (_utilsUtils2['default'].isMainThread) {
            this.canvas = new _canvas_text2['default']();
        } else if (_utilsUtils2['default'].isWorkerThread) {
            this.queues = {};
            this.texts = {}; // unique texts, grouped by tile, by style
        }
    },

    // Called on worker thread to release tile-specific resources
    freeTile: function freeTile(tile) {
        delete this.texts[tile];
    },

    // Override to queue features instead of processing immediately
    addFeature: function addFeature(feature, draw, context) {
        var tile = context.tile;
        if (tile.generation !== this.generation) {
            return;
        }

        // Called here because otherwise it will be delayed until the feature queue is parsed,
        // and we want the preprocessing done before we evaluate text style below
        draw = this.preprocess(draw);
        if (!draw) {
            return;
        }

        // Collect text - default source is feature.properties.name
        var text = undefined;
        var source = draw.text_source || 'name';

        if (typeof source === 'string') {
            text = feature.properties[source];
        } else if (typeof source === 'function') {
            text = source(context);
        }

        if (text == null) {
            return; // no text for this feature
        }

        // Compute text style and layout settings for this feature label
        var layout = _layout_settings2['default'].compute(feature, draw, text, context, tile);
        var text_settings = _text_settings2['default'].compute(feature, draw, context);
        var text_settings_key = _text_settings2['default'].key(text_settings);

        // first label in tile, or with this style?
        this.texts[tile.key] = this.texts[tile.key] || {};
        this.texts[tile.key][text_settings_key] = this.texts[tile.key][text_settings_key] || {};

        // unique text strings, grouped by text drawing style
        if (!this.texts[tile.key][text_settings_key][text]) {
            // first label with this text/style/tile combination, make a new label entry
            this.texts[tile.key][text_settings_key][text] = {
                text_settings: text_settings,
                ref: 0 // # of times this text/style combo appears in tile
            };
        }

        // Queue the feature for processing
        if (!this.tile_data[tile.key]) {
            this.startData(tile.key);
        }

        if (!this.queues[tile.key]) {
            this.queues[tile.key] = [];
        }

        // this.tile_data[tile.key].queue.push({
        this.queues[tile.key].push({
            feature: feature, draw: draw, context: context,
            text: text, text_settings_key: text_settings_key, layout: layout
        });
    },

    // Override
    endData: function endData(tile) {
        var _this = this,
            _arguments = arguments;

        var queue = this.queues[tile];
        this.queues[tile] = [];

        var count = _Object$keys(this.texts[tile] || {}).length;

        if (!count) {
            return _Promise.resolve();
        }

        // first call to main thread, ask for text pixel sizes
        return _utilsWorker_broker2['default'].postMessage(this.main_thread_target + '.calcTextSizes', tile, this.texts[tile]).then(function (texts) {
            if (!texts) {
                _this.freeTile(tile);
                return _this['super'].endData.apply(_this, _arguments);
            }
            _this.texts[tile] = texts;

            var labels = _this.createLabels(tile, queue);

            if (!labels) {
                _this.freeTile(tile);
                return _this['super'].endData.apply(_this, _arguments);
            }

            labels = _this.discardLabels(tile, labels, texts);

            // No labels for this tile
            if (_Object$keys(texts).length === 0) {
                _this.freeTile(tile);
                return _this['super'].endData.apply(_this, _arguments);
            }

            // second call to main thread, for rasterizing the set of texts
            return _utilsWorker_broker2['default'].postMessage(_this.main_thread_target + '.rasterizeTexts', tile, texts).then(function (_ref) {
                var texts = _ref.texts;
                var texture = _ref.texture;

                if (texts) {
                    _this.texts[tile] = texts;

                    // Build queued features
                    labels.forEach(function (q) {
                        var text = q.label.text;
                        var text_settings_key = q.text_settings_key;
                        var text_info = _this.texts[tile] && _this.texts[tile][text_settings_key] && _this.texts[tile][text_settings_key][text];
                        q.label.texcoords = text_info.texcoords;

                        _this['super'].addFeature.call(_this, q.feature, q.draw, q.context, q.label);
                    });
                }

                _this.freeTile(tile);

                return _this['super'].endData.apply(_this, _arguments).then(function (tile_data) {
                    // Attach tile-specific label atlas to mesh as a texture uniform
                    if (texture && tile_data) {
                        tile_data.uniforms = { u_texture: texture };
                        tile_data.textures = [texture]; // assign texture ownership to tile
                        return tile_data;
                    }
                });
            });
        });
    },

    createLabels: function createLabels(tile, feature_queue) {
        var priorities = {}; // labels, group by priority

        for (var f = 0; f < feature_queue.length; f++) {
            var _feature_queue$f = feature_queue[f];
            var feature = _feature_queue$f.feature;
            var draw = _feature_queue$f.draw;
            var context = _feature_queue$f.context;
            var text = _feature_queue$f.text;
            var text_settings_key = _feature_queue$f.text_settings_key;
            var layout = _feature_queue$f.layout;

            var text_info = this.texts[tile][text_settings_key][text];

            var labels = _label_builder2['default'].buildFromGeometry(text, text_info.size, feature.geometry, layout);
            for (var i = 0; i < labels.length; ++i) {
                var label = labels[i];
                priorities[layout.priority] = priorities[layout.priority] || [];
                priorities[layout.priority].push({
                    feature: feature, draw: draw, context: context,
                    text: text, text_settings_key: text_settings_key, layout: layout, label: label
                });
            }
        }

        return priorities;
    },

    // Test labels for collisions, higher to lower priority
    // When two collide, discard the lower-priority label
    discardLabels: function discardLabels(tile, labels, texts) {
        var aabbs = [];
        var keep_labels = [];
        _repeat_group2['default'].clear(tile);

        // Process labels by priority
        var priorities = _Object$keys(labels).sort(function (a, b) {
            return a - b;
        });
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = _getIterator(priorities), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var priority = _step.value;

                if (!labels[priority]) {
                    // no labels at this priority, skip to next
                    continue;
                }

                for (var i = 0; i < labels[priority].length; i++) {
                    var _labels$priority$i = labels[priority][i];
                    var label = _labels$priority$i.label;
                    var text_settings_key = _labels$priority$i.text_settings_key;
                    var layout = _labels$priority$i.layout;

                    var settings = texts[text_settings_key][label.text];

                    // test the label for intersections with other labels in the tile
                    if (!layout.collide || !label.discard(aabbs)) {
                        // check for repeats
                        var check = _repeat_group2['default'].check(label, layout, tile);
                        if (check) {
                            _loglevel2['default'].trace('discard label \'' + label.text + '\', (one_per_group: ' + check.one_per_group + '), dist ' + Math.sqrt(check.dist_sq) / layout.units_per_pixel + ' < ' + Math.sqrt(check.repeat_dist_sq) / layout.units_per_pixel);
                            continue;
                        }
                        // register as placed for future repeat culling
                        _repeat_group2['default'].add(label, layout, tile);

                        label.add(aabbs); // add label to currently visible set
                        keep_labels.push(labels[priority][i]);

                        // increment a count of how many times this style is used in the tile
                        settings.ref++;
                    } else if (layout.collide) {
                        _loglevel2['default'].trace('discard label \'' + label.text + '\' due to collision');
                    }
                }
            }

            // Remove text/style combinations that have no visible labels
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                    _iterator['return']();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        for (var style in texts) {
            for (var text in texts[style]) {
                // no labels for this text
                if (texts[style][text].ref < 1) {
                    delete texts[style][text];
                }
            }
        }
        for (var style in texts) {
            // no labels for this style
            if (_Object$keys(texts[style]).length === 0) {
                delete texts[style];
            }
        }

        return keep_labels;
    },

    // Called on main thread from worker, to compute the size of each text string,
    // were it to be rendered. This info is then used to perform initial label culling, *before*
    // labels are actually rendered.
    calcTextSizes: function calcTextSizes(tile, texts) {
        return this.canvas.textSizes(tile, texts);
    },

    // Called on main thread from worker, to create atlas of labels for a tile
    rasterizeTexts: function rasterizeTexts(tile, texts) {
        var canvas = new _canvas_text2['default']();
        var texture_size = canvas.setTextureTextPositions(texts);
        _loglevel2['default'].trace('text summary for tile ' + tile + ': fits in ' + texture_size[0] + 'x' + texture_size[1] + 'px');

        // update canvas size & rasterize all the text strings we need
        canvas.resize.apply(canvas, _toConsumableArray(texture_size));
        canvas.rasterize(tile, texts, texture_size);

        // create a texture
        var t = 'labels-' + tile + '-' + TextStyle.texture_id++;
        var texture = new _glTexture2['default'](this.gl, t);
        texture.setCanvas(canvas.canvas, {
            filtering: 'linear',
            UNPACK_PREMULTIPLY_ALPHA_WEBGL: true
        });

        return { texts: texts, texture: t }; // texture is returned by name (not instance)
    },

    // Sets up caching for draw rule properties
    _preprocess: function _preprocess(draw) {
        if (!draw.font) {
            return;
        }

        // Colors
        draw.font.fill = _style_parser.StyleParser.cacheObject(draw.font.fill);
        if (draw.font.stroke) {
            draw.font.stroke.color = _style_parser.StyleParser.cacheObject(draw.font.stroke.color);
        }

        // Convert font and text stroke sizes
        draw.font.px_size = _style_parser.StyleParser.cacheObject(draw.font.size, _canvas_text2['default'].fontPixelSize);
        if (draw.font.stroke && draw.font.stroke.width != null) {
            draw.font.stroke.width = _style_parser.StyleParser.cacheObject(draw.font.stroke.width, parseFloat);
        }

        // Offset (parse each array component)
        draw.offset = _style_parser.StyleParser.cacheObject(draw.offset, function (v) {
            return Array.isArray(v) && v.map(parseFloat) || 0;
        });

        // Repeat rules
        draw.repeat_distance = _style_parser.StyleParser.cacheObject(draw.repeat_distance, parseFloat);

        return draw;
    },

    // Parse feature is called "late", after all labels have been created
    // The usual parsing done by _parseFeature() is handled by addFeature() above
    // Here we just pass the label through to the build functions below
    _parseFeature: function _parseFeature(feature, draw, context, label) {
        this.feature_style.label = label;
        return this.feature_style;
    },

    build: function build(style, vertex_data) {
        var vertex_template = this.makeVertexTemplate(style);
        var label = style.label;

        this.texcoord_scale = label.texcoords;

        this.buildQuad([label.position], label.size.logical_size, _utilsUtils2['default'].radToDeg(label.angle) || 0, vertex_data, vertex_template, label.options.offset);
    },

    buildLines: function buildLines(lines, style, vertex_data) {
        this.build(style, vertex_data);
    },

    buildPoints: function buildPoints(points, style, vertex_data) {
        this.build(style, vertex_data);
    },

    buildPolygons: function buildPolygons(points, style, vertex_data) {
        this.build(style, vertex_data);
    }

});

TextStyle.texture_id = 0; // namespaces per-tile label textures

},{"../../gl/texture":200,"../../utils/utils":241,"../../utils/worker_broker":243,"../points/points":220,"../style_parser":225,"./canvas_text":226,"./label_builder":228,"./layout_settings":231,"./repeat_group":232,"./text_settings":234,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/object/create":7,"babel-runtime/core-js/object/keys":11,"babel-runtime/core-js/promise":13,"babel-runtime/helpers/interop-require-default":22,"babel-runtime/helpers/to-consumable-array":24,"loglevel":179}],234:[function(_dereq_,module,exports){
'use strict';

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsUtils = _dereq_('../../utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _geo = _dereq_('../../geo');

var _geo2 = _interopRequireDefault(_geo);

var _style_parser = _dereq_('../style_parser');

var _pointsPoint_anchor = _dereq_('../points/point_anchor');

var _pointsPoint_anchor2 = _interopRequireDefault(_pointsPoint_anchor);

var TextSettings;

exports['default'] = TextSettings = {

    // A key for grouping all labels of the same text style (e.g. same Canvas state, to minimize state changes)
    key: function key(settings) {
        return [settings.style, settings.weight, settings.family, settings.px_size, settings.fill, settings.stroke, settings.stroke_width, settings.transform, settings.typeface, settings.text_wrap, settings.align].join('/'); // typeface for legacy
    },

    defaults: {
        style: 'normal',
        weight: null,
        size: '12px',
        px_size: 12,
        family: 'Helvetica',
        fill: 'white',
        text_wrap: 15,
        align: 'center'
    },

    compute: function compute(feature, draw, context) {
        var style = {};

        draw.font = draw.font || this.defaults;

        // Use fill if specified, or default
        style.fill = draw.font.fill && _utilsUtils2['default'].toCSSColor(_style_parser.StyleParser.cacheColor(draw.font.fill, context)) || this.defaults.fill;

        // Font properties are modeled after CSS names:
        // - family: Helvetica, Futura, etc.
        // - size: in pt, px, or em
        // - style: normal, italic, oblique
        // - weight: normal, bold, etc.
        // - transform: capitalize, uppercase, lowercase
        style.style = draw.font.style || this.defaults.style;
        style.weight = draw.font.weight || this.defaults.weight;
        style.family = (draw.font.family ? draw.font.family + ', ' : '') + this.defaults.family;
        style.transform = draw.font.transform;

        // original size (not currently used, but useful for debugging)
        style.size = draw.font.size || draw.font.typeface || this.defaults.size; // TODO: 'typeface' legacy syntax, deprecate

        // calculated pixel size
        style.px_size = _style_parser.StyleParser.cacheProperty(draw.font.px_size, context) || this.defaults.px_size;

        // Use stroke if specified
        if (draw.font.stroke && draw.font.stroke.color) {
            style.stroke = _utilsUtils2['default'].toCSSColor(_style_parser.StyleParser.cacheColor(draw.font.stroke.color, context) || this.defaults.stroke);
            style.stroke_width = _style_parser.StyleParser.cacheProperty(draw.font.stroke.width, context) || this.defaults.stroke_width;
            style.stroke_width *= _utilsUtils2['default'].device_pixel_ratio;
        }

        if (draw.font.typeface) {
            // 'typeface' legacy syntax, deprecate
            style.font_css = draw.font.typeface;
        } else {
            style.font_css = this.fontCSS(style);
        }

        // Word wrap and text alignment
        // Not a font properties, but affect atlas of unique text textures
        var text_wrap = draw.text_wrap; // use explicitly set value
        if (text_wrap == null && _geo2['default'].geometryType(feature.geometry.type) !== 'line') {
            // point labels (for point and polygon features) have word wrap on w/default max length,
            // line labels default off
            text_wrap = true;
        }

        // setting to 'true' causes default wrap value to be used
        if (text_wrap === true) {
            text_wrap = this.defaults.text_wrap;
        }
        style.text_wrap = text_wrap;

        // default alignment to match anchor
        if (!draw.align && draw.anchor && draw.anchor !== 'center') {
            if (_pointsPoint_anchor2['default'].isLeftAnchor(draw.anchor)) {
                draw.align = 'right';
            } else if (_pointsPoint_anchor2['default'].isRightAnchor(draw.anchor)) {
                draw.align = 'left';
            }
        }

        style.align = draw.align || this.defaults.align;

        return style;
    },

    // Build CSS-style font string (to set Canvas draw state)
    fontCSS: function fontCSS(_ref) {
        var style = _ref.style;
        var weight = _ref.weight;
        var px_size = _ref.px_size;
        var family = _ref.family;

        return [style, weight, px_size + 'px', family].filter(function (x) {
            return x;
        }) // remove null props
        .join(' ');
    }

};
module.exports = exports['default'];

},{"../../geo":192,"../../utils/utils":241,"../points/point_anchor":219,"../style_parser":225,"babel-runtime/helpers/interop-require-default":22}],235:[function(_dereq_,module,exports){
/*global Tile */
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _toConsumableArray = _dereq_('babel-runtime/helpers/to-consumable-array')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _geo = _dereq_('./geo');

var _geo2 = _interopRequireDefault(_geo);

var _stylesStyle_parser = _dereq_('./styles/style_parser');

var _stylesStyle_manager = _dereq_('./styles/style_manager');

var _utilsWorker_broker = _dereq_('./utils/worker_broker');

var _utilsWorker_broker2 = _interopRequireDefault(_utilsWorker_broker);

var _glTexture = _dereq_('./gl/texture');

var _glTexture2 = _interopRequireDefault(_glTexture);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var Tile = (function () {

    /**
        Tile
        @constructor
        Required properties:
        coords: object with {x, y, z} properties identifying tile coordinate location
        worker: web worker to handle tile construction
    */

    function Tile(_ref) {
        var coords = _ref.coords;
        var source = _ref.source;
        var worker = _ref.worker;
        var style_zoom = _ref.style_zoom;

        _classCallCheck(this, Tile);

        _Object$assign(this, {
            coords: {
                x: null,
                y: null,
                z: null
            },
            debug: {},
            loading: false,
            loaded: false,
            error: null,
            worker: null,
            generation: null,
            visible: false,
            center_dist: 0
        });

        this.worker = worker;
        this.source = source;
        this.style_zoom = style_zoom; // zoom level to be used for styling

        this.coords = coords;
        this.coords = Tile.overZoomedCoordinate(this.coords, this.source.max_zoom);
        this.coord_key = Tile.coordKey(this.coords);
        this.key = Tile.key(this.coords, this.source, this.style_zoom);
        this.min = _geo2['default'].metersForTile(this.coords);
        this.max = _geo2['default'].metersForTile({ x: this.coords.x + 1, y: this.coords.y + 1, z: this.coords.z }), this.span = { x: this.max.x - this.min.x, y: this.max.y - this.min.y };
        this.bounds = { sw: { x: this.min.x, y: this.max.y }, ne: { x: this.max.x, y: this.min.y } };

        // Units per pixel needs to account for over-zooming
        this.units_per_pixel = _geo2['default'].units_per_pixel;
        if (this.style_zoom > this.coords.z) {
            this.units_per_pixel /= Math.pow(2, this.style_zoom - this.coords.z);
        }

        this.meshes = {}; // renderable VBO meshes keyed by style
        this.textures = []; // textures that the tile owns (labels, etc.)
    }

    _createClass(Tile, [{
        key: 'freeResources',
        value: function freeResources() {
            if (this.meshes) {
                for (var m in this.meshes) {
                    this.meshes[m].destroy();
                }
            }

            if (this.textures) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = _getIterator(this.textures), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var t = _step.value;

                        var texture = _glTexture2['default'].textures[t];
                        if (texture) {
                            texture.destroy();
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator['return']) {
                            _iterator['return']();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }

            this.meshes = {};
            this.textures = [];
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.workerMessage('self.removeTile', this.key);
            this.freeResources();
            this.worker = null;
        }
    }, {
        key: 'buildAsMessage',
        value: function buildAsMessage() {
            return {
                key: this.key,
                coord_key: this.coord_key,
                source: this.source.name,
                coords: this.coords,
                min: this.min,
                max: this.max,
                units_per_pixel: this.units_per_pixel,
                style_zoom: this.style_zoom,
                generation: this.generation,
                debug: this.debug
            };
        }
    }, {
        key: 'workerMessage',
        value: function workerMessage() {
            for (var _len = arguments.length, message = Array(_len), _key = 0; _key < _len; _key++) {
                message[_key] = arguments[_key];
            }

            return _utilsWorker_broker2['default'].postMessage.apply(_utilsWorker_broker2['default'], [this.worker].concat(message));
        }
    }, {
        key: 'build',
        value: function build(generation) {
            this.generation = generation;
            if (!this.loaded) {
                this.loading = true;
            }
            return this.workerMessage('self.buildTile', { tile: this.buildAsMessage() })['catch'](function (e) {
                throw e;
            });
        }

        // Process geometry for tile - called by web worker
        // Returns a set of tile keys that should be sent to the main thread (so that we can minimize data exchange between worker and main thread)
    }, {
        key: 'buildMeshes',

        /**
           Called on main thread when a web worker completes processing
           for a single tile.
        */
        value: function buildMeshes(styles) {
            if (this.error) {
                return;
            }

            // Cleanup existing VBOs
            this.freeResources();

            // Debug
            this.debug.geometries = 0;
            this.debug.buffer_size = 0;

            // Create VBOs
            var mesh_data = this.mesh_data;
            if (mesh_data) {
                for (var s in mesh_data) {
                    if (mesh_data[s].vertex_data) {
                        this.debug.buffer_size += mesh_data[s].vertex_data.byteLength;
                        if (!styles[s]) {
                            _loglevel2['default'].warn('Could not create mesh because style \'' + s + '\' not found, for tile ' + this.key + ', aborting tile');
                            this.meshes = {};
                            break;
                        }
                        this.meshes[s] = styles[s].makeMesh(mesh_data[s].vertex_data, mesh_data[s]);
                        this.debug.geometries += this.meshes[s].geometry_count;
                    }

                    // Assign ownership to textures if needed
                    if (mesh_data[s].textures) {
                        var _textures;

                        (_textures = this.textures).push.apply(_textures, _toConsumableArray(mesh_data[s].textures));
                    }
                }
            }

            this.debug.geom_ratio = (this.debug.geometries / this.debug.features).toFixed(1);
            this.mesh_data = null; // TODO: might want to preserve this for rebuilding geometries when styles/etc. change?
            this.printDebug();
        }

        /**
            Called on main thread when web worker completes processing, but tile has since been discarded
            Frees resources that would have been transferred to the tile object.
            Static method because the tile object no longer exists (the tile data returned by the worker is passed instead).
        */
    }, {
        key: 'printDebug',
        value: function printDebug() {
            _loglevel2['default'].debug('Tile: debug for ' + this.key + ': [  ' + JSON.stringify(this.debug) + ' ]');
        }
    }, {
        key: 'update',
        value: function update(scene) {
            var coords = this.coords;
            if (coords.z !== scene.center_tile.z) {
                coords = Tile.coordinateAtZoom(coords, scene.center_tile.z);
            }
            this.center_dist = Math.abs(scene.center_tile.x - coords.x) + Math.abs(scene.center_tile.y - coords.y);
        }

        // Slice a subset of keys out of a tile
        // Includes a minimum set of pre-defined keys for load state, debug. etc.
        // We use this to send a subset of the tile back to the main thread, to minimize unnecessary data transfer
        // (e.g. very large items like feature geometry are not needed on the main thread)
    }, {
        key: 'merge',
        value: function merge(other) {
            for (var key in other) {
                if (key !== 'key') {
                    this[key] = other[key];
                }
            }
            return this;
        }
    }], [{
        key: 'create',
        value: function create(spec) {
            return new Tile(spec);
        }
    }, {
        key: 'coordKey',
        value: function coordKey(_ref2) {
            var x = _ref2.x;
            var y = _ref2.y;
            var z = _ref2.z;

            return [x, y, z].join('/');
        }
    }, {
        key: 'key',
        value: function key(coords, source, style_zoom) {
            coords = Tile.overZoomedCoordinate(coords, source.max_zoom);
            if (coords.y < 0 || coords.y >= 1 << coords.z || coords.z < 0) {
                return; // cull tiles out of range (x will wrap)
            }
            return [source.name, style_zoom, coords.x, coords.y, coords.z].join('/');
        }
    }, {
        key: 'coordinateAtZoom',
        value: function coordinateAtZoom(_ref3, zoom) {
            var x = _ref3.x;
            var y = _ref3.y;
            var z = _ref3.z;

            if (z !== zoom) {
                var zscale = Math.pow(2, z - zoom);
                x = Math.floor(x / zscale);
                y = Math.floor(y / zscale);
            }
            return { x: x, y: y, z: zoom };
        }
    }, {
        key: 'isChild',
        value: function isChild(parent, child) {
            if (child.z > parent.z) {
                var _Tile$coordinateAtZoom = Tile.coordinateAtZoom(child, parent.z);

                var x = _Tile$coordinateAtZoom.x;
                var y = _Tile$coordinateAtZoom.y;

                return parent.x === x && parent.y === y;
            }
            return false;
        }
    }, {
        key: 'overZoomedCoordinate',
        value: function overZoomedCoordinate(_ref4, max_zoom) {
            var x = _ref4.x;
            var y = _ref4.y;
            var z = _ref4.z;

            if (max_zoom !== undefined && z > max_zoom) {
                return Tile.coordinateAtZoom({ x: x, y: y, z: z }, max_zoom);
            }
            return { x: x, y: y, z: z };
        }

        // Sort a set of tile instances (which already have a distance from center tile computed)
    }, {
        key: 'sort',
        value: function sort(tiles) {
            return tiles.sort(function (a, b) {
                var ad = a.center_dist;
                var bd = b.center_dist;
                return bd > ad ? -1 : bd === ad ? 0 : 1;
            });
        }
    }, {
        key: 'buildGeometry',
        value: function buildGeometry(tile, layers, rules, styles) {
            tile.debug.rendering = +new Date();
            tile.debug.features = 0;

            var data = tile.source_data;

            // Treat top-level style rules as 'layers'

            var _loop = function (layer_name) {
                var layer = layers[layer_name];
                // Skip layers with no data source defined
                if (!layer || !layer.data) {
                    _loglevel2['default'].warn('Layer ' + layer + ' was defined without a geometry data source and will not be rendered.');
                    return 'continue';
                }

                // Source names don't match
                if (layer.data.source !== tile.source) {
                    return 'continue';
                }

                // Get data for one or more layers from source
                var source_layers = Tile.getDataForSource(data, layer.data, layer_name);
                if (source_layers.length === 0) {
                    return 'continue';
                }

                // Render features in layer
                source_layers.forEach(function (source_layer) {
                    var geom = source_layer.geom;
                    if (!geom) {
                        return;
                    }

                    for (var f = 0; f < geom.features.length; f++) {
                        var feature = geom.features[f];
                        if (feature.geometry == null) {
                            continue; // skip features w/o geometry (valid GeoJSON)
                        }

                        var context = _stylesStyle_parser.StyleParser.getFeatureParseContext(feature, tile);
                        context.layer = source_layer.layer; // add data source layer name

                        // Get draw groups for this feature
                        var layer_rules = rules[layer_name];
                        var draw_groups = layer_rules.buildDrawGroups(context, true);
                        if (!draw_groups) {
                            continue;
                        }

                        // Render draw groups
                        for (var group_name in draw_groups) {
                            var group = draw_groups[group_name];
                            if (!group.visible) {
                                continue;
                            }

                            // Add to style
                            var style_name = group.style || group_name;
                            var style = styles[style_name];

                            if (!style) {
                                _loglevel2['default'].warn('Style \'' + style_name + '\' not found for rule in layer \'' + layer_name + '\':', group, feature);
                                continue;
                            }

                            context.properties = group.properties; // add rule-specific properties to context

                            style.addFeature(feature, group, context);

                            context.properties = null; // clear group-specific properties
                        }

                        tile.debug.features++;
                    }
                });
            };

            for (var layer_name in layers) {
                var _ret = _loop(layer_name);

                if (_ret === 'continue') continue;
            }
            tile.debug.rendering = +new Date() - tile.debug.rendering;

            // Finalize array buffer for each render style
            var tile_styles = _stylesStyle_manager.StyleManager.stylesForTile(tile.key);
            tile.mesh_data = {};
            var queue = [];
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                var _loop2 = function () {
                    var style_name = _step2.value;

                    var style = styles[style_name];
                    queue.push(style.endData(tile.key).then(function (style_data) {
                        if (style_data) {
                            tile.mesh_data[style_name] = {
                                vertex_data: style_data.vertex_data,
                                uniforms: style_data.uniforms,
                                textures: style_data.textures
                            };
                        }
                    }));
                };

                for (var _iterator2 = _getIterator(tile_styles), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    _loop2();
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                        _iterator2['return']();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            return _Promise.all(queue).then(function () {
                // Return keys to be transfered to main thread
                return ['mesh_data'];
            });
        }

        /**
            Retrieves geometry from a tile according to a data source definition
            Returns an array of objects with:
                layer: source layer name
                geom: GeoJSON FeatureCollection
        */
    }, {
        key: 'getDataForSource',
        value: function getDataForSource(source_data, source_config) {
            var default_layer = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

            var layers = [];

            if (source_config != null) {
                // If no layer specified, and a default source layer exists
                if (!source_config.layer && source_data.layers._default) {
                    layers.push({
                        layer: '_default',
                        geom: source_data.layers._default
                    });
                }
                // If no layer specified, and a default requested layer exists
                else if (!source_config.layer && default_layer) {
                        layers.push({
                            layer: default_layer,
                            geom: source_data.layers[default_layer]
                        });
                    }
                    // If a layer is specified by name, use it
                    else if (typeof source_config.layer === 'string') {
                            layers.push({
                                layer: source_config.layer,
                                geom: source_data.layers[source_config.layer]
                            });
                        }
                        // If multiple layers are specified by name, combine them
                        else if (Array.isArray(source_config.layer)) {
                                source_config.layer.forEach(function (layer) {
                                    if (source_data.layers[layer] && source_data.layers[layer].features) {
                                        layers.push({
                                            layer: layer,
                                            geom: source_data.layers[layer]
                                        });
                                    }
                                });
                            }
                            // Assemble a custom layer via a function, which is called with all source layers
                            else if (typeof source_config.layer === 'function') {
                                    layers.push({
                                        geom: source_config.layer(source_data.layers)
                                        // custom layer has no name
                                    });
                                }
            }

            return layers;
        }
    }, {
        key: 'abortBuild',
        value: function abortBuild(tile) {
            if (tile.mesh_data) {
                for (var s in tile.mesh_data) {
                    var textures = tile.mesh_data[s].textures;
                    if (textures) {
                        var _iteratorNormalCompletion3 = true;
                        var _didIteratorError3 = false;
                        var _iteratorError3 = undefined;

                        try {
                            for (var _iterator3 = _getIterator(textures), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                var t = _step3.value;

                                var texture = _glTexture2['default'].textures[t];
                                if (texture) {
                                    _loglevel2['default'].trace('destroying texture ' + t + ' for tile ' + tile.key);
                                    texture.destroy();
                                }
                            }
                        } catch (err) {
                            _didIteratorError3 = true;
                            _iteratorError3 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                                    _iterator3['return']();
                                }
                            } finally {
                                if (_didIteratorError3) {
                                    throw _iteratorError3;
                                }
                            }
                        }
                    }
                }
            }
        }
    }, {
        key: 'slice',
        value: function slice(tile, keys) {
            var keep = ['key', 'loading', 'loaded', 'generation', 'error', 'debug'];
            if (Array.isArray(keys)) {
                keep.push.apply(keep, _toConsumableArray(keys));
            }

            // Build the tile subset
            var tile_subset = {};
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
                for (var _iterator4 = _getIterator(keep), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var key = _step4.value;

                    tile_subset[key] = tile[key];
                }
            } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                        _iterator4['return']();
                    }
                } finally {
                    if (_didIteratorError4) {
                        throw _iteratorError4;
                    }
                }
            }

            return tile_subset;
        }

        /**
            Called on worker to cancel loading
            Static method because the worker only has object representations of tile data, there is no
            tile instance created yet.
        */
    }, {
        key: 'cancel',
        value: function cancel(tile) {
            if (tile) {
                if (tile.source_data && tile.source_data.request) {
                    tile.source_data.request.abort();
                }
                Tile.abortBuild(tile);
            }
        }
    }]);

    return Tile;
})();

exports['default'] = Tile;
module.exports = exports['default'];

},{"./geo":192,"./gl/texture":200,"./styles/style_manager":224,"./styles/style_parser":225,"./utils/worker_broker":243,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/promise":13,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/interop-require-default":22,"babel-runtime/helpers/to-consumable-array":24,"loglevel":179}],236:[function(_dereq_,module,exports){
'use strict';

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _tile = _dereq_('./tile');

var _tile2 = _interopRequireDefault(_tile);

var _utilsUtils = _dereq_('./utils/utils');

var _utilsUtils2 = _interopRequireDefault(_utilsUtils);

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var TileManager;

exports['default'] = TileManager = {

    init: function init(scene) {
        this.scene = scene;
        this.tiles = {};
        this.visible_coords = {};
        this.queued_coords = [];
        this.building_tiles = null;
    },

    destroy: function destroy() {
        this.forEachTile(function (tile) {
            return tile.destroy();
        });
        this.tiles = {};
        this.visible_coords = {};
        this.queued_coords = [];
        this.scene = null;
    },

    keepTile: function keepTile(tile) {
        this.tiles[tile.key] = tile;
    },

    hasTile: function hasTile(key) {
        return this.tiles[key] !== undefined;
    },

    forgetTile: function forgetTile(key) {
        delete this.tiles[key];
        this.tileBuildStop(key);
    },

    // Remove a single tile
    removeTile: function removeTile(key) {
        _loglevel2['default'].trace('tile unload for ' + key);

        var tile = this.tiles[key];

        if (tile != null) {
            tile.destroy();
        }

        this.forgetTile(tile.key);
        this.scene.requestRedraw();
    },

    // Run a function on each tile
    forEachTile: function forEachTile(func) {
        for (var t in this.tiles) {
            func(this.tiles[t]);
        }
    },

    // Remove tiles that pass a filter condition
    removeTiles: function removeTiles(filter) {
        var remove_tiles = [];
        for (var t in this.tiles) {
            var tile = this.tiles[t];
            if (filter(tile)) {
                remove_tiles.push(t);
            }
        }
        for (var r = 0; r < remove_tiles.length; r++) {
            var key = remove_tiles[r];
            this.removeTile(key);
        }
    },

    updateTilesForView: function updateTilesForView() {
        var _this = this;

        // Find visible tiles and load new ones
        this.visible_coords = {};
        var tile_coords = this.scene.findVisibleTileCoordinates();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = _getIterator(tile_coords), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var coords = _step.value;

                this.queueCoordinate(coords);
                this.visible_coords[_tile2['default'].coordKey(coords)] = coords;
            }

            // Remove tiles too far outside of view
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                    _iterator['return']();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        this.scene.pruneTileCoordinatesForView(); // TODO: return list to prune?

        this.forEachTile(function (tile) {
            _this.updateVisibility(tile);
            tile.update(_this.scene);
        });
    },

    updateVisibility: function updateVisibility(tile) {
        if (tile.style_zoom !== this.scene.tile_zoom) {
            tile.visible = false;
            return;
        }

        if (this.visible_coords[tile.coord_key]) {
            tile.visible = true;
        } else {
            // brute force
            for (var key in this.visible_coords) {
                if (_tile2['default'].isChild(tile.coords, this.visible_coords[key])) {
                    tile.visible = true;
                    return;
                }
            }

            tile.visible = false;
        }
    },

    getRenderableTiles: function getRenderableTiles() {
        var tiles = [];
        for (var t in this.tiles) {
            var tile = this.tiles[t];
            if (tile.visible && tile.loaded) {
                tiles.push(tile);
            }
        }
        return tiles;
    },

    // Queue a tile for load
    queueCoordinate: function queueCoordinate(coords) {
        this.queued_coords[this.queued_coords.length] = coords;
    },

    // Load all queued tiles
    loadQueuedCoordinates: function loadQueuedCoordinates() {
        var _this2 = this;

        if (this.queued_coords.length === 0) {
            return;
        }

        // Sort queued tiles from center tile
        this.queued_coords.sort(function (a, b) {
            var ad = Math.abs(_this2.scene.center_tile.x - a.x) + Math.abs(_this2.scene.center_tile.y - a.y);
            var bd = Math.abs(_this2.scene.center_tile.x - b.x) + Math.abs(_this2.scene.center_tile.y - b.y);
            return bd > ad ? -1 : bd === ad ? 0 : 1;
        });
        this.queued_coords.forEach(function (coords) {
            return _this2.loadCoordinate(coords);
        });
        this.queued_coords = [];
    },

    // Load all tiles to cover a given logical tile coordinate
    loadCoordinate: function loadCoordinate(coords) {
        // Skip if not at current scene zoom
        if (coords.z !== this.scene.center_tile.z) {
            return;
        }

        // Determine necessary tiles for each source
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = _getIterator(_utilsUtils2['default'].values(this.scene.sources)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var source = _step2.value;

                if (!source.tiled) {
                    continue;
                }

                var key = _tile2['default'].key(coords, source, this.scene.tile_zoom);
                if (key && !this.hasTile(key)) {
                    var tile = _tile2['default'].create({
                        source: source,
                        coords: coords,
                        // max_zoom: this.scene.findMaxZoom(), // TODO: replace with better max zoom handling
                        worker: this.scene.nextWorker(),
                        style_zoom: this.scene.styleZoom(coords.z) // TODO: replace?
                    });

                    this.keepTile(tile);
                    this.buildTile(tile);
                }
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                    _iterator2['return']();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }
    },

    // Sort and build a list of tiles
    buildTiles: function buildTiles(tiles) {
        var _this3 = this;

        _tile2['default'].sort(tiles).forEach(function (tile) {
            return _this3.buildTile(tile);
        });
        this.checkBuildQueue();
    },

    buildTile: function buildTile(tile) {
        var _this4 = this;

        this.tileBuildStart(tile.key);
        this.updateVisibility(tile);
        tile.update(this.scene);
        tile.build(this.scene.generation).then(function (message) {
            return _this4.buildTileCompleted(message);
        })['catch'](function () {
            _this4.forgetTile(tile.key);
            _tile2['default'].abortBuild(tile);
        });
    },

    // Called on main thread when a web worker completes processing for a single tile (initial load, or rebuild)
    buildTileCompleted: function buildTileCompleted(_ref) {
        var tile = _ref.tile;

        // Removed this tile during load?
        if (this.tiles[tile.key] == null) {
            _loglevel2['default'].trace('discarded tile ' + tile.key + ' in TileManager.buildTileCompleted because previously removed');
            _tile2['default'].abortBuild(tile);
            this.updateTilesForView();
        }
        // Built with an outdated scene configuration?
        else if (tile.generation !== this.scene.generation) {
                _loglevel2['default'].debug('discarded tile ' + tile.key + ' in TileManager.buildTileCompleted because built with ' + ('scene config gen ' + tile.generation + ', current ' + this.scene.generation));
                this.forgetTile(tile.key);
                _tile2['default'].abortBuild(tile);
                this.updateTilesForView();
            } else {
                // Update tile with properties from worker
                if (this.tiles[tile.key]) {
                    tile = this.tiles[tile.key].merge(tile);
                }

                this.updateVisibility(tile);
                tile.update(this.scene);
                tile.buildMeshes(this.scene.styles);
                this.scene.requestRedraw();
            }

        this.tileBuildStop(tile.key);
    },

    // Track tile build state
    tileBuildStart: function tileBuildStart(key) {
        this.building_tiles = this.building_tiles || {};
        this.building_tiles[key] = true;
        _loglevel2['default'].trace('tileBuildStart for ' + key + ': ' + _Object$keys(this.building_tiles).length);
    },

    tileBuildStop: function tileBuildStop(key) {
        // Done building?
        if (this.building_tiles) {
            _loglevel2['default'].trace('tileBuildStop for ' + key + ': ' + _Object$keys(this.building_tiles).length);
            delete this.building_tiles[key];
            this.checkBuildQueue();
        }
    },

    // Check status of tile building queue and notify scene when we're done
    checkBuildQueue: function checkBuildQueue() {
        if (!this.building_tiles || _Object$keys(this.building_tiles).length === 0) {
            this.building_tiles = null;
            this.scene.tileManagerBuildDone();
        }
    },

    // Sum of a debug property across tiles
    getDebugSum: function getDebugSum(prop, filter) {
        var sum = 0;
        for (var t in this.tiles) {
            if (this.tiles[t].debug[prop] != null && (typeof filter !== 'function' || filter(this.tiles[t]) === true)) {
                sum += this.tiles[t].debug[prop];
            }
        }
        return sum;
    },

    // Average of a debug property across tiles
    getDebugAverage: function getDebugAverage(prop, filter) {
        return this.getDebugSum(prop, filter) / _Object$keys(this.tiles).length;
    }

};
module.exports = exports['default'];

},{"./tile":235,"./utils/utils":241,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/keys":11,"babel-runtime/helpers/interop-require-default":22,"loglevel":179}],237:[function(_dereq_,module,exports){
'use strict';

var _get = _dereq_('babel-runtime/helpers/get')['default'];

var _inherits = _dereq_('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var MethodNotImplemented = (function (_Error) {
    _inherits(MethodNotImplemented, _Error);

    function MethodNotImplemented(methodName) {
        _classCallCheck(this, MethodNotImplemented);

        _get(Object.getPrototypeOf(MethodNotImplemented.prototype), 'constructor', this).call(this);
        this.name = 'MethodNotImplemented';
        this.message = 'Method ' + methodName + ' must be implemented in subclass';
    }

    return MethodNotImplemented;
})(Error);

exports.MethodNotImplemented = MethodNotImplemented;

},{"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/get":20,"babel-runtime/helpers/inherits":21}],238:[function(_dereq_,module,exports){
// Deep/recursive merge of one or more source objects into a destination object
'use strict';

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports['default'] = mergeObjects;

function mergeObjects(dest) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            sources[_key - 1] = arguments[_key];
        }

        for (var _iterator = _getIterator(sources), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var source = _step.value;

            if (!source) {
                continue;
            }
            for (var key in source) {
                var value = source[key];
                // Recursively merge the source into the destination if it is a a non-null key/value object
                // (e.g. don't merge arrays, those are treated as scalar values; null values will overwrite/erase
                // the previous destination value)
                if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                    dest[key] = mergeObjects(dest[key] || {}, value);
                }
                // Overwrite the previous destination value if the source property is: a scalar (number/string),
                // an array, or a null value
                else if (value !== undefined) {
                        dest[key] = value;
                    }
                // Undefined source properties are ignored
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
                _iterator['return']();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return dest;
}

module.exports = exports['default'];

},{"babel-runtime/core-js/get-iterator":2}],239:[function(_dereq_,module,exports){
'use strict';

var _createClass = _dereq_('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = _dereq_('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _vector = _dereq_('../vector');

var _vector2 = _interopRequireDefault(_vector);

var OBB = (function () {
    function OBB(x, y, a, w, h) {
        _classCallCheck(this, OBB);

        this.dimension = [w, h];
        this.angle = a;
        this.centroid = [x, y];
        this.quad = [];
        this.axes = [];

        this.update();
    }

    _createClass(OBB, [{
        key: 'move',
        value: function move(px, py) {
            this.centroid = [px, py];

            this.update();
        }
    }, {
        key: 'getExtent',
        value: function getExtent() {
            var inf = 1e6;
            var aabb = [inf, inf, -inf, -inf];

            for (var i = 0; i < 4; ++i) {
                aabb[0] = Math.min(this.quad[i][0], aabb[0]);
                aabb[1] = Math.min(this.quad[i][1], aabb[1]);
                aabb[2] = Math.max(this.quad[i][0], aabb[2]);
                aabb[3] = Math.max(this.quad[i][1], aabb[3]);
            }

            return aabb;
        }
    }, {
        key: 'perpAxes',
        value: function perpAxes() {
            this.axes[0] = _vector2['default'].normalize(_vector2['default'].sub(this.quad[2], this.quad[3]));
            this.axes[1] = _vector2['default'].normalize(_vector2['default'].sub(this.quad[2], this.quad[1]));
        }
    }, {
        key: 'update',
        value: function update() {
            var x = [Math.cos(this.angle), Math.sin(this.angle)];
            var y = [-Math.sin(this.angle), Math.cos(this.angle)];

            x = _vector2['default'].mult(x, this.dimension[0] / 2.0);
            y = _vector2['default'].mult(y, this.dimension[1] / 2.0);

            this.quad[0] = _vector2['default'].sub(_vector2['default'].sub(this.centroid, x), y); // lower-left
            this.quad[1] = _vector2['default'].sub(_vector2['default'].add(this.centroid, x), y); // lower-right
            this.quad[2] = _vector2['default'].add(_vector2['default'].add(this.centroid, x), y); // uper-right
            this.quad[3] = _vector2['default'].add(_vector2['default'].sub(this.centroid, x), y); // uper-left

            this.perpAxes();
        }
    }], [{
        key: 'projectToAxis',
        value: function projectToAxis(obb, axis) {
            var inf = 1e6;
            var min = inf;
            var max = -inf;

            var quad = obb.quad;

            // for each axis, project obb quad to it and find min and max values
            for (var i = 0; i < 4; ++i) {
                var d = _vector2['default'].dot(quad[i], axis);
                min = Math.min(min, d);
                max = Math.max(max, d);
            }

            return [min, max];
        }
    }, {
        key: 'axisCollide',
        value: function axisCollide(obb_a, obb_b, axes) {
            for (var i = 0; i < 2; ++i) {
                var a_proj = OBB.projectToAxis(obb_a, axes[i]);
                var b_proj = OBB.projectToAxis(obb_b, axes[i]);

                if (b_proj[0] > a_proj[1] || b_proj[1] < a_proj[0]) {
                    return false;
                }
            }
            return true;
        }
    }, {
        key: 'intersect',
        value: function intersect(obb_a, obb_b) {
            return OBB.axisCollide(obb_a, obb_b, obb_a.axes) && OBB.axisCollide(obb_a, obb_b, obb_b.axes);
        }
    }]);

    return OBB;
})();

exports['default'] = OBB;
module.exports = exports['default'];

},{"../vector":244,"babel-runtime/helpers/class-call-check":17,"babel-runtime/helpers/create-class":18,"babel-runtime/helpers/interop-require-default":22}],240:[function(_dereq_,module,exports){
'use strict';

var _Set = _dereq_('babel-runtime/core-js/set')['default'];

var _Object$assign = _dereq_('babel-runtime/core-js/object/assign')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports['default'] = subscribeMixin;

function subscribeMixin(target) {

    var listeners = new _Set();
    // var listeners = [];

    return _Object$assign(target, {

        subscribe: function subscribe(listener) {
            listeners.add(listener);
            // listeners.push(listener);
        },

        unsubscribe: function unsubscribe(listener) {
            listeners['delete'](listener);
            // var index = listeners.indexOf(listener);
            // if (index > -1) {
            //     listeners.splice(index, 1);
            // }
        },

        unsubscribeAll: function unsubscribeAll() {
            listeners.clear();
            // listeners = [];
        },

        trigger: function trigger(event) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    data[_key - 1] = arguments[_key];
                }

                for (var _iterator = _getIterator(listeners), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var listener = _step.value;

                    if (typeof listener[event] === 'function') {
                        listener[event].apply(listener, data);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator['return']) {
                        _iterator['return']();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }

    });
}

module.exports = exports['default'];

},{"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/object/assign":6,"babel-runtime/core-js/set":14}],241:[function(_dereq_,module,exports){
// Miscellaneous utilities
/*jshint worker: true*/

'use strict';

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _getIterator = _dereq_('babel-runtime/core-js/get-iterator')['default'];

var _Math$log2 = _dereq_('babel-runtime/core-js/math/log2')['default'];

var _regeneratorRuntime = _dereq_('babel-runtime/regenerator')['default'];

var _Object$keys = _dereq_('babel-runtime/core-js/object/keys')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _loglevel = _dereq_('loglevel');

var _loglevel2 = _interopRequireDefault(_loglevel);

var _jsYaml = _dereq_('js-yaml');

var _jsYaml2 = _interopRequireDefault(_jsYaml);

var _geo = _dereq_('../geo');

var _geo2 = _interopRequireDefault(_geo);

var Utils;
exports['default'] = Utils = {};

// Add a base URL for schemeless or protocol-less URLs
// Defaults to adding current window protocol and base, or adds a custom base if specified
// Maybe use https://github.com/medialize/URI.js if more robust functionality is needed
Utils.addBaseURL = function (url, base) {
    if (!url) {
        return;
    }

    // Schemeless, add protocol
    if (url.substr(0, 2) === '//') {
        url = window.location.protocol + url;
    }
    // No http(s) or data, add base
    else if (url.search(/^(http|https|data|blob):/) < 0) {
            var relative = url[0] !== '/';
            var base_info;
            if (base) {
                base_info = document.createElement('a'); // use a temporary element to parse URL
                base_info.href = base;
            } else {
                base_info = window.location;
            }

            if (relative) {
                var path = base_info.href.match(/([^\#]+)/); // strip hash
                path = path && path.length > 1 ? path[0] : '';
                url = path + url;
            } else {
                // Easy way
                if (base_info.origin) {
                    url = base_info.origin + '/' + url;
                }
                // Hard way (IE11)
                else {
                        var origin = url.match(/^((http|https|data|blob):\/\/[^\/]*\/)/);
                        origin = origin && origin.length > 1 ? origin[0] : '';
                        url = origin + url;
                    }
            }
        }
    return url;
};

Utils.pathForURL = function (url) {
    if (url && url.search(/^(data|blob):/) === -1) {
        return url.substr(0, url.lastIndexOf('/') + 1) || './';
    }
    return './';
};

Utils.cacheBusterForUrl = function (url) {
    if (url.search(/^(data|blob):/) > -1) {
        return url; // no cache-busting on object or data URLs
    }
    if (url.indexOf('?') > -1) {
        url += '&' + +new Date();
    } else {
        url += '?' + +new Date();
    }
    return url;
};

// Polyfill (for Safari compatibility)
Utils._createObjectURL = undefined;
Utils.createObjectURL = function (url) {
    if (Utils._createObjectURL === undefined) {
        Utils._createObjectURL = window.URL && window.URL.createObjectURL || window.webkitURL && window.webkitURL.createObjectURL;

        if (typeof Utils._createObjectURL !== 'function') {
            Utils._createObjectURL = null;
            _loglevel2['default'].warn('window.URL.createObjectURL (or vendor prefix) not found, unable to create local blob URLs');
        }
    }

    if (Utils._createObjectURL) {
        return Utils._createObjectURL(url);
    } else {
        return url;
    }
};

Utils.io = function (url) {
    var timeout = arguments.length <= 1 || arguments[1] === undefined ? 60000 : arguments[1];
    var responseType = arguments.length <= 2 || arguments[2] === undefined ? 'text' : arguments[2];
    var method = arguments.length <= 3 || arguments[3] === undefined ? 'GET' : arguments[3];
    var headers = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];

    var request = new XMLHttpRequest();
    var promise = new _Promise(function (resolve, reject) {
        request.open(method, url, true);
        request.timeout = timeout;
        request.responseType = responseType;
        request.onload = function () {
            if (request.status === 200) {
                if (['text', 'json'].indexOf(request.responseType) > -1) {
                    resolve(request.responseText);
                } else {
                    resolve(request.response);
                }
            } else {
                reject(Error('Request error with a status of ' + request.statusText));
            }
        };
        request.onerror = function (evt) {
            reject(Error('There was a network error' + evt.toString()));
        };
        request.ontimeout = function (evt) {
            reject(Error('timeout ' + evt.toString()));
        };
        request.send();
    });

    Object.defineProperty(promise, 'request', {
        value: request
    });

    return promise;
};

Utils.parseResource = function (body) {
    var data;
    try {
        data = _jsYaml2['default'].safeLoad(body);
    } catch (e) {
        throw e;
    }
    return data;
};

Utils.loadResource = function (source) {
    return new _Promise(function (resolve, reject) {
        if (typeof source === 'string') {
            Utils.io(Utils.cacheBusterForUrl(source)).then(function (body) {
                try {
                    var data = Utils.parseResource(body);
                    resolve(data);
                } catch (e) {
                    reject(e);
                }
            }, reject);
        } else {
            resolve(source);
        }
    });
};

// Needed for older browsers that still support WebGL (Safari 6 etc.)
Utils.requestAnimationFramePolyfill = function () {
    if (typeof window.requestAnimationFrame !== 'function') {
        window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (cb) {
            setTimeout(cb, 1000 / 60);
        };
    }
};

// Stringify an object into JSON, but convert functions to strings
Utils.serializeWithFunctions = function (obj) {
    var serialized = JSON.stringify(obj, function (k, v) {
        // Convert functions to strings
        if (typeof v === 'function') {
            return v.toString();
        }
        return v;
    });

    return serialized;
};

// Parse a JSON string, but convert function-like strings back into functions
Utils.deserializeWithFunctions = function (serialized, wrap) {
    var obj = JSON.parse(serialized);
    obj = Utils.stringsToFunctions(obj, wrap);
    return obj;
};

// Recursively parse an object, attempting to convert string properties that look like functions back into functions
Utils.stringsToFunctions = function (obj, wrap) {
    // Convert string
    if (typeof obj === 'string') {
        obj = Utils.stringToFunction(obj, wrap);
    }
    // Loop through object properties
    else if (typeof obj === 'object') {
            for (var p in obj) {
                obj[p] = Utils.stringsToFunctions(obj[p], wrap);
            }
        }
    return obj;
};

// Convert string back into a function
// TODO: make function matching tolerant of whitespace and multilines
Utils.stringToFunction = function (val, wrap) {
    // Convert strings back into functions
    if (val.match(/^\s*function\s*\w*\s*\([\s\S]*\)\s*\{[\s\S]*\}/m) != null) {
        var f;
        try {
            if (typeof wrap === 'function') {
                eval('f = ' + wrap(val)); // jshint ignore:line
            } else {
                    eval('f = ' + val); // jshint ignore:line
                }
            return f;
        } catch (e) {
            // fall-back to original value if parsing failed
            return val;
        }
    }
    return val;
};

// Log wrapper, sends message to main thread for display, and includes worker id #
Utils.log = function (level) {
    for (var _len = arguments.length, msg = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        msg[_key - 1] = arguments[_key];
    }

    level = level || 'info';
    if (Utils.isWorkerThread) {
        self.postMessage({
            type: 'log',
            level: level,
            worker_id: self._worker_id,
            msg: msg
        });
    } else if (typeof _loglevel2['default'][level] === 'function') {
        _loglevel2['default'][level].apply(_loglevel2['default'], msg);
    }
};

// Default to allowing high pixel density
// Returns true if display density changed
Utils.use_high_density_display = true;
Utils.updateDevicePixelRatio = function () {
    var prev = Utils.device_pixel_ratio;
    Utils.device_pixel_ratio = Utils.use_high_density_display && window.devicePixelRatio || 1;
    return Utils.device_pixel_ratio !== prev;
};

// Mark thread as main or worker
(function () {
    try {
        if (window.document !== undefined) {
            Utils.isWorkerThread = false;
            Utils.isMainThread = true;
            Utils.updateDevicePixelRatio();
        }
    } catch (e) {
        if (self !== undefined) {
            Utils.isWorkerThread = true;
            Utils.isMainThread = false;
        }
    }
})();

// Get URL that the current script was loaded from
// If currentScript is not available, loops through <script> elements searching for a list of provided paths
// e.g. Utils.findCurrentURL('tangram.debug.js', 'tangram.min.js');
Utils.findCurrentURL = function () {
    // Find currently executing script
    var script = document.currentScript;

    for (var _len2 = arguments.length, paths = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        paths[_key2] = arguments[_key2];
    }

    if (script) {
        return script.src;
    } else if (Array.isArray(paths)) {
        // Fallback on looping through <script> elements if document.currentScript is not supported
        var scripts = document.getElementsByTagName('script');
        for (var s = 0; s < scripts.length; s++) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = _getIterator(paths), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var path = _step.value;

                    if (scripts[s].src.indexOf(path) > -1) {
                        return scripts[s].src;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator['return']) {
                        _iterator['return']();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }
};

// Used for differentiating between power-of-2 and non-power-of-2 textures
// Via: http://stackoverflow.com/questions/19722247/webgl-wait-for-texture-to-load
Utils.isPowerOf2 = function (value) {
    return (value & value - 1) === 0;
};

Utils.nextPowerOf2 = function (value) {
    return Math.pow(2, Math.ceil(_Math$log2(value)));
};

// Interpolate 'x' along a series of control points
// 'points' is an array of control points in the form [x, y]
//
// Example:
//     Control points:
//         [0, 5]:  when x=0, y=5
//         [4, 10]: when x=4, y=10
//
//     Utils.interpolate(2, [[0, 5], [4, 10]]);
//     -> computes x=2, halfway between x=0 and x=4: (10 - 5) / 2 +5
//     -> returns 7.5
//
// TODO: add other interpolation methods besides linear
//
Utils.interpolate = function (x, points) {
    // If this doesn't resemble a list of control points, just return the original value
    if (!Array.isArray(points) || !Array.isArray(points[0])) {
        return points;
    } else if (points.length < 1) {
        return points;
    }

    var x1, x2, d, y;

    // Min bounds
    if (x <= points[0][0]) {
        y = points[0][1];
    }
    // Max bounds
    else if (x >= points[points.length - 1][0]) {
            y = points[points.length - 1][1];
        }
        // Find which control points x is between
        else {
                for (var i = 0; i < points.length - 1; i++) {
                    if (x >= points[i][0] && x < points[i + 1][0]) {
                        // Linear interpolation
                        x1 = points[i][0];
                        x2 = points[i + 1][0];

                        // Multiple values
                        if (Array.isArray(points[i][1])) {
                            y = [];
                            for (var c = 0; c < points[i][1].length; c++) {
                                d = points[i + 1][1][c] - points[i][1][c];
                                y[c] = d * (x - x1) / (x2 - x1) + points[i][1][c];
                            }
                        }
                        // Single value
                        else {
                                d = points[i + 1][1] - points[i][1];
                                y = d * (x - x1) / (x2 - x1) + points[i][1];
                            }
                        break;
                    }
                }
            }
    return y;
};

// Iterators (ES6 generators)

// Iterator for key/value pairs of an object
Utils.entries = _regeneratorRuntime.mark(function callee$0$0(obj) {
    var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, key;

    return _regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                context$1$0.prev = 3;
                _iterator2 = _getIterator(_Object$keys(obj));

            case 5:
                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                    context$1$0.next = 12;
                    break;
                }

                key = _step2.value;
                context$1$0.next = 9;
                return [key, obj[key]];

            case 9:
                _iteratorNormalCompletion2 = true;
                context$1$0.next = 5;
                break;

            case 12:
                context$1$0.next = 18;
                break;

            case 14:
                context$1$0.prev = 14;
                context$1$0.t0 = context$1$0['catch'](3);
                _didIteratorError2 = true;
                _iteratorError2 = context$1$0.t0;

            case 18:
                context$1$0.prev = 18;
                context$1$0.prev = 19;

                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                    _iterator2['return']();
                }

            case 21:
                context$1$0.prev = 21;

                if (!_didIteratorError2) {
                    context$1$0.next = 24;
                    break;
                }

                throw _iteratorError2;

            case 24:
                return context$1$0.finish(21);

            case 25:
                return context$1$0.finish(18);

            case 26:
            case 'end':
                return context$1$0.stop();
        }
    }, callee$0$0, this, [[3, 14, 18, 26], [19,, 21, 25]]);
});

// Iterator for values of an object
Utils.values = _regeneratorRuntime.mark(function callee$0$0(obj) {
    var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, key;

    return _regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                _iteratorNormalCompletion3 = true;
                _didIteratorError3 = false;
                _iteratorError3 = undefined;
                context$1$0.prev = 3;
                _iterator3 = _getIterator(_Object$keys(obj));

            case 5:
                if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                    context$1$0.next = 12;
                    break;
                }

                key = _step3.value;
                context$1$0.next = 9;
                return obj[key];

            case 9:
                _iteratorNormalCompletion3 = true;
                context$1$0.next = 5;
                break;

            case 12:
                context$1$0.next = 18;
                break;

            case 14:
                context$1$0.prev = 14;
                context$1$0.t0 = context$1$0['catch'](3);
                _didIteratorError3 = true;
                _iteratorError3 = context$1$0.t0;

            case 18:
                context$1$0.prev = 18;
                context$1$0.prev = 19;

                if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                    _iterator3['return']();
                }

            case 21:
                context$1$0.prev = 21;

                if (!_didIteratorError3) {
                    context$1$0.next = 24;
                    break;
                }

                throw _iteratorError3;

            case 24:
                return context$1$0.finish(21);

            case 25:
                return context$1$0.finish(18);

            case 26:
            case 'end':
                return context$1$0.stop();
        }
    }, callee$0$0, this, [[3, 14, 18, 26], [19,, 21, 25]]);
});

// Recursive iterators for all properties of an object, no matter how deeply nested
// TODO: fix for circular structures
Utils.recurseEntries = _regeneratorRuntime.mark(function callee$0$0(obj) {
    var _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, key;

    return _regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                if (obj) {
                    context$1$0.next = 2;
                    break;
                }

                return context$1$0.abrupt('return');

            case 2:
                _iteratorNormalCompletion4 = true;
                _didIteratorError4 = false;
                _iteratorError4 = undefined;
                context$1$0.prev = 5;
                _iterator4 = _getIterator(_Object$keys(obj));

            case 7:
                if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
                    context$1$0.next = 17;
                    break;
                }

                key = _step4.value;

                if (!obj[key]) {
                    context$1$0.next = 14;
                    break;
                }

                context$1$0.next = 12;
                return [key, obj[key], obj];

            case 12:
                if (!(typeof obj[key] === 'object')) {
                    context$1$0.next = 14;
                    break;
                }

                return context$1$0.delegateYield(Utils.recurseEntries(obj[key]), 't0', 14);

            case 14:
                _iteratorNormalCompletion4 = true;
                context$1$0.next = 7;
                break;

            case 17:
                context$1$0.next = 23;
                break;

            case 19:
                context$1$0.prev = 19;
                context$1$0.t1 = context$1$0['catch'](5);
                _didIteratorError4 = true;
                _iteratorError4 = context$1$0.t1;

            case 23:
                context$1$0.prev = 23;
                context$1$0.prev = 24;

                if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                    _iterator4['return']();
                }

            case 26:
                context$1$0.prev = 26;

                if (!_didIteratorError4) {
                    context$1$0.next = 29;
                    break;
                }

                throw _iteratorError4;

            case 29:
                return context$1$0.finish(26);

            case 30:
                return context$1$0.finish(23);

            case 31:
            case 'end':
                return context$1$0.stop();
        }
    }, callee$0$0, this, [[5, 19, 23, 31], [24,, 26, 30]]);
});

Utils.recurseValues = _regeneratorRuntime.mark(function callee$0$0(obj) {
    var _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, key;

    return _regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                if (obj) {
                    context$1$0.next = 2;
                    break;
                }

                return context$1$0.abrupt('return');

            case 2:
                _iteratorNormalCompletion5 = true;
                _didIteratorError5 = false;
                _iteratorError5 = undefined;
                context$1$0.prev = 5;
                _iterator5 = _getIterator(_Object$keys(obj));

            case 7:
                if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
                    context$1$0.next = 17;
                    break;
                }

                key = _step5.value;

                if (!obj[key]) {
                    context$1$0.next = 14;
                    break;
                }

                context$1$0.next = 12;
                return obj[key];

            case 12:
                if (!(typeof obj[key] === 'object')) {
                    context$1$0.next = 14;
                    break;
                }

                return context$1$0.delegateYield(Utils.recurseValues(obj[key]), 't0', 14);

            case 14:
                _iteratorNormalCompletion5 = true;
                context$1$0.next = 7;
                break;

            case 17:
                context$1$0.next = 23;
                break;

            case 19:
                context$1$0.prev = 19;
                context$1$0.t1 = context$1$0['catch'](5);
                _didIteratorError5 = true;
                _iteratorError5 = context$1$0.t1;

            case 23:
                context$1$0.prev = 23;
                context$1$0.prev = 24;

                if (!_iteratorNormalCompletion5 && _iterator5['return']) {
                    _iterator5['return']();
                }

            case 26:
                context$1$0.prev = 26;

                if (!_didIteratorError5) {
                    context$1$0.next = 29;
                    break;
                }

                throw _iteratorError5;

            case 29:
                return context$1$0.finish(26);

            case 30:
                return context$1$0.finish(23);

            case 31:
            case 'end':
                return context$1$0.stop();
        }
    }, callee$0$0, this, [[5, 19, 23, 31], [24,, 26, 30]]);
});

// Scale a *signed* short for use in a GL VBO
// `unit` is an optional scaling factor to mimic fixed point, since these values will be
// normalized to 0-1, e.g. divide input by unit on the way in, multiply it back in the shader
Utils.scaleInt16 = function (val, unit) {
    return val / unit * 32767;
};

Utils.degToRad = function (degrees) {
    return degrees * Math.PI / 180;
};

Utils.radToDeg = function (radians) {
    return radians * 180 / Math.PI;
};

Utils.toCSSColor = function (color) {
    if (color[3] === 1) {
        // full opacity
        return 'rgb(' + color.slice(0, 3).map(function (c) {
            return Math.round(c * 255);
        }).join(', ') + ')';
    }
    // RGB is between [0, 255] opacity is between [0, 1]
    return 'rgba(' + color.map(function (c, i) {
        return i < 3 && Math.round(c * 255) || c;
    }).join(', ') + ')';
};

Utils.pointInTile = function (point) {
    return point[0] >= 0 && point[1] > -_geo2['default'].tile_scale && point[0] < _geo2['default'].tile_scale && point[1] <= 0;
};

// http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery
Utils.hashString = function (str) {
    if (str.length === 0) {
        return 0;
    }
    var hash = 0;

    for (var i = 0, len = str.length; i < len; i++) {
        var chr = str.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash |= 0;
    }
    return hash;
};

Utils.debounce = function (func, wait, immediate) {
    var timeout = undefined;
    return function () {
        var context = this,
            args = arguments;
        var later = function later() {
            timeout = null;
            if (!immediate) {
                func.apply(context, args);
            }
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) {
            func.apply(context, args);
        }
    };
};
module.exports = exports['default'];

},{"../geo":192,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/math/log2":5,"babel-runtime/core-js/object/keys":11,"babel-runtime/core-js/promise":13,"babel-runtime/helpers/interop-require-default":22,"babel-runtime/regenerator":117,"js-yaml":148,"loglevel":179}],242:[function(_dereq_,module,exports){
"use strict";

var _Object$defineProperties = _dereq_("babel-runtime/core-js/object/define-properties")["default"];

Object.defineProperty(exports, "__esModule", {
    value: true
});
var version;
exports["default"] = version = _Object$defineProperties({
    major: 0,
    minor: 4,
    patch: 4,
    pre: false
}, {
    string: {
        get: function get() {
            return "v" + version.major + "." + version.minor + "." + version.patch;
        },
        configurable: true,
        enumerable: true
    }
});
module.exports = exports["default"];

},{"babel-runtime/core-js/object/define-properties":8}],243:[function(_dereq_,module,exports){
/*jshint worker: true*/

// WorkerBroker routes messages between web workers and the main thread, allowing for simpler
// async code via promises. Example usage:
//
// In web worker, register self as target define a method:
//
//     WorkerBroker.addTarget('self', self);
//
//     self.square = function (x) {
//         return x * x;
//     };
//
// In main thread, invoke that method and receive the result (if any) as a promise:
//
//     worker = new Worker(...);
//     WorkerBroker.addWorker(worker);
//
//     WorkerBroker.postMessage(worker, 'self.square', 5).then(function(y) {
//         console.log(y);
//     });
//
//     -> prints 25
//
// Async code:
//
// For synchronous code that must pass a return value to the main thread, the function can simply
// return an immediate value (see example above). For cases where the worker method needs to run
// asynchronous code, the function can return a promise, and the resolved or rejected value will
// be sent back to the main thread when the promise is fulfilled.
//
// Error handling:
//
// If the worker method either throws an error, or returns a promise that is rejected, it will be
// sent back to the main thread as a promise rejection. These two examples are equivalent:
//
//     In worker, throwing an error:
//
//         self.broken = function () {
//             throw new Error('error in worker!');
//         };
//
//     In worker, returning a rejected promise:
//
//         self.broken = function () {
//             return Promise.reject(new Error('error in worker!'));
//         };
//
//     In main thread, both errors are received as a promise rejection:
//
//         WorkerBroker.postMessage(worker, 'self.broken').then(
//             // Promise resolved
//             function() {
//                 console.log('success!');
//             },
//             // Promise rejected
//             function(error) {
//                 console.log('error!', error);
//             });
//
//         -> prints 'error! error in worker'
//
// Calling from worker to main thread:
//
// The same style of calls can be made *from* a web worker, to the main thread. The API is the same
// with the exception that the first argument, 'worker', is not needed for WorkerBroker.postMessage(),
// since the main thread is the implicit target.
//
// In main thread, define a method and register it:
//
//     var geometry = {
//         length: function(x, y) {
//             return Math.sqrt(x * x + y * y);
//         }
//     };
//
//     WorkerBroker.addTarget('geometry', geometry);
//
// In worker thread:
//
//     WorkerBroker.postMessage('geometry.length', 3, 4).then(function(d) {
//         console.log(d);
//     });
//
//     -> prints 5
//

'use strict';

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

var _Promise = _dereq_('babel-runtime/core-js/promise')['default'];

var _Map = _dereq_('babel-runtime/core-js/map')['default'];

var _interopRequireDefault = _dereq_('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utils = _dereq_('./utils');

var _utils2 = _interopRequireDefault(_utils);

var WorkerBroker;
exports['default'] = WorkerBroker = {};

// Global list of all worker messages
// Uniquely tracks every call made between main thread and a worker
var message_id = 0;
var messages = {};

// Register an object to receive calls from other thread
var targets = {};
WorkerBroker.addTarget = function (name, target) {
    targets[name] = target;
};

// Given a dot-notation-style method name, e.g. 'Object.object.method',
// find the object to call the method on from the list of registered targets
function findTarget(method) {
    var chain = [];
    if (typeof method === 'string') {
        chain = method.split('.');
        method = chain.pop();
    }

    // target = target || (Utils.isMainThread && window) || (Utils.isWorkerThread && self);
    var target = targets;

    for (var m = 0; m < chain.length; m++) {
        if (target[chain[m]]) {
            target = target[chain[m]];
        } else {
            return [];
        }
    }

    return [method, target];
}

// Main thread:
// - Send messages to workers, and optionally receive an async response as a promise
// - Receive messages from workers, and optionally send an async response back as a promise
function setupMainThread() {

    // Send a message to a worker, and optionally get an async response
    // Arguments:
    //   - worker: one or more web worker instances to send the message to (single value or array)
    //   - method: the method with this name, specified with dot-notation, will be invoked in the worker
    //   - message: will be passed to the method call
    // Returns:
    //   - a promise that will be fulfilled if the worker method returns a value (could be immediately, or async)
    //
    WorkerBroker.postMessage = function (worker, method) {
        for (var _len = arguments.length, message = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            message[_key - 2] = arguments[_key];
        }

        // If more than one worker specified, post to multiple
        if (Array.isArray(worker)) {
            return _Promise.all(worker.map(function (w) {
                var _WorkerBroker;

                return (_WorkerBroker = WorkerBroker).postMessage.apply(_WorkerBroker, [w, method].concat(message));
            }));
        }

        // Track state of this message
        var promise = new _Promise(function (resolve, reject) {
            messages[message_id] = { method: method, message: message, resolve: resolve, reject: reject };
        });

        worker.postMessage({
            type: 'main_send', // mark message as method invocation from main thread
            message_id: message_id, // unique id for this message, for life of program
            method: method, // will dispatch to a function of this name within the worker
            message: message // message payload
        });

        message_id++;
        return promise;
    };

    // Add a worker to communicate with - each worker must be registered from the main thread
    var worker_id = 0;
    var workers = new _Map();

    WorkerBroker.addWorker = function (worker) {

        // Keep track of all registered workers
        workers.set(worker, worker_id++);

        // Listen for messages coming back from the worker, and fulfill that message's promise
        worker.addEventListener('message', function (event) {
            if (event.data.type !== 'worker_reply') {
                return;
            }

            // Pass the result to the promise
            var id = event.data.message_id;
            if (messages[id]) {
                if (event.data.error) {
                    messages[id].reject(event.data.error);
                } else {
                    messages[id].resolve(event.data.message);
                }
                delete messages[id];
            }
        });

        // Listen for messages initiating a call from the worker, dispatch them,
        // and send any return value back to the worker
        worker.addEventListener('message', function (event) {
            // Unique id for this message & return call to main thread
            var id = event.data.message_id;
            if (event.data.type !== 'worker_send' || id == null) {
                return;
            }

            // Call the requested method and save the return value
            // var target = targets[event.data.target];

            var _findTarget = findTarget(event.data.method);

            var _findTarget2 = _slicedToArray(_findTarget, 2);

            var method_name = _findTarget2[0];
            var target = _findTarget2[1];

            if (!target) {
                throw Error('Worker broker could not dispatch message type ' + event.data.method + ' on target ' + event.data.target + ' because no object with that name is registered on main thread');
            }

            var method = typeof target[method_name] === 'function' && target[method_name];
            if (!method) {
                throw Error('Worker broker could not dispatch message type ' + event.data.method + ' on target ' + event.data.target + ' because object has no method with that name');
            }

            var result, error;
            try {
                result = method.apply(target, event.data.message);
            } catch (e) {
                // Thrown errors will be passed back (in string form) to worker
                error = e;
            }

            // Send return value to worker
            var transferables = undefined;
            // Async result
            if (result instanceof _Promise) {
                result.then(function (value) {
                    transferables = findTransferables(value);

                    worker.postMessage({
                        type: 'main_reply',
                        message_id: id,
                        message: value
                    }, transferables.map(function (t) {
                        return t.object;
                    }));

                    freeTransferables(transferables);
                    if (transferables.length > 0) {
                        _utils2['default'].log('trace', '\'' + method_name + '\' transferred ' + transferables.length + ' objects to worker thread');
                    }
                }, function (error) {
                    worker.postMessage({
                        type: 'main_reply',
                        message_id: id,
                        error: error instanceof Error ? error.message + ': ' + error.stack : error
                    });
                });
            }
            // Immediate result
            else {
                    transferables = findTransferables(result);

                    worker.postMessage({
                        type: 'main_reply',
                        message_id: id,
                        message: result,
                        error: error instanceof Error ? error.message + ': ' + error.stack : error
                    }, transferables.map(function (t) {
                        return t.object;
                    }));

                    freeTransferables(transferables);
                    if (transferables.length > 0) {
                        _utils2['default'].log('trace', '\'' + method_name + '\' transferred ' + transferables.length + ' objects to worker thread');
                    }
                }
        });
    };

    // Expose for debugging
    WorkerBroker.getMessages = function () {
        return messages;
    };

    WorkerBroker.getMessageId = function () {
        return message_id;
    };
}

// Worker threads:
// - Receive messages from main thread, and optionally send an async response back as a promise
// - Send messages to main thread, and optionally receive an async response as a promise
function setupWorkerThread() {

    // Send a message to the main thread, and optionally get an async response as a promise
    // Arguments:
    //   - method: the method with this name, specified with dot-notation, will be invoked on the main thread
    //   - message: will be passed to the method call
    // Returns:
    //   - a promise that will be fulfilled if the main thread method returns a value (could be immediately, or async)
    //
    WorkerBroker.postMessage = function (method) {
        for (var _len2 = arguments.length, message = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            message[_key2 - 1] = arguments[_key2];
        }

        // Track state of this message
        var promise = new _Promise(function (resolve, reject) {
            messages[message_id] = { method: method, message: message, resolve: resolve, reject: reject };
        });

        self.postMessage({
            type: 'worker_send', // mark message as method invocation from worker
            message_id: message_id, // unique id for this message, for life of program
            method: method, // will dispatch to a method of this name on the main thread
            message: message // message payload
        });

        message_id++;
        return promise;
    };

    // Listen for messages coming back from the main thread, and fulfill that message's promise
    self.addEventListener('message', function (event) {
        if (event.data.type !== 'main_reply') {
            return;
        }

        // Pass the result to the promise
        var id = event.data.message_id;
        if (messages[id]) {
            if (event.data.error) {
                messages[id].reject(event.data.error);
            } else {
                messages[id].resolve(event.data.message);
            }
            delete messages[id];
        }
    });

    // Receive messages from main thread, dispatch them, and send back a reply
    self.addEventListener('message', function (event) {
        // Unique id for this message & return call to main thread
        var id = event.data.message_id;
        if (event.data.type !== 'main_send' || id == null) {
            return;
        }

        // Call the requested worker method and save the return value

        var _findTarget3 = findTarget(event.data.method);

        var _findTarget32 = _slicedToArray(_findTarget3, 2);

        var method_name = _findTarget32[0];
        var target = _findTarget32[1];

        if (!target) {
            throw Error('Worker broker could not dispatch message type ' + event.data.method + ' on target ' + event.data.target + ' because no object with that name is registered on main thread');
        }

        var method = typeof target[method_name] === 'function' && target[method_name];

        if (!method) {
            throw Error('Worker broker could not dispatch message type ' + event.data.method + ' because worker has no method with that name');
        }

        var result, error;
        try {
            result = method.apply(target, event.data.message);
        } catch (e) {
            // Thrown errors will be passed back (in string form) to main thread
            error = e;
        }

        // Send return value to main thread
        var transferables = undefined;
        // Async result
        if (result instanceof _Promise) {
            result.then(function (value) {
                transferables = findTransferables(value);

                self.postMessage({
                    type: 'worker_reply',
                    message_id: id,
                    message: value
                }, transferables.map(function (t) {
                    return t.object;
                }));

                freeTransferables(transferables);
                if (transferables.length > 0) {
                    _utils2['default'].log('trace', '\'' + method_name + '\' transferred ' + transferables.length + ' objects to main thread');
                }
            }, function (error) {
                self.postMessage({
                    type: 'worker_reply',
                    message_id: id,
                    error: error instanceof Error ? error.message + ': ' + error.stack : error
                });
            });
        }
        // Immediate result
        else {
                transferables = findTransferables(result);

                self.postMessage({
                    type: 'worker_reply',
                    message_id: id,
                    message: result,
                    error: error instanceof Error ? error.message + ': ' + error.stack : error
                }, transferables.map(function (t) {
                    return t.object;
                }));

                freeTransferables(transferables);
                if (transferables.length > 0) {
                    _utils2['default'].log('trace', '\'' + method_name + '\' transferred ' + transferables.length + ' objects to main thread');
                }
            }
    });
}

// Build a list of transferable objects from a source object
// Returns a list of info about each transferable:
//   - object: the actual transferable object
//   - parent: the parent object that the transferable is a property of (if any)
//   - property: the property name of the transferable on the parent object (if any)
// TODO: add option in case you DON'T want to transfer objects
function findTransferables(source) {
    var parent = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    var property = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
    var list = arguments.length <= 3 || arguments[3] === undefined ? [] : arguments[3];

    if (!source) {
        return list;
    }

    if (Array.isArray(source)) {
        // Check each array element
        source.forEach(function (x, i) {
            return findTransferables(x, source, i, list);
        });
    } else if (typeof source === 'object') {
        // Is the object a transferable array buffer?
        if (source instanceof ArrayBuffer) {
            list.push({ object: source, parent: parent, property: property });
        }
        // Or looks like a typed array (has an array buffer property)?
        else if (source.buffer instanceof ArrayBuffer) {
                list.push({ object: source.buffer, parent: parent, property: property });
            }
            // Otherwise check each property
            else {
                    for (var prop in source) {
                        findTransferables(source[prop], source, prop, list);
                    }
                }
    }
    return list;
}

// Remove neutered transferables from parent objects, as they should no longer be accessed after transfer
function freeTransferables(transferables) {
    if (!Array.isArray(transferables)) {
        return;
    }
    transferables.filter(function (t) {
        return t.parent && t.property;
    }).forEach(function (t) {
        return delete t.parent[t.property];
    });
}

// Setup this thread as appropriate
if (_utils2['default'].isMainThread) {
    setupMainThread();
}

if (_utils2['default'].isWorkerThread) {
    setupWorkerThread();
}
module.exports = exports['default'];

},{"./utils":241,"babel-runtime/core-js/map":4,"babel-runtime/core-js/promise":13,"babel-runtime/helpers/interop-require-default":22,"babel-runtime/helpers/sliced-to-array":23}],244:[function(_dereq_,module,exports){
/*** Vector functions - vectors provided as [x, y, z] arrays ***/

'use strict';

var _slicedToArray = _dereq_('babel-runtime/helpers/sliced-to-array')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});
var Vector;
exports['default'] = Vector = {};

Vector.set = function (v) {
    var V = [];
    var lim = v.length;
    for (var i = 0; i < lim; i++) {
        V[i] = v[i];
    }
    return V;
};

Vector.neg = function (v) {
    var V = [];
    var lim = v.length;
    for (var i = 0; i < lim; i++) {
        V[i] = v[i] * -1;
    }
    return V;
};

// Addition of two vectors
Vector.add = function (v1, v2) {
    var v = [];
    var lim = Math.min(v1.length, v2.length);
    for (var i = 0; i < lim; i++) {
        v[i] = v1[i] + v2[i];
    }
    return v;
};

// Substraction of two vectors
Vector.sub = function (v1, v2) {
    var v = [];
    var lim = Math.min(v1.length, v2.length);

    for (var i = 0; i < lim; i++) {
        v[i] = v1[i] - v2[i];
    }
    return v;
};

Vector.signed_area = function (v1, v2, v3) {
    return (v2[0] - v1[0]) * (v3[1] - v1[1]) - (v3[0] - v1[0]) * (v2[1] - v1[1]);
};

// Multiplication of two vectors
Vector.mult = function (v1, v2) {
    var v = [],
        len = v1.length,
        i;

    if (typeof v2 === 'number') {
        // Mulitply by scalar
        for (i = 0; i < len; i++) {
            v[i] = v1[i] * v2;
        }
    } else {
        // Multiply two vectors
        len = Math.min(v1.length, v2.length);
        for (i = 0; i < len; i++) {
            v[i] = v1[i] * v2[i];
        }
    }
    return v;
};

// Division of two vectors
Vector.div = function (v1, v2) {
    var v = [],
        i;
    if (typeof v2 === 'number') {
        // Divide by scalar
        for (i = 0; i < v1.length; i++) {
            v[i] = v1[i] / v2;
        }
    } else {
        // Divide to vectors
        var len = Math.min(v1.length, v2.length);
        for (i = 0; i < len; i++) {
            v[i] = v1[i] / v2[i];
        }
    }
    return v;
};

// Get 2D perpendicular
Vector.perp = function (v1, v2) {
    return [v2[1] - v1[1], v1[0] - v2[0]];
};

// Get 2D vector rotated
Vector.rot = function (v, a) {
    var vr = Vector.length(v);
    var va = Vector.angle(v);
    return [vr * Math.cos(va + a), vr * Math.sin(va + a)];
};

// Get 2D heading angle
Vector.angle = function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2);

    var x = _ref2[0];
    var y = _ref2[1];

    return Math.atan2(y, x);
};

// Compare two points
Vector.isEqual = function (v1, v2) {
    var len = v1.length;
    for (var i = 0; i < len; i++) {
        if (v1[i] !== v2[i]) {
            return false;
        }
    }
    return true;
};

// Vector length squared
Vector.lengthSq = function (v) {
    if (v.length === 2) {
        return v[0] * v[0] + v[1] * v[1];
    } else {
        return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
    }
};

// Vector length
Vector.length = function (v) {
    return Math.sqrt(Vector.lengthSq(v));
};

// Normalize a vector
Vector.normalize = function (v) {
    var d;
    if (v.length === 2) {
        d = v[0] * v[0] + v[1] * v[1];
        d = Math.sqrt(d);

        if (d !== 0) {
            return [v[0] / d, v[1] / d];
        }
        return [0, 0];
    } else {
        d = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
        d = Math.sqrt(d);

        if (d !== 0) {
            return [v[0] / d, v[1] / d, v[2] / d];
        }
        return [0, 0, 0];
    }
};

// Cross product of two vectors
Vector.cross = function (v1, v2) {
    return [v1[1] * v2[2] - v1[2] * v2[1], v1[2] * v2[0] - v1[0] * v2[2], v1[0] * v2[1] - v1[1] * v2[0]];
};

// Dot product of two vectors
Vector.dot = function (v1, v2) {
    var n = 0;
    var lim = Math.min(v1.length, v2.length);
    for (var i = 0; i < lim; i++) {
        n += v1[i] * v2[i];
    }
    return n;
};

// Find the intersection of two lines specified as segments from points (p1, p2) and (p3, p4)
// http://en.wikipedia.org/wiki/Line-line_intersection
// http://en.wikipedia.org/wiki/Cramer's_rule
Vector.lineIntersection = function (p1, p2, p3, p4, parallel_tolerance) {
    parallel_tolerance = parallel_tolerance || 0.01;

    // a1*x + b1*y = c1 for line (x1, y1) to (x2, y2)
    // a2*x + b2*y = c2 for line (x3, y3) to (x4, y4)
    var a1 = p1[1] - p2[1]; // y1 - y2
    var b1 = p1[0] - p2[0]; // x1 - x2
    var a2 = p3[1] - p4[1]; // y3 - y4
    var b2 = p3[0] - p4[0]; // x3 - x4
    var c1 = p1[0] * p2[1] - p1[1] * p2[0]; // x1*y2 - y1*x2
    var c2 = p3[0] * p4[1] - p3[1] * p4[0]; // x3*y4 - y3*x4
    var denom = b1 * a2 - a1 * b2;

    if (Math.abs(denom) > parallel_tolerance) {
        return [(c1 * b2 - b1 * c2) / denom, (c1 * a2 - a1 * c2) / denom];
    }
    return null; // return null if lines are (close to) parallel
};
module.exports = exports['default'];

},{"babel-runtime/helpers/sliced-to-array":23}]},{},[208])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvaXMtaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL21hcC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbWF0aC9sb2cyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3MtY2FsbC1jaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlLWNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2dldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2ludGVyb3AtcmVxdWlyZS1kZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWQtdG8tYXJyYXkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3RvLWNvbnN1bWFibGUtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb20uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL21hcC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vbWF0aC9sb2cyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmEtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5hbi1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jbGFzc29mLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29mLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29sbGVjdGlvbi1zdHJvbmcuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmN0eC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmRlZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmRlZmluZWQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmRvbS1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5lbnVtLWtleXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5mYWlscy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmZvci1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmdldC1uYW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmhhcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmhpZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5odG1sLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaW52b2tlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmlzLWFycmF5LWl0ZXIuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pcy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmlzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItY2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLWRldGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItc3RlcC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQua2V5b2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5saWJyYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQubWljcm90YXNrLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQubWl4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQub2JqZWN0LWFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLm9iamVjdC1zYXAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5wcm9wZXJ0eS1kZXNjLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQucmVkZWYuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zYW1lLXZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc2V0LXByb3RvLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc2V0LXNwZWNpZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNoYXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zdHJpY3QtbmV3LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc3RyaW5nLWF0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudGFzay5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRvLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC50by1pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudG8tbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudWlkLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQud2tzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubWFwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5tYXRoLmxvZzIuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc2V0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9icnV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9pbnRlcnNlY3QuanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9saWIvbWVkaWFuLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL3BhcnRpdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9zb3J0LmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL3N3ZWVwLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3Qvbm9kZV9tb2R1bGVzL2JpdC10d2lkZGxlL3R3aWRkbGUuanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9ub2RlX21vZHVsZXMvdHlwZWRhcnJheS1wb29sL25vZGVfbW9kdWxlcy9kdXAvZHVwLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3Qvbm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9wb29sLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2Nzc2NvbG9ycGFyc2VyL2Nzc2NvbG9ycGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL2VhcmN1dC9zcmMvZWFyY3V0LmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL2NsaXAuanMiLCJub2RlX21vZHVsZXMvZ2VvanNvbi12dC9zcmMvY29udmVydC5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy9zaW1wbGlmeS5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy90aWxlLmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL3dyYXAuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Rpc3QvZ2wtbWF0cml4LmpzIiwibm9kZV9tb2R1bGVzL2dsLXNoYWRlci1lcnJvcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZHVtcGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZXhjZXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvbWFyay5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X3NhZmUuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZmFpbHNhZmUuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2JpbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvYm9vbC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvZmxvYXQuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2ludC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2pzL3JlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvdW5kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9tYXAuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL21lcmdlLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9udWxsLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9vbWFwLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9wYWlycy5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvc2VxLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zZXQuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3N0ci5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvdGltZXN0YW1wLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbm9kZV9tb2R1bGVzL2VzcHJpbWEvZXNwcmltYS5qcyIsIm5vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanMiLCJub2RlX21vZHVsZXMvbWF0Y2gtZmVhdHVyZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYmYvYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL3BiZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJpcC1jb21tZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90b3BvanNvbi90b3BvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9saWIvdmVjdG9ydGlsZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9saWIvdmVjdG9ydGlsZWZlYXR1cmUuanMiLCJub2RlX21vZHVsZXMvdmVjdG9yLXRpbGUvbGliL3ZlY3RvcnRpbGVsYXllci5qcyIsIm5vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9ub2RlX21vZHVsZXMvcG9pbnQtZ2VvbWV0cnkvaW5kZXguanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2NhbWVyYS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvZ2VvLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC9jb25zdGFudHMuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2dsL2NvbnRleHQuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2dsL2V4dGVuc2lvbnMuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2dsL2dsc2wuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2dsL3JlbmRlcl9zdGF0ZS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvZ2wvc2hhZGVyX3Byb2dyYW0uanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2dsL3NoYWRlcl9zb3VyY2VzLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC90ZXh0dXJlLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC92YW8uanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2dsL3Zib19tZXNoLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC92ZXJ0ZXhfZGF0YS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvZ2wvdmVydGV4X2xheW91dC5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvbGVhZmxldF9sYXllci5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvbGlnaHQuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL21hdGVyaWFsLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9tb2R1bGUuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3NjZW5lLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zY2VuZV9sb2FkZXIuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3NjZW5lX3dvcmtlci5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc2VsZWN0aW9uLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zb3VyY2VzL2RhdGFfc291cmNlLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zb3VyY2VzL2dlb2pzb24uanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3NvdXJjZXMvbXZ0LmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zb3VyY2VzL3RvcG9qc29uLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvYnVpbGRlcnMuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy9saW5lcy9saW5lcy5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc3R5bGVzL3BvaW50cy9wb2ludF9hbmNob3IuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy9wb2ludHMvcG9pbnRzLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvcG9seWdvbnMvcG9seWdvbnMuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy9ydWxlLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvc3R5bGUuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy9zdHlsZV9tYW5hZ2VyLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvc3R5bGVfcGFyc2VyLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvdGV4dC9jYW52YXNfdGV4dC5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc3R5bGVzL3RleHQvbGFiZWwuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy90ZXh0L2xhYmVsX2J1aWxkZXIuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy90ZXh0L2xhYmVsX2xpbmUuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy90ZXh0L2xhYmVsX3BvaW50LmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvdGV4dC9sYXlvdXRfc2V0dGluZ3MuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy90ZXh0L3JlcGVhdF9ncm91cC5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc3R5bGVzL3RleHQvdGV4dC5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc3R5bGVzL3RleHQvdGV4dF9zZXR0aW5ncy5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvdGlsZS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvdGlsZV9tYW5hZ2VyLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy91dGlscy9lcnJvcnMuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3V0aWxzL21lcmdlLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy91dGlscy9vYmIuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3V0aWxzL3N1YnNjcmliZS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvdXRpbHMvdXRpbHMuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3V0aWxzL3ZlcnNpb24uanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3V0aWxzL3dvcmtlcl9icm9rZXIuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3ZlY3Rvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBOztBQ0ZBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7O0FDRkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcG5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2prQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeHBJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDejBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL21MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0aEJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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RUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ3hDLGlCQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUM7S0FDM0MsTUFBTTtBQUNILFVBQUUsR0FBRyxvQkFBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdEIsVUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNWLFVBQUUsR0FBRyxvQkFBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdEIsVUFBRSxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsR0FBQyxLQUFLLENBQUEsR0FBRSxTQUFTLENBQUMsS0FBSyxHQUFHLEtBQUssR0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDMUUsVUFBRSxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsR0FBQyxLQUFLLENBQUEsR0FBRSxTQUFTLENBQUMsS0FBSyxHQUFHLEtBQUssR0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDMUUsVUFBRSxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsR0FBQyxLQUFLLENBQUEsR0FBRSxTQUFTLENBQUMsS0FBSyxHQUFHLEtBQUssR0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDMUUsaUJBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQztBQUN4QyxpQkFBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0tBQzNDOztBQUVELFVBQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUs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QUFJLENBQUMsR0FBRyxDQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDdEQsZ0JBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDOztBQUV0RCxhQUFDLEdBQUcsb0JBQU8sSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQzVDLGFBQUMsR0FBRyxvQkFBTyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7O0FBRTVDLGdCQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLG9CQUFPLEdBQUcsQ0FBQyxvQkFBTyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUMzRCxnQkFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxvQkFBTyxHQUFHLENBQUMsb0JBQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDM0QsZ0JBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsb0JBQU8sR0FBRyxDQUFDLG9CQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzNELGdCQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLG9CQUFPLEdBQUcsQ0FBQyxvQkFBTyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENB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ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb21cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL21hcFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9tYXRoL2xvZzJcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydGllc1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXNcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zZXRcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX09iamVjdCRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKVtcImRlZmF1bHRcIl07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG5cbiAgICAgIF9PYmplY3QkZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0pKCk7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfT2JqZWN0JGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpW1wiZGVmYXVsdFwiXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgX09iamVjdCRkZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIilbXCJkZWZhdWx0XCJdO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHtcbiAgdmFyIF9hZ2FpbiA9IHRydWU7XG5cbiAgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7XG4gICAgdmFyIG9iamVjdCA9IF94LFxuICAgICAgICBwcm9wZXJ0eSA9IF94MixcbiAgICAgICAgcmVjZWl2ZXIgPSBfeDM7XG4gICAgX2FnYWluID0gZmFsc2U7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gICAgdmFyIGRlc2MgPSBfT2JqZWN0JGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcblxuICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3ggPSBwYXJlbnQ7XG4gICAgICAgIF94MiA9IHByb3BlcnR5O1xuICAgICAgICBfeDMgPSByZWNlaXZlcjtcbiAgICAgICAgX2FnYWluID0gdHJ1ZTtcbiAgICAgICAgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udGludWUgX2Z1bmN0aW9uO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHtcbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9PYmplY3QkY3JlYXRlID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpW1wiZGVmYXVsdFwiXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gX09iamVjdCRjcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9PYmplY3Qkc2V0UHJvdG90eXBlT2YgPyBfT2JqZWN0JHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2dldEl0ZXJhdG9yID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3JcIilbXCJkZWZhdWx0XCJdO1xuXG52YXIgX2lzSXRlcmFibGUgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2lzLWl0ZXJhYmxlXCIpW1wiZGVmYXVsdFwiXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSBfZ2V0SXRlcmF0b3IoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmIChfaXNJdGVyYWJsZShPYmplY3QoYXJyKSkpIHtcbiAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfQXJyYXkkZnJvbSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbVwiKVtcImRlZmF1bHRcIl07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBfQXJyYXkkZnJvbShhcnIpO1xuICB9XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLkFycmF5LmZyb207IiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvcicpOyIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZScpOyIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvJC5jb3JlJykuTWFwOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm1hdGgubG9nMicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLk1hdGgubG9nMjsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuT2JqZWN0LmFzc2lnbjsiLCJ2YXIgJCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCl7XG4gIHJldHVybiAkLmNyZWF0ZShQLCBEKTtcbn07IiwidmFyICQgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhULCBEKXtcbiAgcmV0dXJuICQuc2V0RGVzY3MoVCwgRCk7XG59OyIsInZhciAkID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2Mpe1xuICByZXR1cm4gJC5zZXREZXNjKGl0LCBrZXksIGRlc2MpO1xufTsiLCJ2YXIgJCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIHJldHVybiAkLmdldERlc2MoaXQsIGtleSk7XG59OyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuT2JqZWN0LmtleXM7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kLmNvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7IiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy8kLmNvcmUnKS5Qcm9taXNlOyIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvJC5jb3JlJykuU2V0OyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLlN5bWJvbDsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQud2tzJykoJ2l0ZXJhdG9yJyk7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vJC53a3MnKSgndG9TdHJpbmdUYWcnKVxuICAvLyBFUzMgd3JvbmcgaGVyZVxuICAsIEFSRyA9IGNvZihmdW5jdGlvbigpeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gKE8gPSBPYmplY3QoaXQpKVtUQUddKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07IiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBoaWRlICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGlkZScpXG4gICwgbWl4ICAgICAgICAgID0gcmVxdWlyZSgnLi8kLm1peCcpXG4gICwgY3R4ICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgc3RyaWN0TmV3ICAgID0gcmVxdWlyZSgnLi8kLnN0cmljdC1uZXcnKVxuICAsIGRlZmluZWQgICAgICA9IHJlcXVpcmUoJy4vJC5kZWZpbmVkJylcbiAgLCBmb3JPZiAgICAgICAgPSByZXF1aXJlKCcuLyQuZm9yLW9mJylcbiAgLCAkaXRlckRlZmluZSAgPSByZXF1aXJlKCcuLyQuaXRlci1kZWZpbmUnKVxuICAsIHN0ZXAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyLXN0ZXAnKVxuICAsIElEICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC51aWQnKSgnaWQnKVxuICAsICRoYXMgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oYXMnKVxuICAsIGlzT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIHNldFNwZWNpZXMgICA9IHJlcXVpcmUoJy4vJC5zZXQtc3BlY2llcycpXG4gICwgREVTQ1JJUFRPUlMgID0gcmVxdWlyZSgnLi8kLmRlc2NyaXB0b3JzJylcbiAgLCBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGlzT2JqZWN0XG4gICwgU0laRSAgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnXG4gICwgaWQgICAgICAgICAgID0gMDtcblxudmFyIGZhc3RLZXkgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZighaXNPYmplY3QoaXQpKXJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmKCEkaGFzKGl0LCBJRCkpe1xuICAgIC8vIGNhbid0IHNldCBpZCB0byBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBpZFxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBvYmplY3QgaWRcbiAgICBoaWRlKGl0LCBJRCwgKytpZCk7XG4gIC8vIHJldHVybiBvYmplY3QgaWQgd2l0aCBwcmVmaXhcbiAgfSByZXR1cm4gJ08nICsgaXRbSURdO1xufTtcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24odGhhdCwga2V5KXtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KSwgZW50cnk7XG4gIGlmKGluZGV4ICE9PSAnRicpcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgaWYoZW50cnkuayA9PSBrZXkpcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICBzdHJpY3ROZXcodGhhdCwgQywgTkFNRSk7XG4gICAgICB0aGF0Ll9pID0gJC5jcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICBtaXgoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKXtcbiAgICAgICAgZm9yKHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICAgLCBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmKGVudHJ5KXtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5cbiAgICAgICAgICAgICwgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYocHJldilwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmKG5leHQpbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZih0aGF0Ll9mID09IGVudHJ5KXRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmKHRoYXQuX2wgPT0gZW50cnkpdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMylcbiAgICAgICAgICAsIGVudHJ5O1xuICAgICAgICB3aGlsZShlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2Ype1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYoREVTQ1JJUFRPUlMpJC5zZXREZXNjKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGRlZmluZWQodGhpc1tTSVpFXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24odGhhdCwga2V5LCB2YWx1ZSl7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KVxuICAgICAgLCBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZihlbnRyeSl7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCwgICAgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZighdGhhdC5fZil0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZihwcmV2KXByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZihpbmRleCAhPT0gJ0YnKXRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uKEMsIE5BTUUsIElTX01BUCl7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgICAgIHRoaXMuX3QgPSBpdGVyYXRlZDsgIC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbigpe1xuICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAsIGtpbmQgID0gdGhhdC5fa1xuICAgICAgICAsIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSl7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnICwgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyIGZvck9mICAgPSByZXF1aXJlKCcuLyQuZm9yLW9mJylcbiAgLCBjbGFzc29mID0gcmVxdWlyZSgnLi8kLmNsYXNzb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yT2YodGhpcywgZmFsc2UsIGFyci5wdXNoLCBhcnIpO1xuICAgIHJldHVybiBhcnI7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsICQgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIGZhaWxzICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmZhaWxzJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oaWRlJylcbiAgLCBtaXggICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5taXgnKVxuICAsIGZvck9mICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgc3RyaWN0TmV3ICAgICAgPSByZXF1aXJlKCcuLyQuc3RyaWN0LW5ldycpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0JylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vJC5kZXNjcmlwdG9ycycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLyQuc2V0LXRvLXN0cmluZy10YWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSyl7XG4gIHZhciBCYXNlICA9IGdsb2JhbFtOQU1FXVxuICAgICwgQyAgICAgPSBCYXNlXG4gICAgLCBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCdcbiAgICAsIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZVxuICAgICwgTyAgICAgPSB7fTtcbiAgaWYoIURFU0NSSVBUT1JTIHx8IHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpe1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICBtaXgoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICB9IGVsc2Uge1xuICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgaXRlcmFibGUpe1xuICAgICAgc3RyaWN0TmV3KHRhcmdldCwgQywgTkFNRSk7XG4gICAgICB0YXJnZXQuX2MgPSBuZXcgQmFzZTtcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0YXJnZXRbQURERVJdLCB0YXJnZXQpO1xuICAgIH0pO1xuICAgICQuZWFjaC5jYWxsKCdhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcycuc3BsaXQoJywnKSxmdW5jdGlvbihLRVkpe1xuICAgICAgdmFyIElTX0FEREVSID0gS0VZID09ICdhZGQnIHx8IEtFWSA9PSAnc2V0JztcbiAgICAgIGlmKEtFWSBpbiBwcm90byAmJiAhKElTX1dFQUsgJiYgS0VZID09ICdjbGVhcicpKWhpZGUoQy5wcm90b3R5cGUsIEtFWSwgZnVuY3Rpb24oYSwgYil7XG4gICAgICAgIGlmKCFJU19BRERFUiAmJiBJU19XRUFLICYmICFpc09iamVjdChhKSlyZXR1cm4gS0VZID09ICdnZXQnID8gdW5kZWZpbmVkIDogZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKCdzaXplJyBpbiBwcm90bykkLnNldERlc2MoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5fYy5zaXplO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRkZWYoJGRlZi5HICsgJGRlZi5XICsgJGRlZi5GLCBPKTtcblxuICBpZighSVNfV0VBSyljb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59OyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzEuMi41J307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLyQuYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi8kLmNvcmUnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIGN0eCA9IGZ1bmN0aW9uKGZuLCB0aGF0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xudmFyICRkZWYgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIga2V5LCBvd24sIG91dCwgZXhwXG4gICAgLCBpc0dsb2JhbCA9IHR5cGUgJiAkZGVmLkdcbiAgICAsIGlzUHJvdG8gID0gdHlwZSAmICRkZWYuUFxuICAgICwgdGFyZ2V0ICAgPSBpc0dsb2JhbCA/IGdsb2JhbCA6IHR5cGUgJiAkZGVmLlNcbiAgICAgICAgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBleHBvcnRzICA9IGlzR2xvYmFsID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIGlmKGlzR2xvYmFsKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhKHR5cGUgJiAkZGVmLkYpICYmIHRhcmdldCAmJiBrZXkgaW4gdGFyZ2V0O1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgaWYoaXNHbG9iYWwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicpZXhwID0gc291cmNlW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBlbHNlIGlmKHR5cGUgJiAkZGVmLkIgJiYgb3duKWV4cCA9IGN0eChvdXQsIGdsb2JhbCk7XG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICBlbHNlIGlmKHR5cGUgJiAkZGVmLlcgJiYgdGFyZ2V0W2tleV0gPT0gb3V0KSFmdW5jdGlvbihDKXtcbiAgICAgIGV4cCA9IGZ1bmN0aW9uKHBhcmFtKXtcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBDID8gbmV3IEMocGFyYW0pIDogQyhwYXJhbSk7XG4gICAgICB9O1xuICAgICAgZXhwW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgfShvdXQpO1xuICAgIGVsc2UgZXhwID0gaXNQcm90byAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnRcbiAgICBleHBvcnRzW2tleV0gPSBleHA7XG4gICAgaWYoaXNQcm90bykoZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSkpW2tleV0gPSBvdXQ7XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGRlZi5GID0gMTsgIC8vIGZvcmNlZFxuJGRlZi5HID0gMjsgIC8vIGdsb2JhbFxuJGRlZi5TID0gNDsgIC8vIHN0YXRpY1xuJGRlZi5QID0gODsgIC8vIHByb3RvXG4kZGVmLkIgPSAxNjsgLy8gYmluZFxuJGRlZi5XID0gMzI7IC8vIHdyYXBcbm1vZHVsZS5leHBvcnRzID0gJGRlZjsiLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi8kLmZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59OyIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgJCA9IHJlcXVpcmUoJy4vJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBrZXlzICAgICAgID0gJC5nZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9ICQuZ2V0U3ltYm9scztcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gJC5pc0VudW1cbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07IiwidmFyIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuLyQuaXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vJC5pcy1hcnJheS1pdGVyJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi8kLnRvLWxlbmd0aCcpXG4gICwgZ2V0SXRlckZuICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQpe1xuICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKGl0ZXJhYmxlKVxuICAgICwgZiAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yO1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZihpc0FycmF5SXRlcihpdGVyRm4pKWZvcihsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICB9IGVsc2UgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7ICl7XG4gICAgY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gIH1cbn07IiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKVxuICAsIGdldE5hbWVzICA9IHJlcXVpcmUoJy4vJCcpLmdldE5hbWVzO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdldE5hbWVzKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIGlmKHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nKXJldHVybiBnZXRXaW5kb3dOYW1lcyhpdCk7XG4gIHJldHVybiBnZXROYW1lcyh0b0lPYmplY3QoaXQpKTtcbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59OyIsInZhciAkICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi8kLnByb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmRlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gJC5zZXREZXNjKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTsiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vJC5jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07IiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyAgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJylcbiAgLCBJVEVSQVRPUiAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiAoSXRlcmF0b3JzLkFycmF5IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdKSA9PT0gaXQ7XG59OyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi8kLmNvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKGFyZyl7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07IiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuLyQucHJvcGVydHktZGVzYycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLyQuc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuLyQuaGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9ICQuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgICA9IHJlcXVpcmUoJy4vJC5saWJyYXJ5JylcbiAgLCAkZGVmICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkcmVkZWYgICAgICAgICAgPSByZXF1aXJlKCcuLyQucmVkZWYnKVxuICAsIGhpZGUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGFzJylcbiAgLCBTWU1CT0xfSVRFUkFUT1IgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgICAgICAgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJylcbiAgLCAkaXRlckNyZWF0ZSAgICAgPSByZXF1aXJlKCcuLyQuaXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnICA9IHJlcXVpcmUoJy4vJC5zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgZ2V0UHJvdG8gICAgICAgID0gcmVxdWlyZSgnLi8kJykuZ2V0UHJvdG9cbiAgLCBCVUdHWSAgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICAsIEZGX0lURVJBVE9SICAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgICA9ICdrZXlzJ1xuICAsIFZBTFVFUyAgICAgICAgICA9ICd2YWx1ZXMnO1xudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0Upe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuICAgICwgcHJvdG8gICAgPSBCYXNlLnByb3RvdHlwZVxuICAgICwgX25hdGl2ZSAgPSBwcm90b1tTWU1CT0xfSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCBfZGVmYXVsdCA9IF9uYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpXG4gICAgLCBtZXRob2RzLCBrZXk7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYoX25hdGl2ZSl7XG4gICAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8oX2RlZmF1bHQuY2FsbChuZXcgQmFzZSkpO1xuICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAvLyBGRiBmaXhcbiAgICBpZighTElCUkFSWSAmJiBoYXMocHJvdG8sIEZGX0lURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBTWU1CT0xfSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIUxJQlJBUlkgfHwgRk9SQ0UpICYmIChCVUdHWSB8fCAhKFNZTUJPTF9JVEVSQVRPUiBpbiBwcm90bykpKXtcbiAgICBoaWRlKHByb3RvLCBTWU1CT0xfSVRFUkFUT1IsIF9kZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IF9kZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGQVVMVCA9PSBWQUxVRVMgPyBfZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICAgICAgICAgPyBfZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6IERFRkFVTFQgIT0gVkFMVUVTID8gX2RlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKVxuICAgIH07XG4gICAgaWYoRk9SQ0UpZm9yKGtleSBpbiBtZXRob2RzKXtcbiAgICAgIGlmKCEoa2V5IGluIHByb3RvKSkkcmVkZWYocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGRlZigkZGVmLlAgKyAkZGVmLkYgKiBCVUdHWSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59OyIsInZhciBJVEVSQVRPUiAgICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbigpeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbigpeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjLCBza2lwQ2xvc2luZyl7XG4gIGlmKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKXJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyICA9IFs3XVxuICAgICAgLCBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKCl7IHNhZmUgPSB0cnVlOyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbigpeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7fTsiLCJ2YXIgJE9iamVjdCA9IE9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGU6ICAgICAkT2JqZWN0LmNyZWF0ZSxcbiAgZ2V0UHJvdG86ICAgJE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgaXNFbnVtOiAgICAge30ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gIGdldERlc2M6ICAgICRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICBzZXREZXNjOiAgICAkT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICBzZXREZXNjczogICAkT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsXG4gIGdldEtleXM6ICAgICRPYmplY3Qua2V5cyxcbiAgZ2V0TmFtZXM6ICAgJE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICBnZXRTeW1ib2xzOiAkT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgZWFjaDogICAgICAgW10uZm9yRWFjaFxufTsiLCJ2YXIgJCAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSAkLmdldEtleXMoTylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgbWFjcm90YXNrID0gcmVxdWlyZSgnLi8kLnRhc2snKS5zZXRcbiAgLCBPYnNlcnZlciAgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlclxuICAsIHByb2Nlc3MgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgaXNOb2RlICAgID0gcmVxdWlyZSgnLi8kLmNvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJ1xuICAsIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxudmFyIGZsdXNoID0gZnVuY3Rpb24oKXtcbiAgdmFyIHBhcmVudCwgZG9tYWluO1xuICBpZihpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSl7XG4gICAgcHJvY2Vzcy5kb21haW4gPSBudWxsO1xuICAgIHBhcmVudC5leGl0KCk7XG4gIH1cbiAgd2hpbGUoaGVhZCl7XG4gICAgZG9tYWluID0gaGVhZC5kb21haW47XG4gICAgaWYoZG9tYWluKWRvbWFpbi5lbnRlcigpO1xuICAgIGhlYWQuZm4uY2FsbCgpOyAvLyA8LSBjdXJyZW50bHkgd2UgdXNlIGl0IG9ubHkgZm9yIFByb21pc2UgLSB0cnkgLyBjYXRjaCBub3QgcmVxdWlyZWRcbiAgICBpZihkb21haW4pZG9tYWluLmV4aXQoKTtcbiAgICBoZWFkID0gaGVhZC5uZXh0O1xuICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gIGlmKHBhcmVudClwYXJlbnQuZW50ZXIoKTtcbn07XG5cbi8vIE5vZGUuanNcbmlmKGlzTm9kZSl7XG4gIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG4vLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbn0gZWxzZSBpZihPYnNlcnZlcil7XG4gIHZhciB0b2dnbGUgPSAxXG4gICAgLCBub2RlICAgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9IC10b2dnbGU7XG4gIH07XG4vLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuLy8gLSBzZXRJbW1lZGlhdGVcbi8vIC0gTWVzc2FnZUNoYW5uZWxcbi8vIC0gd2luZG93LnBvc3RNZXNzYWdcbi8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4vLyAtIHNldFRpbWVvdXRcbn0gZWxzZSB7XG4gIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFzYXAoZm4pe1xuICB2YXIgdGFzayA9IHtmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCwgZG9tYWluOiBpc05vZGUgJiYgcHJvY2Vzcy5kb21haW59O1xuICBpZihsYXN0KWxhc3QubmV4dCA9IHRhc2s7XG4gIGlmKCFoZWFkKXtcbiAgICBoZWFkID0gdGFzaztcbiAgICBub3RpZnkoKTtcbiAgfSBsYXN0ID0gdGFzaztcbn07IiwidmFyICRyZWRlZiA9IHJlcXVpcmUoJy4vJC5yZWRlZicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIHNyYyl7XG4gIGZvcih2YXIga2V5IGluIHNyYykkcmVkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07IiwiLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyICQgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vJC50by1vYmplY3QnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi8kLmlvYmplY3QnKTtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBhID0gT2JqZWN0LmFzc2lnblxuICAgICwgQSA9IHt9XG4gICAgLCBCID0ge31cbiAgICAsIFMgPSBTeW1ib2woKVxuICAgICwgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGspeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiBhKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKGEoe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUICAgICA9IHRvT2JqZWN0KHRhcmdldClcbiAgICAsICQkICAgID0gYXJndW1lbnRzXG4gICAgLCAkJGxlbiA9ICQkLmxlbmd0aFxuICAgICwgaW5kZXggPSAxXG4gICAgLCBnZXRLZXlzICAgID0gJC5nZXRLZXlzXG4gICAgLCBnZXRTeW1ib2xzID0gJC5nZXRTeW1ib2xzXG4gICAgLCBpc0VudW0gICAgID0gJC5pc0VudW07XG4gIHdoaWxlKCQkbGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KCQkW2luZGV4KytdKVxuICAgICAgLCBrZXlzICAgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGogICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGopaWYoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSlUW2tleV0gPSBTW2tleV07XG4gIH1cbiAgcmV0dXJuIFQ7XG59IDogT2JqZWN0LmFzc2lnbjsiLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZGVmICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIGNvcmUgID0gcmVxdWlyZSgnLi8kLmNvcmUnKVxuICAsIGZhaWxzID0gcmVxdWlyZSgnLi8kLmZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG4gIHZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICAgLCBmbiAgID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldXG4gICAgLCBleHAgID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRkZWYoJGRlZi5TICsgJGRlZi5GICogZmFpbHMoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmhpZGUnKTsiLCIvLyA3LjIuOSBTYW1lVmFsdWUoeCwgeSlcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpe1xuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcbn07IiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGdldERlc2MgID0gcmVxdWlyZSgnLi8kJykuZ2V0RGVzY1xuICAsIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi8kLmN0eCcpKEZ1bmN0aW9uLmNhbGwsIGdldERlc2MoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgY29yZSAgICAgICAgPSByZXF1aXJlKCcuLyQuY29yZScpXG4gICwgJCAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi8kLmRlc2NyaXB0b3JzJylcbiAgLCBTUEVDSUVTICAgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciBDID0gY29yZVtLRVldO1xuICBpZihERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSQuc2V0RGVzYyhDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59OyIsInZhciBkZWYgPSByZXF1aXJlKCcuLyQnKS5zZXREZXNjXG4gICwgaGFzID0gcmVxdWlyZSgnLi8kLmhhcycpXG4gICwgVEFHID0gcmVxdWlyZSgnLi8kLndrcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59OyIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vJC5hLWZ1bmN0aW9uJylcbiAgLCBTUEVDSUVTICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywgRCl7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3IsIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgQ29uc3RydWN0b3IsIG5hbWUpe1xuICBpZighKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXRocm93IFR5cGVFcnJvcihuYW1lICsgXCI6IHVzZSB0aGUgJ25ldycgb3BlcmF0b3IhXCIpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLyQudG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbFxuICAgICAgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgaW52b2tlICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmh0bWwnKVxuICAsIGNlbCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5kb20tY3JlYXRlJylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdG5lciA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYoIXNldFRhc2sgfHwgIWNsZWFyVGFzayl7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pe1xuICAgIHZhciBhcmdzID0gW10sIGkgPSAxO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpe1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZihyZXF1aXJlKCcuLyQuY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0bmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiAgIHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07IiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59OyIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuLyQuaW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vJC5kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLyQudG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07IiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuLyQuZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTsiLCJ2YXIgc3RvcmUgID0gcmVxdWlyZSgnLi8kLnNoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vJC51aWQnKVxuICAsIFN5bWJvbCA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKS5TeW1ib2w7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBTeW1ib2wgJiYgU3ltYm9sW25hbWVdIHx8IChTeW1ib2wgfHwgdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59OyIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuLyQuY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi8kLml0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTsiLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCBnZXQgICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTsiLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi8kLmNsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmNvcmUnKS5pc0l0ZXJhYmxlID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgTyA9IE9iamVjdChpdCk7XG4gIHJldHVybiBJVEVSQVRPUiBpbiBPXG4gICAgfHwgJ0BAaXRlcmF0b3InIGluIE9cbiAgICB8fCBJdGVyYXRvcnMuaGFzT3duUHJvcGVydHkoY2xhc3NvZihPKSk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsICRkZWYgICAgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuLyQudG8tb2JqZWN0JylcbiAgLCBjYWxsICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi8kLmlzLWFycmF5LWl0ZXInKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi8kLnRvLWxlbmd0aCcpXG4gICwgZ2V0SXRlckZuICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuJGRlZigkZGVmLlMgKyAkZGVmLkYgKiAhcmVxdWlyZSgnLi8kLml0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChhcnJheUxpa2UpXG4gICAgICAsIEMgICAgICAgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5XG4gICAgICAsICQkICAgICAgPSBhcmd1bWVudHNcbiAgICAgICwgJCRsZW4gICA9ICQkLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gJCRsZW4gPiAxID8gJCRbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYobWFwcGluZyltYXBmbiA9IGN0eChtYXBmbiwgJCRsZW4gPiAyID8gJCRbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQzsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLyQuYWRkLXRvLXVuc2NvcGFibGVzJylcbiAgLCBzdGVwICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKVxuICAsIHRvSU9iamVjdCAgICAgICAgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpOyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xucmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24nKSgnTWFwJywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpe1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7IiwiLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG5cbiRkZWYoJGRlZi5TLCAnTWF0aCcsIHtcbiAgbG9nMjogZnVuY3Rpb24gbG9nMih4KXtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbiAgfVxufSk7IiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4kZGVmKCRkZWYuUyArICRkZWYuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vJC5vYmplY3QtYXNzaWduJyl9KTsiLCIvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKTtcblxucmVxdWlyZSgnLi8kLm9iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgZnVuY3Rpb24oJGdldE93blByb3BlcnR5RGVzY3JpcHRvcil7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuLyQub2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24oJGtleXMpe1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG4kZGVmKCRkZWYuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi8kLnNldC1wcm90bycpLnNldH0pOyIsbnVsbCwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIExJQlJBUlkgICAgPSByZXF1aXJlKCcuLyQubGlicmFyeScpXG4gICwgZ2xvYmFsICAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIGN0eCAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBjbGFzc29mICAgID0gcmVxdWlyZSgnLi8kLmNsYXNzb2YnKVxuICAsICRkZWYgICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuLyQuYS1mdW5jdGlvbicpXG4gICwgc3RyaWN0TmV3ICA9IHJlcXVpcmUoJy4vJC5zdHJpY3QtbmV3JylcbiAgLCBmb3JPZiAgICAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgc2V0UHJvdG8gICA9IHJlcXVpcmUoJy4vJC5zZXQtcHJvdG8nKS5zZXRcbiAgLCBzYW1lICAgICAgID0gcmVxdWlyZSgnLi8kLnNhbWUtdmFsdWUnKVxuICAsIFNQRUNJRVMgICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ3NwZWNpZXMnKVxuICAsIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vJC5zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgLCBSRUNPUkQgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpKCdyZWNvcmQnKVxuICAsIGFzYXAgICAgICAgPSByZXF1aXJlKCcuLyQubWljcm90YXNrJylcbiAgLCBQUk9NSVNFICAgID0gJ1Byb21pc2UnXG4gICwgcHJvY2VzcyAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgaXNOb2RlICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgUCAgICAgICAgICA9IGdsb2JhbFtQUk9NSVNFXVxuICAsIFdyYXBwZXI7XG5cbnZhciB0ZXN0UmVzb2x2ZSA9IGZ1bmN0aW9uKHN1Yil7XG4gIHZhciB0ZXN0ID0gbmV3IFAoZnVuY3Rpb24oKXt9KTtcbiAgaWYoc3ViKXRlc3QuY29uc3RydWN0b3IgPSBPYmplY3Q7XG4gIHJldHVybiBQLnJlc29sdmUodGVzdCkgPT09IHRlc3Q7XG59O1xuXG52YXIgdXNlTmF0aXZlID0gZnVuY3Rpb24oKXtcbiAgdmFyIHdvcmtzID0gZmFsc2U7XG4gIGZ1bmN0aW9uIFAyKHgpe1xuICAgIHZhciBzZWxmID0gbmV3IFAoeCk7XG4gICAgc2V0UHJvdG8oc2VsZiwgUDIucHJvdG90eXBlKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICB0cnkge1xuICAgIHdvcmtzID0gUCAmJiBQLnJlc29sdmUgJiYgdGVzdFJlc29sdmUoKTtcbiAgICBzZXRQcm90byhQMiwgUCk7XG4gICAgUDIucHJvdG90eXBlID0gJC5jcmVhdGUoUC5wcm90b3R5cGUsIHtjb25zdHJ1Y3Rvcjoge3ZhbHVlOiBQMn19KTtcbiAgICAvLyBhY3R1YWwgRmlyZWZveCBoYXMgYnJva2VuIHN1YmNsYXNzIHN1cHBvcnQsIHRlc3QgdGhhdFxuICAgIGlmKCEoUDIucmVzb2x2ZSg1KS50aGVuKGZ1bmN0aW9uKCl7fSkgaW5zdGFuY2VvZiBQMikpe1xuICAgICAgd29ya3MgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gYWN0dWFsIFY4IGJ1ZywgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxNjJcbiAgICBpZih3b3JrcyAmJiByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKSl7XG4gICAgICB2YXIgdGhlbmFibGVUaGVuR290dGVuID0gZmFsc2U7XG4gICAgICBQLnJlc29sdmUoJC5zZXREZXNjKHt9LCAndGhlbicsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpeyB0aGVuYWJsZVRoZW5Hb3R0ZW4gPSB0cnVlOyB9XG4gICAgICB9KSk7XG4gICAgICB3b3JrcyA9IHRoZW5hYmxlVGhlbkdvdHRlbjtcbiAgICB9XG4gIH0gY2F0Y2goZSl7IHdvcmtzID0gZmFsc2U7IH1cbiAgcmV0dXJuIHdvcmtzO1xufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNQcm9taXNlID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICh1c2VOYXRpdmUgPyBjbGFzc29mKGl0KSA9PSAnUHJvbWlzZScgOiBSRUNPUkQgaW4gaXQpO1xufTtcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gbGlicmFyeSB3cmFwcGVyIHNwZWNpYWwgY2FzZVxuICBpZihMSUJSQVJZICYmIGEgPT09IFAgJiYgYiA9PT0gV3JhcHBlcilyZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHNhbWUoYSwgYik7XG59O1xudmFyIGdldENvbnN0cnVjdG9yID0gZnVuY3Rpb24oQyl7XG4gIHZhciBTID0gYW5PYmplY3QoQylbU1BFQ0lFU107XG4gIHJldHVybiBTICE9IHVuZGVmaW5lZCA/IFMgOiBDO1xufTtcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbihyZWNvcmQsIGlzUmVqZWN0KXtcbiAgaWYocmVjb3JkLm4pcmV0dXJuO1xuICByZWNvcmQubiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHJlY29yZC5jO1xuICBhc2FwKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcmVjb3JkLnZcbiAgICAgICwgb2sgICAgPSByZWNvcmQucyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Qpe1xuICAgICAgdmFyIGNiID0gb2sgPyByZWFjdC5vayA6IHJlYWN0LmZhaWxcbiAgICAgICAgLCByZXQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihjYil7XG4gICAgICAgICAgaWYoIW9rKXJlY29yZC5oID0gdHJ1ZTtcbiAgICAgICAgICByZXQgPSBjYiA9PT0gdHJ1ZSA/IHZhbHVlIDogY2IodmFsdWUpO1xuICAgICAgICAgIGlmKHJldCA9PT0gcmVhY3QuUCl7XG4gICAgICAgICAgICByZWFjdC5yZWooVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZih0aGVuID0gaXNUaGVuYWJsZShyZXQpKXtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXQsIHJlYWN0LnJlcywgcmVhY3QucmVqKTtcbiAgICAgICAgICB9IGVsc2UgcmVhY3QucmVzKHJldCk7XG4gICAgICAgIH0gZWxzZSByZWFjdC5yZWoodmFsdWUpO1xuICAgICAgfSBjYXRjaChlcnIpe1xuICAgICAgICByZWFjdC5yZWooZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIGNoYWluLmxlbmd0aCA9IDA7XG4gICAgcmVjb3JkLm4gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdClzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcHJvbWlzZSA9IHJlY29yZC5wXG4gICAgICAgICwgaGFuZGxlciwgY29uc29sZTtcbiAgICAgIGlmKGlzVW5oYW5kbGVkKHByb21pc2UpKXtcbiAgICAgICAgaWYoaXNOb2RlKXtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pe1xuICAgICAgICAgIGhhbmRsZXIoe3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWV9KTtcbiAgICAgICAgfSBlbHNlIGlmKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3Ipe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSByZWNvcmQuYSA9IHVuZGVmaW5lZDtcbiAgICB9LCAxKTtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHZhciByZWNvcmQgPSBwcm9taXNlW1JFQ09SRF1cbiAgICAsIGNoYWluICA9IHJlY29yZC5hIHx8IHJlY29yZC5jXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCByZWFjdDtcbiAgaWYocmVjb3JkLmgpcmV0dXJuIGZhbHNlO1xuICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXtcbiAgICByZWFjdCA9IGNoYWluW2krK107XG4gICAgaWYocmVhY3QuZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3QuUCkpcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcmVjb3JkID0gdGhpcztcbiAgaWYocmVjb3JkLmQpcmV0dXJuO1xuICByZWNvcmQuZCA9IHRydWU7XG4gIHJlY29yZCA9IHJlY29yZC5yIHx8IHJlY29yZDsgLy8gdW53cmFwXG4gIHJlY29yZC52ID0gdmFsdWU7XG4gIHJlY29yZC5zID0gMjtcbiAgcmVjb3JkLmEgPSByZWNvcmQuYy5zbGljZSgpO1xuICBub3RpZnkocmVjb3JkLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciByZWNvcmQgPSB0aGlzXG4gICAgLCB0aGVuO1xuICBpZihyZWNvcmQuZClyZXR1cm47XG4gIHJlY29yZC5kID0gdHJ1ZTtcbiAgcmVjb3JkID0gcmVjb3JkLnIgfHwgcmVjb3JkOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgYXNhcChmdW5jdGlvbigpe1xuICAgICAgICB2YXIgd3JhcHBlciA9IHtyOiByZWNvcmQsIGQ6IGZhbHNlfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNvcmQudiA9IHZhbHVlO1xuICAgICAgcmVjb3JkLnMgPSAxO1xuICAgICAgbm90aWZ5KHJlY29yZCwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaChlKXtcbiAgICAkcmVqZWN0LmNhbGwoe3I6IHJlY29yZCwgZDogZmFsc2V9LCBlKTsgLy8gd3JhcFxuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYoIXVzZU5hdGl2ZSl7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gIFAgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIHZhciByZWNvcmQgPSB7XG4gICAgICBwOiBzdHJpY3ROZXcodGhpcywgUCwgUFJPTUlTRSksICAgICAgICAgLy8gPC0gcHJvbWlzZVxuICAgICAgYzogW10sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgICAgYTogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgICBzOiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICAgIGQ6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBkb25lXG4gICAgICB2OiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgIGg6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBoYW5kbGVkIHJlamVjdGlvblxuICAgICAgbjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICAgIH07XG4gICAgdGhpc1tSRUNPUkRdID0gcmVjb3JkO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHJlY29yZCwgMSksIGN0eCgkcmVqZWN0LCByZWNvcmQsIDEpKTtcbiAgICB9IGNhdGNoKGVycil7XG4gICAgICAkcmVqZWN0LmNhbGwocmVjb3JkLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgcmVxdWlyZSgnLi8kLm1peCcpKFAucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKXtcbiAgICAgIHZhciByZWFjdCA9IHtcbiAgICAgICAgb2s6ICAgdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWUsXG4gICAgICAgIGZhaWw6IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgID8gb25SZWplY3RlZCAgOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHZhciBwcm9taXNlID0gcmVhY3QuUCA9IG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIFApKShmdW5jdGlvbihyZXMsIHJlail7XG4gICAgICAgIHJlYWN0LnJlcyA9IHJlcztcbiAgICAgICAgcmVhY3QucmVqID0gcmVqO1xuICAgICAgfSk7XG4gICAgICBhRnVuY3Rpb24ocmVhY3QucmVzKTtcbiAgICAgIGFGdW5jdGlvbihyZWFjdC5yZWopO1xuICAgICAgdmFyIHJlY29yZCA9IHRoaXNbUkVDT1JEXTtcbiAgICAgIHJlY29yZC5jLnB1c2gocmVhY3QpO1xuICAgICAgaWYocmVjb3JkLmEpcmVjb3JkLmEucHVzaChyZWFjdCk7XG4gICAgICBpZihyZWNvcmQucylub3RpZnkocmVjb3JkLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3RlZCl7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gZXhwb3J0XG4kZGVmKCRkZWYuRyArICRkZWYuVyArICRkZWYuRiAqICF1c2VOYXRpdmUsIHtQcm9taXNlOiBQfSk7XG5yZXF1aXJlKCcuLyQuc2V0LXRvLXN0cmluZy10YWcnKShQLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vJC5zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vJC5jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRkZWYoJGRlZi5TICsgJGRlZi5GICogIXVzZU5hdGl2ZSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKXtcbiAgICByZXR1cm4gbmV3IHRoaXMoZnVuY3Rpb24ocmVzLCByZWopeyByZWoocik7IH0pO1xuICB9XG59KTtcbiRkZWYoJGRlZi5TICsgJGRlZi5GICogKCF1c2VOYXRpdmUgfHwgdGVzdFJlc29sdmUodHJ1ZSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpe1xuICAgIHJldHVybiBpc1Byb21pc2UoeCkgJiYgc2FtZUNvbnN0cnVjdG9yKHguY29uc3RydWN0b3IsIHRoaXMpXG4gICAgICA/IHggOiBuZXcgdGhpcyhmdW5jdGlvbihyZXMpeyByZXMoeCk7IH0pO1xuICB9XG59KTtcbiRkZWYoJGRlZi5TICsgJGRlZi5GICogISh1c2VOYXRpdmUgJiYgcmVxdWlyZSgnLi8kLml0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gIFAuYWxsKGl0ZXIpWydjYXRjaCddKGZ1bmN0aW9uKCl7fSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgID0gZ2V0Q29uc3RydWN0b3IodGhpcylcbiAgICAgICwgdmFsdWVzID0gW107XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uKHJlcywgcmVqKXtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgdmFsdWVzLnB1c2gsIHZhbHVlcyk7XG4gICAgICB2YXIgcmVtYWluaW5nID0gdmFsdWVzLmxlbmd0aFxuICAgICAgICAsIHJlc3VsdHMgICA9IEFycmF5KHJlbWFpbmluZyk7XG4gICAgICBpZihyZW1haW5pbmcpJC5lYWNoLmNhbGwodmFsdWVzLCBmdW5jdGlvbihwcm9taXNlLCBpbmRleCl7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlcyhyZXN1bHRzKTtcbiAgICAgICAgfSwgcmVqKTtcbiAgICAgIH0pO1xuICAgICAgZWxzZSByZXMocmVzdWx0cyk7XG4gICAgfSk7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSl7XG4gICAgdmFyIEMgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24ocmVzLCByZWope1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4ocmVzLCByZWopO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24nKSgnU2V0JywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCAgPSByZXF1aXJlKCcuLyQuc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vJC5pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciAkICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oYXMnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi8kLmRlc2NyaXB0b3JzJylcbiAgLCAkZGVmICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICRyZWRlZiAgICAgICAgID0gcmVxdWlyZSgnLi8kLnJlZGVmJylcbiAgLCAkZmFpbHMgICAgICAgICA9IHJlcXVpcmUoJy4vJC5mYWlscycpXG4gICwgc2hhcmVkICAgICAgICAgPSByZXF1aXJlKCcuLyQuc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vJC5zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgdWlkICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQudWlkJylcbiAgLCB3a3MgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC53a3MnKVxuICAsIGtleU9mICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmtleW9mJylcbiAgLCAkbmFtZXMgICAgICAgICA9IHJlcXVpcmUoJy4vJC5nZXQtbmFtZXMnKVxuICAsIGVudW1LZXlzICAgICAgID0gcmVxdWlyZSgnLi8kLmVudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuLyQuaXMtYXJyYXknKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuLyQucHJvcGVydHktZGVzYycpXG4gICwgZ2V0RGVzYyAgICAgICAgPSAkLmdldERlc2NcbiAgLCBzZXREZXNjICAgICAgICA9ICQuc2V0RGVzY1xuICAsIF9jcmVhdGUgICAgICAgID0gJC5jcmVhdGVcbiAgLCBnZXROYW1lcyAgICAgICA9ICRuYW1lcy5nZXRcbiAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcbiAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG4gICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcbiAgLCBzZXR0ZXIgICAgICAgICA9IGZhbHNlXG4gICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuICAsIGlzRW51bSAgICAgICAgID0gJC5pc0VudW1cbiAgLCBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5JylcbiAgLCBBbGxTeW1ib2xzICAgICA9IHNoYXJlZCgnc3ltYm9scycpXG4gICwgdXNlTmF0aXZlICAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBfY3JlYXRlKHNldERlc2Moe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHNldERlc2ModGhpcywgJ2EnLCB7dmFsdWU6IDd9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uKGl0LCBrZXksIEQpe1xuICB2YXIgcHJvdG9EZXNjID0gZ2V0RGVzYyhPYmplY3RQcm90bywga2V5KTtcbiAgaWYocHJvdG9EZXNjKWRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBzZXREZXNjKGl0LCBrZXksIEQpO1xuICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKXNldERlc2MoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBzZXREZXNjO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uKHRhZyl7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2wucHJvdG90eXBlKTtcbiAgc3ltLl9rID0gdGFnO1xuICBERVNDUklQVE9SUyAmJiBzZXR0ZXIgJiYgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpe1xuICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpe1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpc2V0RGVzYyhpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwge2VudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gc2V0RGVzYyhpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpXG4gICAgLCBpICAgID0gMFxuICAgICwgbCA9IGtleXMubGVuZ3RoXG4gICAgLCBrZXk7XG4gIHdoaWxlKGwgPiBpKSRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5KTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XVxuICAgID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIHZhciBEID0gZ2V0RGVzYyhpdCA9IHRvSU9iamVjdChpdCksIGtleSk7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdldE5hbWVzKHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTilyZXN1bHQucHVzaChrZXkpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdldE5hbWVzKHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXtcbiAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gIHZhciBhcmdzID0gW2l0XVxuICAgICwgaSAgICA9IDFcbiAgICAsICQkICAgPSBhcmd1bWVudHNcbiAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gIHdoaWxlKCQkLmxlbmd0aCA+IGkpYXJncy5wdXNoKCQkW2krK10pO1xuICByZXBsYWNlciA9IGFyZ3NbMV07XG4gIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICBpZigkcmVwbGFjZXIgfHwgIWlzQXJyYXkocmVwbGFjZXIpKXJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XG4gIH07XG4gIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xufTtcbnZhciBidWdneUpTT04gPSAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSk7XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIXVzZU5hdGl2ZSl7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKXtcbiAgICBpZihpc1N5bWJvbCh0aGlzKSl0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuICAgIHJldHVybiB3cmFwKHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCkpO1xuICB9O1xuICAkcmVkZWYoJFN5bWJvbC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gIGlzU3ltYm9sID0gZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG4gIH07XG5cbiAgJC5jcmVhdGUgICAgID0gJGNyZWF0ZTtcbiAgJC5pc0VudW0gICAgID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICAkLmdldERlc2MgICAgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkLnNldERlc2MgICAgPSAkZGVmaW5lUHJvcGVydHk7XG4gICQuc2V0RGVzY3MgICA9ICRkZWZpbmVQcm9wZXJ0aWVzO1xuICAkLmdldE5hbWVzICAgPSAkbmFtZXMuZ2V0ID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gICQuZ2V0U3ltYm9scyA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vJC5saWJyYXJ5Jykpe1xuICAgICRyZWRlZihPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxufVxuXG52YXIgc3ltYm9sU3RhdGljcyA9IHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICByZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufTtcbi8vIDE5LjQuMi4yIFN5bWJvbC5oYXNJbnN0YW5jZVxuLy8gMTkuNC4yLjMgU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZVxuLy8gMTkuNC4yLjQgU3ltYm9sLml0ZXJhdG9yXG4vLyAxOS40LjIuNiBTeW1ib2wubWF0Y2hcbi8vIDE5LjQuMi44IFN5bWJvbC5yZXBsYWNlXG4vLyAxOS40LjIuOSBTeW1ib2wuc2VhcmNoXG4vLyAxOS40LjIuMTAgU3ltYm9sLnNwZWNpZXNcbi8vIDE5LjQuMi4xMSBTeW1ib2wuc3BsaXRcbi8vIDE5LjQuMi4xMiBTeW1ib2wudG9QcmltaXRpdmVcbi8vIDE5LjQuMi4xMyBTeW1ib2wudG9TdHJpbmdUYWdcbi8vIDE5LjQuMi4xNCBTeW1ib2wudW5zY29wYWJsZXNcbiQuZWFjaC5jYWxsKChcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCwnICtcbiAgJ3NwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHN5bSA9IHdrcyhpdCk7XG4gIHN5bWJvbFN0YXRpY3NbaXRdID0gdXNlTmF0aXZlID8gc3ltIDogd3JhcChzeW0pO1xufSk7XG5cbnNldHRlciA9IHRydWU7XG5cbiRkZWYoJGRlZi5HICsgJGRlZi5XLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbiRkZWYoJGRlZi5TLCAnU3ltYm9sJywgc3ltYm9sU3RhdGljcyk7XG5cbiRkZWYoJGRlZi5TICsgJGRlZi5GICogIXVzZU5hdGl2ZSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGRlZigkZGVmLlMgKyAkZGVmLkYgKiAoIXVzZU5hdGl2ZSB8fCBidWdneUpTT04pLCAnSlNPTicsIHtzdHJpbmdpZnk6ICRzdHJpbmdpZnl9KTtcblxuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGRlZiAgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG5cbiRkZWYoJGRlZi5QLCAnTWFwJywge3RvSlNPTjogcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKX0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZGVmICA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcblxuJGRlZigkZGVmLlAsICdTZXQnLCB7dG9KU09OOiByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpfSk7IiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJyk7XG5JdGVyYXRvcnMuTm9kZUxpc3QgPSBJdGVyYXRvcnMuSFRNTENvbGxlY3Rpb24gPSBJdGVyYXRvcnMuQXJyYXk7IiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID1cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IG1vZHVsZS5leHBvcnRzLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWlZV0psYkMxeWRXNTBhVzFsTDNKbFoyVnVaWEpoZEc5eUwybHVaR1Y0TG1weklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVNJc0ltWnBiR1VpT2lKblpXNWxjbUYwWldRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lMeThnVkdocGN5QnRaWFJvYjJRZ2IyWWdiMkowWVdsdWFXNW5JR0VnY21WbVpYSmxibU5sSUhSdklIUm9aU0JuYkc5aVlXd2diMkpxWldOMElHNWxaV1J6SUhSdklHSmxYRzR2THlCclpYQjBJR2xrWlc1MGFXTmhiQ0IwYnlCMGFHVWdkMkY1SUdsMElHbHpJRzlpZEdGcGJtVmtJR2x1SUhKMWJuUnBiV1V1YW5OY2JuWmhjaUJuSUQxY2JpQWdkSGx3Wlc5bUlHZHNiMkpoYkNBOVBUMGdYQ0p2WW1wbFkzUmNJaUEvSUdkc2IySmhiQ0E2WEc0Z0lIUjVjR1Z2WmlCM2FXNWtiM2NnUFQwOUlGd2liMkpxWldOMFhDSWdQeUIzYVc1a2IzY2dPbHh1SUNCMGVYQmxiMllnYzJWc1ppQTlQVDBnWENKdlltcGxZM1JjSWlBL0lITmxiR1lnT2lCMGFHbHpPMXh1WEc0dkx5QlZjMlVnWUdkbGRFOTNibEJ5YjNCbGNuUjVUbUZ0WlhOZ0lHSmxZMkYxYzJVZ2JtOTBJR0ZzYkNCaWNtOTNjMlZ5Y3lCemRYQndiM0owSUdOaGJHeHBibWRjYmk4dklHQm9ZWE5QZDI1UWNtOXdaWEowZVdBZ2IyNGdkR2hsSUdkc2IySmhiQ0JnYzJWc1ptQWdiMkpxWldOMElHbHVJR0VnZDI5eWEyVnlMaUJUWldVZ0l6RTRNeTVjYm5aaGNpQm9ZV1JTZFc1MGFXMWxJRDBnWnk1eVpXZGxibVZ5WVhSdmNsSjFiblJwYldVZ0ppWmNiaUFnVDJKcVpXTjBMbWRsZEU5M2JsQnliM0JsY25SNVRtRnRaWE1vWnlrdWFXNWtaWGhQWmloY0luSmxaMlZ1WlhKaGRHOXlVblZ1ZEdsdFpWd2lLU0ErUFNBd08xeHVYRzR2THlCVFlYWmxJSFJvWlNCdmJHUWdjbVZuWlc1bGNtRjBiM0pTZFc1MGFXMWxJR2x1SUdOaGMyVWdhWFFnYm1WbFpITWdkRzhnWW1VZ2NtVnpkRzl5WldRZ2JHRjBaWEl1WEc1MllYSWdiMnhrVW5WdWRHbHRaU0E5SUdoaFpGSjFiblJwYldVZ0ppWWdaeTV5WldkbGJtVnlZWFJ2Y2xKMWJuUnBiV1U3WEc1Y2JpOHZJRVp2Y21ObElISmxaWFpoYkhWMFlYUnBiMjRnYjJZZ2NuVnVkR2x0WlM1cWN5NWNibWN1Y21WblpXNWxjbUYwYjNKU2RXNTBhVzFsSUQwZ2RXNWtaV1pwYm1Wa08xeHVYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJSEpsY1hWcGNtVW9YQ0l1TDNKMWJuUnBiV1ZjSWlrN1hHNWNibWxtSUNob1lXUlNkVzUwYVcxbEtTQjdYRzRnSUM4dklGSmxjM1J2Y21VZ2RHaGxJRzl5YVdkcGJtRnNJSEoxYm5ScGJXVXVYRzRnSUdjdWNtVm5aVzVsY21GMGIzSlNkVzUwYVcxbElEMGdiMnhrVW5WdWRHbHRaVHRjYm4wZ1pXeHpaU0I3WEc0Z0lDOHZJRkpsYlc5MlpTQjBhR1VnWjJ4dlltRnNJSEJ5YjNCbGNuUjVJR0ZrWkdWa0lHSjVJSEoxYm5ScGJXVXVhbk11WEc0Z0lIUnllU0I3WEc0Z0lDQWdaR1ZzWlhSbElHY3VjbVZuWlc1bGNtRjBiM0pTZFc1MGFXMWxPMXh1SUNCOUlHTmhkR05vS0dVcElIdGNiaUFnSUNCbkxuSmxaMlZ1WlhKaGRHOXlVblZ1ZEdsdFpTQTlJSFZ1WkdWbWFXNWxaRHRjYmlBZ2ZWeHVmVnh1WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUhzZ1hDSmtaV1poZFd4MFhDSTZJRzF2WkhWc1pTNWxlSEJ2Y25SekxDQmZYMlZ6VFc5a2RXeGxPaUIwY25WbElIMDdYRzRpWFgwPSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfU3ltYm9sID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2xcIilbXCJkZWZhdWx0XCJdO1xuXG52YXIgX1N5bWJvbCRpdGVyYXRvciA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9PYmplY3QkY3JlYXRlID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9Qcm9taXNlID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlXCIpW1wiZGVmYXVsdFwiXTtcblxuIShmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIF9TeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBfU3ltYm9sJGl0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIGdlbmVyYXRvciA9IF9PYmplY3QkY3JlYXRlKChvdXRlckZuIHx8IEdlbmVyYXRvcikucHJvdG90eXBlKTtcblxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmIHx8IG51bGwsIG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKSk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvciA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBfT2JqZWN0JGNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudGAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuIFNvbWUgbWF5IGNvbnNpZGVyIHRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIHRvb1xuICAvLyBjdXRlc3ksIGJ1dCB0aGV5IGFyZSBjdXJtdWRnZW9ucy5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gbmV3IEF3YWl0QXJndW1lbnQoYXJnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBBd2FpdEFyZ3VtZW50KGFyZykge1xuICAgIHRoaXMuYXJnID0gYXJnO1xuICB9XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICAvLyBUaGlzIGludm9rZSBmdW5jdGlvbiBpcyB3cml0dGVuIGluIGEgc3R5bGUgdGhhdCBhc3N1bWVzIHNvbWVcbiAgICAvLyBjYWxsaW5nIGZ1bmN0aW9uIChvciBQcm9taXNlKSB3aWxsIGhhbmRsZSBleGNlcHRpb25zLlxuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IGdlbmVyYXRvclttZXRob2RdKGFyZyk7XG4gICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50ID8gX1Byb21pc2UucmVzb2x2ZSh2YWx1ZS5hcmcpLnRoZW4oaW52b2tlTmV4dCwgaW52b2tlVGhyb3cpIDogX1Byb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7XG4gICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICBpbnZva2UgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIGludm9rZU5leHQgPSBpbnZva2UuYmluZChnZW5lcmF0b3IsIFwibmV4dFwiKTtcbiAgICB2YXIgaW52b2tlVGhyb3cgPSBpbnZva2UuYmluZChnZW5lcmF0b3IsIFwidGhyb3dcIik7XG4gICAgdmFyIGludm9rZVJldHVybiA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJyZXR1cm5cIik7XG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIHZhciBlbnF1ZXVlUmVzdWx0ID1cbiAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSkgOiBuZXcgX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZShpbnZva2UobWV0aG9kLCBhcmcpKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBlbnF1ZXVlUmVzdWx0IGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5XG4gICAgICAvLyBsYXRlciBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICBwcmV2aW91c1Byb21pc2UgPSBlbnF1ZXVlUmVzdWx0W1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGlnbm9yZWQpIHt9KTtcblxuICAgICAgcmV0dXJuIGVucXVldWVSZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkpO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIiB8fCBtZXRob2QgPT09IFwidGhyb3dcIiAmJiBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEEgcmV0dXJuIG9yIHRocm93ICh3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gdGhyb3dcbiAgICAgICAgICAgIC8vIG1ldGhvZCkgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICAgIHZhciByZXR1cm5NZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5NZXRob2QpIHtcbiAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKHJldHVybk1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJldHVybiBtZXRob2QgdGhyZXcgYW4gZXhjZXB0aW9uLCBsZXQgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiBwcmV2YWlsIG92ZXIgdGhlIG9yaWdpbmFsIHJldHVybiBvciB0aHJvdy5cbiAgICAgICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIG91dGVyIHJldHVybiwgbm93IHRoYXQgdGhlIGRlbGVnYXRlXG4gICAgICAgICAgICAgIC8vIGl0ZXJhdG9yIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdLCBkZWxlZ2F0ZS5pdGVyYXRvciwgYXJnKTtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gTGlrZSByZXR1cm5pbmcgZ2VuZXJhdG9yLnRocm93KHVuY2F1Z2h0KSwgYnV0IHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAvLyBvdmVyaGVhZCBvZiBhbiBleHRyYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERlbGVnYXRlIGdlbmVyYXRvciByYW4gYW5kIGhhbmRsZWQgaXRzIG93biBleGNlcHRpb25zIHNvXG4gICAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiB3aGF0IHRoZSBtZXRob2Qgd2FzLCB3ZSBjb250aW51ZSBhcyBpZiBpdCBpc1xuICAgICAgICAgIC8vIFwibmV4dFwiIHdpdGggYW4gdW5kZWZpbmVkIGFyZy5cbiAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG4gICAgICAgICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNlbnQgPSBhcmc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lID8gR2VuU3RhdGVDb21wbGV0ZWQgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgJiYgbWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsXG4gICAgICAgICAgICBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldChza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIHRoaXMuc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIGRpc3BhdGNoRXhjZXB0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24gYWJydXB0KHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmICh0eXBlID09PSBcImJyZWFrXCIgfHwgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fCByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCh0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4vLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxudHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB1bmRlZmluZWQpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpWVdKbGJDMXlkVzUwYVcxbEwzSmxaMlZ1WlhKaGRHOXlMM0oxYm5ScGJXVXVhbk1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRWlMQ0ptYVd4bElqb2laMlZ1WlhKaGRHVmtMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWk4cUtseHVJQ29nUTI5d2VYSnBaMmgwSUNoaktTQXlNREUwTENCR1lXTmxZbTl2YXl3Z1NXNWpMbHh1SUNvZ1FXeHNJSEpwWjJoMGN5QnlaWE5sY25abFpDNWNiaUFxWEc0Z0tpQlVhR2x6SUhOdmRYSmpaU0JqYjJSbElHbHpJR3hwWTJWdWMyVmtJSFZ1WkdWeUlIUm9aU0JDVTBRdGMzUjViR1VnYkdsalpXNXpaU0JtYjNWdVpDQnBiaUIwYUdWY2JpQXFJR2gwZEhCek9pOHZjbUYzTG1kcGRHaDFZaTVqYjIwdlptRmpaV0p2YjJzdmNtVm5aVzVsY21GMGIzSXZiV0Z6ZEdWeUwweEpRMFZPVTBVZ1ptbHNaUzRnUVc1Y2JpQXFJR0ZrWkdsMGFXOXVZV3dnWjNKaGJuUWdiMllnY0dGMFpXNTBJSEpwWjJoMGN5QmpZVzRnWW1VZ1ptOTFibVFnYVc0Z2RHaGxJRkJCVkVWT1ZGTWdabWxzWlNCcGJseHVJQ29nZEdobElITmhiV1VnWkdseVpXTjBiM0o1TGx4dUlDb3ZYRzVjYmx3aWRYTmxJSE4wY21samRGd2lPMXh1WEc1MllYSWdYMU41YldKdmJDQTlJSEpsY1hWcGNtVW9YQ0ppWVdKbGJDMXlkVzUwYVcxbEwyTnZjbVV0YW5NdmMzbHRZbTlzWENJcFcxd2laR1ZtWVhWc2RGd2lYVHRjYmx4dWRtRnlJRjlUZVcxaWIyd2thWFJsY21GMGIzSWdQU0J5WlhGMWFYSmxLRndpWW1GaVpXd3RjblZ1ZEdsdFpTOWpiM0psTFdwekwzTjViV0p2YkM5cGRHVnlZWFJ2Y2x3aUtWdGNJbVJsWm1GMWJIUmNJbDA3WEc1Y2JuWmhjaUJmVDJKcVpXTjBKR055WldGMFpTQTlJSEpsY1hWcGNtVW9YQ0ppWVdKbGJDMXlkVzUwYVcxbEwyTnZjbVV0YW5NdmIySnFaV04wTDJOeVpXRjBaVndpS1Z0Y0ltUmxabUYxYkhSY0lsMDdYRzVjYm5aaGNpQmZVSEp2YldselpTQTlJSEpsY1hWcGNtVW9YQ0ppWVdKbGJDMXlkVzUwYVcxbEwyTnZjbVV0YW5NdmNISnZiV2x6WlZ3aUtWdGNJbVJsWm1GMWJIUmNJbDA3WEc1Y2JpRW9ablZ1WTNScGIyNGdLR2RzYjJKaGJDa2dlMXh1SUNCY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dUlDQjJZWElnYUdGelQzZHVJRDBnVDJKcVpXTjBMbkJ5YjNSdmRIbHdaUzVvWVhOUGQyNVFjbTl3WlhKMGVUdGNiaUFnZG1GeUlIVnVaR1ZtYVc1bFpEc2dMeThnVFc5eVpTQmpiMjF3Y21WemMybGliR1VnZEdoaGJpQjJiMmxrSURBdVhHNGdJSFpoY2lCcGRHVnlZWFJ2Y2xONWJXSnZiQ0E5SUhSNWNHVnZaaUJmVTNsdFltOXNJRDA5UFNCY0ltWjFibU4wYVc5dVhDSWdKaVlnWDFONWJXSnZiQ1JwZEdWeVlYUnZjaUI4ZkNCY0lrQkFhWFJsY21GMGIzSmNJanRjYmx4dUlDQjJZWElnYVc1TmIyUjFiR1VnUFNCMGVYQmxiMllnYlc5a2RXeGxJRDA5UFNCY0ltOWlhbVZqZEZ3aU8xeHVJQ0IyWVhJZ2NuVnVkR2x0WlNBOUlHZHNiMkpoYkM1eVpXZGxibVZ5WVhSdmNsSjFiblJwYldVN1hHNGdJR2xtSUNoeWRXNTBhVzFsS1NCN1hHNGdJQ0FnYVdZZ0tHbHVUVzlrZFd4bEtTQjdYRzRnSUNBZ0lDQXZMeUJKWmlCeVpXZGxibVZ5WVhSdmNsSjFiblJwYldVZ2FYTWdaR1ZtYVc1bFpDQm5iRzlpWVd4c2VTQmhibVFnZDJVbmNtVWdhVzRnWVNCdGIyUjFiR1VzWEc0Z0lDQWdJQ0F2THlCdFlXdGxJSFJvWlNCbGVIQnZjblJ6SUc5aWFtVmpkQ0JwWkdWdWRHbGpZV3dnZEc4Z2NtVm5aVzVsY21GMGIzSlNkVzUwYVcxbExseHVJQ0FnSUNBZ2JXOWtkV3hsTG1WNGNHOXlkSE1nUFNCeWRXNTBhVzFsTzF4dUlDQWdJSDFjYmlBZ0lDQXZMeUJFYjI0bmRDQmliM1JvWlhJZ1pYWmhiSFZoZEdsdVp5QjBhR1VnY21WemRDQnZaaUIwYUdseklHWnBiR1VnYVdZZ2RHaGxJSEoxYm5ScGJXVWdkMkZ6WEc0Z0lDQWdMeThnWVd4eVpXRmtlU0JrWldacGJtVmtJR2RzYjJKaGJHeDVMbHh1SUNBZ0lISmxkSFZ5Ymp0Y2JpQWdmVnh1WEc0Z0lDOHZJRVJsWm1sdVpTQjBhR1VnY25WdWRHbHRaU0JuYkc5aVlXeHNlU0FvWVhNZ1pYaHdaV04wWldRZ1lua2daMlZ1WlhKaGRHVmtJR052WkdVcElHRnpJR1ZwZEdobGNseHVJQ0F2THlCdGIyUjFiR1V1Wlhod2IzSjBjeUFvYVdZZ2QyVW5jbVVnYVc0Z1lTQnRiMlIxYkdVcElHOXlJR0VnYm1WM0xDQmxiWEIwZVNCdlltcGxZM1F1WEc0Z0lISjFiblJwYldVZ1BTQm5iRzlpWVd3dWNtVm5aVzVsY21GMGIzSlNkVzUwYVcxbElEMGdhVzVOYjJSMWJHVWdQeUJ0YjJSMWJHVXVaWGh3YjNKMGN5QTZJSHQ5TzF4dVhHNGdJR1oxYm1OMGFXOXVJSGR5WVhBb2FXNXVaWEpHYml3Z2IzVjBaWEpHYml3Z2MyVnNaaXdnZEhKNVRHOWpjMHhwYzNRcElIdGNiaUFnSUNBdkx5QkpaaUJ2ZFhSbGNrWnVJSEJ5YjNacFpHVmtMQ0IwYUdWdUlHOTFkR1Z5Um00dWNISnZkRzkwZVhCbElHbHVjM1JoYm1ObGIyWWdSMlZ1WlhKaGRHOXlMbHh1SUNBZ0lIWmhjaUJuWlc1bGNtRjBiM0lnUFNCZlQySnFaV04wSkdOeVpXRjBaU2dvYjNWMFpYSkdiaUI4ZkNCSFpXNWxjbUYwYjNJcExuQnliM1J2ZEhsd1pTazdYRzVjYmlBZ0lDQm5aVzVsY21GMGIzSXVYMmx1ZG05clpTQTlJRzFoYTJWSmJuWnZhMlZOWlhSb2IyUW9hVzV1WlhKR2Jpd2djMlZzWmlCOGZDQnVkV3hzTENCdVpYY2dRMjl1ZEdWNGRDaDBjbmxNYjJOelRHbHpkQ0I4ZkNCYlhTa3BPMXh1WEc0Z0lDQWdjbVYwZFhKdUlHZGxibVZ5WVhSdmNqdGNiaUFnZlZ4dUlDQnlkVzUwYVcxbExuZHlZWEFnUFNCM2NtRndPMXh1WEc0Z0lDOHZJRlJ5ZVM5allYUmphQ0JvWld4d1pYSWdkRzhnYldsdWFXMXBlbVVnWkdWdmNIUnBiV2w2WVhScGIyNXpMaUJTWlhSMWNtNXpJR0VnWTI5dGNHeGxkR2x2Ymx4dUlDQXZMeUJ5WldOdmNtUWdiR2xyWlNCamIyNTBaWGgwTG5SeWVVVnVkSEpwWlhOYmFWMHVZMjl0Y0d4bGRHbHZiaTRnVkdocGN5QnBiblJsY21aaFkyVWdZMjkxYkdSY2JpQWdMeThnYUdGMlpTQmlaV1Z1SUNoaGJtUWdkMkZ6SUhCeVpYWnBiM1Z6YkhrcElHUmxjMmxuYm1Wa0lIUnZJSFJoYTJVZ1lTQmpiRzl6ZFhKbElIUnZJR0psWEc0Z0lDOHZJR2x1ZG05clpXUWdkMmwwYUc5MWRDQmhjbWQxYldWdWRITXNJR0oxZENCcGJpQmhiR3dnZEdobElHTmhjMlZ6SUhkbElHTmhjbVVnWVdKdmRYUWdkMlZjYmlBZ0x5OGdZV3h5WldGa2VTQm9ZWFpsSUdGdUlHVjRhWE4wYVc1bklHMWxkR2h2WkNCM1pTQjNZVzUwSUhSdklHTmhiR3dzSUhOdklIUm9aWEpsSjNNZ2JtOGdibVZsWkZ4dUlDQXZMeUIwYnlCamNtVmhkR1VnWVNCdVpYY2dablZ1WTNScGIyNGdiMkpxWldOMExpQlhaU0JqWVc0Z1pYWmxiaUJuWlhRZ1lYZGhlU0IzYVhSb0lHRnpjM1Z0YVc1blhHNGdJQzh2SUhSb1pTQnRaWFJvYjJRZ2RHRnJaWE1nWlhoaFkzUnNlU0J2Ym1VZ1lYSm5kVzFsYm5Rc0lITnBibU5sSUhSb1lYUWdhR0Z3Y0dWdWN5QjBieUJpWlNCMGNuVmxYRzRnSUM4dklHbHVJR1YyWlhKNUlHTmhjMlVzSUhOdklIZGxJR1J2YmlkMElHaGhkbVVnZEc4Z2RHOTFZMmdnZEdobElHRnlaM1Z0Wlc1MGN5QnZZbXBsWTNRdUlGUm9aVnh1SUNBdkx5QnZibXg1SUdGa1pHbDBhVzl1WVd3Z1lXeHNiMk5oZEdsdmJpQnlaWEYxYVhKbFpDQnBjeUIwYUdVZ1kyOXRjR3hsZEdsdmJpQnlaV052Y21Rc0lIZG9hV05vWEc0Z0lDOHZJR2hoY3lCaElITjBZV0pzWlNCemFHRndaU0JoYm1RZ2MyOGdhRzl3WldaMWJHeDVJSE5vYjNWc1pDQmlaU0JqYUdWaGNDQjBieUJoYkd4dlkyRjBaUzVjYmlBZ1puVnVZM1JwYjI0Z2RISjVRMkYwWTJnb1ptNHNJRzlpYWl3Z1lYSm5LU0I3WEc0Z0lDQWdkSEo1SUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUI3SUhSNWNHVTZJRndpYm05eWJXRnNYQ0lzSUdGeVp6b2dabTR1WTJGc2JDaHZZbW9zSUdGeVp5a2dmVHRjYmlBZ0lDQjlJR05oZEdOb0lDaGxjbklwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUI3SUhSNWNHVTZJRndpZEdoeWIzZGNJaXdnWVhKbk9pQmxjbklnZlR0Y2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCMllYSWdSMlZ1VTNSaGRHVlRkWE53Wlc1a1pXUlRkR0Z5ZENBOUlGd2ljM1Z6Y0dWdVpHVmtVM1JoY25SY0lqdGNiaUFnZG1GeUlFZGxibE4wWVhSbFUzVnpjR1Z1WkdWa1dXbGxiR1FnUFNCY0luTjFjM0JsYm1SbFpGbHBaV3hrWENJN1hHNGdJSFpoY2lCSFpXNVRkR0YwWlVWNFpXTjFkR2x1WnlBOUlGd2laWGhsWTNWMGFXNW5YQ0k3WEc0Z0lIWmhjaUJIWlc1VGRHRjBaVU52YlhCc1pYUmxaQ0E5SUZ3aVkyOXRjR3hsZEdWa1hDSTdYRzVjYmlBZ0x5OGdVbVYwZFhKdWFXNW5JSFJvYVhNZ2IySnFaV04wSUdaeWIyMGdkR2hsSUdsdWJtVnlSbTRnYUdGeklIUm9aU0J6WVcxbElHVm1abVZqZENCaGMxeHVJQ0F2THlCaWNtVmhhMmx1WnlCdmRYUWdiMllnZEdobElHUnBjM0JoZEdOb0lITjNhWFJqYUNCemRHRjBaVzFsYm5RdVhHNGdJSFpoY2lCRGIyNTBhVzUxWlZObGJuUnBibVZzSUQwZ2UzMDdYRzVjYmlBZ0x5OGdSSFZ0YlhrZ1kyOXVjM1J5ZFdOMGIzSWdablZ1WTNScGIyNXpJSFJvWVhRZ2QyVWdkWE5sSUdGeklIUm9aU0F1WTI5dWMzUnlkV04wYjNJZ1lXNWtYRzRnSUM4dklDNWpiMjV6ZEhKMVkzUnZjaTV3Y205MGIzUjVjR1VnY0hKdmNHVnlkR2xsY3lCbWIzSWdablZ1WTNScGIyNXpJSFJvWVhRZ2NtVjBkWEp1SUVkbGJtVnlZWFJ2Y2x4dUlDQXZMeUJ2WW1wbFkzUnpMaUJHYjNJZ1puVnNiQ0J6Y0dWaklHTnZiWEJzYVdGdVkyVXNJSGx2ZFNCdFlYa2dkMmx6YUNCMGJ5QmpiMjVtYVdkMWNtVWdlVzkxY2x4dUlDQXZMeUJ0YVc1cFptbGxjaUJ1YjNRZ2RHOGdiV0Z1WjJ4bElIUm9aU0J1WVcxbGN5QnZaaUIwYUdWelpTQjBkMjhnWm5WdVkzUnBiMjV6TGx4dUlDQm1kVzVqZEdsdmJpQkhaVzVsY21GMGIzSW9LU0I3ZlZ4dUlDQm1kVzVqZEdsdmJpQkhaVzVsY21GMGIzSkdkVzVqZEdsdmJpZ3BJSHQ5WEc0Z0lHWjFibU4wYVc5dUlFZGxibVZ5WVhSdmNrWjFibU4wYVc5dVVISnZkRzkwZVhCbEtDa2dlMzFjYmx4dUlDQjJZWElnUjNBZ1BTQkhaVzVsY21GMGIzSkdkVzVqZEdsdmJsQnliM1J2ZEhsd1pTNXdjbTkwYjNSNWNHVWdQU0JIWlc1bGNtRjBiM0l1Y0hKdmRHOTBlWEJsTzF4dUlDQkhaVzVsY21GMGIzSkdkVzVqZEdsdmJpNXdjbTkwYjNSNWNHVWdQU0JIY0M1amIyNXpkSEoxWTNSdmNpQTlJRWRsYm1WeVlYUnZja1oxYm1OMGFXOXVVSEp2ZEc5MGVYQmxPMXh1SUNCSFpXNWxjbUYwYjNKR2RXNWpkR2x2YmxCeWIzUnZkSGx3WlM1amIyNXpkSEoxWTNSdmNpQTlJRWRsYm1WeVlYUnZja1oxYm1OMGFXOXVPMXh1SUNCSFpXNWxjbUYwYjNKR2RXNWpkR2x2Ymk1a2FYTndiR0Y1VG1GdFpTQTlJRndpUjJWdVpYSmhkRzl5Um5WdVkzUnBiMjVjSWp0Y2JseHVJQ0F2THlCSVpXeHdaWElnWm05eUlHUmxabWx1YVc1bklIUm9aU0F1Ym1WNGRDd2dMblJvY205M0xDQmhibVFnTG5KbGRIVnliaUJ0WlhSb2IyUnpJRzltSUhSb1pWeHVJQ0F2THlCSmRHVnlZWFJ2Y2lCcGJuUmxjbVpoWTJVZ2FXNGdkR1Z5YlhNZ2IyWWdZU0J6YVc1bmJHVWdMbDlwYm5admEyVWdiV1YwYUc5a0xseHVJQ0JtZFc1amRHbHZiaUJrWldacGJtVkpkR1Z5WVhSdmNrMWxkR2h2WkhNb2NISnZkRzkwZVhCbEtTQjdYRzRnSUNBZ1cxd2libVY0ZEZ3aUxDQmNJblJvY205M1hDSXNJRndpY21WMGRYSnVYQ0pkTG1admNrVmhZMmdvWm5WdVkzUnBiMjRnS0cxbGRHaHZaQ2tnZTF4dUlDQWdJQ0FnY0hKdmRHOTBlWEJsVzIxbGRHaHZaRjBnUFNCbWRXNWpkR2x2YmlBb1lYSm5LU0I3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxsOXBiblp2YTJVb2JXVjBhRzlrTENCaGNtY3BPMXh1SUNBZ0lDQWdmVHRjYmlBZ0lDQjlLVHRjYmlBZ2ZWeHVYRzRnSUhKMWJuUnBiV1V1YVhOSFpXNWxjbUYwYjNKR2RXNWpkR2x2YmlBOUlHWjFibU4wYVc5dUlDaG5aVzVHZFc0cElIdGNiaUFnSUNCMllYSWdZM1J2Y2lBOUlIUjVjR1Z2WmlCblpXNUdkVzRnUFQwOUlGd2lablZ1WTNScGIyNWNJaUFtSmlCblpXNUdkVzR1WTI5dWMzUnlkV04wYjNJN1hHNGdJQ0FnY21WMGRYSnVJR04wYjNJZ1B5QmpkRzl5SUQwOVBTQkhaVzVsY21GMGIzSkdkVzVqZEdsdmJpQjhmRnh1SUNBZ0lDOHZJRVp2Y2lCMGFHVWdibUYwYVhabElFZGxibVZ5WVhSdmNrWjFibU4wYVc5dUlHTnZibk4wY25WamRHOXlMQ0IwYUdVZ1ltVnpkQ0IzWlNCallXNWNiaUFnSUNBdkx5QmtieUJwY3lCMGJ5QmphR1ZqYXlCcGRITWdMbTVoYldVZ2NISnZjR1Z5ZEhrdVhHNGdJQ0FnS0dOMGIzSXVaR2x6Y0d4aGVVNWhiV1VnZkh3Z1kzUnZjaTV1WVcxbEtTQTlQVDBnWENKSFpXNWxjbUYwYjNKR2RXNWpkR2x2Ymx3aUlEb2dabUZzYzJVN1hHNGdJSDA3WEc1Y2JpQWdjblZ1ZEdsdFpTNXRZWEpySUQwZ1puVnVZM1JwYjI0Z0tHZGxia1oxYmlrZ2UxeHVJQ0FnSUdkbGJrWjFiaTVmWDNCeWIzUnZYMThnUFNCSFpXNWxjbUYwYjNKR2RXNWpkR2x2YmxCeWIzUnZkSGx3WlR0Y2JpQWdJQ0JuWlc1R2RXNHVjSEp2ZEc5MGVYQmxJRDBnWDA5aWFtVmpkQ1JqY21WaGRHVW9SM0FwTzF4dUlDQWdJSEpsZEhWeWJpQm5aVzVHZFc0N1hHNGdJSDA3WEc1Y2JpQWdMeThnVjJsMGFHbHVJSFJvWlNCaWIyUjVJRzltSUdGdWVTQmhjM2x1WXlCbWRXNWpkR2x2Yml3Z1lHRjNZV2wwSUhoZ0lHbHpJSFJ5WVc1elptOXliV1ZrSUhSdlhHNGdJQzh2SUdCNWFXVnNaQ0J5WldkbGJtVnlZWFJ2Y2xKMWJuUnBiV1V1WVhkeVlYQW9lQ2xnTENCemJ5QjBhR0YwSUhSb1pTQnlkVzUwYVcxbElHTmhiaUIwWlhOMFhHNGdJQzh2SUdCMllXeDFaU0JwYm5OMFlXNWpaVzltSUVGM1lXbDBRWEpuZFcxbGJuUmdJSFJ2SUdSbGRHVnliV2x1WlNCcFppQjBhR1VnZVdsbGJHUmxaQ0IyWVd4MVpTQnBjMXh1SUNBdkx5QnRaV0Z1ZENCMGJ5QmlaU0JoZDJGcGRHVmtMaUJUYjIxbElHMWhlU0JqYjI1emFXUmxjaUIwYUdVZ2JtRnRaU0J2WmlCMGFHbHpJRzFsZEdodlpDQjBiMjljYmlBZ0x5OGdZM1YwWlhONUxDQmlkWFFnZEdobGVTQmhjbVVnWTNWeWJYVmtaMlZ2Ym5NdVhHNGdJSEoxYm5ScGJXVXVZWGR5WVhBZ1BTQm1kVzVqZEdsdmJpQW9ZWEpuS1NCN1hHNGdJQ0FnY21WMGRYSnVJRzVsZHlCQmQyRnBkRUZ5WjNWdFpXNTBLR0Z5WnlrN1hHNGdJSDA3WEc1Y2JpQWdablZ1WTNScGIyNGdRWGRoYVhSQmNtZDFiV1Z1ZENoaGNtY3BJSHRjYmlBZ0lDQjBhR2x6TG1GeVp5QTlJR0Z5Wnp0Y2JpQWdmVnh1WEc0Z0lHWjFibU4wYVc5dUlFRnplVzVqU1hSbGNtRjBiM0lvWjJWdVpYSmhkRzl5S1NCN1hHNGdJQ0FnTHk4Z1ZHaHBjeUJwYm5admEyVWdablZ1WTNScGIyNGdhWE1nZDNKcGRIUmxiaUJwYmlCaElITjBlV3hsSUhSb1lYUWdZWE56ZFcxbGN5QnpiMjFsWEc0Z0lDQWdMeThnWTJGc2JHbHVaeUJtZFc1amRHbHZiaUFvYjNJZ1VISnZiV2x6WlNrZ2QybHNiQ0JvWVc1a2JHVWdaWGhqWlhCMGFXOXVjeTVjYmlBZ0lDQm1kVzVqZEdsdmJpQnBiblp2YTJVb2JXVjBhRzlrTENCaGNtY3BJSHRjYmlBZ0lDQWdJSFpoY2lCeVpYTjFiSFFnUFNCblpXNWxjbUYwYjNKYmJXVjBhRzlrWFNoaGNtY3BPMXh1SUNBZ0lDQWdkbUZ5SUhaaGJIVmxJRDBnY21WemRXeDBMblpoYkhWbE8xeHVJQ0FnSUNBZ2NtVjBkWEp1SUhaaGJIVmxJR2x1YzNSaGJtTmxiMllnUVhkaGFYUkJjbWQxYldWdWRDQS9JRjlRY205dGFYTmxMbkpsYzI5c2RtVW9kbUZzZFdVdVlYSm5LUzUwYUdWdUtHbHVkbTlyWlU1bGVIUXNJR2x1ZG05clpWUm9jbTkzS1NBNklGOVFjbTl0YVhObExuSmxjMjlzZG1Vb2RtRnNkV1VwTG5Sb1pXNG9ablZ1WTNScGIyNGdLSFZ1ZDNKaGNIQmxaQ2tnZTF4dUlDQWdJQ0FnSUNBdkx5QlhhR1Z1SUdFZ2VXbGxiR1JsWkNCUWNtOXRhWE5sSUdseklISmxjMjlzZG1Wa0xDQnBkSE1nWm1sdVlXd2dkbUZzZFdVZ1ltVmpiMjFsYzF4dUlDQWdJQ0FnSUNBdkx5QjBhR1VnTG5aaGJIVmxJRzltSUhSb1pTQlFjbTl0YVhObFBIdDJZV3gxWlN4a2IyNWxmVDRnY21WemRXeDBJR1p2Y2lCMGFHVmNiaUFnSUNBZ0lDQWdMeThnWTNWeWNtVnVkQ0JwZEdWeVlYUnBiMjR1SUVsbUlIUm9aU0JRY205dGFYTmxJR2x6SUhKbGFtVmpkR1ZrTENCb2IzZGxkbVZ5TENCMGFHVmNiaUFnSUNBZ0lDQWdMeThnY21WemRXeDBJR1p2Y2lCMGFHbHpJR2wwWlhKaGRHbHZiaUIzYVd4c0lHSmxJSEpsYW1WamRHVmtJSGRwZEdnZ2RHaGxJSE5oYldWY2JpQWdJQ0FnSUNBZ0x5OGdjbVZoYzI5dUxpQk9iM1JsSUhSb1lYUWdjbVZxWldOMGFXOXVjeUJ2WmlCNWFXVnNaR1ZrSUZCeWIyMXBjMlZ6SUdGeVpTQnViM1JjYmlBZ0lDQWdJQ0FnTHk4Z2RHaHliM2R1SUdKaFkyc2dhVzUwYnlCMGFHVWdaMlZ1WlhKaGRHOXlJR1oxYm1OMGFXOXVMQ0JoY3lCcGN5QjBhR1VnWTJGelpWeHVJQ0FnSUNBZ0lDQXZMeUIzYUdWdUlHRnVJR0YzWVdsMFpXUWdVSEp2YldselpTQnBjeUJ5WldwbFkzUmxaQzRnVkdocGN5QmthV1ptWlhKbGJtTmxJR2x1WEc0Z0lDQWdJQ0FnSUM4dklHSmxhR0YyYVc5eUlHSmxkSGRsWlc0Z2VXbGxiR1FnWVc1a0lHRjNZV2wwSUdseklHbHRjRzl5ZEdGdWRDd2dZbVZqWVhWelpTQnBkRnh1SUNBZ0lDQWdJQ0F2THlCaGJHeHZkM01nZEdobElHTnZibk4xYldWeUlIUnZJR1JsWTJsa1pTQjNhR0YwSUhSdklHUnZJSGRwZEdnZ2RHaGxJSGxwWld4a1pXUmNiaUFnSUNBZ0lDQWdMeThnY21WcVpXTjBhVzl1SUNoemQyRnNiRzkzSUdsMElHRnVaQ0JqYjI1MGFXNTFaU3dnYldGdWRXRnNiSGtnTG5Sb2NtOTNJR2wwSUdKaFkydGNiaUFnSUNBZ0lDQWdMeThnYVc1MGJ5QjBhR1VnWjJWdVpYSmhkRzl5TENCaFltRnVaRzl1SUdsMFpYSmhkR2x2Yml3Z2QyaGhkR1YyWlhJcExpQlhhWFJvWEc0Z0lDQWdJQ0FnSUM4dklHRjNZV2wwTENCaWVTQmpiMjUwY21GemRDd2dkR2hsY21VZ2FYTWdibThnYjNCd2IzSjBkVzVwZEhrZ2RHOGdaWGhoYldsdVpTQjBhR1ZjYmlBZ0lDQWdJQ0FnTHk4Z2NtVnFaV04wYVc5dUlISmxZWE52YmlCdmRYUnphV1JsSUhSb1pTQm5aVzVsY21GMGIzSWdablZ1WTNScGIyNHNJSE52SUhSb1pWeHVJQ0FnSUNBZ0lDQXZMeUJ2Ym14NUlHOXdkR2x2YmlCcGN5QjBieUIwYUhKdmR5QnBkQ0JtY205dElIUm9aU0JoZDJGcGRDQmxlSEJ5WlhOemFXOXVMQ0JoYm1SY2JpQWdJQ0FnSUNBZ0x5OGdiR1YwSUhSb1pTQm5aVzVsY21GMGIzSWdablZ1WTNScGIyNGdhR0Z1Wkd4bElIUm9aU0JsZUdObGNIUnBiMjR1WEc0Z0lDQWdJQ0FnSUhKbGMzVnNkQzUyWVd4MVpTQTlJSFZ1ZDNKaGNIQmxaRHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSEpsYzNWc2REdGNiaUFnSUNBZ0lIMHBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHbG1JQ2gwZVhCbGIyWWdjSEp2WTJWemN5QTlQVDBnWENKdlltcGxZM1JjSWlBbUppQndjbTlqWlhOekxtUnZiV0ZwYmlrZ2UxeHVJQ0FnSUNBZ2FXNTJiMnRsSUQwZ2NISnZZMlZ6Y3k1a2IyMWhhVzR1WW1sdVpDaHBiblp2YTJVcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUhaaGNpQnBiblp2YTJWT1pYaDBJRDBnYVc1MmIydGxMbUpwYm1Rb1oyVnVaWEpoZEc5eUxDQmNJbTVsZUhSY0lpazdYRzRnSUNBZ2RtRnlJR2x1ZG05clpWUm9jbTkzSUQwZ2FXNTJiMnRsTG1KcGJtUW9aMlZ1WlhKaGRHOXlMQ0JjSW5Sb2NtOTNYQ0lwTzF4dUlDQWdJSFpoY2lCcGJuWnZhMlZTWlhSMWNtNGdQU0JwYm5admEyVXVZbWx1WkNoblpXNWxjbUYwYjNJc0lGd2ljbVYwZFhKdVhDSXBPMXh1SUNBZ0lIWmhjaUJ3Y21WMmFXOTFjMUJ5YjIxcGMyVTdYRzVjYmlBZ0lDQm1kVzVqZEdsdmJpQmxibkYxWlhWbEtHMWxkR2h2WkN3Z1lYSm5LU0I3WEc0Z0lDQWdJQ0IyWVhJZ1pXNXhkV1YxWlZKbGMzVnNkQ0E5WEc0Z0lDQWdJQ0F2THlCSlppQmxibkYxWlhWbElHaGhjeUJpWldWdUlHTmhiR3hsWkNCaVpXWnZjbVVzSUhSb1pXNGdkMlVnZDJGdWRDQjBieUIzWVdsMElIVnVkR2xzWEc0Z0lDQWdJQ0F2THlCaGJHd2djSEpsZG1sdmRYTWdVSEp2YldselpYTWdhR0YyWlNCaVpXVnVJSEpsYzI5c2RtVmtJR0psWm05eVpTQmpZV3hzYVc1bklHbHVkbTlyWlN4Y2JpQWdJQ0FnSUM4dklITnZJSFJvWVhRZ2NtVnpkV3gwY3lCaGNtVWdZV3gzWVhseklHUmxiR2wyWlhKbFpDQnBiaUIwYUdVZ1kyOXljbVZqZENCdmNtUmxjaTRnU1daY2JpQWdJQ0FnSUM4dklHVnVjWFZsZFdVZ2FHRnpJRzV2ZENCaVpXVnVJR05oYkd4bFpDQmlaV1p2Y21Vc0lIUm9aVzRnYVhRZ2FYTWdhVzF3YjNKMFlXNTBJSFJ2WEc0Z0lDQWdJQ0F2THlCallXeHNJR2x1ZG05clpTQnBiVzFsWkdsaGRHVnNlU3dnZDJsMGFHOTFkQ0IzWVdsMGFXNW5JRzl1SUdFZ1kyRnNiR0poWTJzZ2RHOGdabWx5WlN4Y2JpQWdJQ0FnSUM4dklITnZJSFJvWVhRZ2RHaGxJR0Z6ZVc1aklHZGxibVZ5WVhSdmNpQm1kVzVqZEdsdmJpQm9ZWE1nZEdobElHOXdjRzl5ZEhWdWFYUjVJSFJ2SUdSdlhHNGdJQ0FnSUNBdkx5QmhibmtnYm1WalpYTnpZWEo1SUhObGRIVndJR2x1SUdFZ2NISmxaR2xqZEdGaWJHVWdkMkY1TGlCVWFHbHpJSEJ5WldScFkzUmhZbWxzYVhSNVhHNGdJQ0FnSUNBdkx5QnBjeUIzYUhrZ2RHaGxJRkJ5YjIxcGMyVWdZMjl1YzNSeWRXTjBiM0lnYzNsdVkyaHliMjV2ZFhOc2VTQnBiblp2YTJWeklHbDBjMXh1SUNBZ0lDQWdMeThnWlhobFkzVjBiM0lnWTJGc2JHSmhZMnNzSUdGdVpDQjNhSGtnWVhONWJtTWdablZ1WTNScGIyNXpJSE41Ym1Ob2NtOXViM1Z6YkhsY2JpQWdJQ0FnSUM4dklHVjRaV04xZEdVZ1kyOWtaU0JpWldadmNtVWdkR2hsSUdacGNuTjBJR0YzWVdsMExpQlRhVzVqWlNCM1pTQnBiWEJzWlcxbGJuUWdjMmx0Y0d4bFhHNGdJQ0FnSUNBdkx5QmhjM2x1WXlCbWRXNWpkR2x2Ym5NZ2FXNGdkR1Z5YlhNZ2IyWWdZWE41Ym1NZ1oyVnVaWEpoZEc5eWN5d2dhWFFnYVhNZ1pYTndaV05wWVd4c2VWeHVJQ0FnSUNBZ0x5OGdhVzF3YjNKMFlXNTBJSFJ2SUdkbGRDQjBhR2x6SUhKcFoyaDBMQ0JsZG1WdUlIUm9iM1ZuYUNCcGRDQnlaWEYxYVhKbGN5QmpZWEpsTGx4dUlDQWdJQ0FnY0hKbGRtbHZkWE5RY205dGFYTmxJRDhnY0hKbGRtbHZkWE5RY205dGFYTmxMblJvWlc0b1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdhVzUyYjJ0bEtHMWxkR2h2WkN3Z1lYSm5LVHRjYmlBZ0lDQWdJSDBwSURvZ2JtVjNJRjlRY205dGFYTmxLR1oxYm1OMGFXOXVJQ2h5WlhOdmJIWmxLU0I3WEc0Z0lDQWdJQ0FnSUhKbGMyOXNkbVVvYVc1MmIydGxLRzFsZEdodlpDd2dZWEpuS1NrN1hHNGdJQ0FnSUNCOUtUdGNibHh1SUNBZ0lDQWdMeThnUVhadmFXUWdjSEp2Y0dGbllYUnBibWNnWlc1eGRXVjFaVkpsYzNWc2RDQm1ZV2xzZFhKbGN5QjBieUJRY205dGFYTmxjeUJ5WlhSMWNtNWxaQ0JpZVZ4dUlDQWdJQ0FnTHk4Z2JHRjBaWElnYVc1MmIyTmhkR2x2Ym5NZ2IyWWdkR2hsSUdsMFpYSmhkRzl5TGx4dUlDQWdJQ0FnY0hKbGRtbHZkWE5RY205dGFYTmxJRDBnWlc1eGRXVjFaVkpsYzNWc2RGdGNJbU5oZEdOb1hDSmRLR1oxYm1OMGFXOXVJQ2hwWjI1dmNtVmtLU0I3ZlNrN1hHNWNiaUFnSUNBZ0lISmxkSFZ5YmlCbGJuRjFaWFZsVW1WemRXeDBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lDOHZJRVJsWm1sdVpTQjBhR1VnZFc1cFptbGxaQ0JvWld4d1pYSWdiV1YwYUc5a0lIUm9ZWFFnYVhNZ2RYTmxaQ0IwYnlCcGJYQnNaVzFsYm5RZ0xtNWxlSFFzWEc0Z0lDQWdMeThnTG5Sb2NtOTNMQ0JoYm1RZ0xuSmxkSFZ5YmlBb2MyVmxJR1JsWm1sdVpVbDBaWEpoZEc5eVRXVjBhRzlrY3lrdVhHNGdJQ0FnZEdocGN5NWZhVzUyYjJ0bElEMGdaVzV4ZFdWMVpUdGNiaUFnZlZ4dVhHNGdJR1JsWm1sdVpVbDBaWEpoZEc5eVRXVjBhRzlrY3loQmMzbHVZMGwwWlhKaGRHOXlMbkJ5YjNSdmRIbHdaU2s3WEc1Y2JpQWdMeThnVG05MFpTQjBhR0YwSUhOcGJYQnNaU0JoYzNsdVl5Qm1kVzVqZEdsdmJuTWdZWEpsSUdsdGNHeGxiV1Z1ZEdWa0lHOXVJSFJ2Y0NCdlpseHVJQ0F2THlCQmMzbHVZMGwwWlhKaGRHOXlJRzlpYW1WamRITTdJSFJvWlhrZ2FuVnpkQ0J5WlhSMWNtNGdZU0JRY205dGFYTmxJR1p2Y2lCMGFHVWdkbUZzZFdVZ2IyWmNiaUFnTHk4Z2RHaGxJR1pwYm1Gc0lISmxjM1ZzZENCd2NtOWtkV05sWkNCaWVTQjBhR1VnYVhSbGNtRjBiM0l1WEc0Z0lISjFiblJwYldVdVlYTjVibU1nUFNCbWRXNWpkR2x2YmlBb2FXNXVaWEpHYml3Z2IzVjBaWEpHYml3Z2MyVnNaaXdnZEhKNVRHOWpjMHhwYzNRcElIdGNiaUFnSUNCMllYSWdhWFJsY2lBOUlHNWxkeUJCYzNsdVkwbDBaWEpoZEc5eUtIZHlZWEFvYVc1dVpYSkdiaXdnYjNWMFpYSkdiaXdnYzJWc1ppd2dkSEo1VEc5amMweHBjM1FwS1R0Y2JseHVJQ0FnSUhKbGRIVnliaUJ5ZFc1MGFXMWxMbWx6UjJWdVpYSmhkRzl5Um5WdVkzUnBiMjRvYjNWMFpYSkdiaWtnUHlCcGRHVnlJQzh2SUVsbUlHOTFkR1Z5Um00Z2FYTWdZU0JuWlc1bGNtRjBiM0lzSUhKbGRIVnliaUIwYUdVZ1puVnNiQ0JwZEdWeVlYUnZjaTVjYmlBZ0lDQTZJR2wwWlhJdWJtVjRkQ2dwTG5Sb1pXNG9ablZ1WTNScGIyNGdLSEpsYzNWc2RDa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlISmxjM1ZzZEM1a2IyNWxJRDhnY21WemRXeDBMblpoYkhWbElEb2dhWFJsY2k1dVpYaDBLQ2s3WEc0Z0lDQWdmU2s3WEc0Z0lIMDdYRzVjYmlBZ1puVnVZM1JwYjI0Z2JXRnJaVWx1ZG05clpVMWxkR2h2WkNocGJtNWxja1p1TENCelpXeG1MQ0JqYjI1MFpYaDBLU0I3WEc0Z0lDQWdkbUZ5SUhOMFlYUmxJRDBnUjJWdVUzUmhkR1ZUZFhOd1pXNWtaV1JUZEdGeWREdGNibHh1SUNBZ0lISmxkSFZ5YmlCbWRXNWpkR2x2YmlCcGJuWnZhMlVvYldWMGFHOWtMQ0JoY21jcElIdGNiaUFnSUNBZ0lHbG1JQ2h6ZEdGMFpTQTlQVDBnUjJWdVUzUmhkR1ZGZUdWamRYUnBibWNwSUh0Y2JpQWdJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0Z3aVIyVnVaWEpoZEc5eUlHbHpJR0ZzY21WaFpIa2djblZ1Ym1sdVoxd2lLVHRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnYVdZZ0tITjBZWFJsSUQwOVBTQkhaVzVUZEdGMFpVTnZiWEJzWlhSbFpDa2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb2JXVjBhRzlrSUQwOVBTQmNJblJvY205M1hDSXBJSHRjYmlBZ0lDQWdJQ0FnSUNCMGFISnZkeUJoY21jN1hHNGdJQ0FnSUNBZ0lIMWNibHh1SUNBZ0lDQWdJQ0F2THlCQ1pTQm1iM0puYVhacGJtY3NJSEJsY2lBeU5TNHpMak11TXk0eklHOW1JSFJvWlNCemNHVmpPbHh1SUNBZ0lDQWdJQ0F2THlCb2RIUndjem92TDNCbGIzQnNaUzV0YjNwcGJHeGhMbTl5Wnk5K2FtOXlaVzVrYjNKbVppOWxjell0WkhKaFpuUXVhSFJ0YkNOelpXTXRaMlZ1WlhKaGRHOXljbVZ6ZFcxbFhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCa2IyNWxVbVZ6ZFd4MEtDazdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJSGRvYVd4bElDaDBjblZsS1NCN1hHNGdJQ0FnSUNBZ0lIWmhjaUJrWld4bFoyRjBaU0E5SUdOdmJuUmxlSFF1WkdWc1pXZGhkR1U3WEc0Z0lDQWdJQ0FnSUdsbUlDaGtaV3hsWjJGMFpTa2dlMXh1SUNBZ0lDQWdJQ0FnSUdsbUlDaHRaWFJvYjJRZ1BUMDlJRndpY21WMGRYSnVYQ0lnZkh3Z2JXVjBhRzlrSUQwOVBTQmNJblJvY205M1hDSWdKaVlnWkdWc1pXZGhkR1V1YVhSbGNtRjBiM0piYldWMGFHOWtYU0E5UFQwZ2RXNWtaV1pwYm1Wa0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBdkx5QkJJSEpsZEhWeWJpQnZjaUIwYUhKdmR5QW9kMmhsYmlCMGFHVWdaR1ZzWldkaGRHVWdhWFJsY21GMGIzSWdhR0Z6SUc1dklIUm9jbTkzWEc0Z0lDQWdJQ0FnSUNBZ0lDQXZMeUJ0WlhSb2IyUXBJR0ZzZDJGNWN5QjBaWEp0YVc1aGRHVnpJSFJvWlNCNWFXVnNaQ29nYkc5dmNDNWNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmJuUmxlSFF1WkdWc1pXZGhkR1VnUFNCdWRXeHNPMXh1WEc0Z0lDQWdJQ0FnSUNBZ0lDQXZMeUJKWmlCMGFHVWdaR1ZzWldkaGRHVWdhWFJsY21GMGIzSWdhR0Z6SUdFZ2NtVjBkWEp1SUcxbGRHaHZaQ3dnWjJsMlpTQnBkQ0JoWEc0Z0lDQWdJQ0FnSUNBZ0lDQXZMeUJqYUdGdVkyVWdkRzhnWTJ4bFlXNGdkWEF1WEc0Z0lDQWdJQ0FnSUNBZ0lDQjJZWElnY21WMGRYSnVUV1YwYUc5a0lEMGdaR1ZzWldkaGRHVXVhWFJsY21GMGIzSmJYQ0p5WlhSMWNtNWNJbDA3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvY21WMGRYSnVUV1YwYUc5a0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lIWmhjaUJ5WldOdmNtUWdQU0IwY25sRFlYUmphQ2h5WlhSMWNtNU5aWFJvYjJRc0lHUmxiR1ZuWVhSbExtbDBaWEpoZEc5eUxDQmhjbWNwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2NtVmpiM0prTG5SNWNHVWdQVDA5SUZ3aWRHaHliM2RjSWlrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDOHZJRWxtSUhSb1pTQnlaWFIxY200Z2JXVjBhRzlrSUhSb2NtVjNJR0Z1SUdWNFkyVndkR2x2Yml3Z2JHVjBJSFJvWVhSY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBdkx5QmxlR05sY0hScGIyNGdjSEpsZG1GcGJDQnZkbVZ5SUhSb1pTQnZjbWxuYVc1aGJDQnlaWFIxY200Z2IzSWdkR2h5YjNjdVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2JXVjBhRzlrSUQwZ1hDSjBhSEp2ZDF3aU8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHRnlaeUE5SUhKbFkyOXlaQzVoY21jN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXVkR2x1ZFdVN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnSUNBZ0lDQWdhV1lnS0cxbGRHaHZaQ0E5UFQwZ1hDSnlaWFIxY201Y0lpa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQXZMeUJEYjI1MGFXNTFaU0IzYVhSb0lIUm9aU0J2ZFhSbGNpQnlaWFIxY200c0lHNXZkeUIwYUdGMElIUm9aU0JrWld4bFoyRjBaVnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQXZMeUJwZEdWeVlYUnZjaUJvWVhNZ1ltVmxiaUIwWlhKdGFXNWhkR1ZrTGx4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjI1MGFXNTFaVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ0lDQjJZWElnY21WamIzSmtJRDBnZEhKNVEyRjBZMmdvWkdWc1pXZGhkR1V1YVhSbGNtRjBiM0piYldWMGFHOWtYU3dnWkdWc1pXZGhkR1V1YVhSbGNtRjBiM0lzSUdGeVp5azdYRzVjYmlBZ0lDQWdJQ0FnSUNCcFppQW9jbVZqYjNKa0xuUjVjR1VnUFQwOUlGd2lkR2h5YjNkY0lpa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVkR1Y0ZEM1a1pXeGxaMkYwWlNBOUlHNTFiR3c3WEc1Y2JpQWdJQ0FnSUNBZ0lDQWdJQzh2SUV4cGEyVWdjbVYwZFhKdWFXNW5JR2RsYm1WeVlYUnZjaTUwYUhKdmR5aDFibU5oZFdkb2RDa3NJR0oxZENCM2FYUm9iM1YwSUhSb1pWeHVJQ0FnSUNBZ0lDQWdJQ0FnTHk4Z2IzWmxjbWhsWVdRZ2IyWWdZVzRnWlhoMGNtRWdablZ1WTNScGIyNGdZMkZzYkM1Y2JpQWdJQ0FnSUNBZ0lDQWdJRzFsZEdodlpDQTlJRndpZEdoeWIzZGNJanRjYmlBZ0lDQWdJQ0FnSUNBZ0lHRnlaeUE5SUhKbFkyOXlaQzVoY21jN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1MGFXNTFaVHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdJQ0F2THlCRVpXeGxaMkYwWlNCblpXNWxjbUYwYjNJZ2NtRnVJR0Z1WkNCb1lXNWtiR1ZrSUdsMGN5QnZkMjRnWlhoalpYQjBhVzl1Y3lCemIxeHVJQ0FnSUNBZ0lDQWdJQzh2SUhKbFoyRnlaR3hsYzNNZ2IyWWdkMmhoZENCMGFHVWdiV1YwYUc5a0lIZGhjeXdnZDJVZ1kyOXVkR2x1ZFdVZ1lYTWdhV1lnYVhRZ2FYTmNiaUFnSUNBZ0lDQWdJQ0F2THlCY0ltNWxlSFJjSWlCM2FYUm9JR0Z1SUhWdVpHVm1hVzVsWkNCaGNtY3VYRzRnSUNBZ0lDQWdJQ0FnYldWMGFHOWtJRDBnWENKdVpYaDBYQ0k3WEc0Z0lDQWdJQ0FnSUNBZ1lYSm5JRDBnZFc1a1pXWnBibVZrTzF4dVhHNGdJQ0FnSUNBZ0lDQWdkbUZ5SUdsdVptOGdQU0J5WldOdmNtUXVZWEpuTzF4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2hwYm1adkxtUnZibVVwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR052Ym5SbGVIUmJaR1ZzWldkaGRHVXVjbVZ6ZFd4MFRtRnRaVjBnUFNCcGJtWnZMblpoYkhWbE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWRHVjRkQzV1WlhoMElEMGdaR1ZzWldkaGRHVXVibVY0ZEV4dll6dGNiaUFnSUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2MzUmhkR1VnUFNCSFpXNVRkR0YwWlZOMWMzQmxibVJsWkZscFpXeGtPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUdsdVptODdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lDQWdZMjl1ZEdWNGRDNWtaV3hsWjJGMFpTQTlJRzUxYkd3N1hHNGdJQ0FnSUNBZ0lIMWNibHh1SUNBZ0lDQWdJQ0JwWmlBb2JXVjBhRzlrSUQwOVBTQmNJbTVsZUhSY0lpa2dlMXh1SUNBZ0lDQWdJQ0FnSUdsbUlDaHpkR0YwWlNBOVBUMGdSMlZ1VTNSaGRHVlRkWE53Wlc1a1pXUlphV1ZzWkNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWRHVjRkQzV6Wlc1MElEMGdZWEpuTzF4dUlDQWdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1MFpYaDBMbk5sYm5RZ1BTQjFibVJsWm1sdVpXUTdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tHMWxkR2h2WkNBOVBUMGdYQ0owYUhKdmQxd2lLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLSE4wWVhSbElEMDlQU0JIWlc1VGRHRjBaVk4xYzNCbGJtUmxaRk4wWVhKMEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCemRHRjBaU0E5SUVkbGJsTjBZWFJsUTI5dGNHeGxkR1ZrTzF4dUlDQWdJQ0FnSUNBZ0lDQWdkR2h5YjNjZ1lYSm5PMXh1SUNBZ0lDQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0lDQWdJR2xtSUNoamIyNTBaWGgwTG1ScGMzQmhkR05vUlhoalpYQjBhVzl1S0dGeVp5a3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDOHZJRWxtSUhSb1pTQmthWE53WVhSamFHVmtJR1Y0WTJWd2RHbHZiaUIzWVhNZ1kyRjFaMmgwSUdKNUlHRWdZMkYwWTJnZ1lteHZZMnNzWEc0Z0lDQWdJQ0FnSUNBZ0lDQXZMeUIwYUdWdUlHeGxkQ0IwYUdGMElHTmhkR05vSUdKc2IyTnJJR2hoYm1Sc1pTQjBhR1VnWlhoalpYQjBhVzl1SUc1dmNtMWhiR3g1TGx4dUlDQWdJQ0FnSUNBZ0lDQWdiV1YwYUc5a0lEMGdYQ0p1WlhoMFhDSTdYRzRnSUNBZ0lDQWdJQ0FnSUNCaGNtY2dQU0IxYm1SbFptbHVaV1E3WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLRzFsZEdodlpDQTlQVDBnWENKeVpYUjFjbTVjSWlrZ2UxeHVJQ0FnSUNBZ0lDQWdJR052Ym5SbGVIUXVZV0p5ZFhCMEtGd2ljbVYwZFhKdVhDSXNJR0Z5WnlrN1hHNGdJQ0FnSUNBZ0lIMWNibHh1SUNBZ0lDQWdJQ0J6ZEdGMFpTQTlJRWRsYmxOMFlYUmxSWGhsWTNWMGFXNW5PMXh1WEc0Z0lDQWdJQ0FnSUhaaGNpQnlaV052Y21RZ1BTQjBjbmxEWVhSamFDaHBibTVsY2tadUxDQnpaV3htTENCamIyNTBaWGgwS1R0Y2JpQWdJQ0FnSUNBZ2FXWWdLSEpsWTI5eVpDNTBlWEJsSUQwOVBTQmNJbTV2Y20xaGJGd2lLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0x5OGdTV1lnWVc0Z1pYaGpaWEIwYVc5dUlHbHpJSFJvY205M2JpQm1jbTl0SUdsdWJtVnlSbTRzSUhkbElHeGxZWFpsSUhOMFlYUmxJRDA5UFZ4dUlDQWdJQ0FnSUNBZ0lDOHZJRWRsYmxOMFlYUmxSWGhsWTNWMGFXNW5JR0Z1WkNCc2IyOXdJR0poWTJzZ1ptOXlJR0Z1YjNSb1pYSWdhVzUyYjJOaGRHbHZiaTVjYmlBZ0lDQWdJQ0FnSUNCemRHRjBaU0E5SUdOdmJuUmxlSFF1Wkc5dVpTQS9JRWRsYmxOMFlYUmxRMjl0Y0d4bGRHVmtJRG9nUjJWdVUzUmhkR1ZUZFhOd1pXNWtaV1JaYVdWc1pEdGNibHh1SUNBZ0lDQWdJQ0FnSUhaaGNpQnBibVp2SUQwZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZG1Gc2RXVTZJSEpsWTI5eVpDNWhjbWNzWEc0Z0lDQWdJQ0FnSUNBZ0lDQmtiMjVsT2lCamIyNTBaWGgwTG1SdmJtVmNiaUFnSUNBZ0lDQWdJQ0I5TzF4dVhHNGdJQ0FnSUNBZ0lDQWdhV1lnS0hKbFkyOXlaQzVoY21jZ1BUMDlJRU52Ym5ScGJuVmxVMlZ1ZEdsdVpXd3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2hqYjI1MFpYaDBMbVJsYkdWbllYUmxJQ1ltSUcxbGRHaHZaQ0E5UFQwZ1hDSnVaWGgwWENJcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0x5OGdSR1ZzYVdKbGNtRjBaV3g1SUdadmNtZGxkQ0IwYUdVZ2JHRnpkQ0J6Wlc1MElIWmhiSFZsSUhOdklIUm9ZWFFnZDJVZ1pHOXVKM1JjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdMeThnWVdOamFXUmxiblJoYkd4NUlIQmhjM01nYVhRZ2IyNGdkRzhnZEdobElHUmxiR1ZuWVhSbExseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCaGNtY2dQU0IxYm1SbFptbHVaV1E3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCcGJtWnZPMXh1SUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaHlaV052Y21RdWRIbHdaU0E5UFQwZ1hDSjBhSEp2ZDF3aUtTQjdYRzRnSUNBZ0lDQWdJQ0FnYzNSaGRHVWdQU0JIWlc1VGRHRjBaVU52YlhCc1pYUmxaRHRjYmlBZ0lDQWdJQ0FnSUNBdkx5QkVhWE53WVhSamFDQjBhR1VnWlhoalpYQjBhVzl1SUdKNUlHeHZiM0JwYm1jZ1ltRmpheUJoY205MWJtUWdkRzhnZEdobFhHNGdJQ0FnSUNBZ0lDQWdMeThnWTI5dWRHVjRkQzVrYVhOd1lYUmphRVY0WTJWd2RHbHZiaWhoY21jcElHTmhiR3dnWVdKdmRtVXVYRzRnSUNBZ0lDQWdJQ0FnYldWMGFHOWtJRDBnWENKMGFISnZkMXdpTzF4dUlDQWdJQ0FnSUNBZ0lHRnlaeUE5SUhKbFkyOXlaQzVoY21jN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMWNiaUFnSUNCOU8xeHVJQ0I5WEc1Y2JpQWdMeThnUkdWbWFXNWxJRWRsYm1WeVlYUnZjaTV3Y205MGIzUjVjR1V1ZTI1bGVIUXNkR2h5YjNjc2NtVjBkWEp1ZlNCcGJpQjBaWEp0Y3lCdlppQjBhR1ZjYmlBZ0x5OGdkVzVwWm1sbFpDQXVYMmx1ZG05clpTQm9aV3h3WlhJZ2JXVjBhRzlrTGx4dUlDQmtaV1pwYm1WSmRHVnlZWFJ2Y2sxbGRHaHZaSE1vUjNBcE8xeHVYRzRnSUVkd1cybDBaWEpoZEc5eVUzbHRZbTlzWFNBOUlHWjFibU4wYVc5dUlDZ3BJSHRjYmlBZ0lDQnlaWFIxY200Z2RHaHBjenRjYmlBZ2ZUdGNibHh1SUNCSGNDNTBiMU4wY21sdVp5QTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdYQ0piYjJKcVpXTjBJRWRsYm1WeVlYUnZjbDFjSWp0Y2JpQWdmVHRjYmx4dUlDQm1kVzVqZEdsdmJpQndkWE5vVkhKNVJXNTBjbmtvYkc5amN5a2dlMXh1SUNBZ0lIWmhjaUJsYm5SeWVTQTlJSHNnZEhKNVRHOWpPaUJzYjJOeld6QmRJSDA3WEc1Y2JpQWdJQ0JwWmlBb01TQnBiaUJzYjJOektTQjdYRzRnSUNBZ0lDQmxiblJ5ZVM1allYUmphRXh2WXlBOUlHeHZZM05iTVYwN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnYVdZZ0tESWdhVzRnYkc5amN5a2dlMXh1SUNBZ0lDQWdaVzUwY25rdVptbHVZV3hzZVV4dll5QTlJR3h2WTNOYk1sMDdYRzRnSUNBZ0lDQmxiblJ5ZVM1aFpuUmxja3h2WXlBOUlHeHZZM05iTTEwN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnZEdocGN5NTBjbmxGYm5SeWFXVnpMbkIxYzJnb1pXNTBjbmtwTzF4dUlDQjlYRzVjYmlBZ1puVnVZM1JwYjI0Z2NtVnpaWFJVY25sRmJuUnllU2hsYm5SeWVTa2dlMXh1SUNBZ0lIWmhjaUJ5WldOdmNtUWdQU0JsYm5SeWVTNWpiMjF3YkdWMGFXOXVJSHg4SUh0OU8xeHVJQ0FnSUhKbFkyOXlaQzUwZVhCbElEMGdYQ0p1YjNKdFlXeGNJanRjYmlBZ0lDQmtaV3hsZEdVZ2NtVmpiM0prTG1GeVp6dGNiaUFnSUNCbGJuUnllUzVqYjIxd2JHVjBhVzl1SUQwZ2NtVmpiM0prTzF4dUlDQjlYRzVjYmlBZ1puVnVZM1JwYjI0Z1EyOXVkR1Y0ZENoMGNubE1iMk56VEdsemRDa2dlMXh1SUNBZ0lDOHZJRlJvWlNCeWIyOTBJR1Z1ZEhKNUlHOWlhbVZqZENBb1pXWm1aV04wYVhabGJIa2dZU0IwY25rZ2MzUmhkR1Z0Wlc1MElIZHBkR2h2ZFhRZ1lTQmpZWFJqYUZ4dUlDQWdJQzh2SUc5eUlHRWdabWx1WVd4c2VTQmliRzlqYXlrZ1oybDJaWE1nZFhNZ1lTQndiR0ZqWlNCMGJ5QnpkRzl5WlNCMllXeDFaWE1nZEdoeWIzZHVJR1p5YjIxY2JpQWdJQ0F2THlCc2IyTmhkR2x2Ym5NZ2QyaGxjbVVnZEdobGNtVWdhWE1nYm04Z1pXNWpiRzl6YVc1bklIUnllU0J6ZEdGMFpXMWxiblF1WEc0Z0lDQWdkR2hwY3k1MGNubEZiblJ5YVdWeklEMGdXM3NnZEhKNVRHOWpPaUJjSW5KdmIzUmNJaUI5WFR0Y2JpQWdJQ0IwY25sTWIyTnpUR2x6ZEM1bWIzSkZZV05vS0hCMWMyaFVjbmxGYm5SeWVTd2dkR2hwY3lrN1hHNGdJQ0FnZEdocGN5NXlaWE5sZENoMGNuVmxLVHRjYmlBZ2ZWeHVYRzRnSUhKMWJuUnBiV1V1YTJWNWN5QTlJR1oxYm1OMGFXOXVJQ2h2WW1wbFkzUXBJSHRjYmlBZ0lDQjJZWElnYTJWNWN5QTlJRnRkTzF4dUlDQWdJR1p2Y2lBb2RtRnlJR3RsZVNCcGJpQnZZbXBsWTNRcElIdGNiaUFnSUNBZ0lHdGxlWE11Y0hWemFDaHJaWGtwTzF4dUlDQWdJSDFjYmlBZ0lDQnJaWGx6TG5KbGRtVnljMlVvS1R0Y2JseHVJQ0FnSUM4dklGSmhkR2hsY2lCMGFHRnVJSEpsZEhWeWJtbHVaeUJoYmlCdlltcGxZM1FnZDJsMGFDQmhJRzVsZUhRZ2JXVjBhRzlrTENCM1pTQnJaV1Z3WEc0Z0lDQWdMeThnZEdocGJtZHpJSE5wYlhCc1pTQmhibVFnY21WMGRYSnVJSFJvWlNCdVpYaDBJR1oxYm1OMGFXOXVJR2wwYzJWc1ppNWNiaUFnSUNCeVpYUjFjbTRnWm5WdVkzUnBiMjRnYm1WNGRDZ3BJSHRjYmlBZ0lDQWdJSGRvYVd4bElDaHJaWGx6TG14bGJtZDBhQ2tnZTF4dUlDQWdJQ0FnSUNCMllYSWdhMlY1SUQwZ2EyVjVjeTV3YjNBb0tUdGNiaUFnSUNBZ0lDQWdhV1lnS0d0bGVTQnBiaUJ2WW1wbFkzUXBJSHRjYmlBZ0lDQWdJQ0FnSUNCdVpYaDBMblpoYkhWbElEMGdhMlY1TzF4dUlDQWdJQ0FnSUNBZ0lHNWxlSFF1Wkc5dVpTQTlJR1poYkhObE8xeHVJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQnVaWGgwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDOHZJRlJ2SUdGMmIybGtJR055WldGMGFXNW5JR0Z1SUdGa1pHbDBhVzl1WVd3Z2IySnFaV04wTENCM1pTQnFkWE4wSUdoaGJtY2dkR2hsSUM1MllXeDFaVnh1SUNBZ0lDQWdMeThnWVc1a0lDNWtiMjVsSUhCeWIzQmxjblJwWlhNZ2IyWm1JSFJvWlNCdVpYaDBJR1oxYm1OMGFXOXVJRzlpYW1WamRDQnBkSE5sYkdZdUlGUm9hWE5jYmlBZ0lDQWdJQzh2SUdGc2MyOGdaVzV6ZFhKbGN5QjBhR0YwSUhSb1pTQnRhVzVwWm1sbGNpQjNhV3hzSUc1dmRDQmhibTl1ZVcxcGVtVWdkR2hsSUdaMWJtTjBhVzl1TGx4dUlDQWdJQ0FnYm1WNGRDNWtiMjVsSUQwZ2RISjFaVHRjYmlBZ0lDQWdJSEpsZEhWeWJpQnVaWGgwTzF4dUlDQWdJSDA3WEc0Z0lIMDdYRzVjYmlBZ1puVnVZM1JwYjI0Z2RtRnNkV1Z6S0dsMFpYSmhZbXhsS1NCN1hHNGdJQ0FnYVdZZ0tHbDBaWEpoWW14bEtTQjdYRzRnSUNBZ0lDQjJZWElnYVhSbGNtRjBiM0pOWlhSb2IyUWdQU0JwZEdWeVlXSnNaVnRwZEdWeVlYUnZjbE41YldKdmJGMDdYRzRnSUNBZ0lDQnBaaUFvYVhSbGNtRjBiM0pOWlhSb2IyUXBJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJR2wwWlhKaGRHOXlUV1YwYUc5a0xtTmhiR3dvYVhSbGNtRmliR1VwTzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCcFppQW9kSGx3Wlc5bUlHbDBaWEpoWW14bExtNWxlSFFnUFQwOUlGd2lablZ1WTNScGIyNWNJaWtnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnYVhSbGNtRmliR1U3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUdsbUlDZ2hhWE5PWVU0b2FYUmxjbUZpYkdVdWJHVnVaM1JvS1NrZ2UxeHVJQ0FnSUNBZ0lDQjJZWElnYVNBOUlDMHhMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2JtVjRkQ0E5SUdaMWJtTjBhVzl1SUc1bGVIUW9LU0I3WEc0Z0lDQWdJQ0FnSUNBZ2QyaHBiR1VnS0NzcmFTQThJR2wwWlhKaFlteGxMbXhsYm1kMGFDa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLR2hoYzA5M2JpNWpZV3hzS0dsMFpYSmhZbXhsTENCcEtTa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnVaWGgwTG5aaGJIVmxJRDBnYVhSbGNtRmliR1ZiYVYwN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUc1bGVIUXVaRzl1WlNBOUlHWmhiSE5sTzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdibVY0ZER0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdJQ0J1WlhoMExuWmhiSFZsSUQwZ2RXNWtaV1pwYm1Wa08xeHVJQ0FnSUNBZ0lDQWdJRzVsZUhRdVpHOXVaU0E5SUhSeWRXVTdYRzVjYmlBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnYm1WNGREdGNiaUFnSUNBZ0lDQWdmVHRjYmx4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnYm1WNGRDNXVaWGgwSUQwZ2JtVjRkRHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmlBZ0lDQXZMeUJTWlhSMWNtNGdZVzRnYVhSbGNtRjBiM0lnZDJsMGFDQnVieUIyWVd4MVpYTXVYRzRnSUNBZ2NtVjBkWEp1SUhzZ2JtVjRkRG9nWkc5dVpWSmxjM1ZzZENCOU8xeHVJQ0I5WEc0Z0lISjFiblJwYldVdWRtRnNkV1Z6SUQwZ2RtRnNkV1Z6TzF4dVhHNGdJR1oxYm1OMGFXOXVJR1J2Ym1WU1pYTjFiSFFvS1NCN1hHNGdJQ0FnY21WMGRYSnVJSHNnZG1Gc2RXVTZJSFZ1WkdWbWFXNWxaQ3dnWkc5dVpUb2dkSEoxWlNCOU8xeHVJQ0I5WEc1Y2JpQWdRMjl1ZEdWNGRDNXdjbTkwYjNSNWNHVWdQU0I3WEc0Z0lDQWdZMjl1YzNSeWRXTjBiM0k2SUVOdmJuUmxlSFFzWEc1Y2JpQWdJQ0J5WlhObGREb2dablZ1WTNScGIyNGdjbVZ6WlhRb2MydHBjRlJsYlhCU1pYTmxkQ2tnZTF4dUlDQWdJQ0FnZEdocGN5NXdjbVYySUQwZ01EdGNiaUFnSUNBZ0lIUm9hWE11Ym1WNGRDQTlJREE3WEc0Z0lDQWdJQ0IwYUdsekxuTmxiblFnUFNCMWJtUmxabWx1WldRN1hHNGdJQ0FnSUNCMGFHbHpMbVJ2Ym1VZ1BTQm1ZV3h6WlR0Y2JpQWdJQ0FnSUhSb2FYTXVaR1ZzWldkaGRHVWdQU0J1ZFd4c08xeHVYRzRnSUNBZ0lDQjBhR2x6TG5SeWVVVnVkSEpwWlhNdVptOXlSV0ZqYUNoeVpYTmxkRlJ5ZVVWdWRISjVLVHRjYmx4dUlDQWdJQ0FnYVdZZ0tDRnphMmx3VkdWdGNGSmxjMlYwS1NCN1hHNGdJQ0FnSUNBZ0lHWnZjaUFvZG1GeUlHNWhiV1VnYVc0Z2RHaHBjeWtnZTF4dUlDQWdJQ0FnSUNBZ0lDOHZJRTV2ZENCemRYSmxJR0ZpYjNWMElIUm9aU0J2Y0hScGJXRnNJRzl5WkdWeUlHOW1JSFJvWlhObElHTnZibVJwZEdsdmJuTTZYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tHNWhiV1V1WTJoaGNrRjBLREFwSUQwOVBTQmNJblJjSWlBbUppQm9ZWE5QZDI0dVkyRnNiQ2gwYUdsekxDQnVZVzFsS1NBbUppQWhhWE5PWVU0b0syNWhiV1V1YzJ4cFkyVW9NU2twS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdselcyNWhiV1ZkSUQwZ2RXNWtaV1pwYm1Wa08xeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlZ4dUlDQWdJSDBzWEc1Y2JpQWdJQ0J6ZEc5d09pQm1kVzVqZEdsdmJpQnpkRzl3S0NrZ2UxeHVJQ0FnSUNBZ2RHaHBjeTVrYjI1bElEMGdkSEoxWlR0Y2JseHVJQ0FnSUNBZ2RtRnlJSEp2YjNSRmJuUnllU0E5SUhSb2FYTXVkSEo1Ulc1MGNtbGxjMXN3WFR0Y2JpQWdJQ0FnSUhaaGNpQnliMjkwVW1WamIzSmtJRDBnY205dmRFVnVkSEo1TG1OdmJYQnNaWFJwYjI0N1hHNGdJQ0FnSUNCcFppQW9jbTl2ZEZKbFkyOXlaQzUwZVhCbElEMDlQU0JjSW5Sb2NtOTNYQ0lwSUh0Y2JpQWdJQ0FnSUNBZ2RHaHliM2NnY205dmRGSmxZMjl5WkM1aGNtYzdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TG5KMllXdzdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lHUnBjM0JoZEdOb1JYaGpaWEIwYVc5dU9pQm1kVzVqZEdsdmJpQmthWE53WVhSamFFVjRZMlZ3ZEdsdmJpaGxlR05sY0hScGIyNHBJSHRjYmlBZ0lDQWdJR2xtSUNoMGFHbHpMbVJ2Ym1VcElIdGNiaUFnSUNBZ0lDQWdkR2h5YjNjZ1pYaGpaWEIwYVc5dU8xeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQjJZWElnWTI5dWRHVjRkQ0E5SUhSb2FYTTdYRzRnSUNBZ0lDQm1kVzVqZEdsdmJpQm9ZVzVrYkdVb2JHOWpMQ0JqWVhWbmFIUXBJSHRjYmlBZ0lDQWdJQ0FnY21WamIzSmtMblI1Y0dVZ1BTQmNJblJvY205M1hDSTdYRzRnSUNBZ0lDQWdJSEpsWTI5eVpDNWhjbWNnUFNCbGVHTmxjSFJwYjI0N1hHNGdJQ0FnSUNBZ0lHTnZiblJsZUhRdWJtVjRkQ0E5SUd4dll6dGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlDRWhZMkYxWjJoME8xeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQm1iM0lnS0haaGNpQnBJRDBnZEdocGN5NTBjbmxGYm5SeWFXVnpMbXhsYm1kMGFDQXRJREU3SUdrZ1BqMGdNRHNnTFMxcEtTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCbGJuUnllU0E5SUhSb2FYTXVkSEo1Ulc1MGNtbGxjMXRwWFR0Y2JpQWdJQ0FnSUNBZ2RtRnlJSEpsWTI5eVpDQTlJR1Z1ZEhKNUxtTnZiWEJzWlhScGIyNDdYRzVjYmlBZ0lDQWdJQ0FnYVdZZ0tHVnVkSEo1TG5SeWVVeHZZeUE5UFQwZ1hDSnliMjkwWENJcElIdGNiaUFnSUNBZ0lDQWdJQ0F2THlCRmVHTmxjSFJwYjI0Z2RHaHliM2R1SUc5MWRITnBaR1VnYjJZZ1lXNTVJSFJ5ZVNCaWJHOWpheUIwYUdGMElHTnZkV3hrSUdoaGJtUnNaVnh1SUNBZ0lDQWdJQ0FnSUM4dklHbDBMQ0J6YnlCelpYUWdkR2hsSUdOdmJYQnNaWFJwYjI0Z2RtRnNkV1VnYjJZZ2RHaGxJR1Z1ZEdseVpTQm1kVzVqZEdsdmJpQjBiMXh1SUNBZ0lDQWdJQ0FnSUM4dklIUm9jbTkzSUhSb1pTQmxlR05sY0hScGIyNHVYRzRnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJR2hoYm1Sc1pTaGNJbVZ1WkZ3aUtUdGNiaUFnSUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0FnSUdsbUlDaGxiblJ5ZVM1MGNubE1iMk1nUEQwZ2RHaHBjeTV3Y21WMktTQjdYRzRnSUNBZ0lDQWdJQ0FnZG1GeUlHaGhjME5oZEdOb0lEMGdhR0Z6VDNkdUxtTmhiR3dvWlc1MGNua3NJRndpWTJGMFkyaE1iMk5jSWlrN1hHNGdJQ0FnSUNBZ0lDQWdkbUZ5SUdoaGMwWnBibUZzYkhrZ1BTQm9ZWE5QZDI0dVkyRnNiQ2hsYm5SeWVTd2dYQ0ptYVc1aGJHeDVURzlqWENJcE8xeHVYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tHaGhjME5oZEdOb0lDWW1JR2hoYzBacGJtRnNiSGtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoMGFHbHpMbkJ5WlhZZ1BDQmxiblJ5ZVM1allYUmphRXh2WXlrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnYUdGdVpHeGxLR1Z1ZEhKNUxtTmhkR05vVEc5akxDQjBjblZsS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDBnWld4elpTQnBaaUFvZEdocGN5NXdjbVYySUR3Z1pXNTBjbmt1Wm1sdVlXeHNlVXh2WXlrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnYUdGdVpHeGxLR1Z1ZEhKNUxtWnBibUZzYkhsTWIyTXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJSDBnWld4elpTQnBaaUFvYUdGelEyRjBZMmdwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoMGFHbHpMbkJ5WlhZZ1BDQmxiblJ5ZVM1allYUmphRXh2WXlrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnYUdGdVpHeGxLR1Z1ZEhKNUxtTmhkR05vVEc5akxDQjBjblZsS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tHaGhjMFpwYm1Gc2JIa3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2gwYUdsekxuQnlaWFlnUENCbGJuUnllUzVtYVc1aGJHeDVURzlqS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUJvWVc1a2JHVW9aVzUwY25rdVptbHVZV3hzZVV4dll5azdYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWhjSW5SeWVTQnpkR0YwWlcxbGJuUWdkMmwwYUc5MWRDQmpZWFJqYUNCdmNpQm1hVzVoYkd4NVhDSXBPMXh1SUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgwc1hHNWNiaUFnSUNCaFluSjFjSFE2SUdaMWJtTjBhVzl1SUdGaWNuVndkQ2gwZVhCbExDQmhjbWNwSUh0Y2JpQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQjBhR2x6TG5SeWVVVnVkSEpwWlhNdWJHVnVaM1JvSUMwZ01Uc2dhU0ErUFNBd095QXRMV2twSUh0Y2JpQWdJQ0FnSUNBZ2RtRnlJR1Z1ZEhKNUlEMGdkR2hwY3k1MGNubEZiblJ5YVdWelcybGRPMXh1SUNBZ0lDQWdJQ0JwWmlBb1pXNTBjbmt1ZEhKNVRHOWpJRHc5SUhSb2FYTXVjSEpsZGlBbUppQm9ZWE5QZDI0dVkyRnNiQ2hsYm5SeWVTd2dYQ0ptYVc1aGJHeDVURzlqWENJcElDWW1JSFJvYVhNdWNISmxkaUE4SUdWdWRISjVMbVpwYm1Gc2JIbE1iMk1wSUh0Y2JpQWdJQ0FnSUNBZ0lDQjJZWElnWm1sdVlXeHNlVVZ1ZEhKNUlEMGdaVzUwY25rN1hHNGdJQ0FnSUNBZ0lDQWdZbkpsWVdzN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdhV1lnS0dacGJtRnNiSGxGYm5SeWVTQW1KaUFvZEhsd1pTQTlQVDBnWENKaWNtVmhhMXdpSUh4OElIUjVjR1VnUFQwOUlGd2lZMjl1ZEdsdWRXVmNJaWtnSmlZZ1ptbHVZV3hzZVVWdWRISjVMblJ5ZVV4dll5QThQU0JoY21jZ0ppWWdZWEpuSUR3OUlHWnBibUZzYkhsRmJuUnllUzVtYVc1aGJHeDVURzlqS1NCN1hHNGdJQ0FnSUNBZ0lDOHZJRWxuYm05eVpTQjBhR1VnWm1sdVlXeHNlU0JsYm5SeWVTQnBaaUJqYjI1MGNtOXNJR2x6SUc1dmRDQnFkVzF3YVc1bklIUnZJR0ZjYmlBZ0lDQWdJQ0FnTHk4Z2JHOWpZWFJwYjI0Z2IzVjBjMmxrWlNCMGFHVWdkSEo1TDJOaGRHTm9JR0pzYjJOckxseHVJQ0FnSUNBZ0lDQm1hVzVoYkd4NVJXNTBjbmtnUFNCdWRXeHNPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0IyWVhJZ2NtVmpiM0prSUQwZ1ptbHVZV3hzZVVWdWRISjVJRDhnWm1sdVlXeHNlVVZ1ZEhKNUxtTnZiWEJzWlhScGIyNGdPaUI3ZlR0Y2JpQWdJQ0FnSUhKbFkyOXlaQzUwZVhCbElEMGdkSGx3WlR0Y2JpQWdJQ0FnSUhKbFkyOXlaQzVoY21jZ1BTQmhjbWM3WEc1Y2JpQWdJQ0FnSUdsbUlDaG1hVzVoYkd4NVJXNTBjbmtwSUh0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTV1WlhoMElEMGdabWx1WVd4c2VVVnVkSEo1TG1acGJtRnNiSGxNYjJNN1hHNGdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbU52YlhCc1pYUmxLSEpsWTI5eVpDazdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJSEpsZEhWeWJpQkRiMjUwYVc1MVpWTmxiblJwYm1Wc08xeHVJQ0FnSUgwc1hHNWNiaUFnSUNCamIyMXdiR1YwWlRvZ1puVnVZM1JwYjI0Z1kyOXRjR3hsZEdVb2NtVmpiM0prTENCaFpuUmxja3h2WXlrZ2UxeHVJQ0FnSUNBZ2FXWWdLSEpsWTI5eVpDNTBlWEJsSUQwOVBTQmNJblJvY205M1hDSXBJSHRjYmlBZ0lDQWdJQ0FnZEdoeWIzY2djbVZqYjNKa0xtRnlaenRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnYVdZZ0tISmxZMjl5WkM1MGVYQmxJRDA5UFNCY0ltSnlaV0ZyWENJZ2ZId2djbVZqYjNKa0xuUjVjR1VnUFQwOUlGd2lZMjl1ZEdsdWRXVmNJaWtnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbTVsZUhRZ1BTQnlaV052Y21RdVlYSm5PMXh1SUNBZ0lDQWdmU0JsYkhObElHbG1JQ2h5WldOdmNtUXVkSGx3WlNBOVBUMGdYQ0p5WlhSMWNtNWNJaWtnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbkoyWVd3Z1BTQnlaV052Y21RdVlYSm5PMXh1SUNBZ0lDQWdJQ0IwYUdsekxtNWxlSFFnUFNCY0ltVnVaRndpTzF4dUlDQWdJQ0FnZlNCbGJITmxJR2xtSUNoeVpXTnZjbVF1ZEhsd1pTQTlQVDBnWENKdWIzSnRZV3hjSWlBbUppQmhablJsY2t4dll5a2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekxtNWxlSFFnUFNCaFpuUmxja3h2WXp0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnWm1sdWFYTm9PaUJtZFc1amRHbHZiaUJtYVc1cGMyZ29abWx1WVd4c2VVeHZZeWtnZTF4dUlDQWdJQ0FnWm05eUlDaDJZWElnYVNBOUlIUm9hWE11ZEhKNVJXNTBjbWxsY3k1c1pXNW5kR2dnTFNBeE95QnBJRDQ5SURBN0lDMHRhU2tnZTF4dUlDQWdJQ0FnSUNCMllYSWdaVzUwY25rZ1BTQjBhR2x6TG5SeWVVVnVkSEpwWlhOYmFWMDdYRzRnSUNBZ0lDQWdJR2xtSUNobGJuUnllUzVtYVc1aGJHeDVURzlqSUQwOVBTQm1hVzVoYkd4NVRHOWpLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2RHaHBjeTVqYjIxd2JHVjBaU2hsYm5SeWVTNWpiMjF3YkdWMGFXOXVMQ0JsYm5SeWVTNWhablJsY2t4dll5azdYRzRnSUNBZ0lDQWdJQ0FnY21WelpYUlVjbmxGYm5SeWVTaGxiblJ5ZVNrN1hHNGdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlFTnZiblJwYm5WbFUyVnVkR2x1Wld3N1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMWNiaUFnSUNCOUxGeHVYRzRnSUNBZ1hDSmpZWFJqYUZ3aU9pQm1kVzVqZEdsdmJpQmZZMkYwWTJnb2RISjVURzlqS1NCN1hHNGdJQ0FnSUNCbWIzSWdLSFpoY2lCcElEMGdkR2hwY3k1MGNubEZiblJ5YVdWekxteGxibWQwYUNBdElERTdJR2tnUGowZ01Ec2dMUzFwS1NCN1hHNGdJQ0FnSUNBZ0lIWmhjaUJsYm5SeWVTQTlJSFJvYVhNdWRISjVSVzUwY21sbGMxdHBYVHRjYmlBZ0lDQWdJQ0FnYVdZZ0tHVnVkSEo1TG5SeWVVeHZZeUE5UFQwZ2RISjVURzlqS1NCN1hHNGdJQ0FnSUNBZ0lDQWdkbUZ5SUhKbFkyOXlaQ0E5SUdWdWRISjVMbU52YlhCc1pYUnBiMjQ3WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLSEpsWTI5eVpDNTBlWEJsSUQwOVBTQmNJblJvY205M1hDSXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIWmhjaUIwYUhKdmQyNGdQU0J5WldOdmNtUXVZWEpuTzF4dUlDQWdJQ0FnSUNBZ0lDQWdjbVZ6WlhSVWNubEZiblJ5ZVNobGJuUnllU2s3WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhSEp2ZDI0N1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdMeThnVkdobElHTnZiblJsZUhRdVkyRjBZMmdnYldWMGFHOWtJRzExYzNRZ2IyNXNlU0JpWlNCallXeHNaV1FnZDJsMGFDQmhJR3h2WTJGMGFXOXVYRzRnSUNBZ0lDQXZMeUJoY21kMWJXVnVkQ0IwYUdGMElHTnZjbkpsYzNCdmJtUnpJSFJ2SUdFZ2EyNXZkMjRnWTJGMFkyZ2dZbXh2WTJzdVhHNGdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvWENKcGJHeGxaMkZzSUdOaGRHTm9JR0YwZEdWdGNIUmNJaWs3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJR1JsYkdWbllYUmxXV2xsYkdRNklHWjFibU4wYVc5dUlHUmxiR1ZuWVhSbFdXbGxiR1FvYVhSbGNtRmliR1VzSUhKbGMzVnNkRTVoYldVc0lHNWxlSFJNYjJNcElIdGNiaUFnSUNBZ0lIUm9hWE11WkdWc1pXZGhkR1VnUFNCN1hHNGdJQ0FnSUNBZ0lHbDBaWEpoZEc5eU9pQjJZV3gxWlhNb2FYUmxjbUZpYkdVcExGeHVJQ0FnSUNBZ0lDQnlaWE4xYkhST1lXMWxPaUJ5WlhOMWJIUk9ZVzFsTEZ4dUlDQWdJQ0FnSUNCdVpYaDBURzlqT2lCdVpYaDBURzlqWEc0Z0lDQWdJQ0I5TzF4dVhHNGdJQ0FnSUNCeVpYUjFjbTRnUTI5dWRHbHVkV1ZUWlc1MGFXNWxiRHRjYmlBZ0lDQjlYRzRnSUgwN1hHNTlLU2hjYmk4dklFRnRiMjVuSUhSb1pTQjJZWEpwYjNWeklIUnlhV05yY3lCbWIzSWdiMkowWVdsdWFXNW5JR0VnY21WbVpYSmxibU5sSUhSdklIUm9aU0JuYkc5aVlXeGNiaTh2SUc5aWFtVmpkQ3dnZEdocGN5QnpaV1Z0Y3lCMGJ5QmlaU0IwYUdVZ2JXOXpkQ0J5Wld4cFlXSnNaU0IwWldOb2JtbHhkV1VnZEdoaGRDQmtiMlZ6SUc1dmRGeHVMeThnZFhObElHbHVaR2x5WldOMElHVjJZV3dnS0hkb2FXTm9JSFpwYjJ4aGRHVnpJRU52Ym5SbGJuUWdVMlZqZFhKcGRIa2dVRzlzYVdONUtTNWNiblI1Y0dWdlppQm5iRzlpWVd3Z1BUMDlJRndpYjJKcVpXTjBYQ0lnUHlCbmJHOWlZV3dnT2lCMGVYQmxiMllnZDJsdVpHOTNJRDA5UFNCY0ltOWlhbVZqZEZ3aUlEOGdkMmx1Wkc5M0lEb2dkSGx3Wlc5bUlITmxiR1lnUFQwOUlGd2liMkpxWldOMFhDSWdQeUJ6Wld4bUlEb2dkVzVrWldacGJtVmtLVHNpWFgwPSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJveEludGVyc2VjdFdyYXBwZXJcblxudmFyIHBvb2wgPSByZXF1aXJlKCd0eXBlZGFycmF5LXBvb2wnKVxudmFyIHN3ZWVwID0gcmVxdWlyZSgnLi9saWIvc3dlZXAnKVxudmFyIGJveEludGVyc2VjdEl0ZXIgPSByZXF1aXJlKCcuL2xpYi9pbnRlcnNlY3QnKVxuXG5mdW5jdGlvbiBib3hFbXB0eShkLCBib3gpIHtcbiAgZm9yKHZhciBqPTA7IGo8ZDsgKytqKSB7XG4gICAgaWYoIShib3hbal0gPD0gYm94W2orZF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy9VbnBhY2sgYm94ZXMgaW50byBhIGZsYXQgdHlwZWQgYXJyYXksIHJlbW92ZSBlbXB0eSBib3hlc1xuZnVuY3Rpb24gY29udmVydEJveGVzKGJveGVzLCBkLCBkYXRhLCBpZHMpIHtcbiAgdmFyIHB0ciA9IDBcbiAgdmFyIGNvdW50ID0gMFxuICBmb3IodmFyIGk9MCwgbj1ib3hlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdmFyIGIgPSBib3hlc1tpXVxuICAgIGlmKGJveEVtcHR5KGQsIGIpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBmb3IodmFyIGo9MDsgajwyKmQ7ICsraikge1xuICAgICAgZGF0YVtwdHIrK10gPSBiW2pdXG4gICAgfVxuICAgIGlkc1tjb3VudCsrXSA9IGlcbiAgfVxuICByZXR1cm4gY291bnRcbn1cblxuLy9QZXJmb3JtIHR5cGUgY29udmVyc2lvbnMsIGNoZWNrIGJvdW5kc1xuZnVuY3Rpb24gYm94SW50ZXJzZWN0KHJlZCwgYmx1ZSwgdmlzaXQsIGZ1bGwpIHtcbiAgdmFyIG4gPSByZWQubGVuZ3RoXG4gIHZhciBtID0gYmx1ZS5sZW5ndGhcblxuICAvL0lmIGVpdGhlciBhcnJheSBpcyBlbXB0eSwgdGhlbiB3ZSBjYW4gc2tpcCB0aGlzIHdob2xlIHRoaW5nXG4gIGlmKG4gPD0gMCB8fCBtIDw9IDApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vQ29tcHV0ZSBkaW1lbnNpb24sIGlmIGl0IGlzIDAgdGhlbiB3ZSBza2lwXG4gIHZhciBkID0gKHJlZFswXS5sZW5ndGgpPj4+MVxuICBpZihkIDw9IDApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciByZXR2YWxcblxuICAvL0NvbnZlcnQgcmVkIGJveGVzXG4gIHZhciByZWRMaXN0ICA9IHBvb2wubWFsbG9jRG91YmxlKDIqZCpuKVxuICB2YXIgcmVkSWRzICAgPSBwb29sLm1hbGxvY0ludDMyKG4pXG4gIG4gPSBjb252ZXJ0Qm94ZXMocmVkLCBkLCByZWRMaXN0LCByZWRJZHMpXG5cbiAgaWYobiA+IDApIHtcbiAgICBpZihkID09PSAxICYmIGZ1bGwpIHtcbiAgICAgIC8vU3BlY2lhbCBjYXNlOiAxZCBjb21wbGV0ZVxuICAgICAgc3dlZXAuaW5pdChuKVxuICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBDb21wbGV0ZShcbiAgICAgICAgZCwgdmlzaXQsIFxuICAgICAgICAwLCBuLCByZWRMaXN0LCByZWRJZHMsXG4gICAgICAgIDAsIG4sIHJlZExpc3QsIHJlZElkcylcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvL0NvbnZlcnQgYmx1ZSBib3hlc1xuICAgICAgdmFyIGJsdWVMaXN0ID0gcG9vbC5tYWxsb2NEb3VibGUoMipkKm0pXG4gICAgICB2YXIgYmx1ZUlkcyAgPSBwb29sLm1hbGxvY0ludDMyKG0pXG4gICAgICBtID0gY29udmVydEJveGVzKGJsdWUsIGQsIGJsdWVMaXN0LCBibHVlSWRzKVxuXG4gICAgICBpZihtID4gMCkge1xuICAgICAgICBzd2VlcC5pbml0KG4rbSlcblxuICAgICAgICBpZihkID09PSAxKSB7XG4gICAgICAgICAgLy9TcGVjaWFsIGNhc2U6IDFkIGJpcGFydGl0ZVxuICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgZCwgdmlzaXQsIFxuICAgICAgICAgICAgMCwgbiwgcmVkTGlzdCwgIHJlZElkcyxcbiAgICAgICAgICAgIDAsIG0sIGJsdWVMaXN0LCBibHVlSWRzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vR2VuZXJhbCBjYXNlOiAgZD4xXG4gICAgICAgICAgcmV0dmFsID0gYm94SW50ZXJzZWN0SXRlcihcbiAgICAgICAgICAgIGQsIHZpc2l0LCAgICBmdWxsLFxuICAgICAgICAgICAgbiwgcmVkTGlzdCwgIHJlZElkcyxcbiAgICAgICAgICAgIG0sIGJsdWVMaXN0LCBibHVlSWRzKVxuICAgICAgICB9XG5cbiAgICAgICAgcG9vbC5mcmVlKGJsdWVMaXN0KVxuICAgICAgICBwb29sLmZyZWUoYmx1ZUlkcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwb29sLmZyZWUocmVkTGlzdClcbiAgICBwb29sLmZyZWUocmVkSWRzKVxuICB9XG5cbiAgcmV0dXJuIHJldHZhbFxufVxuXG5cbnZhciBSRVNVTFRcblxuZnVuY3Rpb24gYXBwZW5kSXRlbShpLGopIHtcbiAgUkVTVUxULnB1c2goW2ksal0pXG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdEZ1bGxBcnJheSh4KSB7XG4gIFJFU1VMVCA9IFtdXG4gIGJveEludGVyc2VjdCh4LCB4LCBhcHBlbmRJdGVtLCB0cnVlKVxuICByZXR1cm4gUkVTVUxUXG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdEJpcGFydGl0ZUFycmF5KHgsIHkpIHtcbiAgUkVTVUxUID0gW11cbiAgYm94SW50ZXJzZWN0KHgsIHksIGFwcGVuZEl0ZW0sIGZhbHNlKVxuICByZXR1cm4gUkVTVUxUXG59XG5cbi8vVXNlci1mcmllbmRseSB3cmFwcGVyLCBoYW5kbGUgZnVsbCBpbnB1dCBhbmQgbm8tdmlzaXRvciBjYXNlc1xuZnVuY3Rpb24gYm94SW50ZXJzZWN0V3JhcHBlcihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gIHZhciByZXN1bHRcbiAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gaW50ZXJzZWN0RnVsbEFycmF5KGFyZzApXG4gICAgY2FzZSAyOlxuICAgICAgaWYodHlwZW9mIGFyZzEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGJveEludGVyc2VjdChhcmcwLCBhcmcwLCBhcmcxLCB0cnVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGludGVyc2VjdEJpcGFydGl0ZUFycmF5KGFyZzAsIGFyZzEpXG4gICAgICB9XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGJveEludGVyc2VjdChhcmcwLCBhcmcxLCBhcmcyLCBmYWxzZSlcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3gtaW50ZXJzZWN0OiBJbnZhbGlkIGFyZ3VtZW50cycpXG4gIH1cbn0iLCIndXNlIHN0cmljdCdcblxudmFyIERJTUVOU0lPTiAgID0gJ2QnXG52YXIgQVhJUyAgICAgICAgPSAnYXgnXG52YXIgVklTSVQgICAgICAgPSAndnYnXG52YXIgRkxJUCAgICAgICAgPSAnZnAnXG5cbnZhciBFTEVNX1NJWkUgICA9ICdlcydcblxudmFyIFJFRF9TVEFSVCAgID0gJ3JzJ1xudmFyIFJFRF9FTkQgICAgID0gJ3JlJ1xudmFyIFJFRF9CT1hFUyAgID0gJ3JiJ1xudmFyIFJFRF9JTkRFWCAgID0gJ3JpJ1xudmFyIFJFRF9QVFIgICAgID0gJ3JwJ1xuXG52YXIgQkxVRV9TVEFSVCAgPSAnYnMnXG52YXIgQkxVRV9FTkQgICAgPSAnYmUnXG52YXIgQkxVRV9CT1hFUyAgPSAnYmInXG52YXIgQkxVRV9JTkRFWCAgPSAnYmknXG52YXIgQkxVRV9QVFIgICAgPSAnYnAnXG5cbnZhciBSRVRWQUwgICAgICA9ICdydidcblxudmFyIElOTkVSX0xBQkVMID0gJ1EnXG5cbnZhciBBUkdTID0gW1xuICBESU1FTlNJT04sXG4gIEFYSVMsXG4gIFZJU0lULFxuICBSRURfU1RBUlQsXG4gIFJFRF9FTkQsXG4gIFJFRF9CT1hFUyxcbiAgUkVEX0lOREVYLFxuICBCTFVFX1NUQVJULFxuICBCTFVFX0VORCxcbiAgQkxVRV9CT1hFUyxcbiAgQkxVRV9JTkRFWFxuXVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUJydXRlRm9yY2UocmVkTWFqb3IsIGZsaXAsIGZ1bGwpIHtcbiAgdmFyIGZ1bmNOYW1lID0gJ2JydXRlRm9yY2UnICsgXG4gICAgKHJlZE1ham9yID8gJ1JlZCcgOiAnQmx1ZScpICsgXG4gICAgKGZsaXAgPyAnRmxpcCcgOiAnJykgK1xuICAgIChmdWxsID8gJ0Z1bGwnIDogJycpXG5cbiAgdmFyIGNvZGUgPSBbJ2Z1bmN0aW9uICcsIGZ1bmNOYW1lLCAnKCcsIEFSR1Muam9pbigpLCAnKXsnLFxuICAgICd2YXIgJywgRUxFTV9TSVpFLCAnPTIqJywgRElNRU5TSU9OLCAnOyddXG5cbiAgdmFyIHJlZExvb3AgPSBcbiAgICAnZm9yKHZhciBpPScgKyBSRURfU1RBUlQgKyAnLCcgKyBSRURfUFRSICsgJz0nICsgRUxFTV9TSVpFICsgJyonICsgUkVEX1NUQVJUICsgJzsnICtcbiAgICAgICAgJ2k8JyArIFJFRF9FTkQgKyc7JyArXG4gICAgICAgICcrK2ksJyArIFJFRF9QVFIgKyAnKz0nICsgRUxFTV9TSVpFICsgJyl7JyArXG4gICAgICAgICd2YXIgeDA9JyArIFJFRF9CT1hFUyArICdbJyArIEFYSVMgKyAnKycgKyBSRURfUFRSICsgJ10sJyArXG4gICAgICAgICAgICAneDE9JyArIFJFRF9CT1hFUyArICdbJyArIEFYSVMgKyAnKycgKyBSRURfUFRSICsgJysnICsgRElNRU5TSU9OICsgJ10sJyArXG4gICAgICAgICAgICAneGk9JyArIFJFRF9JTkRFWCArICdbaV07J1xuXG4gIHZhciBibHVlTG9vcCA9IFxuICAgICdmb3IodmFyIGo9JyArIEJMVUVfU1RBUlQgKyAnLCcgKyBCTFVFX1BUUiArICc9JyArIEVMRU1fU0laRSArICcqJyArIEJMVUVfU1RBUlQgKyAnOycgK1xuICAgICAgICAnajwnICsgQkxVRV9FTkQgKyAnOycgK1xuICAgICAgICAnKytqLCcgKyBCTFVFX1BUUiArICcrPScgKyBFTEVNX1NJWkUgKyAnKXsnICtcbiAgICAgICAgJ3ZhciB5MD0nICsgQkxVRV9CT1hFUyArICdbJyArIEFYSVMgKyAnKycgKyBCTFVFX1BUUiArICddLCcgK1xuICAgICAgICAgICAgKGZ1bGwgPyAneTE9JyArIEJMVUVfQk9YRVMgKyAnWycgKyBBWElTICsgJysnICsgQkxVRV9QVFIgKyAnKycgKyBESU1FTlNJT04gKyAnXSwnIDogJycpICtcbiAgICAgICAgICAgICd5aT0nICsgQkxVRV9JTkRFWCArICdbal07J1xuXG4gIGlmKHJlZE1ham9yKSB7XG4gICAgY29kZS5wdXNoKHJlZExvb3AsIElOTkVSX0xBQkVMLCAnOicsIGJsdWVMb29wKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChibHVlTG9vcCwgSU5ORVJfTEFCRUwsICc6JywgcmVkTG9vcClcbiAgfVxuXG4gIGlmKGZ1bGwpIHtcbiAgICBjb2RlLnB1c2goJ2lmKHkxPHgwfHx4MTx5MCljb250aW51ZTsnKVxuICB9IGVsc2UgaWYoZmxpcCkge1xuICAgIGNvZGUucHVzaCgnaWYoeTA8PXgwfHx4MTx5MCljb250aW51ZTsnKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaCgnaWYoeTA8eDB8fHgxPHkwKWNvbnRpbnVlOycpXG4gIH1cblxuICBjb2RlLnB1c2goJ2Zvcih2YXIgaz0nK0FYSVMrJysxO2s8JytESU1FTlNJT04rJzsrK2speycrXG4gICAgJ3ZhciByMD0nK1JFRF9CT1hFUysnW2srJytSRURfUFRSKyddLCcrXG4gICAgICAgICdyMT0nK1JFRF9CT1hFUysnW2srJytESU1FTlNJT04rJysnK1JFRF9QVFIrJ10sJytcbiAgICAgICAgJ2IwPScrQkxVRV9CT1hFUysnW2srJytCTFVFX1BUUisnXSwnK1xuICAgICAgICAnYjE9JytCTFVFX0JPWEVTKydbaysnK0RJTUVOU0lPTisnKycrQkxVRV9QVFIrJ107JytcbiAgICAgICdpZihyMTxiMHx8YjE8cjApY29udGludWUgJyArIElOTkVSX0xBQkVMICsgJzt9JyArXG4gICAgICAndmFyICcgKyBSRVRWQUwgKyAnPScgKyBWSVNJVCArICcoJylcblxuICBpZihmbGlwKSB7XG4gICAgY29kZS5wdXNoKCd5aSx4aScpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKCd4aSx5aScpXG4gIH1cblxuICBjb2RlLnB1c2goJyk7aWYoJyArIFJFVFZBTCArICchPT12b2lkIDApcmV0dXJuICcgKyBSRVRWQUwgKyAnO319fScpXG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBmdW5jTmFtZSwgXG4gICAgY29kZTogY29kZS5qb2luKCcnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJydXRlRm9yY2VQbGFubmVyKGZ1bGwpIHtcbiAgdmFyIGZ1bmNOYW1lID0gJ2JydXRlRm9yY2UnICsgKGZ1bGwgPyAnRnVsbCcgOiAnUGFydGlhbCcpXG4gIHZhciBwcmVmaXggPSBbXVxuICB2YXIgZmFyZ3MgPSBBUkdTLnNsaWNlKClcbiAgaWYoIWZ1bGwpIHtcbiAgICBmYXJncy5zcGxpY2UoMywgMCwgRkxJUClcbiAgfVxuXG4gIHZhciBjb2RlID0gWydmdW5jdGlvbiAnICsgZnVuY05hbWUgKyAnKCcgKyBmYXJncy5qb2luKCkgKyAnKXsnXVxuXG4gIGZ1bmN0aW9uIGludm9rZShyZWRNYWpvciwgZmxpcCkge1xuICAgIHZhciByZXMgPSBnZW5lcmF0ZUJydXRlRm9yY2UocmVkTWFqb3IsIGZsaXAsIGZ1bGwpXG4gICAgcHJlZml4LnB1c2gocmVzLmNvZGUpXG4gICAgY29kZS5wdXNoKCdyZXR1cm4gJyArIHJlcy5uYW1lICsgJygnICsgQVJHUy5qb2luKCkgKyAnKTsnKVxuICB9XG5cbiAgY29kZS5wdXNoKCdpZignICsgUkVEX0VORCArICctJyArIFJFRF9TVEFSVCArICc+JyArXG4gICAgICAgICAgICAgICAgICAgIEJMVUVfRU5EICsgJy0nICsgQkxVRV9TVEFSVCArICcpeycpXG5cbiAgaWYoZnVsbCkge1xuICAgIGludm9rZSh0cnVlLCBmYWxzZSlcbiAgICBjb2RlLnB1c2goJ31lbHNleycpXG4gICAgaW52b2tlKGZhbHNlLCBmYWxzZSlcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goJ2lmKCcgKyBGTElQICsgJyl7JylcbiAgICBpbnZva2UodHJ1ZSwgdHJ1ZSlcbiAgICBjb2RlLnB1c2goJ31lbHNleycpXG4gICAgaW52b2tlKHRydWUsIGZhbHNlKVxuICAgIGNvZGUucHVzaCgnfX1lbHNle2lmKCcgKyBGTElQICsgJyl7JylcbiAgICBpbnZva2UoZmFsc2UsIHRydWUpXG4gICAgY29kZS5wdXNoKCd9ZWxzZXsnKVxuICAgIGludm9rZShmYWxzZSwgZmFsc2UpXG4gICAgY29kZS5wdXNoKCd9JylcbiAgfVxuICBjb2RlLnB1c2goJ319cmV0dXJuICcgKyBmdW5jTmFtZSlcblxuICB2YXIgY29kZVN0ciA9IHByZWZpeC5qb2luKCcnKSArIGNvZGUuam9pbignJylcbiAgdmFyIHByb2MgPSBuZXcgRnVuY3Rpb24oY29kZVN0cilcbiAgcmV0dXJuIHByb2MoKVxufVxuXG5cbmV4cG9ydHMucGFydGlhbCA9IGJydXRlRm9yY2VQbGFubmVyKGZhbHNlKVxuZXhwb3J0cy5mdWxsICAgID0gYnJ1dGVGb3JjZVBsYW5uZXIodHJ1ZSkiLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBib3hJbnRlcnNlY3RJdGVyXG5cbnZhciBwb29sID0gcmVxdWlyZSgndHlwZWRhcnJheS1wb29sJylcbnZhciBiaXRzID0gcmVxdWlyZSgnYml0LXR3aWRkbGUnKVxudmFyIGJydXRlRm9yY2UgPSByZXF1aXJlKCcuL2JydXRlJylcbnZhciBicnV0ZUZvcmNlUGFydGlhbCA9IGJydXRlRm9yY2UucGFydGlhbFxudmFyIGJydXRlRm9yY2VGdWxsID0gYnJ1dGVGb3JjZS5mdWxsXG52YXIgc3dlZXAgPSByZXF1aXJlKCcuL3N3ZWVwJylcbnZhciBmaW5kTWVkaWFuID0gcmVxdWlyZSgnLi9tZWRpYW4nKVxudmFyIGdlblBhcnRpdGlvbiA9IHJlcXVpcmUoJy4vcGFydGl0aW9uJylcblxuLy9Ud2lkZGxlIHBhcmFtZXRlcnNcbnZhciBCUlVURV9GT1JDRV9DVVRPRkYgICAgPSAxMjggICAgICAgLy9DdXQgb2ZmIGZvciBicnV0ZSBmb3JjZSBzZWFyY2hcbnZhciBTQ0FOX0NVVE9GRiAgICAgICAgICAgPSAoMTw8MjIpICAgLy9DdXQgb2ZmIGZvciB0d28gd2F5IHNjYW5cbnZhciBTQ0FOX0NPTVBMRVRFX0NVVE9GRiAgPSAoMTw8MjIpICBcblxuLy9QYXJ0aXRpb24gZnVuY3Rpb25zXG52YXIgcGFydGl0aW9uSW50ZXJpb3JDb250YWluc0ludGVydmFsID0gZ2VuUGFydGl0aW9uKFxuICAnIShsbz49cDApJiYhKHAxPj1oaSknLCBcbiAgWydwMCcsICdwMSddKVxuXG52YXIgcGFydGl0aW9uU3RhcnRFcXVhbCA9IGdlblBhcnRpdGlvbihcbiAgJ2xvPT09cDAnLFxuICBbJ3AwJ10pXG5cbnZhciBwYXJ0aXRpb25TdGFydExlc3NUaGFuID0gZ2VuUGFydGl0aW9uKFxuICAnbG88cDAnLFxuICBbJ3AwJ10pXG5cbnZhciBwYXJ0aXRpb25FbmRMZXNzVGhhbkVxdWFsID0gZ2VuUGFydGl0aW9uKFxuICAnaGk8PXAwJyxcbiAgWydwMCddKVxuXG52YXIgcGFydGl0aW9uQ29udGFpbnNQb2ludCA9IGdlblBhcnRpdGlvbihcbiAgJ2xvPD1wMCYmcDA8PWhpJyxcbiAgWydwMCddKVxuXG52YXIgcGFydGl0aW9uQ29udGFpbnNQb2ludFByb3BlciA9IGdlblBhcnRpdGlvbihcbiAgJ2xvPHAwJiZwMDw9aGknLFxuICBbJ3AwJ10pXG5cbi8vRnJhbWUgc2l6ZSBmb3IgaXRlcmF0aXZlIGxvb3BcbnZhciBJRlJBTUVfU0laRSA9IDZcbnZhciBERlJBTUVfU0laRSA9IDJcblxuLy9EYXRhIGZvciBib3ggc3RhdGNrXG52YXIgSU5JVF9DQVBBQ0lUWSA9IDEwMjRcbnZhciBCT1hfSVNUQUNLICA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBCT1hfRFNUQUNLICA9IHBvb2wubWFsbG9jRG91YmxlKElOSVRfQ0FQQUNJVFkpXG5cbi8vSW5pdGlhbGl6ZSBpdGVyYXRpdmUgbG9vcCBxdWV1ZVxuZnVuY3Rpb24gaXRlckluaXQoZCwgY291bnQpIHtcbiAgdmFyIGxldmVscyA9ICg4ICogYml0cy5sb2cyKGNvdW50KzEpICogKGQrMSkpfDBcbiAgdmFyIG1heEludHMgPSBiaXRzLm5leHRQb3cyKElGUkFNRV9TSVpFKmxldmVscylcbiAgaWYoQk9YX0lTVEFDSy5sZW5ndGggPCBtYXhJbnRzKSB7XG4gICAgcG9vbC5mcmVlKEJPWF9JU1RBQ0spXG4gICAgQk9YX0lTVEFDSyA9IHBvb2wubWFsbG9jSW50MzIobWF4SW50cylcbiAgfVxuICB2YXIgbWF4RG91YmxlcyA9IGJpdHMubmV4dFBvdzIoREZSQU1FX1NJWkUqbGV2ZWxzKVxuICBpZihCT1hfRFNUQUNLIDwgbWF4RG91Ymxlcykge1xuICAgIHBvb2wuZnJlZShCT1hfRFNUQUNLKVxuICAgIEJPWF9EU1RBQ0sgPSBwb29sLm1hbGxvY0RvdWJsZShtYXhEb3VibGVzKVxuICB9XG59XG5cbi8vQXBwZW5kIGl0ZW0gdG8gcXVldWVcbmZ1bmN0aW9uIGl0ZXJQdXNoKHB0cixcbiAgYXhpcywgXG4gIHJlZFN0YXJ0LCByZWRFbmQsIFxuICBibHVlU3RhcnQsIGJsdWVFbmQsIFxuICBzdGF0ZSwgXG4gIGxvLCBoaSkge1xuXG4gIHZhciBpcHRyID0gSUZSQU1FX1NJWkUgKiBwdHJcbiAgQk9YX0lTVEFDS1tpcHRyXSAgID0gYXhpc1xuICBCT1hfSVNUQUNLW2lwdHIrMV0gPSByZWRTdGFydFxuICBCT1hfSVNUQUNLW2lwdHIrMl0gPSByZWRFbmRcbiAgQk9YX0lTVEFDS1tpcHRyKzNdID0gYmx1ZVN0YXJ0XG4gIEJPWF9JU1RBQ0tbaXB0cis0XSA9IGJsdWVFbmRcbiAgQk9YX0lTVEFDS1tpcHRyKzVdID0gc3RhdGVcblxuICB2YXIgZHB0ciA9IERGUkFNRV9TSVpFICogcHRyXG4gIEJPWF9EU1RBQ0tbZHB0cl0gICA9IGxvXG4gIEJPWF9EU1RBQ0tbZHB0cisxXSA9IGhpXG59XG5cbi8vU3BlY2lhbCBjYXNlOiAgSW50ZXJzZWN0IHNpbmdsZSBwb2ludCB3aXRoIGxpc3Qgb2YgaW50ZXJ2YWxzXG5mdW5jdGlvbiBvbmVQb2ludFBhcnRpYWwoXG4gIGQsIGF4aXMsIHZpc2l0LCBmbGlwLFxuICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlT2Zmc2V0LCBibHVlLCBibHVlSWQpIHtcblxuICB2YXIgZWxlbVNpemUgPSAyICogZFxuICB2YXIgYmx1ZVB0ciAgPSBibHVlT2Zmc2V0ICogZWxlbVNpemVcbiAgdmFyIGJsdWVYICAgID0gYmx1ZVtibHVlUHRyICsgYXhpc11cblxucmVkX2xvb3A6XG4gIGZvcih2YXIgaT1yZWRTdGFydCwgcmVkUHRyPXJlZFN0YXJ0KmVsZW1TaXplOyBpPHJlZEVuZDsgKytpLCByZWRQdHIrPWVsZW1TaXplKSB7XG4gICAgdmFyIHIwID0gcmVkW3JlZFB0citheGlzXVxuICAgIHZhciByMSA9IHJlZFtyZWRQdHIrYXhpcytkXVxuICAgIGlmKGJsdWVYIDwgcjAgfHwgcjEgPCBibHVlWCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYoZmxpcCAmJiBibHVlWCA9PT0gcjApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciByZWRJZCA9IHJlZEluZGV4W2ldXG4gICAgZm9yKHZhciBqPWF4aXMrMTsgajxkOyArK2opIHtcbiAgICAgIHZhciByMCA9IHJlZFtyZWRQdHIral1cbiAgICAgIHZhciByMSA9IHJlZFtyZWRQdHIraitkXVxuICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2pdXG4gICAgICB2YXIgYjEgPSBibHVlW2JsdWVQdHIraitkXVxuICAgICAgaWYocjEgPCBiMCB8fCBiMSA8IHIwKSB7XG4gICAgICAgIGNvbnRpbnVlIHJlZF9sb29wXG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXR2YWxcbiAgICBpZihmbGlwKSB7XG4gICAgICByZXR2YWwgPSB2aXNpdChibHVlSWQsIHJlZElkKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR2YWwgPSB2aXNpdChyZWRJZCwgYmx1ZUlkKVxuICAgIH1cbiAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHJldHZhbFxuICAgIH1cbiAgfVxufVxuXG4vL1NwZWNpYWwgY2FzZTogIEludGVyc2VjdCBvbmUgcG9pbnQgd2l0aCBsaXN0IG9mIGludGVydmFsc1xuZnVuY3Rpb24gb25lUG9pbnRGdWxsKFxuICBkLCBheGlzLCB2aXNpdCxcbiAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgYmx1ZU9mZnNldCwgYmx1ZSwgYmx1ZUlkKSB7XG5cbiAgdmFyIGVsZW1TaXplID0gMiAqIGRcbiAgdmFyIGJsdWVQdHIgID0gYmx1ZU9mZnNldCAqIGVsZW1TaXplXG4gIHZhciBibHVlWCAgICA9IGJsdWVbYmx1ZVB0ciArIGF4aXNdXG5cbnJlZF9sb29wOlxuICBmb3IodmFyIGk9cmVkU3RhcnQsIHJlZFB0cj1yZWRTdGFydCplbGVtU2l6ZTsgaTxyZWRFbmQ7ICsraSwgcmVkUHRyKz1lbGVtU2l6ZSkge1xuICAgIHZhciByZWRJZCA9IHJlZEluZGV4W2ldXG4gICAgaWYocmVkSWQgPT09IGJsdWVJZCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdmFyIHIwID0gcmVkW3JlZFB0citheGlzXVxuICAgIHZhciByMSA9IHJlZFtyZWRQdHIrYXhpcytkXVxuICAgIGlmKGJsdWVYIDwgcjAgfHwgcjEgPCBibHVlWCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgZm9yKHZhciBqPWF4aXMrMTsgajxkOyArK2opIHtcbiAgICAgIHZhciByMCA9IHJlZFtyZWRQdHIral1cbiAgICAgIHZhciByMSA9IHJlZFtyZWRQdHIraitkXVxuICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2pdXG4gICAgICB2YXIgYjEgPSBibHVlW2JsdWVQdHIraitkXVxuICAgICAgaWYocjEgPCBiMCB8fCBiMSA8IHIwKSB7XG4gICAgICAgIGNvbnRpbnVlIHJlZF9sb29wXG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXR2YWwgPSB2aXNpdChyZWRJZCwgYmx1ZUlkKVxuICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcmV0dmFsXG4gICAgfVxuICB9XG59XG5cbi8vVGhlIG1haW4gYm94IGludGVyc2VjdGlvbiByb3V0aW5lXG5mdW5jdGlvbiBib3hJbnRlcnNlY3RJdGVyKFxuICBkLCB2aXNpdCwgaW5pdEZ1bGwsXG4gIHhTaXplLCB4Qm94ZXMsIHhJbmRleCxcbiAgeVNpemUsIHlCb3hlcywgeUluZGV4KSB7XG5cbiAgLy9SZXNlcnZlIG1lbW9yeSBmb3Igc3RhY2tcbiAgaXRlckluaXQoZCwgeFNpemUgKyB5U2l6ZSlcblxuICB2YXIgdG9wICA9IDBcbiAgdmFyIGVsZW1TaXplID0gMiAqIGRcbiAgdmFyIHJldHZhbFxuXG4gIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgMCxcbiAgICAgIDAsIHhTaXplLFxuICAgICAgMCwgeVNpemUsXG4gICAgICBpbml0RnVsbCA/IDE2IDogMCwgXG4gICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICBpZighaW5pdEZ1bGwpIHtcbiAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgIDAsXG4gICAgICAwLCB5U2l6ZSxcbiAgICAgIDAsIHhTaXplLFxuICAgICAgMSwgXG4gICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICB9XG5cbiAgd2hpbGUodG9wID4gMCkge1xuICAgIHRvcCAgLT0gMVxuXG4gICAgdmFyIGlwdHIgPSB0b3AgKiBJRlJBTUVfU0laRVxuICAgIHZhciBheGlzICAgICAgPSBCT1hfSVNUQUNLW2lwdHJdXG4gICAgdmFyIHJlZFN0YXJ0ICA9IEJPWF9JU1RBQ0tbaXB0cisxXVxuICAgIHZhciByZWRFbmQgICAgPSBCT1hfSVNUQUNLW2lwdHIrMl1cbiAgICB2YXIgYmx1ZVN0YXJ0ID0gQk9YX0lTVEFDS1tpcHRyKzNdXG4gICAgdmFyIGJsdWVFbmQgICA9IEJPWF9JU1RBQ0tbaXB0cis0XVxuICAgIHZhciBzdGF0ZSAgICAgPSBCT1hfSVNUQUNLW2lwdHIrNV1cblxuICAgIHZhciBkcHRyID0gdG9wICogREZSQU1FX1NJWkVcbiAgICB2YXIgbG8gICAgICAgID0gQk9YX0RTVEFDS1tkcHRyXVxuICAgIHZhciBoaSAgICAgICAgPSBCT1hfRFNUQUNLW2RwdHIrMV1cblxuICAgIC8vVW5wYWNrIHN0YXRlIGluZm9cbiAgICB2YXIgZmxpcCAgICAgID0gKHN0YXRlICYgMSlcbiAgICB2YXIgZnVsbCAgICAgID0gISEoc3RhdGUgJiAxNilcblxuICAgIC8vVW5wYWNrIGluZGljZXNcbiAgICB2YXIgcmVkICAgICAgID0geEJveGVzXG4gICAgdmFyIHJlZEluZGV4ICA9IHhJbmRleFxuICAgIHZhciBibHVlICAgICAgPSB5Qm94ZXNcbiAgICB2YXIgYmx1ZUluZGV4ID0geUluZGV4XG4gICAgaWYoZmxpcCkge1xuICAgICAgcmVkICAgICAgICAgPSB5Qm94ZXNcbiAgICAgIHJlZEluZGV4ICAgID0geUluZGV4XG4gICAgICBibHVlICAgICAgICA9IHhCb3hlc1xuICAgICAgYmx1ZUluZGV4ICAgPSB4SW5kZXhcbiAgICB9XG5cbiAgICBpZihzdGF0ZSAmIDIpIHtcbiAgICAgIHJlZEVuZCA9IHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4oXG4gICAgICAgIGQsIGF4aXMsXG4gICAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgIGhpKVxuICAgICAgaWYocmVkU3RhcnQgPj0gcmVkRW5kKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmKHN0YXRlICYgNCkge1xuICAgICAgcmVkU3RhcnQgPSBwYXJ0aXRpb25FbmRMZXNzVGhhbkVxdWFsKFxuICAgICAgICBkLCBheGlzLFxuICAgICAgICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICBsbylcbiAgICAgIGlmKHJlZFN0YXJ0ID49IHJlZEVuZCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB2YXIgcmVkQ291bnQgID0gcmVkRW5kICAtIHJlZFN0YXJ0XG4gICAgdmFyIGJsdWVDb3VudCA9IGJsdWVFbmQgLSBibHVlU3RhcnRcblxuICAgIGlmKGZ1bGwpIHtcbiAgICAgIGlmKGQgKiByZWRDb3VudCAqIChyZWRDb3VudCArIGJsdWVDb3VudCkgPCBTQ0FOX0NPTVBMRVRFX0NVVE9GRikge1xuICAgICAgICByZXR2YWwgPSBzd2VlcC5zY2FuQ29tcGxldGUoXG4gICAgICAgICAgZCwgYXhpcywgdmlzaXQsIFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGQgKiBNYXRoLm1pbihyZWRDb3VudCwgYmx1ZUNvdW50KSA8IEJSVVRFX0ZPUkNFX0NVVE9GRikge1xuICAgICAgICAvL0lmIGlucHV0IHNtYWxsLCB0aGVuIHVzZSBicnV0ZSBmb3JjZVxuICAgICAgICByZXR2YWwgPSBicnV0ZUZvcmNlUGFydGlhbChcbiAgICAgICAgICAgIGQsIGF4aXMsIHZpc2l0LCBmbGlwLFxuICAgICAgICAgICAgcmVkU3RhcnQsICByZWRFbmQsICByZWQsICByZWRJbmRleCxcbiAgICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmKGQgKiByZWRDb3VudCAqIGJsdWVDb3VudCA8IFNDQU5fQ1VUT0ZGKSB7XG4gICAgICAgIC8vSWYgaW5wdXQgbWVkaXVtIHNpemVkLCB0aGVuIHVzZSBzd2VlcCBhbmQgcHJ1bmVcbiAgICAgICAgcmV0dmFsID0gc3dlZXAuc2NhbkJpcGFydGl0ZShcbiAgICAgICAgICBkLCBheGlzLCB2aXNpdCwgZmxpcCwgXG4gICAgICAgICAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy9GaXJzdCwgZmluZCBhbGwgcmVkIGludGVydmFscyB3aG9zZSBpbnRlcmlvciBjb250YWlucyAobG8saGkpXG4gICAgdmFyIHJlZDAgPSBwYXJ0aXRpb25JbnRlcmlvckNvbnRhaW5zSW50ZXJ2YWwoXG4gICAgICBkLCBheGlzLCBcbiAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICBsbywgaGkpXG5cbiAgICAvL0xvd2VyIGRpbWVuc2lvbmFsIGNhc2VcbiAgICBpZihyZWRTdGFydCA8IHJlZDApIHtcblxuICAgICAgaWYoZCAqIChyZWQwIC0gcmVkU3RhcnQpIDwgQlJVVEVfRk9SQ0VfQ1VUT0ZGKSB7XG4gICAgICAgIC8vU3BlY2lhbCBjYXNlIGZvciBzbWFsbCBpbnB1dHM6IHVzZSBicnV0ZSBmb3JjZVxuICAgICAgICByZXR2YWwgPSBicnV0ZUZvcmNlRnVsbChcbiAgICAgICAgICBkLCBheGlzKzEsIHZpc2l0LFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGF4aXMgPT09IGQtMikge1xuICAgICAgICBpZihmbGlwKSB7XG4gICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4LFxuICAgICAgICAgICAgcmVkU3RhcnQsIHJlZDAsIHJlZCwgcmVkSW5kZXgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIH1cbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICByZWRTdGFydCwgcmVkMCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsXG4gICAgICAgICAgZmxpcCxcbiAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLFxuICAgICAgICAgIGZsaXBeMSxcbiAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vRGl2aWRlIGFuZCBjb25xdWVyIHBoYXNlXG4gICAgaWYocmVkMCA8IHJlZEVuZCkge1xuXG4gICAgICAvL0N1dCBibHVlIGludG8gMyBwYXJ0czpcbiAgICAgIC8vXG4gICAgICAvLyAgUG9pbnRzIDwgbWlkIHBvaW50XG4gICAgICAvLyAgUG9pbnRzID0gbWlkIHBvaW50XG4gICAgICAvLyAgUG9pbnRzID4gbWlkIHBvaW50XG4gICAgICAvL1xuICAgICAgdmFyIGJsdWUwID0gZmluZE1lZGlhbihcbiAgICAgICAgZCwgYXhpcywgXG4gICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgdmFyIG1pZCA9IGJsdWVbZWxlbVNpemUgKiBibHVlMCArIGF4aXNdXG4gICAgICB2YXIgYmx1ZTEgPSBwYXJ0aXRpb25TdGFydEVxdWFsKFxuICAgICAgICBkLCBheGlzLFxuICAgICAgICBibHVlMCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4LFxuICAgICAgICBtaWQpXG5cbiAgICAgIC8vUmlnaHQgY2FzZVxuICAgICAgaWYoYmx1ZTEgPCBibHVlRW5kKSB7XG4gICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgIGF4aXMsXG4gICAgICAgICAgcmVkMCwgcmVkRW5kLFxuICAgICAgICAgIGJsdWUxLCBibHVlRW5kLFxuICAgICAgICAgIChmbGlwfDQpICsgKGZ1bGwgPyAxNiA6IDApLFxuICAgICAgICAgIG1pZCwgaGkpXG4gICAgICB9XG5cbiAgICAgIC8vTGVmdCBjYXNlXG4gICAgICBpZihibHVlU3RhcnQgPCBibHVlMCkge1xuICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICBheGlzLFxuICAgICAgICAgIHJlZDAsIHJlZEVuZCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWUwLFxuICAgICAgICAgIChmbGlwfDIpICsgKGZ1bGwgPyAxNiA6IDApLFxuICAgICAgICAgIGxvLCBtaWQpXG4gICAgICB9XG5cbiAgICAgIC8vQ2VudGVyIGNhc2UgKHRoZSBoYXJkIHBhcnQpXG4gICAgICBpZihibHVlMCArIDEgPT09IGJsdWUxKSB7XG4gICAgICAgIC8vT3B0aW1pemF0aW9uOiBSYW5nZSB3aXRoIGV4YWN0bHkgMSBwb2ludCwgdXNlIGEgYnJ1dGUgZm9yY2Ugc2NhblxuICAgICAgICBpZihmdWxsKSB7XG4gICAgICAgICAgcmV0dmFsID0gb25lUG9pbnRGdWxsKFxuICAgICAgICAgICAgZCwgYXhpcywgdmlzaXQsXG4gICAgICAgICAgICByZWQwLCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICBibHVlMCwgYmx1ZSwgYmx1ZUluZGV4W2JsdWUwXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR2YWwgPSBvbmVQb2ludFBhcnRpYWwoXG4gICAgICAgICAgICBkLCBheGlzLCB2aXNpdCwgZmxpcCxcbiAgICAgICAgICAgIHJlZDAsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgIGJsdWUwLCBibHVlLCBibHVlSW5kZXhbYmx1ZTBdKVxuICAgICAgICB9XG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoYmx1ZTAgPCBibHVlMSkge1xuICAgICAgICB2YXIgcmVkMVxuICAgICAgICBpZihmdWxsKSB7XG4gICAgICAgICAgLy9JZiBmdWxsIGludGVyc2VjdGlvbiwgbmVlZCB0byBoYW5kbGUgc3BlY2lhbCBjYXNlXG4gICAgICAgICAgcmVkMSA9IHBhcnRpdGlvbkNvbnRhaW5zUG9pbnQoXG4gICAgICAgICAgICBkLCBheGlzLFxuICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgbWlkKVxuICAgICAgICAgIGlmKHJlZDAgPCByZWQxKSB7XG4gICAgICAgICAgICB2YXIgcmVkWCA9IHBhcnRpdGlvblN0YXJ0RXF1YWwoXG4gICAgICAgICAgICAgIGQsIGF4aXMsXG4gICAgICAgICAgICAgIHJlZDAsIHJlZDEsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgIG1pZClcbiAgICAgICAgICAgIGlmKGF4aXMgPT09IGQtMikge1xuICAgICAgICAgICAgICAvL0RlZ2VuZXJhdGUgc3dlZXAgaW50ZXJzZWN0aW9uOlxuICAgICAgICAgICAgICAvLyAgW3JlZDAsIHJlZFhdIHdpdGggW2JsdWUwLCBibHVlMV1cbiAgICAgICAgICAgICAgaWYocmVkMCA8IHJlZFgpIHtcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcENvbXBsZXRlKFxuICAgICAgICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICAgICAgICByZWQwLCByZWRYLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvL05vcm1hbCBzd2VlcCBpbnRlcnNlY3Rpb246XG4gICAgICAgICAgICAgIC8vICBbcmVkWCwgcmVkMV0gd2l0aCBbYmx1ZTAsIGJsdWUxXVxuICAgICAgICAgICAgICBpZihyZWRYIDwgcmVkMSkge1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICAgICAgICByZWRYLCByZWQxLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmKHJlZDAgPCByZWRYKSB7XG4gICAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgICByZWQwLCByZWRYLFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgICAgMTYsXG4gICAgICAgICAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKHJlZFggPCByZWQxKSB7XG4gICAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgICByZWRYLCByZWQxLFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsXG4gICAgICAgICAgICAgICAgICByZWRYLCByZWQxLFxuICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYoZmxpcCkge1xuICAgICAgICAgICAgcmVkMSA9IHBhcnRpdGlvbkNvbnRhaW5zUG9pbnRQcm9wZXIoXG4gICAgICAgICAgICAgIGQsIGF4aXMsXG4gICAgICAgICAgICAgIHJlZDAsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgICAgbWlkKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWQxID0gcGFydGl0aW9uQ29udGFpbnNQb2ludChcbiAgICAgICAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICBtaWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJlZDAgPCByZWQxKSB7XG4gICAgICAgICAgICBpZihheGlzID09PSBkLTIpIHtcbiAgICAgICAgICAgICAgaWYoZmxpcCkge1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsIGJsdWUsIGJsdWVJbmRleCxcbiAgICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsIHJlZCwgcmVkSW5kZXgpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgYXhpcysxLFxuICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsXG4gICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgIGZsaXAsXG4gICAgICAgICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgYXhpcysxLFxuICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSxcbiAgICAgICAgICAgICAgICByZWQwLCByZWQxLFxuICAgICAgICAgICAgICAgIGZsaXBeMSxcbiAgICAgICAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRNZWRpYW5cblxudmFyIGdlblBhcnRpdGlvbiA9IHJlcXVpcmUoJy4vcGFydGl0aW9uJylcblxudmFyIHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4gPSBnZW5QYXJ0aXRpb24oJ2xvPHAwJywgWydwMCddKVxuXG52YXIgUEFSVElUSU9OX1RIUkVTSE9MRCA9IDggICAvL0N1dCBvZmYgZm9yIHVzaW5nIGluc2VydGlvbiBzb3J0IGluIGZpbmRNZWRpYW5cblxuLy9CYXNlIGNhc2UgZm9yIG1lZGlhbiBmaW5kaW5nOiAgVXNlIGluc2VydGlvbiBzb3J0XG5mdW5jdGlvbiBpbnNlcnRpb25Tb3J0KGQsIGF4aXMsIHN0YXJ0LCBlbmQsIGJveGVzLCBpZHMpIHtcbiAgdmFyIGVsZW1TaXplID0gMiAqIGRcbiAgdmFyIGJveFB0ciA9IGVsZW1TaXplICogKHN0YXJ0KzEpICsgYXhpc1xuICBmb3IodmFyIGk9c3RhcnQrMTsgaTxlbmQ7ICsraSwgYm94UHRyKz1lbGVtU2l6ZSkge1xuICAgIHZhciB4ID0gYm94ZXNbYm94UHRyXVxuICAgIGZvcih2YXIgaj1pLCBwdHI9ZWxlbVNpemUqKGktMSk7IFxuICAgICAgICBqPnN0YXJ0ICYmIGJveGVzW3B0citheGlzXSA+IHg7IFxuICAgICAgICAtLWosIHB0ci09ZWxlbVNpemUpIHtcbiAgICAgIC8vU3dhcFxuICAgICAgdmFyIGFQdHIgPSBwdHJcbiAgICAgIHZhciBiUHRyID0gcHRyK2VsZW1TaXplXG4gICAgICBmb3IodmFyIGs9MDsgazxlbGVtU2l6ZTsgKytrLCArK2FQdHIsICsrYlB0cikge1xuICAgICAgICB2YXIgeSA9IGJveGVzW2FQdHJdXG4gICAgICAgIGJveGVzW2FQdHJdID0gYm94ZXNbYlB0cl1cbiAgICAgICAgYm94ZXNbYlB0cl0gPSB5XG4gICAgICB9XG4gICAgICB2YXIgdG1wID0gaWRzW2pdXG4gICAgICBpZHNbal0gPSBpZHNbai0xXVxuICAgICAgaWRzW2otMV0gPSB0bXBcbiAgICB9XG4gIH1cbn1cblxuLy9GaW5kIG1lZGlhbiB1c2luZyBxdWljayBzZWxlY3QgYWxnb3JpdGhtXG4vLyAgdGFrZXMgTyhuKSB0aW1lIHdpdGggaGlnaCBwcm9iYWJpbGl0eVxuZnVuY3Rpb24gZmluZE1lZGlhbihkLCBheGlzLCBzdGFydCwgZW5kLCBib3hlcywgaWRzKSB7XG4gIGlmKGVuZCA8PSBzdGFydCsxKSB7XG4gICAgcmV0dXJuIHN0YXJ0XG4gIH1cblxuICB2YXIgbG8gICAgICAgPSBzdGFydFxuICB2YXIgaGkgICAgICAgPSBlbmRcbiAgdmFyIG1pZCAgICAgID0gKChlbmQgKyBzdGFydCkgPj4+IDEpXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgcGl2b3QgICAgPSBtaWRcbiAgdmFyIHZhbHVlICAgID0gYm94ZXNbZWxlbVNpemUqbWlkK2F4aXNdXG4gIFxuICB3aGlsZShsbyA8IGhpKSB7XG4gICAgaWYoaGkgLSBsbyA8IFBBUlRJVElPTl9USFJFU0hPTEQpIHtcbiAgICAgIGluc2VydGlvblNvcnQoZCwgYXhpcywgbG8sIGhpLCBib3hlcywgaWRzKVxuICAgICAgdmFsdWUgPSBib3hlc1tlbGVtU2l6ZSptaWQrYXhpc11cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIFxuICAgIC8vU2VsZWN0IHBpdm90IHVzaW5nIG1lZGlhbi1vZi0zXG4gICAgdmFyIGNvdW50ICA9IGhpIC0gbG9cbiAgICB2YXIgcGl2b3QwID0gKE1hdGgucmFuZG9tKCkqY291bnQrbG8pfDBcbiAgICB2YXIgdmFsdWUwID0gYm94ZXNbZWxlbVNpemUqcGl2b3QwICsgYXhpc11cbiAgICB2YXIgcGl2b3QxID0gKE1hdGgucmFuZG9tKCkqY291bnQrbG8pfDBcbiAgICB2YXIgdmFsdWUxID0gYm94ZXNbZWxlbVNpemUqcGl2b3QxICsgYXhpc11cbiAgICB2YXIgcGl2b3QyID0gKE1hdGgucmFuZG9tKCkqY291bnQrbG8pfDBcbiAgICB2YXIgdmFsdWUyID0gYm94ZXNbZWxlbVNpemUqcGl2b3QyICsgYXhpc11cbiAgICBpZih2YWx1ZTAgPD0gdmFsdWUxKSB7XG4gICAgICBpZih2YWx1ZTIgPj0gdmFsdWUxKSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QxXG4gICAgICAgIHZhbHVlID0gdmFsdWUxXG4gICAgICB9IGVsc2UgaWYodmFsdWUwID49IHZhbHVlMikge1xuICAgICAgICBwaXZvdCA9IHBpdm90MFxuICAgICAgICB2YWx1ZSA9IHZhbHVlMFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTJcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYodmFsdWUxID49IHZhbHVlMikge1xuICAgICAgICBwaXZvdCA9IHBpdm90MVxuICAgICAgICB2YWx1ZSA9IHZhbHVlMVxuICAgICAgfSBlbHNlIGlmKHZhbHVlMiA+PSB2YWx1ZTApIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDBcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QyXG4gICAgICAgIHZhbHVlID0gdmFsdWUyXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9Td2FwIHBpdm90IHRvIGVuZCBvZiBhcnJheVxuICAgIHZhciBhUHRyID0gZWxlbVNpemUgKiAoaGktMSlcbiAgICB2YXIgYlB0ciA9IGVsZW1TaXplICogcGl2b3RcbiAgICBmb3IodmFyIGk9MDsgaTxlbGVtU2l6ZTsgKytpLCArK2FQdHIsICsrYlB0cikge1xuICAgICAgdmFyIHggPSBib3hlc1thUHRyXVxuICAgICAgYm94ZXNbYVB0cl0gPSBib3hlc1tiUHRyXVxuICAgICAgYm94ZXNbYlB0cl0gPSB4XG4gICAgfVxuICAgIHZhciB5ID0gaWRzW2hpLTFdXG4gICAgaWRzW2hpLTFdID0gaWRzW3Bpdm90XVxuICAgIGlkc1twaXZvdF0gPSB5XG5cbiAgICAvL1BhcnRpdGlvbiB1c2luZyBwaXZvdFxuICAgIHBpdm90ID0gcGFydGl0aW9uU3RhcnRMZXNzVGhhbihcbiAgICAgIGQsIGF4aXMsIFxuICAgICAgbG8sIGhpLTEsIGJveGVzLCBpZHMsXG4gICAgICB2YWx1ZSlcblxuICAgIC8vU3dhcCBwaXZvdCBiYWNrXG4gICAgdmFyIGFQdHIgPSBlbGVtU2l6ZSAqIChoaS0xKVxuICAgIHZhciBiUHRyID0gZWxlbVNpemUgKiBwaXZvdFxuICAgIGZvcih2YXIgaT0wOyBpPGVsZW1TaXplOyArK2ksICsrYVB0ciwgKytiUHRyKSB7XG4gICAgICB2YXIgeCA9IGJveGVzW2FQdHJdXG4gICAgICBib3hlc1thUHRyXSA9IGJveGVzW2JQdHJdXG4gICAgICBib3hlc1tiUHRyXSA9IHhcbiAgICB9XG4gICAgdmFyIHkgPSBpZHNbaGktMV1cbiAgICBpZHNbaGktMV0gPSBpZHNbcGl2b3RdXG4gICAgaWRzW3Bpdm90XSA9IHlcblxuICAgIC8vU3dhcCBwaXZvdCB0byBsYXN0IHBpdm90XG4gICAgaWYobWlkIDwgcGl2b3QpIHtcbiAgICAgIGhpID0gcGl2b3QtMVxuICAgICAgd2hpbGUobG8gPCBoaSAmJiBcbiAgICAgICAgYm94ZXNbZWxlbVNpemUqKGhpLTEpK2F4aXNdID09PSB2YWx1ZSkge1xuICAgICAgICBoaSAtPSAxXG4gICAgICB9XG4gICAgICBoaSArPSAxXG4gICAgfSBlbHNlIGlmKHBpdm90IDwgbWlkKSB7XG4gICAgICBsbyA9IHBpdm90ICsgMVxuICAgICAgd2hpbGUobG8gPCBoaSAmJlxuICAgICAgICBib3hlc1tlbGVtU2l6ZSpsbytheGlzXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgbG8gKz0gMVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vTWFrZSBzdXJlIHBpdm90IGlzIGF0IHN0YXJ0XG4gIHJldHVybiBwYXJ0aXRpb25TdGFydExlc3NUaGFuKFxuICAgIGQsIGF4aXMsIFxuICAgIHN0YXJ0LCBtaWQsIGJveGVzLCBpZHMsXG4gICAgYm94ZXNbZWxlbVNpemUqbWlkK2F4aXNdKVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlblBhcnRpdGlvblxuXG52YXIgY29kZSA9ICdmb3IodmFyIGo9MiphLGs9aipjLGw9ayxtPWMsbj1iLG89YStiLHA9YztkPnA7KytwLGsrPWope3ZhciBfO2lmKCQpaWYobT09PXApbSs9MSxsKz1qO2Vsc2V7Zm9yKHZhciBzPTA7aj5zOysrcyl7dmFyIHQ9ZVtrK3NdO2VbaytzXT1lW2xdLGVbbCsrXT10fXZhciB1PWZbcF07ZltwXT1mW21dLGZbbSsrXT11fX1yZXR1cm4gbSdcblxuZnVuY3Rpb24gZ2VuUGFydGl0aW9uKHByZWRpY2F0ZSwgYXJncykge1xuICB2YXIgZmFyZ3MgPSdhYmNkZWYnLnNwbGl0KCcnKS5jb25jYXQoYXJncylcbiAgdmFyIHJlYWRzID0gW11cbiAgaWYocHJlZGljYXRlLmluZGV4T2YoJ2xvJykgPj0gMCkge1xuICAgIHJlYWRzLnB1c2goJ2xvPWVbaytuXScpXG4gIH1cbiAgaWYocHJlZGljYXRlLmluZGV4T2YoJ2hpJykgPj0gMCkge1xuICAgIHJlYWRzLnB1c2goJ2hpPWVbaytvXScpXG4gIH1cbiAgZmFyZ3MucHVzaChcbiAgICBjb2RlLnJlcGxhY2UoJ18nLCByZWFkcy5qb2luKCkpXG4gICAgICAgIC5yZXBsYWNlKCckJywgcHJlZGljYXRlKSlcbiAgcmV0dXJuIEZ1bmN0aW9uLmFwcGx5KHZvaWQgMCwgZmFyZ3MpXG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vL1RoaXMgY29kZSBpcyBleHRyYWN0ZWQgZnJvbSBuZGFycmF5LXNvcnRcbi8vSXQgaXMgaW5saW5lZCBoZXJlIGFzIGEgdGVtcG9yYXJ5IHdvcmthcm91bmRcblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcGVyO1xuXG52YXIgSU5TRVJUX1NPUlRfQ1VUT0ZGID0gMzJcblxuZnVuY3Rpb24gd3JhcHBlcihkYXRhLCBuMCkge1xuICBpZiAobjAgPD0gNCpJTlNFUlRfU09SVF9DVVRPRkYpIHtcbiAgICBpbnNlcnRpb25Tb3J0KDAsIG4wIC0gMSwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KDAsIG4wIC0gMSwgZGF0YSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0aW9uU29ydChsZWZ0LCByaWdodCwgZGF0YSkge1xuICB2YXIgcHRyID0gMioobGVmdCsxKVxuICBmb3IodmFyIGk9bGVmdCsxOyBpPD1yaWdodDsgKytpKSB7XG4gICAgdmFyIGEgPSBkYXRhW3B0cisrXVxuICAgIHZhciBiID0gZGF0YVtwdHIrK11cbiAgICB2YXIgaiA9IGlcbiAgICB2YXIganB0ciA9IHB0ci0yXG4gICAgd2hpbGUoai0tID4gbGVmdCkge1xuICAgICAgdmFyIHggPSBkYXRhW2pwdHItMl1cbiAgICAgIHZhciB5ID0gZGF0YVtqcHRyLTFdXG4gICAgICBpZih4IDwgYSkge1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmKHggPT09IGEgJiYgeSA8IGIpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRhdGFbanB0cl0gICA9IHhcbiAgICAgIGRhdGFbanB0cisxXSA9IHlcbiAgICAgIGpwdHIgLT0gMlxuICAgIH1cbiAgICBkYXRhW2pwdHJdICAgPSBhXG4gICAgZGF0YVtqcHRyKzFdID0gYlxuICB9XG59XG5cbmZ1bmN0aW9uIHN3YXAoaSwgaiwgZGF0YSkge1xuICBpICo9IDJcbiAgaiAqPSAyXG4gIHZhciB4ID0gZGF0YVtpXVxuICB2YXIgeSA9IGRhdGFbaSsxXVxuICBkYXRhW2ldID0gZGF0YVtqXVxuICBkYXRhW2krMV0gPSBkYXRhW2orMV1cbiAgZGF0YVtqXSA9IHhcbiAgZGF0YVtqKzFdID0geVxufVxuXG5mdW5jdGlvbiBtb3ZlKGksIGosIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICBkYXRhW2ldID0gZGF0YVtqXVxuICBkYXRhW2krMV0gPSBkYXRhW2orMV1cbn1cblxuZnVuY3Rpb24gcm90YXRlKGksIGosIGssIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICBrICo9IDJcbiAgdmFyIHggPSBkYXRhW2ldXG4gIHZhciB5ID0gZGF0YVtpKzFdXG4gIGRhdGFbaV0gPSBkYXRhW2pdXG4gIGRhdGFbaSsxXSA9IGRhdGFbaisxXVxuICBkYXRhW2pdID0gZGF0YVtrXVxuICBkYXRhW2orMV0gPSBkYXRhW2srMV1cbiAgZGF0YVtrXSA9IHhcbiAgZGF0YVtrKzFdID0geVxufVxuXG5mdW5jdGlvbiBzaHVmZmxlUGl2b3QoaSwgaiwgcHgsIHB5LCBkYXRhKSB7XG4gIGkgKj0gMlxuICBqICo9IDJcbiAgZGF0YVtpXSA9IGRhdGFbal1cbiAgZGF0YVtqXSA9IHB4XG4gIGRhdGFbaSsxXSA9IGRhdGFbaisxXVxuICBkYXRhW2orMV0gPSBweVxufVxuXG5mdW5jdGlvbiBjb21wYXJlKGksIGosIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICB2YXIgeCA9IGRhdGFbaV0sXG4gICAgICB5ID0gZGF0YVtqXVxuICBpZih4IDwgeSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYoeCA9PT0geSkge1xuICAgIHJldHVybiBkYXRhW2krMV0gPiBkYXRhW2orMV1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBjb21wYXJlUGl2b3QoaSwgeSwgYiwgZGF0YSkge1xuICBpICo9IDJcbiAgdmFyIHggPSBkYXRhW2ldXG4gIGlmKHggPCB5KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmKHggPT09IHkpIHtcbiAgICByZXR1cm4gZGF0YVtpKzFdIDwgYlxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBxdWlja1NvcnQobGVmdCwgcmlnaHQsIGRhdGEpIHtcbiAgdmFyIHNpeHRoID0gKHJpZ2h0IC0gbGVmdCArIDEpIC8gNiB8IDAsIFxuICAgICAgaW5kZXgxID0gbGVmdCArIHNpeHRoLCBcbiAgICAgIGluZGV4NSA9IHJpZ2h0IC0gc2l4dGgsIFxuICAgICAgaW5kZXgzID0gbGVmdCArIHJpZ2h0ID4+IDEsIFxuICAgICAgaW5kZXgyID0gaW5kZXgzIC0gc2l4dGgsIFxuICAgICAgaW5kZXg0ID0gaW5kZXgzICsgc2l4dGgsIFxuICAgICAgZWwxID0gaW5kZXgxLCBcbiAgICAgIGVsMiA9IGluZGV4MiwgXG4gICAgICBlbDMgPSBpbmRleDMsIFxuICAgICAgZWw0ID0gaW5kZXg0LCBcbiAgICAgIGVsNSA9IGluZGV4NSwgXG4gICAgICBsZXNzID0gbGVmdCArIDEsIFxuICAgICAgZ3JlYXQgPSByaWdodCAtIDEsIFxuICAgICAgdG1wID0gMFxuICBpZihjb21wYXJlKGVsMSwgZWwyLCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMVxuICAgIGVsMSA9IGVsMlxuICAgIGVsMiA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWw0LCBlbDUsIGRhdGEpKSB7XG4gICAgdG1wID0gZWw0XG4gICAgZWw0ID0gZWw1XG4gICAgZWw1ID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDEsIGVsMywgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDFcbiAgICBlbDEgPSBlbDNcbiAgICBlbDMgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMiwgZWwzLCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMlxuICAgIGVsMiA9IGVsM1xuICAgIGVsMyA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwxLCBlbDQsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwxXG4gICAgZWwxID0gZWw0XG4gICAgZWw0ID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDMsIGVsNCwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDNcbiAgICBlbDMgPSBlbDRcbiAgICBlbDQgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMiwgZWw1LCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMlxuICAgIGVsMiA9IGVsNVxuICAgIGVsNSA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwyLCBlbDMsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwyXG4gICAgZWwyID0gZWwzXG4gICAgZWwzID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDQsIGVsNSwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDRcbiAgICBlbDQgPSBlbDVcbiAgICBlbDUgPSB0bXBcbiAgfVxuXG4gIHZhciBwaXZvdDFYID0gZGF0YVsyKmVsMl1cbiAgdmFyIHBpdm90MVkgPSBkYXRhWzIqZWwyKzFdXG4gIHZhciBwaXZvdDJYID0gZGF0YVsyKmVsNF1cbiAgdmFyIHBpdm90MlkgPSBkYXRhWzIqZWw0KzFdXG5cbiAgdmFyIHB0cjAgPSAyICogZWwxO1xuICB2YXIgcHRyMiA9IDIgKiBlbDM7XG4gIHZhciBwdHI0ID0gMiAqIGVsNTtcbiAgdmFyIHB0cjUgPSAyICogaW5kZXgxO1xuICB2YXIgcHRyNiA9IDIgKiBpbmRleDM7XG4gIHZhciBwdHI3ID0gMiAqIGluZGV4NTtcbiAgZm9yICh2YXIgaTEgPSAwOyBpMSA8IDI7ICsraTEpIHtcbiAgICB2YXIgeCA9IGRhdGFbcHRyMCtpMV07XG4gICAgdmFyIHkgPSBkYXRhW3B0cjIraTFdO1xuICAgIHZhciB6ID0gZGF0YVtwdHI0K2kxXTtcbiAgICBkYXRhW3B0cjUraTFdID0geDtcbiAgICBkYXRhW3B0cjYraTFdID0geTtcbiAgICBkYXRhW3B0cjcraTFdID0gejtcbiAgfVxuXG4gIG1vdmUoaW5kZXgyLCBsZWZ0LCBkYXRhKVxuICBtb3ZlKGluZGV4NCwgcmlnaHQsIGRhdGEpXG4gIGZvciAodmFyIGsgPSBsZXNzOyBrIDw9IGdyZWF0OyArK2spIHtcbiAgICBpZiAoY29tcGFyZVBpdm90KGssIHBpdm90MVgsIHBpdm90MVksIGRhdGEpKSB7XG4gICAgICBpZiAoayAhPT0gbGVzcykge1xuICAgICAgICBzd2FwKGssIGxlc3MsIGRhdGEpXG4gICAgICB9XG4gICAgICArK2xlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY29tcGFyZVBpdm90KGssIHBpdm90MlgsIHBpdm90MlksIGRhdGEpKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaWYgKCFjb21wYXJlUGl2b3QoZ3JlYXQsIHBpdm90MlgsIHBpdm90MlksIGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoLS1ncmVhdCA8IGspIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbXBhcmVQaXZvdChncmVhdCwgcGl2b3QxWCwgcGl2b3QxWSwgZGF0YSkpIHtcbiAgICAgICAgICAgICAgcm90YXRlKGssIGxlc3MsIGdyZWF0LCBkYXRhKVxuICAgICAgICAgICAgICArK2xlc3M7XG4gICAgICAgICAgICAgIC0tZ3JlYXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzd2FwKGssIGdyZWF0LCBkYXRhKVxuICAgICAgICAgICAgICAtLWdyZWF0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNodWZmbGVQaXZvdChsZWZ0LCBsZXNzLTEsIHBpdm90MVgsIHBpdm90MVksIGRhdGEpXG4gIHNodWZmbGVQaXZvdChyaWdodCwgZ3JlYXQrMSwgcGl2b3QyWCwgcGl2b3QyWSwgZGF0YSlcbiAgaWYgKGxlc3MgLSAyIC0gbGVmdCA8PSBJTlNFUlRfU09SVF9DVVRPRkYpIHtcbiAgICBpbnNlcnRpb25Tb3J0KGxlZnQsIGxlc3MgLSAyLCBkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBxdWlja1NvcnQobGVmdCwgbGVzcyAtIDIsIGRhdGEpO1xuICB9XG4gIGlmIChyaWdodCAtIChncmVhdCArIDIpIDw9IElOU0VSVF9TT1JUX0NVVE9GRikge1xuICAgIGluc2VydGlvblNvcnQoZ3JlYXQgKyAyLCByaWdodCwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KGdyZWF0ICsgMiwgcmlnaHQsIGRhdGEpO1xuICB9XG4gIGlmIChncmVhdCAtIGxlc3MgPD0gSU5TRVJUX1NPUlRfQ1VUT0ZGKSB7XG4gICAgaW5zZXJ0aW9uU29ydChsZXNzLCBncmVhdCwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KGxlc3MsIGdyZWF0LCBkYXRhKTtcbiAgfVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5pdDogICAgICAgICAgIHNxSW5pdCxcbiAgc3dlZXBCaXBhcnRpdGU6IHN3ZWVwQmlwYXJ0aXRlLFxuICBzd2VlcENvbXBsZXRlOiAgc3dlZXBDb21wbGV0ZSxcbiAgc2NhbkJpcGFydGl0ZTogIHNjYW5CaXBhcnRpdGUsXG4gIHNjYW5Db21wbGV0ZTogICBzY2FuQ29tcGxldGVcbn1cblxudmFyIHBvb2wgID0gcmVxdWlyZSgndHlwZWRhcnJheS1wb29sJylcbnZhciBiaXRzICA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJylcbnZhciBpc29ydCA9IHJlcXVpcmUoJy4vc29ydCcpXG5cbi8vRmxhZyBmb3IgYmx1ZVxudmFyIEJMVUVfRkxBRyA9ICgxPDwyOClcblxuLy8xRCBzd2VlcCBldmVudCBxdWV1ZSBzdHVmZiAodXNlIHBvb2wgdG8gc2F2ZSBzcGFjZSlcbnZhciBJTklUX0NBUEFDSVRZICAgICAgPSAxMDI0XG52YXIgUkVEX1NXRUVQX1FVRVVFICAgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIFJFRF9TV0VFUF9JTkRFWCAgICA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBCTFVFX1NXRUVQX1FVRVVFICAgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgQkxVRV9TV0VFUF9JTkRFWCAgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIENPTU1PTl9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBDT01NT05fU1dFRVBfSU5ERVggPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgU1dFRVBfRVZFTlRTICAgICAgID0gcG9vbC5tYWxsb2NEb3VibGUoSU5JVF9DQVBBQ0lUWSAqIDgpXG5cbi8vUmVzZXJ2ZXMgbWVtb3J5IGZvciB0aGUgMUQgc3dlZXAgZGF0YSBzdHJ1Y3R1cmVzXG5mdW5jdGlvbiBzcUluaXQoY291bnQpIHtcbiAgdmFyIHJjb3VudCA9IGJpdHMubmV4dFBvdzIoY291bnQpXG4gIGlmKFJFRF9TV0VFUF9RVUVVRS5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoUkVEX1NXRUVQX1FVRVVFKVxuICAgIFJFRF9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKFJFRF9TV0VFUF9JTkRFWC5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoUkVEX1NXRUVQX0lOREVYKVxuICAgIFJFRF9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKEJMVUVfU1dFRVBfUVVFVUUubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKEJMVUVfU1dFRVBfUVVFVUUpXG4gICAgQkxVRV9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKEJMVUVfU1dFRVBfSU5ERVgubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKEJMVUVfU1dFRVBfSU5ERVgpXG4gICAgQkxVRV9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKENPTU1PTl9TV0VFUF9RVUVVRS5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoQ09NTU9OX1NXRUVQX1FVRVVFKVxuICAgIENPTU1PTl9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKENPTU1PTl9TV0VFUF9JTkRFWC5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoQ09NTU9OX1NXRUVQX0lOREVYKVxuICAgIENPTU1PTl9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIHZhciBldmVudExlbmd0aCA9IDggKiByY291bnRcbiAgaWYoU1dFRVBfRVZFTlRTLmxlbmd0aCA8IGV2ZW50TGVuZ3RoKSB7XG4gICAgcG9vbC5mcmVlKFNXRUVQX0VWRU5UUylcbiAgICBTV0VFUF9FVkVOVFMgPSBwb29sLm1hbGxvY0RvdWJsZShldmVudExlbmd0aClcbiAgfVxufVxuXG4vL1JlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGFjdGl2ZSBxdWV1ZSBpbiBPKDEpXG5mdW5jdGlvbiBzcVBvcChxdWV1ZSwgaW5kZXgsIGNvdW50LCBpdGVtKSB7XG4gIHZhciBpZHggPSBpbmRleFtpdGVtXVxuICB2YXIgdG9wID0gcXVldWVbY291bnQtMV1cbiAgcXVldWVbaWR4XSA9IHRvcFxuICBpbmRleFt0b3BdID0gaWR4XG59XG5cbi8vSW5zZXJ0IGFuIGl0ZW0gaW50byB0aGUgYWN0aXZlIHF1ZXVlIGluIE8oMSlcbmZ1bmN0aW9uIHNxUHVzaChxdWV1ZSwgaW5kZXgsIGNvdW50LCBpdGVtKSB7XG4gIHF1ZXVlW2NvdW50XSA9IGl0ZW1cbiAgaW5kZXhbaXRlbV0gID0gY291bnRcbn1cblxuLy9SZWN1cnNpb24gYmFzZSBjYXNlOiB1c2UgMUQgc3dlZXAgYWxnb3JpdGhtXG5mdW5jdGlvbiBzd2VlcEJpcGFydGl0ZShcbiAgICBkLCB2aXNpdCxcbiAgICByZWRTdGFydCwgIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCkge1xuXG4gIC8vc3RvcmUgZXZlbnRzIGFzIHBhaXJzIFtjb29yZGluYXRlLCBpZHhdXG4gIC8vXG4gIC8vICByZWQgY3JlYXRlOiAgLShpZHgrMSlcbiAgLy8gIHJlZCBkZXN0cm95OiBpZHhcbiAgLy8gIGJsdWUgY3JlYXRlOiAtKGlkeCtCTFVFX0ZMQUcpXG4gIC8vICBibHVlIGRlc3Ryb3k6IGlkeCtCTFVFX0ZMQUdcbiAgLy9cbiAgdmFyIHB0ciAgICAgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIGlzdGFydCAgID0gZC0xXG4gIHZhciBpZW5kICAgICA9IGVsZW1TaXplLTFcblxuICBmb3IodmFyIGk9cmVkU3RhcnQ7IGk8cmVkRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gcmVkSW5kZXhbaV1cbiAgICB2YXIgcmVkT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLShpZHgrMSlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuXG4gIGZvcih2YXIgaT1ibHVlU3RhcnQ7IGk8Ymx1ZUVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IGJsdWVJbmRleFtpXStCTFVFX0ZMQUdcbiAgICB2YXIgYmx1ZU9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4XG4gIH1cblxuICAvL3Byb2Nlc3MgZXZlbnRzIGZyb20gbGVmdC0+cmlnaHRcbiAgdmFyIG4gPSBwdHIgPj4+IDFcbiAgaXNvcnQoU1dFRVBfRVZFTlRTLCBuKVxuICBcbiAgdmFyIHJlZEFjdGl2ZSAgPSAwXG4gIHZhciBibHVlQWN0aXZlID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgZSA9IFNXRUVQX0VWRU5UU1syKmkrMV18MFxuICAgIGlmKGUgPj0gQkxVRV9GTEFHKSB7XG4gICAgICAvL2JsdWUgZGVzdHJveSBldmVudFxuICAgICAgZSA9IChlLUJMVUVfRkxBRyl8MFxuICAgICAgc3FQb3AoQkxVRV9TV0VFUF9RVUVVRSwgQkxVRV9TV0VFUF9JTkRFWCwgYmx1ZUFjdGl2ZS0tLCBlKVxuICAgIH0gZWxzZSBpZihlID49IDApIHtcbiAgICAgIC8vcmVkIGRlc3Ryb3kgZXZlbnRcbiAgICAgIHNxUG9wKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUtLSwgZSlcbiAgICB9IGVsc2UgaWYoZSA8PSAtQkxVRV9GTEFHKSB7XG4gICAgICAvL2JsdWUgY3JlYXRlIGV2ZW50XG4gICAgICBlID0gKC1lLUJMVUVfRkxBRyl8MFxuICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KFJFRF9TV0VFUF9RVUVVRVtqXSwgZSlcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNxUHVzaChCTFVFX1NXRUVQX1FVRVVFLCBCTFVFX1NXRUVQX0lOREVYLCBibHVlQWN0aXZlKyssIGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vcmVkIGNyZWF0ZSBldmVudFxuICAgICAgZSA9ICgtZS0xKXwwXG4gICAgICBmb3IodmFyIGo9MDsgajxibHVlQWN0aXZlOyArK2opIHtcbiAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KGUsIEJMVUVfU1dFRVBfUVVFVUVbal0pXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzcVB1c2goUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZSsrLCBlKVxuICAgIH1cbiAgfVxufVxuXG4vL0NvbXBsZXRlIHN3ZWVwXG5mdW5jdGlvbiBzd2VlcENvbXBsZXRlKGQsIHZpc2l0LCBcbiAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpIHtcblxuICB2YXIgcHRyICAgICAgPSAwXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgaXN0YXJ0ICAgPSBkLTFcbiAgdmFyIGllbmQgICAgID0gZWxlbVNpemUtMVxuXG4gIGZvcih2YXIgaT1yZWRTdGFydDsgaTxyZWRFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSAocmVkSW5kZXhbaV0rMSk8PDFcbiAgICB2YXIgcmVkT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2llbmRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGlkeFxuICB9XG5cbiAgZm9yKHZhciBpPWJsdWVTdGFydDsgaTxibHVlRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gKGJsdWVJbmRleFtpXSsxKTw8MVxuICAgIHZhciBibHVlT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAoLWlkeCl8MVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4fDFcbiAgfVxuXG4gIC8vcHJvY2VzcyBldmVudHMgZnJvbSBsZWZ0LT5yaWdodFxuICB2YXIgbiA9IHB0ciA+Pj4gMVxuICBpc29ydChTV0VFUF9FVkVOVFMsIG4pXG4gIFxuICB2YXIgcmVkQWN0aXZlICAgID0gMFxuICB2YXIgYmx1ZUFjdGl2ZSAgID0gMFxuICB2YXIgY29tbW9uQWN0aXZlID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgZSAgICAgPSBTV0VFUF9FVkVOVFNbMippKzFdfDBcbiAgICB2YXIgY29sb3IgPSBlJjFcbiAgICBpZihpIDwgbi0xICYmIChlPj4xKSA9PT0gKFNXRUVQX0VWRU5UU1syKmkrM10+PjEpKSB7XG4gICAgICBjb2xvciA9IDJcbiAgICAgIGkgKz0gMVxuICAgIH1cbiAgICBcbiAgICBpZihlIDwgMCkge1xuICAgICAgLy9DcmVhdGUgZXZlbnRcbiAgICAgIHZhciBpZCA9IC0oZT4+MSkgLSAxXG5cbiAgICAgIC8vSW50ZXJzZWN0IHdpdGggY29tbW9uXG4gICAgICBmb3IodmFyIGo9MDsgajxjb21tb25BY3RpdmU7ICsraikge1xuICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoQ09NTU9OX1NXRUVQX1FVRVVFW2pdLCBpZClcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoY29sb3IgIT09IDApIHtcbiAgICAgICAgLy9JbnRlcnNlY3Qgd2l0aCByZWRcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoUkVEX1NXRUVQX1FVRVVFW2pdLCBpZClcbiAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihjb2xvciAhPT0gMSkge1xuICAgICAgICAvL0ludGVyc2VjdCB3aXRoIGJsdWVcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8Ymx1ZUFjdGl2ZTsgKytqKSB7XG4gICAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KEJMVUVfU1dFRVBfUVVFVUVbal0sIGlkKVxuICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKGNvbG9yID09PSAwKSB7XG4gICAgICAgIC8vUmVkXG4gICAgICAgIHNxUHVzaChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlKyssIGlkKVxuICAgICAgfSBlbHNlIGlmKGNvbG9yID09PSAxKSB7XG4gICAgICAgIC8vQmx1ZVxuICAgICAgICBzcVB1c2goQkxVRV9TV0VFUF9RVUVVRSwgQkxVRV9TV0VFUF9JTkRFWCwgYmx1ZUFjdGl2ZSsrLCBpZClcbiAgICAgIH0gZWxzZSBpZihjb2xvciA9PT0gMikge1xuICAgICAgICAvL0JvdGhcbiAgICAgICAgc3FQdXNoKENPTU1PTl9TV0VFUF9RVUVVRSwgQ09NTU9OX1NXRUVQX0lOREVYLCBjb21tb25BY3RpdmUrKywgaWQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vRGVzdHJveSBldmVudFxuICAgICAgdmFyIGlkID0gKGU+PjEpIC0gMVxuICAgICAgaWYoY29sb3IgPT09IDApIHtcbiAgICAgICAgLy9SZWRcbiAgICAgICAgc3FQb3AoUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZS0tLCBpZClcbiAgICAgIH0gZWxzZSBpZihjb2xvciA9PT0gMSkge1xuICAgICAgICAvL0JsdWVcbiAgICAgICAgc3FQb3AoQkxVRV9TV0VFUF9RVUVVRSwgQkxVRV9TV0VFUF9JTkRFWCwgYmx1ZUFjdGl2ZS0tLCBpZClcbiAgICAgIH0gZWxzZSBpZihjb2xvciA9PT0gMikge1xuICAgICAgICAvL0JvdGhcbiAgICAgICAgc3FQb3AoQ09NTU9OX1NXRUVQX1FVRVVFLCBDT01NT05fU1dFRVBfSU5ERVgsIGNvbW1vbkFjdGl2ZS0tLCBpZClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy9Td2VlcCBhbmQgcHJ1bmUvc2NhbmxpbmUgYWxnb3JpdGhtOlxuLy8gIFNjYW4gYWxvbmcgYXhpcywgZGV0ZWN0IGludGVyc2VjdGlvbnNcbi8vICBCcnV0ZSBmb3JjZSBhbGwgYm94ZXMgYWxvbmcgYXhpc1xuZnVuY3Rpb24gc2NhbkJpcGFydGl0ZShcbiAgZCwgYXhpcywgdmlzaXQsIGZsaXAsXG4gIHJlZFN0YXJ0LCAgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCkge1xuICBcbiAgdmFyIHB0ciAgICAgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIGlzdGFydCAgID0gYXhpc1xuICB2YXIgaWVuZCAgICAgPSBheGlzK2RcblxuICB2YXIgcmVkU2hpZnQgID0gMVxuICB2YXIgYmx1ZVNoaWZ0ID0gMVxuICBpZihmbGlwKSB7XG4gICAgYmx1ZVNoaWZ0ID0gQkxVRV9GTEFHXG4gIH0gZWxzZSB7XG4gICAgcmVkU2hpZnQgID0gQkxVRV9GTEFHXG4gIH1cblxuICBmb3IodmFyIGk9cmVkU3RhcnQ7IGk8cmVkRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gaSArIHJlZFNoaWZ0XG4gICAgdmFyIHJlZE9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuICBmb3IodmFyIGk9Ymx1ZVN0YXJ0OyBpPGJsdWVFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSBpICsgYmx1ZVNoaWZ0XG4gICAgdmFyIGJsdWVPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgfVxuXG4gIC8vcHJvY2VzcyBldmVudHMgZnJvbSBsZWZ0LT5yaWdodFxuICB2YXIgbiA9IHB0ciA+Pj4gMVxuICBpc29ydChTV0VFUF9FVkVOVFMsIG4pXG4gIFxuICB2YXIgcmVkQWN0aXZlICAgID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgZSA9IFNXRUVQX0VWRU5UU1syKmkrMV18MFxuICAgIGlmKGUgPCAwKSB7XG4gICAgICB2YXIgaWR4ICAgPSAtZVxuICAgICAgdmFyIGlzUmVkID0gZmFsc2VcbiAgICAgIGlmKGlkeCA+PSBCTFVFX0ZMQUcpIHtcbiAgICAgICAgaXNSZWQgPSAhZmxpcFxuICAgICAgICBpZHggLT0gQkxVRV9GTEFHIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNSZWQgPSAhIWZsaXBcbiAgICAgICAgaWR4IC09IDFcbiAgICAgIH1cbiAgICAgIGlmKGlzUmVkKSB7XG4gICAgICAgIHNxUHVzaChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlKyssIGlkeClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBibHVlSWQgID0gYmx1ZUluZGV4W2lkeF1cbiAgICAgICAgdmFyIGJsdWVQdHIgPSBlbGVtU2l6ZSAqIGlkeFxuICAgICAgICBcbiAgICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2F4aXMrMV1cbiAgICAgICAgdmFyIGIxID0gYmx1ZVtibHVlUHRyK2F4aXMrMStkXVxuXG5yZWRfbG9vcDpcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgICB2YXIgb2lkeCAgID0gUkVEX1NXRUVQX1FVRVVFW2pdXG4gICAgICAgICAgdmFyIHJlZFB0ciA9IGVsZW1TaXplICogb2lkeFxuXG4gICAgICAgICAgaWYoYjEgPCByZWRbcmVkUHRyK2F4aXMrMV0gfHwgXG4gICAgICAgICAgICAgcmVkW3JlZFB0citheGlzKzErZF0gPCBiMCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IodmFyIGs9YXhpcysyOyBrPGQ7ICsraykge1xuICAgICAgICAgICAgaWYoYmx1ZVtibHVlUHRyICsgayArIGRdIDwgcmVkW3JlZFB0ciArIGtdIHx8IFxuICAgICAgICAgICAgICAgcmVkW3JlZFB0ciArIGsgKyBkXSA8IGJsdWVbYmx1ZVB0ciArIGtdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIHJlZF9sb29wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlZElkICA9IHJlZEluZGV4W29pZHhdXG4gICAgICAgICAgdmFyIHJldHZhbFxuICAgICAgICAgIGlmKGZsaXApIHtcbiAgICAgICAgICAgIHJldHZhbCA9IHZpc2l0KGJsdWVJZCwgcmVkSWQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHZhbCA9IHZpc2l0KHJlZElkLCBibHVlSWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsIFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzcVBvcChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlLS0sIGUgLSByZWRTaGlmdClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NhbkNvbXBsZXRlKFxuICBkLCBheGlzLCB2aXNpdCxcbiAgcmVkU3RhcnQsICByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KSB7XG5cbiAgdmFyIHB0ciAgICAgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIGlzdGFydCAgID0gYXhpc1xuICB2YXIgaWVuZCAgICAgPSBheGlzK2RcblxuICBmb3IodmFyIGk9cmVkU3RhcnQ7IGk8cmVkRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gaSArIEJMVUVfRkxBR1xuICAgIHZhciByZWRPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4XG4gIH1cbiAgZm9yKHZhciBpPWJsdWVTdGFydDsgaTxibHVlRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gaSArIDFcbiAgICB2YXIgYmx1ZU9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICB9XG5cbiAgLy9wcm9jZXNzIGV2ZW50cyBmcm9tIGxlZnQtPnJpZ2h0XG4gIHZhciBuID0gcHRyID4+PiAxXG4gIGlzb3J0KFNXRUVQX0VWRU5UUywgbilcbiAgXG4gIHZhciByZWRBY3RpdmUgICAgPSAwXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBlID0gU1dFRVBfRVZFTlRTWzIqaSsxXXwwXG4gICAgaWYoZSA8IDApIHtcbiAgICAgIHZhciBpZHggICA9IC1lXG4gICAgICBpZihpZHggPj0gQkxVRV9GTEFHKSB7XG4gICAgICAgIFJFRF9TV0VFUF9RVUVVRVtyZWRBY3RpdmUrK10gPSBpZHggLSBCTFVFX0ZMQUdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkeCAtPSAxXG4gICAgICAgIHZhciBibHVlSWQgID0gYmx1ZUluZGV4W2lkeF1cbiAgICAgICAgdmFyIGJsdWVQdHIgPSBlbGVtU2l6ZSAqIGlkeFxuXG4gICAgICAgIHZhciBiMCA9IGJsdWVbYmx1ZVB0citheGlzKzFdXG4gICAgICAgIHZhciBiMSA9IGJsdWVbYmx1ZVB0citheGlzKzErZF1cblxucmVkX2xvb3A6XG4gICAgICAgIGZvcih2YXIgaj0wOyBqPHJlZEFjdGl2ZTsgKytqKSB7XG4gICAgICAgICAgdmFyIG9pZHggICA9IFJFRF9TV0VFUF9RVUVVRVtqXVxuICAgICAgICAgIHZhciByZWRJZCAgPSByZWRJbmRleFtvaWR4XVxuXG4gICAgICAgICAgaWYocmVkSWQgPT09IGJsdWVJZCkge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVkUHRyID0gZWxlbVNpemUgKiBvaWR4XG4gICAgICAgICAgaWYoYjEgPCByZWRbcmVkUHRyK2F4aXMrMV0gfHwgXG4gICAgICAgICAgICByZWRbcmVkUHRyK2F4aXMrMStkXSA8IGIwKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IodmFyIGs9YXhpcysyOyBrPGQ7ICsraykge1xuICAgICAgICAgICAgaWYoYmx1ZVtibHVlUHRyICsgayArIGRdIDwgcmVkW3JlZFB0ciArIGtdIHx8IFxuICAgICAgICAgICAgICAgcmVkW3JlZFB0ciArIGsgKyBkXSAgIDwgYmx1ZVtibHVlUHRyICsga10pIHtcbiAgICAgICAgICAgICAgY29udGludWUgcmVkX2xvb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQocmVkSWQsIGJsdWVJZClcbiAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHZhbCBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlkeCA9IGUgLSBCTFVFX0ZMQUdcbiAgICAgIGZvcih2YXIgaj1yZWRBY3RpdmUtMTsgaj49MDsgLS1qKSB7XG4gICAgICAgIGlmKFJFRF9TV0VFUF9RVUVVRVtqXSA9PT0gaWR4KSB7XG4gICAgICAgICAgZm9yKHZhciBrPWorMTsgazxyZWRBY3RpdmU7ICsraykge1xuICAgICAgICAgICAgUkVEX1NXRUVQX1FVRVVFW2stMV0gPSBSRURfU1dFRVBfUVVFVUVba11cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLS1yZWRBY3RpdmVcbiAgICB9XG4gIH1cbn0iLCIvKipcbiAqIEJpdCB0d2lkZGxpbmcgaGFja3MgZm9yIEphdmFTY3JpcHQuXG4gKlxuICogQXV0aG9yOiBNaWtvbGEgTHlzZW5rb1xuICpcbiAqIFBvcnRlZCBmcm9tIFN0YW5mb3JkIGJpdCB0d2lkZGxpbmcgaGFjayBsaWJyYXJ5OlxuICogICAgaHR0cDovL2dyYXBoaWNzLnN0YW5mb3JkLmVkdS9+c2VhbmRlci9iaXRoYWNrcy5odG1sXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7IFwidXNlIHJlc3RyaWN0XCI7XG5cbi8vTnVtYmVyIG9mIGJpdHMgaW4gYW4gaW50ZWdlclxudmFyIElOVF9CSVRTID0gMzI7XG5cbi8vQ29uc3RhbnRzXG5leHBvcnRzLklOVF9CSVRTICA9IElOVF9CSVRTO1xuZXhwb3J0cy5JTlRfTUFYICAgPSAgMHg3ZmZmZmZmZjtcbmV4cG9ydHMuSU5UX01JTiAgID0gLTE8PChJTlRfQklUUy0xKTtcblxuLy9SZXR1cm5zIC0xLCAwLCArMSBkZXBlbmRpbmcgb24gc2lnbiBvZiB4XG5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAodiA+IDApIC0gKHYgPCAwKTtcbn1cblxuLy9Db21wdXRlcyBhYnNvbHV0ZSB2YWx1ZSBvZiBpbnRlZ2VyXG5leHBvcnRzLmFicyA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIG1hc2sgPSB2ID4+IChJTlRfQklUUy0xKTtcbiAgcmV0dXJuICh2IF4gbWFzaykgLSBtYXNrO1xufVxuXG4vL0NvbXB1dGVzIG1pbmltdW0gb2YgaW50ZWdlcnMgeCBhbmQgeVxuZXhwb3J0cy5taW4gPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiB5IF4gKCh4IF4geSkgJiAtKHggPCB5KSk7XG59XG5cbi8vQ29tcHV0ZXMgbWF4aW11bSBvZiBpbnRlZ2VycyB4IGFuZCB5XG5leHBvcnRzLm1heCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIHggXiAoKHggXiB5KSAmIC0oeCA8IHkpKTtcbn1cblxuLy9DaGVja3MgaWYgYSBudW1iZXIgaXMgYSBwb3dlciBvZiB0d29cbmV4cG9ydHMuaXNQb3cyID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gISh2ICYgKHYtMSkpICYmICghIXYpO1xufVxuXG4vL0NvbXB1dGVzIGxvZyBiYXNlIDIgb2YgdlxuZXhwb3J0cy5sb2cyID0gZnVuY3Rpb24odikge1xuICB2YXIgciwgc2hpZnQ7XG4gIHIgPSAgICAgKHYgPiAweEZGRkYpIDw8IDQ7IHYgPj4+PSByO1xuICBzaGlmdCA9ICh2ID4gMHhGRiAgKSA8PCAzOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAweEYgICApIDw8IDI7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDB4MyAgICkgPDwgMTsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICByZXR1cm4gciB8ICh2ID4+IDEpO1xufVxuXG4vL0NvbXB1dGVzIGxvZyBiYXNlIDEwIG9mIHZcbmV4cG9ydHMubG9nMTAgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAgKHYgPj0gMTAwMDAwMDAwMCkgPyA5IDogKHYgPj0gMTAwMDAwMDAwKSA/IDggOiAodiA+PSAxMDAwMDAwMCkgPyA3IDpcbiAgICAgICAgICAodiA+PSAxMDAwMDAwKSA/IDYgOiAodiA+PSAxMDAwMDApID8gNSA6ICh2ID49IDEwMDAwKSA/IDQgOlxuICAgICAgICAgICh2ID49IDEwMDApID8gMyA6ICh2ID49IDEwMCkgPyAyIDogKHYgPj0gMTApID8gMSA6IDA7XG59XG5cbi8vQ291bnRzIG51bWJlciBvZiBiaXRzXG5leHBvcnRzLnBvcENvdW50ID0gZnVuY3Rpb24odikge1xuICB2ID0gdiAtICgodiA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgdiA9ICh2ICYgMHgzMzMzMzMzMykgKyAoKHYgPj4+IDIpICYgMHgzMzMzMzMzMyk7XG4gIHJldHVybiAoKHYgKyAodiA+Pj4gNCkgJiAweEYwRjBGMEYpICogMHgxMDEwMTAxKSA+Pj4gMjQ7XG59XG5cbi8vQ291bnRzIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvc1xuZnVuY3Rpb24gY291bnRUcmFpbGluZ1plcm9zKHYpIHtcbiAgdmFyIGMgPSAzMjtcbiAgdiAmPSAtdjtcbiAgaWYgKHYpIGMtLTtcbiAgaWYgKHYgJiAweDAwMDBGRkZGKSBjIC09IDE2O1xuICBpZiAodiAmIDB4MDBGRjAwRkYpIGMgLT0gODtcbiAgaWYgKHYgJiAweDBGMEYwRjBGKSBjIC09IDQ7XG4gIGlmICh2ICYgMHgzMzMzMzMzMykgYyAtPSAyO1xuICBpZiAodiAmIDB4NTU1NTU1NTUpIGMgLT0gMTtcbiAgcmV0dXJuIGM7XG59XG5leHBvcnRzLmNvdW50VHJhaWxpbmdaZXJvcyA9IGNvdW50VHJhaWxpbmdaZXJvcztcblxuLy9Sb3VuZHMgdG8gbmV4dCBwb3dlciBvZiAyXG5leHBvcnRzLm5leHRQb3cyID0gZnVuY3Rpb24odikge1xuICB2ICs9IHYgPT09IDA7XG4gIC0tdjtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiArIDE7XG59XG5cbi8vUm91bmRzIGRvd24gdG8gcHJldmlvdXMgcG93ZXIgb2YgMlxuZXhwb3J0cy5wcmV2UG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiAtICh2Pj4+MSk7XG59XG5cbi8vQ29tcHV0ZXMgcGFyaXR5IG9mIHdvcmRcbmV4cG9ydHMucGFyaXR5ID0gZnVuY3Rpb24odikge1xuICB2IF49IHYgPj4+IDE2O1xuICB2IF49IHYgPj4+IDg7XG4gIHYgXj0gdiA+Pj4gNDtcbiAgdiAmPSAweGY7XG4gIHJldHVybiAoMHg2OTk2ID4+PiB2KSAmIDE7XG59XG5cbnZhciBSRVZFUlNFX1RBQkxFID0gbmV3IEFycmF5KDI1Nik7XG5cbihmdW5jdGlvbih0YWIpIHtcbiAgZm9yKHZhciBpPTA7IGk8MjU2OyArK2kpIHtcbiAgICB2YXIgdiA9IGksIHIgPSBpLCBzID0gNztcbiAgICBmb3IgKHYgPj4+PSAxOyB2OyB2ID4+Pj0gMSkge1xuICAgICAgciA8PD0gMTtcbiAgICAgIHIgfD0gdiAmIDE7XG4gICAgICAtLXM7XG4gICAgfVxuICAgIHRhYltpXSA9IChyIDw8IHMpICYgMHhmZjtcbiAgfVxufSkoUkVWRVJTRV9UQUJMRSk7XG5cbi8vUmV2ZXJzZSBiaXRzIGluIGEgMzIgYml0IHdvcmRcbmV4cG9ydHMucmV2ZXJzZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICAoUkVWRVJTRV9UQUJMRVsgdiAgICAgICAgICYgMHhmZl0gPDwgMjQpIHxcbiAgICAgICAgICAoUkVWRVJTRV9UQUJMRVsodiA+Pj4gOCkgICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgICAoUkVWRVJTRV9UQUJMRVsodiA+Pj4gMTYpICYgMHhmZl0gPDwgOCkgIHxcbiAgICAgICAgICAgUkVWRVJTRV9UQUJMRVsodiA+Pj4gMjQpICYgMHhmZl07XG59XG5cbi8vSW50ZXJsZWF2ZSBiaXRzIG9mIDIgY29vcmRpbmF0ZXMgd2l0aCAxNiBiaXRzLiAgVXNlZnVsIGZvciBmYXN0IHF1YWR0cmVlIGNvZGVzXG5leHBvcnRzLmludGVybGVhdmUyID0gZnVuY3Rpb24oeCwgeSkge1xuICB4ICY9IDB4RkZGRjtcbiAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICB5ICY9IDB4RkZGRjtcbiAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vL0V4dHJhY3RzIHRoZSBudGggaW50ZXJsZWF2ZWQgY29tcG9uZW50XG5leHBvcnRzLmRlaW50ZXJsZWF2ZTIgPSBmdW5jdGlvbih2LCBuKSB7XG4gIHYgPSAodiA+Pj4gbikgJiAweDU1NTU1NTU1O1xuICB2ID0gKHYgfCAodiA+Pj4gMSkpICAmIDB4MzMzMzMzMzM7XG4gIHYgPSAodiB8ICh2ID4+PiAyKSkgICYgMHgwRjBGMEYwRjtcbiAgdiA9ICh2IHwgKHYgPj4+IDQpKSAgJiAweDAwRkYwMEZGO1xuICB2ID0gKHYgfCAodiA+Pj4gMTYpKSAmIDB4MDAwRkZGRjtcbiAgcmV0dXJuICh2IDw8IDE2KSA+PiAxNjtcbn1cblxuXG4vL0ludGVybGVhdmUgYml0cyBvZiAzIGNvb3JkaW5hdGVzLCBlYWNoIHdpdGggMTAgYml0cy4gIFVzZWZ1bCBmb3IgZmFzdCBvY3RyZWUgY29kZXNcbmV4cG9ydHMuaW50ZXJsZWF2ZTMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHggJj0gMHgzRkY7XG4gIHggID0gKHggfCAoeDw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHggID0gKHggfCAoeDw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeCAgPSAoeCB8ICh4PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeCAgPSAoeCB8ICh4PDwyKSkgICYgMTIyNzEzMzUxMztcblxuICB5ICY9IDB4M0ZGO1xuICB5ICA9ICh5IHwgKHk8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB5ICA9ICh5IHwgKHk8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHkgID0gKHkgfCAoeTw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHkgID0gKHkgfCAoeTw8MikpICAmIDEyMjcxMzM1MTM7XG4gIHggfD0gKHkgPDwgMSk7XG4gIFxuICB6ICY9IDB4M0ZGO1xuICB6ICA9ICh6IHwgKHo8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB6ICA9ICh6IHwgKHo8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHogID0gKHogfCAoejw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHogID0gKHogfCAoejw8MikpICAmIDEyMjcxMzM1MTM7XG4gIFxuICByZXR1cm4geCB8ICh6IDw8IDIpO1xufVxuXG4vL0V4dHJhY3RzIG50aCBpbnRlcmxlYXZlZCBjb21wb25lbnQgb2YgYSAzLXR1cGxlXG5leHBvcnRzLmRlaW50ZXJsZWF2ZTMgPSBmdW5jdGlvbih2LCBuKSB7XG4gIHYgPSAodiA+Pj4gbikgICAgICAgJiAxMjI3MTMzNTEzO1xuICB2ID0gKHYgfCAodj4+PjIpKSAgICYgMzI3MjM1NjAzNTtcbiAgdiA9ICh2IHwgKHY+Pj40KSkgICAmIDI1MTcxOTY5NTtcbiAgdiA9ICh2IHwgKHY+Pj44KSkgICAmIDQyNzgxOTAzMzU7XG4gIHYgPSAodiB8ICh2Pj4+MTYpKSAgJiAweDNGRjtcbiAgcmV0dXJuICh2PDwyMik+PjIyO1xufVxuXG4vL0NvbXB1dGVzIG5leHQgY29tYmluYXRpb24gaW4gY29sZXhpY29ncmFwaGljIG9yZGVyICh0aGlzIGlzIG1pc3Rha2VubHkgY2FsbGVkIG5leHRQZXJtdXRhdGlvbiBvbiB0aGUgYml0IHR3aWRkbGluZyBoYWNrcyBwYWdlKVxuZXhwb3J0cy5uZXh0Q29tYmluYXRpb24gPSBmdW5jdGlvbih2KSB7XG4gIHZhciB0ID0gdiB8ICh2IC0gMSk7XG4gIHJldHVybiAodCArIDEpIHwgKCgofnQgJiAtfnQpIC0gMSkgPj4+IChjb3VudFRyYWlsaW5nWmVyb3ModikgKyAxKSk7XG59XG5cbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIGR1cGVfYXJyYXkoY291bnQsIHZhbHVlLCBpKSB7XG4gIHZhciBjID0gY291bnRbaV18MFxuICBpZihjIDw9IDApIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGMpLCBqXG4gIGlmKGkgPT09IGNvdW50Lmxlbmd0aC0xKSB7XG4gICAgZm9yKGo9MDsgajxjOyArK2opIHtcbiAgICAgIHJlc3VsdFtqXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvcihqPTA7IGo8YzsgKytqKSB7XG4gICAgICByZXN1bHRbal0gPSBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgaSsxKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGR1cGVfbnVtYmVyKGNvdW50LCB2YWx1ZSkge1xuICB2YXIgcmVzdWx0LCBpXG4gIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudClcbiAgZm9yKGk9MDsgaTxjb3VudDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gdmFsdWVcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGR1cGUoY291bnQsIHZhbHVlKSB7XG4gIGlmKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhbHVlID0gMFxuICB9XG4gIHN3aXRjaCh0eXBlb2YgY291bnQpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBpZihjb3VudCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGR1cGVfbnVtYmVyKGNvdW50fDAsIHZhbHVlKVxuICAgICAgfVxuICAgIGJyZWFrXG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYodHlwZW9mIChjb3VudC5sZW5ndGgpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgMClcbiAgICAgIH1cbiAgICBicmVha1xuICB9XG4gIHJldHVybiBbXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGR1cGUiLCIoZnVuY3Rpb24gKGdsb2JhbCxCdWZmZXIpe1xuJ3VzZSBzdHJpY3QnXG5cbnZhciBiaXRzID0gcmVxdWlyZSgnYml0LXR3aWRkbGUnKVxudmFyIGR1cCA9IHJlcXVpcmUoJ2R1cCcpXG5cbi8vTGVnYWN5IHBvb2wgc3VwcG9ydFxuaWYoIWdsb2JhbC5fX1RZUEVEQVJSQVlfUE9PTCkge1xuICBnbG9iYWwuX19UWVBFREFSUkFZX1BPT0wgPSB7XG4gICAgICBVSU5UOCAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UMTYgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UMzIgIDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQ4ICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQxNiAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQzMiAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBGTE9BVCAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBET1VCTEUgIDogZHVwKFszMiwgMF0pXG4gICAgLCBEQVRBICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UOEMgIDogZHVwKFszMiwgMF0pXG4gICAgLCBCVUZGRVIgIDogZHVwKFszMiwgMF0pXG4gIH1cbn1cblxudmFyIGhhc1VpbnQ4QyA9ICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkpICE9PSAndW5kZWZpbmVkJ1xudmFyIFBPT0wgPSBnbG9iYWwuX19UWVBFREFSUkFZX1BPT0xcblxuLy9VcGdyYWRlIHBvb2xcbmlmKCFQT09MLlVJTlQ4Qykge1xuICBQT09MLlVJTlQ4QyA9IGR1cChbMzIsIDBdKVxufVxuaWYoIVBPT0wuQlVGRkVSKSB7XG4gIFBPT0wuQlVGRkVSID0gZHVwKFszMiwgMF0pXG59XG5cbi8vTmV3IHRlY2huaXF1ZTogT25seSBhbGxvY2F0ZSBmcm9tIEFycmF5QnVmZmVyVmlldyBhbmQgQnVmZmVyXG52YXIgREFUQSAgICA9IFBPT0wuREFUQVxuICAsIEJVRkZFUiAgPSBQT09MLkJVRkZFUlxuXG5leHBvcnRzLmZyZWUgPSBmdW5jdGlvbiBmcmVlKGFycmF5KSB7XG4gIGlmKEJ1ZmZlci5pc0J1ZmZlcihhcnJheSkpIHtcbiAgICBCVUZGRVJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG4gIH0gZWxzZSB7XG4gICAgaWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycmF5KSAhPT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgYXJyYXkgPSBhcnJheS5idWZmZXJcbiAgICB9XG4gICAgaWYoIWFycmF5KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIG4gPSBhcnJheS5sZW5ndGggfHwgYXJyYXkuYnl0ZUxlbmd0aFxuICAgIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKXwwXG4gICAgREFUQVtsb2dfbl0ucHVzaChhcnJheSlcbiAgfVxufVxuXG5mdW5jdGlvbiBmcmVlQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gIGlmKCFidWZmZXIpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IGJ1ZmZlci5sZW5ndGggfHwgYnVmZmVyLmJ5dGVMZW5ndGhcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIERBVEFbbG9nX25dLnB1c2goYnVmZmVyKVxufVxuXG5mdW5jdGlvbiBmcmVlVHlwZWRBcnJheShhcnJheSkge1xuICBmcmVlQXJyYXlCdWZmZXIoYXJyYXkuYnVmZmVyKVxufVxuXG5leHBvcnRzLmZyZWVVaW50OCA9XG5leHBvcnRzLmZyZWVVaW50MTYgPVxuZXhwb3J0cy5mcmVlVWludDMyID1cbmV4cG9ydHMuZnJlZUludDggPVxuZXhwb3J0cy5mcmVlSW50MTYgPVxuZXhwb3J0cy5mcmVlSW50MzIgPVxuZXhwb3J0cy5mcmVlRmxvYXQzMiA9IFxuZXhwb3J0cy5mcmVlRmxvYXQgPVxuZXhwb3J0cy5mcmVlRmxvYXQ2NCA9IFxuZXhwb3J0cy5mcmVlRG91YmxlID0gXG5leHBvcnRzLmZyZWVVaW50OENsYW1wZWQgPSBcbmV4cG9ydHMuZnJlZURhdGFWaWV3ID0gZnJlZVR5cGVkQXJyYXlcblxuZXhwb3J0cy5mcmVlQXJyYXlCdWZmZXIgPSBmcmVlQXJyYXlCdWZmZXJcblxuZXhwb3J0cy5mcmVlQnVmZmVyID0gZnVuY3Rpb24gZnJlZUJ1ZmZlcihhcnJheSkge1xuICBCVUZGRVJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG59XG5cbmV4cG9ydHMubWFsbG9jID0gZnVuY3Rpb24gbWFsbG9jKG4sIGR0eXBlKSB7XG4gIGlmKGR0eXBlID09PSB1bmRlZmluZWQgfHwgZHR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICByZXR1cm4gbWFsbG9jQXJyYXlCdWZmZXIobilcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2goZHR5cGUpIHtcbiAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQ4KG4pXG4gICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDE2KG4pXG4gICAgICBjYXNlICd1aW50MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDMyKG4pXG4gICAgICBjYXNlICdpbnQ4JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDgobilcbiAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDE2KG4pXG4gICAgICBjYXNlICdpbnQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQzMihuKVxuICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NGbG9hdChuKVxuICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICByZXR1cm4gbWFsbG9jRG91YmxlKG4pXG4gICAgICBjYXNlICd1aW50OF9jbGFtcGVkJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQ4Q2xhbXBlZChuKVxuICAgICAgY2FzZSAnYnVmZmVyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0J1ZmZlcihuKVxuICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICBjYXNlICdkYXRhdmlldyc6XG4gICAgICAgIHJldHVybiBtYWxsb2NEYXRhVmlldyhuKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBtYWxsb2NBcnJheUJ1ZmZlcihuKSB7XG4gIHZhciBuID0gYml0cy5uZXh0UG93MihuKVxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgdmFyIGQgPSBEQVRBW2xvZ19uXVxuICBpZihkLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZC5wb3AoKVxuICB9XG4gIHJldHVybiBuZXcgQXJyYXlCdWZmZXIobilcbn1cbmV4cG9ydHMubWFsbG9jQXJyYXlCdWZmZXIgPSBtYWxsb2NBcnJheUJ1ZmZlclxuXG5mdW5jdGlvbiBtYWxsb2NVaW50OChuKSB7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDggPSBtYWxsb2NVaW50OFxuXG5mdW5jdGlvbiBtYWxsb2NVaW50MTYobikge1xuICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDIqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQxNiA9IG1hbGxvY1VpbnQxNlxuXG5mdW5jdGlvbiBtYWxsb2NVaW50MzIobikge1xuICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQzMiA9IG1hbGxvY1VpbnQzMlxuXG5mdW5jdGlvbiBtYWxsb2NJbnQ4KG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDggPSBtYWxsb2NJbnQ4XG5cbmZ1bmN0aW9uIG1hbGxvY0ludDE2KG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDIqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDE2ID0gbWFsbG9jSW50MTZcblxuZnVuY3Rpb24gbWFsbG9jSW50MzIobikge1xuICByZXR1cm4gbmV3IEludDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50MzIgPSBtYWxsb2NJbnQzMlxuXG5mdW5jdGlvbiBtYWxsb2NGbG9hdChuKSB7XG4gIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0Zsb2F0MzIgPSBleHBvcnRzLm1hbGxvY0Zsb2F0ID0gbWFsbG9jRmxvYXRcblxuZnVuY3Rpb24gbWFsbG9jRG91YmxlKG4pIHtcbiAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoOCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jRmxvYXQ2NCA9IGV4cG9ydHMubWFsbG9jRG91YmxlID0gbWFsbG9jRG91YmxlXG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQ4Q2xhbXBlZChuKSB7XG4gIGlmKGhhc1VpbnQ4Qykge1xuICAgIHJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1hbGxvY1VpbnQ4KG4pXG4gIH1cbn1cbmV4cG9ydHMubWFsbG9jVWludDhDbGFtcGVkID0gbWFsbG9jVWludDhDbGFtcGVkXG5cbmZ1bmN0aW9uIG1hbGxvY0RhdGFWaWV3KG4pIHtcbiAgcmV0dXJuIG5ldyBEYXRhVmlldyhtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jRGF0YVZpZXcgPSBtYWxsb2NEYXRhVmlld1xuXG5mdW5jdGlvbiBtYWxsb2NCdWZmZXIobikge1xuICBuID0gYml0cy5uZXh0UG93MihuKVxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgdmFyIGNhY2hlID0gQlVGRkVSW2xvZ19uXVxuICBpZihjYWNoZS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGNhY2hlLnBvcCgpXG4gIH1cbiAgcmV0dXJuIG5ldyBCdWZmZXIobilcbn1cbmV4cG9ydHMubWFsbG9jQnVmZmVyID0gbWFsbG9jQnVmZmVyXG5cbmV4cG9ydHMuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XG4gIGZvcih2YXIgaT0wOyBpPDMyOyArK2kpIHtcbiAgICBQT09MLlVJTlQ4W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQxNltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UMzJbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UOFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5JTlQxNltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5JTlQzMltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5GTE9BVFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5ET1VCTEVbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDhDW2ldLmxlbmd0aCA9IDBcbiAgICBEQVRBW2ldLmxlbmd0aCA9IDBcbiAgICBCVUZGRVJbaV0ubGVuZ3RoID0gMFxuICB9XG59XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpYjNndGFXNTBaWEp6WldOMEwyNXZaR1ZmYlc5a2RXeGxjeTkwZVhCbFpHRnljbUY1TFhCdmIyd3ZjRzl2YkM1cWN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFaUxDSm1hV3hsSWpvaVoyVnVaWEpoZEdWa0xtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJaWQxYzJVZ2MzUnlhV04wSjF4dVhHNTJZWElnWW1sMGN5QTlJSEpsY1hWcGNtVW9KMkpwZEMxMGQybGtaR3hsSnlsY2JuWmhjaUJrZFhBZ1BTQnlaWEYxYVhKbEtDZGtkWEFuS1Z4dVhHNHZMMHhsWjJGamVTQndiMjlzSUhOMWNIQnZjblJjYm1sbUtDRm5iRzlpWVd3dVgxOVVXVkJGUkVGU1VrRlpYMUJQVDB3cElIdGNiaUFnWjJ4dlltRnNMbDlmVkZsUVJVUkJVbEpCV1Y5UVQwOU1JRDBnZTF4dUlDQWdJQ0FnVlVsT1ZEZ2dJQ0E2SUdSMWNDaGJNeklzSURCZEtWeHVJQ0FnSUN3Z1ZVbE9WREUySUNBNklHUjFjQ2hiTXpJc0lEQmRLVnh1SUNBZ0lDd2dWVWxPVkRNeUlDQTZJR1IxY0NoYk16SXNJREJkS1Z4dUlDQWdJQ3dnU1U1VU9DQWdJQ0E2SUdSMWNDaGJNeklzSURCZEtWeHVJQ0FnSUN3Z1NVNVVNVFlnSUNBNklHUjFjQ2hiTXpJc0lEQmRLVnh1SUNBZ0lDd2dTVTVVTXpJZ0lDQTZJR1IxY0NoYk16SXNJREJkS1Z4dUlDQWdJQ3dnUmt4UFFWUWdJQ0E2SUdSMWNDaGJNeklzSURCZEtWeHVJQ0FnSUN3Z1JFOVZRa3hGSUNBNklHUjFjQ2hiTXpJc0lEQmRLVnh1SUNBZ0lDd2dSRUZVUVNBZ0lDQTZJR1IxY0NoYk16SXNJREJkS1Z4dUlDQWdJQ3dnVlVsT1ZEaERJQ0E2SUdSMWNDaGJNeklzSURCZEtWeHVJQ0FnSUN3Z1FsVkdSa1ZTSUNBNklHUjFjQ2hiTXpJc0lEQmRLVnh1SUNCOVhHNTlYRzVjYm5aaGNpQm9ZWE5WYVc1ME9FTWdQU0FvZEhsd1pXOW1JRlZwYm5RNFEyeGhiWEJsWkVGeWNtRjVLU0FoUFQwZ0ozVnVaR1ZtYVc1bFpDZGNiblpoY2lCUVQwOU1JRDBnWjJ4dlltRnNMbDlmVkZsUVJVUkJVbEpCV1Y5UVQwOU1YRzVjYmk4dlZYQm5jbUZrWlNCd2IyOXNYRzVwWmlnaFVFOVBUQzVWU1U1VU9FTXBJSHRjYmlBZ1VFOVBUQzVWU1U1VU9FTWdQU0JrZFhBb1d6TXlMQ0F3WFNsY2JuMWNibWxtS0NGUVQwOU1Ma0pWUmtaRlVpa2dlMXh1SUNCUVQwOU1Ma0pWUmtaRlVpQTlJR1IxY0NoYk16SXNJREJkS1Z4dWZWeHVYRzR2TDA1bGR5QjBaV05vYm1seGRXVTZJRTl1YkhrZ1lXeHNiMk5oZEdVZ1puSnZiU0JCY25KaGVVSjFabVpsY2xacFpYY2dZVzVrSUVKMVptWmxjbHh1ZG1GeUlFUkJWRUVnSUNBZ1BTQlFUMDlNTGtSQlZFRmNiaUFnTENCQ1ZVWkdSVklnSUQwZ1VFOVBUQzVDVlVaR1JWSmNibHh1Wlhod2IzSjBjeTVtY21WbElEMGdablZ1WTNScGIyNGdabkpsWlNoaGNuSmhlU2tnZTF4dUlDQnBaaWhDZFdabVpYSXVhWE5DZFdabVpYSW9ZWEp5WVhrcEtTQjdYRzRnSUNBZ1FsVkdSa1ZTVzJKcGRITXViRzluTWloaGNuSmhlUzVzWlc1bmRHZ3BYUzV3ZFhOb0tHRnljbUY1S1Z4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUdsbUtFOWlhbVZqZEM1d2NtOTBiM1I1Y0dVdWRHOVRkSEpwYm1jdVkyRnNiQ2hoY25KaGVTa2dJVDA5SUNkYmIySnFaV04wSUVGeWNtRjVRblZtWm1WeVhTY3BJSHRjYmlBZ0lDQWdJR0Z5Y21GNUlEMGdZWEp5WVhrdVluVm1abVZ5WEc0Z0lDQWdmVnh1SUNBZ0lHbG1LQ0ZoY25KaGVTa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdVhHNGdJQ0FnZlZ4dUlDQWdJSFpoY2lCdUlEMGdZWEp5WVhrdWJHVnVaM1JvSUh4OElHRnljbUY1TG1KNWRHVk1aVzVuZEdoY2JpQWdJQ0IyWVhJZ2JHOW5YMjRnUFNCaWFYUnpMbXh2WnpJb2JpbDhNRnh1SUNBZ0lFUkJWRUZiYkc5blgyNWRMbkIxYzJnb1lYSnlZWGtwWEc0Z0lIMWNibjFjYmx4dVpuVnVZM1JwYjI0Z1puSmxaVUZ5Y21GNVFuVm1abVZ5S0dKMVptWmxjaWtnZTF4dUlDQnBaaWdoWW5WbVptVnlLU0I3WEc0Z0lDQWdjbVYwZFhKdVhHNGdJSDFjYmlBZ2RtRnlJRzRnUFNCaWRXWm1aWEl1YkdWdVozUm9JSHg4SUdKMVptWmxjaTVpZVhSbFRHVnVaM1JvWEc0Z0lIWmhjaUJzYjJkZmJpQTlJR0pwZEhNdWJHOW5NaWh1S1Z4dUlDQkVRVlJCVzJ4dloxOXVYUzV3ZFhOb0tHSjFabVpsY2lsY2JuMWNibHh1Wm5WdVkzUnBiMjRnWm5KbFpWUjVjR1ZrUVhKeVlYa29ZWEp5WVhrcElIdGNiaUFnWm5KbFpVRnljbUY1UW5WbVptVnlLR0Z5Y21GNUxtSjFabVpsY2lsY2JuMWNibHh1Wlhod2IzSjBjeTVtY21WbFZXbHVkRGdnUFZ4dVpYaHdiM0owY3k1bWNtVmxWV2x1ZERFMklEMWNibVY0Y0c5eWRITXVabkpsWlZWcGJuUXpNaUE5WEc1bGVIQnZjblJ6TG1aeVpXVkpiblE0SUQxY2JtVjRjRzl5ZEhNdVpuSmxaVWx1ZERFMklEMWNibVY0Y0c5eWRITXVabkpsWlVsdWRETXlJRDFjYm1WNGNHOXlkSE11Wm5KbFpVWnNiMkYwTXpJZ1BTQmNibVY0Y0c5eWRITXVabkpsWlVac2IyRjBJRDFjYm1WNGNHOXlkSE11Wm5KbFpVWnNiMkYwTmpRZ1BTQmNibVY0Y0c5eWRITXVabkpsWlVSdmRXSnNaU0E5SUZ4dVpYaHdiM0owY3k1bWNtVmxWV2x1ZERoRGJHRnRjR1ZrSUQwZ1hHNWxlSEJ2Y25SekxtWnlaV1ZFWVhSaFZtbGxkeUE5SUdaeVpXVlVlWEJsWkVGeWNtRjVYRzVjYm1WNGNHOXlkSE11Wm5KbFpVRnljbUY1UW5WbVptVnlJRDBnWm5KbFpVRnljbUY1UW5WbVptVnlYRzVjYm1WNGNHOXlkSE11Wm5KbFpVSjFabVpsY2lBOUlHWjFibU4wYVc5dUlHWnlaV1ZDZFdabVpYSW9ZWEp5WVhrcElIdGNiaUFnUWxWR1JrVlNXMkpwZEhNdWJHOW5NaWhoY25KaGVTNXNaVzVuZEdncFhTNXdkWE5vS0dGeWNtRjVLVnh1ZlZ4dVhHNWxlSEJ2Y25SekxtMWhiR3h2WXlBOUlHWjFibU4wYVc5dUlHMWhiR3h2WXlodUxDQmtkSGx3WlNrZ2UxeHVJQ0JwWmloa2RIbHdaU0E5UFQwZ2RXNWtaV1pwYm1Wa0lIeDhJR1IwZVhCbElEMDlQU0FuWVhKeVlYbGlkV1ptWlhJbktTQjdYRzRnSUNBZ2NtVjBkWEp1SUcxaGJHeHZZMEZ5Y21GNVFuVm1abVZ5S0c0cFhHNGdJSDBnWld4elpTQjdYRzRnSUNBZ2MzZHBkR05vS0dSMGVYQmxLU0I3WEc0Z0lDQWdJQ0JqWVhObElDZDFhVzUwT0NjNlhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCdFlXeHNiMk5WYVc1ME9DaHVLVnh1SUNBZ0lDQWdZMkZ6WlNBbmRXbHVkREUySnpwY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUcxaGJHeHZZMVZwYm5ReE5paHVLVnh1SUNBZ0lDQWdZMkZ6WlNBbmRXbHVkRE15SnpwY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUcxaGJHeHZZMVZwYm5Rek1paHVLVnh1SUNBZ0lDQWdZMkZ6WlNBbmFXNTBPQ2M2WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJ0WVd4c2IyTkpiblE0S0c0cFhHNGdJQ0FnSUNCallYTmxJQ2RwYm5ReE5pYzZYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnRZV3hzYjJOSmJuUXhOaWh1S1Z4dUlDQWdJQ0FnWTJGelpTQW5hVzUwTXpJbk9seHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2JXRnNiRzlqU1c1ME16SW9iaWxjYmlBZ0lDQWdJR05oYzJVZ0oyWnNiMkYwSnpwY2JpQWdJQ0FnSUdOaGMyVWdKMlpzYjJGME16SW5PbHh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdiV0ZzYkc5alJteHZZWFFvYmlsY2JpQWdJQ0FnSUdOaGMyVWdKMlJ2ZFdKc1pTYzZYRzRnSUNBZ0lDQmpZWE5sSUNkbWJHOWhkRFkwSnpwY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUcxaGJHeHZZMFJ2ZFdKc1pTaHVLVnh1SUNBZ0lDQWdZMkZ6WlNBbmRXbHVkRGhmWTJ4aGJYQmxaQ2M2WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJ0WVd4c2IyTlZhVzUwT0VOc1lXMXdaV1FvYmlsY2JpQWdJQ0FnSUdOaGMyVWdKMkoxWm1abGNpYzZYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnRZV3hzYjJOQ2RXWm1aWElvYmlsY2JpQWdJQ0FnSUdOaGMyVWdKMlJoZEdFbk9seHVJQ0FnSUNBZ1kyRnpaU0FuWkdGMFlYWnBaWGNuT2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnYldGc2JHOWpSR0YwWVZacFpYY29iaWxjYmx4dUlDQWdJQ0FnWkdWbVlYVnNkRHBjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJRzUxYkd4Y2JpQWdJQ0I5WEc0Z0lIMWNiaUFnY21WMGRYSnVJRzUxYkd4Y2JuMWNibHh1Wm5WdVkzUnBiMjRnYldGc2JHOWpRWEp5WVhsQ2RXWm1aWElvYmlrZ2UxeHVJQ0IyWVhJZ2JpQTlJR0pwZEhNdWJtVjRkRkJ2ZHpJb2JpbGNiaUFnZG1GeUlHeHZaMTl1SUQwZ1ltbDBjeTVzYjJjeUtHNHBYRzRnSUhaaGNpQmtJRDBnUkVGVVFWdHNiMmRmYmwxY2JpQWdhV1lvWkM1c1pXNW5kR2dnUGlBd0tTQjdYRzRnSUNBZ2NtVjBkWEp1SUdRdWNHOXdLQ2xjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdibVYzSUVGeWNtRjVRblZtWm1WeUtHNHBYRzU5WEc1bGVIQnZjblJ6TG0xaGJHeHZZMEZ5Y21GNVFuVm1abVZ5SUQwZ2JXRnNiRzlqUVhKeVlYbENkV1ptWlhKY2JseHVablZ1WTNScGIyNGdiV0ZzYkc5alZXbHVkRGdvYmlrZ2UxeHVJQ0J5WlhSMWNtNGdibVYzSUZWcGJuUTRRWEp5WVhrb2JXRnNiRzlqUVhKeVlYbENkV1ptWlhJb2Jpa3NJREFzSUc0cFhHNTlYRzVsZUhCdmNuUnpMbTFoYkd4dlkxVnBiblE0SUQwZ2JXRnNiRzlqVldsdWREaGNibHh1Wm5WdVkzUnBiMjRnYldGc2JHOWpWV2x1ZERFMktHNHBJSHRjYmlBZ2NtVjBkWEp1SUc1bGR5QlZhVzUwTVRaQmNuSmhlU2h0WVd4c2IyTkJjbkpoZVVKMVptWmxjaWd5S200cExDQXdMQ0J1S1Z4dWZWeHVaWGh3YjNKMGN5NXRZV3hzYjJOVmFXNTBNVFlnUFNCdFlXeHNiMk5WYVc1ME1UWmNibHh1Wm5WdVkzUnBiMjRnYldGc2JHOWpWV2x1ZERNeUtHNHBJSHRjYmlBZ2NtVjBkWEp1SUc1bGR5QlZhVzUwTXpKQmNuSmhlU2h0WVd4c2IyTkJjbkpoZVVKMVptWmxjaWcwS200cExDQXdMQ0J1S1Z4dWZWeHVaWGh3YjNKMGN5NXRZV3hzYjJOVmFXNTBNeklnUFNCdFlXeHNiMk5WYVc1ME16SmNibHh1Wm5WdVkzUnBiMjRnYldGc2JHOWpTVzUwT0NodUtTQjdYRzRnSUhKbGRIVnliaUJ1WlhjZ1NXNTBPRUZ5Y21GNUtHMWhiR3h2WTBGeWNtRjVRblZtWm1WeUtHNHBMQ0F3TENCdUtWeHVmVnh1Wlhod2IzSjBjeTV0WVd4c2IyTkpiblE0SUQwZ2JXRnNiRzlqU1c1ME9GeHVYRzVtZFc1amRHbHZiaUJ0WVd4c2IyTkpiblF4TmlodUtTQjdYRzRnSUhKbGRIVnliaUJ1WlhjZ1NXNTBNVFpCY25KaGVTaHRZV3hzYjJOQmNuSmhlVUoxWm1abGNpZ3lLbTRwTENBd0xDQnVLVnh1ZlZ4dVpYaHdiM0owY3k1dFlXeHNiMk5KYm5ReE5pQTlJRzFoYkd4dlkwbHVkREUyWEc1Y2JtWjFibU4wYVc5dUlHMWhiR3h2WTBsdWRETXlLRzRwSUh0Y2JpQWdjbVYwZFhKdUlHNWxkeUJKYm5Rek1rRnljbUY1S0cxaGJHeHZZMEZ5Y21GNVFuVm1abVZ5S0RRcWJpa3NJREFzSUc0cFhHNTlYRzVsZUhCdmNuUnpMbTFoYkd4dlkwbHVkRE15SUQwZ2JXRnNiRzlqU1c1ME16SmNibHh1Wm5WdVkzUnBiMjRnYldGc2JHOWpSbXh2WVhRb2Jpa2dlMXh1SUNCeVpYUjFjbTRnYm1WM0lFWnNiMkYwTXpKQmNuSmhlU2h0WVd4c2IyTkJjbkpoZVVKMVptWmxjaWcwS200cExDQXdMQ0J1S1Z4dWZWeHVaWGh3YjNKMGN5NXRZV3hzYjJOR2JHOWhkRE15SUQwZ1pYaHdiM0owY3k1dFlXeHNiMk5HYkc5aGRDQTlJRzFoYkd4dlkwWnNiMkYwWEc1Y2JtWjFibU4wYVc5dUlHMWhiR3h2WTBSdmRXSnNaU2h1S1NCN1hHNGdJSEpsZEhWeWJpQnVaWGNnUm14dllYUTJORUZ5Y21GNUtHMWhiR3h2WTBGeWNtRjVRblZtWm1WeUtEZ3FiaWtzSURBc0lHNHBYRzU5WEc1bGVIQnZjblJ6TG0xaGJHeHZZMFpzYjJGME5qUWdQU0JsZUhCdmNuUnpMbTFoYkd4dlkwUnZkV0pzWlNBOUlHMWhiR3h2WTBSdmRXSnNaVnh1WEc1bWRXNWpkR2x2YmlCdFlXeHNiMk5WYVc1ME9FTnNZVzF3WldRb2Jpa2dlMXh1SUNCcFppaG9ZWE5WYVc1ME9FTXBJSHRjYmlBZ0lDQnlaWFIxY200Z2JtVjNJRlZwYm5RNFEyeGhiWEJsWkVGeWNtRjVLRzFoYkd4dlkwRnljbUY1UW5WbVptVnlLRzRwTENBd0xDQnVLVnh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJSEpsZEhWeWJpQnRZV3hzYjJOVmFXNTBPQ2h1S1Z4dUlDQjlYRzU5WEc1bGVIQnZjblJ6TG0xaGJHeHZZMVZwYm5RNFEyeGhiWEJsWkNBOUlHMWhiR3h2WTFWcGJuUTRRMnhoYlhCbFpGeHVYRzVtZFc1amRHbHZiaUJ0WVd4c2IyTkVZWFJoVm1sbGR5aHVLU0I3WEc0Z0lISmxkSFZ5YmlCdVpYY2dSR0YwWVZacFpYY29iV0ZzYkc5alFYSnlZWGxDZFdabVpYSW9iaWtzSURBc0lHNHBYRzU5WEc1bGVIQnZjblJ6TG0xaGJHeHZZMFJoZEdGV2FXVjNJRDBnYldGc2JHOWpSR0YwWVZacFpYZGNibHh1Wm5WdVkzUnBiMjRnYldGc2JHOWpRblZtWm1WeUtHNHBJSHRjYmlBZ2JpQTlJR0pwZEhNdWJtVjRkRkJ2ZHpJb2JpbGNiaUFnZG1GeUlHeHZaMTl1SUQwZ1ltbDBjeTVzYjJjeUtHNHBYRzRnSUhaaGNpQmpZV05vWlNBOUlFSlZSa1pGVWx0c2IyZGZibDFjYmlBZ2FXWW9ZMkZqYUdVdWJHVnVaM1JvSUQ0Z01Da2dlMXh1SUNBZ0lISmxkSFZ5YmlCallXTm9aUzV3YjNBb0tWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCdVpYY2dRblZtWm1WeUtHNHBYRzU5WEc1bGVIQnZjblJ6TG0xaGJHeHZZMEoxWm1abGNpQTlJRzFoYkd4dlkwSjFabVpsY2x4dVhHNWxlSEJ2Y25SekxtTnNaV0Z5UTJGamFHVWdQU0JtZFc1amRHbHZiaUJqYkdWaGNrTmhZMmhsS0NrZ2UxeHVJQ0JtYjNJb2RtRnlJR2s5TURzZ2FUd3pNanNnS3l0cEtTQjdYRzRnSUNBZ1VFOVBUQzVWU1U1VU9GdHBYUzVzWlc1bmRHZ2dQU0F3WEc0Z0lDQWdVRTlQVEM1VlNVNVVNVFpiYVYwdWJHVnVaM1JvSUQwZ01GeHVJQ0FnSUZCUFQwd3VWVWxPVkRNeVcybGRMbXhsYm1kMGFDQTlJREJjYmlBZ0lDQlFUMDlNTGtsT1ZEaGJhVjB1YkdWdVozUm9JRDBnTUZ4dUlDQWdJRkJQVDB3dVNVNVVNVFpiYVYwdWJHVnVaM1JvSUQwZ01GeHVJQ0FnSUZCUFQwd3VTVTVVTXpKYmFWMHViR1Z1WjNSb0lEMGdNRnh1SUNBZ0lGQlBUMHd1Umt4UFFWUmJhVjB1YkdWdVozUm9JRDBnTUZ4dUlDQWdJRkJQVDB3dVJFOVZRa3hGVzJsZExteGxibWQwYUNBOUlEQmNiaUFnSUNCUVQwOU1MbFZKVGxRNFExdHBYUzVzWlc1bmRHZ2dQU0F3WEc0Z0lDQWdSRUZVUVZ0cFhTNXNaVzVuZEdnZ1BTQXdYRzRnSUNBZ1FsVkdSa1ZTVzJsZExteGxibWQwYUNBOUlEQmNiaUFnZlZ4dWZTSmRmUT09IiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzLWFycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIGtNYXhMZW5ndGggPSAweDNmZmZmZmZmXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIE5vdGU6XG4gKlxuICogLSBJbXBsZW1lbnRhdGlvbiBtdXN0IHN1cHBvcnQgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMuXG4gKiAgIEZpcmVmb3ggNC0yOSBsYWNrZWQgc3VwcG9ydCwgZml4ZWQgaW4gRmlyZWZveCAzMCsuXG4gKiAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG4gKlxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXkgd2lsbFxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgd2lsbCB3b3JrIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoMSkuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gc3ViamVjdCA+IDAgPyBzdWJqZWN0ID4+PiAwIDogMFxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpXG4gICAgICBzdWJqZWN0ID0gYmFzZTY0Y2xlYW4oc3ViamVjdClcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiBzdWJqZWN0ICE9PSBudWxsKSB7IC8vIGFzc3VtZSBvYmplY3QgaXMgYXJyYXktbGlrZVxuICAgIGlmIChzdWJqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkoc3ViamVjdC5kYXRhKSlcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0LmRhdGFcbiAgICBsZW5ndGggPSArc3ViamVjdC5sZW5ndGggPiAwID8gTWF0aC5mbG9vcigrc3ViamVjdC5sZW5ndGgpIDogMFxuICB9IGVsc2VcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG5cbiAgaWYgKHRoaXMubGVuZ3RoID4ga01heExlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYnVmW2ldID0gKChzdWJqZWN0W2ldICUgMjU2KSArIDI1NikgJSAyNTZcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuICYmIGFbaV0gPT09IGJbaV07IGkrKykge31cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdFssIGxlbmd0aF0pJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0b3RhbExlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ciArICcnXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoID4+PiAxXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGIpIHtcbiAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpXG4gICAgICBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgMilcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuO1xuICAgIGlmIChzdGFydCA8IDApXG4gICAgICBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMClcbiAgICAgIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydClcbiAgICBlbmQgPSBzdGFydFxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpXG4gICAgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGlmICh0YXJnZXRfc3RhcnQgPCAwIHx8IHRhcmdldF9zdGFydCA+PSB0YXJnZXQubGVuZ3RoKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHNvdXJjZS5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLXpdL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKSB7XG4gICAgICBieXRlQXJyYXkucHVzaChiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgsIHVuaXRTaXplKSB7XG4gIGlmICh1bml0U2l6ZSkgbGVuZ3RoIC09IGxlbmd0aCAlIHVuaXRTaXplO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIlxuLyoqXG4gKiBpc0FycmF5XG4gKi9cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIHRvU3RyaW5nXG4gKi9cblxudmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIGdpdmVuIGB2YWxgXG4gKiBpcyBhbiBhcnJheS5cbiAqXG4gKiBleGFtcGxlOlxuICpcbiAqICAgICAgICBpc0FycmF5KFtdKTtcbiAqICAgICAgICAvLyA+IHRydWVcbiAqICAgICAgICBpc0FycmF5KGFyZ3VtZW50cyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICogICAgICAgIGlzQXJyYXkoJycpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge21peGVkfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5IHx8IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuICEhIHZhbCAmJiAnW29iamVjdCBBcnJheV0nID09IHN0ci5jYWxsKHZhbCk7XG59O1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5NdXRhdGlvbk9ic2VydmVyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcjtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICB2YXIgcXVldWUgPSBbXTtcblxuICAgIGlmIChjYW5NdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgIHZhciBoaWRkZW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcXVldWVMaXN0ID0gcXVldWUuc2xpY2UoKTtcbiAgICAgICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBxdWV1ZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoaGlkZGVuRGl2LCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBpZiAoIXF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGhpZGRlbkRpdi5zZXRBdHRyaWJ1dGUoJ3llcycsICdubycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5MWRHbHNMM1YwYVd3dWFuTWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRWlMQ0ptYVd4bElqb2laMlZ1WlhKaGRHVmtMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWk4dklFTnZjSGx5YVdkb2RDQktiM2xsYm5Rc0lFbHVZeTRnWVc1a0lHOTBhR1Z5SUU1dlpHVWdZMjl1ZEhKcFluVjBiM0p6TGx4dUx5OWNiaTh2SUZCbGNtMXBjM05wYjI0Z2FYTWdhR1Z5WldKNUlHZHlZVzUwWldRc0lHWnlaV1VnYjJZZ1kyaGhjbWRsTENCMGJ5QmhibmtnY0dWeWMyOXVJRzlpZEdGcGJtbHVaeUJoWEc0dkx5QmpiM0I1SUc5bUlIUm9hWE1nYzI5bWRIZGhjbVVnWVc1a0lHRnpjMjlqYVdGMFpXUWdaRzlqZFcxbGJuUmhkR2x2YmlCbWFXeGxjeUFvZEdobFhHNHZMeUJjSWxOdlpuUjNZWEpsWENJcExDQjBieUJrWldGc0lHbHVJSFJvWlNCVGIyWjBkMkZ5WlNCM2FYUm9iM1YwSUhKbGMzUnlhV04wYVc5dUxDQnBibU5zZFdScGJtZGNiaTh2SUhkcGRHaHZkWFFnYkdsdGFYUmhkR2x2YmlCMGFHVWdjbWxuYUhSeklIUnZJSFZ6WlN3Z1kyOXdlU3dnYlc5a2FXWjVMQ0J0WlhKblpTd2djSFZpYkdsemFDeGNiaTh2SUdScGMzUnlhV0oxZEdVc0lITjFZbXhwWTJWdWMyVXNJR0Z1WkM5dmNpQnpaV3hzSUdOdmNHbGxjeUJ2WmlCMGFHVWdVMjltZEhkaGNtVXNJR0Z1WkNCMGJ5QndaWEp0YVhSY2JpOHZJSEJsY25OdmJuTWdkRzhnZDJodmJTQjBhR1VnVTI5bWRIZGhjbVVnYVhNZ1puVnlibWx6YUdWa0lIUnZJR1J2SUhOdkxDQnpkV0pxWldOMElIUnZJSFJvWlZ4dUx5OGdabTlzYkc5M2FXNW5JR052Ym1ScGRHbHZibk02WEc0dkwxeHVMeThnVkdobElHRmliM1psSUdOdmNIbHlhV2RvZENCdWIzUnBZMlVnWVc1a0lIUm9hWE1nY0dWeWJXbHpjMmx2YmlCdWIzUnBZMlVnYzJoaGJHd2dZbVVnYVc1amJIVmtaV1JjYmk4dklHbHVJR0ZzYkNCamIzQnBaWE1nYjNJZ2MzVmljM1JoYm5ScFlXd2djRzl5ZEdsdmJuTWdiMllnZEdobElGTnZablIzWVhKbExseHVMeTljYmk4dklGUklSU0JUVDBaVVYwRlNSU0JKVXlCUVVrOVdTVVJGUkNCY0lrRlRJRWxUWENJc0lGZEpWRWhQVlZRZ1YwRlNVa0ZPVkZrZ1QwWWdRVTVaSUV0SlRrUXNJRVZZVUZKRlUxTmNiaTh2SUU5U0lFbE5VRXhKUlVRc0lFbE9RMHhWUkVsT1J5QkNWVlFnVGs5VUlFeEpUVWxVUlVRZ1ZFOGdWRWhGSUZkQlVsSkJUbFJKUlZNZ1QwWmNiaTh2SUUxRlVrTklRVTVVUVVKSlRFbFVXU3dnUmtsVVRrVlRVeUJHVDFJZ1FTQlFRVkpVU1VOVlRFRlNJRkJWVWxCUFUwVWdRVTVFSUU1UFRrbE9SbEpKVGtkRlRVVk9WQzRnU1U1Y2JpOHZJRTVQSUVWV1JVNVVJRk5JUVV4TUlGUklSU0JCVlZSSVQxSlRJRTlTSUVOUFVGbFNTVWRJVkNCSVQweEVSVkpUSUVKRklFeEpRVUpNUlNCR1QxSWdRVTVaSUVOTVFVbE5MRnh1THk4Z1JFRk5RVWRGVXlCUFVpQlBWRWhGVWlCTVNVRkNTVXhKVkZrc0lGZElSVlJJUlZJZ1NVNGdRVTRnUVVOVVNVOU9JRTlHSUVOUFRsUlNRVU5VTENCVVQxSlVJRTlTWEc0dkx5QlBWRWhGVWxkSlUwVXNJRUZTU1ZOSlRrY2dSbEpQVFN3Z1QxVlVJRTlHSUU5U0lFbE9JRU5QVGs1RlExUkpUMDRnVjBsVVNDQlVTRVVnVTA5R1ZGZEJVa1VnVDFJZ1ZFaEZYRzR2THlCVlUwVWdUMUlnVDFSSVJWSWdSRVZCVEVsT1IxTWdTVTRnVkVoRklGTlBSbFJYUVZKRkxseHVYRzUyWVhJZ1ptOXliV0YwVW1WblJYaHdJRDBnTHlWYmMyUnFKVjB2Wnp0Y2JtVjRjRzl5ZEhNdVptOXliV0YwSUQwZ1puVnVZM1JwYjI0b1ppa2dlMXh1SUNCcFppQW9JV2x6VTNSeWFXNW5LR1lwS1NCN1hHNGdJQ0FnZG1GeUlHOWlhbVZqZEhNZ1BTQmJYVHRjYmlBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR0Z5WjNWdFpXNTBjeTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ2IySnFaV04wY3k1d2RYTm9LR2x1YzNCbFkzUW9ZWEpuZFcxbGJuUnpXMmxkS1NrN1hHNGdJQ0FnZlZ4dUlDQWdJSEpsZEhWeWJpQnZZbXBsWTNSekxtcHZhVzRvSnlBbktUdGNiaUFnZlZ4dVhHNGdJSFpoY2lCcElEMGdNVHRjYmlBZ2RtRnlJR0Z5WjNNZ1BTQmhjbWQxYldWdWRITTdYRzRnSUhaaGNpQnNaVzRnUFNCaGNtZHpMbXhsYm1kMGFEdGNiaUFnZG1GeUlITjBjaUE5SUZOMGNtbHVaeWhtS1M1eVpYQnNZV05sS0dadmNtMWhkRkpsWjBWNGNDd2dablZ1WTNScGIyNG9lQ2tnZTF4dUlDQWdJR2xtSUNoNElEMDlQU0FuSlNVbktTQnlaWFIxY200Z0p5VW5PMXh1SUNBZ0lHbG1JQ2hwSUQ0OUlHeGxiaWtnY21WMGRYSnVJSGc3WEc0Z0lDQWdjM2RwZEdOb0lDaDRLU0I3WEc0Z0lDQWdJQ0JqWVhObElDY2xjeWM2SUhKbGRIVnliaUJUZEhKcGJtY29ZWEpuYzF0cEt5dGRLVHRjYmlBZ0lDQWdJR05oYzJVZ0p5VmtKem9nY21WMGRYSnVJRTUxYldKbGNpaGhjbWR6VzJrcksxMHBPMXh1SUNBZ0lDQWdZMkZ6WlNBbkpXb25PbHh1SUNBZ0lDQWdJQ0IwY25rZ2UxeHVJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQktVMDlPTG5OMGNtbHVaMmxtZVNoaGNtZHpXMmtySzEwcE8xeHVJQ0FnSUNBZ0lDQjlJR05oZEdOb0lDaGZLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUNkYlEybHlZM1ZzWVhKZEp6dGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdaR1ZtWVhWc2REcGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIZzdYRzRnSUNBZ2ZWeHVJQ0I5S1R0Y2JpQWdabTl5SUNoMllYSWdlQ0E5SUdGeVozTmJhVjA3SUdrZ1BDQnNaVzQ3SUhnZ1BTQmhjbWR6V3lzcmFWMHBJSHRjYmlBZ0lDQnBaaUFvYVhOT2RXeHNLSGdwSUh4OElDRnBjMDlpYW1WamRDaDRLU2tnZTF4dUlDQWdJQ0FnYzNSeUlDczlJQ2NnSnlBcklIZzdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUhOMGNpQXJQU0FuSUNjZ0t5QnBibk53WldOMEtIZ3BPMXh1SUNBZ0lIMWNiaUFnZlZ4dUlDQnlaWFIxY200Z2MzUnlPMXh1ZlR0Y2JseHVYRzR2THlCTllYSnJJSFJvWVhRZ1lTQnRaWFJvYjJRZ2MyaHZkV3hrSUc1dmRDQmlaU0IxYzJWa0xseHVMeThnVW1WMGRYSnVjeUJoSUcxdlpHbG1hV1ZrSUdaMWJtTjBhVzl1SUhkb2FXTm9JSGRoY201eklHOXVZMlVnWW5rZ1pHVm1ZWFZzZEM1Y2JpOHZJRWxtSUMwdGJtOHRaR1Z3Y21WallYUnBiMjRnYVhNZ2MyVjBMQ0IwYUdWdUlHbDBJR2x6SUdFZ2JtOHRiM0F1WEc1bGVIQnZjblJ6TG1SbGNISmxZMkYwWlNBOUlHWjFibU4wYVc5dUtHWnVMQ0J0YzJjcElIdGNiaUFnTHk4Z1FXeHNiM2NnWm05eUlHUmxjSEpsWTJGMGFXNW5JSFJvYVc1bmN5QnBiaUIwYUdVZ2NISnZZMlZ6Y3lCdlppQnpkR0Z5ZEdsdVp5QjFjQzVjYmlBZ2FXWWdLR2x6Vlc1a1pXWnBibVZrS0dkc2IySmhiQzV3Y205alpYTnpLU2tnZTF4dUlDQWdJSEpsZEhWeWJpQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQmxlSEJ2Y25SekxtUmxjSEpsWTJGMFpTaG1iaXdnYlhObktTNWhjSEJzZVNoMGFHbHpMQ0JoY21kMWJXVnVkSE1wTzF4dUlDQWdJSDA3WEc0Z0lIMWNibHh1SUNCcFppQW9jSEp2WTJWemN5NXViMFJsY0hKbFkyRjBhVzl1SUQwOVBTQjBjblZsS1NCN1hHNGdJQ0FnY21WMGRYSnVJR1p1TzF4dUlDQjlYRzVjYmlBZ2RtRnlJSGRoY201bFpDQTlJR1poYkhObE8xeHVJQ0JtZFc1amRHbHZiaUJrWlhCeVpXTmhkR1ZrS0NrZ2UxeHVJQ0FnSUdsbUlDZ2hkMkZ5Ym1Wa0tTQjdYRzRnSUNBZ0lDQnBaaUFvY0hKdlkyVnpjeTUwYUhKdmQwUmxjSEpsWTJGMGFXOXVLU0I3WEc0Z0lDQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWh0YzJjcE8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaHdjbTlqWlhOekxuUnlZV05sUkdWd2NtVmpZWFJwYjI0cElIdGNiaUFnSUNBZ0lDQWdZMjl1YzI5c1pTNTBjbUZqWlNodGMyY3BPMXh1SUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdZMjl1YzI5c1pTNWxjbkp2Y2lodGMyY3BPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdkMkZ5Ym1Wa0lEMGdkSEoxWlR0Y2JpQWdJQ0I5WEc0Z0lDQWdjbVYwZFhKdUlHWnVMbUZ3Y0d4NUtIUm9hWE1zSUdGeVozVnRaVzUwY3lrN1hHNGdJSDFjYmx4dUlDQnlaWFIxY200Z1pHVndjbVZqWVhSbFpEdGNibjA3WEc1Y2JseHVkbUZ5SUdSbFluVm5jeUE5SUh0OU8xeHVkbUZ5SUdSbFluVm5SVzUyYVhKdmJqdGNibVY0Y0c5eWRITXVaR1ZpZFdkc2IyY2dQU0JtZFc1amRHbHZiaWh6WlhRcElIdGNiaUFnYVdZZ0tHbHpWVzVrWldacGJtVmtLR1JsWW5WblJXNTJhWEp2YmlrcFhHNGdJQ0FnWkdWaWRXZEZiblpwY205dUlEMGdjSEp2WTJWemN5NWxibll1VGs5RVJWOUVSVUpWUnlCOGZDQW5KenRjYmlBZ2MyVjBJRDBnYzJWMExuUnZWWEJ3WlhKRFlYTmxLQ2s3WEc0Z0lHbG1JQ2doWkdWaWRXZHpXM05sZEYwcElIdGNiaUFnSUNCcFppQW9ibVYzSUZKbFowVjRjQ2duWEZ4Y1hHSW5JQ3NnYzJWMElDc2dKMXhjWEZ4aUp5d2dKMmtuS1M1MFpYTjBLR1JsWW5WblJXNTJhWEp2YmlrcElIdGNiaUFnSUNBZ0lIWmhjaUJ3YVdRZ1BTQndjbTlqWlhOekxuQnBaRHRjYmlBZ0lDQWdJR1JsWW5WbmMxdHpaWFJkSUQwZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCdGMyY2dQU0JsZUhCdmNuUnpMbVp2Y20xaGRDNWhjSEJzZVNobGVIQnZjblJ6TENCaGNtZDFiV1Z1ZEhNcE8xeHVJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExtVnljbTl5S0NjbGN5QWxaRG9nSlhNbkxDQnpaWFFzSUhCcFpDd2diWE5uS1R0Y2JpQWdJQ0FnSUgwN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJR1JsWW5WbmMxdHpaWFJkSUQwZ1puVnVZM1JwYjI0b0tTQjdmVHRjYmlBZ0lDQjlYRzRnSUgxY2JpQWdjbVYwZFhKdUlHUmxZblZuYzF0elpYUmRPMXh1ZlR0Y2JseHVYRzR2S2lwY2JpQXFJRVZqYUc5eklIUm9aU0IyWVd4MVpTQnZaaUJoSUhaaGJIVmxMaUJVY25seklIUnZJSEJ5YVc1MElIUm9aU0IyWVd4MVpTQnZkWFJjYmlBcUlHbHVJSFJvWlNCaVpYTjBJSGRoZVNCd2IzTnphV0pzWlNCbmFYWmxiaUIwYUdVZ1pHbG1abVZ5Wlc1MElIUjVjR1Z6TGx4dUlDcGNiaUFxSUVCd1lYSmhiU0I3VDJKcVpXTjBmU0J2WW1vZ1ZHaGxJRzlpYW1WamRDQjBieUJ3Y21sdWRDQnZkWFF1WEc0Z0tpQkFjR0Z5WVcwZ2UwOWlhbVZqZEgwZ2IzQjBjeUJQY0hScGIyNWhiQ0J2Y0hScGIyNXpJRzlpYW1WamRDQjBhR0YwSUdGc2RHVnljeUIwYUdVZ2IzVjBjSFYwTGx4dUlDb3ZYRzR2S2lCc1pXZGhZM2s2SUc5aWFpd2djMmh2ZDBocFpHUmxiaXdnWkdWd2RHZ3NJR052Ykc5eWN5b3ZYRzVtZFc1amRHbHZiaUJwYm5Od1pXTjBLRzlpYWl3Z2IzQjBjeWtnZTF4dUlDQXZMeUJrWldaaGRXeDBJRzl3ZEdsdmJuTmNiaUFnZG1GeUlHTjBlQ0E5SUh0Y2JpQWdJQ0J6WldWdU9pQmJYU3hjYmlBZ0lDQnpkSGxzYVhwbE9pQnpkSGxzYVhwbFRtOURiMnh2Y2x4dUlDQjlPMXh1SUNBdkx5QnNaV2RoWTNrdUxpNWNiaUFnYVdZZ0tHRnlaM1Z0Wlc1MGN5NXNaVzVuZEdnZ1BqMGdNeWtnWTNSNExtUmxjSFJvSUQwZ1lYSm5kVzFsYm5Seld6SmRPMXh1SUNCcFppQW9ZWEpuZFcxbGJuUnpMbXhsYm1kMGFDQStQU0EwS1NCamRIZ3VZMjlzYjNKeklEMGdZWEpuZFcxbGJuUnpXek5kTzF4dUlDQnBaaUFvYVhOQ2IyOXNaV0Z1S0c5d2RITXBLU0I3WEc0Z0lDQWdMeThnYkdWbllXTjVMaTR1WEc0Z0lDQWdZM1I0TG5Ob2IzZElhV1JrWlc0Z1BTQnZjSFJ6TzF4dUlDQjlJR1ZzYzJVZ2FXWWdLRzl3ZEhNcElIdGNiaUFnSUNBdkx5Qm5iM1FnWVc0Z1hDSnZjSFJwYjI1elhDSWdiMkpxWldOMFhHNGdJQ0FnWlhod2IzSjBjeTVmWlhoMFpXNWtLR04wZUN3Z2IzQjBjeWs3WEc0Z0lIMWNiaUFnTHk4Z2MyVjBJR1JsWm1GMWJIUWdiM0IwYVc5dWMxeHVJQ0JwWmlBb2FYTlZibVJsWm1sdVpXUW9ZM1I0TG5Ob2IzZElhV1JrWlc0cEtTQmpkSGd1YzJodmQwaHBaR1JsYmlBOUlHWmhiSE5sTzF4dUlDQnBaaUFvYVhOVmJtUmxabWx1WldRb1kzUjRMbVJsY0hSb0tTa2dZM1I0TG1SbGNIUm9JRDBnTWp0Y2JpQWdhV1lnS0dselZXNWtaV1pwYm1Wa0tHTjBlQzVqYjJ4dmNuTXBLU0JqZEhndVkyOXNiM0p6SUQwZ1ptRnNjMlU3WEc0Z0lHbG1JQ2hwYzFWdVpHVm1hVzVsWkNoamRIZ3VZM1Z6ZEc5dFNXNXpjR1ZqZENrcElHTjBlQzVqZFhOMGIyMUpibk53WldOMElEMGdkSEoxWlR0Y2JpQWdhV1lnS0dOMGVDNWpiMnh2Y25NcElHTjBlQzV6ZEhsc2FYcGxJRDBnYzNSNWJHbDZaVmRwZEdoRGIyeHZjanRjYmlBZ2NtVjBkWEp1SUdadmNtMWhkRlpoYkhWbEtHTjBlQ3dnYjJKcUxDQmpkSGd1WkdWd2RHZ3BPMXh1ZlZ4dVpYaHdiM0owY3k1cGJuTndaV04wSUQwZ2FXNXpjR1ZqZER0Y2JseHVYRzR2THlCb2RIUndPaTh2Wlc0dWQybHJhWEJsWkdsaExtOXlaeTkzYVd0cEwwRk9VMGxmWlhOallYQmxYMk52WkdValozSmhjR2hwWTNOY2JtbHVjM0JsWTNRdVkyOXNiM0p6SUQwZ2UxeHVJQ0FuWW05c1pDY2dPaUJiTVN3Z01qSmRMRnh1SUNBbmFYUmhiR2xqSnlBNklGc3pMQ0F5TTEwc1hHNGdJQ2QxYm1SbGNteHBibVVuSURvZ1d6UXNJREkwWFN4Y2JpQWdKMmx1ZG1WeWMyVW5JRG9nV3pjc0lESTNYU3hjYmlBZ0ozZG9hWFJsSnlBNklGc3pOeXdnTXpsZExGeHVJQ0FuWjNKbGVTY2dPaUJiT1RBc0lETTVYU3hjYmlBZ0oySnNZV05ySnlBNklGc3pNQ3dnTXpsZExGeHVJQ0FuWW14MVpTY2dPaUJiTXpRc0lETTVYU3hjYmlBZ0oyTjVZVzRuSURvZ1d6TTJMQ0F6T1Ywc1hHNGdJQ2RuY21WbGJpY2dPaUJiTXpJc0lETTVYU3hjYmlBZ0oyMWhaMlZ1ZEdFbklEb2dXek0xTENBek9WMHNYRzRnSUNkeVpXUW5JRG9nV3pNeExDQXpPVjBzWEc0Z0lDZDVaV3hzYjNjbklEb2dXek16TENBek9WMWNibjA3WEc1Y2JpOHZJRVJ2YmlkMElIVnpaU0FuWW14MVpTY2dibTkwSUhacGMybGliR1VnYjI0Z1kyMWtMbVY0WlZ4dWFXNXpjR1ZqZEM1emRIbHNaWE1nUFNCN1hHNGdJQ2R6Y0dWamFXRnNKem9nSjJONVlXNG5MRnh1SUNBbmJuVnRZbVZ5SnpvZ0ozbGxiR3h2ZHljc1hHNGdJQ2RpYjI5c1pXRnVKem9nSjNsbGJHeHZkeWNzWEc0Z0lDZDFibVJsWm1sdVpXUW5PaUFuWjNKbGVTY3NYRzRnSUNkdWRXeHNKem9nSjJKdmJHUW5MRnh1SUNBbmMzUnlhVzVuSnpvZ0oyZHlaV1Z1Snl4Y2JpQWdKMlJoZEdVbk9pQW5iV0ZuWlc1MFlTY3NYRzRnSUM4dklGd2libUZ0WlZ3aU9pQnBiblJsYm5ScGIyNWhiR3g1SUc1dmRDQnpkSGxzYVc1blhHNGdJQ2R5WldkbGVIQW5PaUFuY21Wa0oxeHVmVHRjYmx4dVhHNW1kVzVqZEdsdmJpQnpkSGxzYVhwbFYybDBhRU52Ykc5eUtITjBjaXdnYzNSNWJHVlVlWEJsS1NCN1hHNGdJSFpoY2lCemRIbHNaU0E5SUdsdWMzQmxZM1F1YzNSNWJHVnpXM04wZVd4bFZIbHdaVjA3WEc1Y2JpQWdhV1lnS0hOMGVXeGxLU0I3WEc0Z0lDQWdjbVYwZFhKdUlDZGNYSFV3TURGaVd5Y2dLeUJwYm5Od1pXTjBMbU52Ykc5eWMxdHpkSGxzWlYxYk1GMGdLeUFuYlNjZ0t5QnpkSElnSzF4dUlDQWdJQ0FnSUNBZ0lDQW5YRngxTURBeFlsc25JQ3NnYVc1emNHVmpkQzVqYjJ4dmNuTmJjM1I1YkdWZFd6RmRJQ3NnSjIwbk8xeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lISmxkSFZ5YmlCemRISTdYRzRnSUgxY2JuMWNibHh1WEc1bWRXNWpkR2x2YmlCemRIbHNhWHBsVG05RGIyeHZjaWh6ZEhJc0lITjBlV3hsVkhsd1pTa2dlMXh1SUNCeVpYUjFjbTRnYzNSeU8xeHVmVnh1WEc1Y2JtWjFibU4wYVc5dUlHRnljbUY1Vkc5SVlYTm9LR0Z5Y21GNUtTQjdYRzRnSUhaaGNpQm9ZWE5vSUQwZ2UzMDdYRzVjYmlBZ1lYSnlZWGt1Wm05eVJXRmphQ2htZFc1amRHbHZiaWgyWVd3c0lHbGtlQ2tnZTF4dUlDQWdJR2hoYzJoYmRtRnNYU0E5SUhSeWRXVTdYRzRnSUgwcE8xeHVYRzRnSUhKbGRIVnliaUJvWVhOb08xeHVmVnh1WEc1Y2JtWjFibU4wYVc5dUlHWnZjbTFoZEZaaGJIVmxLR04wZUN3Z2RtRnNkV1VzSUhKbFkzVnljMlZVYVcxbGN5a2dlMXh1SUNBdkx5QlFjbTkyYVdSbElHRWdhRzl2YXlCbWIzSWdkWE5sY2kxemNHVmphV1pwWldRZ2FXNXpjR1ZqZENCbWRXNWpkR2x2Ym5NdVhHNGdJQzh2SUVOb1pXTnJJSFJvWVhRZ2RtRnNkV1VnYVhNZ1lXNGdiMkpxWldOMElIZHBkR2dnWVc0Z2FXNXpjR1ZqZENCbWRXNWpkR2x2YmlCdmJpQnBkRnh1SUNCcFppQW9ZM1I0TG1OMWMzUnZiVWx1YzNCbFkzUWdKaVpjYmlBZ0lDQWdJSFpoYkhWbElDWW1YRzRnSUNBZ0lDQnBjMFoxYm1OMGFXOXVLSFpoYkhWbExtbHVjM0JsWTNRcElDWW1YRzRnSUNBZ0lDQXZMeUJHYVd4MFpYSWdiM1YwSUhSb1pTQjFkR2xzSUcxdlpIVnNaU3dnYVhRbmN5QnBibk53WldOMElHWjFibU4wYVc5dUlHbHpJSE53WldOcFlXeGNiaUFnSUNBZ0lIWmhiSFZsTG1sdWMzQmxZM1FnSVQwOUlHVjRjRzl5ZEhNdWFXNXpjR1ZqZENBbUpseHVJQ0FnSUNBZ0x5OGdRV3h6YnlCbWFXeDBaWElnYjNWMElHRnVlU0J3Y205MGIzUjVjR1VnYjJKcVpXTjBjeUIxYzJsdVp5QjBhR1VnWTJseVkzVnNZWElnWTJobFkyc3VYRzRnSUNBZ0lDQWhLSFpoYkhWbExtTnZibk4wY25WamRHOXlJQ1ltSUhaaGJIVmxMbU52Ym5OMGNuVmpkRzl5TG5CeWIzUnZkSGx3WlNBOVBUMGdkbUZzZFdVcEtTQjdYRzRnSUNBZ2RtRnlJSEpsZENBOUlIWmhiSFZsTG1sdWMzQmxZM1FvY21WamRYSnpaVlJwYldWekxDQmpkSGdwTzF4dUlDQWdJR2xtSUNnaGFYTlRkSEpwYm1jb2NtVjBLU2tnZTF4dUlDQWdJQ0FnY21WMElEMGdabTl5YldGMFZtRnNkV1VvWTNSNExDQnlaWFFzSUhKbFkzVnljMlZVYVcxbGN5azdYRzRnSUNBZ2ZWeHVJQ0FnSUhKbGRIVnliaUJ5WlhRN1hHNGdJSDFjYmx4dUlDQXZMeUJRY21sdGFYUnBkbVVnZEhsd1pYTWdZMkZ1Ym05MElHaGhkbVVnY0hKdmNHVnlkR2xsYzF4dUlDQjJZWElnY0hKcGJXbDBhWFpsSUQwZ1ptOXliV0YwVUhKcGJXbDBhWFpsS0dOMGVDd2dkbUZzZFdVcE8xeHVJQ0JwWmlBb2NISnBiV2wwYVhabEtTQjdYRzRnSUNBZ2NtVjBkWEp1SUhCeWFXMXBkR2wyWlR0Y2JpQWdmVnh1WEc0Z0lDOHZJRXh2YjJzZ2RYQWdkR2hsSUd0bGVYTWdiMllnZEdobElHOWlhbVZqZEM1Y2JpQWdkbUZ5SUd0bGVYTWdQU0JQWW1wbFkzUXVhMlY1Y3loMllXeDFaU2s3WEc0Z0lIWmhjaUIyYVhOcFlteGxTMlY1Y3lBOUlHRnljbUY1Vkc5SVlYTm9LR3RsZVhNcE8xeHVYRzRnSUdsbUlDaGpkSGd1YzJodmQwaHBaR1JsYmlrZ2UxeHVJQ0FnSUd0bGVYTWdQU0JQWW1wbFkzUXVaMlYwVDNkdVVISnZjR1Z5ZEhsT1lXMWxjeWgyWVd4MVpTazdYRzRnSUgxY2JseHVJQ0F2THlCSlJTQmtiMlZ6YmlkMElHMWhhMlVnWlhKeWIzSWdabWxsYkdSeklHNXZiaTFsYm5WdFpYSmhZbXhsWEc0Z0lDOHZJR2gwZEhBNkx5OXRjMlJ1TG0xcFkzSnZjMjltZEM1amIyMHZaVzR0ZFhNdmJHbGljbUZ5ZVM5cFpTOWtkM2MxTW5OaWRDaDJQWFp6TGprMEtTNWhjM0I0WEc0Z0lHbG1JQ2hwYzBWeWNtOXlLSFpoYkhWbEtWeHVJQ0FnSUNBZ0ppWWdLR3RsZVhNdWFXNWtaWGhQWmlnbmJXVnpjMkZuWlNjcElENDlJREFnZkh3Z2EyVjVjeTVwYm1SbGVFOW1LQ2RrWlhOamNtbHdkR2x2YmljcElENDlJREFwS1NCN1hHNGdJQ0FnY21WMGRYSnVJR1p2Y20xaGRFVnljbTl5S0haaGJIVmxLVHRjYmlBZ2ZWeHVYRzRnSUM4dklGTnZiV1VnZEhsd1pTQnZaaUJ2WW1wbFkzUWdkMmwwYUc5MWRDQndjbTl3WlhKMGFXVnpJR05oYmlCaVpTQnphRzl5ZEdOMWRIUmxaQzVjYmlBZ2FXWWdLR3RsZVhNdWJHVnVaM1JvSUQwOVBTQXdLU0I3WEc0Z0lDQWdhV1lnS0dselJuVnVZM1JwYjI0b2RtRnNkV1VwS1NCN1hHNGdJQ0FnSUNCMllYSWdibUZ0WlNBOUlIWmhiSFZsTG01aGJXVWdQeUFuT2lBbklDc2dkbUZzZFdVdWJtRnRaU0E2SUNjbk8xeHVJQ0FnSUNBZ2NtVjBkWEp1SUdOMGVDNXpkSGxzYVhwbEtDZGJSblZ1WTNScGIyNG5JQ3NnYm1GdFpTQXJJQ2RkSnl3Z0ozTndaV05wWVd3bktUdGNiaUFnSUNCOVhHNGdJQ0FnYVdZZ0tHbHpVbVZuUlhod0tIWmhiSFZsS1NrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUdOMGVDNXpkSGxzYVhwbEtGSmxaMFY0Y0M1d2NtOTBiM1I1Y0dVdWRHOVRkSEpwYm1jdVkyRnNiQ2gyWVd4MVpTa3NJQ2R5WldkbGVIQW5LVHRjYmlBZ0lDQjlYRzRnSUNBZ2FXWWdLR2x6UkdGMFpTaDJZV3gxWlNrcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCamRIZ3VjM1I1YkdsNlpTaEVZWFJsTG5CeWIzUnZkSGx3WlM1MGIxTjBjbWx1Wnk1allXeHNLSFpoYkhWbEtTd2dKMlJoZEdVbktUdGNiaUFnSUNCOVhHNGdJQ0FnYVdZZ0tHbHpSWEp5YjNJb2RtRnNkV1VwS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnWm05eWJXRjBSWEp5YjNJb2RtRnNkV1VwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUhaaGNpQmlZWE5sSUQwZ0p5Y3NJR0Z5Y21GNUlEMGdabUZzYzJVc0lHSnlZV05sY3lBOUlGc25leWNzSUNkOUoxMDdYRzVjYmlBZ0x5OGdUV0ZyWlNCQmNuSmhlU0J6WVhrZ2RHaGhkQ0IwYUdWNUlHRnlaU0JCY25KaGVWeHVJQ0JwWmlBb2FYTkJjbkpoZVNoMllXeDFaU2twSUh0Y2JpQWdJQ0JoY25KaGVTQTlJSFJ5ZFdVN1hHNGdJQ0FnWW5KaFkyVnpJRDBnV3lkYkp5d2dKMTBuWFR0Y2JpQWdmVnh1WEc0Z0lDOHZJRTFoYTJVZ1puVnVZM1JwYjI1eklITmhlU0IwYUdGMElIUm9aWGtnWVhKbElHWjFibU4wYVc5dWMxeHVJQ0JwWmlBb2FYTkdkVzVqZEdsdmJpaDJZV3gxWlNrcElIdGNiaUFnSUNCMllYSWdiaUE5SUhaaGJIVmxMbTVoYldVZ1B5QW5PaUFuSUNzZ2RtRnNkV1V1Ym1GdFpTQTZJQ2NuTzF4dUlDQWdJR0poYzJVZ1BTQW5JRnRHZFc1amRHbHZiaWNnS3lCdUlDc2dKMTBuTzF4dUlDQjlYRzVjYmlBZ0x5OGdUV0ZyWlNCU1pXZEZlSEJ6SUhOaGVTQjBhR0YwSUhSb1pYa2dZWEpsSUZKbFowVjRjSE5jYmlBZ2FXWWdLR2x6VW1WblJYaHdLSFpoYkhWbEtTa2dlMXh1SUNBZ0lHSmhjMlVnUFNBbklDY2dLeUJTWldkRmVIQXVjSEp2ZEc5MGVYQmxMblJ2VTNSeWFXNW5MbU5oYkd3b2RtRnNkV1VwTzF4dUlDQjlYRzVjYmlBZ0x5OGdUV0ZyWlNCa1lYUmxjeUIzYVhSb0lIQnliM0JsY25ScFpYTWdabWx5YzNRZ2MyRjVJSFJvWlNCa1lYUmxYRzRnSUdsbUlDaHBjMFJoZEdVb2RtRnNkV1VwS1NCN1hHNGdJQ0FnWW1GelpTQTlJQ2NnSnlBcklFUmhkR1V1Y0hKdmRHOTBlWEJsTG5SdlZWUkRVM1J5YVc1bkxtTmhiR3dvZG1Gc2RXVXBPMXh1SUNCOVhHNWNiaUFnTHk4Z1RXRnJaU0JsY25KdmNpQjNhWFJvSUcxbGMzTmhaMlVnWm1seWMzUWdjMkY1SUhSb1pTQmxjbkp2Y2x4dUlDQnBaaUFvYVhORmNuSnZjaWgyWVd4MVpTa3BJSHRjYmlBZ0lDQmlZWE5sSUQwZ0p5QW5JQ3NnWm05eWJXRjBSWEp5YjNJb2RtRnNkV1VwTzF4dUlDQjlYRzVjYmlBZ2FXWWdLR3RsZVhNdWJHVnVaM1JvSUQwOVBTQXdJQ1ltSUNnaFlYSnlZWGtnZkh3Z2RtRnNkV1V1YkdWdVozUm9JRDA5SURBcEtTQjdYRzRnSUNBZ2NtVjBkWEp1SUdKeVlXTmxjMXN3WFNBcklHSmhjMlVnS3lCaWNtRmpaWE5iTVYwN1hHNGdJSDFjYmx4dUlDQnBaaUFvY21WamRYSnpaVlJwYldWeklEd2dNQ2tnZTF4dUlDQWdJR2xtSUNocGMxSmxaMFY0Y0NoMllXeDFaU2twSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJqZEhndWMzUjViR2w2WlNoU1pXZEZlSEF1Y0hKdmRHOTBlWEJsTG5SdlUzUnlhVzVuTG1OaGJHd29kbUZzZFdVcExDQW5jbVZuWlhod0p5azdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJqZEhndWMzUjViR2w2WlNnblcwOWlhbVZqZEYwbkxDQW5jM0JsWTJsaGJDY3BPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJR04wZUM1elpXVnVMbkIxYzJnb2RtRnNkV1VwTzF4dVhHNGdJSFpoY2lCdmRYUndkWFE3WEc0Z0lHbG1JQ2hoY25KaGVTa2dlMXh1SUNBZ0lHOTFkSEIxZENBOUlHWnZjbTFoZEVGeWNtRjVLR04wZUN3Z2RtRnNkV1VzSUhKbFkzVnljMlZVYVcxbGN5d2dkbWx6YVdKc1pVdGxlWE1zSUd0bGVYTXBPMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJRzkxZEhCMWRDQTlJR3RsZVhNdWJXRndLR1oxYm1OMGFXOXVLR3RsZVNrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUdadmNtMWhkRkJ5YjNCbGNuUjVLR04wZUN3Z2RtRnNkV1VzSUhKbFkzVnljMlZVYVcxbGN5d2dkbWx6YVdKc1pVdGxlWE1zSUd0bGVTd2dZWEp5WVhrcE8xeHVJQ0FnSUgwcE8xeHVJQ0I5WEc1Y2JpQWdZM1I0TG5ObFpXNHVjRzl3S0NrN1hHNWNiaUFnY21WMGRYSnVJSEpsWkhWalpWUnZVMmx1WjJ4bFUzUnlhVzVuS0c5MWRIQjFkQ3dnWW1GelpTd2dZbkpoWTJWektUdGNibjFjYmx4dVhHNW1kVzVqZEdsdmJpQm1iM0p0WVhSUWNtbHRhWFJwZG1Vb1kzUjRMQ0IyWVd4MVpTa2dlMXh1SUNCcFppQW9hWE5WYm1SbFptbHVaV1FvZG1Gc2RXVXBLVnh1SUNBZ0lISmxkSFZ5YmlCamRIZ3VjM1I1YkdsNlpTZ25kVzVrWldacGJtVmtKeXdnSjNWdVpHVm1hVzVsWkNjcE8xeHVJQ0JwWmlBb2FYTlRkSEpwYm1jb2RtRnNkV1VwS1NCN1hHNGdJQ0FnZG1GeUlITnBiWEJzWlNBOUlDZGNYQ2NuSUNzZ1NsTlBUaTV6ZEhKcGJtZHBabmtvZG1Gc2RXVXBMbkpsY0d4aFkyVW9MMTVjSW54Y0lpUXZaeXdnSnljcFhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQXVjbVZ3YkdGalpTZ3ZKeTluTENCY0lseGNYRnduWENJcFhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQXVjbVZ3YkdGalpTZ3ZYRnhjWEZ3aUwyY3NJQ2RjSWljcElDc2dKMXhjSnljN1hHNGdJQ0FnY21WMGRYSnVJR04wZUM1emRIbHNhWHBsS0hOcGJYQnNaU3dnSjNOMGNtbHVaeWNwTzF4dUlDQjlYRzRnSUdsbUlDaHBjMDUxYldKbGNpaDJZV3gxWlNrcFhHNGdJQ0FnY21WMGRYSnVJR04wZUM1emRIbHNhWHBsS0NjbklDc2dkbUZzZFdVc0lDZHVkVzFpWlhJbktUdGNiaUFnYVdZZ0tHbHpRbTl2YkdWaGJpaDJZV3gxWlNrcFhHNGdJQ0FnY21WMGRYSnVJR04wZUM1emRIbHNhWHBsS0NjbklDc2dkbUZzZFdVc0lDZGliMjlzWldGdUp5azdYRzRnSUM4dklFWnZjaUJ6YjIxbElISmxZWE52YmlCMGVYQmxiMllnYm5Wc2JDQnBjeUJjSW05aWFtVmpkRndpTENCemJ5QnpjR1ZqYVdGc0lHTmhjMlVnYUdWeVpTNWNiaUFnYVdZZ0tHbHpUblZzYkNoMllXeDFaU2twWEc0Z0lDQWdjbVYwZFhKdUlHTjBlQzV6ZEhsc2FYcGxLQ2R1ZFd4c0p5d2dKMjUxYkd3bktUdGNibjFjYmx4dVhHNW1kVzVqZEdsdmJpQm1iM0p0WVhSRmNuSnZjaWgyWVd4MVpTa2dlMXh1SUNCeVpYUjFjbTRnSjFzbklDc2dSWEp5YjNJdWNISnZkRzkwZVhCbExuUnZVM1J5YVc1bkxtTmhiR3dvZG1Gc2RXVXBJQ3NnSjEwbk8xeHVmVnh1WEc1Y2JtWjFibU4wYVc5dUlHWnZjbTFoZEVGeWNtRjVLR04wZUN3Z2RtRnNkV1VzSUhKbFkzVnljMlZVYVcxbGN5d2dkbWx6YVdKc1pVdGxlWE1zSUd0bGVYTXBJSHRjYmlBZ2RtRnlJRzkxZEhCMWRDQTlJRnRkTzF4dUlDQm1iM0lnS0haaGNpQnBJRDBnTUN3Z2JDQTlJSFpoYkhWbExteGxibWQwYURzZ2FTQThJR3c3SUNzcmFTa2dlMXh1SUNBZ0lHbG1JQ2hvWVhOUGQyNVFjbTl3WlhKMGVTaDJZV3gxWlN3Z1UzUnlhVzVuS0drcEtTa2dlMXh1SUNBZ0lDQWdiM1YwY0hWMExuQjFjMmdvWm05eWJXRjBVSEp2Y0dWeWRIa29ZM1I0TENCMllXeDFaU3dnY21WamRYSnpaVlJwYldWekxDQjJhWE5wWW14bFMyVjVjeXhjYmlBZ0lDQWdJQ0FnSUNCVGRISnBibWNvYVNrc0lIUnlkV1VwS1R0Y2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdiM1YwY0hWMExuQjFjMmdvSnljcE8xeHVJQ0FnSUgxY2JpQWdmVnh1SUNCclpYbHpMbVp2Y2tWaFkyZ29ablZ1WTNScGIyNG9hMlY1S1NCN1hHNGdJQ0FnYVdZZ0tDRnJaWGt1YldGMFkyZ29MMTVjWEdRckpDOHBLU0I3WEc0Z0lDQWdJQ0J2ZFhSd2RYUXVjSFZ6YUNobWIzSnRZWFJRY205d1pYSjBlU2hqZEhnc0lIWmhiSFZsTENCeVpXTjFjbk5sVkdsdFpYTXNJSFpwYzJsaWJHVkxaWGx6TEZ4dUlDQWdJQ0FnSUNBZ0lHdGxlU3dnZEhKMVpTa3BPMXh1SUNBZ0lIMWNiaUFnZlNrN1hHNGdJSEpsZEhWeWJpQnZkWFJ3ZFhRN1hHNTlYRzVjYmx4dVpuVnVZM1JwYjI0Z1ptOXliV0YwVUhKdmNHVnlkSGtvWTNSNExDQjJZV3gxWlN3Z2NtVmpkWEp6WlZScGJXVnpMQ0IyYVhOcFlteGxTMlY1Y3l3Z2EyVjVMQ0JoY25KaGVTa2dlMXh1SUNCMllYSWdibUZ0WlN3Z2MzUnlMQ0JrWlhOak8xeHVJQ0JrWlhOaklEMGdUMkpxWldOMExtZGxkRTkzYmxCeWIzQmxjblI1UkdWelkzSnBjSFJ2Y2loMllXeDFaU3dnYTJWNUtTQjhmQ0I3SUhaaGJIVmxPaUIyWVd4MVpWdHJaWGxkSUgwN1hHNGdJR2xtSUNoa1pYTmpMbWRsZENrZ2UxeHVJQ0FnSUdsbUlDaGtaWE5qTG5ObGRDa2dlMXh1SUNBZ0lDQWdjM1J5SUQwZ1kzUjRMbk4wZVd4cGVtVW9KMXRIWlhSMFpYSXZVMlYwZEdWeVhTY3NJQ2R6Y0dWamFXRnNKeWs3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lITjBjaUE5SUdOMGVDNXpkSGxzYVhwbEtDZGJSMlYwZEdWeVhTY3NJQ2R6Y0dWamFXRnNKeWs3WEc0Z0lDQWdmVnh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJR2xtSUNoa1pYTmpMbk5sZENrZ2UxeHVJQ0FnSUNBZ2MzUnlJRDBnWTNSNExuTjBlV3hwZW1Vb0oxdFRaWFIwWlhKZEp5d2dKM053WldOcFlXd25LVHRjYmlBZ0lDQjlYRzRnSUgxY2JpQWdhV1lnS0NGb1lYTlBkMjVRY205d1pYSjBlU2gyYVhOcFlteGxTMlY1Y3l3Z2EyVjVLU2tnZTF4dUlDQWdJRzVoYldVZ1BTQW5XeWNnS3lCclpYa2dLeUFuWFNjN1hHNGdJSDFjYmlBZ2FXWWdLQ0Z6ZEhJcElIdGNiaUFnSUNCcFppQW9ZM1I0TG5ObFpXNHVhVzVrWlhoUFppaGtaWE5qTG5aaGJIVmxLU0E4SURBcElIdGNiaUFnSUNBZ0lHbG1JQ2hwYzA1MWJHd29jbVZqZFhKelpWUnBiV1Z6S1NrZ2UxeHVJQ0FnSUNBZ0lDQnpkSElnUFNCbWIzSnRZWFJXWVd4MVpTaGpkSGdzSUdSbGMyTXVkbUZzZFdVc0lHNTFiR3dwTzF4dUlDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnYzNSeUlEMGdabTl5YldGMFZtRnNkV1VvWTNSNExDQmtaWE5qTG5aaGJIVmxMQ0J5WldOMWNuTmxWR2x0WlhNZ0xTQXhLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQWdJR2xtSUNoemRISXVhVzVrWlhoUFppZ25YRnh1SnlrZ1BpQXRNU2tnZTF4dUlDQWdJQ0FnSUNCcFppQW9ZWEp5WVhrcElIdGNiaUFnSUNBZ0lDQWdJQ0J6ZEhJZ1BTQnpkSEl1YzNCc2FYUW9KMXhjYmljcExtMWhjQ2htZFc1amRHbHZiaWhzYVc1bEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnSnlBZ0p5QXJJR3hwYm1VN1hHNGdJQ0FnSUNBZ0lDQWdmU2t1YW05cGJpZ25YRnh1SnlrdWMzVmljM1J5S0RJcE8xeHVJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQWdJSE4wY2lBOUlDZGNYRzRuSUNzZ2MzUnlMbk53YkdsMEtDZGNYRzRuS1M1dFlYQW9ablZ1WTNScGIyNG9iR2x1WlNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJQ2NnSUNBbklDc2diR2x1WlR0Y2JpQWdJQ0FnSUNBZ0lDQjlLUzVxYjJsdUtDZGNYRzRuS1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0J6ZEhJZ1BTQmpkSGd1YzNSNWJHbDZaU2duVzBOcGNtTjFiR0Z5WFNjc0lDZHpjR1ZqYVdGc0p5azdYRzRnSUNBZ2ZWeHVJQ0I5WEc0Z0lHbG1JQ2hwYzFWdVpHVm1hVzVsWkNodVlXMWxLU2tnZTF4dUlDQWdJR2xtSUNoaGNuSmhlU0FtSmlCclpYa3ViV0YwWTJnb0wxNWNYR1FySkM4cEtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z2MzUnlPMXh1SUNBZ0lIMWNiaUFnSUNCdVlXMWxJRDBnU2xOUFRpNXpkSEpwYm1kcFpua29KeWNnS3lCclpYa3BPMXh1SUNBZ0lHbG1JQ2h1WVcxbExtMWhkR05vS0M5ZVhDSW9XMkV0ZWtFdFdsOWRXMkV0ZWtFdFdsOHdMVGxkS2lsY0lpUXZLU2tnZTF4dUlDQWdJQ0FnYm1GdFpTQTlJRzVoYldVdWMzVmljM1J5S0RFc0lHNWhiV1V1YkdWdVozUm9JQzBnTWlrN1hHNGdJQ0FnSUNCdVlXMWxJRDBnWTNSNExuTjBlV3hwZW1Vb2JtRnRaU3dnSjI1aGJXVW5LVHRjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ2JtRnRaU0E5SUc1aGJXVXVjbVZ3YkdGalpTZ3ZKeTluTENCY0lseGNYRnduWENJcFhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDNXlaWEJzWVdObEtDOWNYRnhjWENJdlp5d2dKMXdpSnlsY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0xuSmxjR3hoWTJVb0x5aGVYQ0o4WENJa0tTOW5MQ0JjSWlkY0lpazdYRzRnSUNBZ0lDQnVZVzFsSUQwZ1kzUjRMbk4wZVd4cGVtVW9ibUZ0WlN3Z0ozTjBjbWx1WnljcE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCdVlXMWxJQ3NnSnpvZ0p5QXJJSE4wY2p0Y2JuMWNibHh1WEc1bWRXNWpkR2x2YmlCeVpXUjFZMlZVYjFOcGJtZHNaVk4wY21sdVp5aHZkWFJ3ZFhRc0lHSmhjMlVzSUdKeVlXTmxjeWtnZTF4dUlDQjJZWElnYm5WdFRHbHVaWE5GYzNRZ1BTQXdPMXh1SUNCMllYSWdiR1Z1WjNSb0lEMGdiM1YwY0hWMExuSmxaSFZqWlNobWRXNWpkR2x2Ymlod2NtVjJMQ0JqZFhJcElIdGNiaUFnSUNCdWRXMU1hVzVsYzBWemRDc3JPMXh1SUNBZ0lHbG1JQ2hqZFhJdWFXNWtaWGhQWmlnblhGeHVKeWtnUGowZ01Da2diblZ0VEdsdVpYTkZjM1FyS3p0Y2JpQWdJQ0J5WlhSMWNtNGdjSEpsZGlBcklHTjFjaTV5WlhCc1lXTmxLQzljWEhVd01ERmlYRnhiWEZ4a1hGeGtQMjB2Wnl3Z0p5Y3BMbXhsYm1kMGFDQXJJREU3WEc0Z0lIMHNJREFwTzF4dVhHNGdJR2xtSUNoc1pXNW5kR2dnUGlBMk1Da2dlMXh1SUNBZ0lISmxkSFZ5YmlCaWNtRmpaWE5iTUYwZ0sxeHVJQ0FnSUNBZ0lDQWdJQ0FvWW1GelpTQTlQVDBnSnljZ1B5QW5KeUE2SUdKaGMyVWdLeUFuWEZ4dUlDY3BJQ3RjYmlBZ0lDQWdJQ0FnSUNBZ0p5QW5JQ3RjYmlBZ0lDQWdJQ0FnSUNBZ2IzVjBjSFYwTG1wdmFXNG9KeXhjWEc0Z0lDY3BJQ3RjYmlBZ0lDQWdJQ0FnSUNBZ0p5QW5JQ3RjYmlBZ0lDQWdJQ0FnSUNBZ1luSmhZMlZ6V3pGZE8xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlHSnlZV05sYzFzd1hTQXJJR0poYzJVZ0t5QW5JQ2NnS3lCdmRYUndkWFF1YW05cGJpZ25MQ0FuS1NBcklDY2dKeUFySUdKeVlXTmxjMXN4WFR0Y2JuMWNibHh1WEc0dkx5Qk9UMVJGT2lCVWFHVnpaU0IwZVhCbElHTm9aV05yYVc1bklHWjFibU4wYVc5dWN5QnBiblJsYm5ScGIyNWhiR3g1SUdSdmJpZDBJSFZ6WlNCZ2FXNXpkR0Z1WTJWdlptQmNiaTh2SUdKbFkyRjFjMlVnYVhRZ2FYTWdabkpoWjJsc1pTQmhibVFnWTJGdUlHSmxJR1ZoYzJsc2VTQm1ZV3RsWkNCM2FYUm9JR0JQWW1wbFkzUXVZM0psWVhSbEtDbGdMbHh1Wm5WdVkzUnBiMjRnYVhOQmNuSmhlU2hoY2lrZ2UxeHVJQ0J5WlhSMWNtNGdRWEp5WVhrdWFYTkJjbkpoZVNoaGNpazdYRzU5WEc1bGVIQnZjblJ6TG1selFYSnlZWGtnUFNCcGMwRnljbUY1TzF4dVhHNW1kVzVqZEdsdmJpQnBjMEp2YjJ4bFlXNG9ZWEpuS1NCN1hHNGdJSEpsZEhWeWJpQjBlWEJsYjJZZ1lYSm5JRDA5UFNBblltOXZiR1ZoYmljN1hHNTlYRzVsZUhCdmNuUnpMbWx6UW05dmJHVmhiaUE5SUdselFtOXZiR1ZoYmp0Y2JseHVablZ1WTNScGIyNGdhWE5PZFd4c0tHRnlaeWtnZTF4dUlDQnlaWFIxY200Z1lYSm5JRDA5UFNCdWRXeHNPMXh1ZlZ4dVpYaHdiM0owY3k1cGMwNTFiR3dnUFNCcGMwNTFiR3c3WEc1Y2JtWjFibU4wYVc5dUlHbHpUblZzYkU5eVZXNWtaV1pwYm1Wa0tHRnlaeWtnZTF4dUlDQnlaWFIxY200Z1lYSm5JRDA5SUc1MWJHdzdYRzU5WEc1bGVIQnZjblJ6TG1selRuVnNiRTl5Vlc1a1pXWnBibVZrSUQwZ2FYTk9kV3hzVDNKVmJtUmxabWx1WldRN1hHNWNibVoxYm1OMGFXOXVJR2x6VG5WdFltVnlLR0Z5WnlrZ2UxeHVJQ0J5WlhSMWNtNGdkSGx3Wlc5bUlHRnlaeUE5UFQwZ0oyNTFiV0psY2ljN1hHNTlYRzVsZUhCdmNuUnpMbWx6VG5WdFltVnlJRDBnYVhOT2RXMWlaWEk3WEc1Y2JtWjFibU4wYVc5dUlHbHpVM1J5YVc1bktHRnlaeWtnZTF4dUlDQnlaWFIxY200Z2RIbHdaVzltSUdGeVp5QTlQVDBnSjNOMGNtbHVaeWM3WEc1OVhHNWxlSEJ2Y25SekxtbHpVM1J5YVc1bklEMGdhWE5UZEhKcGJtYzdYRzVjYm1aMWJtTjBhVzl1SUdselUzbHRZbTlzS0dGeVp5a2dlMXh1SUNCeVpYUjFjbTRnZEhsd1pXOW1JR0Z5WnlBOVBUMGdKM041YldKdmJDYzdYRzU5WEc1bGVIQnZjblJ6TG1selUzbHRZbTlzSUQwZ2FYTlRlVzFpYjJ3N1hHNWNibVoxYm1OMGFXOXVJR2x6Vlc1a1pXWnBibVZrS0dGeVp5a2dlMXh1SUNCeVpYUjFjbTRnWVhKbklEMDlQU0IyYjJsa0lEQTdYRzU5WEc1bGVIQnZjblJ6TG1selZXNWtaV1pwYm1Wa0lEMGdhWE5WYm1SbFptbHVaV1E3WEc1Y2JtWjFibU4wYVc5dUlHbHpVbVZuUlhod0tISmxLU0I3WEc0Z0lISmxkSFZ5YmlCcGMwOWlhbVZqZENoeVpTa2dKaVlnYjJKcVpXTjBWRzlUZEhKcGJtY29jbVVwSUQwOVBTQW5XMjlpYW1WamRDQlNaV2RGZUhCZEp6dGNibjFjYm1WNGNHOXlkSE11YVhOU1pXZEZlSEFnUFNCcGMxSmxaMFY0Y0R0Y2JseHVablZ1WTNScGIyNGdhWE5QWW1wbFkzUW9ZWEpuS1NCN1hHNGdJSEpsZEhWeWJpQjBlWEJsYjJZZ1lYSm5JRDA5UFNBbmIySnFaV04wSnlBbUppQmhjbWNnSVQwOUlHNTFiR3c3WEc1OVhHNWxlSEJ2Y25SekxtbHpUMkpxWldOMElEMGdhWE5QWW1wbFkzUTdYRzVjYm1aMWJtTjBhVzl1SUdselJHRjBaU2hrS1NCN1hHNGdJSEpsZEhWeWJpQnBjMDlpYW1WamRDaGtLU0FtSmlCdlltcGxZM1JVYjFOMGNtbHVaeWhrS1NBOVBUMGdKMXR2WW1wbFkzUWdSR0YwWlYwbk8xeHVmVnh1Wlhod2IzSjBjeTVwYzBSaGRHVWdQU0JwYzBSaGRHVTdYRzVjYm1aMWJtTjBhVzl1SUdselJYSnliM0lvWlNrZ2UxeHVJQ0J5WlhSMWNtNGdhWE5QWW1wbFkzUW9aU2tnSmlaY2JpQWdJQ0FnSUNodlltcGxZM1JVYjFOMGNtbHVaeWhsS1NBOVBUMGdKMXR2WW1wbFkzUWdSWEp5YjNKZEp5QjhmQ0JsSUdsdWMzUmhibU5sYjJZZ1JYSnliM0lwTzF4dWZWeHVaWGh3YjNKMGN5NXBjMFZ5Y205eUlEMGdhWE5GY25KdmNqdGNibHh1Wm5WdVkzUnBiMjRnYVhOR2RXNWpkR2x2YmloaGNtY3BJSHRjYmlBZ2NtVjBkWEp1SUhSNWNHVnZaaUJoY21jZ1BUMDlJQ2RtZFc1amRHbHZiaWM3WEc1OVhHNWxlSEJ2Y25SekxtbHpSblZ1WTNScGIyNGdQU0JwYzBaMWJtTjBhVzl1TzF4dVhHNW1kVzVqZEdsdmJpQnBjMUJ5YVcxcGRHbDJaU2hoY21jcElIdGNiaUFnY21WMGRYSnVJR0Z5WnlBOVBUMGdiblZzYkNCOGZGeHVJQ0FnSUNBZ0lDQWdkSGx3Wlc5bUlHRnlaeUE5UFQwZ0oySnZiMnhsWVc0bklIeDhYRzRnSUNBZ0lDQWdJQ0IwZVhCbGIyWWdZWEpuSUQwOVBTQW5iblZ0WW1WeUp5QjhmRnh1SUNBZ0lDQWdJQ0FnZEhsd1pXOW1JR0Z5WnlBOVBUMGdKM04wY21sdVp5Y2dmSHhjYmlBZ0lDQWdJQ0FnSUhSNWNHVnZaaUJoY21jZ1BUMDlJQ2R6ZVcxaWIyd25JSHg4SUNBdkx5QkZVellnYzNsdFltOXNYRzRnSUNBZ0lDQWdJQ0IwZVhCbGIyWWdZWEpuSUQwOVBTQW5kVzVrWldacGJtVmtKenRjYm4xY2JtVjRjRzl5ZEhNdWFYTlFjbWx0YVhScGRtVWdQU0JwYzFCeWFXMXBkR2wyWlR0Y2JseHVaWGh3YjNKMGN5NXBjMEoxWm1abGNpQTlJSEpsY1hWcGNtVW9KeTR2YzNWd2NHOXlkQzlwYzBKMVptWmxjaWNwTzF4dVhHNW1kVzVqZEdsdmJpQnZZbXBsWTNSVWIxTjBjbWx1WnlodktTQjdYRzRnSUhKbGRIVnliaUJQWW1wbFkzUXVjSEp2ZEc5MGVYQmxMblJ2VTNSeWFXNW5MbU5oYkd3b2J5azdYRzU5WEc1Y2JseHVablZ1WTNScGIyNGdjR0ZrS0c0cElIdGNiaUFnY21WMGRYSnVJRzRnUENBeE1DQS9JQ2N3SnlBcklHNHVkRzlUZEhKcGJtY29NVEFwSURvZ2JpNTBiMU4wY21sdVp5Z3hNQ2s3WEc1OVhHNWNibHh1ZG1GeUlHMXZiblJvY3lBOUlGc25TbUZ1Snl3Z0owWmxZaWNzSUNkTllYSW5MQ0FuUVhCeUp5d2dKMDFoZVNjc0lDZEtkVzRuTENBblNuVnNKeXdnSjBGMVp5Y3NJQ2RUWlhBbkxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBblQyTjBKeXdnSjA1dmRpY3NJQ2RFWldNblhUdGNibHh1THk4Z01qWWdSbVZpSURFMk9qRTVPak0wWEc1bWRXNWpkR2x2YmlCMGFXMWxjM1JoYlhBb0tTQjdYRzRnSUhaaGNpQmtJRDBnYm1WM0lFUmhkR1VvS1R0Y2JpQWdkbUZ5SUhScGJXVWdQU0JiY0dGa0tHUXVaMlYwU0c5MWNuTW9LU2tzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJSEJoWkNoa0xtZGxkRTFwYm5WMFpYTW9LU2tzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJSEJoWkNoa0xtZGxkRk5sWTI5dVpITW9LU2xkTG1wdmFXNG9Kem9uS1R0Y2JpQWdjbVYwZFhKdUlGdGtMbWRsZEVSaGRHVW9LU3dnYlc5dWRHaHpXMlF1WjJWMFRXOXVkR2dvS1Ywc0lIUnBiV1ZkTG1wdmFXNG9KeUFuS1R0Y2JuMWNibHh1WEc0dkx5QnNiMmNnYVhNZ2FuVnpkQ0JoSUhSb2FXNGdkM0poY0hCbGNpQjBieUJqYjI1emIyeGxMbXh2WnlCMGFHRjBJSEJ5WlhCbGJtUnpJR0VnZEdsdFpYTjBZVzF3WEc1bGVIQnZjblJ6TG14dlp5QTlJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQmpiMjV6YjJ4bExteHZaeWduSlhNZ0xTQWxjeWNzSUhScGJXVnpkR0Z0Y0NncExDQmxlSEJ2Y25SekxtWnZjbTFoZEM1aGNIQnNlU2hsZUhCdmNuUnpMQ0JoY21kMWJXVnVkSE1wS1R0Y2JuMDdYRzVjYmx4dUx5b3FYRzRnS2lCSmJtaGxjbWwwSUhSb1pTQndjbTkwYjNSNWNHVWdiV1YwYUc5a2N5Qm1jbTl0SUc5dVpTQmpiMjV6ZEhKMVkzUnZjaUJwYm5SdklHRnViM1JvWlhJdVhHNGdLbHh1SUNvZ1ZHaGxJRVoxYm1OMGFXOXVMbkJ5YjNSdmRIbHdaUzVwYm1obGNtbDBjeUJtY205dElHeGhibWN1YW5NZ2NtVjNjbWwwZEdWdUlHRnpJR0VnYzNSaGJtUmhiRzl1WlZ4dUlDb2dablZ1WTNScGIyNGdLRzV2ZENCdmJpQkdkVzVqZEdsdmJpNXdjbTkwYjNSNWNHVXBMaUJPVDFSRk9pQkpaaUIwYUdseklHWnBiR1VnYVhNZ2RHOGdZbVVnYkc5aFpHVmtYRzRnS2lCa2RYSnBibWNnWW05dmRITjBjbUZ3Y0dsdVp5QjBhR2x6SUdaMWJtTjBhVzl1SUc1bFpXUnpJSFJ2SUdKbElISmxkM0pwZEhSbGJpQjFjMmx1WnlCemIyMWxJRzVoZEdsMlpWeHVJQ29nWm5WdVkzUnBiMjV6SUdGeklIQnliM1J2ZEhsd1pTQnpaWFIxY0NCMWMybHVaeUJ1YjNKdFlXd2dTbUYyWVZOamNtbHdkQ0JrYjJWeklHNXZkQ0IzYjNKcklHRnpYRzRnS2lCbGVIQmxZM1JsWkNCa2RYSnBibWNnWW05dmRITjBjbUZ3Y0dsdVp5QW9jMlZsSUcxcGNuSnZjaTVxY3lCcGJpQnlNVEUwT1RBektTNWNiaUFxWEc0Z0tpQkFjR0Z5WVcwZ2UyWjFibU4wYVc5dWZTQmpkRzl5SUVOdmJuTjBjblZqZEc5eUlHWjFibU4wYVc5dUlIZG9hV05vSUc1bFpXUnpJSFJ2SUdsdWFHVnlhWFFnZEdobFhHNGdLaUFnSUNBZ2NISnZkRzkwZVhCbExseHVJQ29nUUhCaGNtRnRJSHRtZFc1amRHbHZibjBnYzNWd1pYSkRkRzl5SUVOdmJuTjBjblZqZEc5eUlHWjFibU4wYVc5dUlIUnZJR2x1YUdWeWFYUWdjSEp2ZEc5MGVYQmxJR1p5YjIwdVhHNGdLaTljYm1WNGNHOXlkSE11YVc1b1pYSnBkSE1nUFNCeVpYRjFhWEpsS0NkcGJtaGxjbWwwY3ljcE8xeHVYRzVsZUhCdmNuUnpMbDlsZUhSbGJtUWdQU0JtZFc1amRHbHZiaWh2Y21sbmFXNHNJR0ZrWkNrZ2UxeHVJQ0F2THlCRWIyNG5kQ0JrYnlCaGJubDBhR2x1WnlCcFppQmhaR1FnYVhOdUozUWdZVzRnYjJKcVpXTjBYRzRnSUdsbUlDZ2hZV1JrSUh4OElDRnBjMDlpYW1WamRDaGhaR1FwS1NCeVpYUjFjbTRnYjNKcFoybHVPMXh1WEc0Z0lIWmhjaUJyWlhseklEMGdUMkpxWldOMExtdGxlWE1vWVdSa0tUdGNiaUFnZG1GeUlHa2dQU0JyWlhsekxteGxibWQwYUR0Y2JpQWdkMmhwYkdVZ0tHa3RMU2tnZTF4dUlDQWdJRzl5YVdkcGJsdHJaWGx6VzJsZFhTQTlJR0ZrWkZ0clpYbHpXMmxkWFR0Y2JpQWdmVnh1SUNCeVpYUjFjbTRnYjNKcFoybHVPMXh1ZlR0Y2JseHVablZ1WTNScGIyNGdhR0Z6VDNkdVVISnZjR1Z5ZEhrb2IySnFMQ0J3Y205d0tTQjdYRzRnSUhKbGRIVnliaUJQWW1wbFkzUXVjSEp2ZEc5MGVYQmxMbWhoYzA5M2JsQnliM0JsY25SNUxtTmhiR3dvYjJKcUxDQndjbTl3S1R0Y2JuMWNiaUpkZlE9PSIsIi8vIChjKSBEZWFuIE1jTmFtZWUgPGRlYW5AZ21haWwuY29tPiwgMjAxMi5cbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGVhbm0vY3NzLWNvbG9yLXBhcnNlci1qc1xuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4vLyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvXG52YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gIFwidHJhbnNwYXJlbnRcIjogWzAsMCwwLDBdLCBcImFsaWNlYmx1ZVwiOiBbMjQwLDI0OCwyNTUsMV0sXG4gIFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsMjM1LDIxNSwxXSwgXCJhcXVhXCI6IFswLDI1NSwyNTUsMV0sXG4gIFwiYXF1YW1hcmluZVwiOiBbMTI3LDI1NSwyMTIsMV0sIFwiYXp1cmVcIjogWzI0MCwyNTUsMjU1LDFdLFxuICBcImJlaWdlXCI6IFsyNDUsMjQ1LDIyMCwxXSwgXCJiaXNxdWVcIjogWzI1NSwyMjgsMTk2LDFdLFxuICBcImJsYWNrXCI6IFswLDAsMCwxXSwgXCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LDIzNSwyMDUsMV0sXG4gIFwiYmx1ZVwiOiBbMCwwLDI1NSwxXSwgXCJibHVldmlvbGV0XCI6IFsxMzgsNDMsMjI2LDFdLFxuICBcImJyb3duXCI6IFsxNjUsNDIsNDIsMV0sIFwiYnVybHl3b29kXCI6IFsyMjIsMTg0LDEzNSwxXSxcbiAgXCJjYWRldGJsdWVcIjogWzk1LDE1OCwxNjAsMV0sIFwiY2hhcnRyZXVzZVwiOiBbMTI3LDI1NSwwLDFdLFxuICBcImNob2NvbGF0ZVwiOiBbMjEwLDEwNSwzMCwxXSwgXCJjb3JhbFwiOiBbMjU1LDEyNyw4MCwxXSxcbiAgXCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLDE0OSwyMzcsMV0sIFwiY29ybnNpbGtcIjogWzI1NSwyNDgsMjIwLDFdLFxuICBcImNyaW1zb25cIjogWzIyMCwyMCw2MCwxXSwgXCJjeWFuXCI6IFswLDI1NSwyNTUsMV0sXG4gIFwiZGFya2JsdWVcIjogWzAsMCwxMzksMV0sIFwiZGFya2N5YW5cIjogWzAsMTM5LDEzOSwxXSxcbiAgXCJkYXJrZ29sZGVucm9kXCI6IFsxODQsMTM0LDExLDFdLCBcImRhcmtncmF5XCI6IFsxNjksMTY5LDE2OSwxXSxcbiAgXCJkYXJrZ3JlZW5cIjogWzAsMTAwLDAsMV0sIFwiZGFya2dyZXlcIjogWzE2OSwxNjksMTY5LDFdLFxuICBcImRhcmtraGFraVwiOiBbMTg5LDE4MywxMDcsMV0sIFwiZGFya21hZ2VudGFcIjogWzEzOSwwLDEzOSwxXSxcbiAgXCJkYXJrb2xpdmVncmVlblwiOiBbODUsMTA3LDQ3LDFdLCBcImRhcmtvcmFuZ2VcIjogWzI1NSwxNDAsMCwxXSxcbiAgXCJkYXJrb3JjaGlkXCI6IFsxNTMsNTAsMjA0LDFdLCBcImRhcmtyZWRcIjogWzEzOSwwLDAsMV0sXG4gIFwiZGFya3NhbG1vblwiOiBbMjMzLDE1MCwxMjIsMV0sIFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsMTg4LDE0MywxXSxcbiAgXCJkYXJrc2xhdGVibHVlXCI6IFs3Miw2MSwxMzksMV0sIFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsNzksNzksMV0sXG4gIFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsNzksNzksMV0sIFwiZGFya3R1cnF1b2lzZVwiOiBbMCwyMDYsMjA5LDFdLFxuICBcImRhcmt2aW9sZXRcIjogWzE0OCwwLDIxMSwxXSwgXCJkZWVwcGlua1wiOiBbMjU1LDIwLDE0NywxXSxcbiAgXCJkZWVwc2t5Ymx1ZVwiOiBbMCwxOTEsMjU1LDFdLCBcImRpbWdyYXlcIjogWzEwNSwxMDUsMTA1LDFdLFxuICBcImRpbWdyZXlcIjogWzEwNSwxMDUsMTA1LDFdLCBcImRvZGdlcmJsdWVcIjogWzMwLDE0NCwyNTUsMV0sXG4gIFwiZmlyZWJyaWNrXCI6IFsxNzgsMzQsMzQsMV0sIFwiZmxvcmFsd2hpdGVcIjogWzI1NSwyNTAsMjQwLDFdLFxuICBcImZvcmVzdGdyZWVuXCI6IFszNCwxMzksMzQsMV0sIFwiZnVjaHNpYVwiOiBbMjU1LDAsMjU1LDFdLFxuICBcImdhaW5zYm9yb1wiOiBbMjIwLDIyMCwyMjAsMV0sIFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LDI0OCwyNTUsMV0sXG4gIFwiZ29sZFwiOiBbMjU1LDIxNSwwLDFdLCBcImdvbGRlbnJvZFwiOiBbMjE4LDE2NSwzMiwxXSxcbiAgXCJncmF5XCI6IFsxMjgsMTI4LDEyOCwxXSwgXCJncmVlblwiOiBbMCwxMjgsMCwxXSxcbiAgXCJncmVlbnllbGxvd1wiOiBbMTczLDI1NSw0NywxXSwgXCJncmV5XCI6IFsxMjgsMTI4LDEyOCwxXSxcbiAgXCJob25leWRld1wiOiBbMjQwLDI1NSwyNDAsMV0sIFwiaG90cGlua1wiOiBbMjU1LDEwNSwxODAsMV0sXG4gIFwiaW5kaWFucmVkXCI6IFsyMDUsOTIsOTIsMV0sIFwiaW5kaWdvXCI6IFs3NSwwLDEzMCwxXSxcbiAgXCJpdm9yeVwiOiBbMjU1LDI1NSwyNDAsMV0sIFwia2hha2lcIjogWzI0MCwyMzAsMTQwLDFdLFxuICBcImxhdmVuZGVyXCI6IFsyMzAsMjMwLDI1MCwxXSwgXCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsMjQwLDI0NSwxXSxcbiAgXCJsYXduZ3JlZW5cIjogWzEyNCwyNTIsMCwxXSwgXCJsZW1vbmNoaWZmb25cIjogWzI1NSwyNTAsMjA1LDFdLFxuICBcImxpZ2h0Ymx1ZVwiOiBbMTczLDIxNiwyMzAsMV0sIFwibGlnaHRjb3JhbFwiOiBbMjQwLDEyOCwxMjgsMV0sXG4gIFwibGlnaHRjeWFuXCI6IFsyMjQsMjU1LDI1NSwxXSwgXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLDI1MCwyMTAsMV0sXG4gIFwibGlnaHRncmF5XCI6IFsyMTEsMjExLDIxMSwxXSwgXCJsaWdodGdyZWVuXCI6IFsxNDQsMjM4LDE0NCwxXSxcbiAgXCJsaWdodGdyZXlcIjogWzIxMSwyMTEsMjExLDFdLCBcImxpZ2h0cGlua1wiOiBbMjU1LDE4MiwxOTMsMV0sXG4gIFwibGlnaHRzYWxtb25cIjogWzI1NSwxNjAsMTIyLDFdLCBcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLDE3OCwxNzAsMV0sXG4gIFwibGlnaHRza3libHVlXCI6IFsxMzUsMjA2LDI1MCwxXSwgXCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LDEzNiwxNTMsMV0sXG4gIFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwxMzYsMTUzLDFdLCBcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsMTk2LDIyMiwxXSxcbiAgXCJsaWdodHllbGxvd1wiOiBbMjU1LDI1NSwyMjQsMV0sIFwibGltZVwiOiBbMCwyNTUsMCwxXSxcbiAgXCJsaW1lZ3JlZW5cIjogWzUwLDIwNSw1MCwxXSwgXCJsaW5lblwiOiBbMjUwLDI0MCwyMzAsMV0sXG4gIFwibWFnZW50YVwiOiBbMjU1LDAsMjU1LDFdLCBcIm1hcm9vblwiOiBbMTI4LDAsMCwxXSxcbiAgXCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIsMjA1LDE3MCwxXSwgXCJtZWRpdW1ibHVlXCI6IFswLDAsMjA1LDFdLFxuICBcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LDg1LDIxMSwxXSwgXCJtZWRpdW1wdXJwbGVcIjogWzE0NywxMTIsMjE5LDFdLFxuICBcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwxNzksMTEzLDFdLCBcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLDEwNCwyMzgsMV0sXG4gIFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogWzAsMjUwLDE1NCwxXSwgXCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLDIwOSwyMDQsMV0sXG4gIFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksMjEsMTMzLDFdLCBcIm1pZG5pZ2h0Ymx1ZVwiOiBbMjUsMjUsMTEyLDFdLFxuICBcIm1pbnRjcmVhbVwiOiBbMjQ1LDI1NSwyNTAsMV0sIFwibWlzdHlyb3NlXCI6IFsyNTUsMjI4LDIyNSwxXSxcbiAgXCJtb2NjYXNpblwiOiBbMjU1LDIyOCwxODEsMV0sIFwibmF2YWpvd2hpdGVcIjogWzI1NSwyMjIsMTczLDFdLFxuICBcIm5hdnlcIjogWzAsMCwxMjgsMV0sIFwib2xkbGFjZVwiOiBbMjUzLDI0NSwyMzAsMV0sXG4gIFwib2xpdmVcIjogWzEyOCwxMjgsMCwxXSwgXCJvbGl2ZWRyYWJcIjogWzEwNywxNDIsMzUsMV0sXG4gIFwib3JhbmdlXCI6IFsyNTUsMTY1LDAsMV0sIFwib3JhbmdlcmVkXCI6IFsyNTUsNjksMCwxXSxcbiAgXCJvcmNoaWRcIjogWzIxOCwxMTIsMjE0LDFdLCBcInBhbGVnb2xkZW5yb2RcIjogWzIzOCwyMzIsMTcwLDFdLFxuICBcInBhbGVncmVlblwiOiBbMTUyLDI1MSwxNTIsMV0sIFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LDIzOCwyMzgsMV0sXG4gIFwicGFsZXZpb2xldHJlZFwiOiBbMjE5LDExMiwxNDcsMV0sIFwicGFwYXlhd2hpcFwiOiBbMjU1LDIzOSwyMTMsMV0sXG4gIFwicGVhY2hwdWZmXCI6IFsyNTUsMjE4LDE4NSwxXSwgXCJwZXJ1XCI6IFsyMDUsMTMzLDYzLDFdLFxuICBcInBpbmtcIjogWzI1NSwxOTIsMjAzLDFdLCBcInBsdW1cIjogWzIyMSwxNjAsMjIxLDFdLFxuICBcInBvd2RlcmJsdWVcIjogWzE3NiwyMjQsMjMwLDFdLCBcInB1cnBsZVwiOiBbMTI4LDAsMTI4LDFdLFxuICBcInJlZFwiOiBbMjU1LDAsMCwxXSwgXCJyb3N5YnJvd25cIjogWzE4OCwxNDMsMTQzLDFdLFxuICBcInJveWFsYmx1ZVwiOiBbNjUsMTA1LDIyNSwxXSwgXCJzYWRkbGVicm93blwiOiBbMTM5LDY5LDE5LDFdLFxuICBcInNhbG1vblwiOiBbMjUwLDEyOCwxMTQsMV0sIFwic2FuZHlicm93blwiOiBbMjQ0LDE2NCw5NiwxXSxcbiAgXCJzZWFncmVlblwiOiBbNDYsMTM5LDg3LDFdLCBcInNlYXNoZWxsXCI6IFsyNTUsMjQ1LDIzOCwxXSxcbiAgXCJzaWVubmFcIjogWzE2MCw4Miw0NSwxXSwgXCJzaWx2ZXJcIjogWzE5MiwxOTIsMTkyLDFdLFxuICBcInNreWJsdWVcIjogWzEzNSwyMDYsMjM1LDFdLCBcInNsYXRlYmx1ZVwiOiBbMTA2LDkwLDIwNSwxXSxcbiAgXCJzbGF0ZWdyYXlcIjogWzExMiwxMjgsMTQ0LDFdLCBcInNsYXRlZ3JleVwiOiBbMTEyLDEyOCwxNDQsMV0sXG4gIFwic25vd1wiOiBbMjU1LDI1MCwyNTAsMV0sIFwic3ByaW5nZ3JlZW5cIjogWzAsMjU1LDEyNywxXSxcbiAgXCJzdGVlbGJsdWVcIjogWzcwLDEzMCwxODAsMV0sIFwidGFuXCI6IFsyMTAsMTgwLDE0MCwxXSxcbiAgXCJ0ZWFsXCI6IFswLDEyOCwxMjgsMV0sIFwidGhpc3RsZVwiOiBbMjE2LDE5MSwyMTYsMV0sXG4gIFwidG9tYXRvXCI6IFsyNTUsOTksNzEsMV0sIFwidHVycXVvaXNlXCI6IFs2NCwyMjQsMjA4LDFdLFxuICBcInZpb2xldFwiOiBbMjM4LDEzMCwyMzgsMV0sIFwid2hlYXRcIjogWzI0NSwyMjIsMTc5LDFdLFxuICBcIndoaXRlXCI6IFsyNTUsMjU1LDI1NSwxXSwgXCJ3aGl0ZXNtb2tlXCI6IFsyNDUsMjQ1LDI0NSwxXSxcbiAgXCJ5ZWxsb3dcIjogWzI1NSwyNTUsMCwxXSwgXCJ5ZWxsb3dncmVlblwiOiBbMTU0LDIwNSw1MCwxXX1cblxuZnVuY3Rpb24gY2xhbXBfY3NzX2J5dGUoaSkgeyAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDI1NS5cbiAgaSA9IE1hdGgucm91bmQoaSk7ICAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cbiAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAyNTUgPyAyNTUgOiBpO1xufVxuXG5mdW5jdGlvbiBjbGFtcF9jc3NfZmxvYXQoZikgeyAgLy8gQ2xhbXAgdG8gZmxvYXQgMC4wIC4uIDEuMC5cbiAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2Nzc19pbnQoc3RyKSB7ICAvLyBpbnQgb3IgcGVyY2VudGFnZS5cbiAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICclJylcbiAgICByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTtcbiAgcmV0dXJuIGNsYW1wX2Nzc19ieXRlKHBhcnNlSW50KHN0cikpO1xufVxuXG5mdW5jdGlvbiBwYXJzZV9jc3NfZmxvYXQoc3RyKSB7ICAvLyBmbG9hdCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKVxuICAgIHJldHVybiBjbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikpO1xufVxuXG5mdW5jdGlvbiBjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpIHtcbiAgaWYgKGggPCAwKSBoICs9IDE7XG4gIGVsc2UgaWYgKGggPiAxKSBoIC09IDE7XG5cbiAgaWYgKGggKiA2IDwgMSkgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gIGlmIChoICogMiA8IDEpIHJldHVybiBtMjtcbiAgaWYgKGggKiAzIDwgMikgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIvMyAtIGgpICogNjtcbiAgcmV0dXJuIG0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNTU0NvbG9yKGNzc19zdHIpIHtcbiAgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuXG4gIHZhciBzdHIgPSBjc3Nfc3RyLnJlcGxhY2UoLyAvZywgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gQ29sb3Iga2V5d29yZHMgKGFuZCB0cmFuc3BhcmVudCkgbG9va3VwLlxuICBpZiAoc3RyIGluIGtDU1NDb2xvclRhYmxlKSByZXR1cm4ga0NTU0NvbG9yVGFibGVbc3RyXS5zbGljZSgpOyAgLy8gZHVwLlxuXG4gIC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkgcmV0dXJuIG51bGw7ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgcmV0dXJuIFsoKGl2ICYgMHhmMDApID4+IDQpIHwgKChpdiAmIDB4ZjAwKSA+PiA4KSxcbiAgICAgICAgICAgICAgKGl2ICYgMHhmMCkgfCAoKGl2ICYgMHhmMCkgPj4gNCksXG4gICAgICAgICAgICAgIChpdiAmIDB4ZikgfCAoKGl2ICYgMHhmKSA8PCA0KSxcbiAgICAgICAgICAgICAgMV07XG4gICAgfSBlbHNlIGlmIChzdHIubGVuZ3RoID09PSA3KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSByZXR1cm4gbnVsbDsgIC8vIENvdmVycyBOYU4uXG4gICAgICByZXR1cm4gWyhpdiAmIDB4ZmYwMDAwKSA+PiAxNixcbiAgICAgICAgICAgICAgKGl2ICYgMHhmZjAwKSA+PiA4LFxuICAgICAgICAgICAgICBpdiAmIDB4ZmYsXG4gICAgICAgICAgICAgIDFdO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKSwgZXAgPSBzdHIuaW5kZXhPZignKScpO1xuICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xuICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wKzEsIGVwLShvcCsxKSkuc3BsaXQoJywnKTtcbiAgICB2YXIgYWxwaGEgPSAxOyAgLy8gVG8gYWxsb3cgY2FzZSBmYWxsdGhyb3VnaC5cbiAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xuICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdyZ2InOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBbcGFyc2VfY3NzX2ludChwYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgIHBhcnNlX2Nzc19pbnQocGFyYW1zWzFdKSxcbiAgICAgICAgICAgICAgICBwYXJzZV9jc3NfaW50KHBhcmFtc1syXSksXG4gICAgICAgICAgICAgICAgYWxwaGFdO1xuICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgYWxwaGEgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgY2FzZSAnaHNsJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQocGFyYW1zWzBdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MDsgIC8vIDAgLi4gMVxuICAgICAgICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmVcbiAgICAgICAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxuICAgICAgICB2YXIgcyA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMV0pO1xuICAgICAgICB2YXIgbCA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMl0pO1xuICAgICAgICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIG0xID0gbCAqIDIgLSBtMjtcbiAgICAgICAgcmV0dXJuIFtjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgrMS8zKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoLTEvMykgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGFscGhhXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG50cnkgeyBleHBvcnRzLnBhcnNlQ1NTQ29sb3IgPSBwYXJzZUNTU0NvbG9yIH0gY2F0Y2goZSkgeyB9XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZWFyY3V0O1xuXG5mdW5jdGlvbiBlYXJjdXQocG9pbnRzKSB7XG5cbiAgICB2YXIgb3V0ZXJOb2RlID0gbGlua2VkTGlzdChwb2ludHNbMF0sIHRydWUpLFxuICAgICAgICBub2RlLCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB4LCB5LCBzaXplLFxuICAgICAgICBsZW4gPSAwLFxuICAgICAgICB0aHJlc2hvbGQgPSA4MDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBsZW4gPCB0aHJlc2hvbGQgJiYgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykgbGVuICs9IHBvaW50c1tpXS5sZW5ndGg7XG5cbiAgICAvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcbiAgICBpZiAobGVuID49IHRocmVzaG9sZCkge1xuICAgICAgICBub2RlID0gb3V0ZXJOb2RlLm5leHQ7XG4gICAgICAgIG1pblggPSBtYXhYID0gbm9kZS5wWzBdO1xuICAgICAgICBtaW5ZID0gbWF4WSA9IG5vZGUucFsxXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgeCA9IG5vZGUucFswXTtcbiAgICAgICAgICAgIHkgPSBub2RlLnBbMV07XG4gICAgICAgICAgICBpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcbiAgICAgICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA+IG1heFkpIG1heFkgPSB5O1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfSB3aGlsZSAobm9kZSAhPT0gb3V0ZXJOb2RlKTtcblxuICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBzaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuICAgICAgICBzaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICB9XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA+IDEpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKHBvaW50cywgb3V0ZXJOb2RlKTtcblxuICAgIHZhciB0cmlhbmdsZXMgPSBbXTtcbiAgICBpZiAob3V0ZXJOb2RlKSBlYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIG1pblgsIG1pblksIHNpemUpO1xuXG4gICAgcmV0dXJuIHRyaWFuZ2xlcztcbn1cblxuLy8gY3JlYXRlIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0IGZyb20gcG9seWdvbiBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG5mdW5jdGlvbiBsaW5rZWRMaXN0KHBvaW50cywgY2xvY2t3aXNlKSB7XG4gICAgdmFyIHN1bSA9IDAsXG4gICAgICAgIGxlbiA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIGksIGosIGxhc3Q7XG5cbiAgICAvLyBjYWxjdWxhdGUgb3JpZ2luYWwgd2luZGluZyBvcmRlciBvZiBhIHBvbHlnb24gcmluZ1xuICAgIGZvciAoaSA9IDAsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XG4gICAgICAgIHZhciBwMSA9IHBvaW50c1tpXSxcbiAgICAgICAgICAgIHAyID0gcG9pbnRzW2pdO1xuICAgICAgICBzdW0gKz0gKHAyWzBdIC0gcDFbMF0pICogKHAxWzFdICsgcDJbMV0pO1xuICAgIH1cblxuICAgIC8vIGxpbmsgcG9pbnRzIGludG8gY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0IGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxuICAgIGlmIChjbG9ja3dpc2UgPT09IChzdW0gPiAwKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIGxhc3QgPSBpbnNlcnROb2RlKHBvaW50c1tpXSwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIGxhc3QgPSBpbnNlcnROb2RlKHBvaW50c1tpXSwgbGFzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhc3Q7XG59XG5cbmZ1bmN0aW9uIGZpbHRlclBvaW50cyhzdGFydCkge1xuICAgIC8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXG4gICAgdmFyIG5vZGUgPSBzdGFydCxcbiAgICAgICAgYWdhaW47XG4gICAgZG8ge1xuICAgICAgICBhZ2FpbiA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChlcXVhbHMobm9kZS5wLCBub2RlLm5leHQucCkgfHwgb3JpZW50KG5vZGUucHJldi5wLCBub2RlLnAsIG5vZGUubmV4dC5wKSA9PT0gMCkge1xuXG4gICAgICAgICAgICBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIG5vZGUubmV4dC5wcmV2ID0gbm9kZS5wcmV2O1xuXG4gICAgICAgICAgICBpZiAobm9kZS5wcmV2Wikgbm9kZS5wcmV2Wi5uZXh0WiA9IG5vZGUubmV4dFo7XG4gICAgICAgICAgICBpZiAobm9kZS5uZXh0Wikgbm9kZS5uZXh0Wi5wcmV2WiA9IG5vZGUucHJldlo7XG5cbiAgICAgICAgICAgIG5vZGUgPSBzdGFydCA9IG5vZGUucHJldjtcblxuICAgICAgICAgICAgaWYgKG5vZGUgPT09IG5vZGUubmV4dCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBhZ2FpbiA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChhZ2FpbiB8fCBub2RlICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gc3RhcnQ7XG59XG5cbmZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgbWluWCwgbWluWSwgc2l6ZSwgc2Vjb25kUGFzcykge1xuICAgIGVhciA9IGZpbHRlclBvaW50cyhlYXIpO1xuICAgIGlmICghZWFyKSByZXR1cm47XG5cbiAgICBpZiAoIXNlY29uZFBhc3MgJiYgbWluWCAhPT0gdW5kZWZpbmVkKSBpbmRleEN1cnZlKGVhciwgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICB2YXIgc3RvcCA9IGVhcixcbiAgICAgICAgcHJldiwgbmV4dDtcblxuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYXJzLCBzbGljaW5nIHRoZW0gb25lIGJ5IG9uZVxuICAgIHdoaWxlIChlYXIucHJldiAhPT0gZWFyLm5leHQpIHtcbiAgICAgICAgcHJldiA9IGVhci5wcmV2O1xuICAgICAgICBuZXh0ID0gZWFyLm5leHQ7XG5cbiAgICAgICAgaWYgKGlzRWFyKGVhciwgbWluWCwgbWluWSwgc2l6ZSkpIHtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYucCwgZWFyLnAsIG5leHQucCk7XG5cbiAgICAgICAgICAgIG5leHQucHJldiA9IHByZXY7XG4gICAgICAgICAgICBwcmV2Lm5leHQgPSBuZXh0O1xuXG4gICAgICAgICAgICBpZiAoZWFyLnByZXZaKSBlYXIucHJldloubmV4dFogPSBlYXIubmV4dFo7XG4gICAgICAgICAgICBpZiAoZWFyLm5leHRaKSBlYXIubmV4dFoucHJldlogPSBlYXIucHJldlo7XG5cbiAgICAgICAgICAgIGVhciA9IG5leHQubmV4dDtcbiAgICAgICAgICAgIHN0b3AgPSBuZXh0Lm5leHQ7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFyID0gbmV4dDtcblxuICAgICAgICBpZiAoZWFyID09PSBzdG9wKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnMsIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBjdXR0aW5nIGFnYWluXG4gICAgICAgICAgICBpZiAoIXNlY29uZFBhc3MpIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgbWluWCwgbWluWSwgc2l6ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xuICAgICAgICAgICAgZWxzZSBzcGxpdEVhcmN1dChlYXIsIHRyaWFuZ2xlcywgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNFYXIoZWFyLCBtaW5YLCBtaW5ZLCBzaXplKSB7XG5cbiAgICB2YXIgYSA9IGVhci5wcmV2LnAsXG4gICAgICAgIGIgPSBlYXIucCxcbiAgICAgICAgYyA9IGVhci5uZXh0LnAsXG5cbiAgICAgICAgYXggPSBhWzBdLCBieCA9IGJbMF0sIGN4ID0gY1swXSxcbiAgICAgICAgYXkgPSBhWzFdLCBieSA9IGJbMV0sIGN5ID0gY1sxXSxcblxuICAgICAgICBhYmQgPSBheCAqIGJ5IC0gYXkgKiBieCxcbiAgICAgICAgYWNkID0gYXggKiBjeSAtIGF5ICogY3gsXG4gICAgICAgIGNiZCA9IGN4ICogYnkgLSBjeSAqIGJ4LFxuICAgICAgICBBID0gYWJkIC0gYWNkIC0gY2JkO1xuXG4gICAgaWYgKEEgPD0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcblxuICAgIHZhciBjYXkgPSBjeSAtIGF5LFxuICAgICAgICBhY3ggPSBheCAtIGN4LFxuICAgICAgICBhYnkgPSBheSAtIGJ5LFxuICAgICAgICBiYXggPSBieCAtIGF4LFxuICAgICAgICBwLCBweCwgcHksIHMsIHQsIGssIG5vZGU7XG5cbiAgICAvLyBpZiB3ZSB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoaW5nLCBpdGVyYXRlIHRocm91Z2ggdGhlIGN1cnZlXG4gICAgaWYgKG1pblggIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG4gICAgICAgIHZhciBtaW5UWCA9IGF4IDwgYnggPyAoYXggPCBjeCA/IGF4IDogY3gpIDogKGJ4IDwgY3ggPyBieCA6IGN4KSxcbiAgICAgICAgICAgIG1pblRZID0gYXkgPCBieSA/IChheSA8IGN5ID8gYXkgOiBjeSkgOiAoYnkgPCBjeSA/IGJ5IDogY3kpLFxuICAgICAgICAgICAgbWF4VFggPSBheCA+IGJ4ID8gKGF4ID4gY3ggPyBheCA6IGN4KSA6IChieCA+IGN4ID8gYnggOiBjeCksXG4gICAgICAgICAgICBtYXhUWSA9IGF5ID4gYnkgPyAoYXkgPiBjeSA/IGF5IDogY3kpIDogKGJ5ID4gY3kgPyBieSA6IGN5KSxcblxuICAgICAgICAgICAgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcbiAgICAgICAgICAgIG1pblogPSB6T3JkZXIobWluVFgsIG1pblRZLCBtaW5YLCBtaW5ZLCBzaXplKSxcbiAgICAgICAgICAgIG1heFogPSB6T3JkZXIobWF4VFgsIG1heFRZLCBtaW5YLCBtaW5ZLCBzaXplKTtcblxuICAgICAgICAvLyBmaXJzdCBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBpbmNyZWFzaW5nIHotb3JkZXJcbiAgICAgICAgbm9kZSA9IGVhci5uZXh0WjtcblxuICAgICAgICB3aGlsZSAobm9kZSAmJiBub2RlLnogPD0gbWF4Wikge1xuICAgICAgICAgICAgcCA9IG5vZGUucDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRaO1xuICAgICAgICAgICAgaWYgKHAgPT09IGEgfHwgcCA9PT0gYykgY29udGludWU7XG5cbiAgICAgICAgICAgIHB4ID0gcFswXTtcbiAgICAgICAgICAgIHB5ID0gcFsxXTtcblxuICAgICAgICAgICAgcyA9IGNheSAqIHB4ICsgYWN4ICogcHkgLSBhY2Q7XG4gICAgICAgICAgICBpZiAocyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdCA9IGFieSAqIHB4ICsgYmF4ICogcHkgKyBhYmQ7XG4gICAgICAgICAgICAgICAgaWYgKHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBrID0gQSAtIHMgLSB0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGsgPj0gMCkgJiYgKChzICYmIHQpIHx8IChzICYmIGspIHx8ICh0ICYmIGspKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZW4gbG9vayBmb3IgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxuICAgICAgICBub2RlID0gZWFyLnByZXZaO1xuXG4gICAgICAgIHdoaWxlIChub2RlICYmIG5vZGUueiA+PSBtaW5aKSB7XG4gICAgICAgICAgICBwID0gbm9kZS5wO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucHJldlo7XG4gICAgICAgICAgICBpZiAocCA9PT0gYSB8fCBwID09PSBjKSBjb250aW51ZTtcblxuICAgICAgICAgICAgcHggPSBwWzBdO1xuICAgICAgICAgICAgcHkgPSBwWzFdO1xuXG4gICAgICAgICAgICBzID0gY2F5ICogcHggKyBhY3ggKiBweSAtIGFjZDtcbiAgICAgICAgICAgIGlmIChzID49IDApIHtcbiAgICAgICAgICAgICAgICB0ID0gYWJ5ICogcHggKyBiYXggKiBweSArIGFiZDtcbiAgICAgICAgICAgICAgICBpZiAodCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBBIC0gcyAtIHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoayA+PSAwKSAmJiAoKHMgJiYgdCkgfHwgKHMgJiYgaykgfHwgKHQgJiYgaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAvLyBpZiB3ZSBkb24ndCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoLCBzaW1wbHkgaXRlcmF0ZSB0aHJvdWdoIGFsbCBvdGhlciBwb2ludHNcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gZWFyLm5leHQubmV4dDtcblxuICAgICAgICB3aGlsZSAobm9kZSAhPT0gZWFyLnByZXYpIHtcbiAgICAgICAgICAgIHAgPSBub2RlLnA7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuXG4gICAgICAgICAgICBweCA9IHBbMF07XG4gICAgICAgICAgICBweSA9IHBbMV07XG5cbiAgICAgICAgICAgIHMgPSBjYXkgKiBweCArIGFjeCAqIHB5IC0gYWNkO1xuICAgICAgICAgICAgaWYgKHMgPj0gMCkge1xuICAgICAgICAgICAgICAgIHQgPSBhYnkgKiBweCArIGJheCAqIHB5ICsgYWJkO1xuICAgICAgICAgICAgICAgIGlmICh0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IEEgLSBzIC0gdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChrID49IDApICYmICgocyAmJiB0KSB8fCAocyAmJiBrKSB8fCAodCAmJiBrKSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc3BsaXRFYXJjdXQoc3RhcnQsIHRyaWFuZ2xlcywgbWluWCwgbWluWSwgc2l6ZSkge1xuICAgIC8vIGZpbmQgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cbiAgICB2YXIgYSA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGIgPSBhLm5leHQubmV4dDtcbiAgICAgICAgd2hpbGUgKGIgIT09IGEucHJldikge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREaWFnb25hbChhLCBiKSkge1xuICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHNwbGl0UG9seWdvbihhLCBiKTtcblxuICAgICAgICAgICAgICAgIC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGEsIHRyaWFuZ2xlcywgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiA9IGIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBhID0gYS5uZXh0O1xuICAgIH0gd2hpbGUgKGEgIT09IHN0YXJ0KTtcbn1cblxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMocG9pbnRzLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcblxuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGxpc3QgPSBmaWx0ZXJQb2ludHMobGlua2VkTGlzdChwb2ludHNbaV0sIGZhbHNlKSk7XG4gICAgICAgIGlmIChsaXN0KSBxdWV1ZS5wdXNoKGdldExlZnRtb3N0KGxpc3QpKTtcbiAgICB9XG4gICAgcXVldWUuc29ydChjb21wYXJlWCk7XG5cbiAgICAvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxuICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xuICAgICAgICBvdXRlck5vZGUgPSBmaWx0ZXJQb2ludHMob3V0ZXJOb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0ZXJOb2RlO1xufVxuXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlKGhvbGVOb2RlLCBvdXRlck5vZGUpIHtcbiAgICBvdXRlck5vZGUgPSBmaW5kSG9sZUJyaWRnZShob2xlTm9kZSwgb3V0ZXJOb2RlKTtcbiAgICBpZiAob3V0ZXJOb2RlKSBzcGxpdFBvbHlnb24oaG9sZU5vZGUsIG91dGVyTm9kZSk7XG59XG5cbi8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cbmZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKGhvbGVOb2RlLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgbm9kZSA9IG91dGVyTm9kZSxcbiAgICAgICAgcCA9IGhvbGVOb2RlLnAsXG4gICAgICAgIHB4ID0gcFswXSxcbiAgICAgICAgcHkgPSBwWzFdLFxuICAgICAgICBxTWF4ID0gLUluZmluaXR5LFxuICAgICAgICBtTm9kZSwgYSwgYjtcblxuICAgIC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcbiAgICAvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XG4gICAgZG8ge1xuICAgICAgICBhID0gbm9kZS5wO1xuICAgICAgICBiID0gbm9kZS5uZXh0LnA7XG5cbiAgICAgICAgaWYgKHB5IDw9IGFbMV0gJiYgcHkgPj0gYlsxXSkge1xuICAgICAgICAgICAgdmFyIHF4ID0gYVswXSArIChweSAtIGFbMV0pICogKGJbMF0gLSBhWzBdKSAvIChiWzFdIC0gYVsxXSk7XG4gICAgICAgICAgICBpZiAocXggPD0gcHggJiYgcXggPiBxTWF4KSB7XG4gICAgICAgICAgICAgICAgcU1heCA9IHF4O1xuICAgICAgICAgICAgICAgIG1Ob2RlID0gYVswXSA8IGJbMF0gPyBub2RlIDogbm9kZS5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfSB3aGlsZSAobm9kZSAhPT0gb3V0ZXJOb2RlKTtcblxuICAgIGlmICghbU5vZGUpIHJldHVybiBudWxsO1xuXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIHN0cmljdGx5IGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xuICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgdGhlIHBvaW50IG9mIHRoZSBtaW5pbXVtIGFuZ2xlIHdpdGggdGhlIHJheSBhcyBjb25uZWN0aW9uIHBvaW50XG5cbiAgICB2YXIgYnggPSBtTm9kZS5wWzBdLFxuICAgICAgICBieSA9IG1Ob2RlLnBbMV0sXG4gICAgICAgIHBiZCA9IHB4ICogYnkgLSBweSAqIGJ4LFxuICAgICAgICBwY2QgPSBweCAqIHB5IC0gcHkgKiBxTWF4LFxuICAgICAgICBjcHkgPSBweSAtIHB5LFxuICAgICAgICBwY3ggPSBweCAtIHFNYXgsXG4gICAgICAgIHBieSA9IHB5IC0gYnksXG4gICAgICAgIGJweCA9IGJ4IC0gcHgsXG4gICAgICAgIEEgPSBwYmQgLSBwY2QgLSAocU1heCAqIGJ5IC0gcHkgKiBieCksXG4gICAgICAgIHNpZ24gPSBBIDw9IDAgPyAtMSA6IDEsXG4gICAgICAgIHN0b3AgPSBtTm9kZSxcbiAgICAgICAgdGFuTWluID0gSW5maW5pdHksXG4gICAgICAgIG14LCBteSwgYW14LCBzLCB0LCB0YW47XG5cbiAgICBub2RlID0gbU5vZGUubmV4dDtcblxuICAgIHdoaWxlIChub2RlICE9PSBzdG9wKSB7XG5cbiAgICAgICAgbXggPSBub2RlLnBbMF07XG4gICAgICAgIG15ID0gbm9kZS5wWzFdO1xuICAgICAgICBhbXggPSBweCAtIG14O1xuXG4gICAgICAgIGlmIChhbXggPj0gMCAmJiBteCA+PSBieCkge1xuICAgICAgICAgICAgcyA9IChjcHkgKiBteCArIHBjeCAqIG15IC0gcGNkKSAqIHNpZ247XG4gICAgICAgICAgICBpZiAocyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdCA9IChwYnkgKiBteCArIGJweCAqIG15ICsgcGJkKSAqIHNpZ247XG5cbiAgICAgICAgICAgICAgICBpZiAodCA+PSAwICYmIEEgKiBzaWduIC0gcyAtIHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0YW4gPSBNYXRoLmFicyhweSAtIG15KSAvIGFteDsgLy8gdGFuZ2VudGlhbFxuICAgICAgICAgICAgICAgICAgICBpZiAodGFuIDwgdGFuTWluICYmIGxvY2FsbHlJbnNpZGUobm9kZSwgaG9sZU5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YW5NaW4gPSB0YW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBtTm9kZTtcbn1cblxuZnVuY3Rpb24gaW5kZXhDdXJ2ZShzdGFydCwgbWluWCwgbWluWSwgc2l6ZSkge1xuICAgIHZhciBub2RlID0gc3RhcnQ7XG5cbiAgICBkbyB7XG4gICAgICAgIG5vZGUueiA9IG5vZGUueiB8fCB6T3JkZXIobm9kZS5wWzBdLCBub2RlLnBbMV0sIG1pblgsIG1pblksIHNpemUpO1xuICAgICAgICBub2RlLnByZXZaID0gbm9kZS5wcmV2O1xuICAgICAgICBub2RlLm5leHRaID0gbm9kZS5uZXh0O1xuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH0gd2hpbGUgKG5vZGUgIT09IHN0YXJ0KTtcblxuICAgIG5vZGUucHJldloubmV4dFogPSBudWxsO1xuICAgIG5vZGUucHJldlogPSBudWxsO1xuXG4gICAgc29ydExpbmtlZChub2RlKTtcbn1cblxuLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cbi8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXG5mdW5jdGlvbiBzb3J0TGlua2VkKGxpc3QpIHtcbiAgICB2YXIgaSwgcCwgcSwgZSwgdGFpbCwgbnVtTWVyZ2VzLCBwU2l6ZSwgcVNpemUsXG4gICAgICAgIGluU2l6ZSA9IDE7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBwID0gbGlzdDtcbiAgICAgICAgbGlzdCA9IG51bGw7XG4gICAgICAgIHRhaWwgPSBudWxsO1xuICAgICAgICBudW1NZXJnZXMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBudW1NZXJnZXMrKztcbiAgICAgICAgICAgIHEgPSBwO1xuICAgICAgICAgICAgcFNpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFNpemUrKztcbiAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICBpZiAoIXEpIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBxU2l6ZSA9IGluU2l6ZTtcblxuICAgICAgICAgICAgd2hpbGUgKHBTaXplID4gMCB8fCAocVNpemUgPiAwICYmIHEpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocFNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocVNpemUgPT09IDAgfHwgIXEpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocC56IDw9IHEueikge1xuICAgICAgICAgICAgICAgICAgICBlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHBTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YWlsKSB0YWlsLm5leHRaID0gZTtcbiAgICAgICAgICAgICAgICBlbHNlIGxpc3QgPSBlO1xuXG4gICAgICAgICAgICAgICAgZS5wcmV2WiA9IHRhaWw7XG4gICAgICAgICAgICAgICAgdGFpbCA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAgPSBxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFpbC5uZXh0WiA9IG51bGw7XG5cbiAgICAgICAgaWYgKG51bU1lcmdlcyA8PSAxKSByZXR1cm4gbGlzdDtcblxuICAgICAgICBpblNpemUgKj0gMjtcbiAgICB9XG59XG5cbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIGJib3hcbmZ1bmN0aW9uIHpPcmRlcih4LCB5LCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgLy8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvICgwLi4xMDAwKSBpbnRlZ2VyIHJhbmdlXG4gICAgeCA9IDEwMDAgKiAoeCAtIG1pblgpIC8gc2l6ZTtcbiAgICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgeSA9IDEwMDAgKiAoeSAtIG1pblkpIC8gc2l6ZTtcbiAgICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0LFxuICAgICAgICBsZWZ0bW9zdCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKG5vZGUucFswXSA8IGxlZnRtb3N0LnBbMF0pIGxlZnRtb3N0ID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9IHdoaWxlIChub2RlICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gbGVmdG1vc3Q7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbChhLCBiKSB7XG4gICAgcmV0dXJuICFpbnRlcnNlY3RzUG9seWdvbihhLCBhLnAsIGIucCkgJiZcbiAgICAgICAgICAgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpICYmXG4gICAgICAgICAgIG1pZGRsZUluc2lkZShhLCBhLnAsIGIucCk7XG59XG5cbi8vIHdpbmRpbmcgb3JkZXIgb2YgdHJpYW5nbGUgZm9ybWVkIGJ5IDMgZ2l2ZW4gcG9pbnRzXG5mdW5jdGlvbiBvcmllbnQocCwgcSwgcikge1xuICAgIHZhciBvID0gKHFbMV0gLSBwWzFdKSAqIChyWzBdIC0gcVswXSkgLSAocVswXSAtIHBbMF0pICogKHJbMV0gLSBxWzFdKTtcbiAgICByZXR1cm4gbyA+IDAgPyAxIDpcbiAgICAgICAgICAgbyA8IDAgPyAtMSA6IDA7XG59XG5cbmZ1bmN0aW9uIGVxdWFscyhwMSwgcDIpIHtcbiAgICByZXR1cm4gcDFbMF0gPT09IHAyWzBdICYmIHAxWzFdID09PSBwMlsxXTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxuZnVuY3Rpb24gaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xuICAgIHJldHVybiBvcmllbnQocDEsIHExLCBwMikgIT09IG9yaWVudChwMSwgcTEsIHEyKSAmJlxuICAgICAgICAgICBvcmllbnQocDIsIHEyLCBwMSkgIT09IG9yaWVudChwMiwgcTIsIHExKTtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcbmZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKHN0YXJ0LCBhLCBiKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBwMSA9IG5vZGUucCxcbiAgICAgICAgICAgIHAyID0gbm9kZS5uZXh0LnA7XG5cbiAgICAgICAgaWYgKHAxICE9PSBhICYmIHAyICE9PSBhICYmIHAxICE9PSBiICYmIHAyICE9PSBiICYmIGludGVyc2VjdHMocDEsIHAyLCBhLCBiKSkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9IHdoaWxlIChub2RlICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbG9jYWxseUluc2lkZShhLCBiKSB7XG4gICAgcmV0dXJuIG9yaWVudChhLnByZXYucCwgYS5wLCBhLm5leHQucCkgPT09IC0xID9cbiAgICAgICAgb3JpZW50KGEucCwgYi5wLCBhLm5leHQucCkgIT09IC0xICYmIG9yaWVudChhLnAsIGEucHJldi5wLCBiLnApICE9PSAtMSA6XG4gICAgICAgIG9yaWVudChhLnAsIGIucCwgYS5wcmV2LnApID09PSAtMSB8fCBvcmllbnQoYS5wLCBhLm5leHQucCwgYi5wKSA9PT0gLTE7XG59XG5cbi8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbWlkZGxlSW5zaWRlKHN0YXJ0LCBhLCBiKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydCxcbiAgICAgICAgaW5zaWRlID0gZmFsc2UsXG4gICAgICAgIHB4ID0gKGFbMF0gKyBiWzBdKSAvIDIsXG4gICAgICAgIHB5ID0gKGFbMV0gKyBiWzFdKSAvIDI7XG4gICAgZG8ge1xuICAgICAgICB2YXIgcDEgPSBub2RlLnAsXG4gICAgICAgICAgICBwMiA9IG5vZGUubmV4dC5wO1xuXG4gICAgICAgIGlmICgoKHAxWzFdID4gcHkpICE9PSAocDJbMV0gPiBweSkpICYmXG4gICAgICAgICAgICAocHggPCAocDJbMF0gLSBwMVswXSkgKiAocHkgLSBwMVsxXSkgLyAocDJbMV0gLSBwMVsxXSkgKyBwMVswXSkpIGluc2lkZSA9ICFpbnNpZGU7XG5cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9IHdoaWxlIChub2RlICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gaW5zaWRlO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlWChhLCBiKSB7XG4gICAgcmV0dXJuIGEucFswXSAtIGIucFswXTtcbn1cblxuLy8gc3BsaXQgdGhlIHBvbHlnb24gdmVydGljZXMgY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaW5rZWQgbGlzdCBpbnRvIHR3b1xuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgYTIgPSBuZXcgTm9kZShhLnApLFxuICAgICAgICBiMiA9IG5ldyBOb2RlKGIucCksXG4gICAgICAgIGFuID0gYS5uZXh0LFxuICAgICAgICBicCA9IGIucHJldjtcblxuICAgIGEubmV4dCA9IGI7XG4gICAgYi5wcmV2ID0gYTtcblxuICAgIGEyLm5leHQgPSBhbjtcbiAgICBhbi5wcmV2ID0gYTI7XG5cbiAgICBiMi5uZXh0ID0gYTI7XG4gICAgYTIucHJldiA9IGIyO1xuXG4gICAgYnAubmV4dCA9IGIyO1xuICAgIGIyLnByZXYgPSBicDtcblxuICAgIHJldHVybiBhMjtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShwb2ludCwgbGFzdCkge1xuICAgIHZhciBub2RlID0gbmV3IE5vZGUocG9pbnQpO1xuXG4gICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIG5vZGUucHJldiA9IG5vZGU7XG4gICAgICAgIG5vZGUubmV4dCA9IG5vZGU7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgICAgIG5vZGUucHJldiA9IGxhc3Q7XG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gbm9kZTtcbiAgICAgICAgbGFzdC5uZXh0ID0gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIE5vZGUocCkge1xuICAgIHRoaXMucCA9IHA7XG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuXG4gICAgdGhpcy56ID0gbnVsbDtcbiAgICB0aGlzLnByZXZaID0gbnVsbDtcbiAgICB0aGlzLm5leHRaID0gbnVsbDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjbGlwO1xuXG4vKiBjbGlwIGZlYXR1cmVzIGJldHdlZW4gdHdvIGF4aXMtcGFyYWxsZWwgbGluZXM6XG4gKiAgICAgfCAgICAgICAgfFxuICogIF9fX3xfX18gICAgIHwgICAgIC9cbiAqIC8gICB8ICAgXFxfX19ffF9fX18vXG4gKiAgICAgfCAgICAgICAgfFxuICovXG5cbmZ1bmN0aW9uIGNsaXAoZmVhdHVyZXMsIHNjYWxlLCBrMSwgazIsIGF4aXMsIGludGVyc2VjdCwgbWluQWxsLCBtYXhBbGwpIHtcblxuICAgIGsxIC89IHNjYWxlO1xuICAgIGsyIC89IHNjYWxlO1xuXG4gICAgaWYgKG1pbkFsbCA+PSBrMSAmJiBtYXhBbGwgPD0gazIpIHJldHVybiBmZWF0dXJlczsgLy8gdHJpdmlhbCBhY2NlcHRcbiAgICBlbHNlIGlmIChtaW5BbGwgPiBrMiB8fCBtYXhBbGwgPCBrMSkgcmV0dXJuIG51bGw7IC8vIHRyaXZpYWwgcmVqZWN0XG5cbiAgICB2YXIgY2xpcHBlZCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbaV0sXG4gICAgICAgICAgICBnZW9tZXRyeSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgICAgICB0eXBlID0gZmVhdHVyZS50eXBlLFxuICAgICAgICAgICAgbWluLCBtYXg7XG5cbiAgICAgICAgbWluID0gZmVhdHVyZS5taW5bYXhpc107XG4gICAgICAgIG1heCA9IGZlYXR1cmUubWF4W2F4aXNdO1xuXG4gICAgICAgIGlmIChtaW4gPj0gazEgJiYgbWF4IDw9IGsyKSB7IC8vIHRyaXZpYWwgYWNjZXB0XG4gICAgICAgICAgICBjbGlwcGVkLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChtaW4gPiBrMiB8fCBtYXggPCBrMSkgY29udGludWU7IC8vIHRyaXZpYWwgcmVqZWN0XG5cbiAgICAgICAgdmFyIHNsaWNlcyA9IHR5cGUgPT09IDEgP1xuICAgICAgICAgICAgICAgIGNsaXBQb2ludHMoZ2VvbWV0cnksIGsxLCBrMiwgYXhpcykgOlxuICAgICAgICAgICAgICAgIGNsaXBHZW9tZXRyeShnZW9tZXRyeSwgazEsIGsyLCBheGlzLCBpbnRlcnNlY3QsIHR5cGUgPT09IDMpO1xuXG4gICAgICAgIGlmIChzbGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBpZiBhIGZlYXR1cmUgZ290IGNsaXBwZWQsIGl0IHdpbGwgbGlrZWx5IGdldCBjbGlwcGVkIG9uIHRoZSBuZXh0IHpvb20gbGV2ZWwgYXMgd2VsbCxcbiAgICAgICAgICAgIC8vIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byByZWNhbGN1bGF0ZSBiYm94ZXNcbiAgICAgICAgICAgIGNsaXBwZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHNsaWNlcyxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIHRhZ3M6IGZlYXR1cmVzW2ldLnRhZ3MgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBtaW46IGZlYXR1cmUubWluLFxuICAgICAgICAgICAgICAgIG1heDogZmVhdHVyZS5tYXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaXBwZWQubGVuZ3RoID8gY2xpcHBlZCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNsaXBQb2ludHMoZ2VvbWV0cnksIGsxLCBrMiwgYXhpcykge1xuICAgIHZhciBzbGljZSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYSA9IGdlb21ldHJ5W2ldLFxuICAgICAgICAgICAgYWsgPSBhW2F4aXNdO1xuXG4gICAgICAgIGlmIChhayA+PSBrMSAmJiBhayA8PSBrMikgc2xpY2UucHVzaChhKTtcbiAgICB9XG4gICAgcmV0dXJuIHNsaWNlO1xufVxuXG5mdW5jdGlvbiBjbGlwR2VvbWV0cnkoZ2VvbWV0cnksIGsxLCBrMiwgYXhpcywgaW50ZXJzZWN0LCBjbG9zZWQpIHtcblxuICAgIHZhciBzbGljZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICB2YXIgYWsgPSAwLFxuICAgICAgICAgICAgYmsgPSAwLFxuICAgICAgICAgICAgYiA9IG51bGwsXG4gICAgICAgICAgICBwb2ludHMgPSBnZW9tZXRyeVtpXSxcbiAgICAgICAgICAgIGFyZWEgPSBwb2ludHMuYXJlYSxcbiAgICAgICAgICAgIGRpc3QgPSBwb2ludHMuZGlzdCxcbiAgICAgICAgICAgIGxlbiA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhLCBqLCBsYXN0O1xuXG4gICAgICAgIHZhciBzbGljZSA9IFtdO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW4gLSAxOyBqKyspIHtcbiAgICAgICAgICAgIGEgPSBiIHx8IHBvaW50c1tqXTtcbiAgICAgICAgICAgIGIgPSBwb2ludHNbaiArIDFdO1xuICAgICAgICAgICAgYWsgPSBiayB8fCBhW2F4aXNdO1xuICAgICAgICAgICAgYmsgPSBiW2F4aXNdO1xuXG4gICAgICAgICAgICBpZiAoYWsgPCBrMSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKChiayA+IGsyKSkgeyAvLyAtLS18LS0tLS18LS0+XG4gICAgICAgICAgICAgICAgICAgIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsxKSwgaW50ZXJzZWN0KGEsIGIsIGsyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSBzbGljZSA9IG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiayA+PSBrMSkgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazEpKTsgLy8gLS0tfC0tPiAgfFxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFrID4gazIpIHtcblxuICAgICAgICAgICAgICAgIGlmICgoYmsgPCBrMSkpIHsgLy8gPC0tfC0tLS0tfC0tLVxuICAgICAgICAgICAgICAgICAgICBzbGljZS5wdXNoKGludGVyc2VjdChhLCBiLCBrMiksIGludGVyc2VjdChhLCBiLCBrMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZCkgc2xpY2UgPSBuZXdTbGljZShzbGljZXMsIHNsaWNlLCBhcmVhLCBkaXN0KTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmsgPD0gazIpIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsyKSk7IC8vIHwgIDwtLXwtLS1cblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHNsaWNlLnB1c2goYSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmsgPCBrMSkgeyAvLyA8LS18LS0tICB8XG4gICAgICAgICAgICAgICAgICAgIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsxKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSBzbGljZSA9IG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiayA+IGsyKSB7IC8vIHwgIC0tLXwtLT5cbiAgICAgICAgICAgICAgICAgICAgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHNsaWNlID0gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHwgLS0+IHxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0aGUgbGFzdCBwb2ludFxuICAgICAgICBhID0gcG9pbnRzW2xlbiAtIDFdO1xuICAgICAgICBhayA9IGFbYXhpc107XG4gICAgICAgIGlmIChhayA+PSBrMSAmJiBhayA8PSBrMikgc2xpY2UucHVzaChhKTtcblxuICAgICAgICAvLyBjbG9zZSB0aGUgcG9seWdvbiBpZiBpdHMgZW5kcG9pbnRzIGFyZSBub3QgdGhlIHNhbWUgYWZ0ZXIgY2xpcHBpbmdcblxuICAgICAgICBsYXN0ID0gc2xpY2Vbc2xpY2UubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChjbG9zZWQgJiYgbGFzdCAmJiAoc2xpY2VbMF1bMF0gIT09IGxhc3RbMF0gfHwgc2xpY2VbMF1bMV0gIT09IGxhc3RbMV0pKSBzbGljZS5wdXNoKHNsaWNlWzBdKTtcblxuICAgICAgICAvLyBhZGQgdGhlIGZpbmFsIHNsaWNlXG4gICAgICAgIG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpO1xuICAgIH1cblxuICAgIHJldHVybiBzbGljZXM7XG59XG5cbmZ1bmN0aW9uIG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpIHtcbiAgICBpZiAoc2xpY2UubGVuZ3RoKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IHJlY2FsY3VsYXRlIHRoZSBhcmVhL2xlbmd0aCBvZiB0aGUgdW5jbGlwcGVkIGdlb21ldHJ5IGJlY2F1c2UgdGhlIGNhc2Ugd2hlcmUgaXQgZ29lc1xuICAgICAgICAvLyBiZWxvdyB0aGUgdmlzaWJpbGl0eSB0aHJlc2hvbGQgYXMgYSByZXN1bHQgb2YgY2xpcHBpbmcgaXMgcmFyZSwgc28gd2UgYXZvaWQgZG9pbmcgdW5uZWNlc3Nhcnkgd29ya1xuICAgICAgICBzbGljZS5hcmVhID0gYXJlYTtcbiAgICAgICAgc2xpY2UuZGlzdCA9IGRpc3Q7XG5cbiAgICAgICAgc2xpY2VzLnB1c2goc2xpY2UpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY29udmVydDtcblxudmFyIHNpbXBsaWZ5ID0gcmVxdWlyZSgnLi9zaW1wbGlmeScpO1xuXG4vLyBjb252ZXJ0cyBHZW9KU09OIGZlYXR1cmUgaW50byBhbiBpbnRlcm1lZGlhdGUgcHJvamVjdGVkIEpTT04gdmVjdG9yIGZvcm1hdCB3aXRoIHNpbXBsaWZpY2F0aW9uIGRhdGFcblxuZnVuY3Rpb24gY29udmVydChkYXRhLCB0b2xlcmFuY2UpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSBbXTtcblxuICAgIGlmIChkYXRhLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb252ZXJ0RmVhdHVyZShmZWF0dXJlcywgZGF0YS5mZWF0dXJlc1tpXSwgdG9sZXJhbmNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnRmVhdHVyZScpIHtcbiAgICAgICAgY29udmVydEZlYXR1cmUoZmVhdHVyZXMsIGRhdGEsIHRvbGVyYW5jZSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzaW5nbGUgZ2VvbWV0cnkgb3IgYSBnZW9tZXRyeSBjb2xsZWN0aW9uXG4gICAgICAgIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCB7Z2VvbWV0cnk6IGRhdGF9LCB0b2xlcmFuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZXM7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCBmZWF0dXJlLCB0b2xlcmFuY2UpIHtcbiAgICB2YXIgZ2VvbSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgIHR5cGUgPSBnZW9tLnR5cGUsXG4gICAgICAgIGNvb3JkcyA9IGdlb20uY29vcmRpbmF0ZXMsXG4gICAgICAgIHRhZ3MgPSBmZWF0dXJlLnByb3BlcnRpZXMsXG4gICAgICAgIGksIGosIHJpbmdzO1xuXG4gICAgaWYgKHR5cGUgPT09ICdQb2ludCcpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaChjcmVhdGUodGFncywgMSwgW3Byb2plY3RQb2ludChjb29yZHMpXSkpO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaChjcmVhdGUodGFncywgMSwgcHJvamVjdChjb29yZHMpKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGNyZWF0ZSh0YWdzLCAyLCBbcHJvamVjdChjb29yZHMsIHRvbGVyYW5jZSldKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnIHx8IHR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICByaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByaW5ncy5wdXNoKHByb2plY3QoY29vcmRzW2ldLCB0b2xlcmFuY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBmZWF0dXJlcy5wdXNoKGNyZWF0ZSh0YWdzLCB0eXBlID09PSAnUG9seWdvbicgPyAzIDogMiwgcmluZ3MpKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgcmluZ3MgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHJpbmdzLnB1c2gocHJvamVjdChjb29yZHNbaV1bal0sIHRvbGVyYW5jZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZlYXR1cmVzLnB1c2goY3JlYXRlKHRhZ3MsIDMsIHJpbmdzKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9tLmdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGdlb20uZ2VvbWV0cmllc1tpXSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB0YWdzXG4gICAgICAgICAgICB9LCB0b2xlcmFuY2UpO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgaXMgbm90IGEgdmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGUodGFncywgdHlwZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgZmVhdHVyZSA9IHtcbiAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB0YWdzOiB0YWdzIHx8IG51bGwsXG4gICAgICAgIG1pbjogWzIsIDFdLCAvLyBpbml0aWFsIGJib3ggdmFsdWVzO1xuICAgICAgICBtYXg6IFstMSwgMF0gIC8vIG5vdGUgdGhhdCBjb29yZHMgYXJlIHVzdWFsbHkgaW4gWzAuLjFdIHJhbmdlXG4gICAgfTtcbiAgICBjYWxjQkJveChmZWF0dXJlKTtcbiAgICByZXR1cm4gZmVhdHVyZTtcbn1cblxuZnVuY3Rpb24gcHJvamVjdChsb25sYXRzLCB0b2xlcmFuY2UpIHtcbiAgICB2YXIgcHJvamVjdGVkID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb25sYXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByb2plY3RlZC5wdXNoKHByb2plY3RQb2ludChsb25sYXRzW2ldKSk7XG4gICAgfVxuICAgIGlmICh0b2xlcmFuY2UpIHtcbiAgICAgICAgc2ltcGxpZnkocHJvamVjdGVkLCB0b2xlcmFuY2UpO1xuICAgICAgICBjYWxjU2l6ZShwcm9qZWN0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvamVjdGVkO1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0UG9pbnQocCkge1xuICAgIHZhciBzaW4gPSBNYXRoLnNpbihwWzFdICogTWF0aC5QSSAvIDE4MCksXG4gICAgICAgIHggPSAocFswXSAvIDM2MCArIDAuNSksXG4gICAgICAgIHkgPSAoMC41IC0gMC4yNSAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyBNYXRoLlBJKTtcblxuICAgIHkgPSB5IDwgLTEgPyAtMSA6XG4gICAgICAgIHkgPiAxID8gMSA6IHk7XG5cbiAgICByZXR1cm4gW3gsIHksIDBdO1xufVxuXG4vLyBjYWxjdWxhdGUgYXJlYSBhbmQgbGVuZ3RoIG9mIHRoZSBwb2x5XG5mdW5jdGlvbiBjYWxjU2l6ZShwb2ludHMpIHtcbiAgICB2YXIgYXJlYSA9IDAsXG4gICAgICAgIGRpc3QgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGEsIGI7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGEgPSBiIHx8IHBvaW50c1tpXTtcbiAgICAgICAgYiA9IHBvaW50c1tpICsgMV07XG5cbiAgICAgICAgYXJlYSArPSBhWzBdICogYlsxXSAtIGJbMF0gKiBhWzFdO1xuXG4gICAgICAgIC8vIHVzZSBNYW5oYXR0YW4gZGlzdGFuY2UgaW5zdGVhZCBvZiBFdWNsaWRpYW4gb25lIHRvIGF2b2lkIGV4cGVuc2l2ZSBzcXVhcmUgcm9vdCBjb21wdXRhdGlvblxuICAgICAgICBkaXN0ICs9IE1hdGguYWJzKGJbMF0gLSBhWzBdKSArIE1hdGguYWJzKGJbMV0gLSBhWzFdKTtcbiAgICB9XG4gICAgcG9pbnRzLmFyZWEgPSBNYXRoLmFicyhhcmVhIC8gMik7XG4gICAgcG9pbnRzLmRpc3QgPSBkaXN0O1xufVxuXG4vLyBjYWxjdWxhdGUgdGhlIGZlYXR1cmUgYm91bmRpbmcgYm94IGZvciBmYXN0ZXIgY2xpcHBpbmcgbGF0ZXJcbmZ1bmN0aW9uIGNhbGNCQm94KGZlYXR1cmUpIHtcbiAgICB2YXIgZ2VvbWV0cnkgPSBmZWF0dXJlLmdlb21ldHJ5LFxuICAgICAgICBtaW4gPSBmZWF0dXJlLm1pbixcbiAgICAgICAgbWF4ID0gZmVhdHVyZS5tYXg7XG5cbiAgICBpZiAoZmVhdHVyZS50eXBlID09PSAxKSBjYWxjUmluZ0JCb3gobWluLCBtYXgsIGdlb21ldHJ5KTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkubGVuZ3RoOyBpKyspIGNhbGNSaW5nQkJveChtaW4sIG1heCwgZ2VvbWV0cnlbaV0pO1xuXG4gICAgcmV0dXJuIGZlYXR1cmU7XG59XG5cbmZ1bmN0aW9uIGNhbGNSaW5nQkJveChtaW4sIG1heCwgcG9pbnRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgbWluWzBdID0gTWF0aC5taW4ocFswXSwgbWluWzBdKTtcbiAgICAgICAgbWF4WzBdID0gTWF0aC5tYXgocFswXSwgbWF4WzBdKTtcbiAgICAgICAgbWluWzFdID0gTWF0aC5taW4ocFsxXSwgbWluWzFdKTtcbiAgICAgICAgbWF4WzFdID0gTWF0aC5tYXgocFsxXSwgbWF4WzFdKTtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VvanNvbnZ0O1xuXG52YXIgY29udmVydCA9IHJlcXVpcmUoJy4vY29udmVydCcpLCAvLyBHZW9KU09OIGNvbnZlcnNpb24gYW5kIHByZXByb2Nlc3NpbmdcbiAgICBjbGlwID0gcmVxdWlyZSgnLi9jbGlwJyksICAgICAgIC8vIHN0cmlwZSBjbGlwcGluZyBhbGdvcml0aG1cbiAgICB3cmFwID0gcmVxdWlyZSgnLi93cmFwJyksICAgICAgIC8vIGRhdGUgbGluZSBwcm9jZXNzaW5nXG4gICAgY3JlYXRlVGlsZSA9IHJlcXVpcmUoJy4vdGlsZScpOyAvLyBmaW5hbCBzaW1wbGlmaWVkIHRpbGUgZ2VuZXJhdGlvblxuXG5cbmZ1bmN0aW9uIGdlb2pzb252dChkYXRhLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBHZW9KU09OVlQoZGF0YSwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIEdlb0pTT05WVChkYXRhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyA9IGV4dGVuZChPYmplY3QuY3JlYXRlKHRoaXMub3B0aW9ucyksIG9wdGlvbnMpO1xuXG4gICAgdmFyIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcblxuICAgIGlmIChkZWJ1ZykgY29uc29sZS50aW1lKCdwcmVwcm9jZXNzIGRhdGEnKTtcblxuICAgIHZhciB6MiA9IDEgPDwgb3B0aW9ucy5tYXhab29tLCAvLyAyXnpcbiAgICAgICAgZmVhdHVyZXMgPSBjb252ZXJ0KGRhdGEsIG9wdGlvbnMudG9sZXJhbmNlIC8gKHoyICogb3B0aW9ucy5leHRlbnQpKTtcblxuICAgIHRoaXMudGlsZXMgPSB7fTtcbiAgICB0aGlzLnRpbGVDb29yZHMgPSBbXTtcblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLnRpbWVFbmQoJ3ByZXByb2Nlc3MgZGF0YScpO1xuICAgICAgICBjb25zb2xlLmxvZygnaW5kZXg6IG1heFpvb206ICVkLCBtYXhQb2ludHM6ICVkJywgb3B0aW9ucy5pbmRleE1heFpvb20sIG9wdGlvbnMuaW5kZXhNYXhQb2ludHMpO1xuICAgICAgICBjb25zb2xlLnRpbWUoJ2dlbmVyYXRlIHRpbGVzJyk7XG4gICAgICAgIHRoaXMuc3RhdHMgPSB7fTtcbiAgICAgICAgdGhpcy50b3RhbCA9IDA7XG4gICAgfVxuXG4gICAgZmVhdHVyZXMgPSB3cmFwKGZlYXR1cmVzLCBvcHRpb25zLmJ1ZmZlciAvIG9wdGlvbnMuZXh0ZW50LCBpbnRlcnNlY3RYKTtcblxuICAgIC8vIHN0YXJ0IHNsaWNpbmcgZnJvbSB0aGUgdG9wIHRpbGUgZG93blxuICAgIGlmIChmZWF0dXJlcy5sZW5ndGgpIHRoaXMuc3BsaXRUaWxlKGZlYXR1cmVzLCAwLCAwLCAwKTtcblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBpZiAoZmVhdHVyZXMubGVuZ3RoKSBjb25zb2xlLmxvZygnZmVhdHVyZXM6ICVkLCBwb2ludHM6ICVkJywgdGhpcy50aWxlc1swXS5udW1GZWF0dXJlcywgdGhpcy50aWxlc1swXS5udW1Qb2ludHMpO1xuICAgICAgICBjb25zb2xlLnRpbWVFbmQoJ2dlbmVyYXRlIHRpbGVzJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCd0aWxlcyBnZW5lcmF0ZWQ6JywgdGhpcy50b3RhbCwgSlNPTi5zdHJpbmdpZnkodGhpcy5zdGF0cykpO1xuICAgIH1cbn1cblxuR2VvSlNPTlZULnByb3RvdHlwZS5vcHRpb25zID0ge1xuICAgIG1heFpvb206IDE0LCAgICAgICAgICAgIC8vIG1heCB6b29tIHRvIHByZXNlcnZlIGRldGFpbCBvblxuICAgIGluZGV4TWF4Wm9vbTogNSwgICAgICAgIC8vIG1heCB6b29tIGluIHRoZSB0aWxlIGluZGV4XG4gICAgaW5kZXhNYXhQb2ludHM6IDEwMDAwMCwgLy8gbWF4IG51bWJlciBvZiBwb2ludHMgcGVyIHRpbGUgaW4gdGhlIHRpbGUgaW5kZXhcbiAgICBzb2xpZENoaWxkcmVuOiBmYWxzZSwgICAvLyB3aGV0aGVyIHRvIHRpbGUgc29saWQgc3F1YXJlIHRpbGVzIGZ1cnRoZXJcbiAgICB0b2xlcmFuY2U6IDMsICAgICAgICAgICAvLyBzaW1wbGlmaWNhdGlvbiB0b2xlcmFuY2UgKGhpZ2hlciBtZWFucyBzaW1wbGVyKVxuICAgIGV4dGVudDogNDA5NiwgICAgICAgICAgIC8vIHRpbGUgZXh0ZW50XG4gICAgYnVmZmVyOiA2NCwgICAgICAgICAgICAgLy8gdGlsZSBidWZmZXIgb24gZWFjaCBzaWRlXG4gICAgZGVidWc6IDAgICAgICAgICAgICAgICAgLy8gbG9nZ2luZyBsZXZlbCAoMCwgMSBvciAyKVxufTtcblxuR2VvSlNPTlZULnByb3RvdHlwZS5zcGxpdFRpbGUgPSBmdW5jdGlvbiAoZmVhdHVyZXMsIHosIHgsIHksIGN6LCBjeCwgY3kpIHtcblxuICAgIHZhciBzdGFjayA9IFtmZWF0dXJlcywgeiwgeCwgeV0sXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcblxuICAgIC8vIGF2b2lkIHJlY3Vyc2lvbiBieSB1c2luZyBhIHByb2Nlc3NpbmcgcXVldWVcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgeCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB6ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGZlYXR1cmVzID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgdmFyIHoyID0gMSA8PCB6LFxuICAgICAgICAgICAgaWQgPSB0b0lEKHosIHgsIHkpLFxuICAgICAgICAgICAgdGlsZSA9IHRoaXMudGlsZXNbaWRdLFxuICAgICAgICAgICAgdGlsZVRvbGVyYW5jZSA9IHogPT09IG9wdGlvbnMubWF4Wm9vbSA/IDAgOiBvcHRpb25zLnRvbGVyYW5jZSAvICh6MiAqIG9wdGlvbnMuZXh0ZW50KTtcblxuICAgICAgICBpZiAoIXRpbGUpIHtcbiAgICAgICAgICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUudGltZSgnY3JlYXRpb24nKTtcblxuICAgICAgICAgICAgdGlsZSA9IHRoaXMudGlsZXNbaWRdID0gY3JlYXRlVGlsZShmZWF0dXJlcywgejIsIHgsIHksIHRpbGVUb2xlcmFuY2UsIHogPT09IG9wdGlvbnMubWF4Wm9vbSk7XG4gICAgICAgICAgICB0aGlzLnRpbGVDb29yZHMucHVzaCh7ejogeiwgeDogeCwgeTogeX0pO1xuXG4gICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVidWcgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0aWxlIHolZC0lZC0lZCAoZmVhdHVyZXM6ICVkLCBwb2ludHM6ICVkLCBzaW1wbGlmaWVkOiAlZCknLFxuICAgICAgICAgICAgICAgICAgICAgICAgeiwgeCwgeSwgdGlsZS5udW1GZWF0dXJlcywgdGlsZS5udW1Qb2ludHMsIHRpbGUubnVtU2ltcGxpZmllZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUudGltZUVuZCgnY3JlYXRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9ICd6JyArIHo7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0c1trZXldID0gKHRoaXMuc3RhdHNba2V5XSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy50b3RhbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgZ2VvbWV0cnkgaW4gdGlsZSBzbyB0aGF0IHdlIGNhbiBkcmlsbCBkb3duIGxhdGVyIGlmIHdlIHN0b3Agbm93XG4gICAgICAgIHRpbGUuc291cmNlID0gZmVhdHVyZXM7XG5cbiAgICAgICAgLy8gc3RvcCB0aWxpbmcgaWYgdGhlIHRpbGUgaXMgc29saWQgY2xpcHBlZCBzcXVhcmVcbiAgICAgICAgaWYgKCFvcHRpb25zLnNvbGlkQ2hpbGRyZW4gJiYgaXNDbGlwcGVkU3F1YXJlKHRpbGUsIG9wdGlvbnMuZXh0ZW50LCBvcHRpb25zLmJ1ZmZlcikpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIGlmIGl0J3MgdGhlIGZpcnN0LXBhc3MgdGlsaW5nXG4gICAgICAgIGlmICghY3opIHtcbiAgICAgICAgICAgIC8vIHN0b3AgdGlsaW5nIGlmIHdlIHJlYWNoZWQgbWF4IHpvb20sIG9yIGlmIHRoZSB0aWxlIGlzIHRvbyBzaW1wbGVcbiAgICAgICAgICAgIGlmICh6ID09PSBvcHRpb25zLmluZGV4TWF4Wm9vbSB8fCB0aWxlLm51bVBvaW50cyA8PSBvcHRpb25zLmluZGV4TWF4UG9pbnRzKSBjb250aW51ZTtcblxuICAgICAgICAvLyBpZiBhIGRyaWxsZG93biB0byBhIHNwZWNpZmljIHRpbGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN0b3AgdGlsaW5nIGlmIHdlIHJlYWNoZWQgYmFzZSB6b29tIG9yIG91ciB0YXJnZXQgdGlsZSB6b29tXG4gICAgICAgICAgICBpZiAoeiA9PT0gb3B0aW9ucy5tYXhab29tIHx8IHogPT09IGN6KSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gc3RvcCB0aWxpbmcgaWYgaXQncyBub3QgYW4gYW5jZXN0b3Igb2YgdGhlIHRhcmdldCB0aWxlXG4gICAgICAgICAgICB2YXIgbSA9IDEgPDwgKGN6IC0geik7XG4gICAgICAgICAgICBpZiAoeCAhPT0gTWF0aC5mbG9vcihjeCAvIG0pIHx8IHkgIT09IE1hdGguZmxvb3IoY3kgLyBtKSkgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBzbGljZSBmdXJ0aGVyIGRvd24sIG5vIG5lZWQgdG8ga2VlcCBzb3VyY2UgZ2VvbWV0cnlcbiAgICAgICAgdGlsZS5zb3VyY2UgPSBudWxsO1xuXG4gICAgICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUudGltZSgnY2xpcHBpbmcnKTtcblxuICAgICAgICAvLyB2YWx1ZXMgd2UnbGwgdXNlIGZvciBjbGlwcGluZ1xuICAgICAgICB2YXIgazEgPSAwLjUgKiBvcHRpb25zLmJ1ZmZlciAvIG9wdGlvbnMuZXh0ZW50LFxuICAgICAgICAgICAgazIgPSAwLjUgLSBrMSxcbiAgICAgICAgICAgIGszID0gMC41ICsgazEsXG4gICAgICAgICAgICBrNCA9IDEgKyBrMSxcbiAgICAgICAgICAgIHRsLCBibCwgdHIsIGJyLCBsZWZ0LCByaWdodDtcblxuICAgICAgICB0bCA9IGJsID0gdHIgPSBiciA9IG51bGw7XG5cbiAgICAgICAgbGVmdCAgPSBjbGlwKGZlYXR1cmVzLCB6MiwgeCAtIGsxLCB4ICsgazMsIDAsIGludGVyc2VjdFgsIHRpbGUubWluWzBdLCB0aWxlLm1heFswXSk7XG4gICAgICAgIHJpZ2h0ID0gY2xpcChmZWF0dXJlcywgejIsIHggKyBrMiwgeCArIGs0LCAwLCBpbnRlcnNlY3RYLCB0aWxlLm1pblswXSwgdGlsZS5tYXhbMF0pO1xuXG4gICAgICAgIGlmIChsZWZ0KSB7XG4gICAgICAgICAgICB0bCA9IGNsaXAobGVmdCwgejIsIHkgLSBrMSwgeSArIGszLCAxLCBpbnRlcnNlY3RZLCB0aWxlLm1pblsxXSwgdGlsZS5tYXhbMV0pO1xuICAgICAgICAgICAgYmwgPSBjbGlwKGxlZnQsIHoyLCB5ICsgazIsIHkgKyBrNCwgMSwgaW50ZXJzZWN0WSwgdGlsZS5taW5bMV0sIHRpbGUubWF4WzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgdHIgPSBjbGlwKHJpZ2h0LCB6MiwgeSAtIGsxLCB5ICsgazMsIDEsIGludGVyc2VjdFksIHRpbGUubWluWzFdLCB0aWxlLm1heFsxXSk7XG4gICAgICAgICAgICBiciA9IGNsaXAocmlnaHQsIHoyLCB5ICsgazIsIHkgKyBrNCwgMSwgaW50ZXJzZWN0WSwgdGlsZS5taW5bMV0sIHRpbGUubWF4WzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUudGltZUVuZCgnY2xpcHBpbmcnKTtcblxuICAgICAgICBpZiAodGwpIHN0YWNrLnB1c2godGwsIHogKyAxLCB4ICogMiwgICAgIHkgKiAyKTtcbiAgICAgICAgaWYgKGJsKSBzdGFjay5wdXNoKGJsLCB6ICsgMSwgeCAqIDIsICAgICB5ICogMiArIDEpO1xuICAgICAgICBpZiAodHIpIHN0YWNrLnB1c2godHIsIHogKyAxLCB4ICogMiArIDEsIHkgKiAyKTtcbiAgICAgICAgaWYgKGJyKSBzdGFjay5wdXNoKGJyLCB6ICsgMSwgeCAqIDIgKyAxLCB5ICogMiArIDEpO1xuICAgIH1cbn07XG5cbkdlb0pTT05WVC5wcm90b3R5cGUuZ2V0VGlsZSA9IGZ1bmN0aW9uICh6LCB4LCB5KSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGV4dGVudCA9IG9wdGlvbnMuZXh0ZW50LFxuICAgICAgICBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG5cbiAgICB2YXIgejIgPSAxIDw8IHo7XG4gICAgeCA9ICgoeCAlIHoyKSArIHoyKSAlIHoyOyAvLyB3cmFwIHRpbGUgeCBjb29yZGluYXRlXG5cbiAgICB2YXIgaWQgPSB0b0lEKHosIHgsIHkpO1xuICAgIGlmICh0aGlzLnRpbGVzW2lkXSkgcmV0dXJuIHRyYW5zZm9ybVRpbGUodGhpcy50aWxlc1tpZF0sIGV4dGVudCk7XG5cbiAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLmxvZygnZHJpbGxpbmcgZG93biB0byB6JWQtJWQtJWQnLCB6LCB4LCB5KTtcblxuICAgIHZhciB6MCA9IHosXG4gICAgICAgIHgwID0geCxcbiAgICAgICAgeTAgPSB5LFxuICAgICAgICBwYXJlbnQ7XG5cbiAgICB3aGlsZSAoIXBhcmVudCAmJiB6MCA+IDApIHtcbiAgICAgICAgejAtLTtcbiAgICAgICAgeDAgPSBNYXRoLmZsb29yKHgwIC8gMik7XG4gICAgICAgIHkwID0gTWF0aC5mbG9vcih5MCAvIDIpO1xuICAgICAgICBwYXJlbnQgPSB0aGlzLnRpbGVzW3RvSUQoejAsIHgwLCB5MCldO1xuICAgIH1cblxuICAgIGlmICghcGFyZW50KSByZXR1cm4gbnVsbDtcblxuICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUubG9nKCdmb3VuZCBwYXJlbnQgdGlsZSB6JWQtJWQtJWQnLCB6MCwgeDAsIHkwKTtcblxuICAgIC8vIGlmIHdlIGZvdW5kIGEgcGFyZW50IHRpbGUgY29udGFpbmluZyB0aGUgb3JpZ2luYWwgZ2VvbWV0cnksIHdlIGNhbiBkcmlsbCBkb3duIGZyb20gaXRcbiAgICBpZiAocGFyZW50LnNvdXJjZSkge1xuICAgICAgICBpZiAoaXNDbGlwcGVkU3F1YXJlKHBhcmVudCwgZXh0ZW50LCBvcHRpb25zLmJ1ZmZlcikpIHJldHVybiB0cmFuc2Zvcm1UaWxlKHBhcmVudCwgZXh0ZW50KTtcblxuICAgICAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLnRpbWUoJ2RyaWxsaW5nIGRvd24nKTtcbiAgICAgICAgdGhpcy5zcGxpdFRpbGUocGFyZW50LnNvdXJjZSwgejAsIHgwLCB5MCwgeiwgeCwgeSk7XG4gICAgICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUudGltZUVuZCgnZHJpbGxpbmcgZG93bicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy50aWxlc1tpZF0pIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIHRyYW5zZm9ybVRpbGUodGhpcy50aWxlc1tpZF0sIGV4dGVudCk7XG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1UaWxlKHRpbGUsIGV4dGVudCkge1xuICAgIGlmICh0aWxlLnRyYW5zZm9ybWVkKSByZXR1cm4gdGlsZTtcblxuICAgIHZhciB6MiA9IHRpbGUuejIsXG4gICAgICAgIHR4ID0gdGlsZS54LFxuICAgICAgICB0eSA9IHRpbGUueSxcbiAgICAgICAgaSwgaiwgaztcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aWxlLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gdGlsZS5mZWF0dXJlc1tpXSxcbiAgICAgICAgICAgIGdlb20gPSBmZWF0dXJlLmdlb21ldHJ5LFxuICAgICAgICAgICAgdHlwZSA9IGZlYXR1cmUudHlwZTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdlb20ubGVuZ3RoOyBqKyspIGdlb21bal0gPSB0cmFuc2Zvcm1Qb2ludChnZW9tW2pdLCBleHRlbnQsIHoyLCB0eCwgdHkpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2VvbS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciByaW5nID0gZ2VvbVtqXTtcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgcmluZy5sZW5ndGg7IGsrKykgcmluZ1trXSA9IHRyYW5zZm9ybVBvaW50KHJpbmdba10sIGV4dGVudCwgejIsIHR4LCB0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aWxlLnRyYW5zZm9ybWVkID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aWxlO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludChwLCBleHRlbnQsIHoyLCB0eCwgdHkpIHtcbiAgICB2YXIgeCA9IE1hdGgucm91bmQoZXh0ZW50ICogKHBbMF0gKiB6MiAtIHR4KSksXG4gICAgICAgIHkgPSBNYXRoLnJvdW5kKGV4dGVudCAqIChwWzFdICogejIgLSB0eSkpO1xuICAgIHJldHVybiBbeCwgeV07XG59XG5cbmZ1bmN0aW9uIHRvSUQoeiwgeCwgeSkge1xuICAgIHJldHVybiAoKCgxIDw8IHopICogeSArIHgpICogMzIpICsgejtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0WChhLCBiLCB4KSB7XG4gICAgcmV0dXJuIFt4LCAoeCAtIGFbMF0pICogKGJbMV0gLSBhWzFdKSAvIChiWzBdIC0gYVswXSkgKyBhWzFdLCAxXTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdFkoYSwgYiwgeSkge1xuICAgIHJldHVybiBbKHkgLSBhWzFdKSAqIChiWzBdIC0gYVswXSkgLyAoYlsxXSAtIGFbMV0pICsgYVswXSwgeSwgMV07XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMpIHtcbiAgICBmb3IgKHZhciBpIGluIHNyYykgZGVzdFtpXSA9IHNyY1tpXTtcbiAgICByZXR1cm4gZGVzdDtcbn1cblxuLy8gY2hlY2tzIHdoZXRoZXIgYSB0aWxlIGlzIGEgd2hvbGUtYXJlYSBmaWxsIGFmdGVyIGNsaXBwaW5nOyBpZiBpdCBpcywgdGhlcmUncyBubyBzZW5zZSBzbGljaW5nIGl0IGZ1cnRoZXJcbmZ1bmN0aW9uIGlzQ2xpcHBlZFNxdWFyZSh0aWxlLCBleHRlbnQsIGJ1ZmZlcikge1xuXG4gICAgdmFyIGZlYXR1cmVzID0gdGlsZS5zb3VyY2U7XG4gICAgaWYgKGZlYXR1cmVzLmxlbmd0aCAhPT0gMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlc1swXTtcbiAgICBpZiAoZmVhdHVyZS50eXBlICE9PSAzIHx8IGZlYXR1cmUuZ2VvbWV0cnkubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbiA9IGZlYXR1cmUuZ2VvbWV0cnlbMF0ubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IDUpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSB0cmFuc2Zvcm1Qb2ludChmZWF0dXJlLmdlb21ldHJ5WzBdW2ldLCBleHRlbnQsIHRpbGUuejIsIHRpbGUueCwgdGlsZS55KTtcbiAgICAgICAgaWYgKChwWzBdICE9PSAtYnVmZmVyICYmIHBbMF0gIT09IGV4dGVudCArIGJ1ZmZlcikgfHxcbiAgICAgICAgICAgIChwWzFdICE9PSAtYnVmZmVyICYmIHBbMV0gIT09IGV4dGVudCArIGJ1ZmZlcikpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBzaW1wbGlmeTtcblxuLy8gY2FsY3VsYXRlIHNpbXBsaWZpY2F0aW9uIGRhdGEgdXNpbmcgb3B0aW1pemVkIERvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1cblxuZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UpIHtcblxuICAgIHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZSxcbiAgICAgICAgbGVuID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgZmlyc3QgPSAwLFxuICAgICAgICBsYXN0ID0gbGVuIC0gMSxcbiAgICAgICAgc3RhY2sgPSBbXSxcbiAgICAgICAgaSwgbWF4U3FEaXN0LCBzcURpc3QsIGluZGV4O1xuXG4gICAgLy8gYWx3YXlzIHJldGFpbiB0aGUgZW5kcG9pbnRzICgxIGlzIHRoZSBtYXggdmFsdWUpXG4gICAgcG9pbnRzW2ZpcnN0XVsyXSA9IDE7XG4gICAgcG9pbnRzW2xhc3RdWzJdID0gMTtcblxuICAgIC8vIGF2b2lkIHJlY3Vyc2lvbiBieSB1c2luZyBhIHN0YWNrXG4gICAgd2hpbGUgKGxhc3QpIHtcblxuICAgICAgICBtYXhTcURpc3QgPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgc3FEaXN0ID0gZ2V0U3FTZWdEaXN0KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdKTtcblxuICAgICAgICAgICAgaWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBtYXhTcURpc3QgPSBzcURpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHBvaW50c1tpbmRleF1bMl0gPSBtYXhTcURpc3Q7IC8vIHNhdmUgdGhlIHBvaW50IGltcG9ydGFuY2UgaW4gc3F1YXJlZCBwaXhlbHMgYXMgYSB6IGNvb3JkaW5hdGVcbiAgICAgICAgICAgIHN0YWNrLnB1c2goZmlyc3QpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChpbmRleCk7XG4gICAgICAgICAgICBmaXJzdCA9IGluZGV4O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBmaXJzdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBzcXVhcmUgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgc2VnbWVudFxuZnVuY3Rpb24gZ2V0U3FTZWdEaXN0KHAsIGEsIGIpIHtcblxuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLFxuICAgICAgICBweCA9IHBbMF0sIHB5ID0gcFsxXSxcbiAgICAgICAgZHggPSBieCAtIHgsXG4gICAgICAgIGR5ID0gYnkgLSB5O1xuXG4gICAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG5cbiAgICAgICAgdmFyIHQgPSAoKHB4IC0geCkgKiBkeCArIChweSAtIHkpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICBpZiAodCA+IDEpIHtcbiAgICAgICAgICAgIHggPSBieDtcbiAgICAgICAgICAgIHkgPSBieTtcblxuICAgICAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICAgICAgICB4ICs9IGR4ICogdDtcbiAgICAgICAgICAgIHkgKz0gZHkgKiB0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHggPSBweCAtIHg7XG4gICAgZHkgPSBweSAtIHk7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVGlsZTtcblxuZnVuY3Rpb24gY3JlYXRlVGlsZShmZWF0dXJlcywgejIsIHR4LCB0eSwgdG9sZXJhbmNlLCBub1NpbXBsaWZ5KSB7XG4gICAgdmFyIHRpbGUgPSB7XG4gICAgICAgIGZlYXR1cmVzOiBbXSxcbiAgICAgICAgbnVtUG9pbnRzOiAwLFxuICAgICAgICBudW1TaW1wbGlmaWVkOiAwLFxuICAgICAgICBudW1GZWF0dXJlczogMCxcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICB4OiB0eCxcbiAgICAgICAgeTogdHksXG4gICAgICAgIHoyOiB6MixcbiAgICAgICAgdHJhbnNmb3JtZWQ6IGZhbHNlLFxuICAgICAgICBtaW46IFsyLCAxXSxcbiAgICAgICAgbWF4OiBbLTEsIDBdXG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRpbGUubnVtRmVhdHVyZXMrKztcbiAgICAgICAgYWRkRmVhdHVyZSh0aWxlLCBmZWF0dXJlc1tpXSwgdG9sZXJhbmNlLCBub1NpbXBsaWZ5KTtcblxuICAgICAgICB2YXIgbWluID0gZmVhdHVyZXNbaV0ubWluLFxuICAgICAgICAgICAgbWF4ID0gZmVhdHVyZXNbaV0ubWF4O1xuXG4gICAgICAgIGlmIChtaW5bMF0gPCB0aWxlLm1pblswXSkgdGlsZS5taW5bMF0gPSBtaW5bMF07XG4gICAgICAgIGlmIChtaW5bMV0gPCB0aWxlLm1pblsxXSkgdGlsZS5taW5bMV0gPSBtaW5bMV07XG4gICAgICAgIGlmIChtYXhbMF0gPiB0aWxlLm1heFswXSkgdGlsZS5tYXhbMF0gPSBtYXhbMF07XG4gICAgICAgIGlmIChtYXhbMV0gPiB0aWxlLm1heFsxXSkgdGlsZS5tYXhbMV0gPSBtYXhbMV07XG4gICAgfVxuICAgIHJldHVybiB0aWxlO1xufVxuXG5mdW5jdGlvbiBhZGRGZWF0dXJlKHRpbGUsIGZlYXR1cmUsIHRvbGVyYW5jZSwgbm9TaW1wbGlmeSkge1xuXG4gICAgdmFyIGdlb20gPSBmZWF0dXJlLmdlb21ldHJ5LFxuICAgICAgICB0eXBlID0gZmVhdHVyZS50eXBlLFxuICAgICAgICBzaW1wbGlmaWVkID0gW10sXG4gICAgICAgIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlLFxuICAgICAgICBpLCBqLCByaW5nLCBwO1xuXG4gICAgaWYgKHR5cGUgPT09IDEpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdlb20ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNpbXBsaWZpZWQucHVzaChnZW9tW2ldKTtcbiAgICAgICAgICAgIHRpbGUubnVtUG9pbnRzKys7XG4gICAgICAgICAgICB0aWxlLm51bVNpbXBsaWZpZWQrKztcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBzaW1wbGlmeSBhbmQgdHJhbnNmb3JtIHByb2plY3RlZCBjb29yZGluYXRlcyBmb3IgdGlsZSBnZW9tZXRyeVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ2VvbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmluZyA9IGdlb21baV07XG5cbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgdGlueSBwb2x5bGluZXMgJiBwb2x5Z29uc1xuICAgICAgICAgICAgaWYgKCFub1NpbXBsaWZ5ICYmICgodHlwZSA9PT0gMiAmJiByaW5nLmRpc3QgPCB0b2xlcmFuY2UpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlID09PSAzICYmIHJpbmcuYXJlYSA8IHNxVG9sZXJhbmNlKSkpIHtcbiAgICAgICAgICAgICAgICB0aWxlLm51bVBvaW50cyArPSByaW5nLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNpbXBsaWZpZWRSaW5nID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCByaW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcCA9IHJpbmdbal07XG4gICAgICAgICAgICAgICAgLy8ga2VlcCBwb2ludHMgd2l0aCBpbXBvcnRhbmNlID4gdG9sZXJhbmNlXG4gICAgICAgICAgICAgICAgaWYgKG5vU2ltcGxpZnkgfHwgcFsyXSA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbXBsaWZpZWRSaW5nLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbGUubnVtU2ltcGxpZmllZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aWxlLm51bVBvaW50cysrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzaW1wbGlmaWVkLnB1c2goc2ltcGxpZmllZFJpbmcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNpbXBsaWZpZWQubGVuZ3RoKSB7XG4gICAgICAgIHRpbGUuZmVhdHVyZXMucHVzaCh7XG4gICAgICAgICAgICBnZW9tZXRyeTogc2ltcGxpZmllZCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB0YWdzOiBmZWF0dXJlLnRhZ3MgfHwgbnVsbFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjbGlwID0gcmVxdWlyZSgnLi9jbGlwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gd3JhcDtcblxuZnVuY3Rpb24gd3JhcChmZWF0dXJlcywgYnVmZmVyLCBpbnRlcnNlY3RYKSB7XG4gICAgdmFyIG1lcmdlZCA9IGZlYXR1cmVzLFxuICAgICAgICBsZWZ0ICA9IGNsaXAoZmVhdHVyZXMsIDEsIC0xIC0gYnVmZmVyLCBidWZmZXIsICAgICAwLCBpbnRlcnNlY3RYLCAtMSwgMiksIC8vIGxlZnQgd29ybGQgY29weVxuICAgICAgICByaWdodCA9IGNsaXAoZmVhdHVyZXMsIDEsICAxIC0gYnVmZmVyLCAyICsgYnVmZmVyLCAwLCBpbnRlcnNlY3RYLCAtMSwgMik7IC8vIHJpZ2h0IHdvcmxkIGNvcHlcblxuICAgIGlmIChsZWZ0IHx8IHJpZ2h0KSB7XG4gICAgICAgIG1lcmdlZCA9IGNsaXAoZmVhdHVyZXMsIDEsIC1idWZmZXIsIDEgKyBidWZmZXIsIDAsIGludGVyc2VjdFgsIC0xLCAyKTsgLy8gY2VudGVyIHdvcmxkIGNvcHlcblxuICAgICAgICBpZiAobGVmdCkgbWVyZ2VkID0gc2hpZnRGZWF0dXJlQ29vcmRzKGxlZnQsIDEpLmNvbmNhdChtZXJnZWQpOyAvLyBtZXJnZSBsZWZ0IGludG8gY2VudGVyXG4gICAgICAgIGlmIChyaWdodCkgbWVyZ2VkID0gbWVyZ2VkLmNvbmNhdChzaGlmdEZlYXR1cmVDb29yZHMocmlnaHQsIC0xKSk7IC8vIG1lcmdlIHJpZ2h0IGludG8gY2VudGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cblxuZnVuY3Rpb24gc2hpZnRGZWF0dXJlQ29vcmRzKGZlYXR1cmVzLCBvZmZzZXQpIHtcbiAgICB2YXIgbmV3RmVhdHVyZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlc1tpXSxcbiAgICAgICAgICAgIHR5cGUgPSBmZWF0dXJlLnR5cGU7XG5cbiAgICAgICAgdmFyIG5ld0dlb21ldHJ5O1xuXG4gICAgICAgIGlmICh0eXBlID09PSAxKSB7XG4gICAgICAgICAgICBuZXdHZW9tZXRyeSA9IHNoaWZ0Q29vcmRzKGZlYXR1cmUuZ2VvbWV0cnksIG9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdHZW9tZXRyeSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmZWF0dXJlLmdlb21ldHJ5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbmV3R2VvbWV0cnkucHVzaChzaGlmdENvb3JkcyhmZWF0dXJlLmdlb21ldHJ5W2pdLCBvZmZzZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0ZlYXR1cmVzLnB1c2goe1xuICAgICAgICAgICAgZ2VvbWV0cnk6IG5ld0dlb21ldHJ5LFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHRhZ3M6IGZlYXR1cmUudGFncyxcbiAgICAgICAgICAgIG1pbjogW2ZlYXR1cmUubWluWzBdICsgb2Zmc2V0LCBmZWF0dXJlLm1pblsxXV0sXG4gICAgICAgICAgICBtYXg6IFtmZWF0dXJlLm1heFswXSArIG9mZnNldCwgZmVhdHVyZS5tYXhbMV1dXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdGZWF0dXJlcztcbn1cblxuZnVuY3Rpb24gc2hpZnRDb29yZHMocG9pbnRzLCBvZmZzZXQpIHtcbiAgICB2YXIgbmV3UG9pbnRzID0gW107XG4gICAgbmV3UG9pbnRzLmFyZWEgPSBwb2ludHMuYXJlYTtcbiAgICBuZXdQb2ludHMuZGlzdCA9IHBvaW50cy5kaXN0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3UG9pbnRzLnB1c2goW3BvaW50c1tpXVswXSArIG9mZnNldCwgcG9pbnRzW2ldWzFdLCBwb2ludHNbaV1bMl1dKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1BvaW50cztcbn1cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBnbC1tYXRyaXggLSBIaWdoIHBlcmZvcm1hbmNlIG1hdHJpeCBhbmQgdmVjdG9yIG9wZXJhdGlvbnNcbiAqIEBhdXRob3IgQnJhbmRvbiBKb25lc1xuICogQGF1dGhvciBDb2xpbiBNYWNLZW56aWUgSVZcbiAqIEB2ZXJzaW9uIDIuMi4xXG4gKi9cblxuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cblxuKGZ1bmN0aW9uKF9nbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIHNoaW0gPSB7fTtcbiAgaWYgKHR5cGVvZihleHBvcnRzKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZih0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgc2hpbS5leHBvcnRzID0ge307XG4gICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzaGltLmV4cG9ydHM7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2wtbWF0cml4IGxpdmVzIGluIGEgYnJvd3NlciwgZGVmaW5lIGl0cyBuYW1lc3BhY2VzIGluIGdsb2JhbFxuICAgICAgc2hpbS5leHBvcnRzID0gdHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogX2dsb2JhbDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZ2wtbWF0cml4IGxpdmVzIGluIGNvbW1vbmpzLCBkZWZpbmUgaXRzIG5hbWVzcGFjZXMgaW4gZXhwb3J0c1xuICAgIHNoaW0uZXhwb3J0cyA9IGV4cG9ydHM7XG4gIH1cblxuICAoZnVuY3Rpb24oZXhwb3J0cykge1xuICAgIC8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cblxuaWYoIUdMTUFUX0VQU0lMT04pIHtcbiAgICB2YXIgR0xNQVRfRVBTSUxPTiA9IDAuMDAwMDAxO1xufVxuXG5pZighR0xNQVRfQVJSQVlfVFlQRSkge1xuICAgIHZhciBHTE1BVF9BUlJBWV9UWVBFID0gKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKSA/IEZsb2F0MzJBcnJheSA6IEFycmF5O1xufVxuXG5pZighR0xNQVRfUkFORE9NKSB7XG4gICAgdmFyIEdMTUFUX1JBTkRPTSA9IE1hdGgucmFuZG9tO1xufVxuXG4vKipcbiAqIEBjbGFzcyBDb21tb24gdXRpbGl0aWVzXG4gKiBAbmFtZSBnbE1hdHJpeFxuICovXG52YXIgZ2xNYXRyaXggPSB7fTtcblxuLyoqXG4gKiBTZXRzIHRoZSB0eXBlIG9mIGFycmF5IHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmVjdG9ycyBhbmQgbWF0cmljaWVzXG4gKlxuICogQHBhcmFtIHtUeXBlfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XG4gKi9cbmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBHTE1BVF9BUlJBWV9UWVBFID0gdHlwZTtcbn1cblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMuZ2xNYXRyaXggPSBnbE1hdHJpeDtcbn1cblxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG5cbi8qKlxuKiBDb252ZXJ0IERlZ3JlZSBUbyBSYWRpYW5cbipcbiogQHBhcmFtIHtOdW1iZXJ9IEFuZ2xlIGluIERlZ3JlZXNcbiovXG5nbE1hdHJpeC50b1JhZGlhbiA9IGZ1bmN0aW9uKGEpe1xuICAgICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIDIgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWMyXG4gKi9cblxudmFyIHZlYzIgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKlxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSkge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zdWIgPSB2ZWMyLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLm11bCA9IHZlYzIubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5kaXYgPSB2ZWMyLmRpdmlkZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc2NhbGVBbmRBZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5kaXN0ID0gdmVjMi5kaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuc3FyRGlzdCA9IHZlYzIuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzIubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmxlbiA9IHZlYzIubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbnZlYzIuc3F1YXJlZExlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLnNxckxlbiA9IHZlYzIuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5Knk7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzIuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICogTm90ZSB0aGF0IHRoZSBjcm9zcyBwcm9kdWN0IG11c3QgYnkgZGVmaW5pdGlvbiBwcm9kdWNlIGEgM0QgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMyLmNyb3NzID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICAgIG91dFswXSA9IG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gICAgdmFyIHIgPSBHTE1BVF9SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZTtcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MiA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQyZCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDN9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MyA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0NFxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMCdcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVsxMl07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMi5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAndmVjMignICsgYVswXSArICcsICcgKyBhWzFdICsgJyknO1xufTtcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMudmVjMiA9IHZlYzI7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyAzIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjM1xuICovXG5cbnZhciB2ZWMzID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5LCB6KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3ViID0gdmVjMy5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5tdWwgPSB2ZWMzLm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZGl2ID0gdmVjMy5kaXZpZGU7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMzLmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZGlzdCA9IHZlYzMuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMzLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3FyRGlzdCA9IHZlYzMuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzMubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5sZW4gPSB2ZWMzLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMzLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Kno7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3FyTGVuID0gdmVjMy5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6Kno7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgICAgICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzMuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmNyb3NzID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl07XG5cbiAgICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcblxuICAgIHZhciByID0gR0xNQVRfUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICAgIHZhciB6ID0gKEdMTUFUX1JBTkRPTSgpICogMi4wKSAtIDEuMDtcbiAgICB2YXIgelNjYWxlID0gTWF0aC5zcXJ0KDEuMC16KnopICogc2NhbGU7XG5cbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZTtcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcbiAgICBvdXRbMl0gPSB6ICogc2NhbGU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXTtcbiAgICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy50cmFuc2Zvcm1NYXQzID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gICAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdO1xuICAgIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIC8vIGJlbmNobWFya3M6IGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tdHJhbnNmb3JtLXZlYzMtaW1wbGVtZW50YXRpb25zXG5cbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdLFxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gICAgICAgIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5LFxuICAgICAgICBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcbiAgICAgICAgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXG4gICAgICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gICAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLypcbiogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeC1heGlzXG4qIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4qIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiogQHJldHVybnMge3ZlYzN9IG91dFxuKi9cbnZlYzMucm90YXRlWCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gICB2YXIgcCA9IFtdLCByPVtdO1xuXHQgIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblx0ICBwWzBdID0gYVswXSAtIGJbMF07XG5cdCAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcblxuXHQgIC8vcGVyZm9ybSByb3RhdGlvblxuXHQgIHJbMF0gPSBwWzBdO1xuXHQgIHJbMV0gPSBwWzFdKk1hdGguY29zKGMpIC0gcFsyXSpNYXRoLnNpbihjKTtcblx0ICByWzJdID0gcFsxXSpNYXRoLnNpbihjKSArIHBbMl0qTWF0aC5jb3MoYyk7XG5cblx0ICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cdCAgb3V0WzBdID0gclswXSArIGJbMF07XG5cdCAgb3V0WzFdID0gclsxXSArIGJbMV07XG5cdCAgb3V0WzJdID0gclsyXSArIGJbMl07XG5cbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLypcbiogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeS1heGlzXG4qIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4qIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiogQHJldHVybnMge3ZlYzN9IG91dFxuKi9cbnZlYzMucm90YXRlWSA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gIFx0dmFyIHAgPSBbXSwgcj1bXTtcbiAgXHQvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIFx0cFswXSA9IGFbMF0gLSBiWzBdO1xuICBcdHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgXHRwWzJdID0gYVsyXSAtIGJbMl07XG4gIFxuICBcdC8vcGVyZm9ybSByb3RhdGlvblxuICBcdHJbMF0gPSBwWzJdKk1hdGguc2luKGMpICsgcFswXSpNYXRoLmNvcyhjKTtcbiAgXHRyWzFdID0gcFsxXTtcbiAgXHRyWzJdID0gcFsyXSpNYXRoLmNvcyhjKSAtIHBbMF0qTWF0aC5zaW4oYyk7XG4gIFxuICBcdC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgXHRvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgXHRvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgXHRvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgXG4gIFx0cmV0dXJuIG91dDtcbn07XG5cbi8qXG4qIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4qIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiovXG52ZWMzLnJvdGF0ZVogPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICBcdHZhciBwID0gW10sIHI9W107XG4gIFx0Ly9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgXHRwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuICBcbiAgXHQvL3BlcmZvcm0gcm90YXRpb25cbiAgXHRyWzBdID0gcFswXSpNYXRoLmNvcyhjKSAtIHBbMV0qTWF0aC5zaW4oYyk7XG4gIFx0clsxXSA9IHBbMF0qTWF0aC5zaW4oYykgKyBwWzFdKk1hdGguY29zKGMpO1xuICBcdHJbMl0gPSBwWzJdO1xuICBcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIFx0b3V0WzBdID0gclswXSArIGJbMF07XG4gIFx0b3V0WzFdID0gclsxXSArIGJbMV07XG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XG4gIFxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjMy5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDM7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTsgdmVjWzJdID0gYVtpKzJdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07IGFbaSsyXSA9IHZlY1syXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzMuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzMoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJyknO1xufTtcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMudmVjMyA9IHZlYzM7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyA0IERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjNFxuICovXG5cbnZhciB2ZWM0ID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjNFxuICpcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHksIHosIHcpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjNCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSwgeiwgdykge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuc3ViID0gdmVjNC5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICogYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5tdWwgPSB2ZWM0Lm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC8gYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZGl2ID0gdmVjNC5kaXZpZGU7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICAgIG91dFszXSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWM0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIG91dFszXSA9IGFbM10gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjNC5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZGlzdCA9IHZlYzQuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWM0LnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zcXJEaXN0ID0gdmVjNC5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjNC5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5sZW4gPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWM0LnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnNxckxlbiA9IHZlYzQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9IC1hWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXSxcbiAgICAgICAgdyA9IGFbM107XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqeiArIHcqdztcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gICAgICAgIG91dFszXSA9IGFbM10gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjNC5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl0gKyBhWzNdICogYlszXTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV0sXG4gICAgICAgIGF6ID0gYVsyXSxcbiAgICAgICAgYXcgPSBhWzNdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICAgIG91dFszXSA9IGF3ICsgdCAqIChiWzNdIC0gYXcpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcblxuICAgIC8vVE9ETzogVGhpcyBpcyBhIHByZXR0eSBhd2Z1bCB3YXkgb2YgZG9pbmcgdGhpcy4gRmluZCBzb21ldGhpbmcgYmV0dGVyLlxuICAgIG91dFswXSA9IEdMTUFUX1JBTkRPTSgpO1xuICAgIG91dFsxXSA9IEdMTUFUX1JBTkRPTSgpO1xuICAgIG91dFsyXSA9IEdMTUFUX1JBTkRPTSgpO1xuICAgIG91dFszXSA9IEdMTUFUX1JBTkRPTSgpO1xuICAgIHZlYzQubm9ybWFsaXplKG91dCwgb3V0KTtcbiAgICB2ZWM0LnNjYWxlKG91dCwgb3V0LCBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgbWF0NC5cbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLCB3ID0gYVszXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSAqIHc7XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10gKiB3O1xuICAgIG91dFsyXSA9IG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSAqIHc7XG4gICAgb3V0WzNdID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdICogdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC50cmFuc2Zvcm1RdWF0ID0gZnVuY3Rpb24ob3V0LCBhLCBxKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgICAgIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzQuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWM0LmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gNDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07IHZlY1szXSA9IGFbaSszXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07IGFbaSszXSA9IHZlY1szXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy52ZWM0ID0gdmVjNDtcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIDJ4MiBNYXRyaXhcbiAqIEBuYW1lIG1hdDJcbiAqL1xuXG52YXIgbWF0MiA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MlxuICpcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbm1hdDIuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xubWF0Mi5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDIgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTEgPSBhWzFdO1xuICAgICAgICBvdXRbMV0gPSBhWzJdO1xuICAgICAgICBvdXRbMl0gPSBhMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzJdO1xuICAgICAgICBvdXRbMl0gPSBhWzFdO1xuICAgICAgICBvdXRbM10gPSBhWzNdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYTAgKiBhMyAtIGEyICogYTE7XG5cbiAgICBpZiAoIWRldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuICAgIFxuICAgIG91dFswXSA9ICBhMyAqIGRldDtcbiAgICBvdXRbMV0gPSAtYTEgKiBkZXQ7XG4gICAgb3V0WzJdID0gLWEyICogZGV0O1xuICAgIG91dFszXSA9ICBhMCAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gQ2FjaGluZyB0aGlzIHZhbHVlIGlzIG5lc3NlY2FyeSBpZiBvdXQgPT0gYVxuICAgIHZhciBhMCA9IGFbMF07XG4gICAgb3V0WzBdID0gIGFbM107XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgb3V0WzNdID0gIGEwO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDIuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdO1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICAgIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICAgIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICAgIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICAgIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyLm11bCA9IG1hdDIubXVsdGlwbHk7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogcztcbiAgICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzO1xuICAgIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gICAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICoqL1xubWF0Mi5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICAgIG91dFswXSA9IGEwICogdjA7XG4gICAgb3V0WzFdID0gYTEgKiB2MDtcbiAgICBvdXRbMl0gPSBhMiAqIHYxO1xuICAgIG91dFszXSA9IGEzICogdjE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0Mi5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpKSlcbn07XG5cbi8qKlxuICogUmV0dXJucyBMLCBEIGFuZCBVIG1hdHJpY2VzIChMb3dlciB0cmlhbmd1bGFyLCBEaWFnb25hbCBhbmQgVXBwZXIgdHJpYW5ndWxhcikgYnkgZmFjdG9yaXppbmcgdGhlIGlucHV0IG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gRCB0aGUgZGlhZ29uYWwgbWF0cml4IFxuICogQHBhcmFtIHttYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxuICovXG5cbm1hdDIuTERVID0gZnVuY3Rpb24gKEwsIEQsIFUsIGEpIHsgXG4gICAgTFsyXSA9IGFbMl0vYVswXTsgXG4gICAgVVswXSA9IGFbMF07IFxuICAgIFVbMV0gPSBhWzFdOyBcbiAgICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdOyBcbiAgICByZXR1cm4gW0wsIEQsIFVdOyAgICAgICBcbn07IFxuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5tYXQyID0gbWF0Mjtcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIDJ4MyBNYXRyaXhcbiAqIEBuYW1lIG1hdDJkXG4gKiBcbiAqIEBkZXNjcmlwdGlvbiBcbiAqIEEgbWF0MmQgY29udGFpbnMgc2l4IGVsZW1lbnRzIGRlZmluZWQgYXM6XG4gKiA8cHJlPlxuICogW2EsIGMsIHR4LFxuICogIGIsIGQsIHR5XVxuICogPC9wcmU+XG4gKiBUaGlzIGlzIGEgc2hvcnQgZm9ybSBmb3IgdGhlIDN4MyBtYXRyaXg6XG4gKiA8cHJlPlxuICogW2EsIGMsIHR4LFxuICogIGIsIGQsIHR5LFxuICogIDAsIDAsIDFdXG4gKiA8L3ByZT5cbiAqIFRoZSBsYXN0IHJvdyBpcyBpZ25vcmVkIHNvIHRoZSBhcnJheSBpcyBzaG9ydGVyIGFuZCBvcGVyYXRpb25zIGFyZSBmYXN0ZXIuXG4gKi9cblxudmFyIG1hdDJkID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyZFxuICpcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxuICovXG5tYXQyZC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQyZCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xubWF0MmQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDYpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyZCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MmQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhYSA9IGFbMF0sIGFiID0gYVsxXSwgYWMgPSBhWzJdLCBhZCA9IGFbM10sXG4gICAgICAgIGF0eCA9IGFbNF0sIGF0eSA9IGFbNV07XG5cbiAgICB2YXIgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG4gICAgaWYoIWRldCl7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgICBvdXRbMV0gPSAtYWIgKiBkZXQ7XG4gICAgb3V0WzJdID0gLWFjICogZGV0O1xuICAgIG91dFszXSA9IGFhICogZGV0O1xuICAgIG91dFs0XSA9IChhYyAqIGF0eSAtIGFkICogYXR4KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYWIgKiBhdHggLSBhYSAqIGF0eSkgKiBkZXQ7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0MmQuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhWzBdICogYVszXSAtIGFbMV0gKiBhWzJdO1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyZCdzXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXSwgYjQgPSBiWzRdLCBiNSA9IGJbNV07XG4gICAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gICAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gICAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gICAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gICAgb3V0WzRdID0gYTAgKiBiNCArIGEyICogYjUgKyBhNDtcbiAgICBvdXRbNV0gPSBhMSAqIGI0ICsgYTMgKiBiNSArIGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0MmQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0MmQubXVsID0gbWF0MmQubXVsdGlwbHk7XG5cblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MmQgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzO1xuICAgIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHM7XG4gICAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICAgIG91dFs0XSA9IGE0O1xuICAgIG91dFs1XSA9IGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICoqL1xubWF0MmQuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTAgKiB2MDtcbiAgICBvdXRbMV0gPSBhMSAqIHYwO1xuICAgIG91dFsyXSA9IGEyICogdjE7XG4gICAgb3V0WzNdID0gYTMgKiB2MTtcbiAgICBvdXRbNF0gPSBhNDtcbiAgICBvdXRbNV0gPSBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHRyYW5zbGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICoqL1xubWF0MmQudHJhbnNsYXRlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICAgIG91dFswXSA9IGEwO1xuICAgIG91dFsxXSA9IGExO1xuICAgIG91dFsyXSA9IGEyO1xuICAgIG91dFszXSA9IGEzO1xuICAgIG91dFs0XSA9IGEwICogdjAgKyBhMiAqIHYxICsgYTQ7XG4gICAgb3V0WzVdID0gYTEgKiB2MCArIGEzICogdjEgKyBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDJkLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQyZCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQyZC5mcm9iID0gZnVuY3Rpb24gKGEpIHsgXG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyAxKSlcbn07IFxuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5tYXQyZCA9IG1hdDJkO1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgM3gzIE1hdHJpeFxuICogQG5hbWUgbWF0M1xuICovXG5cbnZhciBtYXQzID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQzXG4gKlxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xubWF0My5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoOSk7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAxO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29waWVzIHRoZSB1cHBlci1sZWZ0IDN4MyB2YWx1ZXMgaW50byB0aGUgZ2l2ZW4gbWF0My5cbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIDN4MyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSAgIHRoZSBzb3VyY2UgNHg0IG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVs0XTtcbiAgICBvdXRbNF0gPSBhWzVdO1xuICAgIG91dFs1XSA9IGFbNl07XG4gICAgb3V0WzZdID0gYVs4XTtcbiAgICBvdXRbN10gPSBhWzldO1xuICAgIG91dFs4XSA9IGFbMTBdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XG4gKi9cbm1hdDMuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDkpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDE7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGExMiA9IGFbNV07XG4gICAgICAgIG91dFsxXSA9IGFbM107XG4gICAgICAgIG91dFsyXSA9IGFbNl07XG4gICAgICAgIG91dFszXSA9IGEwMTtcbiAgICAgICAgb3V0WzVdID0gYVs3XTtcbiAgICAgICAgb3V0WzZdID0gYTAyO1xuICAgICAgICBvdXRbN10gPSBhMTI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVszXTtcbiAgICAgICAgb3V0WzJdID0gYVs2XTtcbiAgICAgICAgb3V0WzNdID0gYVsxXTtcbiAgICAgICAgb3V0WzRdID0gYVs0XTtcbiAgICAgICAgb3V0WzVdID0gYVs3XTtcbiAgICAgICAgb3V0WzZdID0gYVsyXTtcbiAgICAgICAgb3V0WzddID0gYVs1XTtcbiAgICAgICAgb3V0WzhdID0gYVs4XTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxLFxuICAgICAgICBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwLFxuICAgICAgICBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjAsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSBiMDEgKiBkZXQ7XG4gICAgb3V0WzFdID0gKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0O1xuICAgIG91dFszXSA9IGIxMSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldDtcbiAgICBvdXRbNV0gPSAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQ7XG4gICAgb3V0WzZdID0gYjIxICogZGV0O1xuICAgIG91dFs3XSA9ICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGEyMiAtIGExMiAqIGEyMSk7XG4gICAgb3V0WzFdID0gKGEwMiAqIGEyMSAtIGEwMSAqIGEyMik7XG4gICAgb3V0WzJdID0gKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XG4gICAgb3V0WzNdID0gKGExMiAqIGEyMCAtIGExMCAqIGEyMik7XG4gICAgb3V0WzRdID0gKGEwMCAqIGEyMiAtIGEwMiAqIGEyMCk7XG4gICAgb3V0WzVdID0gKGEwMiAqIGExMCAtIGEwMCAqIGExMik7XG4gICAgb3V0WzZdID0gKGExMCAqIGEyMSAtIGExMSAqIGEyMCk7XG4gICAgb3V0WzddID0gKGEwMSAqIGEyMCAtIGEwMCAqIGEyMSk7XG4gICAgb3V0WzhdID0gKGEwMCAqIGExMSAtIGEwMSAqIGExMCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDMuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gICAgcmV0dXJuIGEwMCAqIChhMjIgKiBhMTEgLSBhMTIgKiBhMjEpICsgYTAxICogKC1hMjIgKiBhMTAgKyBhMTIgKiBhMjApICsgYTAyICogKGEyMSAqIGExMCAtIGExMSAqIGEyMCk7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDMnc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBiMDAgPSBiWzBdLCBiMDEgPSBiWzFdLCBiMDIgPSBiWzJdLFxuICAgICAgICBiMTAgPSBiWzNdLCBiMTEgPSBiWzRdLCBiMTIgPSBiWzVdLFxuICAgICAgICBiMjAgPSBiWzZdLCBiMjEgPSBiWzddLCBiMjIgPSBiWzhdO1xuXG4gICAgb3V0WzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICAgIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgICBvdXRbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XG5cbiAgICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gICAgb3V0WzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICAgIG91dFs1XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMjtcblxuICAgIG91dFs2XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMDtcbiAgICBvdXRbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gICAgb3V0WzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQzLm11bCA9IG1hdDMubXVsdGlwbHk7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0MyBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My50cmFuc2xhdGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcbiAgICAgICAgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gICAgb3V0WzBdID0gYTAwO1xuICAgIG91dFsxXSA9IGEwMTtcbiAgICBvdXRbMl0gPSBhMDI7XG5cbiAgICBvdXRbM10gPSBhMTA7XG4gICAgb3V0WzRdID0gYTExO1xuICAgIG91dFs1XSA9IGExMjtcblxuICAgIG91dFs2XSA9IHggKiBhMDAgKyB5ICogYTEwICsgYTIwO1xuICAgIG91dFs3XSA9IHggKiBhMDEgKyB5ICogYTExICsgYTIxO1xuICAgIG91dFs4XSA9IHggKiBhMDIgKyB5ICogYTEyICsgYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQzIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gICAgb3V0WzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XG4gICAgb3V0WzJdID0gYyAqIGEwMiArIHMgKiBhMTI7XG5cbiAgICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgICBvdXRbNF0gPSBjICogYTExIC0gcyAqIGEwMTtcbiAgICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcblxuICAgIG91dFs2XSA9IGEyMDtcbiAgICBvdXRbN10gPSBhMjE7XG4gICAgb3V0WzhdID0gYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5tYXQzLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXTtcblxuICAgIG91dFswXSA9IHggKiBhWzBdO1xuICAgIG91dFsxXSA9IHggKiBhWzFdO1xuICAgIG91dFsyXSA9IHggKiBhWzJdO1xuXG4gICAgb3V0WzNdID0geSAqIGFbM107XG4gICAgb3V0WzRdID0geSAqIGFbNF07XG4gICAgb3V0WzVdID0geSAqIGFbNV07XG5cbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBmcm9tIGEgbWF0MmQgaW50byBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNvcHlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqKi9cbm1hdDMuZnJvbU1hdDJkID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IDA7XG5cbiAgICBvdXRbM10gPSBhWzJdO1xuICAgIG91dFs0XSA9IGFbM107XG4gICAgb3V0WzVdID0gMDtcblxuICAgIG91dFs2XSA9IGFbNF07XG4gICAgb3V0WzddID0gYVs1XTtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiogQ2FsY3VsYXRlcyBhIDN4MyBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxuKlxuKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4qIEBwYXJhbSB7cXVhdH0gcSBRdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxuKlxuKiBAcmV0dXJucyB7bWF0M30gb3V0XG4qL1xubWF0My5mcm9tUXVhdCA9IGZ1bmN0aW9uIChvdXQsIHEpIHtcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHl4ID0geSAqIHgyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgenggPSB6ICogeDIsXG4gICAgICAgIHp5ID0geiAqIHkyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICAgIG91dFszXSA9IHl4IC0gd3o7XG4gICAgb3V0WzZdID0genggKyB3eTtcblxuICAgIG91dFsxXSA9IHl4ICsgd3o7XG4gICAgb3V0WzRdID0gMSAtIHh4IC0geno7XG4gICAgb3V0WzddID0genkgLSB3eDtcblxuICAgIG91dFsyXSA9IHp4IC0gd3k7XG4gICAgb3V0WzVdID0genkgKyB3eDtcbiAgICBvdXRbOF0gPSAxIC0geHggLSB5eTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiogQ2FsY3VsYXRlcyBhIDN4MyBub3JtYWwgbWF0cml4ICh0cmFuc3Bvc2UgaW52ZXJzZSkgZnJvbSB0aGUgNHg0IG1hdHJpeFxuKlxuKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4qIEBwYXJhbSB7bWF0NH0gYSBNYXQ0IHRvIGRlcml2ZSB0aGUgbm9ybWFsIG1hdHJpeCBmcm9tXG4qXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcbiovXG5tYXQzLm5vcm1hbEZyb21NYXQ0ID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMV0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcblxuICAgIG91dFszXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICAgIG91dFs0XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIG91dFs1XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuXG4gICAgb3V0WzZdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzddID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gbWF0IG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDMuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ21hdDMoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzNdICsgJywgJyArIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVs2XSArICcsICcgKyBhWzddICsgJywgJyArIGFbOF0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQzLmZyb2IgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzddLCAyKSArIE1hdGgucG93KGFbOF0sIDIpKSlcbn07XG5cblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMubWF0MyA9IG1hdDM7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyA0eDQgTWF0cml4XG4gKiBAbmFtZSBtYXQ0XG4gKi9cblxudmFyIG1hdDQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5tYXQ0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgxNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5tYXQ0LmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgxNik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0NCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgICAgIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYTAxO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYTAyO1xuICAgICAgICBvdXRbOV0gPSBhMTI7XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGEwMztcbiAgICAgICAgb3V0WzEzXSA9IGExMztcbiAgICAgICAgb3V0WzE0XSA9IGEyMztcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYVsxXTtcbiAgICAgICAgb3V0WzVdID0gYVs1XTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGFbMl07XG4gICAgICAgIG91dFs5XSA9IGFbNl07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYVszXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbN107XG4gICAgICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgb3V0WzBdICA9ICAoYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgICBvdXRbMV0gID0gLShhMDEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICAgIG91dFsyXSAgPSAgKGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzNdICA9IC0oYTAxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbNF0gID0gLShhMTAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFs1XSAgPSAgKGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzZdICA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbN10gID0gIChhMDAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs4XSAgPSAgKGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSk7XG4gICAgb3V0WzldICA9IC0oYTAwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpKTtcbiAgICBvdXRbMTBdID0gIChhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICAgIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcbiAgICBvdXRbMTNdID0gIChhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkpO1xuICAgIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gICAgb3V0WzE1XSA9ICAoYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0NC5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0J3NcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcbiAgICB2YXIgYjAgID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTsgIFxuICAgIG91dFswXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzJdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFszXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls0XTsgYjEgPSBiWzVdOyBiMiA9IGJbNl07IGIzID0gYls3XTtcbiAgICBvdXRbNF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzVdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFs2XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbN10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbOF07IGIxID0gYls5XTsgYjIgPSBiWzEwXTsgYjMgPSBiWzExXTtcbiAgICBvdXRbOF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzldID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxMF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzExXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYlsxMl07IGIxID0gYlsxM107IGIyID0gYlsxNF07IGIzID0gYlsxNV07XG4gICAgb3V0WzEyXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMTNdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxNF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzE1XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0NC5tdWwgPSBtYXQ0Lm11bHRpcGx5O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQudHJhbnNsYXRlID0gZnVuY3Rpb24gKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdLFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gICAgaWYgKGEgPT09IG91dCkge1xuICAgICAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgICAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgICAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzBdID0gYTAwOyBvdXRbMV0gPSBhMDE7IG91dFsyXSA9IGEwMjsgb3V0WzNdID0gYTAzO1xuICAgICAgICBvdXRbNF0gPSBhMTA7IG91dFs1XSA9IGExMTsgb3V0WzZdID0gYTEyOyBvdXRbN10gPSBhMTM7XG4gICAgICAgIG91dFs4XSA9IGEyMDsgb3V0WzldID0gYTIxOyBvdXRbMTBdID0gYTIyOyBvdXRbMTFdID0gYTIzO1xuXG4gICAgICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKiovXG5tYXQ0LnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl07XG5cbiAgICBvdXRbMF0gPSBhWzBdICogeDtcbiAgICBvdXRbMV0gPSBhWzFdICogeDtcbiAgICBvdXRbMl0gPSBhWzJdICogeDtcbiAgICBvdXRbM10gPSBhWzNdICogeDtcbiAgICBvdXRbNF0gPSBhWzRdICogeTtcbiAgICBvdXRbNV0gPSBhWzVdICogeTtcbiAgICBvdXRbNl0gPSBhWzZdICogeTtcbiAgICBvdXRbN10gPSBhWzddICogeTtcbiAgICBvdXRbOF0gPSBhWzhdICogejtcbiAgICBvdXRbOV0gPSBhWzldICogejtcbiAgICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICAgIG91dFsxMV0gPSBhWzExXSAqIHo7XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCwgYXhpcykge1xuICAgIHZhciB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdLFxuICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KSxcbiAgICAgICAgcywgYywgdCxcbiAgICAgICAgYTAwLCBhMDEsIGEwMiwgYTAzLFxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXG4gICAgICAgIGEyMCwgYTIxLCBhMjIsIGEyMyxcbiAgICAgICAgYjAwLCBiMDEsIGIwMixcbiAgICAgICAgYjEwLCBiMTEsIGIxMixcbiAgICAgICAgYjIwLCBiMjEsIGIyMjtcblxuICAgIGlmIChNYXRoLmFicyhsZW4pIDwgR0xNQVRfRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxuICAgIFxuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeCAqPSBsZW47XG4gICAgeSAqPSBsZW47XG4gICAgeiAqPSBsZW47XG5cbiAgICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICB0ID0gMSAtIGM7XG5cbiAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG4gICAgYjAwID0geCAqIHggKiB0ICsgYzsgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7IGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICAgIGIxMCA9IHggKiB5ICogdCAtIHogKiBzOyBiMTEgPSB5ICogeSAqIHQgKyBjOyBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgICBiMjAgPSB4ICogeiAqIHQgKyB5ICogczsgYjIxID0geSAqIHogKiB0IC0geCAqIHM7IGIyMiA9IHogKiB6ICogdCArIGM7XG5cbiAgICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgICBvdXRbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gICAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICAgIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgICBvdXRbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTI7XG4gICAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICAgIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgICBvdXRbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTI7XG4gICAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICAgIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgICBvdXRbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICAgIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzBdICA9IGFbMF07XG4gICAgICAgIG91dFsxXSAgPSBhWzFdO1xuICAgICAgICBvdXRbMl0gID0gYVsyXTtcbiAgICAgICAgb3V0WzNdICA9IGFbM107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzRdID0gYTEwICogYyArIGEyMCAqIHM7XG4gICAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gICAgb3V0WzZdID0gYTEyICogYyArIGEyMiAqIHM7XG4gICAgb3V0WzddID0gYTEzICogYyArIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gICAgb3V0WzldID0gYTIxICogYyAtIGExMSAqIHM7XG4gICAgb3V0WzEwXSA9IGEyMiAqIGMgLSBhMTIgKiBzO1xuICAgIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlWSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbNF0gID0gYVs0XTtcbiAgICAgICAgb3V0WzVdICA9IGFbNV07XG4gICAgICAgIG91dFs2XSAgPSBhWzZdO1xuICAgICAgICBvdXRbN10gID0gYVs3XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcbiAgICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gICAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGVaID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzhdICA9IGFbOF07XG4gICAgICAgIG91dFs5XSAgPSBhWzldO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjICsgYTExICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjICsgYTEyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgICBvdXRbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjIC0gYTAxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjIC0gYTAzICogcztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uID0gZnVuY3Rpb24gKG91dCwgcSwgdikge1xuICAgIC8vIFF1YXRlcm5pb24gbWF0aFxuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeHkgPSB4ICogeTIsXG4gICAgICAgIHh6ID0geCAqIHoyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgeXogPSB5ICogejIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtICh5eSArIHp6KTtcbiAgICBvdXRbMV0gPSB4eSArIHd6O1xuICAgIG91dFsyXSA9IHh6IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4eSAtIHd6O1xuICAgIG91dFs1XSA9IDEgLSAoeHggKyB6eik7XG4gICAgb3V0WzZdID0geXogKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHh6ICsgd3k7XG4gICAgb3V0WzldID0geXogLSB3eDtcbiAgICBvdXRbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gdlswXTtcbiAgICBvdXRbMTNdID0gdlsxXTtcbiAgICBvdXRbMTRdID0gdlsyXTtcbiAgICBvdXRbMTVdID0gMTtcbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxubWF0NC5mcm9tUXVhdCA9IGZ1bmN0aW9uIChvdXQsIHEpIHtcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHl4ID0geSAqIHgyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgenggPSB6ICogeDIsXG4gICAgICAgIHp5ID0geiAqIHkyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICAgIG91dFsxXSA9IHl4ICsgd3o7XG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuXG4gICAgb3V0WzRdID0geXggLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbNl0gPSB6eSArIHd4O1xuICAgIG91dFs3XSA9IDA7XG5cbiAgICBvdXRbOF0gPSB6eCArIHd5O1xuICAgIG91dFs5XSA9IHp5IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICAgIG91dFsxMV0gPSAwO1xuXG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcnVzdHVtID0gZnVuY3Rpb24gKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgcmwgPSAxIC8gKHJpZ2h0IC0gbGVmdCksXG4gICAgICAgIHRiID0gMSAvICh0b3AgLSBib3R0b20pLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gKG5lYXIgKiAyKSAqIHJsO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gKG5lYXIgKiAyKSAqIHRiO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICAgIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKGZhciAqIG5lYXIgKiAyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucGVyc3BlY3RpdmUgPSBmdW5jdGlvbiAob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICAgIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IGY7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoMiAqIGZhciAqIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5vcnRobyA9IGZ1bmN0aW9uIChvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpLFxuICAgICAgICBidCA9IDEgLyAoYm90dG9tIC0gdG9wKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IC0yICogbHI7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAtMiAqIGJ0O1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgICBvdXRbMTRdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge3ZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lmxvb2tBdCA9IGZ1bmN0aW9uIChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICAgIHZhciB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW4sXG4gICAgICAgIGV5ZXggPSBleWVbMF0sXG4gICAgICAgIGV5ZXkgPSBleWVbMV0sXG4gICAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgICB1cHkgPSB1cFsxXSxcbiAgICAgICAgdXB6ID0gdXBbMl0sXG4gICAgICAgIGNlbnRlcnggPSBjZW50ZXJbMF0sXG4gICAgICAgIGNlbnRlcnkgPSBjZW50ZXJbMV0sXG4gICAgICAgIGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgR0xNQVRfRVBTSUxPTiAmJlxuICAgICAgICBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCBHTE1BVF9FUFNJTE9OICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IEdMTUFUX0VQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIG1hdDQuaWRlbnRpdHkob3V0KTtcbiAgICB9XG5cbiAgICB6MCA9IGV5ZXggLSBjZW50ZXJ4O1xuICAgIHoxID0gZXlleSAtIGNlbnRlcnk7XG4gICAgejIgPSBleWV6IC0gY2VudGVyejtcblxuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQoejAgKiB6MCArIHoxICogejEgKyB6MiAqIHoyKTtcbiAgICB6MCAqPSBsZW47XG4gICAgejEgKj0gbGVuO1xuICAgIHoyICo9IGxlbjtcblxuICAgIHgwID0gdXB5ICogejIgLSB1cHogKiB6MTtcbiAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICAgIGxlbiA9IE1hdGguc3FydCh4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHgwID0gMDtcbiAgICAgICAgeDEgPSAwO1xuICAgICAgICB4MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeDAgKj0gbGVuO1xuICAgICAgICB4MSAqPSBsZW47XG4gICAgICAgIHgyICo9IGxlbjtcbiAgICB9XG5cbiAgICB5MCA9IHoxICogeDIgLSB6MiAqIHgxO1xuICAgIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gICAgeTIgPSB6MCAqIHgxIC0gejEgKiB4MDtcblxuICAgIGxlbiA9IE1hdGguc3FydCh5MCAqIHkwICsgeTEgKiB5MSArIHkyICogeTIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHkwID0gMDtcbiAgICAgICAgeTEgPSAwO1xuICAgICAgICB5MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeTAgKj0gbGVuO1xuICAgICAgICB5MSAqPSBsZW47XG4gICAgICAgIHkyICo9IGxlbjtcbiAgICB9XG5cbiAgICBvdXRbMF0gPSB4MDtcbiAgICBvdXRbMV0gPSB5MDtcbiAgICBvdXRbMl0gPSB6MDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHgxO1xuICAgIG91dFs1XSA9IHkxO1xuICAgIG91dFs2XSA9IHoxO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geDI7XG4gICAgb3V0WzldID0geTI7XG4gICAgb3V0WzEwXSA9IHoyO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAtKHgwICogZXlleCArIHgxICogZXlleSArIHgyICogZXlleik7XG4gICAgb3V0WzEzXSA9IC0oeTAgKiBleWV4ICsgeTEgKiBleWV5ICsgeTIgKiBleWV6KTtcbiAgICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQ0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQ0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgKyBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs4XSArICcsICcgKyBhWzldICsgJywgJyArIGFbMTBdICsgJywgJyArIGFbMTFdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzEyXSArICcsICcgKyBhWzEzXSArICcsICcgKyBhWzE0XSArICcsICcgKyBhWzE1XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDQuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs3XSwgMikgKyBNYXRoLnBvdyhhWzhdLCAyKSArIE1hdGgucG93KGFbOV0sIDIpICsgTWF0aC5wb3coYVsxMF0sIDIpICsgTWF0aC5wb3coYVsxMV0sIDIpICsgTWF0aC5wb3coYVsxMl0sIDIpICsgTWF0aC5wb3coYVsxM10sIDIpICsgTWF0aC5wb3coYVsxNF0sIDIpICsgTWF0aC5wb3coYVsxNV0sIDIpICkpXG59O1xuXG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLm1hdDQgPSBtYXQ0O1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgUXVhdGVybmlvblxuICogQG5hbWUgcXVhdFxuICovXG5cbnZhciBxdWF0ID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBxdWF0XG4gKlxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqL1xucXVhdC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXRzIGEgcXVhdGVybmlvbiB0byByZXByZXNlbnQgdGhlIHNob3J0ZXN0IHJvdGF0aW9uIGZyb20gb25lXG4gKiB2ZWN0b3IgdG8gYW5vdGhlci5cbiAqXG4gKiBCb3RoIHZlY3RvcnMgYXJlIGFzc3VtZWQgdG8gYmUgdW5pdCBsZW5ndGguXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uLlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBpbml0aWFsIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBkZXN0aW5hdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGlvblRvID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB0bXB2ZWMzID0gdmVjMy5jcmVhdGUoKTtcbiAgICB2YXIgeFVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDEsMCwwKTtcbiAgICB2YXIgeVVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDAsMSwwKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICAgICAgdmFyIGRvdCA9IHZlYzMuZG90KGEsIGIpO1xuICAgICAgICBpZiAoZG90IDwgLTAuOTk5OTk5KSB7XG4gICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHhVbml0VmVjMywgYSk7XG4gICAgICAgICAgICBpZiAodmVjMy5sZW5ndGgodG1wdmVjMykgPCAwLjAwMDAwMSlcbiAgICAgICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHlVbml0VmVjMywgYSk7XG4gICAgICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh0bXB2ZWMzLCB0bXB2ZWMzKTtcbiAgICAgICAgICAgIHF1YXQuc2V0QXhpc0FuZ2xlKG91dCwgdG1wdmVjMywgTWF0aC5QSSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9IGVsc2UgaWYgKGRvdCA+IDAuOTk5OTk5KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSAwO1xuICAgICAgICAgICAgb3V0WzFdID0gMDtcbiAgICAgICAgICAgIG91dFsyXSA9IDA7XG4gICAgICAgICAgICBvdXRbM10gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgYSwgYik7XG4gICAgICAgICAgICBvdXRbMF0gPSB0bXB2ZWMzWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdG1wdmVjM1sxXTtcbiAgICAgICAgICAgIG91dFsyXSA9IHRtcHZlYzNbMl07XG4gICAgICAgICAgICBvdXRbM10gPSAxICsgZG90O1xuICAgICAgICAgICAgcmV0dXJuIHF1YXQubm9ybWFsaXplKG91dCwgb3V0KTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFNldHMgdGhlIHNwZWNpZmllZCBxdWF0ZXJuaW9uIHdpdGggdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuXG4gKiBheGVzLiBFYWNoIGF4aXMgaXMgYSB2ZWMzIGFuZCBpcyBleHBlY3RlZCB0byBiZSB1bml0IGxlbmd0aCBhbmRcbiAqIHBlcnBlbmRpY3VsYXIgdG8gYWxsIG90aGVyIHNwZWNpZmllZCBheGVzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gdmlldyAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHZpZXdpbmcgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHJpZ2h0IHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInJpZ2h0XCIgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHVwICAgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInVwXCIgZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuc2V0QXhlcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgbWF0ciA9IG1hdDMuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob3V0LCB2aWV3LCByaWdodCwgdXApIHtcbiAgICAgICAgbWF0clswXSA9IHJpZ2h0WzBdO1xuICAgICAgICBtYXRyWzNdID0gcmlnaHRbMV07XG4gICAgICAgIG1hdHJbNl0gPSByaWdodFsyXTtcblxuICAgICAgICBtYXRyWzFdID0gdXBbMF07XG4gICAgICAgIG1hdHJbNF0gPSB1cFsxXTtcbiAgICAgICAgbWF0cls3XSA9IHVwWzJdO1xuXG4gICAgICAgIG1hdHJbMl0gPSAtdmlld1swXTtcbiAgICAgICAgbWF0cls1XSA9IC12aWV3WzFdO1xuICAgICAgICBtYXRyWzhdID0gLXZpZXdbMl07XG5cbiAgICAgICAgcmV0dXJuIHF1YXQubm9ybWFsaXplKG91dCwgcXVhdC5mcm9tTWF0MyhvdXQsIG1hdHIpKTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gY2xvbmVcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5jbG9uZSA9IHZlYzQuY2xvbmU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZnJvbVZhbHVlcyA9IHZlYzQuZnJvbVZhbHVlcztcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgcXVhdCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHNvdXJjZSBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5jb3B5ID0gdmVjNC5jb3B5O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNldCA9IHZlYzQuc2V0O1xuXG4vKipcbiAqIFNldCBhIHF1YXQgdG8gdGhlIGlkZW50aXR5IHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0cyBhIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYW5kIHJvdGF0aW9uIGF4aXMsXG4gKiB0aGVuIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgYXJvdW5kIHdoaWNoIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICoqL1xucXVhdC5zZXRBeGlzQW5nbGUgPSBmdW5jdGlvbihvdXQsIGF4aXMsIHJhZCkge1xuICAgIHJhZCA9IHJhZCAqIDAuNTtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgb3V0WzBdID0gcyAqIGF4aXNbMF07XG4gICAgb3V0WzFdID0gcyAqIGF4aXNbMV07XG4gICAgb3V0WzJdID0gcyAqIGF4aXNbMl07XG4gICAgb3V0WzNdID0gTWF0aC5jb3MocmFkKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuYWRkID0gdmVjNC5hZGQ7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubXVsID0gcXVhdC5tdWx0aXBseTtcblxuLyoqXG4gKiBTY2FsZXMgYSBxdWF0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNjYWxlID0gdmVjNC5zY2FsZTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWCA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieDtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXogKiBieDtcbiAgICBvdXRbMl0gPSBheiAqIGJ3IC0gYXkgKiBieDtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnkgPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieTtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXggKiBieTtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXkgKiBieTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWiA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnogPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXkgKiBiejtcbiAgICBvdXRbMV0gPSBheSAqIGJ3IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBiejtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXogKiBiejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBXIGNvbXBvbmVudCBvZiBhIHF1YXQgZnJvbSB0aGUgWCwgWSwgYW5kIFogY29tcG9uZW50cy5cbiAqIEFzc3VtZXMgdGhhdCBxdWF0ZXJuaW9uIGlzIDEgdW5pdCBpbiBsZW5ndGguXG4gKiBBbnkgZXhpc3RpbmcgVyBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIFcgY29tcG9uZW50IG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuY2FsY3VsYXRlVyA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcblxuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IC1NYXRoLnNxcnQoTWF0aC5hYnMoMS4wIC0geCAqIHggLSB5ICogeSAtIHogKiB6KSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZG90ID0gdmVjNC5kb3Q7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVycCA9IHZlYzQubGVycDtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5zbGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICAvLyBiZW5jaG1hcmtzOlxuICAgIC8vICAgIGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tc2xlcnAtaW1wbGVtZW50YXRpb25zXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgICB2YXIgICAgICAgIG9tZWdhLCBjb3NvbSwgc2lub20sIHNjYWxlMCwgc2NhbGUxO1xuXG4gICAgLy8gY2FsYyBjb3NpbmVcbiAgICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7XG4gICAgLy8gYWRqdXN0IHNpZ25zIChpZiBuZWNlc3NhcnkpXG4gICAgaWYgKCBjb3NvbSA8IDAuMCApIHtcbiAgICAgICAgY29zb20gPSAtY29zb207XG4gICAgICAgIGJ4ID0gLSBieDtcbiAgICAgICAgYnkgPSAtIGJ5O1xuICAgICAgICBieiA9IC0gYno7XG4gICAgICAgIGJ3ID0gLSBidztcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIGNvZWZmaWNpZW50c1xuICAgIGlmICggKDEuMCAtIGNvc29tKSA+IDAuMDAwMDAxICkge1xuICAgICAgICAvLyBzdGFuZGFyZCBjYXNlIChzbGVycClcbiAgICAgICAgb21lZ2EgID0gTWF0aC5hY29zKGNvc29tKTtcbiAgICAgICAgc2lub20gID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgICBzY2FsZTAgPSBNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICAgICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xuICAgIH0gZWxzZSB7ICAgICAgICBcbiAgICAgICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBxdWF0ZXJuaW9ucyBhcmUgdmVyeSBjbG9zZSBcbiAgICAgICAgLy8gIC4uLiBzbyB3ZSBjYW4gZG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgICBzY2FsZTAgPSAxLjAgLSB0O1xuICAgICAgICBzY2FsZTEgPSB0O1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzXG4gICAgb3V0WzBdID0gc2NhbGUwICogYXggKyBzY2FsZTEgKiBieDtcbiAgICBvdXRbMV0gPSBzY2FsZTAgKiBheSArIHNjYWxlMSAqIGJ5O1xuICAgIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gICAgb3V0WzNdID0gc2NhbGUwICogYXcgKyBzY2FsZTEgKiBidztcbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGludmVyc2Ugb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICBkb3QgPSBhMCphMCArIGExKmExICsgYTIqYTIgKyBhMyphMyxcbiAgICAgICAgaW52RG90ID0gZG90ID8gMS4wL2RvdCA6IDA7XG4gICAgXG4gICAgLy8gVE9ETzogV291bGQgYmUgZmFzdGVyIHRvIHJldHVybiBbMCwwLDAsMF0gaW1tZWRpYXRlbHkgaWYgZG90ID09IDBcblxuICAgIG91dFswXSA9IC1hMCppbnZEb3Q7XG4gICAgb3V0WzFdID0gLWExKmludkRvdDtcbiAgICBvdXRbMl0gPSAtYTIqaW52RG90O1xuICAgIG91dFszXSA9IGEzKmludkRvdDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBjb25qdWdhdGUgb2YgYSBxdWF0XG4gKiBJZiB0aGUgcXVhdGVybmlvbiBpcyBub3JtYWxpemVkLCB0aGlzIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuIHF1YXQuaW52ZXJzZSBhbmQgcHJvZHVjZXMgdGhlIHNhbWUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGNvbmp1Z2F0ZSBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZW5ndGggPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVuID0gcXVhdC5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNxdWFyZWRMZW5ndGggPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0LnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zcXJMZW4gPSBxdWF0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTm9ybWFsaXplIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5ub3JtYWxpemUgPSB2ZWM0Lm5vcm1hbGl6ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiAzeDMgcm90YXRpb24gbWF0cml4LlxuICpcbiAqIE5PVEU6IFRoZSByZXN1bHRhbnQgcXVhdGVybmlvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28geW91IHNob3VsZCBiZSBzdXJlXG4gKiB0byByZW5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB5b3Vyc2VsZiB3aGVyZSBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge21hdDN9IG0gcm90YXRpb24gbWF0cml4XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5mcm9tTWF0MyA9IGZ1bmN0aW9uKG91dCwgbSkge1xuICAgIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzXG4gICAgLy8gYXJ0aWNsZSBcIlF1YXRlcm5pb24gQ2FsY3VsdXMgYW5kIEZhc3QgQW5pbWF0aW9uXCIuXG4gICAgdmFyIGZUcmFjZSA9IG1bMF0gKyBtWzRdICsgbVs4XTtcbiAgICB2YXIgZlJvb3Q7XG5cbiAgICBpZiAoIGZUcmFjZSA+IDAuMCApIHtcbiAgICAgICAgLy8gfHd8ID4gMS8yLCBtYXkgYXMgd2VsbCBjaG9vc2UgdyA+IDEvMlxuICAgICAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxLjApOyAgLy8gMndcbiAgICAgICAgb3V0WzNdID0gMC41ICogZlJvb3Q7XG4gICAgICAgIGZSb290ID0gMC41L2ZSb290OyAgLy8gMS8oNHcpXG4gICAgICAgIG91dFswXSA9IChtWzddLW1bNV0pKmZSb290O1xuICAgICAgICBvdXRbMV0gPSAobVsyXS1tWzZdKSpmUm9vdDtcbiAgICAgICAgb3V0WzJdID0gKG1bM10tbVsxXSkqZlJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gfHd8IDw9IDEvMlxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmICggbVs0XSA+IG1bMF0gKVxuICAgICAgICAgIGkgPSAxO1xuICAgICAgICBpZiAoIG1bOF0gPiBtW2kqMytpXSApXG4gICAgICAgICAgaSA9IDI7XG4gICAgICAgIHZhciBqID0gKGkrMSklMztcbiAgICAgICAgdmFyIGsgPSAoaSsyKSUzO1xuICAgICAgICBcbiAgICAgICAgZlJvb3QgPSBNYXRoLnNxcnQobVtpKjMraV0tbVtqKjMral0tbVtrKjMra10gKyAxLjApO1xuICAgICAgICBvdXRbaV0gPSAwLjUgKiBmUm9vdDtcbiAgICAgICAgZlJvb3QgPSAwLjUgLyBmUm9vdDtcbiAgICAgICAgb3V0WzNdID0gKG1bayozK2pdIC0gbVtqKjMra10pICogZlJvb3Q7XG4gICAgICAgIG91dFtqXSA9IChtW2oqMytpXSArIG1baSozK2pdKSAqIGZSb290O1xuICAgICAgICBvdXRba10gPSAobVtrKjMraV0gKyBtW2kqMytrXSkgKiBmUm9vdDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHF1YXRlbmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnF1YXQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3F1YXQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5xdWF0ID0gcXVhdDtcbn1cbjtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuICB9KShzaGltLmV4cG9ydHMpO1xufSkodGhpcyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHBhcnNlRXJyb3JzXG5cbmZ1bmN0aW9uIHBhcnNlRXJyb3JzKGxvZykge1xuICBsb2cgPSBTdHJpbmcobG9nKVxuXG4gIHZhciBsb2dzID0gW11cbiAgdmFyIHJlc3VsdFxuXG4gIHdoaWxlIChyZXN1bHQgPSBsb2cubWF0Y2goL0VSUk9SXFw6KFteXFxuXSspLykpIHtcbiAgICBsb2cgPSBsb2cuc2xpY2UocmVzdWx0LmluZGV4ICsgMSlcblxuICAgIHZhciBsaW5lID0gcmVzdWx0WzFdLnRyaW0oKVxuICAgIHZhciBzZXBzID0gbGluZS5zcGxpdCgnOicpXG4gICAgdmFyIGVtc2cgPSBzZXBzLnNsaWNlKDIpLmpvaW4oJzonKS50cmltKClcbiAgICB2YXIgZmlsZSA9IHBhcnNlSW50KHNlcHNbMF0sIDEwKVxuICAgIHZhciBsaW5lID0gcGFyc2VJbnQoc2Vwc1sxXSwgMTApXG5cbiAgICBsb2dzLnB1c2goe1xuICAgICAgICBtZXNzYWdlOiBlbXNnXG4gICAgICAsIGZpbGU6IGZpbGVcbiAgICAgICwgbGluZTogbGluZVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gbG9nc1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB5YW1sID0gcmVxdWlyZSgnLi9saWIvanMteWFtbC5qcycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0geWFtbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgbG9hZGVyID0gcmVxdWlyZSgnLi9qcy15YW1sL2xvYWRlcicpO1xudmFyIGR1bXBlciA9IHJlcXVpcmUoJy4vanMteWFtbC9kdW1wZXInKTtcblxuXG5mdW5jdGlvbiBkZXByZWNhdGVkKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uICcgKyBuYW1lICsgJyBpcyBkZXByZWNhdGVkIGFuZCBjYW5ub3QgYmUgdXNlZC4nKTtcbiAgfTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5UeXBlICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3R5cGUnKTtcbm1vZHVsZS5leHBvcnRzLlNjaGVtYSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hJyk7XG5tb2R1bGUuZXhwb3J0cy5GQUlMU0FGRV9TQ0hFTUEgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuSlNPTl9TQ0hFTUEgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvanNvbicpO1xubW9kdWxlLmV4cG9ydHMuQ09SRV9TQ0hFTUEgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvY29yZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9TQUZFX1NDSEVNQSA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlJyk7XG5tb2R1bGUuZXhwb3J0cy5ERUZBVUxUX0ZVTExfU0NIRU1BID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X2Z1bGwnKTtcbm1vZHVsZS5leHBvcnRzLmxvYWQgICAgICAgICAgICAgICAgPSBsb2FkZXIubG9hZDtcbm1vZHVsZS5leHBvcnRzLmxvYWRBbGwgICAgICAgICAgICAgPSBsb2FkZXIubG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkICAgICAgICAgICAgPSBsb2FkZXIuc2FmZUxvYWQ7XG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZEFsbCAgICAgICAgID0gbG9hZGVyLnNhZmVMb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMuZHVtcCAgICAgICAgICAgICAgICA9IGR1bXBlci5kdW1wO1xubW9kdWxlLmV4cG9ydHMuc2FmZUR1bXAgICAgICAgICAgICA9IGR1bXBlci5zYWZlRHVtcDtcbm1vZHVsZS5leHBvcnRzLllBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvZXhjZXB0aW9uJyk7XG5cbi8vIERlcHJlY2F0ZWQgc2NoZW1hIG5hbWVzIGZyb20gSlMtWUFNTCAyLjAueFxubW9kdWxlLmV4cG9ydHMuTUlOSU1BTF9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2ZhaWxzYWZlJyk7XG5tb2R1bGUuZXhwb3J0cy5TQUZFX1NDSEVNQSAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlJyk7XG5tb2R1bGUuZXhwb3J0cy5ERUZBVUxUX1NDSEVNQSA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5cbi8vIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGZyb20gSlMtWUFNTCAxLngueFxubW9kdWxlLmV4cG9ydHMuc2NhbiAgICAgICAgICAgPSBkZXByZWNhdGVkKCdzY2FuJyk7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSAgICAgICAgICA9IGRlcHJlY2F0ZWQoJ3BhcnNlJyk7XG5tb2R1bGUuZXhwb3J0cy5jb21wb3NlICAgICAgICA9IGRlcHJlY2F0ZWQoJ2NvbXBvc2UnKTtcbm1vZHVsZS5leHBvcnRzLmFkZENvbnN0cnVjdG9yID0gZGVwcmVjYXRlZCgnYWRkQ29uc3RydWN0b3InKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBpc05vdGhpbmcoc3ViamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBzdWJqZWN0ID09PSAndW5kZWZpbmVkJykgfHwgKG51bGwgPT09IHN1YmplY3QpO1xufVxuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHN1YmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcpICYmIChudWxsICE9PSBzdWJqZWN0KTtcbn1cblxuXG5mdW5jdGlvbiB0b0FycmF5KHNlcXVlbmNlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNlcXVlbmNlKSkge1xuICAgIHJldHVybiBzZXF1ZW5jZTtcbiAgfSBlbHNlIGlmIChpc05vdGhpbmcoc2VxdWVuY2UpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBbIHNlcXVlbmNlIF07XG59XG5cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCBrZXksIHNvdXJjZUtleXM7XG5cbiAgaWYgKHNvdXJjZSkge1xuICAgIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpbmRleF07XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cblxuZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgY291bnQpIHtcbiAgdmFyIHJlc3VsdCA9ICcnLCBjeWNsZTtcblxuICBmb3IgKGN5Y2xlID0gMDsgY3ljbGUgPCBjb3VudDsgY3ljbGUgKz0gMSkge1xuICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGlzTmVnYXRpdmVaZXJvKG51bWJlcikge1xuICByZXR1cm4gKDAgPT09IG51bWJlcikgJiYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gMSAvIG51bWJlcik7XG59XG5cblxubW9kdWxlLmV4cG9ydHMuaXNOb3RoaW5nICAgICAgPSBpc05vdGhpbmc7XG5tb2R1bGUuZXhwb3J0cy5pc09iamVjdCAgICAgICA9IGlzT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMudG9BcnJheSAgICAgICAgPSB0b0FycmF5O1xubW9kdWxlLmV4cG9ydHMucmVwZWF0ICAgICAgICAgPSByZXBlYXQ7XG5tb2R1bGUuZXhwb3J0cy5pc05lZ2F0aXZlWmVybyA9IGlzTmVnYXRpdmVaZXJvO1xubW9kdWxlLmV4cG9ydHMuZXh0ZW5kICAgICAgICAgPSBleHRlbmQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG52YXIgY29tbW9uICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xudmFyIERFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcblxudmFyIF90b1N0cmluZyAgICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIENIQVJfVEFCICAgICAgICAgICAgICAgICAgPSAweDA5OyAvKiBUYWIgKi9cbnZhciBDSEFSX0xJTkVfRkVFRCAgICAgICAgICAgID0gMHgwQTsgLyogTEYgKi9cbnZhciBDSEFSX0NBUlJJQUdFX1JFVFVSTiAgICAgID0gMHgwRDsgLyogQ1IgKi9cbnZhciBDSEFSX1NQQUNFICAgICAgICAgICAgICAgID0gMHgyMDsgLyogU3BhY2UgKi9cbnZhciBDSEFSX0VYQ0xBTUFUSU9OICAgICAgICAgID0gMHgyMTsgLyogISAqL1xudmFyIENIQVJfRE9VQkxFX1FVT1RFICAgICAgICAgPSAweDIyOyAvKiBcIiAqL1xudmFyIENIQVJfU0hBUlAgICAgICAgICAgICAgICAgPSAweDIzOyAvKiAjICovXG52YXIgQ0hBUl9QRVJDRU5UICAgICAgICAgICAgICA9IDB4MjU7IC8qICUgKi9cbnZhciBDSEFSX0FNUEVSU0FORCAgICAgICAgICAgID0gMHgyNjsgLyogJiAqL1xudmFyIENIQVJfU0lOR0xFX1FVT1RFICAgICAgICAgPSAweDI3OyAvKiAnICovXG52YXIgQ0hBUl9BU1RFUklTSyAgICAgICAgICAgICA9IDB4MkE7IC8qICogKi9cbnZhciBDSEFSX0NPTU1BICAgICAgICAgICAgICAgID0gMHgyQzsgLyogLCAqL1xudmFyIENIQVJfTUlOVVMgICAgICAgICAgICAgICAgPSAweDJEOyAvKiAtICovXG52YXIgQ0hBUl9DT0xPTiAgICAgICAgICAgICAgICA9IDB4M0E7IC8qIDogKi9cbnZhciBDSEFSX0dSRUFURVJfVEhBTiAgICAgICAgID0gMHgzRTsgLyogPiAqL1xudmFyIENIQVJfUVVFU1RJT04gICAgICAgICAgICAgPSAweDNGOyAvKiA/ICovXG52YXIgQ0hBUl9DT01NRVJDSUFMX0FUICAgICAgICA9IDB4NDA7IC8qIEAgKi9cbnZhciBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQgID0gMHg1QjsgLyogWyAqL1xudmFyIENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQgPSAweDVEOyAvKiBdICovXG52YXIgQ0hBUl9HUkFWRV9BQ0NFTlQgICAgICAgICA9IDB4NjA7IC8qIGAgKi9cbnZhciBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVCAgID0gMHg3QjsgLyogeyAqL1xudmFyIENIQVJfVkVSVElDQUxfTElORSAgICAgICAgPSAweDdDOyAvKiB8ICovXG52YXIgQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUICA9IDB4N0Q7IC8qIH0gKi9cblxudmFyIEVTQ0FQRV9TRVFVRU5DRVMgPSB7fTtcblxuRVNDQVBFX1NFUVVFTkNFU1sweDAwXSAgID0gJ1xcXFwwJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwN10gICA9ICdcXFxcYSc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDhdICAgPSAnXFxcXGInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA5XSAgID0gJ1xcXFx0JztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQV0gICA9ICdcXFxcbic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MEJdICAgPSAnXFxcXHYnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBDXSAgID0gJ1xcXFxmJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwRF0gICA9ICdcXFxccic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MUJdICAgPSAnXFxcXGUnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIyXSAgID0gJ1xcXFxcIic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4NUNdICAgPSAnXFxcXFxcXFwnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDg1XSAgID0gJ1xcXFxOJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHhBMF0gICA9ICdcXFxcXyc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjAyOF0gPSAnXFxcXEwnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIwMjldID0gJ1xcXFxQJztcblxudmFyIERFUFJFQ0FURURfQk9PTEVBTlNfU1lOVEFYID0gW1xuICAneScsICdZJywgJ3llcycsICdZZXMnLCAnWUVTJywgJ29uJywgJ09uJywgJ09OJyxcbiAgJ24nLCAnTicsICdubycsICdObycsICdOTycsICdvZmYnLCAnT2ZmJywgJ09GRidcbl07XG5cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZU1hcChzY2hlbWEsIG1hcCkge1xuICB2YXIgcmVzdWx0LCBrZXlzLCBpbmRleCwgbGVuZ3RoLCB0YWcsIHN0eWxlLCB0eXBlO1xuXG4gIGlmIChudWxsID09PSBtYXApIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICByZXN1bHQgPSB7fTtcbiAga2V5cyA9IE9iamVjdC5rZXlzKG1hcCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHRhZyA9IGtleXNbaW5kZXhdO1xuICAgIHN0eWxlID0gU3RyaW5nKG1hcFt0YWddKTtcblxuICAgIGlmICgnISEnID09PSB0YWcuc2xpY2UoMCwgMikpIHtcbiAgICAgIHRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnLnNsaWNlKDIpO1xuICAgIH1cblxuICAgIHR5cGUgPSBzY2hlbWEuY29tcGlsZWRUeXBlTWFwW3RhZ107XG5cbiAgICBpZiAodHlwZSAmJiBfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLnN0eWxlQWxpYXNlcywgc3R5bGUpKSB7XG4gICAgICBzdHlsZSA9IHR5cGUuc3R5bGVBbGlhc2VzW3N0eWxlXTtcbiAgICB9XG5cbiAgICByZXN1bHRbdGFnXSA9IHN0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZW5jb2RlSGV4KGNoYXJhY3Rlcikge1xuICB2YXIgc3RyaW5nLCBoYW5kbGUsIGxlbmd0aDtcblxuICBzdHJpbmcgPSBjaGFyYWN0ZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cbiAgaWYgKGNoYXJhY3RlciA8PSAweEZGKSB7XG4gICAgaGFuZGxlID0gJ3gnO1xuICAgIGxlbmd0aCA9IDI7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyIDw9IDB4RkZGRikge1xuICAgIGhhbmRsZSA9ICd1JztcbiAgICBsZW5ndGggPSA0O1xuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA8PSAweEZGRkZGRkZGKSB7XG4gICAgaGFuZGxlID0gJ1UnO1xuICAgIGxlbmd0aCA9IDg7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ2NvZGUgcG9pbnQgd2l0aGluIGEgc3RyaW5nIG1heSBub3QgYmUgZ3JlYXRlciB0aGFuIDB4RkZGRkZGRkYnKTtcbiAgfVxuXG4gIHJldHVybiAnXFxcXCcgKyBoYW5kbGUgKyBjb21tb24ucmVwZWF0KCcwJywgbGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIFN0YXRlKG9wdGlvbnMpIHtcbiAgdGhpcy5zY2hlbWEgICAgICA9IG9wdGlvbnNbJ3NjaGVtYSddIHx8IERFRkFVTFRfRlVMTF9TQ0hFTUE7XG4gIHRoaXMuaW5kZW50ICAgICAgPSBNYXRoLm1heCgxLCAob3B0aW9uc1snaW5kZW50J10gfHwgMikpO1xuICB0aGlzLnNraXBJbnZhbGlkID0gb3B0aW9uc1snc2tpcEludmFsaWQnXSB8fCBmYWxzZTtcbiAgdGhpcy5mbG93TGV2ZWwgICA9IChjb21tb24uaXNOb3RoaW5nKG9wdGlvbnNbJ2Zsb3dMZXZlbCddKSA/IC0xIDogb3B0aW9uc1snZmxvd0xldmVsJ10pO1xuICB0aGlzLnN0eWxlTWFwICAgID0gY29tcGlsZVN0eWxlTWFwKHRoaXMuc2NoZW1hLCBvcHRpb25zWydzdHlsZXMnXSB8fCBudWxsKTtcbiAgdGhpcy5zb3J0S2V5cyAgICA9IG9wdGlvbnNbJ3NvcnRLZXlzJ10gfHwgZmFsc2U7XG5cbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy5leHBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRFeHBsaWNpdDtcblxuICB0aGlzLnRhZyA9IG51bGw7XG4gIHRoaXMucmVzdWx0ID0gJyc7XG5cbiAgdGhpcy5kdXBsaWNhdGVzID0gW107XG4gIHRoaXMudXNlZER1cGxpY2F0ZXMgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBpbmRlbnRTdHJpbmcoc3RyaW5nLCBzcGFjZXMpIHtcbiAgdmFyIGluZCA9IGNvbW1vbi5yZXBlYXQoJyAnLCBzcGFjZXMpLFxuICAgICAgcG9zaXRpb24gPSAwLFxuICAgICAgbmV4dCA9IC0xLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBsaW5lLFxuICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGgpIHtcbiAgICBuZXh0ID0gc3RyaW5nLmluZGV4T2YoJ1xcbicsIHBvc2l0aW9uKTtcbiAgICBpZiAobmV4dCA9PT0gLTEpIHtcbiAgICAgIGxpbmUgPSBzdHJpbmcuc2xpY2UocG9zaXRpb24pO1xuICAgICAgcG9zaXRpb24gPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUgPSBzdHJpbmcuc2xpY2UocG9zaXRpb24sIG5leHQgKyAxKTtcbiAgICAgIHBvc2l0aW9uID0gbmV4dCArIDE7XG4gICAgfVxuICAgIGlmIChsaW5lLmxlbmd0aCAmJiBsaW5lICE9PSAnXFxuJykge1xuICAgICAgcmVzdWx0ICs9IGluZDtcbiAgICB9XG4gICAgcmVzdWx0ICs9IGxpbmU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCkge1xuICByZXR1cm4gJ1xcbicgKyBjb21tb24ucmVwZWF0KCcgJywgc3RhdGUuaW5kZW50ICogbGV2ZWwpO1xufVxuXG5mdW5jdGlvbiB0ZXN0SW1wbGljaXRSZXNvbHZpbmcoc3RhdGUsIHN0cikge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwgdHlwZTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gc3RhdGUuaW1wbGljaXRUeXBlcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHN0YXRlLmltcGxpY2l0VHlwZXNbaW5kZXhdO1xuXG4gICAgaWYgKHR5cGUucmVzb2x2ZShzdHIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIFN0cmluZ0J1aWxkZXIoc291cmNlKSB7XG4gIHRoaXMuc291cmNlID0gc291cmNlO1xuICB0aGlzLnJlc3VsdCA9ICcnO1xuICB0aGlzLmNoZWNrcG9pbnQgPSAwO1xufVxuXG5TdHJpbmdCdWlsZGVyLnByb3RvdHlwZS50YWtlVXBUbyA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICB2YXIgZXI7XG5cbiAgaWYgKHBvc2l0aW9uIDwgdGhpcy5jaGVja3BvaW50KSB7XG4gICAgZXIgPSBuZXcgRXJyb3IoJ3Bvc2l0aW9uIHNob3VsZCBiZSA+IGNoZWNrcG9pbnQnKTtcbiAgICBlci5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIGVyLmNoZWNrcG9pbnQgPSB0aGlzLmNoZWNrcG9pbnQ7XG4gICAgdGhyb3cgZXI7XG4gIH1cblxuICB0aGlzLnJlc3VsdCArPSB0aGlzLnNvdXJjZS5zbGljZSh0aGlzLmNoZWNrcG9pbnQsIHBvc2l0aW9uKTtcbiAgdGhpcy5jaGVja3BvaW50ID0gcG9zaXRpb247XG4gIHJldHVybiB0aGlzO1xufTtcblxuU3RyaW5nQnVpbGRlci5wcm90b3R5cGUuZXNjYXBlQ2hhciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNoYXJhY3RlciwgZXNjO1xuXG4gIGNoYXJhY3RlciA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5jaGVja3BvaW50KTtcbiAgZXNjID0gRVNDQVBFX1NFUVVFTkNFU1tjaGFyYWN0ZXJdIHx8IGVuY29kZUhleChjaGFyYWN0ZXIpO1xuICB0aGlzLnJlc3VsdCArPSBlc2M7XG4gIHRoaXMuY2hlY2twb2ludCArPSAxO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuU3RyaW5nQnVpbGRlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zb3VyY2UubGVuZ3RoID4gdGhpcy5jaGVja3BvaW50KSB7XG4gICAgdGhpcy50YWtlVXBUbyh0aGlzLnNvdXJjZS5sZW5ndGgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZVNjYWxhcihzdGF0ZSwgb2JqZWN0LCBsZXZlbCwgaXNrZXkpIHtcbiAgdmFyIHNpbXBsZSwgZmlyc3QsIHNwYWNlV3JhcCwgZm9sZGVkLCBsaXRlcmFsLCBzaW5nbGUsIGRvdWJsZSxcbiAgICAgIHNhd0xpbmVGZWVkLCBsaW5lUG9zaXRpb24sIGxvbmdlc3RMaW5lLCBpbmRlbnQsIG1heCwgY2hhcmFjdGVyLFxuICAgICAgcG9zaXRpb24sIGVzY2FwZVNlcSwgaGV4RXNjLCBwcmV2aW91cywgbGluZUxlbmd0aCwgbW9kaWZpZXIsXG4gICAgICB0cmFpbGluZ0xpbmVCcmVha3MsIHJlc3VsdDtcblxuICBpZiAoMCA9PT0gb2JqZWN0Lmxlbmd0aCkge1xuICAgIHN0YXRlLmR1bXAgPSBcIicnXCI7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKC0xICE9PSBERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWC5pbmRleE9mKG9iamVjdCkpIHtcbiAgICBzdGF0ZS5kdW1wID0gXCInXCIgKyBvYmplY3QgKyBcIidcIjtcbiAgICByZXR1cm47XG4gIH1cblxuICBzaW1wbGUgPSB0cnVlO1xuICBmaXJzdCA9IG9iamVjdC5sZW5ndGggPyBvYmplY3QuY2hhckNvZGVBdCgwKSA6IDA7XG4gIHNwYWNlV3JhcCA9IChDSEFSX1NQQUNFID09PSBmaXJzdCB8fFxuICAgICAgICAgICAgICAgQ0hBUl9TUEFDRSA9PT0gb2JqZWN0LmNoYXJDb2RlQXQob2JqZWN0Lmxlbmd0aCAtIDEpKTtcblxuICAvLyBTaW1wbGlmaWVkIGNoZWNrIGZvciByZXN0cmljdGVkIGZpcnN0IGNoYXJhY3RlcnNcbiAgLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjbnMtcGxhaW4tZmlyc3QlMjhjJTI5XG4gIGlmIChDSEFSX01JTlVTICAgICAgICAgPT09IGZpcnN0IHx8XG4gICAgICBDSEFSX1FVRVNUSU9OICAgICAgPT09IGZpcnN0IHx8XG4gICAgICBDSEFSX0NPTU1FUkNJQUxfQVQgPT09IGZpcnN0IHx8XG4gICAgICBDSEFSX0dSQVZFX0FDQ0VOVCAgPT09IGZpcnN0KSB7XG4gICAgc2ltcGxlID0gZmFsc2U7XG4gIH1cblxuICAvLyBjYW4gb25seSB1c2UgPiBhbmQgfCBpZiBub3Qgd3JhcHBlZCBpbiBzcGFjZXMgb3IgaXMgbm90IGEga2V5LlxuICBpZiAoc3BhY2VXcmFwKSB7XG4gICAgc2ltcGxlID0gZmFsc2U7XG4gICAgZm9sZGVkID0gZmFsc2U7XG4gICAgbGl0ZXJhbCA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGZvbGRlZCA9ICFpc2tleTtcbiAgICBsaXRlcmFsID0gIWlza2V5O1xuICB9XG5cbiAgc2luZ2xlID0gdHJ1ZTtcbiAgZG91YmxlID0gbmV3IFN0cmluZ0J1aWxkZXIob2JqZWN0KTtcblxuICBzYXdMaW5lRmVlZCA9IGZhbHNlO1xuICBsaW5lUG9zaXRpb24gPSAwO1xuICBsb25nZXN0TGluZSA9IDA7XG5cbiAgaW5kZW50ID0gc3RhdGUuaW5kZW50ICogbGV2ZWw7XG4gIG1heCA9IDgwO1xuICBpZiAoaW5kZW50IDwgNDApIHtcbiAgICBtYXggLT0gaW5kZW50O1xuICB9IGVsc2Uge1xuICAgIG1heCA9IDQwO1xuICB9XG5cbiAgZm9yIChwb3NpdGlvbiA9IDA7IHBvc2l0aW9uIDwgb2JqZWN0Lmxlbmd0aDsgcG9zaXRpb24rKykge1xuICAgIGNoYXJhY3RlciA9IG9iamVjdC5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgICBpZiAoc2ltcGxlKSB7XG4gICAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgY2FuIG5ldmVyIGFwcGVhciBpbiB0aGUgc2ltcGxlIHNjYWxhclxuICAgICAgaWYgKCFzaW1wbGVDaGFyKGNoYXJhY3RlcikpIHtcbiAgICAgICAgc2ltcGxlID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdGlsbCBzaW1wbGUuICBJZiB3ZSBtYWtlIGl0IGFsbCB0aGUgd2F5IHRocm91Z2ggbGlrZVxuICAgICAgICAvLyB0aGlzLCB0aGVuIHdlIGNhbiBqdXN0IGR1bXAgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNpbmdsZSAmJiBjaGFyYWN0ZXIgPT09IENIQVJfU0lOR0xFX1FVT1RFKSB7XG4gICAgICBzaW5nbGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBlc2NhcGVTZXEgPSBFU0NBUEVfU0VRVUVOQ0VTW2NoYXJhY3Rlcl07XG4gICAgaGV4RXNjID0gbmVlZHNIZXhFc2NhcGUoY2hhcmFjdGVyKTtcblxuICAgIGlmICghZXNjYXBlU2VxICYmICFoZXhFc2MpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjaGFyYWN0ZXIgIT09IENIQVJfTElORV9GRUVEICYmXG4gICAgICAgIGNoYXJhY3RlciAhPT0gQ0hBUl9ET1VCTEVfUVVPVEUgJiZcbiAgICAgICAgY2hhcmFjdGVyICE9PSBDSEFSX1NJTkdMRV9RVU9URSkge1xuICAgICAgZm9sZGVkID0gZmFsc2U7XG4gICAgICBsaXRlcmFsID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IENIQVJfTElORV9GRUVEKSB7XG4gICAgICBzYXdMaW5lRmVlZCA9IHRydWU7XG4gICAgICBzaW5nbGUgPSBmYWxzZTtcbiAgICAgIGlmIChwb3NpdGlvbiA+IDApIHtcbiAgICAgICAgcHJldmlvdXMgPSBvYmplY3QuY2hhckNvZGVBdChwb3NpdGlvbiAtIDEpO1xuICAgICAgICBpZiAocHJldmlvdXMgPT09IENIQVJfU1BBQ0UpIHtcbiAgICAgICAgICBsaXRlcmFsID0gZmFsc2U7XG4gICAgICAgICAgZm9sZGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb2xkZWQpIHtcbiAgICAgICAgbGluZUxlbmd0aCA9IHBvc2l0aW9uIC0gbGluZVBvc2l0aW9uO1xuICAgICAgICBsaW5lUG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgaWYgKGxpbmVMZW5ndGggPiBsb25nZXN0TGluZSkge1xuICAgICAgICAgIGxvbmdlc3RMaW5lID0gbGluZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGFyYWN0ZXIgIT09IENIQVJfRE9VQkxFX1FVT1RFKSB7XG4gICAgICBzaW5nbGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBkb3VibGUudGFrZVVwVG8ocG9zaXRpb24pO1xuICAgIGRvdWJsZS5lc2NhcGVDaGFyKCk7XG4gIH1cblxuICBpZiAoc2ltcGxlICYmIHRlc3RJbXBsaWNpdFJlc29sdmluZyhzdGF0ZSwgb2JqZWN0KSkge1xuICAgIHNpbXBsZSA9IGZhbHNlO1xuICB9XG5cbiAgbW9kaWZpZXIgPSAnJztcbiAgaWYgKGZvbGRlZCB8fCBsaXRlcmFsKSB7XG4gICAgdHJhaWxpbmdMaW5lQnJlYWtzID0gMDtcbiAgICBpZiAob2JqZWN0LmNoYXJDb2RlQXQob2JqZWN0Lmxlbmd0aCAtIDEpID09PSBDSEFSX0xJTkVfRkVFRCkge1xuICAgICAgdHJhaWxpbmdMaW5lQnJlYWtzICs9IDE7XG4gICAgICBpZiAob2JqZWN0LmNoYXJDb2RlQXQob2JqZWN0Lmxlbmd0aCAtIDIpID09PSBDSEFSX0xJTkVfRkVFRCkge1xuICAgICAgICB0cmFpbGluZ0xpbmVCcmVha3MgKz0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHJhaWxpbmdMaW5lQnJlYWtzID09PSAwKSB7XG4gICAgICBtb2RpZmllciA9ICctJztcbiAgICB9IGVsc2UgaWYgKHRyYWlsaW5nTGluZUJyZWFrcyA9PT0gMikge1xuICAgICAgbW9kaWZpZXIgPSAnKyc7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxpdGVyYWwgJiYgbG9uZ2VzdExpbmUgPCBtYXgpIHtcbiAgICBmb2xkZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIGl0J3MgbGl0ZXJhbGx5IG9uZSBsaW5lLCB0aGVuIGRvbid0IGJvdGhlciB3aXRoIHRoZSBsaXRlcmFsLlxuICAvLyBXZSBtYXkgc3RpbGwgd2FudCB0byBkbyBhIGZvbGQsIHRob3VnaCwgaWYgaXQncyBhIHN1cGVyIGxvbmcgbGluZS5cbiAgaWYgKCFzYXdMaW5lRmVlZCkge1xuICAgIGxpdGVyYWwgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChzaW1wbGUpIHtcbiAgICBzdGF0ZS5kdW1wID0gb2JqZWN0O1xuICB9IGVsc2UgaWYgKHNpbmdsZSkge1xuICAgIHN0YXRlLmR1bXAgPSAnXFwnJyArIG9iamVjdCArICdcXCcnO1xuICB9IGVsc2UgaWYgKGZvbGRlZCkge1xuICAgIHJlc3VsdCA9IGZvbGQob2JqZWN0LCBtYXgpO1xuICAgIHN0YXRlLmR1bXAgPSAnPicgKyBtb2RpZmllciArICdcXG4nICsgaW5kZW50U3RyaW5nKHJlc3VsdCwgaW5kZW50KTtcbiAgfSBlbHNlIGlmIChsaXRlcmFsKSB7XG4gICAgaWYgKCFtb2RpZmllcikge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0LnJlcGxhY2UoL1xcbiQvLCAnJyk7XG4gICAgfVxuICAgIHN0YXRlLmR1bXAgPSAnfCcgKyBtb2RpZmllciArICdcXG4nICsgaW5kZW50U3RyaW5nKG9iamVjdCwgaW5kZW50KTtcbiAgfSBlbHNlIGlmIChkb3VibGUpIHtcbiAgICBkb3VibGUuZmluaXNoKCk7XG4gICAgc3RhdGUuZHVtcCA9ICdcIicgKyBkb3VibGUucmVzdWx0ICsgJ1wiJztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkdW1wIHNjYWxhciB2YWx1ZScpO1xuICB9XG5cbiAgcmV0dXJuO1xufVxuXG4vLyBUaGUgYHRyYWlsaW5nYCB2YXIgaXMgYSByZWdleHAgbWF0Y2ggb2YgYW55IHRyYWlsaW5nIGBcXG5gIGNoYXJhY3RlcnMuXG4vL1xuLy8gVGhlcmUgYXJlIHRocmVlIGNhc2VzIHdlIGNhcmUgYWJvdXQ6XG4vL1xuLy8gMS4gT25lIHRyYWlsaW5nIGBcXG5gIG9uIHRoZSBzdHJpbmcuICBKdXN0IHVzZSBgfGAgb3IgYD5gLlxuLy8gICAgVGhpcyBpcyB0aGUgYXNzdW1lZCBkZWZhdWx0LiAodHJhaWxpbmcgPSBudWxsKVxuLy8gMi4gTm8gdHJhaWxpbmcgYFxcbmAgb24gdGhlIHN0cmluZy4gIFVzZSBgfC1gIG9yIGA+LWAgdG8gXCJjaG9tcFwiIHRoZSBlbmQuXG4vLyAzLiBNb3JlIHRoYW4gb25lIHRyYWlsaW5nIGBcXG5gIG9uIHRoZSBzdHJpbmcuICBVc2UgYHwrYCBvciBgPitgLlxuLy9cbi8vIEluIHRoZSBjYXNlIG9mIGA+K2AsIHRoZXNlIGxpbmUgYnJlYWtzIGFyZSAqbm90KiBkb3VibGVkIChsaWtlIHRoZSBsaW5lXG4vLyBicmVha3Mgd2l0aGluIHRoZSBzdHJpbmcpLCBzbyBpdCdzIGltcG9ydGFudCB0byBvbmx5IGVuZCB3aXRoIHRoZSBleGFjdFxuLy8gc2FtZSBudW1iZXIgYXMgd2Ugc3RhcnRlZC5cbmZ1bmN0aW9uIGZvbGQob2JqZWN0LCBtYXgpIHtcbiAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgcG9zaXRpb24gPSAwLFxuICAgICAgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgIHRyYWlsaW5nID0gL1xcbiskLy5leGVjKG9iamVjdCksXG4gICAgICBuZXdMaW5lO1xuXG4gIGlmICh0cmFpbGluZykge1xuICAgIGxlbmd0aCA9IHRyYWlsaW5nLmluZGV4ICsgMTtcbiAgfVxuXG4gIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xuICAgIG5ld0xpbmUgPSBvYmplY3QuaW5kZXhPZignXFxuJywgcG9zaXRpb24pO1xuICAgIGlmIChuZXdMaW5lID4gbGVuZ3RoIHx8IG5ld0xpbmUgPT09IC0xKSB7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdCArPSAnXFxuXFxuJztcbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSBmb2xkTGluZShvYmplY3Quc2xpY2UocG9zaXRpb24sIGxlbmd0aCksIG1heCk7XG4gICAgICBwb3NpdGlvbiA9IGxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXN1bHQgKz0gJ1xcblxcbic7XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gZm9sZExpbmUob2JqZWN0LnNsaWNlKHBvc2l0aW9uLCBuZXdMaW5lKSwgbWF4KTtcbiAgICAgIHBvc2l0aW9uID0gbmV3TGluZSArIDE7XG4gICAgfVxuICB9XG4gIGlmICh0cmFpbGluZyAmJiB0cmFpbGluZ1swXSAhPT0gJ1xcbicpIHtcbiAgICByZXN1bHQgKz0gdHJhaWxpbmdbMF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmb2xkTGluZShsaW5lLCBtYXgpIHtcbiAgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgcmV0dXJuIGxpbmU7XG4gIH1cblxuICB2YXIgZm9sZFJlID0gL1teXFxzXSBbXlxcc10vZyxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgcHJldk1hdGNoID0gMCxcbiAgICAgIGZvbGRTdGFydCA9IDAsXG4gICAgICBtYXRjaCA9IGZvbGRSZS5leGVjKGxpbmUpLFxuICAgICAgaW5kZXgsXG4gICAgICBmb2xkRW5kLFxuICAgICAgZm9sZGVkO1xuXG4gIHdoaWxlIChtYXRjaCkge1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG5cbiAgICAvLyB3aGVuIHdlIGNyb3NzIHRoZSBtYXggbGVuLCBpZiB0aGUgcHJldmlvdXMgbWF0Y2ggd291bGQndmVcbiAgICAvLyBiZWVuIG9rLCB1c2UgdGhhdCBvbmUsIGFuZCBjYXJyeSBvbi4gIElmIHRoZXJlIHdhcyBubyBwcmV2aW91c1xuICAgIC8vIG1hdGNoIG9uIHRoaXMgZm9sZCBzZWN0aW9uLCB0aGVuIGp1c3QgaGF2ZSBhIGxvbmcgbGluZS5cbiAgICBpZiAoaW5kZXggLSBmb2xkU3RhcnQgPiBtYXgpIHtcbiAgICAgIGlmIChwcmV2TWF0Y2ggIT09IGZvbGRTdGFydCkge1xuICAgICAgICBmb2xkRW5kID0gcHJldk1hdGNoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9sZEVuZCA9IGluZGV4O1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgIH1cbiAgICAgIGZvbGRlZCA9IGxpbmUuc2xpY2UoZm9sZFN0YXJ0LCBmb2xkRW5kKTtcbiAgICAgIHJlc3VsdCArPSBmb2xkZWQ7XG4gICAgICBmb2xkU3RhcnQgPSBmb2xkRW5kICsgMTtcbiAgICB9XG4gICAgcHJldk1hdGNoID0gaW5kZXggKyAxO1xuICAgIG1hdGNoID0gZm9sZFJlLmV4ZWMobGluZSk7XG4gIH1cblxuICBpZiAocmVzdWx0KSB7XG4gICAgcmVzdWx0ICs9ICdcXG4nO1xuICB9XG5cbiAgLy8gaWYgd2UgZW5kIHVwIHdpdGggb25lIGxhc3Qgd29yZCBhdCB0aGUgZW5kLCB0aGVuIHRoZSBsYXN0IGJpdCBtaWdodFxuICAvLyBiZSBzbGlnaHRseSBiaWdnZXIgdGhhbiB3ZSB3YW50ZWQsIGJlY2F1c2Ugd2UgZXhpdGVkIG91dCBvZiB0aGUgbG9vcC5cbiAgaWYgKGZvbGRTdGFydCAhPT0gcHJldk1hdGNoICYmIGxpbmUubGVuZ3RoIC0gZm9sZFN0YXJ0ID4gbWF4KSB7XG4gICAgcmVzdWx0ICs9IGxpbmUuc2xpY2UoZm9sZFN0YXJ0LCBwcmV2TWF0Y2gpICsgJ1xcbicgK1xuICAgICAgICAgICAgICBsaW5lLnNsaWNlKHByZXZNYXRjaCArIDEpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKGZvbGRTdGFydCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBSZXR1cm5zIHRydWUgaWYgY2hhcmFjdGVyIGNhbiBiZSBmb3VuZCBpbiBhIHNpbXBsZSBzY2FsYXJcbmZ1bmN0aW9uIHNpbXBsZUNoYXIoY2hhcmFjdGVyKSB7XG4gIHJldHVybiBDSEFSX1RBQiAgICAgICAgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgIENIQVJfTElORV9GRUVEICAgICAgICAgICAgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgQ0hBUl9DQVJSSUFHRV9SRVRVUk4gICAgICAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICBDSEFSX0NPTU1BICAgICAgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVCAgICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgIENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVCAgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgQ0hBUl9TSEFSUCAgICAgICAgICAgICAgICAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICBDSEFSX0FNUEVSU0FORCAgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgIENIQVJfQVNURVJJU0sgICAgICAgICAgICAgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgQ0hBUl9FWENMQU1BVElPTiAgICAgICAgICAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICBDSEFSX1ZFUlRJQ0FMX0xJTkUgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgIENIQVJfR1JFQVRFUl9USEFOICAgICAgICAgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgQ0hBUl9TSU5HTEVfUVVPVEUgICAgICAgICAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICBDSEFSX0RPVUJMRV9RVU9URSAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgIENIQVJfUEVSQ0VOVCAgICAgICAgICAgICAgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgQ0hBUl9DT0xPTiAgICAgICAgICAgICAgICAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICAhRVNDQVBFX1NFUVVFTkNFU1tjaGFyYWN0ZXJdICAgICAgICAgICAgJiZcbiAgICAgICAgICFuZWVkc0hleEVzY2FwZShjaGFyYWN0ZXIpO1xufVxuXG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIGNoYXJhY3RlciBjb2RlIG5lZWRzIHRvIGJlIGVzY2FwZWQuXG5mdW5jdGlvbiBuZWVkc0hleEVzY2FwZShjaGFyYWN0ZXIpIHtcbiAgcmV0dXJuICEoKDB4MDAwMjAgPD0gY2hhcmFjdGVyICYmIGNoYXJhY3RlciA8PSAweDAwMDA3RSkgfHxcbiAgICAgICAgICAgKDB4MDAwODUgPT09IGNoYXJhY3RlcikgICAgICAgICAgICAgICAgICAgICAgICAgfHxcbiAgICAgICAgICAgKDB4MDAwQTAgPD0gY2hhcmFjdGVyICYmIGNoYXJhY3RlciA8PSAweDAwRDdGRikgfHxcbiAgICAgICAgICAgKDB4MEUwMDAgPD0gY2hhcmFjdGVyICYmIGNoYXJhY3RlciA8PSAweDAwRkZGRCkgfHxcbiAgICAgICAgICAgKDB4MTAwMDAgPD0gY2hhcmFjdGVyICYmIGNoYXJhY3RlciA8PSAweDEwRkZGRikpO1xufVxuXG5mdW5jdGlvbiB3cml0ZUZsb3dTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCkge1xuICB2YXIgX3Jlc3VsdCA9ICcnLFxuICAgICAgX3RhZyAgICA9IHN0YXRlLnRhZyxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIC8vIFdyaXRlIG9ubHkgdmFsaWQgZWxlbWVudHMuXG4gICAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdFtpbmRleF0sIGZhbHNlLCBmYWxzZSkpIHtcbiAgICAgIGlmICgwICE9PSBpbmRleCkge1xuICAgICAgICBfcmVzdWx0ICs9ICcsICc7XG4gICAgICB9XG4gICAgICBfcmVzdWx0ICs9IHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICdbJyArIF9yZXN1bHQgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgY29tcGFjdCkge1xuICB2YXIgX3Jlc3VsdCA9ICcnLFxuICAgICAgX3RhZyAgICA9IHN0YXRlLnRhZyxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIC8vIFdyaXRlIG9ubHkgdmFsaWQgZWxlbWVudHMuXG4gICAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RbaW5kZXhdLCB0cnVlLCB0cnVlKSkge1xuICAgICAgaWYgKCFjb21wYWN0IHx8IDAgIT09IGluZGV4KSB7XG4gICAgICAgIF9yZXN1bHQgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgICAgfVxuICAgICAgX3Jlc3VsdCArPSAnLSAnICsgc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAnW10nOyAvLyBFbXB0eSBzZXF1ZW5jZSBpZiBubyB2YWxpZCB2YWx1ZXMuXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvd01hcHBpbmcoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgICAgICAgPSAnJyxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgb2JqZWN0S2V5LFxuICAgICAgb2JqZWN0VmFsdWUsXG4gICAgICBwYWlyQnVmZmVyO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyQnVmZmVyID0gJyc7XG5cbiAgICBpZiAoMCAhPT0gaW5kZXgpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJywgJztcbiAgICB9XG5cbiAgICBvYmplY3RLZXkgPSBvYmplY3RLZXlMaXN0W2luZGV4XTtcbiAgICBvYmplY3RWYWx1ZSA9IG9iamVjdFtvYmplY3RLZXldO1xuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RLZXksIGZhbHNlLCBmYWxzZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQga2V5O1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wLmxlbmd0aCA+IDEwMjQpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJz8gJztcbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXAgKyAnOiAnO1xuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RWYWx1ZSwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCB2YWx1ZS5cbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7XG5cbiAgICAvLyBCb3RoIGtleSBhbmQgdmFsdWUgYXJlIHZhbGlkLlxuICAgIF9yZXN1bHQgKz0gcGFpckJ1ZmZlcjtcbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSAneycgKyBfcmVzdWx0ICsgJ30nO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJsb2NrTWFwcGluZyhzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgY29tcGFjdCkge1xuICB2YXIgX3Jlc3VsdCAgICAgICA9ICcnLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBvYmplY3RLZXksXG4gICAgICBvYmplY3RWYWx1ZSxcbiAgICAgIGV4cGxpY2l0UGFpcixcbiAgICAgIHBhaXJCdWZmZXI7XG5cbiAgLy8gQWxsb3cgc29ydGluZyBrZXlzIHNvIHRoYXQgdGhlIG91dHB1dCBmaWxlIGlzIGRldGVybWluaXN0aWNcbiAgaWYgKHN0YXRlLnNvcnRLZXlzID09PSB0cnVlKSB7XG4gICAgLy8gRGVmYXVsdCBzb3J0aW5nXG4gICAgb2JqZWN0S2V5TGlzdC5zb3J0KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN0YXRlLnNvcnRLZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gQ3VzdG9tIHNvcnQgZnVuY3Rpb25cbiAgICBvYmplY3RLZXlMaXN0LnNvcnQoc3RhdGUuc29ydEtleXMpO1xuICB9IGVsc2UgaWYgKHN0YXRlLnNvcnRLZXlzKSB7XG4gICAgLy8gU29tZXRoaW5nIGlzIHdyb25nXG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ3NvcnRLZXlzIG11c3QgYmUgYSBib29sZWFuIG9yIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyQnVmZmVyID0gJyc7XG5cbiAgICBpZiAoIWNvbXBhY3QgfHwgMCAhPT0gaW5kZXgpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RLZXksIHRydWUsIHRydWUsIHRydWUpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleS5cbiAgICB9XG5cbiAgICBleHBsaWNpdFBhaXIgPSAobnVsbCAhPT0gc3RhdGUudGFnICYmICc/JyAhPT0gc3RhdGUudGFnKSB8fFxuICAgICAgICAgICAgICAgICAgIChzdGF0ZS5kdW1wICYmIHN0YXRlLmR1bXAubGVuZ3RoID4gMTAyNCk7XG5cbiAgICBpZiAoZXhwbGljaXRQYWlyKSB7XG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJz8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdFZhbHVlLCB0cnVlLCBleHBsaWNpdFBhaXIpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzonO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc6ICc7XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAne30nOyAvLyBFbXB0eSBtYXBwaW5nIGlmIG5vIHZhbGlkIHBhaXJzLlxufVxuXG5mdW5jdGlvbiBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIGV4cGxpY2l0KSB7XG4gIHZhciBfcmVzdWx0LCB0eXBlTGlzdCwgaW5kZXgsIGxlbmd0aCwgdHlwZSwgc3R5bGU7XG5cbiAgdHlwZUxpc3QgPSBleHBsaWNpdCA/IHN0YXRlLmV4cGxpY2l0VHlwZXMgOiBzdGF0ZS5pbXBsaWNpdFR5cGVzO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB0eXBlTGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHR5cGVMaXN0W2luZGV4XTtcblxuICAgIGlmICgodHlwZS5pbnN0YW5jZU9mICB8fCB0eXBlLnByZWRpY2F0ZSkgJiZcbiAgICAgICAgKCF0eXBlLmluc3RhbmNlT2YgfHwgKCgnb2JqZWN0JyA9PT0gdHlwZW9mIG9iamVjdCkgJiYgKG9iamVjdCBpbnN0YW5jZW9mIHR5cGUuaW5zdGFuY2VPZikpKSAmJlxuICAgICAgICAoIXR5cGUucHJlZGljYXRlICB8fCB0eXBlLnByZWRpY2F0ZShvYmplY3QpKSkge1xuXG4gICAgICBzdGF0ZS50YWcgPSBleHBsaWNpdCA/IHR5cGUudGFnIDogJz8nO1xuXG4gICAgICBpZiAodHlwZS5yZXByZXNlbnQpIHtcbiAgICAgICAgc3R5bGUgPSBzdGF0ZS5zdHlsZU1hcFt0eXBlLnRhZ10gfHwgdHlwZS5kZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgaWYgKCdbb2JqZWN0IEZ1bmN0aW9uXScgPT09IF90b1N0cmluZy5jYWxsKHR5cGUucmVwcmVzZW50KSkge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudChvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLnJlcHJlc2VudCwgc3R5bGUpKSB7XG4gICAgICAgICAgX3Jlc3VsdCA9IHR5cGUucmVwcmVzZW50W3N0eWxlXShvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignITwnICsgdHlwZS50YWcgKyAnPiB0YWcgcmVzb2x2ZXIgYWNjZXB0cyBub3QgXCInICsgc3R5bGUgKyAnXCIgc3R5bGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmR1bXAgPSBfcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFNlcmlhbGl6ZXMgYG9iamVjdGAgYW5kIHdyaXRlcyBpdCB0byBnbG9iYWwgYHJlc3VsdGAuXG4vLyBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcywgb3IgZmFsc2Ugb24gaW52YWxpZCBvYmplY3QuXG4vL1xuZnVuY3Rpb24gd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBibG9jaywgY29tcGFjdCwgaXNrZXkpIHtcbiAgc3RhdGUudGFnID0gbnVsbDtcbiAgc3RhdGUuZHVtcCA9IG9iamVjdDtcblxuICBpZiAoIWRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZmFsc2UpKSB7XG4gICAgZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCB0cnVlKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gX3RvU3RyaW5nLmNhbGwoc3RhdGUuZHVtcCk7XG5cbiAgaWYgKGJsb2NrKSB7XG4gICAgYmxvY2sgPSAoMCA+IHN0YXRlLmZsb3dMZXZlbCB8fCBzdGF0ZS5mbG93TGV2ZWwgPiBsZXZlbCk7XG4gIH1cblxuICB2YXIgb2JqZWN0T3JBcnJheSA9ICdbb2JqZWN0IE9iamVjdF0nID09PSB0eXBlIHx8ICdbb2JqZWN0IEFycmF5XScgPT09IHR5cGUsXG4gICAgICBkdXBsaWNhdGVJbmRleCxcbiAgICAgIGR1cGxpY2F0ZTtcblxuICBpZiAob2JqZWN0T3JBcnJheSkge1xuICAgIGR1cGxpY2F0ZUluZGV4ID0gc3RhdGUuZHVwbGljYXRlcy5pbmRleE9mKG9iamVjdCk7XG4gICAgZHVwbGljYXRlID0gZHVwbGljYXRlSW5kZXggIT09IC0xO1xuICB9XG5cbiAgaWYgKChudWxsICE9PSBzdGF0ZS50YWcgJiYgJz8nICE9PSBzdGF0ZS50YWcpIHx8IGR1cGxpY2F0ZSB8fCAoMiAhPT0gc3RhdGUuaW5kZW50ICYmIGxldmVsID4gMCkpIHtcbiAgICBjb21wYWN0ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoZHVwbGljYXRlICYmIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgIHN0YXRlLmR1bXAgPSAnKnJlZl8nICsgZHVwbGljYXRlSW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9iamVjdE9yQXJyYXkgJiYgZHVwbGljYXRlICYmICFzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0pIHtcbiAgICAgIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSA9IHRydWU7XG4gICAgfVxuICAgIGlmICgnW29iamVjdCBPYmplY3RdJyA9PT0gdHlwZSkge1xuICAgICAgaWYgKGJsb2NrICYmICgwICE9PSBPYmplY3Qua2V5cyhzdGF0ZS5kdW1wKS5sZW5ndGgpKSB7XG4gICAgICAgIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCwgY29tcGFjdCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXApO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCdbb2JqZWN0IEFycmF5XScgPT09IHR5cGUpIHtcbiAgICAgIGlmIChibG9jayAmJiAoMCAhPT0gc3RhdGUuZHVtcC5sZW5ndGgpKSB7XG4gICAgICAgIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXAsIGNvbXBhY3QpO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJ1tvYmplY3QgU3RyaW5nXScgPT09IHR5cGUpIHtcbiAgICAgIGlmICgnPycgIT09IHN0YXRlLnRhZykge1xuICAgICAgICB3cml0ZVNjYWxhcihzdGF0ZSwgc3RhdGUuZHVtcCwgbGV2ZWwsIGlza2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLnNraXBJbnZhbGlkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCd1bmFjY2VwdGFibGUga2luZCBvZiBhbiBvYmplY3QgdG8gZHVtcCAnICsgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKG51bGwgIT09IHN0YXRlLnRhZyAmJiAnPycgIT09IHN0YXRlLnRhZykge1xuICAgICAgc3RhdGUuZHVtcCA9ICchPCcgKyBzdGF0ZS50YWcgKyAnPiAnICsgc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhvYmplY3QsIHN0YXRlKSB7XG4gIHZhciBvYmplY3RzID0gW10sXG4gICAgICBkdXBsaWNhdGVzSW5kZXhlcyA9IFtdLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgaW5zcGVjdE5vZGUob2JqZWN0LCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGR1cGxpY2F0ZXNJbmRleGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBzdGF0ZS5kdXBsaWNhdGVzLnB1c2gob2JqZWN0c1tkdXBsaWNhdGVzSW5kZXhlc1tpbmRleF1dKTtcbiAgfVxuICBzdGF0ZS51c2VkRHVwbGljYXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0Tm9kZShvYmplY3QsIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKSB7XG4gIHZhciBvYmplY3RLZXlMaXN0LFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgaWYgKG51bGwgIT09IG9iamVjdCAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG9iamVjdCkge1xuICAgIGluZGV4ID0gb2JqZWN0cy5pbmRleE9mKG9iamVjdCk7XG4gICAgaWYgKC0xICE9PSBpbmRleCkge1xuICAgICAgaWYgKC0xID09PSBkdXBsaWNhdGVzSW5kZXhlcy5pbmRleE9mKGluZGV4KSkge1xuICAgICAgICBkdXBsaWNhdGVzSW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0cy5wdXNoKG9iamVjdCk7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgaW5zcGVjdE5vZGUob2JqZWN0W2luZGV4XSwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgaW5zcGVjdE5vZGUob2JqZWN0W29iamVjdEtleUxpc3RbaW5kZXhdXSwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGR1bXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKG9wdGlvbnMpO1xuXG4gIGdldER1cGxpY2F0ZVJlZmVyZW5jZXMoaW5wdXQsIHN0YXRlKTtcblxuICBpZiAod3JpdGVOb2RlKHN0YXRlLCAwLCBpbnB1dCwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICByZXR1cm4gc3RhdGUuZHVtcCArICdcXG4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gc2FmZUR1bXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGR1bXAoaW5wdXQsIGNvbW1vbi5leHRlbmQoeyBzY2hlbWE6IERFRkFVTFRfU0FGRV9TQ0hFTUEgfSwgb3B0aW9ucykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5kdW1wICAgICA9IGR1bXA7XG5tb2R1bGUuZXhwb3J0cy5zYWZlRHVtcCA9IHNhZmVEdW1wO1xuIiwiLy8gWUFNTCBlcnJvciBjbGFzcy4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NDU4OTg0XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcblxuXG5mdW5jdGlvbiBZQU1MRXhjZXB0aW9uKHJlYXNvbiwgbWFyaykge1xuICAvLyBTdXBlciBjb25zdHJ1Y3RvclxuICBFcnJvci5jYWxsKHRoaXMpO1xuXG4gIC8vIEluY2x1ZGUgc3RhY2sgdHJhY2UgaW4gZXJyb3Igb2JqZWN0XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIC8vIENocm9tZSBhbmQgTm9kZUpTXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gRkYsIElFIDEwKyBhbmQgU2FmYXJpIDYrLiBGYWxsYmFjayBmb3Igb3RoZXJzXG4gICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2sgfHwgJyc7XG4gIH1cblxuICB0aGlzLm5hbWUgPSAnWUFNTEV4Y2VwdGlvbic7XG4gIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB0aGlzLm1hcmsgPSBtYXJrO1xuICB0aGlzLm1lc3NhZ2UgPSAodGhpcy5yZWFzb24gfHwgJyh1bmtub3duIHJlYXNvbiknKSArICh0aGlzLm1hcmsgPyAnICcgKyB0aGlzLm1hcmsudG9TdHJpbmcoKSA6ICcnKTtcbn1cblxuXG4vLyBJbmhlcml0IGZyb20gRXJyb3JcbmluaGVyaXRzKFlBTUxFeGNlcHRpb24sIEVycm9yKTtcblxuXG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMubmFtZSArICc6ICc7XG5cbiAgcmVzdWx0ICs9IHRoaXMucmVhc29uIHx8ICcodW5rbm93biByZWFzb24pJztcblxuICBpZiAoIWNvbXBhY3QgJiYgdGhpcy5tYXJrKSB7XG4gICAgcmVzdWx0ICs9ICcgJyArIHRoaXMubWFyay50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBZQU1MRXhjZXB0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4sbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG52YXIgY29tbW9uICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgTWFyayAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vbWFyaycpO1xudmFyIERFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcbnZhciBERUZBVUxUX0ZVTExfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblxudmFyIENPTlRFWFRfRkxPV19JTiAgID0gMTtcbnZhciBDT05URVhUX0ZMT1dfT1VUICA9IDI7XG52YXIgQ09OVEVYVF9CTE9DS19JTiAgPSAzO1xudmFyIENPTlRFWFRfQkxPQ0tfT1VUID0gNDtcblxuXG52YXIgQ0hPTVBJTkdfQ0xJUCAgPSAxO1xudmFyIENIT01QSU5HX1NUUklQID0gMjtcbnZhciBDSE9NUElOR19LRUVQICA9IDM7XG5cblxudmFyIFBBVFRFUk5fTk9OX1BSSU5UQUJMRSAgICAgICAgID0gL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGLVxceDg0XFx4ODYtXFx4OUZcXHVGRkZFXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vO1xudmFyIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTID0gL1tcXHg4NVxcdTIwMjhcXHUyMDI5XS87XG52YXIgUEFUVEVSTl9GTE9XX0lORElDQVRPUlMgICAgICAgPSAvWyxcXFtcXF1cXHtcXH1dLztcbnZhciBQQVRURVJOX1RBR19IQU5ETEUgICAgICAgICAgICA9IC9eKD86IXwhIXwhW2EtelxcLV0rISkkL2k7XG52YXIgUEFUVEVSTl9UQUdfVVJJICAgICAgICAgICAgICAgPSAvXig/OiF8W14sXFxbXFxdXFx7XFx9XSkoPzolWzAtOWEtZl17Mn18WzAtOWEtelxcLSM7XFwvXFw/OkAmPVxcK1xcJCxfXFwuIX5cXConXFwoXFwpXFxbXFxdXSkqJC9pO1xuXG5cbmZ1bmN0aW9uIGlzX0VPTChjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwQS8qIExGICovKSB8fCAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV0hJVEVfU1BBQ0UoYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8IChjID09PSAweDIwLyogU3BhY2UgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19XU19PUl9FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MEEvKiBMRiAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBELyogQ1IgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19GTE9XX0lORElDQVRPUihjKSB7XG4gIHJldHVybiAweDJDLyogLCAqLyA9PT0gYyB8fFxuICAgICAgICAgMHg1Qi8qIFsgKi8gPT09IGMgfHxcbiAgICAgICAgIDB4NUQvKiBdICovID09PSBjIHx8XG4gICAgICAgICAweDdCLyogeyAqLyA9PT0gYyB8fFxuICAgICAgICAgMHg3RC8qIH0gKi8gPT09IGM7XG59XG5cbmZ1bmN0aW9uIGZyb21IZXhDb2RlKGMpIHtcbiAgdmFyIGxjO1xuXG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cbiAgbGMgPSBjIHwgMHgyMDtcblxuICBpZiAoKDB4NjEvKiBhICovIDw9IGxjKSAmJiAobGMgPD0gMHg2Ni8qIGYgKi8pKSB7XG4gICAgcmV0dXJuIGxjIC0gMHg2MSArIDEwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVkSGV4TGVuKGMpIHtcbiAgaWYgKGMgPT09IDB4NzgvKiB4ICovKSB7IHJldHVybiAyOyB9XG4gIGlmIChjID09PSAweDc1LyogdSAqLykgeyByZXR1cm4gNDsgfVxuICBpZiAoYyA9PT0gMHg1NS8qIFUgKi8pIHsgcmV0dXJuIDg7IH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGZyb21EZWNpbWFsQ29kZShjKSB7XG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFc2NhcGVTZXF1ZW5jZShjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgzMC8qIDAgKi8pID8gJ1xceDAwJyA6XG4gICAgICAgIChjID09PSAweDYxLyogYSAqLykgPyAnXFx4MDcnIDpcbiAgICAgICAgKGMgPT09IDB4NjIvKiBiICovKSA/ICdcXHgwOCcgOlxuICAgICAgICAoYyA9PT0gMHg3NC8qIHQgKi8pID8gJ1xceDA5JyA6XG4gICAgICAgIChjID09PSAweDA5LyogVGFiICovKSA/ICdcXHgwOScgOlxuICAgICAgICAoYyA9PT0gMHg2RS8qIG4gKi8pID8gJ1xceDBBJyA6XG4gICAgICAgIChjID09PSAweDc2LyogdiAqLykgPyAnXFx4MEInIDpcbiAgICAgICAgKGMgPT09IDB4NjYvKiBmICovKSA/ICdcXHgwQycgOlxuICAgICAgICAoYyA9PT0gMHg3Mi8qIHIgKi8pID8gJ1xceDBEJyA6XG4gICAgICAgIChjID09PSAweDY1LyogZSAqLykgPyAnXFx4MUInIDpcbiAgICAgICAgKGMgPT09IDB4MjAvKiBTcGFjZSAqLykgPyAnICcgOlxuICAgICAgICAoYyA9PT0gMHgyMi8qIFwiICovKSA/ICdcXHgyMicgOlxuICAgICAgICAoYyA9PT0gMHgyRi8qIC8gKi8pID8gJy8nIDpcbiAgICAgICAgKGMgPT09IDB4NUMvKiBcXCAqLykgPyAnXFx4NUMnIDpcbiAgICAgICAgKGMgPT09IDB4NEUvKiBOICovKSA/ICdcXHg4NScgOlxuICAgICAgICAoYyA9PT0gMHg1Ri8qIF8gKi8pID8gJ1xceEEwJyA6XG4gICAgICAgIChjID09PSAweDRDLyogTCAqLykgPyAnXFx1MjAyOCcgOlxuICAgICAgICAoYyA9PT0gMHg1MC8qIFAgKi8pID8gJ1xcdTIwMjknIDogJyc7XG59XG5cbmZ1bmN0aW9uIGNoYXJGcm9tQ29kZXBvaW50KGMpIHtcbiAgaWYgKGMgPD0gMHhGRkZGKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gIH1cbiAgLy8gRW5jb2RlIFVURi0xNiBzdXJyb2dhdGUgcGFpclxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtMTYjQ29kZV9wb2ludHNfVS4yQjAxMDAwMF90b19VLjJCMTBGRkZGXG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAtIDB4MDEwMDAwKSA+PiAxMCkgKyAweEQ4MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoYyAtIDB4MDEwMDAwKSAmIDB4MDNGRikgKyAweERDMDApO1xufVxuXG52YXIgc2ltcGxlRXNjYXBlQ2hlY2sgPSBuZXcgQXJyYXkoMjU2KTsgLy8gaW50ZWdlciwgZm9yIGZhc3QgYWNjZXNzXG52YXIgc2ltcGxlRXNjYXBlTWFwID0gbmV3IEFycmF5KDI1Nik7XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gIHNpbXBsZUVzY2FwZUNoZWNrW2ldID0gc2ltcGxlRXNjYXBlU2VxdWVuY2UoaSkgPyAxIDogMDtcbiAgc2ltcGxlRXNjYXBlTWFwW2ldID0gc2ltcGxlRXNjYXBlU2VxdWVuY2UoaSk7XG59XG5cblxuZnVuY3Rpb24gU3RhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xuXG4gIHRoaXMuZmlsZW5hbWUgID0gb3B0aW9uc1snZmlsZW5hbWUnXSAgfHwgbnVsbDtcbiAgdGhpcy5zY2hlbWEgICAgPSBvcHRpb25zWydzY2hlbWEnXSAgICB8fCBERUZBVUxUX0ZVTExfU0NIRU1BO1xuICB0aGlzLm9uV2FybmluZyA9IG9wdGlvbnNbJ29uV2FybmluZyddIHx8IG51bGw7XG4gIHRoaXMubGVnYWN5ICAgID0gb3B0aW9uc1snbGVnYWN5J10gICAgfHwgZmFsc2U7XG5cbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy50eXBlTWFwICAgICAgID0gdGhpcy5zY2hlbWEuY29tcGlsZWRUeXBlTWFwO1xuXG4gIHRoaXMubGVuZ3RoICAgICA9IGlucHV0Lmxlbmd0aDtcbiAgdGhpcy5wb3NpdGlvbiAgID0gMDtcbiAgdGhpcy5saW5lICAgICAgID0gMDtcbiAgdGhpcy5saW5lU3RhcnQgID0gMDtcbiAgdGhpcy5saW5lSW5kZW50ID0gMDtcblxuICB0aGlzLmRvY3VtZW50cyA9IFtdO1xuXG4gIC8qXG4gIHRoaXMudmVyc2lvbjtcbiAgdGhpcy5jaGVja0xpbmVCcmVha3M7XG4gIHRoaXMudGFnTWFwO1xuICB0aGlzLmFuY2hvck1hcDtcbiAgdGhpcy50YWc7XG4gIHRoaXMuYW5jaG9yO1xuICB0aGlzLmtpbmQ7XG4gIHRoaXMucmVzdWx0OyovXG5cbn1cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgWUFNTEV4Y2VwdGlvbihcbiAgICBtZXNzYWdlLFxuICAgIG5ldyBNYXJrKHN0YXRlLmZpbGVuYW1lLCBzdGF0ZS5pbnB1dCwgc3RhdGUucG9zaXRpb24sIHN0YXRlLmxpbmUsIChzdGF0ZS5wb3NpdGlvbiAtIHN0YXRlLmxpbmVTdGFydCkpKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB0aHJvdyBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dXYXJuaW5nKHN0YXRlLCBtZXNzYWdlKSB7XG4gIGlmIChzdGF0ZS5vbldhcm5pbmcpIHtcbiAgICBzdGF0ZS5vbldhcm5pbmcuY2FsbChudWxsLCBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSk7XG4gIH1cbn1cblxuXG52YXIgZGlyZWN0aXZlSGFuZGxlcnMgPSB7XG5cbiAgWUFNTDogZnVuY3Rpb24gaGFuZGxlWWFtbERpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgICB2YXIgbWF0Y2gsIG1ham9yLCBtaW5vcjtcblxuICAgICAgaWYgKG51bGwgIT09IHN0YXRlLnZlcnNpb24pIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mICVZQU1MIGRpcmVjdGl2ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoMSAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1lBTUwgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSBvbmUgYXJndW1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSAvXihbMC05XSspXFwuKFswLTldKykkLy5leGVjKGFyZ3NbMF0pO1xuXG4gICAgICBpZiAobnVsbCA9PT0gbWF0Y2gpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgYXJndW1lbnQgb2YgdGhlIFlBTUwgZGlyZWN0aXZlJyk7XG4gICAgICB9XG5cbiAgICAgIG1ham9yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgIG1pbm9yID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKTtcblxuICAgICAgaWYgKDEgIT09IG1ham9yKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS52ZXJzaW9uID0gYXJnc1swXTtcbiAgICAgIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IChtaW5vciA8IDIpO1xuXG4gICAgICBpZiAoMSAhPT0gbWlub3IgJiYgMiAhPT0gbWlub3IpIHtcbiAgICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgVEFHOiBmdW5jdGlvbiBoYW5kbGVUYWdEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcblxuICAgICAgdmFyIGhhbmRsZSwgcHJlZml4O1xuXG4gICAgICBpZiAoMiAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1RBRyBkaXJlY3RpdmUgYWNjZXB0cyBleGFjdGx5IHR3byBhcmd1bWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgaGFuZGxlID0gYXJnc1swXTtcbiAgICAgIHByZWZpeCA9IGFyZ3NbMV07XG5cbiAgICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QoaGFuZGxlKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgaGFuZGxlKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlcmUgaXMgYSBwcmV2aW91c2x5IGRlY2xhcmVkIHN1ZmZpeCBmb3IgXCInICsgaGFuZGxlICsgJ1wiIHRhZyBoYW5kbGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFQQVRURVJOX1RBR19VUkkudGVzdChwcmVmaXgpKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIHRhZyBwcmVmaXggKHNlY29uZCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUudGFnTWFwW2hhbmRsZV0gPSBwcmVmaXg7XG4gICAgfVxufTtcblxuXG5mdW5jdGlvbiBjYXB0dXJlU2VnbWVudChzdGF0ZSwgc3RhcnQsIGVuZCwgY2hlY2tKc29uKSB7XG4gIHZhciBfcG9zaXRpb24sIF9sZW5ndGgsIF9jaGFyYWN0ZXIsIF9yZXN1bHQ7XG5cbiAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgX3Jlc3VsdCA9IHN0YXRlLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgaWYgKGNoZWNrSnNvbikge1xuICAgICAgZm9yIChfcG9zaXRpb24gPSAwLCBfbGVuZ3RoID0gX3Jlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgIF9wb3NpdGlvbiA8IF9sZW5ndGg7XG4gICAgICAgICAgIF9wb3NpdGlvbiArPSAxKSB7XG4gICAgICAgIF9jaGFyYWN0ZXIgPSBfcmVzdWx0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcbiAgICAgICAgaWYgKCEoMHgwOSA9PT0gX2NoYXJhY3RlciB8fFxuICAgICAgICAgICAgICAweDIwIDw9IF9jaGFyYWN0ZXIgJiYgX2NoYXJhY3RlciA8PSAweDEwRkZGRikpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgdmFsaWQgSlNPTiBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLnJlc3VsdCArPSBfcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFwcGluZ3Moc3RhdGUsIGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgdmFyIHNvdXJjZUtleXMsIGtleSwgaW5kZXgsIHF1YW50aXR5O1xuXG4gIGlmICghY29tbW9uLmlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IG1lcmdlIG1hcHBpbmdzOyB0aGUgcHJvdmlkZWQgc291cmNlIG9iamVjdCBpcyB1bmFjY2VwdGFibGUnKTtcbiAgfVxuXG4gIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpbmRleF07XG5cbiAgICBpZiAoIV9oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc3RpbmF0aW9uLCBrZXkpKSB7XG4gICAgICBkZXN0aW5hdGlvbltrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKSB7XG4gIHZhciBpbmRleCwgcXVhbnRpdHk7XG5cbiAga2V5Tm9kZSA9IFN0cmluZyhrZXlOb2RlKTtcblxuICBpZiAobnVsbCA9PT0gX3Jlc3VsdCkge1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfVxuXG4gIGlmICgndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnID09PSBrZXlUYWcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZU5vZGUpKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSB2YWx1ZU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZVtpbmRleF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZU1hcHBpbmdzKHN0YXRlLCBfcmVzdWx0LCB2YWx1ZU5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBfcmVzdWx0W2tleU5vZGVdID0gdmFsdWVOb2RlO1xuICB9XG5cbiAgcmV0dXJuIF9yZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRMaW5lQnJlYWsoc3RhdGUpIHtcbiAgdmFyIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKDB4MEEvKiBMRiAqLyA9PT0gY2gpIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICB9IGVsc2UgaWYgKDB4MEQvKiBDUiAqLyA9PT0gY2gpIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIGlmICgweDBBLyogTEYgKi8gPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSBsaW5lIGJyZWFrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBzdGF0ZS5saW5lICs9IDE7XG4gIHN0YXRlLmxpbmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBhbGxvd0NvbW1lbnRzLCBjaGVja0luZGVudCkge1xuICB2YXIgbGluZUJyZWFrcyA9IDAsXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlICgwICE9PSBjaCkge1xuICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dDb21tZW50cyAmJiAweDIzLyogIyAqLyA9PT0gY2gpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfSB3aGlsZSAoY2ggIT09IDB4MEEvKiBMRiAqLyAmJiBjaCAhPT0gMHgwRC8qIENSICovICYmIDAgIT09IGNoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBsaW5lQnJlYWtzKys7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgICAgd2hpbGUgKDB4MjAvKiBTcGFjZSAqLyA9PT0gY2gpIHtcbiAgICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICgtMSAhPT0gY2hlY2tJbmRlbnQgJiYgMCAhPT0gbGluZUJyZWFrcyAmJiBzdGF0ZS5saW5lSW5kZW50IDwgY2hlY2tJbmRlbnQpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdkZWZpY2llbnQgaW5kZW50YXRpb24nKTtcbiAgfVxuXG4gIHJldHVybiBsaW5lQnJlYWtzO1xufVxuXG5mdW5jdGlvbiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgLy8gQ29uZGl0aW9uIHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgaXMgdGVzdGVkXG4gIC8vIGluIHBhcmVudCBvbiBlYWNoIGNhbGwsIGZvciBlZmZpY2llbmN5LiBObyBuZWVkcyB0byB0ZXN0IGhlcmUgYWdhaW4uXG4gIGlmICgoMHgyRC8qIC0gKi8gPT09IGNoIHx8IDB4MkUvKiAuICovID09PSBjaCkgJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMSkgPT09IGNoICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbiArIDIpID09PSBjaCkge1xuXG4gICAgX3Bvc2l0aW9uICs9IDM7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMCB8fCBpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIGNvdW50KSB7XG4gIGlmICgxID09PSBjb3VudCkge1xuICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gIH0gZWxzZSBpZiAoY291bnQgPiAxKSB7XG4gICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGNvdW50IC0gMSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiByZWFkUGxhaW5TY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQsIHdpdGhpbkZsb3dDb2xsZWN0aW9uKSB7XG4gIHZhciBwcmVjZWRpbmcsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGFzUGVuZGluZ0NvbnRlbnQsXG4gICAgICBfbGluZSxcbiAgICAgIF9saW5lU3RhcnQsXG4gICAgICBfbGluZUluZGVudCxcbiAgICAgIF9raW5kID0gc3RhdGUua2luZCxcbiAgICAgIF9yZXN1bHQgPSBzdGF0ZS5yZXN1bHQsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChpc19XU19PUl9FT0woY2gpICAgICAgICAgICAgIHx8XG4gICAgICBpc19GTE9XX0lORElDQVRPUihjaCkgICAgICAgIHx8XG4gICAgICAweDIzLyogIyAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDI2LyogJiAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDJBLyogKiAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDIxLyogISAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDdDLyogfCAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDNFLyogPiAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDI3LyogJyAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDIyLyogXCIgKi8gICAgICAgICAgID09PSBjaCB8fFxuICAgICAgMHgyNS8qICUgKi8gICAgICAgICAgID09PSBjaCB8fFxuICAgICAgMHg0MC8qIEAgKi8gICAgICAgICAgID09PSBjaCB8fFxuICAgICAgMHg2MC8qIGAgKi8gICAgICAgICAgID09PSBjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICgweDNGLyogPyAqLyA9PT0gY2ggfHwgMHgyRC8qIC0gKi8gPT09IGNoKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8XG4gICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG5cbiAgd2hpbGUgKDAgIT09IGNoKSB7XG4gICAgaWYgKDB4M0EvKiA6ICovID09PSBjaCkge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgweDIzLyogIyAqLyA9PT0gY2gpIHtcbiAgICAgIHByZWNlZGluZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gLSAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChwcmVjZWRpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB8fFxuICAgICAgICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgICBicmVhaztcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2xpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9saW5lSW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCAtMSk7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID49IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uID0gY2FwdHVyZUVuZDtcbiAgICAgICAgc3RhdGUubGluZSA9IF9saW5lO1xuICAgICAgICBzdGF0ZS5saW5lU3RhcnQgPSBfbGluZVN0YXJ0O1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50ID0gX2xpbmVJbmRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQ29udGVudCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc3RhdGUubGluZSAtIF9saW5lKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuXG4gIGlmIChzdGF0ZS5yZXN1bHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSBfa2luZDtcbiAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmICgweDI3LyogJyAqLyAhPT0gY2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKDAgIT09IChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSkge1xuICAgIGlmICgweDI3LyogJyAqLyA9PT0gY2gpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKDB4MjcvKiAnICovID09PSBjaCkge1xuICAgICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgc2luZ2xlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWREb3VibGVRdW90ZWRTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNhcHR1cmVTdGFydCxcbiAgICAgIGNhcHR1cmVFbmQsXG4gICAgICBoZXhMZW5ndGgsXG4gICAgICBoZXhSZXN1bHQsXG4gICAgICB0bXAsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmICgweDIyLyogXCIgKi8gIT09IGNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgc3RhdGUucG9zaXRpb24rKztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlICgwICE9PSAoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkpIHtcbiAgICBpZiAoMHgyMi8qIFwiICovID09PSBjaCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSBlbHNlIGlmICgweDVDLyogXFwgKi8gPT09IGNoKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KTtcblxuICAgICAgICAvLyBUT0RPOiByZXdvcmsgdG8gaW5saW5lIGZuIHdpdGggbm8gdHlwZSBjYXN0P1xuICAgICAgfSBlbHNlIGlmIChjaCA8IDI1NiAmJiBzaW1wbGVFc2NhcGVDaGVja1tjaF0pIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IHNpbXBsZUVzY2FwZU1hcFtjaF07XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICAgIH0gZWxzZSBpZiAoKHRtcCA9IGVzY2FwZWRIZXhMZW4oY2gpKSA+IDApIHtcbiAgICAgICAgaGV4TGVuZ3RoID0gdG1wO1xuICAgICAgICBoZXhSZXN1bHQgPSAwO1xuXG4gICAgICAgIGZvciAoOyBoZXhMZW5ndGggPiAwOyBoZXhMZW5ndGgtLSkge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmICgodG1wID0gZnJvbUhleENvZGUoY2gpKSA+PSAwKSB7XG4gICAgICAgICAgICBoZXhSZXN1bHQgPSAoaGV4UmVzdWx0IDw8IDQpICsgdG1wO1xuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdleHBlY3RlZCBoZXhhZGVjaW1hbCBjaGFyYWN0ZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY2hhckZyb21Db2RlcG9pbnQoaGV4UmVzdWx0KTtcblxuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5rbm93biBlc2NhcGUgc2VxdWVuY2UnKTtcbiAgICAgIH1cblxuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCB0cnVlKTtcbiAgICAgIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KSk7XG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB9IGVsc2UgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBkb2N1bWVudCB3aXRoaW4gYSBkb3VibGUgcXVvdGVkIHNjYWxhcicpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcbn1cblxuZnVuY3Rpb24gcmVhZEZsb3dDb2xsZWN0aW9uKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciByZWFkTmV4dCA9IHRydWUsXG4gICAgICBfbGluZSxcbiAgICAgIF90YWcgICAgID0gc3RhdGUudGFnLFxuICAgICAgX3Jlc3VsdCxcbiAgICAgIF9hbmNob3IgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgdGVybWluYXRvcixcbiAgICAgIGlzUGFpcixcbiAgICAgIGlzRXhwbGljaXRQYWlyLFxuICAgICAgaXNNYXBwaW5nLFxuICAgICAga2V5Tm9kZSxcbiAgICAgIGtleVRhZyxcbiAgICAgIHZhbHVlTm9kZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDVCLyogWyAqLykge1xuICAgIHRlcm1pbmF0b3IgPSAweDVEOy8qIF0gKi9cbiAgICBpc01hcHBpbmcgPSBmYWxzZTtcbiAgICBfcmVzdWx0ID0gW107XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4N0IvKiB7ICovKSB7XG4gICAgdGVybWluYXRvciA9IDB4N0Q7LyogfSAqL1xuICAgIGlzTWFwcGluZyA9IHRydWU7XG4gICAgX3Jlc3VsdCA9IHt9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChudWxsICE9PSBzdGF0ZS5hbmNob3IpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKDAgIT09IGNoKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSB0ZXJtaW5hdG9yKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICBzdGF0ZS5raW5kID0gaXNNYXBwaW5nID8gJ21hcHBpbmcnIDogJ3NlcXVlbmNlJztcbiAgICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFyZWFkTmV4dCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ21pc3NlZCBjb21tYSBiZXR3ZWVuIGZsb3cgY29sbGVjdGlvbiBlbnRyaWVzJyk7XG4gICAgfVxuXG4gICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSBmYWxzZTtcblxuICAgIGlmICgweDNGLyogPyAqLyA9PT0gY2gpIHtcbiAgICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICAgIGlzUGFpciA9IGlzRXhwbGljaXRQYWlyID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICBrZXlUYWcgPSBzdGF0ZS50YWc7XG4gICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKGlzRXhwbGljaXRQYWlyIHx8IHN0YXRlLmxpbmUgPT09IF9saW5lKSAmJiAweDNBLyogOiAqLyA9PT0gY2gpIHtcbiAgICAgIGlzUGFpciA9IHRydWU7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoaXNNYXBwaW5nKSB7XG4gICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSk7XG4gICAgfSBlbHNlIGlmIChpc1BhaXIpIHtcbiAgICAgIF9yZXN1bHQucHVzaChzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBudWxsLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcmVzdWx0LnB1c2goa2V5Tm9kZSk7XG4gICAgfVxuXG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKDB4MkMvKiAsICovID09PSBjaCkge1xuICAgICAgcmVhZE5leHQgPSB0cnVlO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWFkTmV4dCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvbicpO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNhcHR1cmVTdGFydCxcbiAgICAgIGZvbGRpbmcsXG4gICAgICBjaG9tcGluZyAgICAgICA9IENIT01QSU5HX0NMSVAsXG4gICAgICBkZXRlY3RlZEluZGVudCA9IGZhbHNlLFxuICAgICAgdGV4dEluZGVudCAgICAgPSBub2RlSW5kZW50LFxuICAgICAgZW1wdHlMaW5lcyAgICAgPSAwLFxuICAgICAgYXRNb3JlSW5kZW50ZWQgPSBmYWxzZSxcbiAgICAgIHRtcCxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDdDLyogfCAqLykge1xuICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgzRS8qID4gKi8pIHtcbiAgICBmb2xkaW5nID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuXG4gIHdoaWxlICgwICE9PSBjaCkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgweDJCLyogKyAqLyA9PT0gY2ggfHwgMHgyRC8qIC0gKi8gPT09IGNoKSB7XG4gICAgICBpZiAoQ0hPTVBJTkdfQ0xJUCA9PT0gY2hvbXBpbmcpIHtcbiAgICAgICAgY2hvbXBpbmcgPSAoMHgyQi8qICsgKi8gPT09IGNoKSA/IENIT01QSU5HX0tFRVAgOiBDSE9NUElOR19TVFJJUDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdyZXBlYXQgb2YgYSBjaG9tcGluZyBtb2RlIGlkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoKHRtcCA9IGZyb21EZWNpbWFsQ29kZShjaCkpID49IDApIHtcbiAgICAgIGlmICh0bXAgPT09IDApIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBleHBsaWNpdCBpbmRlbnRhdGlvbiB3aWR0aCBvZiBhIGJsb2NrIHNjYWxhcjsgaXQgY2Fubm90IGJlIGxlc3MgdGhhbiBvbmUnKTtcbiAgICAgIH0gZWxzZSBpZiAoIWRldGVjdGVkSW5kZW50KSB7XG4gICAgICAgIHRleHRJbmRlbnQgPSBub2RlSW5kZW50ICsgdG1wIC0gMTtcbiAgICAgICAgZGV0ZWN0ZWRJbmRlbnQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhbiBpbmRlbnRhdGlvbiB3aWR0aCBpZGVudGlmaWVyJyk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSk7XG5cbiAgICBpZiAoMHgyMy8qICMgKi8gPT09IGNoKSB7XG4gICAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgICAgd2hpbGUgKCFpc19FT0woY2gpICYmICgwICE9PSBjaCkpO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlICgwICE9PSBjaCkge1xuICAgIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuICAgIHN0YXRlLmxpbmVJbmRlbnQgPSAwO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIHdoaWxlICgoIWRldGVjdGVkSW5kZW50IHx8IHN0YXRlLmxpbmVJbmRlbnQgPCB0ZXh0SW5kZW50KSAmJlxuICAgICAgICAgICAoMHgyMC8qIFNwYWNlICovID09PSBjaCkpIHtcbiAgICAgIHN0YXRlLmxpbmVJbmRlbnQrKztcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoIWRldGVjdGVkSW5kZW50ICYmIHN0YXRlLmxpbmVJbmRlbnQgPiB0ZXh0SW5kZW50KSB7XG4gICAgICB0ZXh0SW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICB9XG5cbiAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgZW1wdHlMaW5lcysrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gRW5kIG9mIHRoZSBzY2FsYXIuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCB0ZXh0SW5kZW50KSB7XG5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGNob21waW5nLlxuICAgICAgaWYgKGNob21waW5nID09PSBDSE9NUElOR19LRUVQKSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0NMSVApIHtcbiAgICAgICAgaWYgKGRldGVjdGVkSW5kZW50KSB7IC8vIGkuZS4gb25seSBpZiB0aGUgc2NhbGFyIGlzIG5vdCBlbXB0eS5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQnJlYWsgdGhpcyBgd2hpbGVgIGN5Y2xlIGFuZCBnbyB0byB0aGUgZnVuY2l0b24ncyBlcGlsb2d1ZS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEZvbGRlZCBzdHlsZTogdXNlIGZhbmN5IHJ1bGVzIHRvIGhhbmRsZSBsaW5lIGJyZWFrcy5cbiAgICBpZiAoZm9sZGluZykge1xuXG4gICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoIHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMgKG1vcmUtaW5kZW50ZWQgbGluZXMpIGFyZSBub3QgZm9sZGVkLlxuICAgICAgaWYgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IHRydWU7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzICsgMSk7XG5cbiAgICAgIC8vIEVuZCBvZiBtb3JlLWluZGVudGVkIGJsb2NrLlxuICAgICAgfSBlbHNlIGlmIChhdE1vcmVJbmRlbnRlZCkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyArIDEpO1xuXG4gICAgICAvLyBKdXN0IG9uZSBsaW5lIGJyZWFrIC0gcGVyY2VpdmUgYXMgdGhlIHNhbWUgbGluZS5cbiAgICAgIH0gZWxzZSBpZiAoMCA9PT0gZW1wdHlMaW5lcykge1xuICAgICAgICBpZiAoZGV0ZWN0ZWRJbmRlbnQpIHsgLy8gaS5lLiBvbmx5IGlmIHdlIGhhdmUgYWxyZWFkeSByZWFkIHNvbWUgc2NhbGFyIGNvbnRlbnQuXG4gICAgICAgICAgc3RhdGUucmVzdWx0ICs9ICcgJztcbiAgICAgICAgfVxuXG4gICAgICAvLyBTZXZlcmFsIGxpbmUgYnJlYWtzIC0gcGVyY2VpdmUgYXMgZGlmZmVyZW50IGxpbmVzLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMpO1xuICAgICAgfVxuXG4gICAgLy8gTGl0ZXJhbCBzdHlsZToganVzdCBhZGQgZXhhY3QgbnVtYmVyIG9mIGxpbmUgYnJlYWtzIGJldHdlZW4gY29udGVudCBsaW5lcy5cbiAgICB9IGVsc2UgaWYgKGRldGVjdGVkSW5kZW50KSB7XG4gICAgICAvLyBJZiBjdXJyZW50IGxpbmUgaXNuJ3QgdGhlIGZpcnN0IG9uZSAtIGNvdW50IGxpbmUgYnJlYWsgZnJvbSB0aGUgbGFzdCBjb250ZW50IGxpbmUuXG4gICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIHRoZSBmaXJzdCBjb250ZW50IGxpbmUgLSBjb3VudCBvbmx5IGVtcHR5IGxpbmVzLlxuICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMpO1xuICAgIH1cblxuICAgIGRldGVjdGVkSW5kZW50ID0gdHJ1ZTtcbiAgICBlbXB0eUxpbmVzID0gMDtcbiAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlICghaXNfRU9MKGNoKSAmJiAoMCAhPT0gY2gpKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgX2xpbmUsXG4gICAgICBfdGFnICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfYW5jaG9yICAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ICAgPSBbXSxcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIGRldGVjdGVkICA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKG51bGwgIT09IHN0YXRlLmFuY2hvcikge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKDAgIT09IGNoKSB7XG5cbiAgICBpZiAoMHgyRC8qIC0gKi8gIT09IGNoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAoIWlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50IDw9IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgX3Jlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfQkxPQ0tfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICBfcmVzdWx0LnB1c2goc3RhdGUucmVzdWx0KTtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkgJiYgKDAgIT09IGNoKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBpbmRlbnRhdGlvbiBvZiBhIHNlcXVlbmNlIGVudHJ5Jyk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgbm9kZUluZGVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRldGVjdGVkKSB7XG4gICAgc3RhdGUudGFnID0gX3RhZztcbiAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgIHN0YXRlLmtpbmQgPSAnc2VxdWVuY2UnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tNYXBwaW5nKHN0YXRlLCBub2RlSW5kZW50LCBmbG93SW5kZW50KSB7XG4gIHZhciBmb2xsb3dpbmcsXG4gICAgICBhbGxvd0NvbXBhY3QsXG4gICAgICBfbGluZSxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfYW5jaG9yICAgICAgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgX3Jlc3VsdCAgICAgICA9IHt9LFxuICAgICAga2V5VGFnICAgICAgICA9IG51bGwsXG4gICAgICBrZXlOb2RlICAgICAgID0gbnVsbCxcbiAgICAgIHZhbHVlTm9kZSAgICAgPSBudWxsLFxuICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlLFxuICAgICAgZGV0ZWN0ZWQgICAgICA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKG51bGwgIT09IHN0YXRlLmFuY2hvcikge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKDAgIT09IGNoKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuICAgIF9saW5lID0gc3RhdGUubGluZTsgLy8gU2F2ZSB0aGUgY3VycmVudCBsaW5lLlxuXG4gICAgLy9cbiAgICAvLyBFeHBsaWNpdCBub3RhdGlvbiBjYXNlLiBUaGVyZSBhcmUgdHdvIHNlcGFyYXRlIGJsb2NrczpcbiAgICAvLyBmaXJzdCBmb3IgdGhlIGtleSAoZGVub3RlZCBieSBcIj9cIikgYW5kIHNlY29uZCBmb3IgdGhlIHZhbHVlIChkZW5vdGVkIGJ5IFwiOlwiKVxuICAgIC8vXG4gICAgaWYgKCgweDNGLyogPyAqLyA9PT0gY2ggfHwgMHgzQS8qIDogKi8gID09PSBjaCkgJiYgaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcblxuICAgICAgaWYgKDB4M0YvKiA/ICovID09PSBjaCkge1xuICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIGtleVRhZywga2V5Tm9kZSwgbnVsbCk7XG4gICAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgIGF0RXhwbGljaXRLZXkgPSB0cnVlO1xuICAgICAgICBhbGxvd0NvbXBhY3QgPSB0cnVlO1xuXG4gICAgICB9IGVsc2UgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgLy8gaS5lLiAweDNBLyogOiAqLyA9PT0gY2hhcmFjdGVyIGFmdGVyIHRoZSBleHBsaWNpdCBrZXkuXG4gICAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2luY29tcGxldGUgZXhwbGljaXQgbWFwcGluZyBwYWlyOyBhIGtleSBub2RlIGlzIG1pc3NlZCcpO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5wb3NpdGlvbiArPSAxO1xuICAgICAgY2ggPSBmb2xsb3dpbmc7XG5cbiAgICAvL1xuICAgIC8vIEltcGxpY2l0IG5vdGF0aW9uIGNhc2UuIEZsb3ctc3R5bGUgbm9kZSBhcyB0aGUga2V5IGZpcnN0LCB0aGVuIFwiOlwiLCBhbmQgdGhlIHZhbHVlLlxuICAgIC8vXG4gICAgfSBlbHNlIGlmIChjb21wb3NlTm9kZShzdGF0ZSwgZmxvd0luZGVudCwgQ09OVEVYVF9GTE9XX09VVCwgZmFsc2UsIHRydWUpKSB7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoMHgzQS8qIDogKi8gPT09IGNoKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKCFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSB3aGl0ZXNwYWNlIGNoYXJhY3RlciBpcyBleHBlY3RlZCBhZnRlciB0aGUga2V5LXZhbHVlIHNlcGFyYXRvciB3aXRoaW4gYSBibG9jayBtYXBwaW5nJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIGtleVRhZywga2V5Tm9kZSwgbnVsbCk7XG4gICAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICAgIGFsbG93Q29tcGFjdCA9IGZhbHNlO1xuICAgICAgICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGFuIGltcGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBjb2xvbiBpcyBtaXNzZWQnKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGEgYmxvY2sgbWFwcGluZyBlbnRyeTsgYSBtdWx0aWxpbmUga2V5IG1heSBub3QgYmUgYW4gaW1wbGljaXQga2V5Jyk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhazsgLy8gUmVhZGluZyBpcyBkb25lLiBHbyB0byB0aGUgZXBpbG9ndWUuXG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBDb21tb24gcmVhZGluZyBjb2RlIGZvciBib3RoIGV4cGxpY2l0IGFuZCBpbXBsaWNpdCBub3RhdGlvbnMuXG4gICAgLy9cbiAgICBpZiAoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpIHtcbiAgICAgIGlmIChjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19PVVQsIHRydWUsIGFsbG93Q29tcGFjdCkpIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUpO1xuICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQgJiYgKDAgIT09IGNoKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBpbmRlbnRhdGlvbiBvZiBhIG1hcHBpbmcgZW50cnknKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBFcGlsb2d1ZS5cbiAgLy9cblxuICAvLyBTcGVjaWFsIGNhc2U6IGxhc3QgbWFwcGluZydzIG5vZGUgY29udGFpbnMgb25seSB0aGUga2V5IGluIGV4cGxpY2l0IG5vdGF0aW9uLlxuICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIGtleVRhZywga2V5Tm9kZSwgbnVsbCk7XG4gIH1cblxuICAvLyBFeHBvc2UgdGhlIHJlc3VsdGluZyBtYXBwaW5nLlxuICBpZiAoZGV0ZWN0ZWQpIHtcbiAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgc3RhdGUua2luZCA9ICdtYXBwaW5nJztcbiAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGRldGVjdGVkO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnUHJvcGVydHkoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbixcbiAgICAgIGlzVmVyYmF0aW0gPSBmYWxzZSxcbiAgICAgIGlzTmFtZWQgICAgPSBmYWxzZSxcbiAgICAgIHRhZ0hhbmRsZSxcbiAgICAgIHRhZ05hbWUsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmICgweDIxLyogISAqLyAhPT0gY2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobnVsbCAhPT0gc3RhdGUudGFnKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGEgdGFnIHByb3BlcnR5Jyk7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKDB4M0MvKiA8ICovID09PSBjaCkge1xuICAgIGlzVmVyYmF0aW0gPSB0cnVlO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB9IGVsc2UgaWYgKDB4MjEvKiAhICovID09PSBjaCkge1xuICAgIGlzTmFtZWQgPSB0cnVlO1xuICAgIHRhZ0hhbmRsZSA9ICchISc7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIH0gZWxzZSB7XG4gICAgdGFnSGFuZGxlID0gJyEnO1xuICB9XG5cbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgaWYgKGlzVmVyYmF0aW0pIHtcbiAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgIHdoaWxlICgwICE9PSBjaCAmJiAweDNFLyogPiAqLyAhPT0gY2gpO1xuXG4gICAgaWYgKHN0YXRlLnBvc2l0aW9uIDwgc3RhdGUubGVuZ3RoKSB7XG4gICAgICB0YWdOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHZlcmJhdGltIHRhZycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoMCAhPT0gY2ggJiYgIWlzX1dTX09SX0VPTChjaCkpIHtcblxuICAgICAgaWYgKDB4MjEvKiAhICovID09PSBjaCkge1xuICAgICAgICBpZiAoIWlzTmFtZWQpIHtcbiAgICAgICAgICB0YWdIYW5kbGUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24gLSAxLCBzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICAgICAgaWYgKCFQQVRURVJOX1RBR19IQU5ETEUudGVzdCh0YWdIYW5kbGUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmFtZWQgdGFnIGhhbmRsZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpc05hbWVkID0gdHJ1ZTtcbiAgICAgICAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBzdWZmaXggY2Fubm90IGNvbnRhaW4gZXhjbGFtYXRpb24gbWFya3MnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgdGFnTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKFBBVFRFUk5fRkxPV19JTkRJQ0FUT1JTLnRlc3QodGFnTmFtZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGZsb3cgaW5kaWNhdG9yIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGFnTmFtZSAmJiAhUEFUVEVSTl9UQUdfVVJJLnRlc3QodGFnTmFtZSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIG5hbWUgY2Fubm90IGNvbnRhaW4gc3VjaCBjaGFyYWN0ZXJzOiAnICsgdGFnTmFtZSk7XG4gIH1cblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIHN0YXRlLnRhZyA9IHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS50YWdNYXAsIHRhZ0hhbmRsZSkpIHtcbiAgICBzdGF0ZS50YWcgPSBzdGF0ZS50YWdNYXBbdGFnSGFuZGxlXSArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmICgnIScgPT09IHRhZ0hhbmRsZSkge1xuICAgIHN0YXRlLnRhZyA9ICchJyArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmICgnISEnID09PSB0YWdIYW5kbGUpIHtcbiAgICBzdGF0ZS50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5kZWNsYXJlZCB0YWcgaGFuZGxlIFwiJyArIHRhZ0hhbmRsZSArICdcIicpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoMHgyNi8qICYgKi8gIT09IGNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG51bGwgIT09IHN0YXRlLmFuY2hvcikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiBhbiBhbmNob3IgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKDAgIT09IGNoICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFuY2hvciBub2RlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyJyk7XG4gIH1cblxuICBzdGF0ZS5hbmNob3IgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbGlhcyhzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLCBhbGlhcyxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKDB4MkEvKiAqICovICE9PSBjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKDAgIT09IGNoICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFsaWFzIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIGFsaWFzID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKCFzdGF0ZS5hbmNob3JNYXAuaGFzT3duUHJvcGVydHkoYWxpYXMpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuaWRlbnRpZmllZCBhbGlhcyBcIicgKyBhbGlhcyArICdcIicpO1xuICB9XG5cbiAgc3RhdGUucmVzdWx0ID0gc3RhdGUuYW5jaG9yTWFwW2FsaWFzXTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29tcG9zZU5vZGUoc3RhdGUsIHBhcmVudEluZGVudCwgbm9kZUNvbnRleHQsIGFsbG93VG9TZWVrLCBhbGxvd0NvbXBhY3QpIHtcbiAgdmFyIGFsbG93QmxvY2tTdHlsZXMsXG4gICAgICBhbGxvd0Jsb2NrU2NhbGFycyxcbiAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyxcbiAgICAgIGluZGVudFN0YXR1cyA9IDEsIC8vIDE6IHRoaXM+cGFyZW50LCAwOiB0aGlzPXBhcmVudCwgLTE6IHRoaXM8cGFyZW50XG4gICAgICBhdE5ld0xpbmUgID0gZmFsc2UsXG4gICAgICBoYXNDb250ZW50ID0gZmFsc2UsXG4gICAgICB0eXBlSW5kZXgsXG4gICAgICB0eXBlUXVhbnRpdHksXG4gICAgICB0eXBlLFxuICAgICAgZmxvd0luZGVudCxcbiAgICAgIGJsb2NrSW5kZW50O1xuXG4gIHN0YXRlLnRhZyAgICA9IG51bGw7XG4gIHN0YXRlLmFuY2hvciA9IG51bGw7XG4gIHN0YXRlLmtpbmQgICA9IG51bGw7XG4gIHN0YXRlLnJlc3VsdCA9IG51bGw7XG5cbiAgYWxsb3dCbG9ja1N0eWxlcyA9IGFsbG93QmxvY2tTY2FsYXJzID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zID1cbiAgICBDT05URVhUX0JMT0NLX09VVCA9PT0gbm9kZUNvbnRleHQgfHxcbiAgICBDT05URVhUX0JMT0NLX0lOICA9PT0gbm9kZUNvbnRleHQ7XG5cbiAgaWYgKGFsbG93VG9TZWVrKSB7XG4gICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgYXROZXdMaW5lID0gdHJ1ZTtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKDEgPT09IGluZGVudFN0YXR1cykge1xuICAgIHdoaWxlIChyZWFkVGFnUHJvcGVydHkoc3RhdGUpIHx8IHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkpIHtcbiAgICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgICAgYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYWxsb3dCbG9ja1N0eWxlcztcblxuICAgICAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbGxvd0Jsb2NrQ29sbGVjdGlvbnMpIHtcbiAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBhdE5ld0xpbmUgfHwgYWxsb3dDb21wYWN0O1xuICB9XG5cbiAgaWYgKDEgPT09IGluZGVudFN0YXR1cyB8fCBDT05URVhUX0JMT0NLX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICBpZiAoQ09OVEVYVF9GTE9XX0lOID09PSBub2RlQ29udGV4dCB8fCBDT05URVhUX0ZMT1dfT1VUID09PSBub2RlQ29udGV4dCkge1xuICAgICAgZmxvd0luZGVudCA9IHBhcmVudEluZGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxvd0luZGVudCA9IHBhcmVudEluZGVudCArIDE7XG4gICAgfVxuXG4gICAgYmxvY2tJbmRlbnQgPSBzdGF0ZS5wb3NpdGlvbiAtIHN0YXRlLmxpbmVTdGFydDtcblxuICAgIGlmICgxID09PSBpbmRlbnRTdGF0dXMpIHtcbiAgICAgIGlmIChhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiZcbiAgICAgICAgICAocmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIGJsb2NrSW5kZW50KSB8fFxuICAgICAgICAgICByZWFkQmxvY2tNYXBwaW5nKHN0YXRlLCBibG9ja0luZGVudCwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgcmVhZEZsb3dDb2xsZWN0aW9uKHN0YXRlLCBmbG93SW5kZW50KSkge1xuICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgoYWxsb3dCbG9ja1NjYWxhcnMgJiYgcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSkgfHxcbiAgICAgICAgICAgIHJlYWRTaW5nbGVRdW90ZWRTY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQpIHx8XG4gICAgICAgICAgICByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVhZEFsaWFzKHN0YXRlKSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlLnRhZyB8fCBudWxsICE9PSBzdGF0ZS5hbmNob3IpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdhbGlhcyBub2RlIHNob3VsZCBub3QgaGF2ZSBhbnkgcHJvcGVydGllcycpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRQbGFpblNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCwgQ09OVEVYVF9GTE9XX0lOID09PSBub2RlQ29udGV4dCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChudWxsID09PSBzdGF0ZS50YWcpIHtcbiAgICAgICAgICAgIHN0YXRlLnRhZyA9ICc/JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGUuYW5jaG9yKSB7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKDAgPT09IGluZGVudFN0YXR1cykge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlOiBibG9jayBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgdG8gaGF2ZSBzYW1lIGluZGVudGF0aW9uIGxldmVsIGFzIHRoZSBwYXJlbnQuXG4gICAgICAvLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI3OTk3ODRcbiAgICAgIGhhc0NvbnRlbnQgPSBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiYgcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIGJsb2NrSW5kZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAobnVsbCAhPT0gc3RhdGUudGFnICYmICchJyAhPT0gc3RhdGUudGFnKSB7XG4gICAgaWYgKCc/JyA9PT0gc3RhdGUudGFnKSB7XG4gICAgICBmb3IgKHR5cGVJbmRleCA9IDAsIHR5cGVRdWFudGl0eSA9IHN0YXRlLmltcGxpY2l0VHlwZXMubGVuZ3RoO1xuICAgICAgICAgICB0eXBlSW5kZXggPCB0eXBlUXVhbnRpdHk7XG4gICAgICAgICAgIHR5cGVJbmRleCArPSAxKSB7XG4gICAgICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW3R5cGVJbmRleF07XG5cbiAgICAgICAgLy8gSW1wbGljaXQgcmVzb2x2aW5nIGlzIG5vdCBhbGxvd2VkIGZvciBub24tc2NhbGFyIHR5cGVzLCBhbmQgJz8nXG4gICAgICAgIC8vIG5vbi1zcGVjaWZpYyB0YWcgaXMgb25seSBhc3NpZ25lZCB0byBwbGFpbiBzY2FsYXJzLiBTbywgaXQgaXNuJ3RcbiAgICAgICAgLy8gbmVlZGVkIHRvIGNoZWNrIGZvciAna2luZCcgY29uZm9ybWl0eS5cblxuICAgICAgICBpZiAodHlwZS5yZXNvbHZlKHN0YXRlLnJlc3VsdCkpIHsgLy8gYHN0YXRlLnJlc3VsdGAgdXBkYXRlZCBpbiByZXNvbHZlciBpZiBtYXRjaGVkXG4gICAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcbiAgICAgICAgICBzdGF0ZS50YWcgPSB0eXBlLnRhZztcbiAgICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGUuYW5jaG9yKSB7XG4gICAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnR5cGVNYXAsIHN0YXRlLnRhZykpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS50eXBlTWFwW3N0YXRlLnRhZ107XG5cbiAgICAgIGlmIChudWxsICE9PSBzdGF0ZS5yZXN1bHQgJiYgdHlwZS5raW5kICE9PSBzdGF0ZS5raW5kKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgbm9kZSBraW5kIGZvciAhPCcgKyBzdGF0ZS50YWcgKyAnPiB0YWc7IGl0IHNob3VsZCBiZSBcIicgKyB0eXBlLmtpbmQgKyAnXCIsIG5vdCBcIicgKyBzdGF0ZS5raW5kICsgJ1wiJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHlwZS5yZXNvbHZlKHN0YXRlLnJlc3VsdCkpIHsgLy8gYHN0YXRlLnJlc3VsdGAgdXBkYXRlZCBpbiByZXNvbHZlciBpZiBtYXRjaGVkXG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgcmVzb2x2ZSBhIG5vZGUgd2l0aCAhPCcgKyBzdGF0ZS50YWcgKyAnPiBleHBsaWNpdCB0YWcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCk7XG4gICAgICAgIGlmIChudWxsICE9PSBzdGF0ZS5hbmNob3IpIHtcbiAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5rbm93biB0YWcgITwnICsgc3RhdGUudGFnICsgJz4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbCAhPT0gc3RhdGUudGFnIHx8IG51bGwgIT09IHN0YXRlLmFuY2hvciB8fCBoYXNDb250ZW50O1xufVxuXG5mdW5jdGlvbiByZWFkRG9jdW1lbnQoc3RhdGUpIHtcbiAgdmFyIGRvY3VtZW50U3RhcnQgPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIF9wb3NpdGlvbixcbiAgICAgIGRpcmVjdGl2ZU5hbWUsXG4gICAgICBkaXJlY3RpdmVBcmdzLFxuICAgICAgaGFzRGlyZWN0aXZlcyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgc3RhdGUudmVyc2lvbiA9IG51bGw7XG4gIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IHN0YXRlLmxlZ2FjeTtcbiAgc3RhdGUudGFnTWFwID0ge307XG4gIHN0YXRlLmFuY2hvck1hcCA9IHt9O1xuXG4gIHdoaWxlICgwICE9PSAoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkpIHtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiAwIHx8IDB4MjUvKiAlICovICE9PSBjaCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgd2hpbGUgKDAgIT09IGNoICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgZGlyZWN0aXZlTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgIGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblxuICAgIGlmIChkaXJlY3RpdmVOYW1lLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmUgbmFtZSBtdXN0IG5vdCBiZSBsZXNzIHRoYW4gb25lIGNoYXJhY3RlciBpbiBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoMCAhPT0gY2gpIHtcbiAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoMHgyMy8qICMgKi8gPT09IGNoKSB7XG4gICAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICAgIHdoaWxlICgwICE9PSBjaCAmJiAhaXNfRU9MKGNoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgICAgIHdoaWxlICgwICE9PSBjaCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGRpcmVjdGl2ZUFyZ3MucHVzaChzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKSk7XG4gICAgfVxuXG4gICAgaWYgKDAgIT09IGNoKSB7XG4gICAgICByZWFkTGluZUJyZWFrKHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoZGlyZWN0aXZlSGFuZGxlcnMsIGRpcmVjdGl2ZU5hbWUpKSB7XG4gICAgICBkaXJlY3RpdmVIYW5kbGVyc1tkaXJlY3RpdmVOYW1lXShzdGF0ZSwgZGlyZWN0aXZlTmFtZSwgZGlyZWN0aXZlQXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vua25vd24gZG9jdW1lbnQgZGlyZWN0aXZlIFwiJyArIGRpcmVjdGl2ZU5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH1cblxuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKDAgPT09IHN0YXRlLmxpbmVJbmRlbnQgJiZcbiAgICAgIDB4MkQvKiAtICovID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSAmJlxuICAgICAgMHgyRC8qIC0gKi8gPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKSAmJlxuICAgICAgMHgyRC8qIC0gKi8gPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAyKSkge1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIH0gZWxzZSBpZiAoaGFzRGlyZWN0aXZlcykge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmVzIGVuZCBtYXJrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBjb21wb3NlTm9kZShzdGF0ZSwgc3RhdGUubGluZUluZGVudCAtIDEsIENPTlRFWFRfQkxPQ0tfT1VULCBmYWxzZSwgdHJ1ZSk7XG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICBpZiAoc3RhdGUuY2hlY2tMaW5lQnJlYWtzICYmXG4gICAgICBQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUy50ZXN0KHN0YXRlLmlucHV0LnNsaWNlKGRvY3VtZW50U3RhcnQsIHN0YXRlLnBvc2l0aW9uKSkpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdub24tQVNDSUkgbGluZSBicmVha3MgYXJlIGludGVycHJldGVkIGFzIGNvbnRlbnQnKTtcbiAgfVxuXG4gIHN0YXRlLmRvY3VtZW50cy5wdXNoKHN0YXRlLnJlc3VsdCk7XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuXG4gICAgaWYgKDB4MkUvKiAuICovID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkge1xuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMztcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uIDwgKHN0YXRlLmxlbmd0aCAtIDEpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2VuZCBvZiB0aGUgc3RyZWFtIG9yIGEgZG9jdW1lbnQgc2VwYXJhdG9yIGlzIGV4cGVjdGVkJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5cblxuZnVuY3Rpb24gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucykge1xuICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbnB1dC5sZW5ndGggIT09IDApIHtcblxuICAgIC8vIEFkZCB0YWlsaW5nIGBcXG5gIGlmIG5vdCBleGlzdHNcbiAgICBpZiAoMHgwQS8qIExGICovICE9PSBpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICYmXG4gICAgICAgIDB4MEQvKiBDUiAqLyAhPT0gaW5wdXQuY2hhckNvZGVBdChpbnB1dC5sZW5ndGggLSAxKSkge1xuICAgICAgaW5wdXQgKz0gJ1xcbic7XG4gICAgfVxuXG4gICAgLy8gU3RyaXAgQk9NXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgxKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIGlmIChQQVRURVJOX05PTl9QUklOVEFCTEUudGVzdChzdGF0ZS5pbnB1dCkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlIHN0cmVhbSBjb250YWlucyBub24tcHJpbnRhYmxlIGNoYXJhY3RlcnMnKTtcbiAgfVxuXG4gIC8vIFVzZSAwIGFzIHN0cmluZyB0ZXJtaW5hdG9yLiBUaGF0IHNpZ25pZmljYW50bHkgc2ltcGxpZmllcyBib3VuZHMgY2hlY2suXG4gIHN0YXRlLmlucHV0ICs9ICdcXDAnO1xuXG4gIHdoaWxlICgweDIwLyogU3BhY2UgKi8gPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSB7XG4gICAgc3RhdGUubGluZUluZGVudCArPSAxO1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gIH1cblxuICB3aGlsZSAoc3RhdGUucG9zaXRpb24gPCAoc3RhdGUubGVuZ3RoIC0gMSkpIHtcbiAgICByZWFkRG9jdW1lbnQoc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmRvY3VtZW50cztcbn1cblxuXG5mdW5jdGlvbiBsb2FkQWxsKGlucHV0LCBpdGVyYXRvciwgb3B0aW9ucykge1xuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyksIGluZGV4LCBsZW5ndGg7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGRvY3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgaXRlcmF0b3IoZG9jdW1lbnRzW2luZGV4XSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBsb2FkKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBkb2N1bWVudHMgPSBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKTtcblxuICBpZiAoMCA9PT0gZG9jdW1lbnRzLmxlbmd0aCkge1xuICAgIC8qZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkKi9cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKDEgPT09IGRvY3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnRzWzBdO1xuICB9XG4gIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdleHBlY3RlZCBhIHNpbmdsZSBkb2N1bWVudCBpbiB0aGUgc3RyZWFtLCBidXQgZm91bmQgbW9yZScpO1xufVxuXG5cbmZ1bmN0aW9uIHNhZmVMb2FkQWxsKGlucHV0LCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgbG9hZEFsbChpbnB1dCwgb3V0cHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbn1cblxuXG5mdW5jdGlvbiBzYWZlTG9hZChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbG9hZChpbnB1dCwgY29tbW9uLmV4dGVuZCh7IHNjaGVtYTogREVGQVVMVF9TQUZFX1NDSEVNQSB9LCBvcHRpb25zKSk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMubG9hZEFsbCAgICAgPSBsb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMubG9hZCAgICAgICAgPSBsb2FkO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgPSBzYWZlTG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkICAgID0gc2FmZUxvYWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuZnVuY3Rpb24gTWFyayhuYW1lLCBidWZmZXIsIHBvc2l0aW9uLCBsaW5lLCBjb2x1bW4pIHtcbiAgdGhpcy5uYW1lICAgICA9IG5hbWU7XG4gIHRoaXMuYnVmZmVyICAgPSBidWZmZXI7XG4gIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgdGhpcy5saW5lICAgICA9IGxpbmU7XG4gIHRoaXMuY29sdW1uICAgPSBjb2x1bW47XG59XG5cblxuTWFyay5wcm90b3R5cGUuZ2V0U25pcHBldCA9IGZ1bmN0aW9uIGdldFNuaXBwZXQoaW5kZW50LCBtYXhMZW5ndGgpIHtcbiAgdmFyIGhlYWQsIHN0YXJ0LCB0YWlsLCBlbmQsIHNuaXBwZXQ7XG5cbiAgaWYgKCF0aGlzLmJ1ZmZlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaW5kZW50ID0gaW5kZW50IHx8IDQ7XG4gIG1heExlbmd0aCA9IG1heExlbmd0aCB8fCA3NTtcblxuICBoZWFkID0gJyc7XG4gIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoc3RhcnQgPiAwICYmIC0xID09PSAnXFx4MDBcXHJcXG5cXHg4NVxcdTIwMjhcXHUyMDI5Jy5pbmRleE9mKHRoaXMuYnVmZmVyLmNoYXJBdChzdGFydCAtIDEpKSkge1xuICAgIHN0YXJ0IC09IDE7XG4gICAgaWYgKHRoaXMucG9zaXRpb24gLSBzdGFydCA+IChtYXhMZW5ndGggLyAyIC0gMSkpIHtcbiAgICAgIGhlYWQgPSAnIC4uLiAnO1xuICAgICAgc3RhcnQgKz0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRhaWwgPSAnJztcbiAgZW5kID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoZW5kIDwgdGhpcy5idWZmZXIubGVuZ3RoICYmIC0xID09PSAnXFx4MDBcXHJcXG5cXHg4NVxcdTIwMjhcXHUyMDI5Jy5pbmRleE9mKHRoaXMuYnVmZmVyLmNoYXJBdChlbmQpKSkge1xuICAgIGVuZCArPSAxO1xuICAgIGlmIChlbmQgLSB0aGlzLnBvc2l0aW9uID4gKG1heExlbmd0aCAvIDIgLSAxKSkge1xuICAgICAgdGFpbCA9ICcgLi4uICc7XG4gICAgICBlbmQgLT0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHNuaXBwZXQgPSB0aGlzLmJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTtcblxuICByZXR1cm4gY29tbW9uLnJlcGVhdCgnICcsIGluZGVudCkgKyBoZWFkICsgc25pcHBldCArIHRhaWwgKyAnXFxuJyArXG4gICAgICAgICBjb21tb24ucmVwZWF0KCcgJywgaW5kZW50ICsgdGhpcy5wb3NpdGlvbiAtIHN0YXJ0ICsgaGVhZC5sZW5ndGgpICsgJ14nO1xufTtcblxuXG5NYXJrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgdmFyIHNuaXBwZXQsIHdoZXJlID0gJyc7XG5cbiAgaWYgKHRoaXMubmFtZSkge1xuICAgIHdoZXJlICs9ICdpbiBcIicgKyB0aGlzLm5hbWUgKyAnXCIgJztcbiAgfVxuXG4gIHdoZXJlICs9ICdhdCBsaW5lICcgKyAodGhpcy5saW5lICsgMSkgKyAnLCBjb2x1bW4gJyArICh0aGlzLmNvbHVtbiArIDEpO1xuXG4gIGlmICghY29tcGFjdCkge1xuICAgIHNuaXBwZXQgPSB0aGlzLmdldFNuaXBwZXQoKTtcblxuICAgIGlmIChzbmlwcGV0KSB7XG4gICAgICB3aGVyZSArPSAnOlxcbicgKyBzbmlwcGV0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3aGVyZTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBNYXJrO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG52YXIgY29tbW9uICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgVHlwZSAgICAgICAgICA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG5cbmZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjaGVtYSwgbmFtZSwgcmVzdWx0KSB7XG4gIHZhciBleGNsdWRlID0gW107XG5cbiAgc2NoZW1hLmluY2x1ZGUuZm9yRWFjaChmdW5jdGlvbiAoaW5jbHVkZWRTY2hlbWEpIHtcbiAgICByZXN1bHQgPSBjb21waWxlTGlzdChpbmNsdWRlZFNjaGVtYSwgbmFtZSwgcmVzdWx0KTtcbiAgfSk7XG5cbiAgc2NoZW1hW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRUeXBlKSB7XG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHByZXZpb3VzVHlwZSwgcHJldmlvdXNJbmRleCkge1xuICAgICAgaWYgKHByZXZpb3VzVHlwZS50YWcgPT09IGN1cnJlbnRUeXBlLnRhZykge1xuICAgICAgICBleGNsdWRlLnB1c2gocHJldmlvdXNJbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXN1bHQucHVzaChjdXJyZW50VHlwZSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuICAgIHJldHVybiAtMSA9PT0gZXhjbHVkZS5pbmRleE9mKGluZGV4KTtcbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gY29tcGlsZU1hcCgvKiBsaXN0cy4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge30sIGluZGV4LCBsZW5ndGg7XG5cbiAgZnVuY3Rpb24gY29sbGVjdFR5cGUodHlwZSkge1xuICAgIHJlc3VsdFt0eXBlLnRhZ10gPSB0eXBlO1xuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgYXJndW1lbnRzW2luZGV4XS5mb3JFYWNoKGNvbGxlY3RUeXBlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gU2NoZW1hKGRlZmluaXRpb24pIHtcbiAgdGhpcy5pbmNsdWRlICA9IGRlZmluaXRpb24uaW5jbHVkZSAgfHwgW107XG4gIHRoaXMuaW1wbGljaXQgPSBkZWZpbml0aW9uLmltcGxpY2l0IHx8IFtdO1xuICB0aGlzLmV4cGxpY2l0ID0gZGVmaW5pdGlvbi5leHBsaWNpdCB8fCBbXTtcblxuICB0aGlzLmltcGxpY2l0LmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodHlwZS5sb2FkS2luZCAmJiAnc2NhbGFyJyAhPT0gdHlwZS5sb2FkS2luZCkge1xuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1RoZXJlIGlzIGEgbm9uLXNjYWxhciB0eXBlIGluIHRoZSBpbXBsaWNpdCBsaXN0IG9mIGEgc2NoZW1hLiBJbXBsaWNpdCByZXNvbHZpbmcgb2Ygc3VjaCB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5jb21waWxlZEltcGxpY2l0ID0gY29tcGlsZUxpc3QodGhpcywgJ2ltcGxpY2l0JywgW10pO1xuICB0aGlzLmNvbXBpbGVkRXhwbGljaXQgPSBjb21waWxlTGlzdCh0aGlzLCAnZXhwbGljaXQnLCBbXSk7XG4gIHRoaXMuY29tcGlsZWRUeXBlTWFwICA9IGNvbXBpbGVNYXAodGhpcy5jb21waWxlZEltcGxpY2l0LCB0aGlzLmNvbXBpbGVkRXhwbGljaXQpO1xufVxuXG5cblNjaGVtYS5ERUZBVUxUID0gbnVsbDtcblxuXG5TY2hlbWEuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlU2NoZW1hKCkge1xuICB2YXIgc2NoZW1hcywgdHlwZXM7XG5cbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gIGNhc2UgMTpcbiAgICBzY2hlbWFzID0gU2NoZW1hLkRFRkFVTFQ7XG4gICAgdHlwZXMgPSBhcmd1bWVudHNbMF07XG4gICAgYnJlYWs7XG5cbiAgY2FzZSAyOlxuICAgIHNjaGVtYXMgPSBhcmd1bWVudHNbMF07XG4gICAgdHlwZXMgPSBhcmd1bWVudHNbMV07XG4gICAgYnJlYWs7XG5cbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgU2NoZW1hLmNyZWF0ZSBmdW5jdGlvbicpO1xuICB9XG5cbiAgc2NoZW1hcyA9IGNvbW1vbi50b0FycmF5KHNjaGVtYXMpO1xuICB0eXBlcyA9IGNvbW1vbi50b0FycmF5KHR5cGVzKTtcblxuICBpZiAoIXNjaGVtYXMuZXZlcnkoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hIGluc3RhbmNlb2YgU2NoZW1hOyB9KSkge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBzdXBlciBzY2hlbWFzIChvciBhIHNpbmdsZSBTY2hlbWEgb2JqZWN0KSBjb250YWlucyBhIG5vbi1TY2hlbWEgb2JqZWN0LicpO1xuICB9XG5cbiAgaWYgKCF0eXBlcy5ldmVyeShmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIFR5cGU7IH0pKSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIFlBTUwgdHlwZXMgKG9yIGEgc2luZ2xlIFR5cGUgb2JqZWN0KSBjb250YWlucyBhIG5vbi1UeXBlIG9iamVjdC4nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2NoZW1hKHtcbiAgICBpbmNsdWRlOiBzY2hlbWFzLFxuICAgIGV4cGxpY2l0OiB0eXBlc1xuICB9KTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWE7XG4iLCIvLyBTdGFuZGFyZCBZQU1MJ3MgQ29yZSBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDQ5MjNcbi8vXG4vLyBOT1RFOiBKUy1ZQU1MIGRvZXMgbm90IHN1cHBvcnQgc2NoZW1hLXNwZWNpZmljIHRhZyByZXNvbHV0aW9uIHJlc3RyaWN0aW9ucy5cbi8vIFNvLCBDb3JlIHNjaGVtYSBoYXMgbm8gZGlzdGluY3Rpb25zIGZyb20gSlNPTiBzY2hlbWEgaXMgSlMtWUFNTC5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGluY2x1ZGU6IFtcbiAgICByZXF1aXJlKCcuL2pzb24nKVxuICBdXG59KTtcbiIsIi8vIEpTLVlBTUwncyBkZWZhdWx0IHNjaGVtYSBmb3IgYGxvYWRgIGZ1bmN0aW9uLlxuLy8gSXQgaXMgbm90IGRlc2NyaWJlZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy9cbi8vIFRoaXMgc2NoZW1hIGlzIGJhc2VkIG9uIEpTLVlBTUwncyBkZWZhdWx0IHNhZmUgc2NoZW1hIGFuZCBpbmNsdWRlc1xuLy8gSmF2YVNjcmlwdC1zcGVjaWZpYyB0eXBlczogISFqcy91bmRlZmluZWQsICEhanMvcmVnZXhwIGFuZCAhIWpzL2Z1bmN0aW9uLlxuLy9cbi8vIEFsc28gdGhpcyBzY2hlbWEgaXMgdXNlZCBhcyBkZWZhdWx0IGJhc2Ugc2NoZW1hIGF0IGBTY2hlbWEuY3JlYXRlYCBmdW5jdGlvbi5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hLkRFRkFVTFQgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vZGVmYXVsdF9zYWZlJylcbiAgXSxcbiAgZXhwbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL2pzL3VuZGVmaW5lZCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvanMvcmVnZXhwJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9qcy9mdW5jdGlvbicpXG4gIF1cbn0pO1xuIiwiLy8gSlMtWUFNTCdzIGRlZmF1bHQgc2NoZW1hIGZvciBgc2FmZUxvYWRgIGZ1bmN0aW9uLlxuLy8gSXQgaXMgbm90IGRlc2NyaWJlZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy9cbi8vIFRoaXMgc2NoZW1hIGlzIGJhc2VkIG9uIHN0YW5kYXJkIFlBTUwncyBDb3JlIHNjaGVtYSBhbmQgaW5jbHVkZXMgbW9zdCBvZlxuLy8gZXh0cmEgdHlwZXMgZGVzY3JpYmVkIGF0IFlBTUwgdGFnIHJlcG9zaXRvcnkuIChodHRwOi8veWFtbC5vcmcvdHlwZS8pXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9jb3JlJylcbiAgXSxcbiAgaW1wbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL3RpbWVzdGFtcCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvbWVyZ2UnKVxuICBdLFxuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvYmluYXJ5JyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9vbWFwJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9wYWlycycpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvc2V0JylcbiAgXVxufSk7XG4iLCIvLyBTdGFuZGFyZCBZQU1MJ3MgRmFpbHNhZmUgc2NoZW1hLlxuLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyODAyMzQ2XG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvc3RyJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zZXEnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL21hcCcpXG4gIF1cbn0pO1xuIiwiLy8gU3RhbmRhcmQgWUFNTCdzIEpTT04gc2NoZW1hLlxuLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyODAzMjMxXG4vL1xuLy8gTk9URTogSlMtWUFNTCBkb2VzIG5vdCBzdXBwb3J0IHNjaGVtYS1zcGVjaWZpYyB0YWcgcmVzb2x1dGlvbiByZXN0cmljdGlvbnMuXG4vLyBTbywgdGhpcyBzY2hlbWEgaXMgbm90IHN1Y2ggc3RyaWN0IGFzIGRlZmluZWQgaW4gdGhlIFlBTUwgc3BlY2lmaWNhdGlvbi5cbi8vIEl0IGFsbG93cyBudW1iZXJzIGluIGJpbmFyeSBub3RhaW9uLCB1c2UgYE51bGxgIGFuZCBgTlVMTGAgYXMgYG51bGxgLCBldGMuXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9mYWlsc2FmZScpXG4gIF0sXG4gIGltcGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9udWxsJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9ib29sJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9pbnQnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2Zsb2F0JylcbiAgXVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBZQU1MRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9leGNlcHRpb24nKTtcblxudmFyIFRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUyA9IFtcbiAgJ2tpbmQnLFxuICAncmVzb2x2ZScsXG4gICdjb25zdHJ1Y3QnLFxuICAnaW5zdGFuY2VPZicsXG4gICdwcmVkaWNhdGUnLFxuICAncmVwcmVzZW50JyxcbiAgJ2RlZmF1bHRTdHlsZScsXG4gICdzdHlsZUFsaWFzZXMnXG5dO1xuXG52YXIgWUFNTF9OT0RFX0tJTkRTID0gW1xuICAnc2NhbGFyJyxcbiAgJ3NlcXVlbmNlJyxcbiAgJ21hcHBpbmcnXG5dO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVBbGlhc2VzKG1hcCkge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgaWYgKG51bGwgIT09IG1hcCkge1xuICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIG1hcFtzdHlsZV0uZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgcmVzdWx0W1N0cmluZyhhbGlhcyldID0gc3R5bGU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIFR5cGUodGFnLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoLTEgPT09IFRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUy5pbmRleE9mKG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVW5rbm93biBvcHRpb24gXCInICsgbmFtZSArICdcIiBpcyBtZXQgaW4gZGVmaW5pdGlvbiBvZiBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVE9ETzogQWRkIHRhZyBmb3JtYXQgY2hlY2suXG4gIHRoaXMudGFnICAgICAgICAgID0gdGFnO1xuICB0aGlzLmtpbmQgICAgICAgICA9IG9wdGlvbnNbJ2tpbmQnXSAgICAgICAgIHx8IG51bGw7XG4gIHRoaXMucmVzb2x2ZSAgICAgID0gb3B0aW9uc1sncmVzb2x2ZSddICAgICAgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgdGhpcy5jb25zdHJ1Y3QgICAgPSBvcHRpb25zWydjb25zdHJ1Y3QnXSAgICB8fCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YTsgfTtcbiAgdGhpcy5pbnN0YW5jZU9mICAgPSBvcHRpb25zWydpbnN0YW5jZU9mJ10gICB8fCBudWxsO1xuICB0aGlzLnByZWRpY2F0ZSAgICA9IG9wdGlvbnNbJ3ByZWRpY2F0ZSddICAgIHx8IG51bGw7XG4gIHRoaXMucmVwcmVzZW50ICAgID0gb3B0aW9uc1sncmVwcmVzZW50J10gICAgfHwgbnVsbDtcbiAgdGhpcy5kZWZhdWx0U3R5bGUgPSBvcHRpb25zWydkZWZhdWx0U3R5bGUnXSB8fCBudWxsO1xuICB0aGlzLnN0eWxlQWxpYXNlcyA9IGNvbXBpbGVTdHlsZUFsaWFzZXMob3B0aW9uc1snc3R5bGVBbGlhc2VzJ10gfHwgbnVsbCk7XG5cbiAgaWYgKC0xID09PSBZQU1MX05PREVfS0lORFMuaW5kZXhPZih0aGlzLmtpbmQpKSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1Vua25vd24ga2luZCBcIicgKyB0aGlzLmtpbmQgKyAnXCIgaXMgc3BlY2lmaWVkIGZvciBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cblxuLy8gQSB0cmljayBmb3IgYnJvd3NlcmlmaWVkIHZlcnNpb24uXG4vLyBTaW5jZSB3ZSBtYWtlIGJyb3dzZXJpZmllciB0byBpZ25vcmUgYGJ1ZmZlcmAgbW9kdWxlLCBOb2RlQnVmZmVyIHdpbGwgYmUgdW5kZWZpbmVkXG52YXIgTm9kZUJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbnZhciBUeXBlICAgICAgID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5cbi8vIFsgNjQsIDY1LCA2NiBdIC0+IFsgcGFkZGluZywgQ1IsIExGIF1cbnZhciBCQVNFNjRfTUFQID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XFxuXFxyJztcblxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJpbmFyeShkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGNvZGUsIGlkeCwgYml0bGVuID0gMCwgbWF4ID0gZGF0YS5sZW5ndGgsIG1hcCA9IEJBU0U2NF9NQVA7XG5cbiAgLy8gQ29udmVydCBvbmUgYnkgb25lLlxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBjb2RlID0gbWFwLmluZGV4T2YoZGF0YS5jaGFyQXQoaWR4KSk7XG5cbiAgICAvLyBTa2lwIENSL0xGXG4gICAgaWYgKGNvZGUgPiA2NCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gRmFpbCBvbiBpbGxlZ2FsIGNoYXJhY3RlcnNcbiAgICBpZiAoY29kZSA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBiaXRsZW4gKz0gNjtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBhbnkgYml0cyBsZWZ0LCBzb3VyY2Ugd2FzIGNvcnJ1cHRlZFxuICByZXR1cm4gKGJpdGxlbiAlIDgpID09PSAwO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQmluYXJ5KGRhdGEpIHtcbiAgdmFyIGlkeCwgdGFpbGJpdHMsXG4gICAgICBpbnB1dCA9IGRhdGEucmVwbGFjZSgvW1xcclxcbj1dL2csICcnKSwgLy8gcmVtb3ZlIENSL0xGICYgcGFkZGluZyB0byBzaW1wbGlmeSBzY2FuXG4gICAgICBtYXggPSBpbnB1dC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQLFxuICAgICAgYml0cyA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICAvLyBDb2xsZWN0IGJ5IDYqNCBiaXRzICgzIGJ5dGVzKVxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgNCA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxNikgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDYpIHwgbWFwLmluZGV4T2YoaW5wdXQuY2hhckF0KGlkeCkpO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbGJpdHMgPSAobWF4ICUgNCkgKiA2O1xuXG4gIGlmICh0YWlsYml0cyA9PT0gMCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxOCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDEwKSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDIpICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDEyKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gNCkgJiAweEZGKTtcbiAgfVxuXG4gIC8vIFdyYXAgaW50byBCdWZmZXIgZm9yIE5vZGVKUyBhbmQgbGVhdmUgQXJyYXkgZm9yIGJyb3dzZXJcbiAgaWYgKE5vZGVCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IE5vZGVCdWZmZXIocmVzdWx0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxCaW5hcnkob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHZhciByZXN1bHQgPSAnJywgYml0cyA9IDAsIGlkeCwgdGFpbCxcbiAgICAgIG1heCA9IG9iamVjdC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgZXZlcnkgdGhyZWUgYnl0ZXMgdG8gNCBBU0NJSSBjaGFyYWN0ZXJzLlxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgMyA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA4KSArIG9iamVjdFtpZHhdO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbCA9IG1heCAlIDM7XG5cbiAgaWYgKHRhaWwgPT09IDApIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDIpIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEwKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMSkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDQpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0JpbmFyeShvYmplY3QpIHtcbiAgcmV0dXJuIE5vZGVCdWZmZXIgJiYgTm9kZUJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJpbmFyeSxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sQmluYXJ5LFxuICBwcmVkaWNhdGU6IGlzQmluYXJ5LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxCaW5hcnlcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCb29sZWFuKGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG5cbiAgcmV0dXJuIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICd0cnVlJyB8fCBkYXRhID09PSAnVHJ1ZScgfHwgZGF0YSA9PT0gJ1RSVUUnKSkgfHxcbiAgICAgICAgIChtYXggPT09IDUgJiYgKGRhdGEgPT09ICdmYWxzZScgfHwgZGF0YSA9PT0gJ0ZhbHNlJyB8fCBkYXRhID09PSAnRkFMU0UnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCb29sZWFuKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09ICd0cnVlJyB8fFxuICAgICAgICAgZGF0YSA9PT0gJ1RydWUnIHx8XG4gICAgICAgICBkYXRhID09PSAnVFJVRSc7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihvYmplY3QpIHtcbiAgcmV0dXJuICdbb2JqZWN0IEJvb2xlYW5dJyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJvb2xlYW4sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJvb2xlYW4sXG4gIHByZWRpY2F0ZTogaXNCb29sZWFuLFxuICByZXByZXNlbnQ6IHtcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICd0cnVlJyA6ICdmYWxzZSc7IH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAnVFJVRScgOiAnRkFMU0UnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RydWUnIDogJ0ZhbHNlJzsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIFR5cGUgICA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIFlBTUxfRkxPQVRfUEFUVEVSTiA9IG5ldyBSZWdFeHAoXG4gICdeKD86Wy0rXT8oPzpbMC05XVswLTlfXSopXFxcXC5bMC05X10qKD86W2VFXVstK11bMC05XSspPycgK1xuICAnfFxcXFwuWzAtOV9dKyg/OltlRV1bLStdWzAtOV0rKT8nICtcbiAgJ3xbLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFxcXC5bMC05X10qJyArXG4gICd8Wy0rXT9cXFxcLig/OmluZnxJbmZ8SU5GKScgK1xuICAnfFxcXFwuKD86bmFufE5hTnxOQU4pKSQnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxGbG9hdChkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFZQU1MX0ZMT0FUX1BBVFRFUk4udGVzdChkYXRhKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEZsb2F0KGRhdGEpIHtcbiAgdmFyIHZhbHVlLCBzaWduLCBiYXNlLCBkaWdpdHM7XG5cbiAgdmFsdWUgID0gZGF0YS5yZXBsYWNlKC9fL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICBzaWduICAgPSAnLScgPT09IHZhbHVlWzBdID8gLTEgOiAxO1xuICBkaWdpdHMgPSBbXTtcblxuICBpZiAoMCA8PSAnKy0nLmluZGV4T2YodmFsdWVbMF0pKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgfVxuXG4gIGlmICgnLmluZicgPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuICgxID09PSBzaWduKSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICB9IGVsc2UgaWYgKCcubmFuJyA9PT0gdmFsdWUpIHtcbiAgICByZXR1cm4gTmFOO1xuXG4gIH0gZWxzZSBpZiAoMCA8PSB2YWx1ZS5pbmRleE9mKCc6JykpIHtcbiAgICB2YWx1ZS5zcGxpdCgnOicpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIGRpZ2l0cy51bnNoaWZ0KHBhcnNlRmxvYXQodiwgMTApKTtcbiAgICB9KTtcblxuICAgIHZhbHVlID0gMC4wO1xuICAgIGJhc2UgPSAxO1xuXG4gICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhbHVlICs9IGQgKiBiYXNlO1xuICAgICAgYmFzZSAqPSA2MDtcbiAgICB9KTtcblxuICAgIHJldHVybiBzaWduICogdmFsdWU7XG5cbiAgfVxuICByZXR1cm4gc2lnbiAqIHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEZsb2F0KG9iamVjdCwgc3R5bGUpIHtcbiAgaWYgKGlzTmFOKG9iamVjdCkpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgY2FzZSAnbG93ZXJjYXNlJzpcbiAgICAgIHJldHVybiAnLm5hbic7XG4gICAgY2FzZSAndXBwZXJjYXNlJzpcbiAgICAgIHJldHVybiAnLk5BTic7XG4gICAgY2FzZSAnY2FtZWxjYXNlJzpcbiAgICAgIHJldHVybiAnLk5hTic7XG4gICAgfVxuICB9IGVsc2UgaWYgKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA9PT0gb2JqZWN0KSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgIGNhc2UgJ2xvd2VyY2FzZSc6XG4gICAgICByZXR1cm4gJy5pbmYnO1xuICAgIGNhc2UgJ3VwcGVyY2FzZSc6XG4gICAgICByZXR1cm4gJy5JTkYnO1xuICAgIGNhc2UgJ2NhbWVsY2FzZSc6XG4gICAgICByZXR1cm4gJy5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICBjYXNlICdsb3dlcmNhc2UnOlxuICAgICAgcmV0dXJuICctLmluZic7XG4gICAgY2FzZSAndXBwZXJjYXNlJzpcbiAgICAgIHJldHVybiAnLS5JTkYnO1xuICAgIGNhc2UgJ2NhbWVsY2FzZSc6XG4gICAgICByZXR1cm4gJy0uSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpIHtcbiAgICByZXR1cm4gJy0wLjAnO1xuICB9XG4gIHJldHVybiBvYmplY3QudG9TdHJpbmcoMTApO1xufVxuXG5mdW5jdGlvbiBpc0Zsb2F0KG9iamVjdCkge1xuICByZXR1cm4gKCdbb2JqZWN0IE51bWJlcl0nID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSkgJiZcbiAgICAgICAgICgwICE9PSBvYmplY3QgJSAxIHx8IGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEZsb2F0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxGbG9hdCxcbiAgcHJlZGljYXRlOiBpc0Zsb2F0LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxGbG9hdCxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBUeXBlICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIGlzSGV4Q29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkgfHxcbiAgICAgICAgICgoMHg0MS8qIEEgKi8gPD0gYykgJiYgKGMgPD0gMHg0Ni8qIEYgKi8pKSB8fFxuICAgICAgICAgKCgweDYxLyogYSAqLyA8PSBjKSAmJiAoYyA8PSAweDY2LyogZiAqLykpO1xufVxuXG5mdW5jdGlvbiBpc09jdENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM3LyogNyAqLykpO1xufVxuXG5mdW5jdGlvbiBpc0RlY0NvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEludGVnZXIoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGhhc0RpZ2l0cyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKCFtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgY2ggPSBkYXRhW2luZGV4XTtcblxuICAvLyBzaWduXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG4gIH1cblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIC8vIDBcbiAgICBpZiAoaW5kZXggKyAxID09PSBtYXgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG5cbiAgICAvLyBiYXNlIDIsIGJhc2UgOCwgYmFzZSAxNlxuXG4gICAgaWYgKGNoID09PSAnYicpIHtcbiAgICAgIC8vIGJhc2UgMlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmIChjaCAhPT0gJzAnICYmIGNoICE9PSAnMScpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHM7XG4gICAgfVxuXG5cbiAgICBpZiAoY2ggPT09ICd4Jykge1xuICAgICAgLy8gYmFzZSAxNlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmICghaXNIZXhDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzO1xuICAgIH1cblxuICAgIC8vIGJhc2UgOFxuICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgIGlmIChjaCA9PT0gJ18nKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAoIWlzT2N0Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzRGlnaXRzO1xuICB9XG5cbiAgLy8gYmFzZSAxMCAoZXhjZXB0IDApIG9yIGJhc2UgNjBcblxuICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgIGlmIChjaCA9PT0gJ18nKSB7IGNvbnRpbnVlOyB9XG4gICAgaWYgKGNoID09PSAnOicpIHsgYnJlYWs7IH1cbiAgICBpZiAoIWlzRGVjQ29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICB9XG5cbiAgaWYgKCFoYXNEaWdpdHMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gaWYgIWJhc2U2MCAtIGRvbmU7XG4gIGlmIChjaCAhPT0gJzonKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gYmFzZTYwIGFsbW9zdCBub3QgdXNlZCwgbm8gbmVlZHMgdG8gb3B0aW1pemVcbiAgcmV0dXJuIC9eKDpbMC01XT9bMC05XSkrJC8udGVzdChkYXRhLnNsaWNlKGluZGV4KSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgdmFyIHZhbHVlID0gZGF0YSwgc2lnbiA9IDEsIGNoLCBiYXNlLCBkaWdpdHMgPSBbXTtcblxuICBpZiAodmFsdWUuaW5kZXhPZignXycpICE9PSAtMSkge1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXy9nLCAnJyk7XG4gIH1cblxuICBjaCA9IHZhbHVlWzBdO1xuXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBpZiAoY2ggPT09ICctJykgeyBzaWduID0gLTE7IH1cbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgIGNoID0gdmFsdWVbMF07XG4gIH1cblxuICBpZiAoJzAnID09PSB2YWx1ZSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICBpZiAodmFsdWVbMV0gPT09ICdiJykge1xuICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMik7XG4gICAgfVxuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ3gnKSB7XG4gICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCAxNik7XG4gICAgfVxuICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDgpO1xuXG4gIH1cblxuICBpZiAodmFsdWUuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgIHZhbHVlLnNwbGl0KCc6JykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgZGlnaXRzLnVuc2hpZnQocGFyc2VJbnQodiwgMTApKTtcbiAgICB9KTtcblxuICAgIHZhbHVlID0gMDtcbiAgICBiYXNlID0gMTtcblxuICAgIGRpZ2l0cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YWx1ZSArPSAoZCAqIGJhc2UpO1xuICAgICAgYmFzZSAqPSA2MDtcbiAgICB9KTtcblxuICAgIHJldHVybiBzaWduICogdmFsdWU7XG5cbiAgfVxuXG4gIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gaXNJbnRlZ2VyKG9iamVjdCkge1xuICByZXR1cm4gKCdbb2JqZWN0IE51bWJlcl0nID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSkgJiZcbiAgICAgICAgICgwID09PSBvYmplY3QgJSAxICYmICFjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sSW50ZWdlcixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sSW50ZWdlcixcbiAgcHJlZGljYXRlOiBpc0ludGVnZXIsXG4gIHJlcHJlc2VudDoge1xuICAgIGJpbmFyeTogICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAnMGInICsgb2JqZWN0LnRvU3RyaW5nKDIpOyB9LFxuICAgIG9jdGFsOiAgICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAnMCcgICsgb2JqZWN0LnRvU3RyaW5nKDgpOyB9LFxuICAgIGRlY2ltYWw6ICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAgICAgICAgb2JqZWN0LnRvU3RyaW5nKDEwKTsgfSxcbiAgICBoZXhhZGVjaW1hbDogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gJzB4JyArIG9iamVjdC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdkZWNpbWFsJyxcbiAgc3R5bGVBbGlhc2VzOiB7XG4gICAgYmluYXJ5OiAgICAgIFsgMiwgICdiaW4nIF0sXG4gICAgb2N0YWw6ICAgICAgIFsgOCwgICdvY3QnIF0sXG4gICAgZGVjaW1hbDogICAgIFsgMTAsICdkZWMnIF0sXG4gICAgaGV4YWRlY2ltYWw6IFsgMTYsICdoZXgnIF1cbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlc3ByaW1hO1xuXG4vLyBCcm93c2VyaWZpZWQgdmVyc2lvbiBkb2VzIG5vdCBoYXZlIGVzcHJpbWFcbi8vXG4vLyAxLiBGb3Igbm9kZS5qcyBqdXN0IHJlcXVpcmUgbW9kdWxlIGFzIGRlcHNcbi8vIDIuIEZvciBicm93c2VyIHRyeSB0byByZXF1aXJlIG11ZHVsZSB2aWEgZXh0ZXJuYWwgQU1EIHN5c3RlbS5cbi8vICAgIElmIG5vdCBmb3VuZCAtIHRyeSB0byBmYWxsYmFjayB0byB3aW5kb3cuZXNwcmltYS4gSWYgbm90XG4vLyAgICBmb3VuZCB0b28gLSB0aGVuIGZhaWwgdG8gcGFyc2UuXG4vL1xudHJ5IHtcbiAgZXNwcmltYSA9IHJlcXVpcmUoJ2VzcHJpbWEnKTtcbn0gY2F0Y2ggKF8pIHtcbiAgLypnbG9iYWwgd2luZG93ICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyBlc3ByaW1hID0gd2luZG93LmVzcHJpbWE7IH1cbn1cblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi8uLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24oZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIHNvdXJjZSA9ICcoJyArIGRhdGEgKyAnKScsXG4gICAgICAgIGFzdCAgICA9IGVzcHJpbWEucGFyc2Uoc291cmNlLCB7IHJhbmdlOiB0cnVlIH0pO1xuXG4gICAgaWYgKCdQcm9ncmFtJyAgICAgICAgICAgICAhPT0gYXN0LnR5cGUgICAgICAgICB8fFxuICAgICAgICAxICAgICAgICAgICAgICAgICAgICAgIT09IGFzdC5ib2R5Lmxlbmd0aCAgfHxcbiAgICAgICAgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnICE9PSBhc3QuYm9keVswXS50eXBlIHx8XG4gICAgICAgICdGdW5jdGlvbkV4cHJlc3Npb24nICAhPT0gYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RKYXZhc2NyaXB0RnVuY3Rpb24oZGF0YSkge1xuICAvKmpzbGludCBldmlsOnRydWUqL1xuXG4gIHZhciBzb3VyY2UgPSAnKCcgKyBkYXRhICsgJyknLFxuICAgICAgYXN0ICAgID0gZXNwcmltYS5wYXJzZShzb3VyY2UsIHsgcmFuZ2U6IHRydWUgfSksXG4gICAgICBwYXJhbXMgPSBbXSxcbiAgICAgIGJvZHk7XG5cbiAgaWYgKCdQcm9ncmFtJyAgICAgICAgICAgICAhPT0gYXN0LnR5cGUgICAgICAgICB8fFxuICAgICAgMSAgICAgICAgICAgICAgICAgICAgICE9PSBhc3QuYm9keS5sZW5ndGggIHx8XG4gICAgICAnRXhwcmVzc2lvblN0YXRlbWVudCcgIT09IGFzdC5ib2R5WzBdLnR5cGUgfHxcbiAgICAgICdGdW5jdGlvbkV4cHJlc3Npb24nICAhPT0gYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVzb2x2ZSBmdW5jdGlvbicpO1xuICB9XG5cbiAgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi5wYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICBwYXJhbXMucHVzaChwYXJhbS5uYW1lKTtcbiAgfSk7XG5cbiAgYm9keSA9IGFzdC5ib2R5WzBdLmV4cHJlc3Npb24uYm9keS5yYW5nZTtcblxuICAvLyBFc3ByaW1hJ3MgcmFuZ2VzIGluY2x1ZGUgdGhlIGZpcnN0ICd7JyBhbmQgdGhlIGxhc3QgJ30nIGNoYXJhY3RlcnMgb25cbiAgLy8gZnVuY3Rpb24gZXhwcmVzc2lvbnMuIFNvIGN1dCB0aGVtIG91dC5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYyovXG4gIHJldHVybiBuZXcgRnVuY3Rpb24ocGFyYW1zLCBzb3VyY2Uuc2xpY2UoYm9keVswXSArIDEsIGJvZHlbMV0gLSAxKSk7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudEphdmFzY3JpcHRGdW5jdGlvbihvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgcmV0dXJuIG9iamVjdC50b1N0cmluZygpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iamVjdCkge1xuICByZXR1cm4gJ1tvYmplY3QgRnVuY3Rpb25dJyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL2Z1bmN0aW9uJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZUphdmFzY3JpcHRGdW5jdGlvbixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0RnVuY3Rpb24sXG4gIHByZWRpY2F0ZTogaXNGdW5jdGlvbixcbiAgcmVwcmVzZW50OiByZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb25cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZUphdmFzY3JpcHRSZWdFeHAoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICgwID09PSBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciByZWdleHAgPSBkYXRhLFxuICAgICAgdGFpbCAgID0gL1xcLyhbZ2ltXSopJC8uZXhlYyhkYXRhKSxcbiAgICAgIG1vZGlmaWVycyA9ICcnO1xuXG4gIC8vIGlmIHJlZ2V4cCBzdGFydHMgd2l0aCAnLycgaXQgY2FuIGhhdmUgbW9kaWZpZXJzIGFuZCBtdXN0IGJlIHByb3Blcmx5IGNsb3NlZFxuICAvLyBgL2Zvby9naW1gIC0gbW9kaWZpZXJzIHRhaWwgY2FuIGJlIG1heGltdW0gMyBjaGFyc1xuICBpZiAoJy8nID09PSByZWdleHBbMF0pIHtcbiAgICBpZiAodGFpbCkge1xuICAgICAgbW9kaWZpZXJzID0gdGFpbFsxXTtcbiAgICB9XG5cbiAgICBpZiAobW9kaWZpZXJzLmxlbmd0aCA+IDMpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLy8gaWYgZXhwcmVzc2lvbiBzdGFydHMgd2l0aCAvLCBpcyBzaG91bGQgYmUgcHJvcGVybHkgdGVybWluYXRlZFxuICAgIGlmIChyZWdleHBbcmVnZXhwLmxlbmd0aCAtIG1vZGlmaWVycy5sZW5ndGggLSAxXSAhPT0gJy8nKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgcmVnZXhwID0gcmVnZXhwLnNsaWNlKDEsIHJlZ2V4cC5sZW5ndGggLSBtb2RpZmllcnMubGVuZ3RoIC0gMSk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RKYXZhc2NyaXB0UmVnRXhwKGRhdGEpIHtcbiAgdmFyIHJlZ2V4cCA9IGRhdGEsXG4gICAgICB0YWlsICAgPSAvXFwvKFtnaW1dKikkLy5leGVjKGRhdGEpLFxuICAgICAgbW9kaWZpZXJzID0gJyc7XG5cbiAgLy8gYC9mb28vZ2ltYCAtIHRhaWwgY2FuIGJlIG1heGltdW0gNCBjaGFyc1xuICBpZiAoJy8nID09PSByZWdleHBbMF0pIHtcbiAgICBpZiAodGFpbCkge1xuICAgICAgbW9kaWZpZXJzID0gdGFpbFsxXTtcbiAgICB9XG4gICAgcmVnZXhwID0gcmVnZXhwLnNsaWNlKDEsIHJlZ2V4cC5sZW5ndGggLSBtb2RpZmllcnMubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHAsIG1vZGlmaWVycyk7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudEphdmFzY3JpcHRSZWdFeHAob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHZhciByZXN1bHQgPSAnLycgKyBvYmplY3Quc291cmNlICsgJy8nO1xuXG4gIGlmIChvYmplY3QuZ2xvYmFsKSB7XG4gICAgcmVzdWx0ICs9ICdnJztcbiAgfVxuXG4gIGlmIChvYmplY3QubXVsdGlsaW5lKSB7XG4gICAgcmVzdWx0ICs9ICdtJztcbiAgfVxuXG4gIGlmIChvYmplY3QuaWdub3JlQ2FzZSkge1xuICAgIHJlc3VsdCArPSAnaSc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cChvYmplY3QpIHtcbiAgcmV0dXJuICdbb2JqZWN0IFJlZ0V4cF0nID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6anMvcmVnZXhwJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZUphdmFzY3JpcHRSZWdFeHAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0SmF2YXNjcmlwdFJlZ0V4cCxcbiAgcHJlZGljYXRlOiBpc1JlZ0V4cCxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRKYXZhc2NyaXB0UmVnRXhwXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi8uLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0VW5kZWZpbmVkKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgLyplc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQqL1xuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0VW5kZWZpbmVkKCkge1xuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iamVjdCkge1xuICByZXR1cm4gJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL3VuZGVmaW5lZCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0VW5kZWZpbmVkLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdEphdmFzY3JpcHRVbmRlZmluZWQsXG4gIHByZWRpY2F0ZTogaXNVbmRlZmluZWQsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdFVuZGVmaW5lZFxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gbnVsbCAhPT0gZGF0YSA/IGRhdGEgOiB7fTsgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE1lcmdlKGRhdGEpIHtcbiAgcmV0dXJuICc8PCcgPT09IGRhdGEgfHwgbnVsbCA9PT0gZGF0YTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE1lcmdlXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sTnVsbChkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG5cbiAgcmV0dXJuIChtYXggPT09IDEgJiYgZGF0YSA9PT0gJ34nKSB8fFxuICAgICAgICAgKG1heCA9PT0gNCAmJiAoZGF0YSA9PT0gJ251bGwnIHx8IGRhdGEgPT09ICdOdWxsJyB8fCBkYXRhID09PSAnTlVMTCcpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc051bGwob2JqZWN0KSB7XG4gIHJldHVybiBudWxsID09PSBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE51bGwsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbE51bGwsXG4gIHByZWRpY2F0ZTogaXNOdWxsLFxuICByZXByZXNlbnQ6IHtcbiAgICBjYW5vbmljYWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICd+JzsgICAgfSxcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdudWxsJzsgfSxcbiAgICB1cHBlcmNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdOVUxMJzsgfSxcbiAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdOdWxsJzsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF90b1N0cmluZyAgICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sT21hcChkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgb2JqZWN0S2V5cyA9IFtdLCBpbmRleCwgbGVuZ3RoLCBwYWlyLCBwYWlyS2V5LCBwYWlySGFzS2V5LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcbiAgICBwYWlySGFzS2V5ID0gZmFsc2U7XG5cbiAgICBpZiAoJ1tvYmplY3QgT2JqZWN0XScgIT09IF90b1N0cmluZy5jYWxsKHBhaXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChwYWlyS2V5IGluIHBhaXIpIHtcbiAgICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChwYWlyLCBwYWlyS2V5KSkge1xuICAgICAgICBpZiAoIXBhaXJIYXNLZXkpIHtcbiAgICAgICAgICBwYWlySGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhaXJIYXNLZXkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoLTEgPT09IG9iamVjdEtleXMuaW5kZXhPZihwYWlyS2V5KSkge1xuICAgICAgb2JqZWN0S2V5cy5wdXNoKHBhaXJLZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxPbWFwKGRhdGEpIHtcbiAgcmV0dXJuIG51bGwgIT09IGRhdGEgPyBkYXRhIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sT21hcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sT21hcFxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxQYWlycyhkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG5cbiAgICBpZiAoJ1tvYmplY3QgT2JqZWN0XScgIT09IF90b1N0cmluZy5jYWxsKHBhaXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHBhaXIpO1xuXG4gICAgaWYgKDEgIT09IGtleXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmVzdWx0W2luZGV4XSA9IFsga2V5c1swXSwgcGFpcltrZXlzWzBdXSBdO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxQYWlycyhkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGluZGV4LCBsZW5ndGgsIHBhaXIsIGtleXMsIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHBhaXIpO1xuXG4gICAgcmVzdWx0W2luZGV4XSA9IFsga2V5c1swXSwgcGFpcltrZXlzWzBdXSBdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sUGFpcnMsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFBhaXJzXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNlcScsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gbnVsbCAhPT0gZGF0YSA/IGRhdGEgOiBbXTsgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxTZXQoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGtleSwgb2JqZWN0ID0gZGF0YTtcblxuICBmb3IgKGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICBpZiAobnVsbCAhPT0gb2JqZWN0W2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sU2V0KGRhdGEpIHtcbiAgcmV0dXJuIG51bGwgIT09IGRhdGEgPyBkYXRhIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcsIHtcbiAga2luZDogJ21hcHBpbmcnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFNldCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sU2V0XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG51bGwgIT09IGRhdGEgPyBkYXRhIDogJyc7IH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIFlBTUxfVElNRVNUQU1QX1JFR0VYUCA9IG5ldyBSZWdFeHAoXG4gICdeKFswLTldWzAtOV1bMC05XVswLTldKScgICAgICAgICAgKyAvLyBbMV0geWVhclxuICAnLShbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICsgLy8gWzJdIG1vbnRoXG4gICctKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgKyAvLyBbM10gZGF5XG4gICcoPzooPzpbVHRdfFsgXFxcXHRdKyknICAgICAgICAgICAgICArIC8vIC4uLlxuICAnKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgICsgLy8gWzRdIGhvdXJcbiAgJzooWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFs1XSBtaW51dGVcbiAgJzooWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFs2XSBzZWNvbmRcbiAgJyg/OlxcXFwuKFswLTldKikpPycgICAgICAgICAgICAgICAgICsgLy8gWzddIGZyYWN0aW9uXG4gICcoPzpbIFxcXFx0XSooWnwoWy0rXSkoWzAtOV1bMC05XT8pJyArIC8vIFs4XSB0eiBbOV0gdHpfc2lnbiBbMTBdIHR6X2hvdXJcbiAgJyg/OjooWzAtOV1bMC05XSkpPykpPyk/JCcpOyAgICAgICAgIC8vIFsxMV0gdHpfbWludXRlXG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sVGltZXN0YW1wKGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIHZhciBtYXRjaCwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uID0gMCxcbiAgICAgIGRlbHRhID0gbnVsbCwgdHpfaG91ciwgdHpfbWludXRlLCBkYXRlO1xuXG4gIG1hdGNoID0gWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSk7XG5cbiAgaWYgKG51bGwgPT09IG1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEYXRlIHJlc29sdmUgZXJyb3InKTtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbMV0geWVhciBbMl0gbW9udGggWzNdIGRheVxuXG4gIHllYXIgPSArKG1hdGNoWzFdKTtcbiAgbW9udGggPSArKG1hdGNoWzJdKSAtIDE7IC8vIEpTIG1vbnRoIHN0YXJ0cyB3aXRoIDBcbiAgZGF5ID0gKyhtYXRjaFszXSk7XG5cbiAgaWYgKCFtYXRjaFs0XSkgeyAvLyBubyBob3VyXG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXkpKTtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbNF0gaG91ciBbNV0gbWludXRlIFs2XSBzZWNvbmQgWzddIGZyYWN0aW9uXG5cbiAgaG91ciA9ICsobWF0Y2hbNF0pO1xuICBtaW51dGUgPSArKG1hdGNoWzVdKTtcbiAgc2Vjb25kID0gKyhtYXRjaFs2XSk7XG5cbiAgaWYgKG1hdGNoWzddKSB7XG4gICAgZnJhY3Rpb24gPSBtYXRjaFs3XS5zbGljZSgwLCAzKTtcbiAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgMykgeyAvLyBtaWxsaS1zZWNvbmRzXG4gICAgICBmcmFjdGlvbiArPSAnMCc7XG4gICAgfVxuICAgIGZyYWN0aW9uID0gK2ZyYWN0aW9uO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs4XSB0eiBbOV0gdHpfc2lnbiBbMTBdIHR6X2hvdXIgWzExXSB0el9taW51dGVcblxuICBpZiAobWF0Y2hbOV0pIHtcbiAgICB0el9ob3VyID0gKyhtYXRjaFsxMF0pO1xuICAgIHR6X21pbnV0ZSA9ICsobWF0Y2hbMTFdIHx8IDApO1xuICAgIGRlbHRhID0gKHR6X2hvdXIgKiA2MCArIHR6X21pbnV0ZSkgKiA2MDAwMDsgLy8gZGVsdGEgaW4gbWlsaS1zZWNvbmRzXG4gICAgaWYgKCctJyA9PT0gbWF0Y2hbOV0pIHtcbiAgICAgIGRlbHRhID0gLWRlbHRhO1xuICAgIH1cbiAgfVxuXG4gIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24pKTtcblxuICBpZiAoZGVsdGEpIHtcbiAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgLSBkZWx0YSk7XG4gIH1cblxuICByZXR1cm4gZGF0ZTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbFRpbWVzdGFtcChvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgcmV0dXJuIG9iamVjdC50b0lTT1N0cmluZygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFRpbWVzdGFtcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wLFxuICBpbnN0YW5jZU9mOiBEYXRlLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxUaW1lc3RhbXBcbn0pO1xuIiwiLypcbiAgQ29weXJpZ2h0IChjKSBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgQ29udHJpYnV0b3JzLCBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcyxcbiAgICAvLyBSaGlubywgYW5kIHBsYWluIGJyb3dzZXIgbG9hZGluZy5cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZhY3RvcnkoZXhwb3J0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeSgocm9vdC5lc3ByaW1hID0ge30pKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFRva2VuLFxuICAgICAgICBUb2tlbk5hbWUsXG4gICAgICAgIEZuRXhwclRva2VucyxcbiAgICAgICAgU3ludGF4LFxuICAgICAgICBQbGFjZUhvbGRlcnMsXG4gICAgICAgIE1lc3NhZ2VzLFxuICAgICAgICBSZWdleCxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBzdHJpY3QsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBsaW5lTnVtYmVyLFxuICAgICAgICBsaW5lU3RhcnQsXG4gICAgICAgIGhhc0xpbmVUZXJtaW5hdG9yLFxuICAgICAgICBsYXN0SW5kZXgsXG4gICAgICAgIGxhc3RMaW5lTnVtYmVyLFxuICAgICAgICBsYXN0TGluZVN0YXJ0LFxuICAgICAgICBzdGFydEluZGV4LFxuICAgICAgICBzdGFydExpbmVOdW1iZXIsXG4gICAgICAgIHN0YXJ0TGluZVN0YXJ0LFxuICAgICAgICBzY2FubmluZyxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBsb29rYWhlYWQsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBleHRyYSxcbiAgICAgICAgaXNCaW5kaW5nRWxlbWVudCxcbiAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0LFxuICAgICAgICBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I7XG5cbiAgICBUb2tlbiA9IHtcbiAgICAgICAgQm9vbGVhbkxpdGVyYWw6IDEsXG4gICAgICAgIEVPRjogMixcbiAgICAgICAgSWRlbnRpZmllcjogMyxcbiAgICAgICAgS2V5d29yZDogNCxcbiAgICAgICAgTnVsbExpdGVyYWw6IDUsXG4gICAgICAgIE51bWVyaWNMaXRlcmFsOiA2LFxuICAgICAgICBQdW5jdHVhdG9yOiA3LFxuICAgICAgICBTdHJpbmdMaXRlcmFsOiA4LFxuICAgICAgICBSZWd1bGFyRXhwcmVzc2lvbjogOSxcbiAgICAgICAgVGVtcGxhdGU6IDEwXG4gICAgfTtcblxuICAgIFRva2VuTmFtZSA9IHt9O1xuICAgIFRva2VuTmFtZVtUb2tlbi5Cb29sZWFuTGl0ZXJhbF0gPSAnQm9vbGVhbic7XG4gICAgVG9rZW5OYW1lW1Rva2VuLkVPRl0gPSAnPGVuZD4nO1xuICAgIFRva2VuTmFtZVtUb2tlbi5JZGVudGlmaWVyXSA9ICdJZGVudGlmaWVyJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uS2V5d29yZF0gPSAnS2V5d29yZCc7XG4gICAgVG9rZW5OYW1lW1Rva2VuLk51bGxMaXRlcmFsXSA9ICdOdWxsJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uTnVtZXJpY0xpdGVyYWxdID0gJ051bWVyaWMnO1xuICAgIFRva2VuTmFtZVtUb2tlbi5QdW5jdHVhdG9yXSA9ICdQdW5jdHVhdG9yJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uU3RyaW5nTGl0ZXJhbF0gPSAnU3RyaW5nJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uUmVndWxhckV4cHJlc3Npb25dID0gJ1JlZ3VsYXJFeHByZXNzaW9uJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uVGVtcGxhdGVdID0gJ1RlbXBsYXRlJztcblxuICAgIC8vIEEgZnVuY3Rpb24gZm9sbG93aW5nIG9uZSBvZiB0aG9zZSB0b2tlbnMgaXMgYW4gZXhwcmVzc2lvbi5cbiAgICBGbkV4cHJUb2tlbnMgPSBbJygnLCAneycsICdbJywgJ2luJywgJ3R5cGVvZicsICdpbnN0YW5jZW9mJywgJ25ldycsXG4gICAgICAgICAgICAgICAgICAgICdyZXR1cm4nLCAnY2FzZScsICdkZWxldGUnLCAndGhyb3cnLCAndm9pZCcsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbm1lbnQgb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgICc9JywgJys9JywgJy09JywgJyo9JywgJy89JywgJyU9JywgJzw8PScsICc+Pj0nLCAnPj4+PScsXG4gICAgICAgICAgICAgICAgICAgICcmPScsICd8PScsICdePScsICcsJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gYmluYXJ5L3VuYXJ5IG9wZXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICAnKycsICctJywgJyonLCAnLycsICclJywgJysrJywgJy0tJywgJzw8JywgJz4+JywgJz4+PicsICcmJyxcbiAgICAgICAgICAgICAgICAgICAgJ3wnLCAnXicsICchJywgJ34nLCAnJiYnLCAnfHwnLCAnPycsICc6JywgJz09PScsICc9PScsICc+PScsXG4gICAgICAgICAgICAgICAgICAgICc8PScsICc8JywgJz4nLCAnIT0nLCAnIT09J107XG5cbiAgICBTeW50YXggPSB7XG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxuICAgICAgICBBc3NpZ25tZW50UGF0dGVybjogJ0Fzc2lnbm1lbnRQYXR0ZXJuJyxcbiAgICAgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcbiAgICAgICAgQXJyYXlQYXR0ZXJuOiAnQXJyYXlQYXR0ZXJuJyxcbiAgICAgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgICAgIEJsb2NrU3RhdGVtZW50OiAnQmxvY2tTdGF0ZW1lbnQnLFxuICAgICAgICBCaW5hcnlFeHByZXNzaW9uOiAnQmluYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgIEJyZWFrU3RhdGVtZW50OiAnQnJlYWtTdGF0ZW1lbnQnLFxuICAgICAgICBDYWxsRXhwcmVzc2lvbjogJ0NhbGxFeHByZXNzaW9uJyxcbiAgICAgICAgQ2F0Y2hDbGF1c2U6ICdDYXRjaENsYXVzZScsXG4gICAgICAgIENsYXNzQm9keTogJ0NsYXNzQm9keScsXG4gICAgICAgIENsYXNzRGVjbGFyYXRpb246ICdDbGFzc0RlY2xhcmF0aW9uJyxcbiAgICAgICAgQ2xhc3NFeHByZXNzaW9uOiAnQ2xhc3NFeHByZXNzaW9uJyxcbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICAgICAgQ29udGludWVTdGF0ZW1lbnQ6ICdDb250aW51ZVN0YXRlbWVudCcsXG4gICAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6ICdEb1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgRGVidWdnZXJTdGF0ZW1lbnQ6ICdEZWJ1Z2dlclN0YXRlbWVudCcsXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiAnRW1wdHlTdGF0ZW1lbnQnLFxuICAgICAgICBFeHBvcnRBbGxEZWNsYXJhdGlvbjogJ0V4cG9ydEFsbERlY2xhcmF0aW9uJyxcbiAgICAgICAgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOiAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJyxcbiAgICAgICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbjogJ0V4cG9ydE5hbWVkRGVjbGFyYXRpb24nLFxuICAgICAgICBFeHBvcnRTcGVjaWZpZXI6ICdFeHBvcnRTcGVjaWZpZXInLFxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiAnRXhwcmVzc2lvblN0YXRlbWVudCcsXG4gICAgICAgIEZvclN0YXRlbWVudDogJ0ZvclN0YXRlbWVudCcsXG4gICAgICAgIEZvck9mU3RhdGVtZW50OiAnRm9yT2ZTdGF0ZW1lbnQnLFxuICAgICAgICBGb3JJblN0YXRlbWVudDogJ0ZvckluU3RhdGVtZW50JyxcbiAgICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogJ0Z1bmN0aW9uRGVjbGFyYXRpb24nLFxuICAgICAgICBGdW5jdGlvbkV4cHJlc3Npb246ICdGdW5jdGlvbkV4cHJlc3Npb24nLFxuICAgICAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXG4gICAgICAgIElmU3RhdGVtZW50OiAnSWZTdGF0ZW1lbnQnLFxuICAgICAgICBJbXBvcnREZWNsYXJhdGlvbjogJ0ltcG9ydERlY2xhcmF0aW9uJyxcbiAgICAgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnRTcGVjaWZpZXI6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6ICdMYWJlbGVkU3RhdGVtZW50JyxcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246ICdMb2dpY2FsRXhwcmVzc2lvbicsXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgTWV0YVByb3BlcnR5OiAnTWV0YVByb3BlcnR5JyxcbiAgICAgICAgTWV0aG9kRGVmaW5pdGlvbjogJ01ldGhvZERlZmluaXRpb24nLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiAnTmV3RXhwcmVzc2lvbicsXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgICAgT2JqZWN0UGF0dGVybjogJ09iamVjdFBhdHRlcm4nLFxuICAgICAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXG4gICAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgICBSZXN0RWxlbWVudDogJ1Jlc3RFbGVtZW50JyxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiAnUmV0dXJuU3RhdGVtZW50JyxcbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uOiAnU2VxdWVuY2VFeHByZXNzaW9uJyxcbiAgICAgICAgU3ByZWFkRWxlbWVudDogJ1NwcmVhZEVsZW1lbnQnLFxuICAgICAgICBTdXBlcjogJ1N1cGVyJyxcbiAgICAgICAgU3dpdGNoQ2FzZTogJ1N3aXRjaENhc2UnLFxuICAgICAgICBTd2l0Y2hTdGF0ZW1lbnQ6ICdTd2l0Y2hTdGF0ZW1lbnQnLFxuICAgICAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246ICdUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24nLFxuICAgICAgICBUZW1wbGF0ZUVsZW1lbnQ6ICdUZW1wbGF0ZUVsZW1lbnQnLFxuICAgICAgICBUZW1wbGF0ZUxpdGVyYWw6ICdUZW1wbGF0ZUxpdGVyYWwnLFxuICAgICAgICBUaGlzRXhwcmVzc2lvbjogJ1RoaXNFeHByZXNzaW9uJyxcbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6ICdUaHJvd1N0YXRlbWVudCcsXG4gICAgICAgIFRyeVN0YXRlbWVudDogJ1RyeVN0YXRlbWVudCcsXG4gICAgICAgIFVuYXJ5RXhwcmVzc2lvbjogJ1VuYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246ICdVcGRhdGVFeHByZXNzaW9uJyxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICBXaGlsZVN0YXRlbWVudDogJ1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgV2l0aFN0YXRlbWVudDogJ1dpdGhTdGF0ZW1lbnQnLFxuICAgICAgICBZaWVsZEV4cHJlc3Npb246ICdZaWVsZEV4cHJlc3Npb24nXG4gICAgfTtcblxuICAgIFBsYWNlSG9sZGVycyA9IHtcbiAgICAgICAgQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcjogJ0Fycm93UGFyYW1ldGVyUGxhY2VIb2xkZXInXG4gICAgfTtcblxuICAgIC8vIEVycm9yIG1lc3NhZ2VzIHNob3VsZCBiZSBpZGVudGljYWwgdG8gVjguXG4gICAgTWVzc2FnZXMgPSB7XG4gICAgICAgIFVuZXhwZWN0ZWRUb2tlbjogJ1VuZXhwZWN0ZWQgdG9rZW4gJTAnLFxuICAgICAgICBVbmV4cGVjdGVkTnVtYmVyOiAnVW5leHBlY3RlZCBudW1iZXInLFxuICAgICAgICBVbmV4cGVjdGVkU3RyaW5nOiAnVW5leHBlY3RlZCBzdHJpbmcnLFxuICAgICAgICBVbmV4cGVjdGVkSWRlbnRpZmllcjogJ1VuZXhwZWN0ZWQgaWRlbnRpZmllcicsXG4gICAgICAgIFVuZXhwZWN0ZWRSZXNlcnZlZDogJ1VuZXhwZWN0ZWQgcmVzZXJ2ZWQgd29yZCcsXG4gICAgICAgIFVuZXhwZWN0ZWRUZW1wbGF0ZTogJ1VuZXhwZWN0ZWQgcXVhc2kgJTAnLFxuICAgICAgICBVbmV4cGVjdGVkRU9TOiAnVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnLFxuICAgICAgICBOZXdsaW5lQWZ0ZXJUaHJvdzogJ0lsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvdycsXG4gICAgICAgIEludmFsaWRSZWdFeHA6ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbicsXG4gICAgICAgIFVudGVybWluYXRlZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiBtaXNzaW5nIC8nLFxuICAgICAgICBJbnZhbGlkTEhTSW5Bc3NpZ25tZW50OiAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBhc3NpZ25tZW50JyxcbiAgICAgICAgSW52YWxpZExIU0luRm9ySW46ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1pbicsXG4gICAgICAgIEludmFsaWRMSFNJbkZvckxvb3A6ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1sb29wJyxcbiAgICAgICAgTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoOiAnTW9yZSB0aGFuIG9uZSBkZWZhdWx0IGNsYXVzZSBpbiBzd2l0Y2ggc3RhdGVtZW50JyxcbiAgICAgICAgTm9DYXRjaE9yRmluYWxseTogJ01pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBhZnRlciB0cnknLFxuICAgICAgICBVbmtub3duTGFiZWw6ICdVbmRlZmluZWQgbGFiZWwgXFwnJTBcXCcnLFxuICAgICAgICBSZWRlY2xhcmF0aW9uOiAnJTAgXFwnJTFcXCcgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZCcsXG4gICAgICAgIElsbGVnYWxDb250aW51ZTogJ0lsbGVnYWwgY29udGludWUgc3RhdGVtZW50JyxcbiAgICAgICAgSWxsZWdhbEJyZWFrOiAnSWxsZWdhbCBicmVhayBzdGF0ZW1lbnQnLFxuICAgICAgICBJbGxlZ2FsUmV0dXJuOiAnSWxsZWdhbCByZXR1cm4gc3RhdGVtZW50JyxcbiAgICAgICAgU3RyaWN0TW9kZVdpdGg6ICdTdHJpY3QgbW9kZSBjb2RlIG1heSBub3QgaW5jbHVkZSBhIHdpdGggc3RhdGVtZW50JyxcbiAgICAgICAgU3RyaWN0Q2F0Y2hWYXJpYWJsZTogJ0NhdGNoIHZhcmlhYmxlIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RWYXJOYW1lOiAnVmFyaWFibGUgbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0UGFyYW1OYW1lOiAnUGFyYW1ldGVyIG5hbWUgZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RQYXJhbUR1cGU6ICdTdHJpY3QgbW9kZSBmdW5jdGlvbiBtYXkgbm90IGhhdmUgZHVwbGljYXRlIHBhcmFtZXRlciBuYW1lcycsXG4gICAgICAgIFN0cmljdEZ1bmN0aW9uTmFtZTogJ0Z1bmN0aW9uIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdE9jdGFsTGl0ZXJhbDogJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZS4nLFxuICAgICAgICBTdHJpY3REZWxldGU6ICdEZWxldGUgb2YgYW4gdW5xdWFsaWZpZWQgaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZS4nLFxuICAgICAgICBTdHJpY3RMSFNBc3NpZ25tZW50OiAnQXNzaWdubWVudCB0byBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdExIU1Bvc3RmaXg6ICdQb3N0Zml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RMSFNQcmVmaXg6ICdQcmVmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdFJlc2VydmVkV29yZDogJ1VzZSBvZiBmdXR1cmUgcmVzZXJ2ZWQgd29yZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFRlbXBsYXRlT2N0YWxMaXRlcmFsOiAnT2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHRlbXBsYXRlIHN0cmluZ3MuJyxcbiAgICAgICAgUGFyYW1ldGVyQWZ0ZXJSZXN0UGFyYW1ldGVyOiAnUmVzdCBwYXJhbWV0ZXIgbXVzdCBiZSBsYXN0IGZvcm1hbCBwYXJhbWV0ZXInLFxuICAgICAgICBEZWZhdWx0UmVzdFBhcmFtZXRlcjogJ1VuZXhwZWN0ZWQgdG9rZW4gPScsXG4gICAgICAgIE9iamVjdFBhdHRlcm5Bc1Jlc3RQYXJhbWV0ZXI6ICdVbmV4cGVjdGVkIHRva2VuIHsnLFxuICAgICAgICBEdXBsaWNhdGVQcm90b1Byb3BlcnR5OiAnRHVwbGljYXRlIF9fcHJvdG9fXyBmaWVsZHMgYXJlIG5vdCBhbGxvd2VkIGluIG9iamVjdCBsaXRlcmFscycsXG4gICAgICAgIENvbnN0cnVjdG9yU3BlY2lhbE1ldGhvZDogJ0NsYXNzIGNvbnN0cnVjdG9yIG1heSBub3QgYmUgYW4gYWNjZXNzb3InLFxuICAgICAgICBEdXBsaWNhdGVDb25zdHJ1Y3RvcjogJ0EgY2xhc3MgbWF5IG9ubHkgaGF2ZSBvbmUgY29uc3RydWN0b3InLFxuICAgICAgICBTdGF0aWNQcm90b3R5cGU6ICdDbGFzc2VzIG1heSBub3QgaGF2ZSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgcHJvdG90eXBlJyxcbiAgICAgICAgTWlzc2luZ0Zyb21DbGF1c2U6ICdVbmV4cGVjdGVkIHRva2VuJyxcbiAgICAgICAgTm9Bc0FmdGVySW1wb3J0TmFtZXNwYWNlOiAnVW5leHBlY3RlZCB0b2tlbicsXG4gICAgICAgIEludmFsaWRNb2R1bGVTcGVjaWZpZXI6ICdVbmV4cGVjdGVkIHRva2VuJyxcbiAgICAgICAgSWxsZWdhbEltcG9ydERlY2xhcmF0aW9uOiAnVW5leHBlY3RlZCB0b2tlbicsXG4gICAgICAgIElsbGVnYWxFeHBvcnREZWNsYXJhdGlvbjogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxuICAgICAgICBEdXBsaWNhdGVCaW5kaW5nOiAnRHVwbGljYXRlIGJpbmRpbmcgJTAnXG4gICAgfTtcblxuICAgIC8vIFNlZSBhbHNvIHRvb2xzL2dlbmVyYXRlLXVuaWNvZGUtcmVnZXguanMuXG4gICAgUmVnZXggPSB7XG4gICAgICAgIC8vIEVDTUFTY3JpcHQgNi9Vbmljb2RlIHY3LjAuMCBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDpcbiAgICAgICAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6IC9bXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjJcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNThcXHUwQzU5XFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENjBcXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QzEtXFx1MTlDN1xcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5Qi1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkNDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3QURcXHVBN0IwXFx1QTdCMVxcdUE3RjctXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjVGXFx1QUI2NFxcdUFCNjVcXHVBQkMwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERDQwLVxcdURENzRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNEFcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdUREMDMtXFx1REQyNlxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REVCMC1cXHVERURFXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQV18XFx1RDgwNltcXHVEQ0EwLVxcdURDREZcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA4W1xcdURDMDAtXFx1REY5OF18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVdfFtcXHVEODBDXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNDAtXFx1REY0M1xcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwXFx1REY5My1cXHVERjlGXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNF18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF0vLFxuXG4gICAgICAgIC8vIEVDTUFTY3JpcHQgNi9Vbmljb2RlIHY3LjAuMCBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OlxuICAgICAgICBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OiAvW1xceEFBXFx4QjVcXHhCN1xceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODYtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwOEEwLVxcdTA4QjJcXHUwOEU0LVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4XFx1MEM1OVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODEtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENjAtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzNjktXFx1MTM3MVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOURBXFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFDRjhcXHUxQ0Y5XFx1MUQwMC1cXHUxREY1XFx1MURGQy1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwMENcXHUyMDBEXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTktXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTY5RFxcdUE2OUYtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjBcXHVBN0IxXFx1QTdGNy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM0XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlGRVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0EtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI1RlxcdUFCNjRcXHVBQjY1XFx1QUJDMC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRFxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURERkRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERUUwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjRBXFx1REY1MC1cXHVERjdBXFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQTAtXFx1RENBOVxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTZcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XXxcXHVEODA0W1xcdURDMDAtXFx1REM0NlxcdURDNjYtXFx1REM2RlxcdURDN0YtXFx1RENCQVxcdURDRDAtXFx1RENFOFxcdURDRjAtXFx1RENGOVxcdUREMDAtXFx1REQzNFxcdUREMzYtXFx1REQzRlxcdURENTAtXFx1REQ3M1xcdURENzZcXHVERDgwLVxcdUREQzRcXHVEREQwLVxcdUREREFcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMzdcXHVERUIwLVxcdURFRUFcXHVERUYwLVxcdURFRjlcXHVERjAxLVxcdURGMDNcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzQy1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjU3XFx1REY1RC1cXHVERjYzXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDODAtXFx1RENDNVxcdURDQzdcXHVEQ0QwLVxcdURDRDlcXHVERDgwLVxcdUREQjVcXHVEREI4LVxcdUREQzBcXHVERTAwLVxcdURFNDBcXHVERTQ0XFx1REU1MC1cXHVERTU5XFx1REU4MC1cXHVERUI3XFx1REVDMC1cXHVERUM5XXxcXHVEODA2W1xcdURDQTAtXFx1RENFOVxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk4XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RV18W1xcdUQ4MENcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REU2MC1cXHVERTY5XFx1REVEMC1cXHVERUVEXFx1REVGMC1cXHVERUY0XFx1REYwMC1cXHVERjM2XFx1REY0MC1cXHVERjQzXFx1REY1MC1cXHVERjU5XFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTAtXFx1REY3RVxcdURGOEYtXFx1REY5Rl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTlcXHVEQzlEXFx1REM5RV18XFx1RDgzNFtcXHVERDY1LVxcdURENjlcXHVERDZELVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQlxcdURGQ0UtXFx1REZGRl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVEQ0QwLVxcdURDRDZdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRF18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXS9cbiAgICB9O1xuXG4gICAgLy8gRW5zdXJlIHRoZSBjb25kaXRpb24gaXMgdHJ1ZSwgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yLlxuICAgIC8vIFRoaXMgaXMgb25seSB0byBoYXZlIGEgYmV0dGVyIGNvbnRyYWN0IHNlbWFudGljLCBpLmUuIGFub3RoZXIgc2FmZXR5IG5ldFxuICAgIC8vIHRvIGNhdGNoIGEgbG9naWMgZXJyb3IuIFRoZSBjb25kaXRpb24gc2hhbGwgYmUgZnVsZmlsbGVkIGluIG5vcm1hbCBjYXNlLlxuICAgIC8vIERvIE5PVCB1c2UgdGhpcyB0byBlbmZvcmNlIGEgY2VydGFpbiBjb25kaXRpb24gb24gYW55IHVzZXIgaW5wdXQuXG5cbiAgICBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBU1NFUlQ6ICcgKyBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPj0gMHgzMCAmJiBjaCA8PSAweDM5KTsgICAvLyAwLi45XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gJzAxMjM0NTY3ODlhYmNkZWZBQkNERUYnLmluZGV4T2YoY2gpID49IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpID49IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2N0YWxUb0RlY2ltYWwoY2gpIHtcbiAgICAgICAgLy8gXFwwIGlzIG5vdCBvY3RhbCBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgdmFyIG9jdGFsID0gKGNoICE9PSAnMCcpLCBjb2RlID0gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKTtcblxuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICBvY3RhbCA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTtcblxuICAgICAgICAgICAgLy8gMyBkaWdpdHMgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHN0cmluZyBzdGFydHNcbiAgICAgICAgICAgIC8vIHdpdGggMCwgMSwgMiwgM1xuICAgICAgICAgICAgaWYgKCcwMTIzJy5pbmRleE9mKGNoKSA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGluZGV4IDwgbGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIGlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArICcwMTIzNDU2NycuaW5kZXhPZihzb3VyY2VbaW5kZXgrK10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICBvY3RhbDogb2N0YWxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMS4yIFdoaXRlIFNwYWNlXG5cbiAgICBmdW5jdGlvbiBpc1doaXRlU3BhY2UoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA9PT0gMHgyMCkgfHwgKGNoID09PSAweDA5KSB8fCAoY2ggPT09IDB4MEIpIHx8IChjaCA9PT0gMHgwQykgfHwgKGNoID09PSAweEEwKSB8fFxuICAgICAgICAgICAgKGNoID49IDB4MTY4MCAmJiBbMHgxNjgwLCAweDE4MEUsIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsIDB4MjAwMywgMHgyMDA0LCAweDIwMDUsIDB4MjAwNiwgMHgyMDA3LCAweDIwMDgsIDB4MjAwOSwgMHgyMDBBLCAweDIwMkYsIDB4MjA1RiwgMHgzMDAwLCAweEZFRkZdLmluZGV4T2YoY2gpID49IDApO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDExLjMgTGluZSBUZXJtaW5hdG9yc1xuXG4gICAgZnVuY3Rpb24gaXNMaW5lVGVybWluYXRvcihjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAweDBBKSB8fCAoY2ggPT09IDB4MEQpIHx8IChjaCA9PT0gMHgyMDI4KSB8fCAoY2ggPT09IDB4MjAyOSk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTEuNiBJZGVudGlmaWVyIE5hbWVzIGFuZCBJZGVudGlmaWVyc1xuXG4gICAgZnVuY3Rpb24gZnJvbUNvZGVQb2ludChjcCkge1xuICAgICAgICByZXR1cm4gKGNwIDwgMHgxMDAwMCkgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNwKSA6XG4gICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCArICgoY3AgLSAweDEwMDAwKSA+PiAxMCkpICtcbiAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEQzAwICsgKChjcCAtIDB4MTAwMDApICYgMTAyMykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPT09IDB4MjQpIHx8IChjaCA9PT0gMHg1RikgfHwgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICAgICAgICAoY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgICAgIChjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EpIHx8ICAgICAgICAgLy8gYS4uelxuICAgICAgICAgICAgKGNoID09PSAweDVDKSB8fCAgICAgICAgICAgICAgICAgICAgICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KGZyb21Db2RlUG9pbnQoY2gpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAweDI0KSB8fCAoY2ggPT09IDB4NUYpIHx8ICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICAgICAgICAgICAgKGNoID49IDB4NDEgJiYgY2ggPD0gMHg1QSkgfHwgICAgICAgICAvLyBBLi5aXG4gICAgICAgICAgICAoY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBKSB8fCAgICAgICAgIC8vIGEuLnpcbiAgICAgICAgICAgIChjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkpIHx8ICAgICAgICAgLy8gMC4uOVxuICAgICAgICAgICAgKGNoID09PSAweDVDKSB8fCAgICAgICAgICAgICAgICAgICAgICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoZnJvbUNvZGVQb2ludChjaCkpKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMS42LjIuMiBGdXR1cmUgUmVzZXJ2ZWQgV29yZHNcblxuICAgIGZ1bmN0aW9uIGlzRnV0dXJlUmVzZXJ2ZWRXb3JkKGlkKSB7XG4gICAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgICAgY2FzZSAnZW51bSc6XG4gICAgICAgIGNhc2UgJ2V4cG9ydCc6XG4gICAgICAgIGNhc2UgJ2ltcG9ydCc6XG4gICAgICAgIGNhc2UgJ3N1cGVyJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKGlkKSB7XG4gICAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgICAgY2FzZSAnaW1wbGVtZW50cyc6XG4gICAgICAgIGNhc2UgJ2ludGVyZmFjZSc6XG4gICAgICAgIGNhc2UgJ3BhY2thZ2UnOlxuICAgICAgICBjYXNlICdwcml2YXRlJzpcbiAgICAgICAgY2FzZSAncHJvdGVjdGVkJzpcbiAgICAgICAgY2FzZSAncHVibGljJzpcbiAgICAgICAgY2FzZSAnc3RhdGljJzpcbiAgICAgICAgY2FzZSAneWllbGQnOlxuICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Jlc3RyaWN0ZWRXb3JkKGlkKSB7XG4gICAgICAgIHJldHVybiBpZCA9PT0gJ2V2YWwnIHx8IGlkID09PSAnYXJndW1lbnRzJztcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMS42LjIuMSBLZXl3b3Jkc1xuXG4gICAgZnVuY3Rpb24gaXNLZXl3b3JkKGlkKSB7XG4gICAgICAgIHN3aXRjaCAoaWQubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpZicpIHx8IChpZCA9PT0gJ2luJykgfHwgKGlkID09PSAnZG8nKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3ZhcicpIHx8IChpZCA9PT0gJ2ZvcicpIHx8IChpZCA9PT0gJ25ldycpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAndHJ5JykgfHwgKGlkID09PSAnbGV0Jyk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd0aGlzJykgfHwgKGlkID09PSAnZWxzZScpIHx8IChpZCA9PT0gJ2Nhc2UnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3ZvaWQnKSB8fCAoaWQgPT09ICd3aXRoJykgfHwgKGlkID09PSAnZW51bScpO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnd2hpbGUnKSB8fCAoaWQgPT09ICdicmVhaycpIHx8IChpZCA9PT0gJ2NhdGNoJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICd0aHJvdycpIHx8IChpZCA9PT0gJ2NvbnN0JykgfHwgKGlkID09PSAneWllbGQnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ2NsYXNzJykgfHwgKGlkID09PSAnc3VwZXInKTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3JldHVybicpIHx8IChpZCA9PT0gJ3R5cGVvZicpIHx8IChpZCA9PT0gJ2RlbGV0ZScpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAnc3dpdGNoJykgfHwgKGlkID09PSAnZXhwb3J0JykgfHwgKGlkID09PSAnaW1wb3J0Jyk7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdkZWZhdWx0JykgfHwgKGlkID09PSAnZmluYWxseScpIHx8IChpZCA9PT0gJ2V4dGVuZHMnKTtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2Z1bmN0aW9uJykgfHwgKGlkID09PSAnY29udGludWUnKSB8fCAoaWQgPT09ICdkZWJ1Z2dlcicpO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2luc3RhbmNlb2YnKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDExLjQgQ29tbWVudHNcblxuICAgIGZ1bmN0aW9uIGFkZENvbW1lbnQodHlwZSwgdmFsdWUsIHN0YXJ0LCBlbmQsIGxvYykge1xuICAgICAgICB2YXIgY29tbWVudDtcblxuICAgICAgICBhc3NlcnQodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJywgJ0NvbW1lbnQgbXVzdCBoYXZlIHZhbGlkIHBvc2l0aW9uJyk7XG5cbiAgICAgICAgc3RhdGUubGFzdENvbW1lbnRTdGFydCA9IHN0YXJ0O1xuXG4gICAgICAgIGNvbW1lbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgY29tbWVudC5yYW5nZSA9IFtzdGFydCwgZW5kXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICBjb21tZW50LmxvYyA9IGxvYztcbiAgICAgICAgfVxuICAgICAgICBleHRyYS5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICBpZiAoZXh0cmEuYXR0YWNoQ29tbWVudCkge1xuICAgICAgICAgICAgZXh0cmEubGVhZGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICBleHRyYS50cmFpbGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICBjb21tZW50LnR5cGUgPSBjb21tZW50LnR5cGUgKyAnQ29tbWVudCc7XG4gICAgICAgICAgICBpZiAoZXh0cmEuZGVsZWdhdGUpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gZXh0cmEuZGVsZWdhdGUoY29tbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRyYS50b2tlbnMucHVzaChjb21tZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNraXBTaW5nbGVMaW5lQ29tbWVudChvZmZzZXQpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBsb2MsIGNoLCBjb21tZW50O1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXggLSBvZmZzZXQ7XG4gICAgICAgIGxvYyA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0IC0gb2Zmc2V0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICBoYXNMaW5lVGVybWluYXRvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyBvZmZzZXQsIGluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydCAtIDFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ29tbWVudCgnTGluZScsIGNvbW1lbnQsIHN0YXJ0LCBpbmRleCAtIDEsIGxvYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMTMgJiYgc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICBjb21tZW50ID0gc291cmNlLnNsaWNlKHN0YXJ0ICsgb2Zmc2V0LCBpbmRleCk7XG4gICAgICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFkZENvbW1lbnQoJ0xpbmUnLCBjb21tZW50LCBzdGFydCwgaW5kZXgsIGxvYyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2lwTXVsdGlMaW5lQ29tbWVudCgpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBsb2MsIGNoLCBjb21tZW50O1xuXG4gICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xuICAgICAgICAgICAgc3RhcnQgPSBpbmRleCAtIDI7XG4gICAgICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydCAtIDJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgwRCAmJiBzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpID09PSAweDBBKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhc0xpbmVUZXJtaW5hdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MkEpIHtcbiAgICAgICAgICAgICAgICAvLyBCbG9jayBjb21tZW50IGVuZHMgd2l0aCAnKi8nLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpID09PSAweDJGKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IHNvdXJjZS5zbGljZShzdGFydCArIDIsIGluZGV4IC0gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnQoJ0Jsb2NrJywgY29tbWVudCwgc3RhcnQsIGluZGV4LCBsb2MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIGVuZCBvZiB0aGUgZmlsZSAtIHRoZSB3aG9sZSB0aGluZyBpcyBhIGNvbW1lbnRcbiAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbW1lbnQgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyAyLCBpbmRleCk7XG4gICAgICAgICAgICBhZGRDb21tZW50KCdCbG9jaycsIGNvbW1lbnQsIHN0YXJ0LCBpbmRleCwgbG9jKTtcbiAgICAgICAgfVxuICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNraXBDb21tZW50KCkge1xuICAgICAgICB2YXIgY2gsIHN0YXJ0O1xuICAgICAgICBoYXNMaW5lVGVybWluYXRvciA9IGZhbHNlO1xuXG4gICAgICAgIHN0YXJ0ID0gKGluZGV4ID09PSAwKTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgICAgICAgICAgaWYgKGlzV2hpdGVTcGFjZShjaCkpIHtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgIGhhc0xpbmVUZXJtaW5hdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgwRCAmJiBzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4MEEpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MkYpIHsgLy8gVSswMDJGIGlzICcvJ1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MkYpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNpbmdsZUxpbmVDb21tZW50KDIpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyQSkgeyAgLy8gVSswMDJBIGlzICcqJ1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICBza2lwTXVsdGlMaW5lQ29tbWVudCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnQgJiYgY2ggPT09IDB4MkQpIHsgLy8gVSswMDJEIGlzICctJ1xuICAgICAgICAgICAgICAgIC8vIFUrMDAzRSBpcyAnPidcbiAgICAgICAgICAgICAgICBpZiAoKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSkgPT09IDB4MkQpICYmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDIpID09PSAweDNFKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAnLS0+JyBpcyBhIHNpbmdsZS1saW5lIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNpbmdsZUxpbmVDb21tZW50KDMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4M0MpIHsgLy8gVSswMDNDIGlzICc8J1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoaW5kZXggKyAxLCBpbmRleCArIDQpID09PSAnIS0tJykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4OyAvLyBgPGBcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDsgLy8gYCFgXG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7IC8vIGAtYFxuICAgICAgICAgICAgICAgICAgICArK2luZGV4OyAvLyBgLWBcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNpbmdsZUxpbmVDb21tZW50KDQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuSGV4RXNjYXBlKHByZWZpeCkge1xuICAgICAgICB2YXIgaSwgbGVuLCBjaCwgY29kZSA9IDA7XG5cbiAgICAgICAgbGVuID0gKHByZWZpeCA9PT0gJ3UnKSA/IDQgOiAyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKSB7XG4gICAgICAgIHZhciBjaCwgY29kZTtcblxuICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIGNvZGUgPSAwO1xuXG4gICAgICAgIC8vIEF0IGxlYXN0LCBvbmUgaGV4IGRpZ2l0IGlzIHJlcXVpcmVkLlxuICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA+IDB4MTBGRkZGIHx8IGNoICE9PSAnfScpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnJvbUNvZGVQb2ludChjb2RlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2RlUG9pbnRBdChpKSB7XG4gICAgICAgIHZhciBjcCwgZmlyc3QsIHNlY29uZDtcblxuICAgICAgICBjcCA9IHNvdXJjZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY3AgPj0gMHhEODAwICYmIGNwIDw9IDB4REJGRikge1xuICAgICAgICAgICAgc2Vjb25kID0gc291cmNlLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgICAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gY3A7XG4gICAgICAgICAgICAgICAgY3AgPSAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENvbXBsZXhJZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgY3AsIGNoLCBpZDtcblxuICAgICAgICBjcCA9IGNvZGVQb2ludEF0KGluZGV4KTtcbiAgICAgICAgaWQgPSBmcm9tQ29kZVBvaW50KGNwKTtcbiAgICAgICAgaW5kZXggKz0gaWQubGVuZ3RoO1xuXG4gICAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgaWYgKGNwID09PSAweDVDKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpICE9PSAweDc1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICBjaCA9IHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgICAgIGNwID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoIHx8IGNoID09PSAnXFxcXCcgfHwgIWlzSWRlbnRpZmllclN0YXJ0KGNwKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkID0gY2g7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNwID0gY29kZVBvaW50QXQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNwKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2ggPSBmcm9tQ29kZVBvaW50KGNwKTtcbiAgICAgICAgICAgIGlkICs9IGNoO1xuICAgICAgICAgICAgaW5kZXggKz0gY2gubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBpZiAoY3AgPT09IDB4NUMpIHtcbiAgICAgICAgICAgICAgICBpZCA9IGlkLnN1YnN0cigwLCBpZC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpICE9PSAweDc1KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICBjaCA9IHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNwID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJQYXJ0KGNwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZCArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgc3RhcnQsIGNoO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXgrKztcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgICAgICAgICAgIC8vIEJsYWNrc2xhc2ggKFUrMDA1QykgbWFya3MgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgaW5kZXggPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcGxleElkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPj0gMHhEODAwICYmIGNoIDwgMHhERkZGKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBoYW5kbGUgc3Vycm9nYXRlIHBhaXJzLlxuICAgICAgICAgICAgICAgIGluZGV4ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBsZXhJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGluZGV4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuSWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBpZCwgdHlwZTtcblxuICAgICAgICBzdGFydCA9IGluZGV4O1xuXG4gICAgICAgIC8vIEJhY2tzbGFzaCAoVSswMDVDKSBzdGFydHMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgIGlkID0gKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHg1QykgPyBnZXRDb21wbGV4SWRlbnRpZmllcigpIDogZ2V0SWRlbnRpZmllcigpO1xuXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIGtleXdvcmQgb3IgbGl0ZXJhbCB3aXRoIG9ubHkgb25lIGNoYXJhY3Rlci5cbiAgICAgICAgLy8gVGh1cywgaXQgbXVzdCBiZSBhbiBpZGVudGlmaWVyLlxuICAgICAgICBpZiAoaWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uSWRlbnRpZmllcjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0tleXdvcmQoaWQpKSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uS2V5d29yZDtcbiAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uTnVsbExpdGVyYWw7XG4gICAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICd0cnVlJyB8fCBpZCA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgdHlwZSA9IFRva2VuLkJvb2xlYW5MaXRlcmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZSA9IFRva2VuLklkZW50aWZpZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBpZCxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIC8vIEVDTUEtMjYyIDExLjcgUHVuY3R1YXRvcnNcblxuICAgIGZ1bmN0aW9uIHNjYW5QdW5jdHVhdG9yKCkge1xuICAgICAgICB2YXIgdG9rZW4sIHN0cjtcblxuICAgICAgICB0b2tlbiA9IHtcbiAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICB2YWx1ZTogJycsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICBzdGFydDogaW5kZXgsXG4gICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG1vc3QgY29tbW9uIHNpbmdsZS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXG4gICAgICAgIHN0ciA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIHN3aXRjaCAoc3RyKSB7XG5cbiAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICBpZiAoZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5vcGVuUGFyZW5Ub2tlbiA9IGV4dHJhLnRva2VuVmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgIGlmIChleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgICAgICAgIGV4dHJhLm9wZW5DdXJseVRva2VuID0gZXh0cmEudG9rZW5WYWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUuY3VybHlTdGFjay5wdXNoKCd7Jyk7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICcuJyAmJiBzb3VyY2VbaW5kZXggKyAxXSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgLy8gU3ByZWFkIG9wZXJhdG9yOiAuLi5cbiAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgIHN0ciA9ICcuLi4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgc3RhdGUuY3VybHlTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcpJzpcbiAgICAgICAgY2FzZSAnOyc6XG4gICAgICAgIGNhc2UgJywnOlxuICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgIGNhc2UgJzonOlxuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgY2FzZSAnfic6XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIDQtY2hhcmFjdGVyIHB1bmN0dWF0b3IuXG4gICAgICAgICAgICBzdHIgPSBzb3VyY2Uuc3Vic3RyKGluZGV4LCA0KTtcbiAgICAgICAgICAgIGlmIChzdHIgPT09ICc+Pj49Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gMy1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCAzKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAnPT09JyB8fCBzdHIgPT09ICchPT0nIHx8IHN0ciA9PT0gJz4+PicgfHxcbiAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnPDw9JyB8fCBzdHIgPT09ICc+Pj0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyAyLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gJyYmJyB8fCBzdHIgPT09ICd8fCcgfHwgc3RyID09PSAnPT0nIHx8IHN0ciA9PT0gJyE9JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnKz0nIHx8IHN0ciA9PT0gJy09JyB8fCBzdHIgPT09ICcqPScgfHwgc3RyID09PSAnLz0nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICcrKycgfHwgc3RyID09PSAnLS0nIHx8IHN0ciA9PT0gJzw8JyB8fCBzdHIgPT09ICc+PicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJyY9JyB8fCBzdHIgPT09ICd8PScgfHwgc3RyID09PSAnXj0nIHx8IHN0ciA9PT0gJyU9JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnPD0nIHx8IHN0ciA9PT0gJz49JyB8fCBzdHIgPT09ICc9PicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnPD49ISstKiUmfF4vJy5pbmRleE9mKHN0cikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPT09IHRva2VuLnN0YXJ0KSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW4uZW5kID0gaW5kZXg7XG4gICAgICAgIHRva2VuLnZhbHVlID0gc3RyO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTEuOC4zIE51bWVyaWMgTGl0ZXJhbHNcblxuICAgIGZ1bmN0aW9uIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KSB7XG4gICAgICAgIHZhciBudW1iZXIgPSAnJztcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChudW1iZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQoJzB4JyArIG51bWJlciwgMTYpLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5CaW5hcnlMaXRlcmFsKHN0YXJ0KSB7XG4gICAgICAgIHZhciBjaCwgbnVtYmVyO1xuXG4gICAgICAgIG51bWJlciA9ICcnO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGNoICE9PSAnMCcgJiYgY2ggIT09ICcxJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChudW1iZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBvbmx5IDBiIG9yIDBCXG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpIHx8IGlzRGVjaW1hbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQobnVtYmVyLCAyKSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuT2N0YWxMaXRlcmFsKHByZWZpeCwgc3RhcnQpIHtcbiAgICAgICAgdmFyIG51bWJlciwgb2N0YWw7XG5cbiAgICAgICAgaWYgKGlzT2N0YWxEaWdpdChwcmVmaXgpKSB7XG4gICAgICAgICAgICBvY3RhbCA9IHRydWU7XG4gICAgICAgICAgICBudW1iZXIgPSAnMCcgKyBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvY3RhbCA9IGZhbHNlO1xuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIG51bWJlciA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb2N0YWwgJiYgbnVtYmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gb25seSAwbyBvciAwT1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpIHx8IGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQobnVtYmVyLCA4KSxcbiAgICAgICAgICAgIG9jdGFsOiBvY3RhbCxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0ltcGxpY2l0T2N0YWxMaXRlcmFsKCkge1xuICAgICAgICB2YXIgaSwgY2g7XG5cbiAgICAgICAgLy8gSW1wbGljaXQgb2N0YWwsIHVubGVzcyB0aGVyZSBpcyBhIG5vbi1vY3RhbCBkaWdpdC5cbiAgICAgICAgLy8gKEFubmV4IEIuMS4xIG9uIE51bWVyaWMgTGl0ZXJhbHMpXG4gICAgICAgIGZvciAoaSA9IGluZGV4ICsgMTsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJzgnIHx8IGNoID09PSAnOScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5OdW1lcmljTGl0ZXJhbCgpIHtcbiAgICAgICAgdmFyIG51bWJlciwgc3RhcnQsIGNoO1xuXG4gICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgYXNzZXJ0KGlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpIHx8IChjaCA9PT0gJy4nKSxcbiAgICAgICAgICAgICdOdW1lcmljIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgZGVjaW1hbCBkaWdpdCBvciBhIGRlY2ltYWwgcG9pbnQnKTtcblxuICAgICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgICBudW1iZXIgPSAnJztcbiAgICAgICAgaWYgKGNoICE9PSAnLicpIHtcbiAgICAgICAgICAgIG51bWJlciA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcblxuICAgICAgICAgICAgLy8gSGV4IG51bWJlciBzdGFydHMgd2l0aCAnMHgnLlxuICAgICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJy5cbiAgICAgICAgICAgIC8vIE9jdGFsIG51bWJlciBpbiBFUzYgc3RhcnRzIHdpdGggJzBvJy5cbiAgICAgICAgICAgIC8vIEJpbmFyeSBudW1iZXIgaW4gRVM2IHN0YXJ0cyB3aXRoICcwYicuXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd4JyB8fCBjaCA9PT0gJ1gnKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuSGV4TGl0ZXJhbChzdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ2InIHx8IGNoID09PSAnQicpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5CaW5hcnlMaXRlcmFsKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnbycgfHwgY2ggPT09ICdPJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Nhbk9jdGFsTGl0ZXJhbChjaCwgc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ltcGxpY2l0T2N0YWxMaXRlcmFsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuT2N0YWxMaXRlcmFsKGNoLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnKycgfHwgY2ggPT09ICctJykge1xuICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDExLjguNCBTdHJpbmcgTGl0ZXJhbHNcblxuICAgIGZ1bmN0aW9uIHNjYW5TdHJpbmdMaXRlcmFsKCkge1xuICAgICAgICB2YXIgc3RyID0gJycsIHF1b3RlLCBzdGFydCwgY2gsIHVuZXNjYXBlZCwgb2N0VG9EZWMsIG9jdGFsID0gZmFsc2U7XG5cbiAgICAgICAgcXVvdGUgPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoKHF1b3RlID09PSAnXFwnJyB8fCBxdW90ZSA9PT0gJ1wiJyksXG4gICAgICAgICAgICAnU3RyaW5nIGxpdGVyYWwgbXVzdCBzdGFydHMgd2l0aCBhIHF1b3RlJyk7XG5cbiAgICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgKytpbmRleDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XG4gICAgICAgICAgICAgICAgcXVvdGUgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmICghY2ggfHwgIWlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkID0gc2NhbkhleEVzY2FwZShjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1bmVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHVuZXNjYXBlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxmJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx4MEInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzgnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICc5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvY3RUb0RlYyA9IG9jdGFsVG9EZWNpbWFsKGNoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gb2N0VG9EZWMub2N0YWwgfHwgb2N0YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUob2N0VG9EZWMuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHNvdXJjZVtpbmRleF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocXVvdGUgIT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFRva2VuLlN0cmluZ0xpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogc3RyLFxuICAgICAgICAgICAgb2N0YWw6IG9jdGFsLFxuICAgICAgICAgICAgbGluZU51bWJlcjogc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBzdGFydExpbmVTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMS44LjYgVGVtcGxhdGUgTGl0ZXJhbCBMZXhpY2FsIENvbXBvbmVudHNcblxuICAgIGZ1bmN0aW9uIHNjYW5UZW1wbGF0ZSgpIHtcbiAgICAgICAgdmFyIGNvb2tlZCA9ICcnLCBjaCwgc3RhcnQsIHJhd09mZnNldCwgdGVybWluYXRlZCwgaGVhZCwgdGFpbCwgcmVzdG9yZSwgdW5lc2NhcGVkO1xuXG4gICAgICAgIHRlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGFpbCA9IGZhbHNlO1xuICAgICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgICBoZWFkID0gKHNvdXJjZVtpbmRleF0gPT09ICdgJyk7XG4gICAgICAgIHJhd09mZnNldCA9IDI7XG5cbiAgICAgICAgKytpbmRleDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnYCcpIHtcbiAgICAgICAgICAgICAgICByYXdPZmZzZXQgPSAxO1xuICAgICAgICAgICAgICAgIHRhaWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJseVN0YWNrLnB1c2goJyR7Jyk7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgaWYgKCFpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xccic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWQgPSBzY2FuSGV4RXNjYXBlKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSB1bmVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXGInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXGYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbDogXFwwMSBcXDAyIGFuZCBzbyBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLlRlbXBsYXRlT2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbDogXFwxIFxcMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuVGVtcGxhdGVPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGVybWluYXRlZCkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuY3VybHlTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5UZW1wbGF0ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgY29va2VkOiBjb29rZWQsXG4gICAgICAgICAgICAgICAgcmF3OiBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyAxLCBpbmRleCAtIHJhd09mZnNldClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWFkOiBoZWFkLFxuICAgICAgICAgICAgdGFpbDogdGFpbCxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMS44LjUgUmVndWxhciBFeHByZXNzaW9uIExpdGVyYWxzXG5cbiAgICBmdW5jdGlvbiB0ZXN0UmVnRXhwKHBhdHRlcm4sIGZsYWdzKSB7XG4gICAgICAgIC8vIFRoZSBCTVAgY2hhcmFjdGVyIHRvIHVzZSBhcyBhIHJlcGxhY2VtZW50IGZvciBhc3RyYWwgc3ltYm9scyB3aGVuXG4gICAgICAgIC8vIHRyYW5zbGF0aW5nIGFuIEVTNiBcInVcIi1mbGFnZ2VkIHBhdHRlcm4gdG8gYW4gRVM1LWNvbXBhdGlibGVcbiAgICAgICAgLy8gYXBwcm94aW1hdGlvbi5cbiAgICAgICAgLy8gTm90ZTogcmVwbGFjaW5nIHdpdGggJ1xcdUZGRkYnIGVuYWJsZXMgZmFsc2UgcG9zaXRpdmVzIGluIHVubGlrZWx5XG4gICAgICAgIC8vIHNjZW5hcmlvcy4gRm9yIGV4YW1wbGUsIGBbXFx1ezEwNDRmfS1cXHV7MTA0NDB9XWAgaXMgYW4gaW52YWxpZFxuICAgICAgICAvLyBwYXR0ZXJuIHRoYXQgd291bGQgbm90IGJlIGRldGVjdGVkIGJ5IHRoaXMgc3Vic3RpdHV0aW9uLlxuICAgICAgICB2YXIgYXN0cmFsU3Vic3RpdHV0ZSA9ICdcXHVGRkZGJyxcbiAgICAgICAgICAgIHRtcCA9IHBhdHRlcm47XG5cbiAgICAgICAgaWYgKGZsYWdzLmluZGV4T2YoJ3UnKSA+PSAwKSB7XG4gICAgICAgICAgICB0bXAgPSB0bXBcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGV2ZXJ5IFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIHdpdGggdGhlIGVxdWl2YWxlbnRcbiAgICAgICAgICAgICAgICAvLyBCTVAgY2hhcmFjdGVyIG9yIGEgY29uc3RhbnQgQVNDSUkgY29kZSBwb2ludCBpbiB0aGUgY2FzZSBvZlxuICAgICAgICAgICAgICAgIC8vIGFzdHJhbCBzeW1ib2xzLiAoU2VlIHRoZSBhYm92ZSBub3RlIG9uIGBhc3RyYWxTdWJzdGl0dXRlYFxuICAgICAgICAgICAgICAgIC8vIGZvciBtb3JlIGluZm9ybWF0aW9uLilcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXHVcXHsoWzAtOWEtZkEtRl0rKVxcfXxcXFxcdShbYS1mQS1GMC05XXs0fSkvZywgZnVuY3Rpb24gKCQwLCAkMSwgJDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IHBhcnNlSW50KCQxIHx8ICQyLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPiAweDEwRkZGRikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obnVsbCwgTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweEZGRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzdHJhbFN1YnN0aXR1dGU7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGVhY2ggcGFpcmVkIHN1cnJvZ2F0ZSB3aXRoIGEgc2luZ2xlIEFTQ0lJIHN5bWJvbCB0b1xuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHRocm93aW5nIG9uIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBhcmUgb25seSB2YWxpZCBpblxuICAgICAgICAgICAgICAgIC8vIGNvbWJpbmF0aW9uIHdpdGggdGhlIFwidVwiIGZsYWcuXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2csXG4gICAgICAgICAgICAgICAgICAgIGFzdHJhbFN1YnN0aXR1dGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QsIGRldGVjdCBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWdFeHAodG1wKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obnVsbCwgTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IGZvciB0aGlzIHBhdHRlcm4tZmxhZyBwYWlyLCBvclxuICAgICAgICAvLyBgbnVsbGAgaW4gY2FzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IHN1cHBvcnQgdGhlIGZsYWdzIGl0XG4gICAgICAgIC8vIHVzZXMuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuUmVnRXhwQm9keSgpIHtcbiAgICAgICAgdmFyIGNoLCBzdHIsIGNsYXNzTWFya2VyLCB0ZXJtaW5hdGVkLCBib2R5O1xuXG4gICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgYXNzZXJ0KGNoID09PSAnLycsICdSZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBzbGFzaCcpO1xuICAgICAgICBzdHIgPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcbiAgICAgICAgdGVybWluYXRlZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAvLyBFQ01BLTI2MiA3LjguNVxuICAgICAgICAgICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKG51bGwsIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKG51bGwsIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTWFya2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGVybWluYXRlZCkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obnVsbCwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4Y2x1ZGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2guXG4gICAgICAgIGJvZHkgPSBzdHIuc3Vic3RyKDEsIHN0ci5sZW5ndGggLSAyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBib2R5LFxuICAgICAgICAgICAgbGl0ZXJhbDogc3RyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhblJlZ0V4cEZsYWdzKCkge1xuICAgICAgICB2YXIgY2gsIHN0ciwgZmxhZ3MsIHJlc3RvcmU7XG5cbiAgICAgICAgc3RyID0gJyc7XG4gICAgICAgIGZsYWdzID0gJyc7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJyAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChzdHIgKz0gJ1xcXFx1JzsgcmVzdG9yZSA8IGluZGV4OyArK3Jlc3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gc291cmNlW3Jlc3RvcmVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gJ3UnO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2g7XG4gICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBmbGFncyxcbiAgICAgICAgICAgIGxpdGVyYWw6IHN0clxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5SZWdFeHAoKSB7XG4gICAgICAgIHZhciBzdGFydCwgYm9keSwgZmxhZ3MsIHZhbHVlO1xuICAgICAgICBzY2FubmluZyA9IHRydWU7XG5cbiAgICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgICAgc3RhcnQgPSBpbmRleDtcblxuICAgICAgICBib2R5ID0gc2NhblJlZ0V4cEJvZHkoKTtcbiAgICAgICAgZmxhZ3MgPSBzY2FuUmVnRXhwRmxhZ3MoKTtcbiAgICAgICAgdmFsdWUgPSB0ZXN0UmVnRXhwKGJvZHkudmFsdWUsIGZsYWdzLnZhbHVlKTtcbiAgICAgICAgc2Nhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlJlZ3VsYXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICByZWdleDoge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBib2R5LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBmbGFnczogZmxhZ3MudmFsdWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGl0ZXJhbDogYm9keS5saXRlcmFsICsgZmxhZ3MubGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICAgICAgcGF0dGVybjogYm9keS52YWx1ZSxcbiAgICAgICAgICAgICAgICBmbGFnczogZmxhZ3MudmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdFJlZ2V4KCkge1xuICAgICAgICB2YXIgcG9zLCBsb2MsIHJlZ2V4LCB0b2tlbjtcblxuICAgICAgICBza2lwQ29tbWVudCgpO1xuXG4gICAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2V4ID0gc2NhblJlZ0V4cCgpO1xuXG4gICAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICB9O1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmICghZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICAgIC8vIFBvcCB0aGUgcHJldmlvdXMgdG9rZW4sIHdoaWNoIGlzIGxpa2VseSAnLycgb3IgJy89J1xuICAgICAgICAgICAgaWYgKGV4dHJhLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEudG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5yYW5nZVswXSA9PT0gcG9zICYmIHRva2VuLnR5cGUgPT09ICdQdW5jdHVhdG9yJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICcvJyB8fCB0b2tlbi52YWx1ZSA9PT0gJy89Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHRyYS50b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1JlZ3VsYXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVnZXgubGl0ZXJhbCxcbiAgICAgICAgICAgICAgICByZWdleDogcmVnZXgucmVnZXgsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtwb3MsIGluZGV4XSxcbiAgICAgICAgICAgICAgICBsb2M6IGxvY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyTmFtZSh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllciB8fFxuICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCB8fFxuICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uQm9vbGVhbkxpdGVyYWwgfHxcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuLk51bGxMaXRlcmFsO1xuICAgIH1cblxuICAgIC8vIFVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG5cbiAgICBmdW5jdGlvbiBhZHZhbmNlU2xhc2goKSB7XG4gICAgICAgIHZhciByZWdleCwgcHJldmlvdXMsIGNoZWNrO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRlc3RLZXl3b3JkKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgJiYgKHZhbHVlLmxlbmd0aCA+IDEpICYmICh2YWx1ZVswXSA+PSAnYScpICYmICh2YWx1ZVswXSA8PSAneicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXMgPSBleHRyYS50b2tlblZhbHVlc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJlZ2V4ID0gKHByZXZpb3VzICE9PSBudWxsKTtcblxuICAgICAgICBzd2l0Y2ggKHByZXZpb3VzKSB7XG4gICAgICAgIGNhc2UgJ3RoaXMnOlxuICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAgIHJlZ2V4ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcpJzpcbiAgICAgICAgICAgIGNoZWNrID0gZXh0cmEudG9rZW5WYWx1ZXNbZXh0cmEub3BlblBhcmVuVG9rZW4gLSAxXTtcbiAgICAgICAgICAgIHJlZ2V4ID0gKGNoZWNrID09PSAnaWYnIHx8IGNoZWNrID09PSAnd2hpbGUnIHx8IGNoZWNrID09PSAnZm9yJyB8fCBjaGVjayA9PT0gJ3dpdGgnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgLy8gRGl2aWRpbmcgYSBmdW5jdGlvbiBieSBhbnl0aGluZyBtYWtlcyBsaXR0bGUgc2Vuc2UsXG4gICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSB0byBjaGVjayBmb3IgdGhhdC5cbiAgICAgICAgICAgIHJlZ2V4ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGVzdEtleXdvcmQoZXh0cmEudG9rZW5WYWx1ZXNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSAzXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb24sIGUuZy4gZnVuY3Rpb24oKXt9IC80MlxuICAgICAgICAgICAgICAgIGNoZWNrID0gZXh0cmEudG9rZW5WYWx1ZXNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA0XTtcbiAgICAgICAgICAgICAgICByZWdleCA9IGNoZWNrID8gKEZuRXhwclRva2Vucy5pbmRleE9mKGNoZWNrKSA8IDApIDogZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRlc3RLZXl3b3JkKGV4dHJhLnRva2VuVmFsdWVzW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gTmFtZWQgZnVuY3Rpb24sIGUuZy4gZnVuY3Rpb24gZigpe30gLzQyL1xuICAgICAgICAgICAgICAgIGNoZWNrID0gZXh0cmEudG9rZW5WYWx1ZXNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA1XTtcbiAgICAgICAgICAgICAgICByZWdleCA9IGNoZWNrID8gKEZuRXhwclRva2Vucy5pbmRleE9mKGNoZWNrKSA8IDApIDogdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleCA/IGNvbGxlY3RSZWdleCgpIDogc2NhblB1bmN0dWF0b3IoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZHZhbmNlKCkge1xuICAgICAgICB2YXIgY3AsIHRva2VuO1xuXG4gICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uRU9GLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGluZGV4LFxuICAgICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjcCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY3ApKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHNjYW5JZGVudGlmaWVyKCk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gVG9rZW4uS2V5d29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcnkgY29tbW9uOiAoIGFuZCApIGFuZCA7XG4gICAgICAgIGlmIChjcCA9PT0gMHgyOCB8fCBjcCA9PT0gMHgyOSB8fCBjcCA9PT0gMHgzQikge1xuICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdHJpbmcgbGl0ZXJhbCBzdGFydHMgd2l0aCBzaW5nbGUgcXVvdGUgKFUrMDAyNykgb3IgZG91YmxlIHF1b3RlIChVKzAwMjIpLlxuICAgICAgICBpZiAoY3AgPT09IDB4MjcgfHwgY3AgPT09IDB4MjIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuU3RyaW5nTGl0ZXJhbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG90ICguKSBVKzAwMkUgY2FuIGFsc28gc3RhcnQgYSBmbG9hdGluZy1wb2ludCBudW1iZXIsIGhlbmNlIHRoZSBuZWVkXG4gICAgICAgIC8vIHRvIGNoZWNrIHRoZSBuZXh0IGNoYXJhY3Rlci5cbiAgICAgICAgaWYgKGNwID09PSAweDJFKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChjcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsYXNoICgvKSBVKzAwMkYgY2FuIGFsc28gc3RhcnQgYSByZWdleC5cbiAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplICYmIGNwID09PSAweDJGKSB7XG4gICAgICAgICAgICByZXR1cm4gYWR2YW5jZVNsYXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZW1wbGF0ZSBsaXRlcmFscyBzdGFydCB3aXRoIGAgKFUrMDA2MCkgZm9yIHRlbXBsYXRlIGhlYWRcbiAgICAgICAgLy8gb3IgfSAoVSswMDdEKSBmb3IgdGVtcGxhdGUgbWlkZGxlIG9yIHRlbXBsYXRlIHRhaWwuXG4gICAgICAgIGlmIChjcCA9PT0gMHg2MCB8fCAoY3AgPT09IDB4N0QgJiYgc3RhdGUuY3VybHlTdGFja1tzdGF0ZS5jdXJseVN0YWNrLmxlbmd0aCAtIDFdID09PSAnJHsnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjYW5UZW1wbGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUG9zc2libGUgaWRlbnRpZmllciBzdGFydCBpbiBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgICBpZiAoY3AgPj0gMHhEODAwICYmIGNwIDwgMHhERkZGKSB7XG4gICAgICAgICAgICBjcCA9IGNvZGVQb2ludEF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhbklkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3RUb2tlbigpIHtcbiAgICAgICAgdmFyIGxvYywgdG9rZW4sIHZhbHVlLCBlbnRyeTtcblxuICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRva2VuID0gYWR2YW5jZSgpO1xuICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcbiAgICAgICAgICAgIGVudHJ5ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuTmFtZVt0b2tlbi50eXBlXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFt0b2tlbi5zdGFydCwgdG9rZW4uZW5kXSxcbiAgICAgICAgICAgICAgICBsb2M6IGxvY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5yZWdleCkge1xuICAgICAgICAgICAgICAgIGVudHJ5LnJlZ2V4ID0ge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiB0b2tlbi5yZWdleC5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICBmbGFnczogdG9rZW4ucmVnZXguZmxhZ3NcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dHJhLnRva2VuVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgZXh0cmEudG9rZW5WYWx1ZXMucHVzaCgoZW50cnkudHlwZSA9PT0gJ1B1bmN0dWF0b3InIHx8IGVudHJ5LnR5cGUgPT09ICdLZXl3b3JkJykgPyBlbnRyeS52YWx1ZSA6IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZW50cnkucmFuZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZXh0cmEubG9jKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnRyeS5sb2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHRyYS5kZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICBlbnRyeSA9IGV4dHJhLmRlbGVnYXRlKGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRyYS50b2tlbnMucHVzaChlbnRyeSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHNjYW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgbGFzdExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICBsYXN0TGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICBzdGFydExpbmVTdGFydCA9IGxpbmVTdGFydDtcblxuICAgICAgICBsb29rYWhlYWQgPSAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpID8gY29sbGVjdFRva2VuKCkgOiBhZHZhbmNlKCk7XG4gICAgICAgIHNjYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWVrKCkge1xuICAgICAgICBzY2FubmluZyA9IHRydWU7XG5cbiAgICAgICAgc2tpcENvbW1lbnQoKTtcblxuICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgbGFzdExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICBsYXN0TGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuXG4gICAgICAgIHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgc3RhcnRMaW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG5cbiAgICAgICAgbG9va2FoZWFkID0gKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSA/IGNvbGxlY3RUb2tlbigpIDogYWR2YW5jZSgpO1xuICAgICAgICBzY2FubmluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLmxpbmUgPSBzdGFydExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuY29sdW1uID0gc3RhcnRJbmRleCAtIHN0YXJ0TGluZVN0YXJ0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gbmV3IFBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuZW5kID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGluZ1NvdXJjZUxvY2F0aW9uKHN0YXJ0VG9rZW4pIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHtcbiAgICAgICAgICAgIGxpbmU6IHN0YXJ0VG9rZW4ubGluZU51bWJlcixcbiAgICAgICAgICAgIGNvbHVtbjogc3RhcnRUb2tlbi5zdGFydCAtIHN0YXJ0VG9rZW4ubGluZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5kID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBOb2RlKCkge1xuICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSBbc3RhcnRJbmRleCwgMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdyYXBwaW5nTm9kZShzdGFydFRva2VuKSB7XG4gICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5yYW5nZSA9IFtzdGFydFRva2VuLnN0YXJ0LCAwXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICB0aGlzLmxvYyA9IG5ldyBXcmFwcGluZ1NvdXJjZUxvY2F0aW9uKHN0YXJ0VG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgV3JhcHBpbmdOb2RlLnByb3RvdHlwZSA9IE5vZGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIHByb2Nlc3NDb21tZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGFzdENoaWxkLFxuICAgICAgICAgICAgICAgIGlubmVyQ29tbWVudHMsXG4gICAgICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMsXG4gICAgICAgICAgICAgICAgYm90dG9tUmlnaHQgPSBleHRyYS5ib3R0b21SaWdodFN0YWNrLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgY29tbWVudCxcbiAgICAgICAgICAgICAgICBsYXN0ID0gYm90dG9tUmlnaHRbYm90dG9tUmlnaHQubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFN5bnRheC5Qcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHBhdGNoIGlubm5lckNvbW1lbnRzIGZvciBwcm9wZXJ0aWVzIGVtcHR5IGJsb2NrXG4gICAgICAgICAgICAgKiBgZnVuY3Rpb24gYSgpIHsvKiogY29tbWVudHMgKipcXC99YFxuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCAmJiB0aGlzLmJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaW5uZXJDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGV4dHJhLmxlYWRpbmdDb21tZW50cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gZXh0cmEubGVhZGluZ0NvbW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yYW5nZVsxXSA+PSBjb21tZW50LnJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lckNvbW1lbnRzLnVuc2hpZnQoY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYS5sZWFkaW5nQ29tbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEudHJhaWxpbmdDb21tZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyQ29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJDb21tZW50cyA9IGlubmVyQ29tbWVudHM7XG4gICAgICAgICAgICAgICAgICAgIC8vYm90dG9tUmlnaHQucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4dHJhLnRyYWlsaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBleHRyYS50cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBleHRyYS50cmFpbGluZ0NvbW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5yYW5nZVswXSA+PSB0aGlzLnJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLnVuc2hpZnQoY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYS50cmFpbGluZ0NvbW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHRyYS50cmFpbGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3QudHJhaWxpbmdDb21tZW50cyAmJiBsYXN0LnRyYWlsaW5nQ29tbWVudHNbMF0ucmFuZ2VbMF0gPj0gdGhpcy5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzID0gbGFzdC50cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbGFzdC50cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRWF0aW5nIHRoZSBzdGFjay5cbiAgICAgICAgICAgIHdoaWxlIChsYXN0ICYmIGxhc3QucmFuZ2VbMF0gPj0gdGhpcy5yYW5nZVswXSkge1xuICAgICAgICAgICAgICAgIGxhc3RDaGlsZCA9IGJvdHRvbVJpZ2h0LnBvcCgpO1xuICAgICAgICAgICAgICAgIGxhc3QgPSBib3R0b21SaWdodFtib3R0b21SaWdodC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gbGFzdENoaWxkLmxlYWRpbmdDb21tZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LnJhbmdlWzFdIDw9IHRoaXMucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMudW5zaGlmdChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4dHJhLmxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gZXh0cmEubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBleHRyYS5sZWFkaW5nQ29tbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LnJhbmdlWzFdIDw9IHRoaXMucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cy51bnNoaWZ0KGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEubGVhZGluZ0NvbW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZiAobGVhZGluZ0NvbW1lbnRzICYmIGxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFkaW5nQ29tbWVudHMgPSBsZWFkaW5nQ29tbWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhaWxpbmdDb21tZW50cyAmJiB0cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWlsaW5nQ29tbWVudHMgPSB0cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib3R0b21SaWdodC5wdXNoKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZVsxXSA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYy5lbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGxhc3RMaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGxhc3RJbmRleCAtIGxhc3RMaW5lU3RhcnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChleHRyYS5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2Muc291cmNlID0gZXh0cmEuc291cmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4dHJhLmF0dGFjaENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NDb21tZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQXJyYXlFeHByZXNzaW9uOiBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5BcnJheUV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQXJyYXlQYXR0ZXJuOiBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5BcnJheVBhdHRlcm47XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uIChwYXJhbXMsIGRlZmF1bHRzLCBib2R5LCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmlkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEFzc2lnbm1lbnRQYXR0ZXJuOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQmluYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gKG9wZXJhdG9yID09PSAnfHwnIHx8IG9wZXJhdG9yID09PSAnJiYnKSA/IFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbiA6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hCbG9ja1N0YXRlbWVudDogZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5CbG9ja1N0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQnJlYWtTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkJyZWFrU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENhbGxFeHByZXNzaW9uOiBmdW5jdGlvbiAoY2FsbGVlLCBhcmdzKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQ2FsbEV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzID0gYXJncztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hDYXRjaENsYXVzZTogZnVuY3Rpb24gKHBhcmFtLCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQ2F0Y2hDbGF1c2U7XG4gICAgICAgICAgICB0aGlzLnBhcmFtID0gcGFyYW07XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENsYXNzQm9keTogZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5DbGFzc0JvZHk7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uIChpZCwgc3VwZXJDbGFzcywgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNsYXNzRGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLnN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hDbGFzc0V4cHJlc3Npb246IGZ1bmN0aW9uIChpZCwgc3VwZXJDbGFzcywgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNsYXNzRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMuc3VwZXJDbGFzcyA9IHN1cGVyQ2xhc3M7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbjogZnVuY3Rpb24gKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xuICAgICAgICAgICAgdGhpcy5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQ29udGludWVTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNvbnRpbnVlU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaERlYnVnZ2VyU3RhdGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRGVidWdnZXJTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRG9XaGlsZVN0YXRlbWVudDogZnVuY3Rpb24gKGJvZHksIHRlc3QpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Eb1doaWxlU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRW1wdHlTdGF0ZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FbXB0eVN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hFeHByZXNzaW9uU3RhdGVtZW50OiBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEZvclN0YXRlbWVudDogZnVuY3Rpb24gKGluaXQsIHRlc3QsIHVwZGF0ZSwgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkZvclN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy51cGRhdGUgPSB1cGRhdGU7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEZvck9mU3RhdGVtZW50OiBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Gb3JPZlN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEZvckluU3RhdGVtZW50OiBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Gb3JJblN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5lYWNoID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb24gKGlkLCBwYXJhbXMsIGRlZmF1bHRzLCBib2R5LCBnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uIChpZCwgcGFyYW1zLCBkZWZhdWx0cywgYm9keSwgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hJZGVudGlmaWVyOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LklkZW50aWZpZXI7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaElmU3RhdGVtZW50OiBmdW5jdGlvbiAodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguSWZTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaExhYmVsZWRTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsYWJlbCwgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkxhYmVsZWRTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaExpdGVyYWw6IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkxpdGVyYWw7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJhdyA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5yZWdleCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVnZXggPSB0b2tlbi5yZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hNZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbiAoYWNjZXNzb3IsIG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlZCA9IGFjY2Vzc29yID09PSAnWyc7XG4gICAgICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hNZXRhUHJvcGVydHk6IGZ1bmN0aW9uIChtZXRhLCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4Lk1ldGFQcm9wZXJ0eTtcbiAgICAgICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoTmV3RXhwcmVzc2lvbjogZnVuY3Rpb24gKGNhbGxlZSwgYXJncykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4Lk5ld0V4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzID0gYXJncztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hPYmplY3RFeHByZXNzaW9uOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4Lk9iamVjdEV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaE9iamVjdFBhdHRlcm46IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguT2JqZWN0UGF0dGVybjtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoUG9zdGZpeEV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5VcGRhdGVFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgICAgdGhpcy5wcmVmaXggPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hQcm9ncmFtOiBmdW5jdGlvbiAoYm9keSwgc291cmNlVHlwZSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlByb2dyYW07XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VUeXBlID0gc291cmNlVHlwZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hQcm9wZXJ0eTogZnVuY3Rpb24gKGtpbmQsIGtleSwgY29tcHV0ZWQsIHZhbHVlLCBtZXRob2QsIHNob3J0aGFuZCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlByb3BlcnR5O1xuICAgICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgICAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgICAgICB0aGlzLnNob3J0aGFuZCA9IHNob3J0aGFuZDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hSZXN0RWxlbWVudDogZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguUmVzdEVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoUmV0dXJuU3RhdGVtZW50OiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoU2VxdWVuY2VFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoU3ByZWFkRWxlbWVudDogZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguU3ByZWFkRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hTd2l0Y2hDYXNlOiBmdW5jdGlvbiAodGVzdCwgY29uc2VxdWVudCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlN3aXRjaENhc2U7XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hTdXBlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlN1cGVyO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFN3aXRjaFN0YXRlbWVudDogZnVuY3Rpb24gKGRpc2NyaW1pbmFudCwgY2FzZXMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Td2l0Y2hTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmRpc2NyaW1pbmFudCA9IGRpc2NyaW1pbmFudDtcbiAgICAgICAgICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uICh0YWcsIHF1YXNpKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgICAgICB0aGlzLnF1YXNpID0gcXVhc2k7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoVGVtcGxhdGVFbGVtZW50OiBmdW5jdGlvbiAodmFsdWUsIHRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5UZW1wbGF0ZUVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFRlbXBsYXRlTGl0ZXJhbDogZnVuY3Rpb24gKHF1YXNpcywgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5UZW1wbGF0ZUxpdGVyYWw7XG4gICAgICAgICAgICB0aGlzLnF1YXNpcyA9IHF1YXNpcztcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hUaGlzRXhwcmVzc2lvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlRoaXNFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFRocm93U3RhdGVtZW50OiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5UaHJvd1N0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hUcnlTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChibG9jaywgaGFuZGxlciwgZmluYWxpemVyKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVHJ5U3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5ibG9jayA9IGJsb2NrO1xuICAgICAgICAgICAgdGhpcy5ndWFyZGVkSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVyID8gW2hhbmRsZXJdIDogW107XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICAgICAgdGhpcy5maW5hbGl6ZXIgPSBmaW5hbGl6ZXI7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoVW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGFyZ3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAob3BlcmF0b3IgPT09ICcrKycgfHwgb3BlcmF0b3IgPT09ICctLScpID8gU3ludGF4LlVwZGF0ZUV4cHJlc3Npb24gOiBTeW50YXguVW5hcnlFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgICAgdGhpcy5wcmVmaXggPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFZhcmlhYmxlRGVjbGFyYXRpb246IGZ1bmN0aW9uIChkZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvbnMgPSBkZWNsYXJhdGlvbnM7XG4gICAgICAgICAgICB0aGlzLmtpbmQgPSAndmFyJztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hMZXhpY2FsRGVjbGFyYXRpb246IGZ1bmN0aW9uIChkZWNsYXJhdGlvbnMsIGtpbmQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvbnMgPSBkZWNsYXJhdGlvbnM7XG4gICAgICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFZhcmlhYmxlRGVjbGFyYXRvcjogZnVuY3Rpb24gKGlkLCBpbml0KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5pbml0ID0gaW5pdDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hXaGlsZVN0YXRlbWVudDogZnVuY3Rpb24gKHRlc3QsIGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5XaGlsZVN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFdpdGhTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChvYmplY3QsIGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5XaXRoU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEV4cG9ydFNwZWNpZmllcjogZnVuY3Rpb24gKGxvY2FsLCBleHBvcnRlZCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkV4cG9ydFNwZWNpZmllcjtcbiAgICAgICAgICAgIHRoaXMuZXhwb3J0ZWQgPSBleHBvcnRlZCB8fCBsb2NhbDtcbiAgICAgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiBmdW5jdGlvbiAobG9jYWwpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5JbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xuICAgICAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjogZnVuY3Rpb24gKGxvY2FsKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xuICAgICAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEV4cG9ydE5hbWVkRGVjbGFyYXRpb246IGZ1bmN0aW9uIChkZWNsYXJhdGlvbiwgc3BlY2lmaWVycywgc3JjKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuc3BlY2lmaWVycyA9IHNwZWNpZmllcnM7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZSA9IHNyYztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hFeHBvcnREZWZhdWx0RGVjbGFyYXRpb246IGZ1bmN0aW9uIChkZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hFeHBvcnRBbGxEZWNsYXJhdGlvbjogZnVuY3Rpb24gKHNyYykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkV4cG9ydEFsbERlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBzcmM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoSW1wb3J0U3BlY2lmaWVyOiBmdW5jdGlvbiAobG9jYWwsIGltcG9ydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguSW1wb3J0U3BlY2lmaWVyO1xuICAgICAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsIHx8IGltcG9ydGVkO1xuICAgICAgICAgICAgdGhpcy5pbXBvcnRlZCA9IGltcG9ydGVkO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEltcG9ydERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoc3BlY2lmaWVycywgc3JjKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguSW1wb3J0RGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLnNwZWNpZmllcnMgPSBzcGVjaWZpZXJzO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBzcmM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoWWllbGRFeHByZXNzaW9uOiBmdW5jdGlvbiAoYXJndW1lbnQsIGRlbGVnYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguWWllbGRFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgZnVuY3Rpb24gcmVjb3JkRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdmFyIGUsIGV4aXN0aW5nO1xuXG4gICAgICAgIGZvciAoZSA9IDA7IGUgPCBleHRyYS5lcnJvcnMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICAgIGV4aXN0aW5nID0gZXh0cmEuZXJyb3JzW2VdO1xuICAgICAgICAgICAgLy8gUHJldmVudCBkdXBsaWNhdGVkIGVycm9yLlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmIChleGlzdGluZy5pbmRleCA9PT0gZXJyb3IuaW5kZXggJiYgZXhpc3RpbmcubWVzc2FnZSA9PT0gZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dHJhLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25zdHJ1Y3RFcnJvcihtc2csIGNvbHVtbikge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9IGNhdGNoIChiYXNlKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKE9iamVjdC5jcmVhdGUgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBPYmplY3QuY3JlYXRlKGJhc2UpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgJ2NvbHVtbicsIHsgdmFsdWU6IGNvbHVtbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVycm9yKGxpbmUsIHBvcywgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIG1zZywgY29sdW1uLCBlcnJvcjtcblxuICAgICAgICBtc2cgPSAnTGluZSAnICsgbGluZSArICc6ICcgKyBkZXNjcmlwdGlvbjtcbiAgICAgICAgY29sdW1uID0gcG9zIC0gKHNjYW5uaW5nID8gbGluZVN0YXJ0IDogbGFzdExpbmVTdGFydCkgKyAxO1xuICAgICAgICBlcnJvciA9IGNvbnN0cnVjdEVycm9yKG1zZywgY29sdW1uKTtcbiAgICAgICAgZXJyb3IubGluZU51bWJlciA9IGxpbmU7XG4gICAgICAgIGVycm9yLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIGVycm9yLmluZGV4ID0gcG9zO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uXG5cbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yKG1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIG1zZztcblxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKC8lKFxcZCkvZyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICh3aG9sZSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGlkeCA8IGFyZ3MubGVuZ3RoLCAnTWVzc2FnZSByZWZlcmVuY2UgbXVzdCBiZSBpbiByYW5nZScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IobGFzdExpbmVOdW1iZXIsIGxhc3RJbmRleCwgbXNnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2xlcmF0ZUVycm9yKG1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIG1zZywgZXJyb3I7XG5cbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZSgvJShcXGQpL2csXG4gICAgICAgICAgICBmdW5jdGlvbiAod2hvbGUsIGlkeCkge1xuICAgICAgICAgICAgICAgIGFzc2VydChpZHggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1tpZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGVycm9yID0gY3JlYXRlRXJyb3IobGluZU51bWJlciwgbGFzdEluZGV4LCBtc2cpO1xuICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICByZWNvcmRFcnJvcihlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIG9mIHRoZSB0b2tlbi5cblxuICAgIGZ1bmN0aW9uIHVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciB2YWx1ZSwgbXNnID0gbWVzc2FnZSB8fCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW47XG5cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBtc2cgPSAodG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GKSA/IE1lc3NhZ2VzLlVuZXhwZWN0ZWRFT1MgOlxuICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikgPyBNZXNzYWdlcy5VbmV4cGVjdGVkSWRlbnRpZmllciA6XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkgPyBNZXNzYWdlcy5VbmV4cGVjdGVkTnVtYmVyIDpcbiAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwpID8gTWVzc2FnZXMuVW5leHBlY3RlZFN0cmluZyA6XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSBUb2tlbi5UZW1wbGF0ZSkgPyBNZXNzYWdlcy5VbmV4cGVjdGVkVGVtcGxhdGUgOlxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW47XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdXR1cmVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBNZXNzYWdlcy5VbmV4cGVjdGVkUmVzZXJ2ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSAodG9rZW4udHlwZSA9PT0gVG9rZW4uVGVtcGxhdGUpID8gdG9rZW4udmFsdWUucmF3IDogdG9rZW4udmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICdJTExFR0FMJztcbiAgICAgICAgfVxuXG4gICAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKCclMCcsIHZhbHVlKTtcblxuICAgICAgICByZXR1cm4gKHRva2VuICYmIHR5cGVvZiB0b2tlbi5saW5lTnVtYmVyID09PSAnbnVtYmVyJykgP1xuICAgICAgICAgICAgY3JlYXRlRXJyb3IodG9rZW4ubGluZU51bWJlciwgdG9rZW4uc3RhcnQsIG1zZykgOlxuICAgICAgICAgICAgY3JlYXRlRXJyb3Ioc2Nhbm5pbmcgPyBsaW5lTnVtYmVyIDogbGFzdExpbmVOdW1iZXIsIHNjYW5uaW5nID8gaW5kZXggOiBsYXN0SW5kZXgsIG1zZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgdW5leHBlY3RlZFRva2VuRXJyb3IodG9rZW4sIG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKTtcbiAgICAgICAgaWYgKGV4dHJhLmVycm9ycykge1xuICAgICAgICAgICAgcmVjb3JkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuICAgIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuXG4gICAgZnVuY3Rpb24gZXhwZWN0KHZhbHVlKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGV4cGVjdENvbW1hU2VwYXJhdG9yXG4gICAgICogQGRlc2NyaXB0aW9uIFF1aWV0bHkgZXhwZWN0IGEgY29tbWEgd2hlbiBpbiB0b2xlcmFudCBtb2RlLCBvdGhlcndpc2UgZGVsZWdhdGVzXG4gICAgICogdG8gPGNvZGU+ZXhwZWN0KHZhbHVlKTwvY29kZT5cbiAgICAgKiBAc2luY2UgMi4wXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXhwZWN0Q29tbWFTZXBhcmF0b3IoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcblxuICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnZhbHVlID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvciAmJiB0b2tlbi52YWx1ZSA9PT0gJzsnKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQga2V5d29yZC5cbiAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICAgIGZ1bmN0aW9uIGV4cGVjdEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQgfHwgdG9rZW4udmFsdWUgIT09IGtleXdvcmQpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuXG4gICAgZnVuY3Rpb24gbWF0Y2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleXdvcmRcblxuICAgIGZ1bmN0aW9uIG1hdGNoS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCAmJiBsb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGNvbnRleHR1YWwga2V5d29yZFxuICAgIC8vICh3aGVyZSBhbiBpZGVudGlmaWVyIGlzIHNvbWV0aW1lcyBhIGtleXdvcmQgZGVwZW5kaW5nIG9uIHRoZSBjb250ZXh0KVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hDb250ZXh0dWFsS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllciAmJiBsb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gaXMgYW4gYXNzaWdubWVudCBvcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gbWF0Y2hBc3NpZ24oKSB7XG4gICAgICAgIHZhciBvcDtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvcCA9IGxvb2thaGVhZC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG9wID09PSAnPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnKj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJy89JyB8fFxuICAgICAgICAgICAgb3AgPT09ICclPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnKz0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJy09JyB8fFxuICAgICAgICAgICAgb3AgPT09ICc8PD0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJz4+PScgfHxcbiAgICAgICAgICAgIG9wID09PSAnPj4+PScgfHxcbiAgICAgICAgICAgIG9wID09PSAnJj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJ149JyB8fFxuICAgICAgICAgICAgb3AgPT09ICd8PSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uc3VtZVNlbWljb2xvbigpIHtcbiAgICAgICAgLy8gQ2F0Y2ggdGhlIHZlcnkgY29tbW9uIGNhc2UgZmlyc3Q6IGltbWVkaWF0ZWx5IGEgc2VtaWNvbG9uIChVKzAwM0IpLlxuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoc3RhcnRJbmRleCkgPT09IDB4M0IgfHwgbWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTGluZVRlcm1pbmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZJWE1FKGlrYXJpZW5hdG9yKTogdGhpcyBpcyBzZWVtaW5nbHkgYW4gaXNzdWUgaW4gdGhlIHByZXZpb3VzIGxvY2F0aW9uIGluZm8gY29udmVudGlvbi5cbiAgICAgICAgbGFzdEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgbGFzdExpbmVOdW1iZXIgPSBzdGFydExpbmVOdW1iZXI7XG4gICAgICAgIGxhc3RMaW5lU3RhcnQgPSBzdGFydExpbmVTdGFydDtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRiAmJiAhbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvdmVyIGdyYW1tYXIgc3VwcG9ydC5cbiAgICAvL1xuICAgIC8vIFdoZW4gYW4gYXNzaWdubWVudCBleHByZXNzaW9uIHBvc2l0aW9uIHN0YXJ0cyB3aXRoIGFuIGxlZnQgcGFyZW50aGVzaXMsIHRoZSBkZXRlcm1pbmF0aW9uIG9mIHRoZSB0eXBlXG4gICAgLy8gb2YgdGhlIHN5bnRheCBpcyB0byBiZSBkZWZlcnJlZCBhcmJpdHJhcmlseSBsb25nIHVudGlsIHRoZSBlbmQgb2YgdGhlIHBhcmVudGhlc2VzIHBhaXIgKHBsdXMgYSBsb29rYWhlYWQpXG4gICAgLy8gb3IgdGhlIGZpcnN0IGNvbW1hLiBUaGlzIHNpdHVhdGlvbiBhbHNvIGRlZmVycyB0aGUgZGV0ZXJtaW5hdGlvbiBvZiBhbGwgdGhlIGV4cHJlc3Npb25zIG5lc3RlZCBpbiB0aGUgcGFpci5cbiAgICAvL1xuICAgIC8vIFRoZXJlIGFyZSB0aHJlZSBwcm9kdWN0aW9ucyB0aGF0IGNhbiBiZSBwYXJzZWQgaW4gYSBwYXJlbnRoZXNlcyBwYWlyIHRoYXQgbmVlZHMgdG8gYmUgZGV0ZXJtaW5lZFxuICAgIC8vIGFmdGVyIHRoZSBvdXRlcm1vc3QgcGFpciBpcyBjbG9zZWQuIFRoZXkgYXJlOlxuICAgIC8vXG4gICAgLy8gICAxLiBBc3NpZ25tZW50RXhwcmVzc2lvblxuICAgIC8vICAgMi4gQmluZGluZ0VsZW1lbnRzXG4gICAgLy8gICAzLiBBc3NpZ25tZW50VGFyZ2V0c1xuICAgIC8vXG4gICAgLy8gSW4gb3JkZXIgdG8gYXZvaWQgZXhwb25lbnRpYWwgYmFja3RyYWNraW5nLCB3ZSB1c2UgdHdvIGZsYWdzIHRvIGRlbm90ZSBpZiB0aGUgcHJvZHVjdGlvbiBjYW4gYmVcbiAgICAvLyBiaW5kaW5nIGVsZW1lbnQgb3IgYXNzaWdubWVudCB0YXJnZXQuXG4gICAgLy9cbiAgICAvLyBUaGUgdGhyZWUgcHJvZHVjdGlvbnMgaGF2ZSB0aGUgcmVsYXRpb25zaGlwOlxuICAgIC8vXG4gICAgLy8gICBCaW5kaW5nRWxlbWVudHMg4oqGIEFzc2lnbm1lbnRUYXJnZXRzIOKKhiBBc3NpZ25tZW50RXhwcmVzc2lvblxuICAgIC8vXG4gICAgLy8gd2l0aCBhIHNpbmdsZSBleGNlcHRpb24gdGhhdCBDb3ZlckluaXRpYWxpemVkTmFtZSB3aGVuIHVzZWQgZGlyZWN0bHkgaW4gYW4gRXhwcmVzc2lvbiwgZ2VuZXJhdGVzXG4gICAgLy8gYW4gZWFybHkgZXJyb3IuIFRoZXJlZm9yZSwgd2UgbmVlZCB0aGUgdGhpcmQgc3RhdGUsIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciwgdG8gdHJhY2sgdGhlXG4gICAgLy8gZmlyc3QgdXNhZ2Ugb2YgQ292ZXJJbml0aWFsaXplZE5hbWUgYW5kIHJlcG9ydCBpdCB3aGVuIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcGFyZW50aGVzZXMgcGFpci5cbiAgICAvL1xuICAgIC8vIGlzb2xhdGVDb3ZlckdyYW1tYXIgZnVuY3Rpb24gcnVucyB0aGUgZ2l2ZW4gcGFyc2VyIGZ1bmN0aW9uIHdpdGggYSBuZXcgY292ZXIgZ3JhbW1hciBjb250ZXh0LCBhbmQgaXQgZG9lcyBub3RcbiAgICAvLyBlZmZlY3QgdGhlIGN1cnJlbnQgZmxhZ3MuIFRoaXMgbWVhbnMgdGhlIHByb2R1Y3Rpb24gdGhlIHBhcnNlciBwYXJzZXMgaXMgb25seSB1c2VkIGFzIGFuIGV4cHJlc3Npb24uIFRoZXJlZm9yZVxuICAgIC8vIHRoZSBDb3ZlckluaXRpYWxpemVkTmFtZSBjaGVjayBpcyBjb25kdWN0ZWQuXG4gICAgLy9cbiAgICAvLyBpbmhlcml0Q292ZXJHcmFtbWFyIGZ1bmN0aW9uIHJ1bnMgdGhlIGdpdmVuIHBhcnNlIGZ1bmN0aW9uIHdpdGggYSBuZXcgY292ZXIgZ3JhbW1hciBjb250ZXh0LCBhbmQgaXQgcHJvcGFnYXRlc1xuICAgIC8vIHRoZSBmbGFncyBvdXRzaWRlIG9mIHRoZSBwYXJzZXIuIFRoaXMgbWVhbnMgdGhlIHByb2R1Y3Rpb24gdGhlIHBhcnNlciBwYXJzZXMgaXMgdXNlZCBhcyBhIHBhcnQgb2YgYSBwb3RlbnRpYWxcbiAgICAvLyBwYXR0ZXJuLiBUaGUgQ292ZXJJbml0aWFsaXplZE5hbWUgY2hlY2sgaXMgZGVmZXJyZWQuXG4gICAgZnVuY3Rpb24gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZXIpIHtcbiAgICAgICAgdmFyIG9sZElzQmluZGluZ0VsZW1lbnQgPSBpc0JpbmRpbmdFbGVtZW50LFxuICAgICAgICAgICAgb2xkSXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNBc3NpZ25tZW50VGFyZ2V0LFxuICAgICAgICAgICAgb2xkRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yLFxuICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcbiAgICAgICAgcmVzdWx0ID0gcGFyc2VyKCk7XG4gICAgICAgIGlmIChmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IG9sZElzQmluZGluZ0VsZW1lbnQ7XG4gICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IG9sZElzQXNzaWdubWVudFRhcmdldDtcbiAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gb2xkRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VyKSB7XG4gICAgICAgIHZhciBvbGRJc0JpbmRpbmdFbGVtZW50ID0gaXNCaW5kaW5nRWxlbWVudCxcbiAgICAgICAgICAgIG9sZElzQXNzaWdubWVudFRhcmdldCA9IGlzQXNzaWdubWVudFRhcmdldCxcbiAgICAgICAgICAgIG9sZEZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcixcbiAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XG4gICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XG4gICAgICAgIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XG4gICAgICAgIHJlc3VsdCA9IHBhcnNlcigpO1xuICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gaXNCaW5kaW5nRWxlbWVudCAmJiBvbGRJc0JpbmRpbmdFbGVtZW50O1xuICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0Fzc2lnbm1lbnRUYXJnZXQgJiYgb2xkSXNBc3NpZ25tZW50VGFyZ2V0O1xuICAgICAgICBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBvbGRGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgfHwgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEzLjMuMyBEZXN0cnVjdHVyaW5nIEJpbmRpbmcgUGF0dGVybnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlQXJyYXlQYXR0ZXJuKHBhcmFtcywga2luZCkge1xuICAgICAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKCksIGVsZW1lbnRzID0gW10sIHJlc3QsIHJlc3ROb2RlO1xuICAgICAgICBleHBlY3QoJ1snKTtcblxuICAgICAgICB3aGlsZSAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcuLi4nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN0Tm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChsb29rYWhlYWQpO1xuICAgICAgICAgICAgICAgICAgICByZXN0ID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoa2luZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gocmVzdE5vZGUuZmluaXNoUmVzdEVsZW1lbnQocmVzdCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcywga2luZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ10nKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hBcnJheVBhdHRlcm4oZWxlbWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJvcGVydHlQYXR0ZXJuKHBhcmFtcywga2luZCkge1xuICAgICAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKCksIGtleSwga2V5VG9rZW4sIGNvbXB1dGVkID0gbWF0Y2goJ1snKSwgaW5pdDtcbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBrZXlUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIGtleSA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICBpZiAobWF0Y2goJz0nKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGtleVRva2VuKTtcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICBpbml0ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICdpbml0Jywga2V5LCBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFdyYXBwaW5nTm9kZShrZXlUb2tlbikuZmluaXNoQXNzaWdubWVudFBhdHRlcm4oa2V5LCBpbml0KSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1hdGNoKCc6JykpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChrZXlUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIGZhbHNlLCBrZXksIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgaW5pdCA9IHBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcywga2luZCk7XG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0Jywga2V5LCBjb21wdXRlZCwgaW5pdCwgZmFsc2UsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9iamVjdFBhdHRlcm4ocGFyYW1zLCBraW5kKSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IE5vZGUoKSwgcHJvcGVydGllcyA9IFtdO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICAgIHdoaWxlICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHBhcnNlUHJvcGVydHlQYXR0ZXJuKHBhcmFtcywga2luZCkpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXgoKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hPYmplY3RQYXR0ZXJuKHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUGF0dGVybihwYXJhbXMsIGtpbmQpIHtcbiAgICAgICAgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUFycmF5UGF0dGVybihwYXJhbXMsIGtpbmQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdFBhdHRlcm4ocGFyYW1zLCBraW5kKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaEtleXdvcmQoJ2xldCcpKSB7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gJ2NvbnN0JyB8fCBraW5kID09PSAnbGV0Jykge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtcy5wdXNoKGxvb2thaGVhZCk7XG4gICAgICAgIHJldHVybiBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcihraW5kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBhdHRlcm5XaXRoRGVmYXVsdChwYXJhbXMsIGtpbmQpIHtcbiAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQsIHBhdHRlcm4sIHByZXZpb3VzQWxsb3dZaWVsZCwgcmlnaHQ7XG4gICAgICAgIHBhdHRlcm4gPSBwYXJzZVBhdHRlcm4ocGFyYW1zLCBraW5kKTtcbiAgICAgICAgaWYgKG1hdGNoKCc9JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgcHJldmlvdXNBbGxvd1lpZWxkID0gc3RhdGUuYWxsb3dZaWVsZDtcbiAgICAgICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSB0cnVlO1xuICAgICAgICAgICAgcmlnaHQgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaEFzc2lnbm1lbnRQYXR0ZXJuKHBhdHRlcm4sIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMi4yLjUgQXJyYXkgSW5pdGlhbGl6ZXJcblxuICAgIGZ1bmN0aW9uIHBhcnNlQXJyYXlJbml0aWFsaXplcigpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW10sIG5vZGUgPSBuZXcgTm9kZSgpLCByZXN0U3ByZWFkO1xuXG4gICAgICAgIGV4cGVjdCgnWycpO1xuXG4gICAgICAgIHdoaWxlICghbWF0Y2goJ10nKSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnLi4uJykpIHtcbiAgICAgICAgICAgICAgICByZXN0U3ByZWFkID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICByZXN0U3ByZWFkLmZpbmlzaFNwcmVhZEVsZW1lbnQoaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChyZXN0U3ByZWFkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChpbmhlcml0Q292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcblxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2goJ10nKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXgoKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hBcnJheUV4cHJlc3Npb24oZWxlbWVudHMpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEyLjIuNiBPYmplY3QgSW5pdGlhbGl6ZXJcblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJvcGVydHlGdW5jdGlvbihub2RlLCBwYXJhbUluZm8sIGlzR2VuZXJhdG9yKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1N0cmljdCwgYm9keTtcblxuICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG5cbiAgICAgICAgcHJldmlvdXNTdHJpY3QgPSBzdHJpY3Q7XG4gICAgICAgIGJvZHkgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cyk7XG5cbiAgICAgICAgaWYgKHN0cmljdCAmJiBwYXJhbUluZm8uZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihwYXJhbUluZm8uZmlyc3RSZXN0cmljdGVkLCBwYXJhbUluZm8ubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmljdCAmJiBwYXJhbUluZm8uc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHBhcmFtSW5mby5zdHJpY3RlZCwgcGFyYW1JbmZvLm1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBwYXJhbUluZm8ucGFyYW1zLCBwYXJhbUluZm8uZGVmYXVsdHMsIGJvZHksIGlzR2VuZXJhdG9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbXMsIG1ldGhvZCwgbm9kZSA9IG5ldyBOb2RlKCksXG4gICAgICAgICAgICBwcmV2aW91c0FsbG93WWllbGQgPSBzdGF0ZS5hbGxvd1lpZWxkO1xuXG4gICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSBmYWxzZTtcbiAgICAgICAgcGFyYW1zID0gcGFyc2VQYXJhbXMoKTtcbiAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gZmFsc2U7XG4gICAgICAgIG1ldGhvZCA9IHBhcnNlUHJvcGVydHlGdW5jdGlvbihub2RlLCBwYXJhbXMsIGZhbHNlKTtcbiAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICByZXR1cm4gbWV0aG9kO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKSB7XG4gICAgICAgIHZhciB0b2tlbiwgbm9kZSA9IG5ldyBOb2RlKCksIGV4cHI7XG5cbiAgICAgICAgdG9rZW4gPSBsZXgoKTtcblxuICAgICAgICAvLyBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IGZyb20gcGFyc2VPYmplY3RQcm9wZXJ0eSgpLCB3aGVyZVxuICAgICAgICAvLyBFT0YgYW5kIFB1bmN0dWF0b3IgdG9rZW5zIGFyZSBhbHJlYWR5IGZpbHRlcmVkIG91dC5cblxuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSBUb2tlbi5TdHJpbmdMaXRlcmFsOlxuICAgICAgICBjYXNlIFRva2VuLk51bWVyaWNMaXRlcmFsOlxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiB0b2tlbi5vY3RhbCkge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICAgIGNhc2UgVG9rZW4uSWRlbnRpZmllcjpcbiAgICAgICAgY2FzZSBUb2tlbi5Cb29sZWFuTGl0ZXJhbDpcbiAgICAgICAgY2FzZSBUb2tlbi5OdWxsTGl0ZXJhbDpcbiAgICAgICAgY2FzZSBUb2tlbi5LZXl3b3JkOlxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSWRlbnRpZmllcih0b2tlbi52YWx1ZSk7XG4gICAgICAgIGNhc2UgVG9rZW4uUHVuY3R1YXRvcjpcbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgZXhwciA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCddJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9va2FoZWFkUHJvcGVydHlOYW1lKCkge1xuICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC50eXBlKSB7XG4gICAgICAgIGNhc2UgVG9rZW4uSWRlbnRpZmllcjpcbiAgICAgICAgY2FzZSBUb2tlbi5TdHJpbmdMaXRlcmFsOlxuICAgICAgICBjYXNlIFRva2VuLkJvb2xlYW5MaXRlcmFsOlxuICAgICAgICBjYXNlIFRva2VuLk51bGxMaXRlcmFsOlxuICAgICAgICBjYXNlIFRva2VuLk51bWVyaWNMaXRlcmFsOlxuICAgICAgICBjYXNlIFRva2VuLktleXdvcmQ6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSBUb2tlbi5QdW5jdHVhdG9yOlxuICAgICAgICAgICAgcmV0dXJuIGxvb2thaGVhZC52YWx1ZSA9PT0gJ1snO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHRvIHRyeSB0byBwYXJzZSBhIE1ldGhvZERlZmluaXRpb24gYXMgZGVmaW5lZCBpbiAxNC4zLiBCdXQgaW4gdGhlIGNhc2Ugb2Ygb2JqZWN0IGxpdGVyYWxzLFxuICAgIC8vIGl0IG1pZ2h0IGJlIGNhbGxlZCBhdCBhIHBvc2l0aW9uIHdoZXJlIHRoZXJlIGlzIGluIGZhY3QgYSBzaG9ydCBoYW5kIGlkZW50aWZpZXIgcGF0dGVybiBvciBhIGRhdGEgcHJvcGVydHkuXG4gICAgLy8gVGhpcyBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGFmdGVyIHdlIGNvbnN1bWVkIHVwIHRvIHRoZSBsZWZ0IHBhcmVudGhlc2VzLlxuICAgIC8vXG4gICAgLy8gSW4gb3JkZXIgdG8gYXZvaWQgYmFjayB0cmFja2luZywgaXQgcmV0dXJucyBgbnVsbGAgaWYgdGhlIHBvc2l0aW9uIGlzIG5vdCBhIE1ldGhvZERlZmluaXRpb24gYW5kIHRoZSBjYWxsZXJcbiAgICAvLyBpcyByZXNwb25zaWJsZSB0byB2aXNpdCBvdGhlciBvcHRpb25zLlxuICAgIGZ1bmN0aW9uIHRyeVBhcnNlTWV0aG9kRGVmaW5pdGlvbih0b2tlbiwga2V5LCBjb21wdXRlZCwgbm9kZSkge1xuICAgICAgICB2YXIgdmFsdWUsIG9wdGlvbnMsIG1ldGhvZE5vZGUsIHBhcmFtcyxcbiAgICAgICAgICAgIHByZXZpb3VzQWxsb3dZaWVsZCA9IHN0YXRlLmFsbG93WWllbGQ7XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBgZ2V0YCBhbmQgYHNldGA7XG5cbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ2dldCcgJiYgbG9va2FoZWFkUHJvcGVydHlOYW1lKCkpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlZCA9IG1hdGNoKCdbJyk7XG4gICAgICAgICAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICAgICAgICAgIG1ldGhvZE5vZGUgPSBuZXcgTm9kZSgpO1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnKCcpO1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKG1ldGhvZE5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzdHJpY3RlZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBudWxsXG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnZ2V0Jywga2V5LCBjb21wdXRlZCwgdmFsdWUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnc2V0JyAmJiBsb29rYWhlYWRQcm9wZXJ0eU5hbWUoKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gbWF0Y2goJ1snKTtcbiAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgICAgICAgbWV0aG9kTm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Q291bnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbVNldDoge31cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVBhcmFtKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlUHJvcGVydHlGdW5jdGlvbihtZXRob2ROb2RlLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdzZXQnLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnZhbHVlID09PSAnKicgJiYgbG9va2FoZWFkUHJvcGVydHlOYW1lKCkpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkID0gbWF0Y2goJ1snKTtcbiAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgIG1ldGhvZE5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcnNlUGFyYW1zKCk7XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuXG4gICAgICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gZmFsc2U7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlUHJvcGVydHlGdW5jdGlvbihtZXRob2ROb2RlLCBwYXJhbXMsIHRydWUpO1xuICAgICAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSAmJiBtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlUHJvcGVydHlNZXRob2RGdW5jdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90IGEgTWV0aG9kRGVmaW5pdGlvbi5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eShoYXNQcm90bykge1xuICAgICAgICB2YXIgdG9rZW4gPSBsb29rYWhlYWQsIG5vZGUgPSBuZXcgTm9kZSgpLCBjb21wdXRlZCwga2V5LCBtYXliZU1ldGhvZCwgcHJvdG8sIHZhbHVlO1xuXG4gICAgICAgIGNvbXB1dGVkID0gbWF0Y2goJ1snKTtcbiAgICAgICAgaWYgKG1hdGNoKCcqJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICB9XG4gICAgICAgIG1heWJlTWV0aG9kID0gdHJ5UGFyc2VNZXRob2REZWZpbml0aW9uKHRva2VuLCBrZXksIGNvbXB1dGVkLCBub2RlKTtcbiAgICAgICAgaWYgKG1heWJlTWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF5YmVNZXRob2Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGVkIF9fcHJvdG9fX1xuICAgICAgICBpZiAoIWNvbXB1dGVkKSB7XG4gICAgICAgICAgICBwcm90byA9IChrZXkudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYga2V5Lm5hbWUgPT09ICdfX3Byb3RvX18nKSB8fFxuICAgICAgICAgICAgICAgIChrZXkudHlwZSA9PT0gU3ludGF4LkxpdGVyYWwgJiYga2V5LnZhbHVlID09PSAnX19wcm90b19fJyk7XG4gICAgICAgICAgICBpZiAoaGFzUHJvdG8udmFsdWUgJiYgcHJvdG8pIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLkR1cGxpY2F0ZVByb3RvUHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFzUHJvdG8udmFsdWUgfD0gcHJvdG87XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJzonKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB2YWx1ZSA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGtleSwgY29tcHV0ZWQsIHZhbHVlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnPScpKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbG9va2FoZWFkO1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGtleSwgY29tcHV0ZWQsXG4gICAgICAgICAgICAgICAgICAgIG5ldyBXcmFwcGluZ05vZGUodG9rZW4pLmZpbmlzaEFzc2lnbm1lbnRQYXR0ZXJuKGtleSwgdmFsdWUpLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGtleSwgY29tcHV0ZWQsIGtleSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9iamVjdEluaXRpYWxpemVyKCkge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IFtdLCBoYXNQcm90byA9IHt2YWx1ZTogZmFsc2V9LCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICB3aGlsZSAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChwYXJzZU9iamVjdFByb3BlcnR5KGhhc1Byb3RvKSk7XG5cbiAgICAgICAgICAgIGlmICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICAgIGV4cGVjdENvbW1hU2VwYXJhdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hPYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgICBjYXNlIFN5bnRheC5JZGVudGlmaWVyOlxuICAgICAgICBjYXNlIFN5bnRheC5NZW1iZXJFeHByZXNzaW9uOlxuICAgICAgICBjYXNlIFN5bnRheC5SZXN0RWxlbWVudDpcbiAgICAgICAgY2FzZSBTeW50YXguQXNzaWdubWVudFBhdHRlcm46XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTeW50YXguU3ByZWFkRWxlbWVudDpcbiAgICAgICAgICAgIGV4cHIudHlwZSA9IFN5bnRheC5SZXN0RWxlbWVudDtcbiAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmFyZ3VtZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN5bnRheC5BcnJheUV4cHJlc3Npb246XG4gICAgICAgICAgICBleHByLnR5cGUgPSBTeW50YXguQXJyYXlQYXR0ZXJuO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cHIuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwci5lbGVtZW50c1tpXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5lbGVtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3ludGF4Lk9iamVjdEV4cHJlc3Npb246XG4gICAgICAgICAgICBleHByLnR5cGUgPSBTeW50YXguT2JqZWN0UGF0dGVybjtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHByLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5wcm9wZXJ0aWVzW2ldLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGV4cHIudHlwZSA9IFN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjtcbiAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmxlZnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBBbGxvdyBvdGhlciBub2RlIHR5cGUgZm9yIHRvbGVyYW50IHBhcnNpbmcuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEyLjIuOSBUZW1wbGF0ZSBMaXRlcmFsc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZUVsZW1lbnQob3B0aW9uKSB7XG4gICAgICAgIHZhciBub2RlLCB0b2tlbjtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlRlbXBsYXRlIHx8IChvcHRpb24uaGVhZCAmJiAhbG9va2FoZWFkLmhlYWQpKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoVGVtcGxhdGVFbGVtZW50KHsgcmF3OiB0b2tlbi52YWx1ZS5yYXcsIGNvb2tlZDogdG9rZW4udmFsdWUuY29va2VkIH0sIHRva2VuLnRhaWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVGVtcGxhdGVMaXRlcmFsKCkge1xuICAgICAgICB2YXIgcXVhc2ksIHF1YXNpcywgZXhwcmVzc2lvbnMsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIHF1YXNpID0gcGFyc2VUZW1wbGF0ZUVsZW1lbnQoeyBoZWFkOiB0cnVlIH0pO1xuICAgICAgICBxdWFzaXMgPSBbcXVhc2ldO1xuICAgICAgICBleHByZXNzaW9ucyA9IFtdO1xuXG4gICAgICAgIHdoaWxlICghcXVhc2kudGFpbCkge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChwYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICAgICAgICBxdWFzaSA9IHBhcnNlVGVtcGxhdGVFbGVtZW50KHsgaGVhZDogZmFsc2UgfSk7XG4gICAgICAgICAgICBxdWFzaXMucHVzaChxdWFzaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hUZW1wbGF0ZUxpdGVyYWwocXVhc2lzLCBleHByZXNzaW9ucyk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTIuMi4xMCBUaGUgR3JvdXBpbmcgT3BlcmF0b3JcblxuICAgIGZ1bmN0aW9uIHBhcnNlR3JvdXBFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciwgZXhwcmVzc2lvbnMsIHN0YXJ0VG9rZW4sIGksIHBhcmFtcyA9IFtdO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJz0+JykpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoJz0+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgICAgICAgICAgcmF3UGFyYW1zOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgIGlmIChtYXRjaCgnLi4uJykpIHtcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZVJlc3RFbGVtZW50KHBhcmFtcyk7XG4gICAgICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJz0+JykpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoJz0+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW2V4cHJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XG4gICAgICAgIGV4cHIgPSBpbmhlcml0Q292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuXG4gICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zID0gW2V4cHJdO1xuXG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV4KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2goJy4uLicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNCaW5kaW5nRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHBhcnNlUmVzdEVsZW1lbnQocGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnKScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKCc9PicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoJz0+Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByZXNzaW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBleHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaFNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnPT4nKSkge1xuICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgZXhwci5uYW1lID09PSAneWllbGQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogUGxhY2VIb2xkZXJzLkFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogW2V4cHJdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc0JpbmRpbmdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHByLmV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmV4cHJlc3Npb25zW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBQbGFjZUhvbGRlcnMuQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IGV4cHIudHlwZSA9PT0gU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbiA/IGV4cHIuZXhwcmVzc2lvbnMgOiBbZXhwcl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cblxuICAgIC8vIEVDTUEtMjYyIDEyLjIgUHJpbWFyeSBFeHByZXNzaW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHR5cGUsIHRva2VuLCBleHByLCBub2RlO1xuXG4gICAgICAgIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUdyb3VwRXhwcmVzc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgcmV0dXJuIGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VBcnJheUluaXRpYWxpemVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZU9iamVjdEluaXRpYWxpemVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHR5cGUgPSBsb29rYWhlYWQudHlwZTtcbiAgICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zb3VyY2VUeXBlID09PSAnbW9kdWxlJyAmJiBsb29rYWhlYWQudmFsdWUgPT09ICdhd2FpdCcpIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoSWRlbnRpZmllcihsZXgoKS52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCB8fCB0eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkge1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBsb29rYWhlYWQub2N0YWwpIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQsIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKGxleCgpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiBzdGF0ZS5hbGxvd1lpZWxkICYmIG1hdGNoS2V5d29yZCgneWllbGQnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3RoaXMnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFRoaXNFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdjbGFzcycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQ2xhc3NFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiBtYXRjaEtleXdvcmQoJ2xldCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSWRlbnRpZmllcihsZXgoKS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsZXgoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uQm9vbGVhbkxpdGVyYWwpIHtcbiAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9ICh0b2tlbi52YWx1ZSA9PT0gJ3RydWUnKTtcbiAgICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwodG9rZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLk51bGxMaXRlcmFsKSB7XG4gICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgdG9rZW4udmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJy8nKSB8fCBtYXRjaCgnLz0nKSkge1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSBzdGFydEluZGV4O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHNjYW5SZWdFeHAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obGV4KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTIuMyBMZWZ0LUhhbmQtU2lkZSBFeHByZXNzaW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VBcmd1bWVudHMoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGV4cHI7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnLi4uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwciA9IG5ldyBOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBleHByLmZpbmlzaFNwcmVhZEVsZW1lbnQoaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwciA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChleHByKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2goJyknKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0Q29tbWFTZXBhcmF0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpIHtcbiAgICAgICAgdmFyIHRva2VuLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICB0b2tlbiA9IGxleCgpO1xuXG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyTmFtZSh0b2tlbikpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKSB7XG4gICAgICAgIGV4cGVjdCgnLicpO1xuXG4gICAgICAgIHJldHVybiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbXB1dGVkTWVtYmVyKCkge1xuICAgICAgICB2YXIgZXhwcjtcblxuICAgICAgICBleHBlY3QoJ1snKTtcblxuICAgICAgICBleHByID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUV4cHJlc3Npb24pO1xuXG4gICAgICAgIGV4cGVjdCgnXScpO1xuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEyLjMuMyBUaGUgbmV3IE9wZXJhdG9yXG5cbiAgICBmdW5jdGlvbiBwYXJzZU5ld0V4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBjYWxsZWUsIGFyZ3MsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ25ldycpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnLicpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllciAmJiBsb29rYWhlYWQudmFsdWUgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmluRnVuY3Rpb25Cb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hNZXRhUHJvcGVydHkoJ25ldycsICd0YXJnZXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGVlID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24pO1xuICAgICAgICBhcmdzID0gbWF0Y2goJygnKSA/IHBhcnNlQXJndW1lbnRzKCkgOiBbXTtcblxuICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoTmV3RXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEyLjMuNCBGdW5jdGlvbiBDYWxsc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKCkge1xuICAgICAgICB2YXIgcXVhc2ksIGV4cHIsIGFyZ3MsIHByb3BlcnR5LCBzdGFydFRva2VuLCBwcmV2aW91c0FsbG93SW4gPSBzdGF0ZS5hbGxvd0luO1xuXG4gICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgIHN0YXRlLmFsbG93SW4gPSB0cnVlO1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3N1cGVyJykgJiYgc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgIGV4cHIgPSBuZXcgTm9kZSgpO1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBleHByID0gZXhwci5maW5pc2hTdXBlcigpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnKCcpICYmICFtYXRjaCgnLicpICYmICFtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHIgPSBpbmhlcml0Q292ZXJHcmFtbWFyKG1hdGNoS2V5d29yZCgnbmV3JykgPyBwYXJzZU5ld0V4cHJlc3Npb24gOiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnLicpKSB7XG4gICAgICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignLicsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJygnKSkge1xuICAgICAgICAgICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhcmdzID0gcGFyc2VBcmd1bWVudHMoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hDYWxsRXhwcmVzc2lvbihleHByLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VDb21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJ1snLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5UZW1wbGF0ZSAmJiBsb29rYWhlYWQuaGVhZCkge1xuICAgICAgICAgICAgICAgIHF1YXNpID0gcGFyc2VUZW1wbGF0ZUxpdGVyYWwoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oZXhwciwgcXVhc2kpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEyLjMgTGVmdC1IYW5kLVNpZGUgRXhwcmVzc2lvbnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHF1YXNpLCBleHByLCBwcm9wZXJ0eSwgc3RhcnRUb2tlbjtcbiAgICAgICAgYXNzZXJ0KHN0YXRlLmFsbG93SW4sICdjYWxsZWUgb2YgbmV3IGV4cHJlc3Npb24gYWx3YXlzIGFsbG93IGluIGtleXdvcmQuJyk7XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdzdXBlcicpICYmIHN0YXRlLmluRnVuY3Rpb25Cb2R5KSB7XG4gICAgICAgICAgICBleHByID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IGV4cHIuZmluaXNoU3VwZXIoKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJ1snKSAmJiAhbWF0Y2goJy4nKSkge1xuICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHByID0gaW5oZXJpdENvdmVyR3JhbW1hcihtYXRjaEtleXdvcmQoJ25ldycpID8gcGFyc2VOZXdFeHByZXNzaW9uIDogcGFyc2VQcmltYXJ5RXhwcmVzc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VDb21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJ1snLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcuJykpIHtcbiAgICAgICAgICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hNZW1iZXJFeHByZXNzaW9uKCcuJywgZXhwciwgcHJvcGVydHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uVGVtcGxhdGUgJiYgbG9va2FoZWFkLmhlYWQpIHtcbiAgICAgICAgICAgICAgICBxdWFzaSA9IHBhcnNlVGVtcGxhdGVMaXRlcmFsKCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGV4cHIsIHF1YXNpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTIuNCBQb3N0Zml4IEV4cHJlc3Npb25zXG5cbiAgICBmdW5jdGlvbiBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciwgdG9rZW4sIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgZXhwciA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKTtcblxuICAgICAgICBpZiAoIWhhc0xpbmVUZXJtaW5hdG9yICYmIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpIHtcbiAgICAgICAgICAgICAgICAvLyBFQ01BLTI2MiAxMS4zLjEsIDExLjMuMlxuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBpc1Jlc3RyaWN0ZWRXb3JkKGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3RMSFNQb3N0Zml4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzQXNzaWdubWVudFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoUG9zdGZpeEV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTIuNSBVbmFyeSBPcGVyYXRvcnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlVW5hcnlFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgdG9rZW4sIGV4cHIsIHN0YXJ0VG9rZW47XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICBleHByID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcrKycpIHx8IG1hdGNoKCctLScpKSB7XG4gICAgICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgIGV4cHIgPSBpbmhlcml0Q292ZXJHcmFtbWFyKHBhcnNlVW5hcnlFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIC8vIEVDTUEtMjYyIDExLjQuNCwgMTEuNC41XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3RMSFNQcmVmaXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzQXNzaWdubWVudFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hVbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpO1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcrJykgfHwgbWF0Y2goJy0nKSB8fCBtYXRjaCgnficpIHx8IG1hdGNoKCchJykpIHtcbiAgICAgICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VVbmFyeUV4cHJlc3Npb24pO1xuICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKTtcbiAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaEtleXdvcmQoJ2RlbGV0ZScpIHx8IG1hdGNoS2V5d29yZCgndm9pZCcpIHx8IG1hdGNoS2V5d29yZCgndHlwZW9mJykpIHtcbiAgICAgICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VVbmFyeUV4cHJlc3Npb24pO1xuICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZXhwci5vcGVyYXRvciA9PT0gJ2RlbGV0ZScgJiYgZXhwci5hcmd1bWVudC50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuU3RyaWN0RGVsZXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiaW5hcnlQcmVjZWRlbmNlKHRva2VuLCBhbGxvd0luKSB7XG4gICAgICAgIHZhciBwcmVjID0gMDtcblxuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciAmJiB0b2tlbi50eXBlICE9PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgICAgY2FzZSAnfHwnOlxuICAgICAgICAgICAgcHJlYyA9IDE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcmJic6XG4gICAgICAgICAgICBwcmVjID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgcHJlYyA9IDM7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICAgIHByZWMgPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICBwcmVjID0gNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICBjYXNlICchPT0nOlxuICAgICAgICAgICAgcHJlYyA9IDY7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICBjYXNlICdpbnN0YW5jZW9mJzpcbiAgICAgICAgICAgIHByZWMgPSA3O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaW4nOlxuICAgICAgICAgICAgcHJlYyA9IGFsbG93SW4gPyA3IDogMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzw8JzpcbiAgICAgICAgY2FzZSAnPj4nOlxuICAgICAgICBjYXNlICc+Pj4nOlxuICAgICAgICAgICAgcHJlYyA9IDg7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICBwcmVjID0gOTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJyonOlxuICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICBwcmVjID0gMTE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJlYztcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMi42IE11bHRpcGxpY2F0aXZlIE9wZXJhdG9yc1xuICAgIC8vIEVDTUEtMjYyIDEyLjcgQWRkaXRpdmUgT3BlcmF0b3JzXG4gICAgLy8gRUNNQS0yNjIgMTIuOCBCaXR3aXNlIFNoaWZ0IE9wZXJhdG9yc1xuICAgIC8vIEVDTUEtMjYyIDEyLjkgUmVsYXRpb25hbCBPcGVyYXRvcnNcbiAgICAvLyBFQ01BLTI2MiAxMi4xMCBFcXVhbGl0eSBPcGVyYXRvcnNcbiAgICAvLyBFQ01BLTI2MiAxMi4xMSBCaW5hcnkgQml0d2lzZSBPcGVyYXRvcnNcbiAgICAvLyBFQ01BLTI2MiAxMi4xMiBCaW5hcnkgTG9naWNhbCBPcGVyYXRvcnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlQmluYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIG1hcmtlciwgbWFya2VycywgZXhwciwgdG9rZW4sIHByZWMsIHN0YWNrLCByaWdodCwgb3BlcmF0b3IsIGxlZnQsIGk7XG5cbiAgICAgICAgbWFya2VyID0gbG9va2FoZWFkO1xuICAgICAgICBsZWZ0ID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZVVuYXJ5RXhwcmVzc2lvbik7XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgIHByZWMgPSBiaW5hcnlQcmVjZWRlbmNlKHRva2VuLCBzdGF0ZS5hbGxvd0luKTtcbiAgICAgICAgaWYgKHByZWMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgdG9rZW4ucHJlYyA9IHByZWM7XG4gICAgICAgIGxleCgpO1xuXG4gICAgICAgIG1hcmtlcnMgPSBbbWFya2VyLCBsb29rYWhlYWRdO1xuICAgICAgICByaWdodCA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VVbmFyeUV4cHJlc3Npb24pO1xuXG4gICAgICAgIHN0YWNrID0gW2xlZnQsIHRva2VuLCByaWdodF07XG5cbiAgICAgICAgd2hpbGUgKChwcmVjID0gYmluYXJ5UHJlY2VkZW5jZShsb29rYWhlYWQsIHN0YXRlLmFsbG93SW4pKSA+IDApIHtcblxuICAgICAgICAgICAgLy8gUmVkdWNlOiBtYWtlIGEgYmluYXJ5IGV4cHJlc3Npb24gZnJvbSB0aGUgdGhyZWUgdG9wbW9zdCBlbnRyaWVzLlxuICAgICAgICAgICAgd2hpbGUgKChzdGFjay5sZW5ndGggPiAyKSAmJiAocHJlYyA8PSBzdGFja1tzdGFjay5sZW5ndGggLSAyXS5wcmVjKSkge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBzdGFjay5wb3AoKS52YWx1ZTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgbWFya2Vycy5wb3AoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShtYXJrZXJzW21hcmtlcnMubGVuZ3RoIC0gMV0pLmZpbmlzaEJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGV4cHIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTaGlmdC5cbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICB0b2tlbi5wcmVjID0gcHJlYztcbiAgICAgICAgICAgIHN0YWNrLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgbWFya2Vycy5wdXNoKGxvb2thaGVhZCk7XG4gICAgICAgICAgICBleHByID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZVVuYXJ5RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGV4cHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluYWwgcmVkdWNlIHRvIGNsZWFuLXVwIHRoZSBzdGFjay5cbiAgICAgICAgaSA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGV4cHIgPSBzdGFja1tpXTtcbiAgICAgICAgbWFya2Vycy5wb3AoKTtcbiAgICAgICAgd2hpbGUgKGkgPiAxKSB7XG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShtYXJrZXJzLnBvcCgpKS5maW5pc2hCaW5hcnlFeHByZXNzaW9uKHN0YWNrW2kgLSAxXS52YWx1ZSwgc3RhY2tbaSAtIDJdLCBleHByKTtcbiAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuXG4gICAgLy8gRUNNQS0yNjIgMTIuMTMgQ29uZGl0aW9uYWwgT3BlcmF0b3JcblxuICAgIGZ1bmN0aW9uIHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciwgcHJldmlvdXNBbGxvd0luLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIHN0YXJ0VG9rZW47XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICBleHByID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUJpbmFyeUV4cHJlc3Npb24pO1xuICAgICAgICBpZiAobWF0Y2goJz8nKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBwcmV2aW91c0FsbG93SW4gPSBzdGF0ZS5hbGxvd0luO1xuICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG4gICAgICAgICAgICBjb25zZXF1ZW50ID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG4gICAgICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgICAgIGFsdGVybmF0ZSA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG5cbiAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbihleHByLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpO1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTQuMiBBcnJvdyBGdW5jdGlvbiBEZWZpbml0aW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VDb25jaXNlQm9keSgpIHtcbiAgICAgICAgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgc3dpdGNoIChwYXJhbS50eXBlKSB7XG4gICAgICAgIGNhc2UgU3ludGF4LklkZW50aWZpZXI6XG4gICAgICAgICAgICB2YWxpZGF0ZVBhcmFtKG9wdGlvbnMsIHBhcmFtLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN5bnRheC5SZXN0RWxlbWVudDpcbiAgICAgICAgICAgIGNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLmFyZ3VtZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjpcbiAgICAgICAgICAgIGNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLmxlZnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3ludGF4LkFycmF5UGF0dGVybjpcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJhbS5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS5lbGVtZW50c1tpXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5lbGVtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3ludGF4LllpZWxkRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYXNzZXJ0KHBhcmFtLnR5cGUgPT09IFN5bnRheC5PYmplY3RQYXR0ZXJuLCAnSW52YWxpZCB0eXBlJyk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyYW0ucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLnByb3BlcnRpZXNbaV0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVpbnRlcnByZXRBc0NvdmVyRm9ybWFsc0xpc3QoZXhwcikge1xuICAgICAgICB2YXIgaSwgbGVuLCBwYXJhbSwgcGFyYW1zLCBkZWZhdWx0cywgZGVmYXVsdENvdW50LCBvcHRpb25zLCB0b2tlbjtcblxuICAgICAgICBkZWZhdWx0cyA9IFtdO1xuICAgICAgICBkZWZhdWx0Q291bnQgPSAwO1xuICAgICAgICBwYXJhbXMgPSBbZXhwcl07XG5cbiAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgICAgY2FzZSBTeW50YXguSWRlbnRpZmllcjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyOlxuICAgICAgICAgICAgcGFyYW1zID0gZXhwci5wYXJhbXM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhcmFtU2V0OiB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBhcmFtcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcGFyYW0gPSBwYXJhbXNbaV07XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcmFtLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuOlxuICAgICAgICAgICAgICAgIHBhcmFtc1tpXSA9IHBhcmFtLmxlZnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnJpZ2h0LnR5cGUgPT09IFN5bnRheC5ZaWVsZEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnJpZ2h0LmFyZ3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnJpZ2h0LnR5cGUgPSBTeW50YXguSWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0ucmlnaHQubmFtZSA9ICd5aWVsZCc7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbS5yaWdodC5hcmd1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtLnJpZ2h0LmRlbGVnYXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0cy5wdXNoKHBhcmFtLnJpZ2h0KTtcbiAgICAgICAgICAgICAgICArK2RlZmF1bHRDb3VudDtcbiAgICAgICAgICAgICAgICBjaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5sZWZ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0pO1xuICAgICAgICAgICAgICAgIHBhcmFtc1tpXSA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0IHx8ICFzdGF0ZS5hbGxvd1lpZWxkKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwYXJhbXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBwYXJhbSA9IHBhcmFtc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gU3ludGF4LllpZWxkRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLm1lc3NhZ2UgPT09IE1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZSkge1xuICAgICAgICAgICAgdG9rZW4gPSBzdHJpY3QgPyBvcHRpb25zLnN0cmljdGVkIDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQ7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgb3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZhdWx0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGRlZmF1bHRzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgICAgICAgICBzdHJpY3RlZDogb3B0aW9ucy5zdHJpY3RlZCxcbiAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQsXG4gICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUFycm93RnVuY3Rpb25FeHByZXNzaW9uKG9wdGlvbnMsIG5vZGUpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0LCBwcmV2aW91c0FsbG93WWllbGQsIGJvZHk7XG5cbiAgICAgICAgaWYgKGhhc0xpbmVUZXJtaW5hdG9yKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnPT4nKTtcblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgcHJldmlvdXNBbGxvd1lpZWxkID0gc3RhdGUuYWxsb3dZaWVsZDtcbiAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHRydWU7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlQ29uY2lzZUJvZHkoKTtcblxuICAgICAgICBpZiAoc3RyaWN0ICYmIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCwgb3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaWN0ICYmIG9wdGlvbnMuc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKG9wdGlvbnMuc3RyaWN0ZWQsIG9wdGlvbnMubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcbiAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihvcHRpb25zLnBhcmFtcywgb3B0aW9ucy5kZWZhdWx0cywgYm9keSwgYm9keS50eXBlICE9PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDE0LjQgWWllbGQgZXhwcmVzc2lvblxuXG4gICAgZnVuY3Rpb24gcGFyc2VZaWVsZEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBhcmd1bWVudCwgZXhwciwgZGVsZWdhdGUsIHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICBhcmd1bWVudCA9IG51bGw7XG4gICAgICAgIGV4cHIgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3lpZWxkJyk7XG5cbiAgICAgICAgaWYgKCFoYXNMaW5lVGVybWluYXRvcikge1xuICAgICAgICAgICAgcHJldmlvdXNBbGxvd1lpZWxkID0gc3RhdGUuYWxsb3dZaWVsZDtcbiAgICAgICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRlbGVnYXRlID0gbWF0Y2goJyonKTtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKCc7JykgJiYgIW1hdGNoKCd9JykgJiYgIW1hdGNoKCcpJykgJiYgbG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHIuZmluaXNoWWllbGRFeHByZXNzaW9uKGFyZ3VtZW50LCBkZWxlZ2F0ZSk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTIuMTQgQXNzaWdubWVudCBPcGVyYXRvcnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciB0b2tlbiwgZXhwciwgcmlnaHQsIGxpc3QsIHN0YXJ0VG9rZW47XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5hbGxvd1lpZWxkICYmIG1hdGNoS2V5d29yZCgneWllbGQnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlWWllbGRFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBleHByID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcblxuICAgICAgICBpZiAoZXhwci50eXBlID09PSBQbGFjZUhvbGRlcnMuQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlciB8fCBtYXRjaCgnPT4nKSkge1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgbGlzdCA9IHJlaW50ZXJwcmV0QXNDb3ZlckZvcm1hbHNMaXN0KGV4cHIpO1xuXG4gICAgICAgICAgICBpZiAobGlzdCkge1xuICAgICAgICAgICAgICAgIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24obGlzdCwgbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoQXNzaWduKCkpIHtcbiAgICAgICAgICAgIGlmICghaXNBc3NpZ25tZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRUNNQS0yNjIgMTIuMS4xXG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdHJpY3RMSFNBc3NpZ25tZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnPScpKSB7XG4gICAgICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICByaWdodCA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hBc3NpZ25tZW50RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwciwgcmlnaHQpO1xuICAgICAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEyLjE1IENvbW1hIE9wZXJhdG9yXG5cbiAgICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByLCBzdGFydFRva2VuID0gbG9va2FoZWFkLCBleHByZXNzaW9ucztcblxuICAgICAgICBleHByID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcblxuICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMgPSBbZXhwcl07XG5cbiAgICAgICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hTZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTMuMiBCbG9ja1xuXG4gICAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpIHtcbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnZXhwb3J0JzpcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc291cmNlVHlwZSAhPT0gJ21vZHVsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkLCBNZXNzYWdlcy5JbGxlZ2FsRXhwb3J0RGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VFeHBvcnREZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgY2FzZSAnaW1wb3J0JzpcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc291cmNlVHlwZSAhPT0gJ21vZHVsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkLCBNZXNzYWdlcy5JbGxlZ2FsSW1wb3J0RGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbXBvcnREZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgY2FzZSAnY29uc3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUxleGljYWxEZWNsYXJhdGlvbih7aW5Gb3I6IGZhbHNlfSk7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihuZXcgTm9kZSgpKTtcbiAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VDbGFzc0RlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdsZXQnKSAmJiBpc0xleGljYWxEZWNsYXJhdGlvbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VMZXhpY2FsRGVjbGFyYXRpb24oe2luRm9yOiBmYWxzZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlU3RhdGVtZW50KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnRMaXN0KCkge1xuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QucHVzaChwYXJzZVN0YXRlbWVudExpc3RJdGVtKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VCbG9jaygpIHtcbiAgICAgICAgdmFyIGJsb2NrLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICBibG9jayA9IHBhcnNlU3RhdGVtZW50TGlzdCgpO1xuXG4gICAgICAgIGV4cGVjdCgnfScpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEJsb2NrU3RhdGVtZW50KGJsb2NrKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMy4zLjIgVmFyaWFibGUgU3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcihraW5kKSB7XG4gICAgICAgIHZhciB0b2tlbiwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgdG9rZW4gPSBsZXgoKTtcblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCAmJiB0b2tlbi52YWx1ZSA9PT0gJ3lpZWxkJykge1xuICAgICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xuICAgICAgICAgICAgfSBpZiAoIXN0YXRlLmFsbG93WWllbGQpIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiB0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCB8fCB0b2tlbi52YWx1ZSAhPT0gJ2xldCcgfHwga2luZCAhPT0gJ3ZhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5zb3VyY2VUeXBlID09PSAnbW9kdWxlJyAmJiB0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyICYmIHRva2VuLnZhbHVlID09PSAnYXdhaXQnKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hJZGVudGlmaWVyKHRva2VuLnZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgaW5pdCA9IG51bGwsIGlkLCBub2RlID0gbmV3IE5vZGUoKSwgcGFyYW1zID0gW107XG5cbiAgICAgICAgaWQgPSBwYXJzZVBhdHRlcm4ocGFyYW1zLCAndmFyJyk7XG5cbiAgICAgICAgLy8gRUNNQS0yNjIgMTIuMi4xXG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xuICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCgnPScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGluaXQgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGlkLnR5cGUgIT09IFN5bnRheC5JZGVudGlmaWVyICYmICFvcHRpb25zLmluRm9yKSB7XG4gICAgICAgICAgICBleHBlY3QoJz0nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChvcHRpb25zKSB7XG4gICAgICAgIHZhciBsaXN0ID0gW107XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGlzdC5wdXNoKHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbih7IGluRm9yOiBvcHRpb25zLmluRm9yIH0pKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgIH0gd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVmFyaWFibGVTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgZGVjbGFyYXRpb25zO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3ZhcicpO1xuXG4gICAgICAgIGRlY2xhcmF0aW9ucyA9IHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoeyBpbkZvcjogZmFsc2UgfSk7XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMy4zLjEgTGV0IGFuZCBDb25zdCBEZWNsYXJhdGlvbnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlTGV4aWNhbEJpbmRpbmcoa2luZCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgaW5pdCA9IG51bGwsIGlkLCBub2RlID0gbmV3IE5vZGUoKSwgcGFyYW1zID0gW107XG5cbiAgICAgICAgaWQgPSBwYXJzZVBhdHRlcm4ocGFyYW1zLCBraW5kKTtcblxuICAgICAgICAvLyBFQ01BLTI2MiAxMi4yLjFcbiAgICAgICAgaWYgKHN0cmljdCAmJiBpZC50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBpc1Jlc3RyaWN0ZWRXb3JkKGlkLm5hbWUpKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLlN0cmljdFZhck5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtpbmQgPT09ICdjb25zdCcpIHtcbiAgICAgICAgICAgIGlmICghbWF0Y2hLZXl3b3JkKCdpbicpICYmICFtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCc9Jyk7XG4gICAgICAgICAgICAgICAgaW5pdCA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoKCFvcHRpb25zLmluRm9yICYmIGlkLnR5cGUgIT09IFN5bnRheC5JZGVudGlmaWVyKSB8fCBtYXRjaCgnPScpKSB7XG4gICAgICAgICAgICBleHBlY3QoJz0nKTtcbiAgICAgICAgICAgIGluaXQgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoVmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUJpbmRpbmdMaXN0KGtpbmQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBsaXN0LnB1c2gocGFyc2VMZXhpY2FsQmluZGluZyhraW5kLCBvcHRpb25zKSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9IHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHRva2VuaXplclN0YXRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgaGFzTGluZVRlcm1pbmF0b3I6IGhhc0xpbmVUZXJtaW5hdG9yLFxuICAgICAgICAgICAgbGFzdEluZGV4OiBsYXN0SW5kZXgsXG4gICAgICAgICAgICBsYXN0TGluZU51bWJlcjogbGFzdExpbmVOdW1iZXIsXG4gICAgICAgICAgICBsYXN0TGluZVN0YXJ0OiBsYXN0TGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnRJbmRleDogc3RhcnRJbmRleCxcbiAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICAgICAgc3RhcnRMaW5lU3RhcnQ6IHN0YXJ0TGluZVN0YXJ0LFxuICAgICAgICAgICAgbG9va2FoZWFkOiBsb29rYWhlYWQsXG4gICAgICAgICAgICB0b2tlbkNvdW50OiBleHRyYS50b2tlbnMgPyBleHRyYS50b2tlbnMubGVuZ3RoIDogMFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2V0VG9rZW5pemVyU3RhdGUodHMpIHtcbiAgICAgICAgaW5kZXggPSB0cy5pbmRleDtcbiAgICAgICAgbGluZU51bWJlciA9IHRzLmxpbmVOdW1iZXI7XG4gICAgICAgIGxpbmVTdGFydCA9IHRzLmxpbmVTdGFydDtcbiAgICAgICAgaGFzTGluZVRlcm1pbmF0b3IgPSB0cy5oYXNMaW5lVGVybWluYXRvcjtcbiAgICAgICAgbGFzdEluZGV4ID0gdHMubGFzdEluZGV4O1xuICAgICAgICBsYXN0TGluZU51bWJlciA9IHRzLmxhc3RMaW5lTnVtYmVyO1xuICAgICAgICBsYXN0TGluZVN0YXJ0ID0gdHMubGFzdExpbmVTdGFydDtcbiAgICAgICAgc3RhcnRJbmRleCA9IHRzLnN0YXJ0SW5kZXg7XG4gICAgICAgIHN0YXJ0TGluZU51bWJlciA9IHRzLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgc3RhcnRMaW5lU3RhcnQgPSB0cy5zdGFydExpbmVTdGFydDtcbiAgICAgICAgbG9va2FoZWFkID0gdHMubG9va2FoZWFkO1xuICAgICAgICBpZiAoZXh0cmEudG9rZW5zKSB7XG4gICAgICAgICAgICBleHRyYS50b2tlbnMuc3BsaWNlKHRzLnRva2VuQ291bnQsIGV4dHJhLnRva2Vucy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZXhpY2FsRGVjbGFyYXRpb24oKSB7XG4gICAgICAgIHZhciBsZXhpY2FsLCB0cztcblxuICAgICAgICB0cyA9IHRva2VuaXplclN0YXRlKCk7XG5cbiAgICAgICAgbGV4KCk7XG4gICAgICAgIGxleGljYWwgPSAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHx8IG1hdGNoKCdbJykgfHwgbWF0Y2goJ3snKSB8fFxuICAgICAgICAgICAgbWF0Y2hLZXl3b3JkKCdsZXQnKSB8fCBtYXRjaEtleXdvcmQoJ3lpZWxkJyk7XG5cbiAgICAgICAgcmVzZXRUb2tlbml6ZXJTdGF0ZSh0cyk7XG5cbiAgICAgICAgcmV0dXJuIGxleGljYWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMZXhpY2FsRGVjbGFyYXRpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIga2luZCwgZGVjbGFyYXRpb25zLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBraW5kID0gbGV4KCkudmFsdWU7XG4gICAgICAgIGFzc2VydChraW5kID09PSAnbGV0JyB8fCBraW5kID09PSAnY29uc3QnLCAnTGV4aWNhbCBkZWNsYXJhdGlvbiBtdXN0IGJlIGVpdGhlciBsZXQgb3IgY29uc3QnKTtcblxuICAgICAgICBkZWNsYXJhdGlvbnMgPSBwYXJzZUJpbmRpbmdMaXN0KGtpbmQsIG9wdGlvbnMpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hMZXhpY2FsRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVJlc3RFbGVtZW50KHBhcmFtcykge1xuICAgICAgICB2YXIgcGFyYW0sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGxleCgpO1xuXG4gICAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLk9iamVjdFBhdHRlcm5Bc1Jlc3RQYXJhbWV0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1zLnB1c2gobG9va2FoZWFkKTtcblxuICAgICAgICBwYXJhbSA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCc9JykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuRGVmYXVsdFJlc3RQYXJhbWV0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLlBhcmFtZXRlckFmdGVyUmVzdFBhcmFtZXRlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hSZXN0RWxlbWVudChwYXJhbSk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTMuNCBFbXB0eSBTdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICBleHBlY3QoJzsnKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRW1wdHlTdGF0ZW1lbnQoKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMi40IEV4cHJlc3Npb24gU3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcik7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTMuNiBJZiBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlSWZTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgdGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2lmJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIGNvbnNlcXVlbnQgPSBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2Vsc2UnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBhbHRlcm5hdGUgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaElmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTMuNyBJdGVyYXRpb24gU3RhdGVtZW50c1xuXG4gICAgZnVuY3Rpb24gcGFyc2VEb1doaWxlU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGJvZHksIHRlc3QsIG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2RvJyk7XG5cbiAgICAgICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSB0cnVlO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnd2hpbGUnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRG9XaGlsZVN0YXRlbWVudChib2R5LCB0ZXN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIHRlc3QsIGJvZHksIG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIG9sZEluSXRlcmF0aW9uID0gc3RhdGUuaW5JdGVyYXRpb247XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gdHJ1ZTtcblxuICAgICAgICBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFdoaWxlU3RhdGVtZW50KHRlc3QsIGJvZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRm9yU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGluaXQsIGZvckluLCBpbml0U2VxLCBpbml0U3RhcnRUb2tlbiwgdGVzdCwgdXBkYXRlLCBsZWZ0LCByaWdodCwga2luZCwgZGVjbGFyYXRpb25zLFxuICAgICAgICAgICAgYm9keSwgb2xkSW5JdGVyYXRpb24sIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG5cbiAgICAgICAgaW5pdCA9IHRlc3QgPSB1cGRhdGUgPSBudWxsO1xuICAgICAgICBmb3JJbiA9IHRydWU7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnZm9yJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgndmFyJykpIHtcbiAgICAgICAgICAgICAgICBpbml0ID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICBsZXgoKTtcblxuICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnMgPSBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KHsgaW5Gb3I6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcblxuICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIG1hdGNoS2V5d29yZCgnaW4nKSkge1xuICAgICAgICAgICAgICAgICAgICBpbml0ID0gaW5pdC5maW5pc2hWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIGRlY2xhcmF0aW9uc1swXS5pbml0ID09PSBudWxsICYmIG1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ29mJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdCA9IGluaXQuZmluaXNoVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZm9ySW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbml0ID0gaW5pdC5maW5pc2hWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnOycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hLZXl3b3JkKCdjb25zdCcpIHx8IG1hdGNoS2V5d29yZCgnbGV0JykpIHtcbiAgICAgICAgICAgICAgICBpbml0ID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICBraW5kID0gbGV4KCkudmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXN0cmljdCAmJiBsb29rYWhlYWQudmFsdWUgPT09ICdpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdCA9IGluaXQuZmluaXNoSWRlbnRpZmllcihraW5kKTtcbiAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9ucyA9IHBhcnNlQmluZGluZ0xpc3Qoa2luZCwge2luRm9yOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZGVjbGFyYXRpb25zWzBdLmluaXQgPT09IG51bGwgJiYgbWF0Y2hLZXl3b3JkKCdpbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gaW5pdC5maW5pc2hMZXhpY2FsRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBkZWNsYXJhdGlvbnNbMF0uaW5pdCA9PT0gbnVsbCAmJiBtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gaW5pdC5maW5pc2hMZXhpY2FsRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ySW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSBpbml0LmZpbmlzaExleGljYWxEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0U3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaW5pdCA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2luJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Fzc2lnbm1lbnRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuSW52YWxpZExIU0luRm9ySW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihpbml0KTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnb2YnKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXNzaWdubWVudFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5JbnZhbGlkTEhTSW5Gb3JMb29wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICByZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oaW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZvckluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRTZXEgPSBbaW5pdF07XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRTZXEucHVzaChpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSBuZXcgV3JhcHBpbmdOb2RlKGluaXRTdGFydFRva2VuKS5maW5pc2hTZXF1ZW5jZUV4cHJlc3Npb24oaW5pdFNlcSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KCc7Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgICAgICBpZiAoIW1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBlY3QoJzsnKTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBvbGRJbkl0ZXJhdGlvbiA9IHN0YXRlLmluSXRlcmF0aW9uO1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IHRydWU7XG5cbiAgICAgICAgYm9keSA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VTdGF0ZW1lbnQpO1xuXG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgcmV0dXJuICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpID9cbiAgICAgICAgICAgICAgICBub2RlLmZpbmlzaEZvclN0YXRlbWVudChpbml0LCB0ZXN0LCB1cGRhdGUsIGJvZHkpIDpcbiAgICAgICAgICAgICAgICBmb3JJbiA/IG5vZGUuZmluaXNoRm9ySW5TdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpIDpcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5maW5pc2hGb3JPZlN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTMuOCBUaGUgY29udGludWUgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbnRpbnVlU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gbnVsbCwga2V5O1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2NvbnRpbnVlJyk7XG5cbiAgICAgICAgLy8gT3B0aW1pemUgdGhlIG1vc3QgY29tbW9uIGZvcm06ICdjb250aW51ZTsnLlxuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoc3RhcnRJbmRleCkgPT09IDB4M0IpIHtcbiAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmluSXRlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsQ29udGludWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hDb250aW51ZVN0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNMaW5lVGVybWluYXRvcikge1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pbkl0ZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQ29udGludWVTdGF0ZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGxhYmVsID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblxuICAgICAgICAgICAga2V5ID0gJyQnICsgbGFiZWwubmFtZTtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmxhYmVsU2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5Vbmtub3duTGFiZWwsIGxhYmVsLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIGlmIChsYWJlbCA9PT0gbnVsbCAmJiAhc3RhdGUuaW5JdGVyYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaENvbnRpbnVlU3RhdGVtZW50KGxhYmVsKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMy45IFRoZSBicmVhayBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlQnJlYWtTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgbGFiZWwgPSBudWxsLCBrZXk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnYnJlYWsnKTtcblxuICAgICAgICAvLyBDYXRjaCB0aGUgdmVyeSBjb21tb24gY2FzZSBmaXJzdDogaW1tZWRpYXRlbHkgYSBzZW1pY29sb24gKFUrMDAzQikuXG4gICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChsYXN0SW5kZXgpID09PSAweDNCKSB7XG4gICAgICAgICAgICBsZXgoKTtcblxuICAgICAgICAgICAgaWYgKCEoc3RhdGUuaW5JdGVyYXRpb24gfHwgc3RhdGUuaW5Td2l0Y2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsQnJlYWspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hCcmVha1N0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNMaW5lVGVybWluYXRvcikge1xuICAgICAgICAgICAgaWYgKCEoc3RhdGUuaW5JdGVyYXRpb24gfHwgc3RhdGUuaW5Td2l0Y2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsQnJlYWspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBsYWJlbCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgICAgIGtleSA9ICckJyArIGxhYmVsLm5hbWU7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS5sYWJlbFNldCwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuVW5rbm93bkxhYmVsLCBsYWJlbC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICBpZiAobGFiZWwgPT09IG51bGwgJiYgIShzdGF0ZS5pbkl0ZXJhdGlvbiB8fCBzdGF0ZS5pblN3aXRjaCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSWxsZWdhbEJyZWFrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEJyZWFrU3RhdGVtZW50KGxhYmVsKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMy4xMCBUaGUgcmV0dXJuIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VSZXR1cm5TdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgYXJndW1lbnQgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3JldHVybicpO1xuXG4gICAgICAgIGlmICghc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuSWxsZWdhbFJldHVybik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAncmV0dXJuJyBmb2xsb3dlZCBieSBhIHNwYWNlIGFuZCBhbiBpZGVudGlmaWVyIGlzIHZlcnkgY29tbW9uLlxuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQobGFzdEluZGV4KSA9PT0gMHgyMCkge1xuICAgICAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGxhc3RJbmRleCArIDEpKSkge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFJldHVyblN0YXRlbWVudChhcmd1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTGluZVRlcm1pbmF0b3IpIHtcbiAgICAgICAgICAgIC8vIEhBQ0tcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFJldHVyblN0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpICYmIGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFJldHVyblN0YXRlbWVudChhcmd1bWVudCk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTMuMTEgVGhlIHdpdGggc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgb2JqZWN0LCBib2R5O1xuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuU3RyaWN0TW9kZVdpdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnd2l0aCcpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIG9iamVjdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFdpdGhTdGF0ZW1lbnQob2JqZWN0LCBib2R5KTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMy4xMiBUaGUgc3dpdGNoIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VTd2l0Y2hDYXNlKCkge1xuICAgICAgICB2YXIgdGVzdCwgY29uc2VxdWVudCA9IFtdLCBzdGF0ZW1lbnQsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB0ZXN0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cGVjdEtleXdvcmQoJ2Nhc2UnKTtcbiAgICAgICAgICAgIHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJzonKTtcblxuICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCd9JykgfHwgbWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykgfHwgbWF0Y2hLZXl3b3JkKCdjYXNlJykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlbWVudCA9IHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKTtcbiAgICAgICAgICAgIGNvbnNlcXVlbnQucHVzaChzdGF0ZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoU3dpdGNoQ2FzZSh0ZXN0LCBjb25zZXF1ZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBkaXNjcmltaW5hbnQsIGNhc2VzLCBjbGF1c2UsIG9sZEluU3dpdGNoLCBkZWZhdWx0Rm91bmQ7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnc3dpdGNoJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgZGlzY3JpbWluYW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgICAgY2FzZXMgPSBbXTtcblxuICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hTd2l0Y2hTdGF0ZW1lbnQoZGlzY3JpbWluYW50LCBjYXNlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBvbGRJblN3aXRjaCA9IHN0YXRlLmluU3dpdGNoO1xuICAgICAgICBzdGF0ZS5pblN3aXRjaCA9IHRydWU7XG4gICAgICAgIGRlZmF1bHRGb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xhdXNlID0gcGFyc2VTd2l0Y2hDYXNlKCk7XG4gICAgICAgICAgICBpZiAoY2xhdXNlLnRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2VzLnB1c2goY2xhdXNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmluU3dpdGNoID0gb2xkSW5Td2l0Y2g7XG5cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoU3dpdGNoU3RhdGVtZW50KGRpc2NyaW1pbmFudCwgY2FzZXMpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEzLjE0IFRoZSB0aHJvdyBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgYXJndW1lbnQ7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgndGhyb3cnKTtcblxuICAgICAgICBpZiAoaGFzTGluZVRlcm1pbmF0b3IpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuTmV3bGluZUFmdGVyVGhyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoVGhyb3dTdGF0ZW1lbnQoYXJndW1lbnQpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEzLjE1IFRoZSB0cnkgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNhdGNoQ2xhdXNlKCkge1xuICAgICAgICB2YXIgcGFyYW0sIHBhcmFtcyA9IFtdLCBwYXJhbU1hcCA9IHt9LCBrZXksIGksIGJvZHksIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2NhdGNoJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG4gICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW0gPSBwYXJzZVBhdHRlcm4ocGFyYW1zKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAga2V5ID0gJyQnICsgcGFyYW1zW2ldLnZhbHVlO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbU1hcCwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuRHVwbGljYXRlQmluZGluZywgcGFyYW1zW2ldLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtTWFwW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRUNNQS0yNjIgMTIuMTQuMVxuICAgICAgICBpZiAoc3RyaWN0ICYmIGlzUmVzdHJpY3RlZFdvcmQocGFyYW0ubmFtZSkpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuU3RyaWN0Q2F0Y2hWYXJpYWJsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgYm9keSA9IHBhcnNlQmxvY2soKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQ2F0Y2hDbGF1c2UocGFyYW0sIGJvZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGJsb2NrLCBoYW5kbGVyID0gbnVsbCwgZmluYWxpemVyID0gbnVsbDtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd0cnknKTtcblxuICAgICAgICBibG9jayA9IHBhcnNlQmxvY2soKTtcblxuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdjYXRjaCcpKSB7XG4gICAgICAgICAgICBoYW5kbGVyID0gcGFyc2VDYXRjaENsYXVzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZmluYWxseScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGZpbmFsaXplciA9IHBhcnNlQmxvY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFuZGxlciAmJiAhZmluYWxpemVyKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLk5vQ2F0Y2hPckZpbmFsbHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoVHJ5U3RhdGVtZW50KGJsb2NrLCBoYW5kbGVyLCBmaW5hbGl6ZXIpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEzLjE2IFRoZSBkZWJ1Z2dlciBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICBleHBlY3RLZXl3b3JkKCdkZWJ1Z2dlcicpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hEZWJ1Z2dlclN0YXRlbWVudCgpO1xuICAgIH1cblxuICAgIC8vIDEzIFN0YXRlbWVudHNcblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgdHlwZSA9IGxvb2thaGVhZC50eXBlLFxuICAgICAgICAgICAgZXhwcixcbiAgICAgICAgICAgIGxhYmVsZWRCb2R5LFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgbm9kZTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnZhbHVlID09PSAneycpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUJsb2NrKCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XG4gICAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnOyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnYnJlYWsnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUJyZWFrU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnY29udGludWUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUNvbnRpbnVlU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnZGVidWdnZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZURlYnVnZ2VyU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnZG8nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZURvV2hpbGVTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICdmb3InOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZvclN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnaWYnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUlmU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAncmV0dXJuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VSZXR1cm5TdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICdzd2l0Y2gnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ3Rocm93JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUaHJvd1N0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ3RyeSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAndmFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VWYXJpYWJsZVN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ3doaWxlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VXaGlsZVN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ3dpdGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIC8vIEVDTUEtMjYyIDEyLjEyIExhYmVsbGVkIFN0YXRlbWVudHNcbiAgICAgICAgaWYgKChleHByLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSAmJiBtYXRjaCgnOicpKSB7XG4gICAgICAgICAgICBsZXgoKTtcblxuICAgICAgICAgICAga2V5ID0gJyQnICsgZXhwci5uYW1lO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS5sYWJlbFNldCwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuUmVkZWNsYXJhdGlvbiwgJ0xhYmVsJywgZXhwci5uYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUubGFiZWxTZXRba2V5XSA9IHRydWU7XG4gICAgICAgICAgICBsYWJlbGVkQm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUubGFiZWxTZXRba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaExhYmVsZWRTdGF0ZW1lbnQoZXhwciwgbGFiZWxlZEJvZHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcik7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTQuMSBGdW5jdGlvbiBEZWZpbml0aW9uXG5cbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKSB7XG4gICAgICAgIHZhciBzdGF0ZW1lbnQsIGJvZHkgPSBbXSwgdG9rZW4sIGRpcmVjdGl2ZSwgZmlyc3RSZXN0cmljdGVkLFxuICAgICAgICAgICAgb2xkTGFiZWxTZXQsIG9sZEluSXRlcmF0aW9uLCBvbGRJblN3aXRjaCwgb2xkSW5GdW5jdGlvbkJvZHksIG9sZFBhcmVudGhlc2lzQ291bnQsXG4gICAgICAgICAgICBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICAgICAgc3RhdGVtZW50ID0gcGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xuICAgICAgICAgICAgYm9keS5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgICAgICBpZiAoc3RhdGVtZW50LmV4cHJlc3Npb24udHlwZSAhPT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBkaXJlY3RpdmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpcmVjdGl2ZSA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCArIDEsIHRva2VuLmVuZCAtIDEpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZSA9PT0gJ3VzZSBzdHJpY3QnKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGZpcnN0UmVzdHJpY3RlZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZmlyc3RSZXN0cmljdGVkICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9sZExhYmVsU2V0ID0gc3RhdGUubGFiZWxTZXQ7XG4gICAgICAgIG9sZEluSXRlcmF0aW9uID0gc3RhdGUuaW5JdGVyYXRpb247XG4gICAgICAgIG9sZEluU3dpdGNoID0gc3RhdGUuaW5Td2l0Y2g7XG4gICAgICAgIG9sZEluRnVuY3Rpb25Cb2R5ID0gc3RhdGUuaW5GdW5jdGlvbkJvZHk7XG4gICAgICAgIG9sZFBhcmVudGhlc2lzQ291bnQgPSBzdGF0ZS5wYXJlbnRoZXNpemVkQ291bnQ7XG5cbiAgICAgICAgc3RhdGUubGFiZWxTZXQgPSB7fTtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaW5Td2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaW5GdW5jdGlvbkJvZHkgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5wYXJlbnRoZXNpemVkQ291bnQgPSAwO1xuXG4gICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keS5wdXNoKHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICBzdGF0ZS5sYWJlbFNldCA9IG9sZExhYmVsU2V0O1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IG9sZEluSXRlcmF0aW9uO1xuICAgICAgICBzdGF0ZS5pblN3aXRjaCA9IG9sZEluU3dpdGNoO1xuICAgICAgICBzdGF0ZS5pbkZ1bmN0aW9uQm9keSA9IG9sZEluRnVuY3Rpb25Cb2R5O1xuICAgICAgICBzdGF0ZS5wYXJlbnRoZXNpemVkQ291bnQgPSBvbGRQYXJlbnRoZXNpc0NvdW50O1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEJsb2NrU3RhdGVtZW50KGJvZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUGFyYW0ob3B0aW9ucywgcGFyYW0sIG5hbWUpIHtcbiAgICAgICAgdmFyIGtleSA9ICckJyArIG5hbWU7XG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3RlZCA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5wYXJhbVNldCwga2V5KSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0ZWQgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZChuYW1lKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkID0gcGFyYW07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMucGFyYW1TZXQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0cmljdGVkID0gcGFyYW07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMucGFyYW1TZXRba2V5XSA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQYXJhbShvcHRpb25zKSB7XG4gICAgICAgIHZhciB0b2tlbiwgcGFyYW0sIHBhcmFtcyA9IFtdLCBpLCBkZWY7XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJy4uLicpIHtcbiAgICAgICAgICAgIHBhcmFtID0gcGFyc2VSZXN0RWxlbWVudChwYXJhbXMpO1xuICAgICAgICAgICAgdmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbS5hcmd1bWVudCwgcGFyYW0uYXJndW1lbnQubmFtZSk7XG4gICAgICAgICAgICBvcHRpb25zLnBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdHMucHVzaChudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtID0gcGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbXNbaV0sIHBhcmFtc1tpXS52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuKSB7XG4gICAgICAgICAgICBkZWYgPSBwYXJhbS5yaWdodDtcbiAgICAgICAgICAgIHBhcmFtID0gcGFyYW0ubGVmdDtcbiAgICAgICAgICAgICsrb3B0aW9ucy5kZWZhdWx0Q291bnQ7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLnBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgb3B0aW9ucy5kZWZhdWx0cy5wdXNoKGRlZik7XG5cbiAgICAgICAgcmV0dXJuICFtYXRjaCgnKScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUGFyYW1zKGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICB2YXIgb3B0aW9ucztcblxuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgICAgIGRlZmF1bHRDb3VudDogMCxcbiAgICAgICAgICAgIGRlZmF1bHRzOiBbXSxcbiAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogZmlyc3RSZXN0cmljdGVkXG4gICAgICAgIH07XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBhcmFtU2V0ID0ge307XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VQYXJhbShvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdHMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJhbXM6IG9wdGlvbnMucGFyYW1zLFxuICAgICAgICAgICAgZGVmYXVsdHM6IG9wdGlvbnMuZGVmYXVsdHMsXG4gICAgICAgICAgICBzdHJpY3RlZDogb3B0aW9ucy5zdHJpY3RlZCxcbiAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQsXG4gICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24obm9kZSwgaWRlbnRpZmllcklzT3B0aW9uYWwpIHtcbiAgICAgICAgdmFyIGlkID0gbnVsbCwgcGFyYW1zID0gW10sIGRlZmF1bHRzID0gW10sIGJvZHksIHRva2VuLCBzdHJpY3RlZCwgdG1wLCBmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UsIHByZXZpb3VzU3RyaWN0LFxuICAgICAgICAgICAgaXNHZW5lcmF0b3IsIHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICBwcmV2aW91c0FsbG93WWllbGQgPSBzdGF0ZS5hbGxvd1lpZWxkO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2Z1bmN0aW9uJyk7XG5cbiAgICAgICAgaXNHZW5lcmF0b3IgPSBtYXRjaCgnKicpO1xuICAgICAgICBpZiAoaXNHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpZGVudGlmaWVySXNPcHRpb25hbCB8fCAhbWF0Y2goJygnKSkge1xuICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICBpZCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gIWlzR2VuZXJhdG9yO1xuICAgICAgICB0bXAgPSBwYXJzZVBhcmFtcyhmaXJzdFJlc3RyaWN0ZWQpO1xuICAgICAgICBwYXJhbXMgPSB0bXAucGFyYW1zO1xuICAgICAgICBkZWZhdWx0cyA9IHRtcC5kZWZhdWx0cztcbiAgICAgICAgc3RyaWN0ZWQgPSB0bXAuc3RyaWN0ZWQ7XG4gICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRtcC5maXJzdFJlc3RyaWN0ZWQ7XG4gICAgICAgIGlmICh0bXAubWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRtcC5tZXNzYWdlO1xuICAgICAgICB9XG5cblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgYm9keSA9IHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xuICAgICAgICBpZiAoc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaWN0ICYmIHN0cmljdGVkKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcbiAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hGdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIGRlZmF1bHRzLCBib2R5LCBpc0dlbmVyYXRvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciB0b2tlbiwgaWQgPSBudWxsLCBzdHJpY3RlZCwgZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlLCB0bXAsXG4gICAgICAgICAgICBwYXJhbXMgPSBbXSwgZGVmYXVsdHMgPSBbXSwgYm9keSwgcHJldmlvdXNTdHJpY3QsIG5vZGUgPSBuZXcgTm9kZSgpLFxuICAgICAgICAgICAgaXNHZW5lcmF0b3IsIHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICBwcmV2aW91c0FsbG93WWllbGQgPSBzdGF0ZS5hbGxvd1lpZWxkO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2Z1bmN0aW9uJyk7XG5cbiAgICAgICAgaXNHZW5lcmF0b3IgPSBtYXRjaCgnKicpO1xuICAgICAgICBpZiAoaXNHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9ICFpc0dlbmVyYXRvcjtcbiAgICAgICAgaWYgKCFtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIGlkID0gKCFzdHJpY3QgJiYgIWlzR2VuZXJhdG9yICYmIG1hdGNoS2V5d29yZCgneWllbGQnKSkgPyBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKSA6IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0bXAgPSBwYXJzZVBhcmFtcyhmaXJzdFJlc3RyaWN0ZWQpO1xuICAgICAgICBwYXJhbXMgPSB0bXAucGFyYW1zO1xuICAgICAgICBkZWZhdWx0cyA9IHRtcC5kZWZhdWx0cztcbiAgICAgICAgc3RyaWN0ZWQgPSB0bXAuc3RyaWN0ZWQ7XG4gICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRtcC5maXJzdFJlc3RyaWN0ZWQ7XG4gICAgICAgIGlmICh0bXAubWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRtcC5tZXNzYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNTdHJpY3QgPSBzdHJpY3Q7XG4gICAgICAgIGJvZHkgPSBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcbiAgICAgICAgaWYgKHN0cmljdCAmJiBmaXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmljdCAmJiBzdHJpY3RlZCkge1xuICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oc3RyaWN0ZWQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEZ1bmN0aW9uRXhwcmVzc2lvbihpZCwgcGFyYW1zLCBkZWZhdWx0cywgYm9keSwgaXNHZW5lcmF0b3IpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDE0LjUgQ2xhc3MgRGVmaW5pdGlvbnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3NCb2R5KCkge1xuICAgICAgICB2YXIgY2xhc3NCb2R5LCB0b2tlbiwgaXNTdGF0aWMsIGhhc0NvbnN0cnVjdG9yID0gZmFsc2UsIGJvZHksIG1ldGhvZCwgY29tcHV0ZWQsIGtleTtcblxuICAgICAgICBjbGFzc0JvZHkgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuICAgICAgICBib2R5ID0gW107XG4gICAgICAgIHdoaWxlICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgICAgICBpc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gbWF0Y2goJ1snKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2goJyonKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkubmFtZSA9PT0gJ3N0YXRpYycgJiYgKGxvb2thaGVhZFByb3BlcnR5TmFtZSgpIHx8IG1hdGNoKCcqJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gbWF0Y2goJ1snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnKicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0cnlQYXJzZU1ldGhvZERlZmluaXRpb24odG9rZW4sIGtleSwgY29tcHV0ZWQsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2RbJ3N0YXRpYyddID0gaXNTdGF0aWM7IC8vIGpzY3M6aWdub3JlIHJlcXVpcmVEb3ROb3RhdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmtpbmQgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmtpbmQgPSAnbWV0aG9kJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU3RhdGljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGhvZC5jb21wdXRlZCAmJiAobWV0aG9kLmtleS5uYW1lIHx8IG1ldGhvZC5rZXkudmFsdWUudG9TdHJpbmcoKSkgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmtpbmQgIT09ICdtZXRob2QnIHx8ICFtZXRob2QubWV0aG9kIHx8IG1ldGhvZC52YWx1ZS5nZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLkNvbnN0cnVjdG9yU3BlY2lhbE1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgTWVzc2FnZXMuRHVwbGljYXRlQ29uc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmtpbmQgPSAnY29uc3RydWN0b3InO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRob2QuY29tcHV0ZWQgJiYgKG1ldGhvZC5rZXkubmFtZSB8fCBtZXRob2Qua2V5LnZhbHVlLnRvU3RyaW5nKCkpID09PSAncHJvdG90eXBlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdGF0aWNQcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZC50eXBlID0gU3ludGF4Lk1ldGhvZERlZmluaXRpb247XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXRob2QubWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWV0aG9kLnNob3J0aGFuZDtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5wdXNoKG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV4KCk7XG4gICAgICAgIHJldHVybiBjbGFzc0JvZHkuZmluaXNoQ2xhc3NCb2R5KGJvZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3NEZWNsYXJhdGlvbihpZGVudGlmaWVySXNPcHRpb25hbCkge1xuICAgICAgICB2YXIgaWQgPSBudWxsLCBzdXBlckNsYXNzID0gbnVsbCwgY2xhc3NOb2RlID0gbmV3IE5vZGUoKSwgY2xhc3NCb2R5LCBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdjbGFzcycpO1xuXG4gICAgICAgIGlmICghaWRlbnRpZmllcklzT3B0aW9uYWwgfHwgbG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2V4dGVuZHMnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBzdXBlckNsYXNzID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzQm9keSA9IHBhcnNlQ2xhc3NCb2R5KCk7XG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjbGFzc05vZGUuZmluaXNoQ2xhc3NEZWNsYXJhdGlvbihpZCwgc3VwZXJDbGFzcywgY2xhc3NCb2R5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNsYXNzRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGlkID0gbnVsbCwgc3VwZXJDbGFzcyA9IG51bGwsIGNsYXNzTm9kZSA9IG5ldyBOb2RlKCksIGNsYXNzQm9keSwgcHJldmlvdXNTdHJpY3QgPSBzdHJpY3Q7XG4gICAgICAgIHN0cmljdCA9IHRydWU7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnY2xhc3MnKTtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2V4dGVuZHMnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBzdXBlckNsYXNzID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzQm9keSA9IHBhcnNlQ2xhc3NCb2R5KCk7XG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjbGFzc05vZGUuZmluaXNoQ2xhc3NFeHByZXNzaW9uKGlkLCBzdXBlckNsYXNzLCBjbGFzc0JvZHkpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDE1LjIgTW9kdWxlc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VNb2R1bGVTcGVjaWZpZXIoKSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSW52YWxpZE1vZHVsZVNwZWNpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoTGl0ZXJhbChsZXgoKSk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTUuMi4zIEV4cG9ydHNcblxuICAgIGZ1bmN0aW9uIHBhcnNlRXhwb3J0U3BlY2lmaWVyKCkge1xuICAgICAgICB2YXIgZXhwb3J0ZWQsIGxvY2FsLCBub2RlID0gbmV3IE5vZGUoKSwgZGVmO1xuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgIC8vIGV4cG9ydCB7ZGVmYXVsdH0gZnJvbSAnc29tZXRoaW5nJztcbiAgICAgICAgICAgIGRlZiA9IG5ldyBOb2RlKCk7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGxvY2FsID0gZGVmLmZpbmlzaElkZW50aWZpZXIoJ2RlZmF1bHQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvY2FsID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXMnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBleHBvcnRlZCA9IHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cG9ydFNwZWNpZmllcihsb2NhbCwgZXhwb3J0ZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRXhwb3J0TmFtZWREZWNsYXJhdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IG51bGwsXG4gICAgICAgICAgICBpc0V4cG9ydEZyb21JZGVudGlmaWVyLFxuICAgICAgICAgICAgc3JjID0gbnVsbCwgc3BlY2lmaWVycyA9IFtdO1xuXG4gICAgICAgIC8vIG5vbi1kZWZhdWx0IGV4cG9ydFxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIC8vIGNvdmVyczpcbiAgICAgICAgICAgIC8vIGV4cG9ydCB2YXIgZiA9IDE7XG4gICAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xldCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29uc3QnOlxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHBhcnNlTGV4aWNhbERlY2xhcmF0aW9uKHtpbkZvcjogZmFsc2V9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgc3BlY2lmaWVycywgbnVsbCk7XG4gICAgICAgICAgICAgICAgY2FzZSAndmFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgc3BlY2lmaWVycywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ3snKTtcbiAgICAgICAgd2hpbGUgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICBpc0V4cG9ydEZyb21JZGVudGlmaWVyID0gaXNFeHBvcnRGcm9tSWRlbnRpZmllciB8fCBtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKTtcbiAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaChwYXJzZUV4cG9ydFNwZWNpZmllcigpKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICBpZiAobWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcmluZzpcbiAgICAgICAgICAgIC8vIGV4cG9ydCB7ZGVmYXVsdH0gZnJvbSAnZm9vJztcbiAgICAgICAgICAgIC8vIGV4cG9ydCB7Zm9vfSBmcm9tICdmb28nO1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBzcmMgPSBwYXJzZU1vZHVsZVNwZWNpZmllcigpO1xuICAgICAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRXhwb3J0RnJvbUlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIC8vIGNvdmVyaW5nOlxuICAgICAgICAgICAgLy8gZXhwb3J0IHtkZWZhdWx0fTsgLy8gbWlzc2luZyBmcm9tQ2xhdXNlXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGxvb2thaGVhZC52YWx1ZSA/XG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiA6IE1lc3NhZ2VzLk1pc3NpbmdGcm9tQ2xhdXNlLCBsb29rYWhlYWQudmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY292ZXJcbiAgICAgICAgICAgIC8vIGV4cG9ydCB7Zm9vfTtcbiAgICAgICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHBvcnROYW1lZERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCBzcGVjaWZpZXJzLCBzcmMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gbnVsbCxcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBudWxsO1xuXG4gICAgICAgIC8vIGNvdmVyczpcbiAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgLi4uXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2RlZmF1bHQnKTtcblxuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb28gKCkge31cbiAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHt9XG4gICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihuZXcgTm9kZSgpLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnY2xhc3MnKSkge1xuICAgICAgICAgICAgZGVjbGFyYXRpb24gPSBwYXJzZUNsYXNzRGVjbGFyYXRpb24odHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIGxvb2thaGVhZC52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IHt9O1xuICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBbXTtcbiAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgKDEgKyAyKTtcbiAgICAgICAgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBwYXJzZU9iamVjdEluaXRpYWxpemVyKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHBhcnNlQXJyYXlJbml0aWFsaXplcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihleHByZXNzaW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUV4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHNyYztcblxuICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgIC8vIGV4cG9ydCAqIGZyb20gJ2Zvbyc7XG4gICAgICAgIGV4cGVjdCgnKicpO1xuICAgICAgICBpZiAoIW1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihsb29rYWhlYWQudmFsdWUgP1xuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4gOiBNZXNzYWdlcy5NaXNzaW5nRnJvbUNsYXVzZSwgbG9va2FoZWFkLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXgoKTtcbiAgICAgICAgc3JjID0gcGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cG9ydEFsbERlY2xhcmF0aW9uKHNyYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHBvcnREZWNsYXJhdGlvbigpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgTm9kZSgpO1xuICAgICAgICBpZiAoc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSWxsZWdhbEV4cG9ydERlY2xhcmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2V4cG9ydCcpO1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCgnKicpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VFeHBvcnROYW1lZERlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDE1LjIuMiBJbXBvcnRzXG5cbiAgICBmdW5jdGlvbiBwYXJzZUltcG9ydFNwZWNpZmllcigpIHtcbiAgICAgICAgLy8gaW1wb3J0IHs8Zm9vIGFzIGJhcj59IC4uLjtcbiAgICAgICAgdmFyIGxvY2FsLCBpbXBvcnRlZCwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgaW1wb3J0ZWQgPSBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcbiAgICAgICAgaWYgKG1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgbG9jYWwgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSW1wb3J0U3BlY2lmaWVyKGxvY2FsLCBpbXBvcnRlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VOYW1lZEltcG9ydHMoKSB7XG4gICAgICAgIHZhciBzcGVjaWZpZXJzID0gW107XG4gICAgICAgIC8vIHtmb28sIGJhciBhcyBiYXN9XG4gICAgICAgIGV4cGVjdCgneycpO1xuICAgICAgICB3aGlsZSAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaChwYXJzZUltcG9ydFNwZWNpZmllcigpKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJ30nKTtcbiAgICAgICAgcmV0dXJuIHNwZWNpZmllcnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJbXBvcnREZWZhdWx0U3BlY2lmaWVyKCkge1xuICAgICAgICAvLyBpbXBvcnQgPGZvbz4gLi4uO1xuICAgICAgICB2YXIgbG9jYWwsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGxvY2FsID0gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSW1wb3J0RGVmYXVsdFNwZWNpZmllcihsb2NhbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSB7XG4gICAgICAgIC8vIGltcG9ydCA8KiBhcyBmb28+IC4uLjtcbiAgICAgICAgdmFyIGxvY2FsLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBleHBlY3QoJyonKTtcbiAgICAgICAgaWYgKCFtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLk5vQXNBZnRlckltcG9ydE5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV4KCk7XG4gICAgICAgIGxvY2FsID0gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKGxvY2FsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUltcG9ydERlY2xhcmF0aW9uKCkge1xuICAgICAgICB2YXIgc3BlY2lmaWVycyA9IFtdLCBzcmMsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGlmIChzdGF0ZS5pbkZ1bmN0aW9uQm9keSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsSW1wb3J0RGVjbGFyYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnaW1wb3J0Jyk7XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICAvLyBpbXBvcnQgJ2Zvbyc7XG4gICAgICAgICAgICBzcmMgPSBwYXJzZU1vZHVsZVNwZWNpZmllcigpO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAobWF0Y2goJ3snKSkge1xuICAgICAgICAgICAgICAgIC8vIGltcG9ydCB7YmFyfVxuICAgICAgICAgICAgICAgIHNwZWNpZmllcnMgPSBzcGVjaWZpZXJzLmNvbmNhdChwYXJzZU5hbWVkSW1wb3J0cygpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJyonKSkge1xuICAgICAgICAgICAgICAgIC8vIGltcG9ydCAqIGFzIGZvb1xuICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaChwYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllcigpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNJZGVudGlmaWVyTmFtZShsb29rYWhlYWQpICYmICFtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgICAgIC8vIGltcG9ydCBmb29cbiAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2gocGFyc2VJbXBvcnREZWZhdWx0U3BlY2lmaWVyKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2goJyonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1wb3J0IGZvbywgKiBhcyBmb29cbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaChwYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllcigpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbXBvcnQgZm9vLCB7YmFyfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVycyA9IHNwZWNpZmllcnMuY29uY2F0KHBhcnNlTmFtZWRJbXBvcnRzKCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obGV4KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IobG9va2FoZWFkLnZhbHVlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiA6IE1lc3NhZ2VzLk1pc3NpbmdGcm9tQ2xhdXNlLCBsb29rYWhlYWQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBzcmMgPSBwYXJzZU1vZHVsZVNwZWNpZmllcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hJbXBvcnREZWNsYXJhdGlvbihzcGVjaWZpZXJzLCBzcmMpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDE1LjEgU2NyaXB0c1xuXG4gICAgZnVuY3Rpb24gcGFyc2VTY3JpcHRCb2R5KCkge1xuICAgICAgICB2YXIgc3RhdGVtZW50LCBib2R5ID0gW10sIHRva2VuLCBkaXJlY3RpdmUsIGZpcnN0UmVzdHJpY3RlZDtcblxuICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVN0YXRlbWVudExpc3RJdGVtKCk7XG4gICAgICAgICAgICBib2R5LnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgICAgIGlmIChzdGF0ZW1lbnQuZXhwcmVzc2lvbi50eXBlICE9PSBTeW50YXguTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IGRpcmVjdGl2ZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlyZWN0aXZlID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0ICsgMSwgdG9rZW4uZW5kIC0gMSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlID09PSAndXNlIHN0cmljdCcpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdFJlc3RyaWN0ZWQgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YXRlbWVudCA9IHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5LnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVByb2dyYW0oKSB7XG4gICAgICAgIHZhciBib2R5LCBub2RlO1xuXG4gICAgICAgIHBlZWsoKTtcbiAgICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlU2NyaXB0Qm9keSgpO1xuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9ncmFtKGJvZHksIHN0YXRlLnNvdXJjZVR5cGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlclRva2VuTG9jYXRpb24oKSB7XG4gICAgICAgIHZhciBpLCBlbnRyeSwgdG9rZW4sIHRva2VucyA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHRyYS50b2tlbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gZXh0cmEudG9rZW5zW2ldO1xuICAgICAgICAgICAgdG9rZW4gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogZW50cnkudHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZW50cnkudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZW50cnkucmVnZXgpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi5yZWdleCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogZW50cnkucmVnZXgucGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IGVudHJ5LnJlZ2V4LmZsYWdzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgICAgIHRva2VuLnJhbmdlID0gZW50cnkucmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ubG9jID0gZW50cnkubG9jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgZXh0cmEudG9rZW5zID0gdG9rZW5zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuaXplKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XG4gICAgICAgIHZhciB0b1N0cmluZyxcbiAgICAgICAgICAgIHRva2VucztcblxuICAgICAgICB0b1N0cmluZyA9IFN0cmluZztcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJyAmJiAhKGNvZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgICAgICBjb2RlID0gdG9TdHJpbmcoY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzb3VyY2UgPSBjb2RlO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGxpbmVOdW1iZXIgPSAoc291cmNlLmxlbmd0aCA+IDApID8gMSA6IDA7XG4gICAgICAgIGxpbmVTdGFydCA9IDA7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgc3RhcnRMaW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIGxvb2thaGVhZCA9IG51bGw7XG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93WWllbGQ6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFNldDoge30sXG4gICAgICAgICAgICBpbkZ1bmN0aW9uQm9keTogZmFsc2UsXG4gICAgICAgICAgICBpbkl0ZXJhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBpblN3aXRjaDogZmFsc2UsXG4gICAgICAgICAgICBsYXN0Q29tbWVudFN0YXJ0OiAtMSxcbiAgICAgICAgICAgIGN1cmx5U3RhY2s6IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgZXh0cmEgPSB7fTtcblxuICAgICAgICAvLyBPcHRpb25zIG1hdGNoaW5nLlxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvLyBPZiBjb3Vyc2Ugd2UgY29sbGVjdCB0b2tlbnMgaGVyZS5cbiAgICAgICAgb3B0aW9ucy50b2tlbnMgPSB0cnVlO1xuICAgICAgICBleHRyYS50b2tlbnMgPSBbXTtcbiAgICAgICAgZXh0cmEudG9rZW5WYWx1ZXMgPSBbXTtcbiAgICAgICAgZXh0cmEudG9rZW5pemUgPSB0cnVlO1xuICAgICAgICBleHRyYS5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgdHdvIGZpZWxkcyBhcmUgbmVjZXNzYXJ5IHRvIGNvbXB1dGUgdGhlIFJlZ2V4IHRva2Vucy5cbiAgICAgICAgZXh0cmEub3BlblBhcmVuVG9rZW4gPSAtMTtcbiAgICAgICAgZXh0cmEub3BlbkN1cmx5VG9rZW4gPSAtMTtcblxuICAgICAgICBleHRyYS5yYW5nZSA9ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlO1xuICAgICAgICBleHRyYS5sb2MgPSAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5jb21tZW50KSB7XG4gICAgICAgICAgICBleHRyYS5jb21tZW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICAgIGV4dHJhLmVycm9ycyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBlZWsoKTtcbiAgICAgICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhLnRva2VucztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB3aGlsZSAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGxleEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZEVycm9yKGxleEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gYnJlYWsgb24gdGhlIGZpcnN0IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBpbmZpbml0ZSBsb29wcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbGV4RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuZXJyb3JzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRva2Vucy5lcnJvcnMgPSBleHRyYS5lcnJvcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBleHRyYSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2UoY29kZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcHJvZ3JhbSwgdG9TdHJpbmc7XG5cbiAgICAgICAgdG9TdHJpbmcgPSBTdHJpbmc7XG4gICAgICAgIGlmICh0eXBlb2YgY29kZSAhPT0gJ3N0cmluZycgJiYgIShjb2RlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgICAgICAgY29kZSA9IHRvU3RyaW5nKGNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc291cmNlID0gY29kZTtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICBsaW5lTnVtYmVyID0gKHNvdXJjZS5sZW5ndGggPiAwKSA/IDEgOiAwO1xuICAgICAgICBsaW5lU3RhcnQgPSAwO1xuICAgICAgICBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgIHN0YXJ0TGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgIHN0YXJ0TGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICBhbGxvd1lpZWxkOiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxTZXQ6IHt9LFxuICAgICAgICAgICAgaW5GdW5jdGlvbkJvZHk6IGZhbHNlLFxuICAgICAgICAgICAgaW5JdGVyYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgaW5Td2l0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgbGFzdENvbW1lbnRTdGFydDogLTEsXG4gICAgICAgICAgICBjdXJseVN0YWNrOiBbXSxcbiAgICAgICAgICAgIHNvdXJjZVR5cGU6ICdzY3JpcHQnXG4gICAgICAgIH07XG4gICAgICAgIHN0cmljdCA9IGZhbHNlO1xuXG4gICAgICAgIGV4dHJhID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGV4dHJhLnJhbmdlID0gKHR5cGVvZiBvcHRpb25zLnJhbmdlID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMucmFuZ2U7XG4gICAgICAgICAgICBleHRyYS5sb2MgPSAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jO1xuICAgICAgICAgICAgZXh0cmEuYXR0YWNoQ29tbWVudCA9ICh0eXBlb2Ygb3B0aW9ucy5hdHRhY2hDb21tZW50ID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMuYXR0YWNoQ29tbWVudDtcblxuICAgICAgICAgICAgaWYgKGV4dHJhLmxvYyAmJiBvcHRpb25zLnNvdXJjZSAhPT0gbnVsbCAmJiBvcHRpb25zLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXh0cmEuc291cmNlID0gdG9TdHJpbmcob3B0aW9ucy5zb3VyY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9rZW5zID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBleHRyYS50b2tlbnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgZXh0cmEuY29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5hdHRhY2hDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgZXh0cmEucmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGV4dHJhLmNvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgZXh0cmEuYm90dG9tUmlnaHRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICAgIGV4dHJhLnRyYWlsaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBleHRyYS5sZWFkaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNvdXJjZVR5cGUgPT09ICdtb2R1bGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gdmVyeSByZXN0cmljdGl2ZSBjb25kaXRpb24gZm9yIG5vd1xuICAgICAgICAgICAgICAgIHN0YXRlLnNvdXJjZVR5cGUgPSBvcHRpb25zLnNvdXJjZVR5cGU7XG4gICAgICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9ncmFtID0gcGFyc2VQcm9ncmFtKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmNvbW1lbnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHByb2dyYW0uY29tbWVudHMgPSBleHRyYS5jb21tZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGZpbHRlclRva2VuTG9jYXRpb24oKTtcbiAgICAgICAgICAgICAgICBwcm9ncmFtLnRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuZXJyb3JzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHByb2dyYW0uZXJyb3JzID0gZXh0cmEuZXJyb3JzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cblxuICAgIC8vIFN5bmMgd2l0aCAqLmpzb24gbWFuaWZlc3RzLlxuICAgIGV4cG9ydHMudmVyc2lvbiA9ICcyLjcuMCc7XG5cbiAgICBleHBvcnRzLnRva2VuaXplID0gdG9rZW5pemU7XG5cbiAgICBleHBvcnRzLnBhcnNlID0gcGFyc2U7XG5cbiAgICAvLyBEZWVwIGNvcHkuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBleHBvcnRzLlN5bnRheCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuYW1lLCB0eXBlcyA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHlwZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChuYW1lIGluIFN5bnRheCkge1xuICAgICAgICAgICAgaWYgKFN5bnRheC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIHR5cGVzW25hbWVdID0gU3ludGF4W25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZnJlZXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHR5cGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICB9KCkpO1xuXG59KSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIiwiLypcclxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxyXG4qXHJcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxyXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuKi9cclxuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xyXG4gICAgfVxyXG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzZWxmID0ge307XHJcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XHJcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gV2UgY2FuJ3QgYnVpbGQgYSByZWFsIG1ldGhvZCB3aXRob3V0IGEgY29uc29sZSB0byBsb2cgdG9cclxuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub29wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgc2VsZlttZXRob2ROYW1lXS5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcclxuICAgICAgICBcInRyYWNlXCIsXHJcbiAgICAgICAgXCJkZWJ1Z1wiLFxyXG4gICAgICAgIFwiaW5mb1wiLFxyXG4gICAgICAgIFwid2FyblwiLFxyXG4gICAgICAgIFwiZXJyb3JcIlxyXG4gICAgXTtcclxuXHJcbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xyXG4gICAgICAgICAgICBzZWxmW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgPyBub29wIDogc2VsZi5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xyXG4gICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVsnbG9nbGV2ZWwnXSA9IGxldmVsTmFtZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cclxuXHJcbiAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9IFwibG9nbGV2ZWw9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcclxuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbG9hZFBlcnNpc3RlZExldmVsKCkge1xyXG4gICAgICAgIHZhciBzdG9yZWRMZXZlbDtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlWydsb2dsZXZlbCddO1xyXG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvbG9nbGV2ZWw9KFteO10rKS8uZXhlYyh3aW5kb3cuZG9jdW1lbnQuY29va2llKVsxXTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSBcIldBUk5cIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgICpcclxuICAgICAqIFB1YmxpYyBBUElcclxuICAgICAqXHJcbiAgICAgKi9cclxuXHJcbiAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcclxuICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xyXG5cclxuICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBsZXZlbCkge1xyXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XHJcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcclxuICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XHJcbiAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5UKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXHJcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XHJcbiAgICBzZWxmLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxyXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBzZWxmKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9O1xyXG5cclxuICAgIGxvYWRQZXJzaXN0ZWRMZXZlbCgpO1xyXG4gICAgcmV0dXJuIHNlbGY7XHJcbn0pKTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2hpdGVMaXN0ID0gWydub3QnLCAnYW55JywgJ2FsbCcsICdub25lJ107XG5cblxuZnVuY3Rpb24gbm90TnVsbCh4KSAgeyByZXR1cm4geCAhPSBudWxsOyB9XG5mdW5jdGlvbiB0b1N0cmluZyh4KSB7IHJldHVybiB4LnRvU3RyaW5nKCk7IH1cbmZ1bmN0aW9uIHdyYXAoeCkgICAgIHsgcmV0dXJuICcoJyArIHggKyAnKSc7fVxuXG5mdW5jdGlvbiBtYXliZVF1b3RlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuICdcIicgKyB2YWx1ZSArICdcIic7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gbG9va1VwKGtleSkge1xuICAgIGlmIChrZXkubGFzdEluZGV4T2YoJyQnKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJ2NvbnRleHQuJyArIGtleS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIHJldHVybiAnY29udGV4dC5mZWF0dXJlLnByb3BlcnRpZXMuJyArIGtleTtcbn1cblxuZnVuY3Rpb24gbnVsbFZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnbnVsbFZhbHVlJyxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyB0cnVlICc7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUVxdWFsKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAncHJvcGVydHlFcXVhbCcsXG4gICAgICAgIG9wdDogJz09PScgLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAobWF5YmVRdW90ZSh0aGlzLnZhbHVlKSArICcgJyArIHRoaXMub3B0ICsgJyAnICsgbG9va1VwKGtleSkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlPcihrZXksIHZhbHVlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdwcm9wZXJ0eU9yJyxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlczogdmFsdWVzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gcHJvcGVydHlFcXVhbChrZXksIHgpOyB9KSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwKHRoaXMudmFsdWVzLm1hcCh0b1N0cmluZykuam9pbignIHx8ICcpKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG5vdChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ25vdFByb3BlcnR5JyxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiBwYXJzZUZpbHRlcih2YWx1ZSksXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyEnICsgd3JhcCh0aGlzLnZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbm9uZShrZXksIHZhbHVlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdub25lJyxcbiAgICAgICAgdmFsdWVzOiBhbnkobnVsbCwgdmFsdWVzKSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnIScgKyB3cmFwKHRoaXMudmFsdWVzLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcHJpbnROZXN0ZWQodmFsdWVzLCBqb2luZXIpIHtcbiAgICByZXR1cm4gd3JhcCh2YWx1ZXMuZmlsdGVyKG5vdE51bGwpLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gd3JhcCh4LmpvaW4oJyAmJiAnKSk7XG4gICAgfSkuam9pbignICcgKyBqb2luZXIgKyAnICcpKTtcbn1cblxuZnVuY3Rpb24gYW55KF8sIHZhbHVlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdhbnknLFxuICAgICAgICB2YWx1ZXM6IHZhbHVlcy5tYXAocGFyc2VGaWx0ZXIpLFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50TmVzdGVkKHRoaXMudmFsdWVzLCAnfHwnKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFsbChfLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnYWxsJyxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMuZmlsdGVyKG5vdE51bGwpLm1hcChwYXJzZUZpbHRlciksXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbnROZXN0ZWQodGhpcy52YWx1ZXMsICcmJicpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlNYXRjaGVzQm9vbGVhbihrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3Byb3BlcnR5TWF0Y2hlc0Jvb2xlYW4nLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAobG9va1VwKHRoaXMua2V5KSArICh0aGlzLnZhbHVlID8gJyAhPSAnIDogJyA9PSAnKSAgKyAnbnVsbCcpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcmFuZ2VNYXRjaChrZXksIHZhbHVlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdyYW5nZU1hdGNoJyxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlcy5tYXgpIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKCcnICsgbG9va1VwKGtleSkgKyAnIDwgJyArIHRoaXMudmFsdWVzLm1heCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlcy5taW4pIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKCcnICsgbG9va1VwKGtleSkgKyAnID49ICcgKyB0aGlzLnZhbHVlcy5taW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gd3JhcChleHByZXNzaW9ucy5qb2luKCcgJiYgJykpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXIoZmlsdGVyKSB7XG4gICAgdmFyIGZpbHRlckFTVCA9IFtdO1xuXG4gICAgLy8gRnVuY3Rpb24gZmlsdGVyXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmlsdGVyQVNULnB1c2god3JhcChmaWx0ZXIudG9TdHJpbmcoKSArICcoY29udGV4dCknKSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJBU1Q7XG4gICAgfVxuICAgIC8vIEFycmF5IGZpbHRlciwgaW1wbGljaXQgJ2FueSdcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcikpIHtcbiAgICAgICAgZmlsdGVyQVNULnB1c2goYW55KG51bGwsIGZpbHRlcikpO1xuICAgICAgICByZXR1cm4gZmlsdGVyQVNUO1xuICAgIH1cblxuICAgIC8vIE9iamVjdCBmaWx0ZXIsIGUuZy4gaW1wbGljaXQgJ2FsbCdcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZpbHRlcik7XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGlkeCkge1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IGZpbHRlcltrZXldLFxuICAgICAgICAgICAgdHlwZSAgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZmlsdGVyQVNULnB1c2gocHJvcGVydHlFcXVhbChrZXksIHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChwcm9wZXJ0eU1hdGNoZXNCb29sZWFuKGtleSwgdmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChudWxsVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHdoaXRlTGlzdC5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ25vdCc6XG4gICAgICAgICAgICAgICAgZmlsdGVyQVNULnB1c2gobm90KGtleSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FueSc6XG4gICAgICAgICAgICAgICAgZmlsdGVyQVNULnB1c2goYW55KGtleSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FsbCc6XG4gICAgICAgICAgICAgICAgZmlsdGVyQVNULnB1c2goYWxsKGtleSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKG5vbmUoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBXaGl0ZUxpc3RlZCBwcm9wZXJ0eTogJyArIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKHByb3BlcnR5T3Ioa2V5LCB2YWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5tYXggfHwgdmFsdWUubWluKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyQVNULnB1c2gocmFuZ2VNYXRjaChrZXksIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gUXVlcnkgc3l0bmF4OiAnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ga2V5cy5sZW5ndGggPT09IDAgPyBbJ3RydWUnXSA6IGZpbHRlckFTVDtcbn1cblxuZnVuY3Rpb24gZmlsdGVyVG9TdHJpbmcoZmlsdGVyQVNUKSB7XG4gICAgcmV0dXJuIHdyYXAoZmlsdGVyQVNULmpvaW4oJyAmJiAnKSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIgPT0gbnVsbCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTsgfVxuICAgIC8vIGpzaGludCBldmlsOiB0cnVlXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbignY29udGV4dCcsICdyZXR1cm4gJyArIGZpbHRlclRvU3RyaW5nKHBhcnNlRmlsdGVyKGZpbHRlcikpICsgJzsnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbWF0Y2g6IG1hdGNoLFxuICAgIGZpbHRlclRvU3RyaW5nOiBmaWx0ZXJUb1N0cmluZyxcbiAgICBwYXJzZUZpbHRlcjogcGFyc2VGaWx0ZXJcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGxpZ2h0d2VpZ2h0IEJ1ZmZlciBzaGltIGZvciBwYmYgYnJvd3NlciBidWlsZFxuLy8gYmFzZWQgb24gY29kZSBmcm9tIGdpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlciAoTUlULWxpY2Vuc2VkKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcjtcblxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0Jyk7XG5cbnZhciBCdWZmZXJNZXRob2RzO1xuXG5mdW5jdGlvbiBCdWZmZXIobGVuZ3RoKSB7XG4gICAgdmFyIGFycjtcbiAgICBpZiAobGVuZ3RoICYmIGxlbmd0aC5sZW5ndGgpIHtcbiAgICAgICAgYXJyID0gbGVuZ3RoO1xuICAgICAgICBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoIHx8IDApO1xuICAgIGlmIChhcnIpIGJ1Zi5zZXQoYXJyKTtcblxuICAgIGJ1Zi5yZWFkVUludDMyTEUgPSBCdWZmZXJNZXRob2RzLnJlYWRVSW50MzJMRTtcbiAgICBidWYud3JpdGVVSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVVSW50MzJMRTtcbiAgICBidWYucmVhZEludDMyTEUgPSBCdWZmZXJNZXRob2RzLnJlYWRJbnQzMkxFO1xuICAgIGJ1Zi53cml0ZUludDMyTEUgPSBCdWZmZXJNZXRob2RzLndyaXRlSW50MzJMRTtcbiAgICBidWYucmVhZEZsb2F0TEUgPSBCdWZmZXJNZXRob2RzLnJlYWRGbG9hdExFO1xuICAgIGJ1Zi53cml0ZUZsb2F0TEUgPSBCdWZmZXJNZXRob2RzLndyaXRlRmxvYXRMRTtcbiAgICBidWYucmVhZERvdWJsZUxFID0gQnVmZmVyTWV0aG9kcy5yZWFkRG91YmxlTEU7XG4gICAgYnVmLndyaXRlRG91YmxlTEUgPSBCdWZmZXJNZXRob2RzLndyaXRlRG91YmxlTEU7XG4gICAgYnVmLnRvU3RyaW5nID0gQnVmZmVyTWV0aG9kcy50b1N0cmluZztcbiAgICBidWYud3JpdGUgPSBCdWZmZXJNZXRob2RzLndyaXRlO1xuICAgIGJ1Zi5zbGljZSA9IEJ1ZmZlck1ldGhvZHMuc2xpY2U7XG4gICAgYnVmLmNvcHkgPSBCdWZmZXJNZXRob2RzLmNvcHk7XG5cbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZTtcbiAgICByZXR1cm4gYnVmO1xufVxuXG52YXIgbGFzdFN0ciwgbGFzdFN0ckVuY29kZWQ7XG5cbkJ1ZmZlck1ldGhvZHMgPSB7XG4gICAgcmVhZFVJbnQzMkxFOiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgcmV0dXJuICgodGhpc1twb3NdKSB8XG4gICAgICAgICAgICAodGhpc1twb3MgKyAxXSA8PCA4KSB8XG4gICAgICAgICAgICAodGhpc1twb3MgKyAyXSA8PCAxNikpICtcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDNdICogMHgxMDAwMDAwKTtcbiAgICB9LFxuXG4gICAgd3JpdGVVSW50MzJMRTogZnVuY3Rpb24odmFsLCBwb3MpIHtcbiAgICAgICAgdGhpc1twb3NdID0gdmFsO1xuICAgICAgICB0aGlzW3BvcyArIDFdID0gKHZhbCA+Pj4gOCk7XG4gICAgICAgIHRoaXNbcG9zICsgMl0gPSAodmFsID4+PiAxNik7XG4gICAgICAgIHRoaXNbcG9zICsgM10gPSAodmFsID4+PiAyNCk7XG4gICAgfSxcblxuICAgIHJlYWRJbnQzMkxFOiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgcmV0dXJuICgodGhpc1twb3NdKSB8XG4gICAgICAgICAgICAodGhpc1twb3MgKyAxXSA8PCA4KSB8XG4gICAgICAgICAgICAodGhpc1twb3MgKyAyXSA8PCAxNikpICtcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDNdIDw8IDI0KTtcbiAgICB9LFxuXG4gICAgcmVhZEZsb2F0TEU6ICBmdW5jdGlvbihwb3MpIHsgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBwb3MsIHRydWUsIDIzLCA0KTsgfSxcbiAgICByZWFkRG91YmxlTEU6IGZ1bmN0aW9uKHBvcykgeyByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIHBvcywgdHJ1ZSwgNTIsIDgpOyB9LFxuXG4gICAgd3JpdGVGbG9hdExFOiAgZnVuY3Rpb24odmFsLCBwb3MpIHsgcmV0dXJuIGllZWU3NTQud3JpdGUodGhpcywgdmFsLCBwb3MsIHRydWUsIDIzLCA0KTsgfSxcbiAgICB3cml0ZURvdWJsZUxFOiBmdW5jdGlvbih2YWwsIHBvcykgeyByZXR1cm4gaWVlZTc1NC53cml0ZSh0aGlzLCB2YWwsIHBvcywgdHJ1ZSwgNTIsIDgpOyB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBzdHIgPSAnJyxcbiAgICAgICAgICAgIHRtcCA9ICcnO1xuXG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICAgICAgZW5kID0gTWF0aC5taW4odGhpcy5sZW5ndGgsIGVuZCB8fCB0aGlzLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHRoaXNbaV07XG4gICAgICAgICAgICBpZiAoY2ggPD0gMHg3Rikge1xuICAgICAgICAgICAgICAgIHN0ciArPSBkZWNvZGVVUklDb21wb25lbnQodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICAgICAgICAgIHRtcCA9ICcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0bXAgKz0gJyUnICsgY2gudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9IGRlY29kZVVSSUNvbXBvbmVudCh0bXApO1xuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIHdyaXRlOiBmdW5jdGlvbihzdHIsIHBvcykge1xuICAgICAgICB2YXIgYnl0ZXMgPSBzdHIgPT09IGxhc3RTdHIgPyBsYXN0U3RyRW5jb2RlZCA6IGVuY29kZVN0cmluZyhzdHIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzW3BvcyArIGldID0gYnl0ZXNbaV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2xpY2U6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCk7XG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKGJ1ZiwgcG9zKSB7XG4gICAgICAgIHBvcyA9IHBvcyB8fCAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJ1Zltwb3MgKyBpXSA9IHRoaXNbaV07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5CdWZmZXJNZXRob2RzLndyaXRlSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVVSW50MzJMRTtcblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbihzdHIpIHtcbiAgICBsYXN0U3RyID0gc3RyO1xuICAgIGxhc3RTdHJFbmNvZGVkID0gZW5jb2RlU3RyaW5nKHN0cik7XG4gICAgcmV0dXJuIGxhc3RTdHJFbmNvZGVkLmxlbmd0aDtcbn07XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uKGJ1Zikge1xuICAgIHJldHVybiAhIShidWYgJiYgYnVmLl9pc0J1ZmZlcik7XG59O1xuXG5mdW5jdGlvbiBlbmNvZGVTdHJpbmcoc3RyKSB7XG4gICAgdmFyIGxlbmd0aCA9IHN0ci5sZW5ndGgsXG4gICAgICAgIGJ5dGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgYywgbGVhZDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTsgLy8gY29kZSBwb2ludFxuXG4gICAgICAgIGlmIChjID4gMHhEN0ZGICYmIGMgPCAweEUwMDApIHtcblxuICAgICAgICAgICAgaWYgKGxlYWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA8IDB4REMwMCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgICAgICAgICAgICBsZWFkID0gYztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjID0gbGVhZCAtIDB4RDgwMCA8PCAxMCB8IGMgLSAweERDMDAgfCAweDEwMDAwO1xuICAgICAgICAgICAgICAgICAgICBsZWFkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPiAweERCRkYgfHwgKGkgKyAxID09PSBsZW5ndGgpKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgICAgICAgIGVsc2UgbGVhZCA9IGM7XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGxlYWQpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgICBsZWFkID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgMHg4MCkgYnl0ZXMucHVzaChjKTtcbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSBieXRlcy5wdXNoKGMgPj4gMHg2IHwgMHhDMCwgYyAmIDB4M0YgfCAweDgwKTtcbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4MTAwMDApIGJ5dGVzLnB1c2goYyA+PiAweEMgfCAweEUwLCBjID4+IDB4NiAmIDB4M0YgfCAweDgwLCBjICYgMHgzRiB8IDB4ODApO1xuICAgICAgICBlbHNlIGJ5dGVzLnB1c2goYyA+PiAweDEyIHwgMHhGMCwgYyA+PiAweEMgJiAweDNGIHwgMHg4MCwgYyA+PiAweDYgJiAweDNGIHwgMHg4MCwgYyAmIDB4M0YgfCAweDgwKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBiZjtcblxudmFyIEJ1ZmZlciA9IGdsb2JhbC5CdWZmZXIgfHwgcmVxdWlyZSgnLi9idWZmZXInKTtcblxuZnVuY3Rpb24gUGJmKGJ1Zikge1xuICAgIHRoaXMuYnVmID0gIUJ1ZmZlci5pc0J1ZmZlcihidWYpID8gbmV3IEJ1ZmZlcihidWYgfHwgMCkgOiBidWY7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5idWYubGVuZ3RoO1xufVxuXG5QYmYuVmFyaW50ICA9IDA7IC8vIHZhcmludDogaW50MzIsIGludDY0LCB1aW50MzIsIHVpbnQ2NCwgc2ludDMyLCBzaW50NjQsIGJvb2wsIGVudW1cblBiZi5GaXhlZDY0ID0gMTsgLy8gNjQtYml0OiBkb3VibGUsIGZpeGVkNjQsIHNmaXhlZDY0XG5QYmYuQnl0ZXMgICA9IDI7IC8vIGxlbmd0aC1kZWxpbWl0ZWQ6IHN0cmluZywgYnl0ZXMsIGVtYmVkZGVkIG1lc3NhZ2VzLCBwYWNrZWQgcmVwZWF0ZWQgZmllbGRzXG5QYmYuRml4ZWQzMiA9IDU7IC8vIDMyLWJpdDogZmxvYXQsIGZpeGVkMzIsIHNmaXhlZDMyXG5cbnZhciBTSElGVF9MRUZUXzMyID0gKDEgPDwgMTYpICogKDEgPDwgMTYpLFxuICAgIFNISUZUX1JJR0hUXzMyID0gMSAvIFNISUZUX0xFRlRfMzIsXG4gICAgUE9XXzJfNjMgPSBNYXRoLnBvdygyLCA2Myk7XG5cblBiZi5wcm90b3R5cGUgPSB7XG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5idWYgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvLyA9PT0gUkVBRElORyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgcmVhZEZpZWxkczogZnVuY3Rpb24ocmVhZEZpZWxkLCByZXN1bHQsIGVuZCkge1xuICAgICAgICBlbmQgPSBlbmQgfHwgdGhpcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5yZWFkVmFyaW50KCksXG4gICAgICAgICAgICAgICAgdGFnID0gdmFsID4+IDMsXG4gICAgICAgICAgICAgICAgc3RhcnRQb3MgPSB0aGlzLnBvcztcblxuICAgICAgICAgICAgcmVhZEZpZWxkKHRhZywgcmVzdWx0LCB0aGlzKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBzdGFydFBvcykgdGhpcy5za2lwKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgcmVhZE1lc3NhZ2U6IGZ1bmN0aW9uKHJlYWRGaWVsZCwgcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRGaWVsZHMocmVhZEZpZWxkLCByZXN1bHQsIHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MpO1xuICAgIH0sXG5cbiAgICByZWFkRml4ZWQzMjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkU0ZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZEludDMyTEUodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICAvLyA2NC1iaXQgaW50IGhhbmRsaW5nIGlzIGJhc2VkIG9uIGdpdGh1Yi5jb20vZHB3L25vZGUtYnVmZmVyLW1vcmUtaW50cyAoTUlULWxpY2Vuc2VkKVxuXG4gICAgcmVhZEZpeGVkNjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zKSArIHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcyArIDQpICogU0hJRlRfTEVGVF8zMjtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgcmVhZFNGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcykgKyB0aGlzLmJ1Zi5yZWFkSW50MzJMRSh0aGlzLnBvcyArIDQpICogU0hJRlRfTEVGVF8zMjtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgcmVhZEZsb2F0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRGbG9hdExFKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgcmVhZERvdWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkRG91YmxlTEUodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkVmFyaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHRoaXMuYnVmLFxuICAgICAgICAgICAgdmFsLCBiLCBiMCwgYjEsIGIyLCBiMztcblxuICAgICAgICBiMCA9IGJ1Zlt0aGlzLnBvcysrXTsgaWYgKGIwIDwgMHg4MCkgcmV0dXJuIGIwOyAgICAgICAgICAgICAgICAgYjAgPSBiMCAmIDB4N2Y7XG4gICAgICAgIGIxID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjEgPCAweDgwKSByZXR1cm4gYjAgfCBiMSA8PCA3OyAgICAgICBiMSA9IChiMSAmIDB4N2YpIDw8IDc7XG4gICAgICAgIGIyID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjIgPCAweDgwKSByZXR1cm4gYjAgfCBiMSB8IGIyIDw8IDE0OyBiMiA9IChiMiAmIDB4N2YpIDw8IDE0O1xuICAgICAgICBiMyA9IGJ1Zlt0aGlzLnBvcysrXTsgaWYgKGIzIDwgMHg4MCkgcmV0dXJuIGIwIHwgYjEgfCBiMiB8IGIzIDw8IDIxO1xuXG4gICAgICAgIHZhbCA9IGIwIHwgYjEgfCBiMiB8IChiMyAmIDB4N2YpIDw8IDIxO1xuXG4gICAgICAgIGIgPSBidWZbdGhpcy5wb3MrK107IHZhbCArPSAoYiAmIDB4N2YpICogMHgxMDAwMDAwMDsgICAgICAgICBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7XG4gICAgICAgIGIgPSBidWZbdGhpcy5wb3MrK107IHZhbCArPSAoYiAmIDB4N2YpICogMHg4MDAwMDAwMDA7ICAgICAgICBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7XG4gICAgICAgIGIgPSBidWZbdGhpcy5wb3MrK107IHZhbCArPSAoYiAmIDB4N2YpICogMHg0MDAwMDAwMDAwMDsgICAgICBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7XG4gICAgICAgIGIgPSBidWZbdGhpcy5wb3MrK107IHZhbCArPSAoYiAmIDB4N2YpICogMHgyMDAwMDAwMDAwMDAwOyAgICBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7XG4gICAgICAgIGIgPSBidWZbdGhpcy5wb3MrK107IHZhbCArPSAoYiAmIDB4N2YpICogMHgxMDAwMDAwMDAwMDAwMDA7ICBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7XG4gICAgICAgIGIgPSBidWZbdGhpcy5wb3MrK107IHZhbCArPSAoYiAmIDB4N2YpICogMHg4MDAwMDAwMDAwMDAwMDAwOyBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YXJpbnQgbm90IG1vcmUgdGhhbiAxMCBieXRlcycpO1xuICAgIH0sXG5cbiAgICByZWFkVmFyaW50NjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnBvcyxcbiAgICAgICAgICAgIHZhbCA9IHRoaXMucmVhZFZhcmludCgpO1xuXG4gICAgICAgIGlmICh2YWwgPCBQT1dfMl82MykgcmV0dXJuIHZhbDtcblxuICAgICAgICB2YXIgcG9zID0gdGhpcy5wb3MgLSAyO1xuICAgICAgICB3aGlsZSAodGhpcy5idWZbcG9zXSA9PT0gMHhmZikgcG9zLS07XG4gICAgICAgIGlmIChwb3MgPCBzdGFydFBvcykgcG9zID0gc3RhcnRQb3M7XG5cbiAgICAgICAgdmFsID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3MgLSBzdGFydFBvcyArIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIGIgPSB+dGhpcy5idWZbc3RhcnRQb3MgKyBpXSAmIDB4N2Y7XG4gICAgICAgICAgICB2YWwgKz0gaSA8IDQgPyBiIDw8IGkgKiA3IDogYiAqIE1hdGgucG93KDIsIGkgKiA3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtdmFsIC0gMTtcbiAgICB9LFxuXG4gICAgcmVhZFNWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbnVtID0gdGhpcy5yZWFkVmFyaW50KCk7XG4gICAgICAgIHJldHVybiBudW0gJSAyID09PSAxID8gKG51bSArIDEpIC8gLTIgOiBudW0gLyAyOyAvLyB6aWd6YWcgZW5jb2RpbmdcbiAgICB9LFxuXG4gICAgcmVhZEJvb2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnJlYWRWYXJpbnQoKSk7XG4gICAgfSxcblxuICAgIHJlYWRTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcyxcbiAgICAgICAgICAgIHN0ciA9IHRoaXMuYnVmLnRvU3RyaW5nKCd1dGY4JywgdGhpcy5wb3MsIGVuZCk7XG4gICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cbiAgICByZWFkQnl0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcyxcbiAgICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuYnVmLnNsaWNlKHRoaXMucG9zLCBlbmQpO1xuICAgICAgICB0aGlzLnBvcyA9IGVuZDtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9LFxuXG4gICAgLy8gdmVyYm9zZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczsgZG9lc24ndCBhZmZlY3QgZ3ppcHBlZCBzaXplXG5cbiAgICByZWFkUGFja2VkVmFyaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZFZhcmludCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRTVmFyaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZFNWYXJpbnQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkQm9vbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRCb29sZWFuKCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZEZsb2F0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEZsb2F0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZERvdWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWREb3VibGUoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRml4ZWQzMjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGaXhlZDMyKCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZFNGaXhlZDMyKCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZEZpeGVkNjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRml4ZWQ2NCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRTRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRTRml4ZWQ2NCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuXG4gICAgc2tpcDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHZhciB0eXBlID0gdmFsICYgMHg3O1xuICAgICAgICBpZiAodHlwZSA9PT0gUGJmLlZhcmludCkgd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdID4gMHg3Zikge31cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gUGJmLkJ5dGVzKSB0aGlzLnBvcyA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3M7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBiZi5GaXhlZDMyKSB0aGlzLnBvcyArPSA0O1xuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuRml4ZWQ2NCkgdGhpcy5wb3MgKz0gODtcbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgdHlwZTogJyArIHR5cGUpO1xuICAgIH0sXG5cbiAgICAvLyA9PT0gV1JJVElORyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgd3JpdGVUYWc6IGZ1bmN0aW9uKHRhZywgdHlwZSkge1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KCh0YWcgPDwgMykgfCB0eXBlKTtcbiAgICB9LFxuXG4gICAgcmVhbGxvYzogZnVuY3Rpb24obWluKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAxNjtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoIDwgdGhpcy5wb3MgKyBtaW4pIGxlbmd0aCAqPSAyO1xuXG4gICAgICAgIGlmIChsZW5ndGggIT09IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5idWYuY29weShidWYpO1xuICAgICAgICAgICAgdGhpcy5idWYgPSBidWY7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zbGljZSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgfSxcblxuICAgIHdyaXRlRml4ZWQzMjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVVSW50MzJMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICB9LFxuXG4gICAgd3JpdGVTRml4ZWQzMjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVJbnQzMkxFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZUZpeGVkNjQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQzMkxFKE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCB0aGlzLnBvcyArIDQpO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgIH0sXG5cbiAgICB3cml0ZVNGaXhlZDY0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDgpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUodmFsICYgLTEsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVJbnQzMkxFKE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCB0aGlzLnBvcyArIDQpO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgIH0sXG5cbiAgICB3cml0ZVZhcmludDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHZhbCA9ICt2YWw7XG5cbiAgICAgICAgaWYgKHZhbCA8PSAweDdmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMSk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IHZhbDtcblxuICAgICAgICB9IGVsc2UgaWYgKHZhbCA8PSAweDNmZmYpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYygyKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDApICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gNykgJiAweDdmKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHZhbCA8PSAweDFmZmZmZikge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDMpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMCkgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiA3KSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDE0KSAmIDB4N2YpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4ZmZmZmZmZikge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMCkgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiA3KSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDE0KSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDIxKSAmIDB4N2YpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB3aGlsZSAodmFsID49IDB4ODApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWxsb2MoMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAodmFsICYgMHhmZikgfCAweDgwO1xuICAgICAgICAgICAgICAgIHZhbCAvPSAweDgwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDEpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSB2YWwgfCAwO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zIC0gcG9zID4gMTApIHRocm93IG5ldyBFcnJvcignR2l2ZW4gdmFyaW50IGRvZXNuXFwndCBmaXQgaW50byAxMCBieXRlcycpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHdyaXRlU1ZhcmludDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQodmFsIDwgMCA/IC12YWwgKiAyIC0gMSA6IHZhbCAqIDIpO1xuICAgIH0sXG5cbiAgICB3cml0ZUJvb2xlYW46IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KEJvb2xlYW4odmFsKSk7XG4gICAgfSxcblxuICAgIHdyaXRlU3RyaW5nOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICAgIHZhciBieXRlcyA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN0cik7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoYnl0ZXMpO1xuICAgICAgICB0aGlzLnJlYWxsb2MoYnl0ZXMpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZShzdHIsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gYnl0ZXM7XG4gICAgfSxcblxuICAgIHdyaXRlRmxvYXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlRmxvYXRMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICB9LFxuXG4gICAgd3JpdGVEb3VibGU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlRG91YmxlTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlQnl0ZXM6IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChsZW4pO1xuICAgICAgICB0aGlzLnJlYWxsb2MobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgdGhpcy5idWZbdGhpcy5wb3MrK10gPSBidWZmZXJbaV07XG4gICAgfSxcblxuICAgIHdyaXRlTWVzc2FnZTogZnVuY3Rpb24odGFnLCBmbiwgb2JqKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuXG4gICAgICAgIHRoaXMucG9zKys7IC8vIHJlc2VydmUgMSBieXRlIGZvciBzaG9ydCBtZXNzYWdlIGxlbmd0aFxuXG4gICAgICAgIC8vIHdyaXRlIHRoZSBtZXNzYWdlIGRpcmVjdGx5IHRvIHRoZSBidWZmZXIgYW5kIHNlZSBob3cgbXVjaCB3YXMgd3JpdHRlblxuICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgZm4ob2JqLCB0aGlzKTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMucG9zIC0gc3RhcnRQb3M7XG5cbiAgICAgICAgdmFyIHZhcmludExlbiA9XG4gICAgICAgICAgICBsZW4gPD0gMHg3ZiA/IDEgOlxuICAgICAgICAgICAgbGVuIDw9IDB4M2ZmZiA/IDIgOlxuICAgICAgICAgICAgbGVuIDw9IDB4MWZmZmZmID8gMyA6XG4gICAgICAgICAgICBsZW4gPD0gMHhmZmZmZmZmID8gNCA6IE1hdGguY2VpbChNYXRoLmxvZyhsZW4pIC8gKE1hdGguTE4yICogNykpO1xuXG4gICAgICAgIC8vIGlmIDEgYnl0ZSBpc24ndCBlbm91Z2ggZm9yIGVuY29kaW5nIG1lc3NhZ2UgbGVuZ3RoLCBzaGlmdCB0aGUgZGF0YSB0byB0aGUgcmlnaHRcbiAgICAgICAgaWYgKHZhcmludExlbiA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYyh2YXJpbnRMZW4gLSAxKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBvcyAtIDE7IGkgPj0gc3RhcnRQb3M7IGktLSkgdGhpcy5idWZbaSArIHZhcmludExlbiAtIDFdID0gdGhpcy5idWZbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5hbGx5LCB3cml0ZSB0aGUgbWVzc2FnZSBsZW5ndGggaW4gdGhlIHJlc2VydmVkIHBsYWNlIGFuZCByZXN0b3JlIHRoZSBwb3NpdGlvblxuICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0UG9zIC0gMTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChsZW4pO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW47XG4gICAgfSxcblxuICAgIHdyaXRlUGFja2VkVmFyaW50OiAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRWYXJpbnQsIGFycik7ICAgfSxcbiAgICB3cml0ZVBhY2tlZFNWYXJpbnQ6ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU1ZhcmludCwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRCb29sZWFuOiAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEJvb2xlYW4sIGFycik7ICB9LFxuICAgIHdyaXRlUGFja2VkRmxvYXQ6ICAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRGbG9hdCwgYXJyKTsgICAgfSxcbiAgICB3cml0ZVBhY2tlZERvdWJsZTogICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRG91YmxlLCBhcnIpOyAgIH0sXG4gICAgd3JpdGVQYWNrZWRGaXhlZDMyOiAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZpeGVkMzIsIGFycik7ICB9LFxuICAgIHdyaXRlUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRTRml4ZWQzMiwgYXJyKTsgfSxcbiAgICB3cml0ZVBhY2tlZEZpeGVkNjQ6ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRml4ZWQ2NCwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRTRml4ZWQ2NDogZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNGaXhlZDY0LCBhcnIpOyB9LFxuXG4gICAgd3JpdGVCeXRlc0ZpZWxkOiBmdW5jdGlvbih0YWcsIGJ1ZmZlcikge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkJ5dGVzKTtcbiAgICAgICAgdGhpcy53cml0ZUJ5dGVzKGJ1ZmZlcik7XG4gICAgfSxcbiAgICB3cml0ZUZpeGVkMzJGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDMyKTtcbiAgICAgICAgdGhpcy53cml0ZUZpeGVkMzIodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU0ZpeGVkMzJGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDMyKTtcbiAgICAgICAgdGhpcy53cml0ZVNGaXhlZDMyKHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZUZpeGVkNjRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcbiAgICAgICAgdGhpcy53cml0ZUZpeGVkNjQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU0ZpeGVkNjRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcbiAgICAgICAgdGhpcy53cml0ZVNGaXhlZDY0KHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZVZhcmludEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLlZhcmludCk7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU1ZhcmludEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLlZhcmludCk7XG4gICAgICAgIHRoaXMud3JpdGVTVmFyaW50KHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZVN0cmluZ0ZpZWxkOiBmdW5jdGlvbih0YWcsIHN0cikge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkJ5dGVzKTtcbiAgICAgICAgdGhpcy53cml0ZVN0cmluZyhzdHIpO1xuICAgIH0sXG4gICAgd3JpdGVGbG9hdEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlRmxvYXQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlRG91YmxlRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQ2NCk7XG4gICAgICAgIHRoaXMud3JpdGVEb3VibGUodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlQm9vbGVhbkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50RmllbGQodGFnLCBCb29sZWFuKHZhbCkpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHdyaXRlUGFja2VkVmFyaW50KGFyciwgcGJmKSAgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZVZhcmludChhcnJbaV0pOyAgIH1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkU1ZhcmludChhcnIsIHBiZikgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZVNWYXJpbnQoYXJyW2ldKTsgIH1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkRmxvYXQoYXJyLCBwYmYpICAgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZUZsb2F0KGFycltpXSk7ICAgIH1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkRG91YmxlKGFyciwgcGJmKSAgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZURvdWJsZShhcnJbaV0pOyAgIH1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkQm9vbGVhbihhcnIsIHBiZikgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZUJvb2xlYW4oYXJyW2ldKTsgIH1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkRml4ZWQzMihhcnIsIHBiZikgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZUZpeGVkMzIoYXJyW2ldKTsgIH1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkU0ZpeGVkMzIoYXJyLCBwYmYpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZVNGaXhlZDMyKGFycltpXSk7IH1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkRml4ZWQ2NChhcnIsIHBiZikgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZUZpeGVkNjQoYXJyW2ldKTsgIH1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkU0ZpeGVkNjQoYXJyLCBwYmYpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZVNGaXhlZDY0KGFycltpXSk7IH1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5d1ltWXZhVzVrWlhndWFuTWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CSWl3aVptbHNaU0k2SW1kbGJtVnlZWFJsWkM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SW5kWE5sSUhOMGNtbGpkQ2M3WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1VHSm1PMXh1WEc1MllYSWdRblZtWm1WeUlEMGdaMnh2WW1Gc0xrSjFabVpsY2lCOGZDQnlaWEYxYVhKbEtDY3VMMkoxWm1abGNpY3BPMXh1WEc1bWRXNWpkR2x2YmlCUVltWW9ZblZtS1NCN1hHNGdJQ0FnZEdocGN5NWlkV1lnUFNBaFFuVm1abVZ5TG1selFuVm1abVZ5S0dKMVppa2dQeUJ1WlhjZ1FuVm1abVZ5S0dKMVppQjhmQ0F3S1NBNklHSjFaanRjYmlBZ0lDQjBhR2x6TG5CdmN5QTlJREE3WEc0Z0lDQWdkR2hwY3k1c1pXNW5kR2dnUFNCMGFHbHpMbUoxWmk1c1pXNW5kR2c3WEc1OVhHNWNibEJpWmk1V1lYSnBiblFnSUQwZ01Ec2dMeThnZG1GeWFXNTBPaUJwYm5Rek1pd2dhVzUwTmpRc0lIVnBiblF6TWl3Z2RXbHVkRFkwTENCemFXNTBNeklzSUhOcGJuUTJOQ3dnWW05dmJDd2daVzUxYlZ4dVVHSm1Ma1pwZUdWa05qUWdQU0F4T3lBdkx5QTJOQzFpYVhRNklHUnZkV0pzWlN3Z1ptbDRaV1EyTkN3Z2MyWnBlR1ZrTmpSY2JsQmlaaTVDZVhSbGN5QWdJRDBnTWpzZ0x5OGdiR1Z1WjNSb0xXUmxiR2x0YVhSbFpEb2djM1J5YVc1bkxDQmllWFJsY3l3Z1pXMWlaV1JrWldRZ2JXVnpjMkZuWlhNc0lIQmhZMnRsWkNCeVpYQmxZWFJsWkNCbWFXVnNaSE5jYmxCaVppNUdhWGhsWkRNeUlEMGdOVHNnTHk4Z016SXRZbWwwT2lCbWJHOWhkQ3dnWm1sNFpXUXpNaXdnYzJacGVHVmtNekpjYmx4dWRtRnlJRk5JU1VaVVgweEZSbFJmTXpJZ1BTQW9NU0E4UENBeE5pa2dLaUFvTVNBOFBDQXhOaWtzWEc0Z0lDQWdVMGhKUmxSZlVrbEhTRlJmTXpJZ1BTQXhJQzhnVTBoSlJsUmZURVZHVkY4ek1peGNiaUFnSUNCUVQxZGZNbDgyTXlBOUlFMWhkR2d1Y0c5M0tESXNJRFl6S1R0Y2JseHVVR0ptTG5CeWIzUnZkSGx3WlNBOUlIdGNibHh1SUNBZ0lHUmxjM1J5YjNrNklHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekxtSjFaaUE5SUc1MWJHdzdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lDOHZJRDA5UFNCU1JVRkVTVTVISUQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVhHNWNiaUFnSUNCeVpXRmtSbWxsYkdSek9pQm1kVzVqZEdsdmJpaHlaV0ZrUm1sbGJHUXNJSEpsYzNWc2RDd2daVzVrS1NCN1hHNGdJQ0FnSUNBZ0lHVnVaQ0E5SUdWdVpDQjhmQ0IwYUdsekxteGxibWQwYUR0Y2JseHVJQ0FnSUNBZ0lDQjNhR2xzWlNBb2RHaHBjeTV3YjNNZ1BDQmxibVFwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFpoY2lCMllXd2dQU0IwYUdsekxuSmxZV1JXWVhKcGJuUW9LU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwWVdjZ1BTQjJZV3dnUGo0Z015eGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnpkR0Z5ZEZCdmN5QTlJSFJvYVhNdWNHOXpPMXh1WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaV0ZrUm1sbGJHUW9kR0ZuTENCeVpYTjFiSFFzSUhSb2FYTXBPMXh1WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvZEdocGN5NXdiM01nUFQwOUlITjBZWEowVUc5ektTQjBhR2x6TG5OcmFYQW9kbUZzS1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2NtVnpkV3gwTzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0J5WldGa1RXVnpjMkZuWlRvZ1puVnVZM1JwYjI0b2NtVmhaRVpwWld4a0xDQnlaWE4xYkhRcElIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11Y21WaFpFWnBaV3hrY3loeVpXRmtSbWxsYkdRc0lISmxjM1ZzZEN3Z2RHaHBjeTV5WldGa1ZtRnlhVzUwS0NrZ0t5QjBhR2x6TG5CdmN5azdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lISmxZV1JHYVhobFpETXlPaUJtZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0FnSUNBZ2RtRnlJSFpoYkNBOUlIUm9hWE11WW5WbUxuSmxZV1JWU1c1ME16Sk1SU2gwYUdsekxuQnZjeWs3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjRzl6SUNzOUlEUTdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjJZV3c3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJSEpsWVdSVFJtbDRaV1F6TWpvZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCMllXd2dQU0IwYUdsekxtSjFaaTV5WldGa1NXNTBNekpNUlNoMGFHbHpMbkJ2Y3lrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11Y0c5eklDczlJRFE3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIyWVd3N1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUM4dklEWTBMV0pwZENCcGJuUWdhR0Z1Wkd4cGJtY2dhWE1nWW1GelpXUWdiMjRnWjJsMGFIVmlMbU52YlM5a2NIY3ZibTlrWlMxaWRXWm1aWEl0Ylc5eVpTMXBiblJ6SUNoTlNWUXRiR2xqWlc1elpXUXBYRzVjYmlBZ0lDQnlaV0ZrUm1sNFpXUTJORG9nWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNBZ0lIWmhjaUIyWVd3Z1BTQjBhR2x6TG1KMVppNXlaV0ZrVlVsdWRETXlURVVvZEdocGN5NXdiM01wSUNzZ2RHaHBjeTVpZFdZdWNtVmhaRlZKYm5Rek1reEZLSFJvYVhNdWNHOXpJQ3NnTkNrZ0tpQlRTRWxHVkY5TVJVWlVYek15TzF4dUlDQWdJQ0FnSUNCMGFHbHpMbkJ2Y3lBclBTQTRPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkbUZzTzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0J5WldGa1UwWnBlR1ZrTmpRNklHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lDQWdJQ0IyWVhJZ2RtRnNJRDBnZEdocGN5NWlkV1l1Y21WaFpGVkpiblF6TWt4RktIUm9hWE11Y0c5ektTQXJJSFJvYVhNdVluVm1MbkpsWVdSSmJuUXpNa3hGS0hSb2FYTXVjRzl6SUNzZ05Da2dLaUJUU0VsR1ZGOU1SVVpVWHpNeU8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG5CdmN5QXJQU0E0TzF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZG1Gc08xeHVJQ0FnSUgwc1hHNWNiaUFnSUNCeVpXRmtSbXh2WVhRNklHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lDQWdJQ0IyWVhJZ2RtRnNJRDBnZEdocGN5NWlkV1l1Y21WaFpFWnNiMkYwVEVVb2RHaHBjeTV3YjNNcE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG5CdmN5QXJQU0EwTzF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZG1Gc08xeHVJQ0FnSUgwc1hHNWNiaUFnSUNCeVpXRmtSRzkxWW14bE9pQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlIWmhiQ0E5SUhSb2FYTXVZblZtTG5KbFlXUkViM1ZpYkdWTVJTaDBhR2x6TG5CdmN5azdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNHOXpJQ3M5SURnN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMllXdzdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lISmxZV1JXWVhKcGJuUTZJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnSUNCMllYSWdZblZtSUQwZ2RHaHBjeTVpZFdZc1hHNGdJQ0FnSUNBZ0lDQWdJQ0IyWVd3c0lHSXNJR0l3TENCaU1Td2dZaklzSUdJek8xeHVYRzRnSUNBZ0lDQWdJR0l3SUQwZ1luVm1XM1JvYVhNdWNHOXpLeXRkT3lCcFppQW9ZakFnUENBd2VEZ3dLU0J5WlhSMWNtNGdZakE3SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JpTUNBOUlHSXdJQ1lnTUhnM1pqdGNiaUFnSUNBZ0lDQWdZakVnUFNCaWRXWmJkR2hwY3k1d2IzTXJLMTA3SUdsbUlDaGlNU0E4SURCNE9EQXBJSEpsZEhWeWJpQmlNQ0I4SUdJeElEdzhJRGM3SUNBZ0lDQWdJR0l4SUQwZ0tHSXhJQ1lnTUhnM1ppa2dQRHdnTnp0Y2JpQWdJQ0FnSUNBZ1lqSWdQU0JpZFdaYmRHaHBjeTV3YjNNcksxMDdJR2xtSUNoaU1pQThJREI0T0RBcElISmxkSFZ5YmlCaU1DQjhJR0l4SUh3Z1lqSWdQRHdnTVRRN0lHSXlJRDBnS0dJeUlDWWdNSGczWmlrZ1BEd2dNVFE3WEc0Z0lDQWdJQ0FnSUdJeklEMGdZblZtVzNSb2FYTXVjRzl6S3l0ZE95QnBaaUFvWWpNZ1BDQXdlRGd3S1NCeVpYUjFjbTRnWWpBZ2ZDQmlNU0I4SUdJeUlId2dZak1nUER3Z01qRTdYRzVjYmlBZ0lDQWdJQ0FnZG1Gc0lEMGdZakFnZkNCaU1TQjhJR0l5SUh3Z0tHSXpJQ1lnTUhnM1ppa2dQRHdnTWpFN1hHNWNiaUFnSUNBZ0lDQWdZaUE5SUdKMVpsdDBhR2x6TG5CdmN5c3JYVHNnZG1Gc0lDczlJQ2hpSUNZZ01IZzNaaWtnS2lBd2VERXdNREF3TURBd095QWdJQ0FnSUNBZ0lHbG1JQ2hpSUR3Z01IZzRNQ2tnY21WMGRYSnVJSFpoYkR0Y2JpQWdJQ0FnSUNBZ1lpQTlJR0oxWmx0MGFHbHpMbkJ2Y3lzclhUc2dkbUZzSUNzOUlDaGlJQ1lnTUhnM1ppa2dLaUF3ZURnd01EQXdNREF3TURzZ0lDQWdJQ0FnSUdsbUlDaGlJRHdnTUhnNE1Da2djbVYwZFhKdUlIWmhiRHRjYmlBZ0lDQWdJQ0FnWWlBOUlHSjFabHQwYUdsekxuQnZjeXNyWFRzZ2RtRnNJQ3M5SUNoaUlDWWdNSGczWmlrZ0tpQXdlRFF3TURBd01EQXdNREF3T3lBZ0lDQWdJR2xtSUNoaUlEd2dNSGc0TUNrZ2NtVjBkWEp1SUhaaGJEdGNiaUFnSUNBZ0lDQWdZaUE5SUdKMVpsdDBhR2x6TG5CdmN5c3JYVHNnZG1Gc0lDczlJQ2hpSUNZZ01IZzNaaWtnS2lBd2VESXdNREF3TURBd01EQXdNREE3SUNBZ0lHbG1JQ2hpSUR3Z01IZzRNQ2tnY21WMGRYSnVJSFpoYkR0Y2JpQWdJQ0FnSUNBZ1lpQTlJR0oxWmx0MGFHbHpMbkJ2Y3lzclhUc2dkbUZzSUNzOUlDaGlJQ1lnTUhnM1ppa2dLaUF3ZURFd01EQXdNREF3TURBd01EQXdNRHNnSUdsbUlDaGlJRHdnTUhnNE1Da2djbVYwZFhKdUlIWmhiRHRjYmlBZ0lDQWdJQ0FnWWlBOUlHSjFabHQwYUdsekxuQnZjeXNyWFRzZ2RtRnNJQ3M5SUNoaUlDWWdNSGczWmlrZ0tpQXdlRGd3TURBd01EQXdNREF3TURBd01EQTdJR2xtSUNoaUlEd2dNSGc0TUNrZ2NtVjBkWEp1SUhaaGJEdGNibHh1SUNBZ0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9KMFY0Y0dWamRHVmtJSFpoY21sdWRDQnViM1FnYlc5eVpTQjBhR0Z1SURFd0lHSjVkR1Z6SnlrN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUhKbFlXUldZWEpwYm5RMk5Eb2dablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUhaaGNpQnpkR0Z5ZEZCdmN5QTlJSFJvYVhNdWNHOXpMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2RtRnNJRDBnZEdocGN5NXlaV0ZrVm1GeWFXNTBLQ2s3WEc1Y2JpQWdJQ0FnSUNBZ2FXWWdLSFpoYkNBOElGQlBWMTh5WHpZektTQnlaWFIxY200Z2RtRnNPMXh1WEc0Z0lDQWdJQ0FnSUhaaGNpQndiM01nUFNCMGFHbHpMbkJ2Y3lBdElESTdYRzRnSUNBZ0lDQWdJSGRvYVd4bElDaDBhR2x6TG1KMVpsdHdiM05kSUQwOVBTQXdlR1ptS1NCd2IzTXRMVHRjYmlBZ0lDQWdJQ0FnYVdZZ0tIQnZjeUE4SUhOMFlYSjBVRzl6S1NCd2IzTWdQU0J6ZEdGeWRGQnZjenRjYmx4dUlDQWdJQ0FnSUNCMllXd2dQU0F3TzF4dUlDQWdJQ0FnSUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElIQnZjeUF0SUhOMFlYSjBVRzl6SUNzZ01Uc2dhU3NyS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IyWVhJZ1lpQTlJSDUwYUdsekxtSjFabHR6ZEdGeWRGQnZjeUFySUdsZElDWWdNSGczWmp0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFpoYkNBclBTQnBJRHdnTkNBL0lHSWdQRHdnYVNBcUlEY2dPaUJpSUNvZ1RXRjBhQzV3YjNjb01pd2dhU0FxSURjcE8xeHVJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJQzEyWVd3Z0xTQXhPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQnlaV0ZrVTFaaGNtbHVkRG9nWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNBZ0lIWmhjaUJ1ZFcwZ1BTQjBhR2x6TG5KbFlXUldZWEpwYm5Rb0tUdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHNTFiU0FsSURJZ1BUMDlJREVnUHlBb2JuVnRJQ3NnTVNrZ0x5QXRNaUE2SUc1MWJTQXZJREk3SUM4dklIcHBaM3BoWnlCbGJtTnZaR2x1WjF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0J5WldGa1FtOXZiR1ZoYmpvZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQkNiMjlzWldGdUtIUm9hWE11Y21WaFpGWmhjbWx1ZENncEtUdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ2NtVmhaRk4wY21sdVp6b2dablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUhaaGNpQmxibVFnUFNCMGFHbHpMbkpsWVdSV1lYSnBiblFvS1NBcklIUm9hWE11Y0c5ekxGeHVJQ0FnSUNBZ0lDQWdJQ0FnYzNSeUlEMGdkR2hwY3k1aWRXWXVkRzlUZEhKcGJtY29KM1YwWmpnbkxDQjBhR2x6TG5CdmN5d2daVzVrS1R0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTV3YjNNZ1BTQmxibVE3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJ6ZEhJN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUhKbFlXUkNlWFJsY3pvZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCbGJtUWdQU0IwYUdsekxuSmxZV1JXWVhKcGJuUW9LU0FySUhSb2FYTXVjRzl6TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdZblZtWm1WeUlEMGdkR2hwY3k1aWRXWXVjMnhwWTJVb2RHaHBjeTV3YjNNc0lHVnVaQ2s3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjRzl6SUQwZ1pXNWtPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdZblZtWm1WeU8xeHVJQ0FnSUgwc1hHNWNiaUFnSUNBdkx5QjJaWEppYjNObElHWnZjaUJ3WlhKbWIzSnRZVzVqWlNCeVpXRnpiMjV6T3lCa2IyVnpiaWQwSUdGbVptVmpkQ0JuZW1sd2NHVmtJSE5wZW1WY2JseHVJQ0FnSUhKbFlXUlFZV05yWldSV1lYSnBiblE2SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ0lDQjJZWElnWlc1a0lEMGdkR2hwY3k1eVpXRmtWbUZ5YVc1MEtDa2dLeUIwYUdsekxuQnZjeXdnWVhKeUlEMGdXMTA3WEc0Z0lDQWdJQ0FnSUhkb2FXeGxJQ2gwYUdsekxuQnZjeUE4SUdWdVpDa2dZWEp5TG5CMWMyZ29kR2hwY3k1eVpXRmtWbUZ5YVc1MEtDa3BPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdZWEp5TzF4dUlDQWdJSDBzWEc0Z0lDQWdjbVZoWkZCaFkydGxaRk5XWVhKcGJuUTZJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnSUNCMllYSWdaVzVrSUQwZ2RHaHBjeTV5WldGa1ZtRnlhVzUwS0NrZ0t5QjBhR2x6TG5CdmN5d2dZWEp5SUQwZ1cxMDdYRzRnSUNBZ0lDQWdJSGRvYVd4bElDaDBhR2x6TG5CdmN5QThJR1Z1WkNrZ1lYSnlMbkIxYzJnb2RHaHBjeTV5WldGa1UxWmhjbWx1ZENncEtUdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHRnljanRjYmlBZ0lDQjlMRnh1SUNBZ0lISmxZV1JRWVdOclpXUkNiMjlzWldGdU9pQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlHVnVaQ0E5SUhSb2FYTXVjbVZoWkZaaGNtbHVkQ2dwSUNzZ2RHaHBjeTV3YjNNc0lHRnljaUE5SUZ0ZE8xeHVJQ0FnSUNBZ0lDQjNhR2xzWlNBb2RHaHBjeTV3YjNNZ1BDQmxibVFwSUdGeWNpNXdkWE5vS0hSb2FYTXVjbVZoWkVKdmIyeGxZVzRvS1NrN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCaGNuSTdYRzRnSUNBZ2ZTeGNiaUFnSUNCeVpXRmtVR0ZqYTJWa1JteHZZWFE2SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ0lDQjJZWElnWlc1a0lEMGdkR2hwY3k1eVpXRmtWbUZ5YVc1MEtDa2dLeUIwYUdsekxuQnZjeXdnWVhKeUlEMGdXMTA3WEc0Z0lDQWdJQ0FnSUhkb2FXeGxJQ2gwYUdsekxuQnZjeUE4SUdWdVpDa2dZWEp5TG5CMWMyZ29kR2hwY3k1eVpXRmtSbXh2WVhRb0tTazdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmhjbkk3WEc0Z0lDQWdmU3hjYmlBZ0lDQnlaV0ZrVUdGamEyVmtSRzkxWW14bE9pQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlHVnVaQ0E5SUhSb2FYTXVjbVZoWkZaaGNtbHVkQ2dwSUNzZ2RHaHBjeTV3YjNNc0lHRnljaUE5SUZ0ZE8xeHVJQ0FnSUNBZ0lDQjNhR2xzWlNBb2RHaHBjeTV3YjNNZ1BDQmxibVFwSUdGeWNpNXdkWE5vS0hSb2FYTXVjbVZoWkVSdmRXSnNaU2dwS1R0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUdGeWNqdGNiaUFnSUNCOUxGeHVJQ0FnSUhKbFlXUlFZV05yWldSR2FYaGxaRE15T2lCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lDQWdkbUZ5SUdWdVpDQTlJSFJvYVhNdWNtVmhaRlpoY21sdWRDZ3BJQ3NnZEdocGN5NXdiM01zSUdGeWNpQTlJRnRkTzF4dUlDQWdJQ0FnSUNCM2FHbHNaU0FvZEdocGN5NXdiM01nUENCbGJtUXBJR0Z5Y2k1d2RYTm9LSFJvYVhNdWNtVmhaRVpwZUdWa016SW9LU2s3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJoY25JN1hHNGdJQ0FnZlN4Y2JpQWdJQ0J5WldGa1VHRmphMlZrVTBacGVHVmtNekk2SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ0lDQjJZWElnWlc1a0lEMGdkR2hwY3k1eVpXRmtWbUZ5YVc1MEtDa2dLeUIwYUdsekxuQnZjeXdnWVhKeUlEMGdXMTA3WEc0Z0lDQWdJQ0FnSUhkb2FXeGxJQ2gwYUdsekxuQnZjeUE4SUdWdVpDa2dZWEp5TG5CMWMyZ29kR2hwY3k1eVpXRmtVMFpwZUdWa016SW9LU2s3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJoY25JN1hHNGdJQ0FnZlN4Y2JpQWdJQ0J5WldGa1VHRmphMlZrUm1sNFpXUTJORG9nWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNBZ0lIWmhjaUJsYm1RZ1BTQjBhR2x6TG5KbFlXUldZWEpwYm5Rb0tTQXJJSFJvYVhNdWNHOXpMQ0JoY25JZ1BTQmJYVHRjYmlBZ0lDQWdJQ0FnZDJocGJHVWdLSFJvYVhNdWNHOXpJRHdnWlc1a0tTQmhjbkl1Y0hWemFDaDBhR2x6TG5KbFlXUkdhWGhsWkRZMEtDa3BPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdZWEp5TzF4dUlDQWdJSDBzWEc0Z0lDQWdjbVZoWkZCaFkydGxaRk5HYVhobFpEWTBPaUJtZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0FnSUNBZ2RtRnlJR1Z1WkNBOUlIUm9hWE11Y21WaFpGWmhjbWx1ZENncElDc2dkR2hwY3k1d2IzTXNJR0Z5Y2lBOUlGdGRPMXh1SUNBZ0lDQWdJQ0IzYUdsc1pTQW9kR2hwY3k1d2IzTWdQQ0JsYm1RcElHRnljaTV3ZFhOb0tIUm9hWE11Y21WaFpGTkdhWGhsWkRZMEtDa3BPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdZWEp5TzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0J6YTJsd09pQm1kVzVqZEdsdmJpaDJZV3dwSUh0Y2JpQWdJQ0FnSUNBZ2RtRnlJSFI1Y0dVZ1BTQjJZV3dnSmlBd2VEYzdYRzRnSUNBZ0lDQWdJR2xtSUNoMGVYQmxJRDA5UFNCUVltWXVWbUZ5YVc1MEtTQjNhR2xzWlNBb2RHaHBjeTVpZFdaYmRHaHBjeTV3YjNNcksxMGdQaUF3ZURkbUtTQjdmVnh1SUNBZ0lDQWdJQ0JsYkhObElHbG1JQ2gwZVhCbElEMDlQU0JRWW1ZdVFubDBaWE1wSUhSb2FYTXVjRzl6SUQwZ2RHaHBjeTV5WldGa1ZtRnlhVzUwS0NrZ0t5QjBhR2x6TG5CdmN6dGNiaUFnSUNBZ0lDQWdaV3h6WlNCcFppQW9kSGx3WlNBOVBUMGdVR0ptTGtacGVHVmtNeklwSUhSb2FYTXVjRzl6SUNzOUlEUTdYRzRnSUNBZ0lDQWdJR1ZzYzJVZ2FXWWdLSFI1Y0dVZ1BUMDlJRkJpWmk1R2FYaGxaRFkwS1NCMGFHbHpMbkJ2Y3lBclBTQTRPMXh1SUNBZ0lDQWdJQ0JsYkhObElIUm9jbTkzSUc1bGR5QkZjbkp2Y2lnblZXNXBiWEJzWlcxbGJuUmxaQ0IwZVhCbE9pQW5JQ3NnZEhsd1pTazdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lDOHZJRDA5UFNCWFVrbFVTVTVISUQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVhHNWNiaUFnSUNCM2NtbDBaVlJoWnpvZ1puVnVZM1JwYjI0b2RHRm5MQ0IwZVhCbEtTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdWQzSnBkR1ZXWVhKcGJuUW9LSFJoWnlBOFBDQXpLU0I4SUhSNWNHVXBPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQnlaV0ZzYkc5ak9pQm1kVzVqZEdsdmJpaHRhVzRwSUh0Y2JpQWdJQ0FnSUNBZ2RtRnlJR3hsYm1kMGFDQTlJSFJvYVhNdWJHVnVaM1JvSUh4OElERTJPMXh1WEc0Z0lDQWdJQ0FnSUhkb2FXeGxJQ2hzWlc1bmRHZ2dQQ0IwYUdsekxuQnZjeUFySUcxcGJpa2diR1Z1WjNSb0lDbzlJREk3WEc1Y2JpQWdJQ0FnSUNBZ2FXWWdLR3hsYm1kMGFDQWhQVDBnZEdocGN5NXNaVzVuZEdncElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhaaGNpQmlkV1lnUFNCdVpYY2dRblZtWm1WeUtHeGxibWQwYUNrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxtSjFaaTVqYjNCNUtHSjFaaWs3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TG1KMVppQTlJR0oxWmp0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdWJHVnVaM1JvSUQwZ2JHVnVaM1JvTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnZlN4Y2JseHVJQ0FnSUdacGJtbHphRG9nWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11YkdWdVozUm9JRDBnZEdocGN5NXdiM003WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjRzl6SUQwZ01EdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11WW5WbUxuTnNhV05sS0RBc0lIUm9hWE11YkdWdVozUm9LVHRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdkM0pwZEdWR2FYaGxaRE15T2lCbWRXNWpkR2x2YmloMllXd3BJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NXlaV0ZzYkc5aktEUXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxtSjFaaTUzY21sMFpWVkpiblF6TWt4RktIWmhiQ3dnZEdocGN5NXdiM01wTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbkJ2Y3lBclBTQTBPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQjNjbWwwWlZOR2FYaGxaRE15T2lCbWRXNWpkR2x2YmloMllXd3BJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NXlaV0ZzYkc5aktEUXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxtSjFaaTUzY21sMFpVbHVkRE15VEVVb2RtRnNMQ0IwYUdsekxuQnZjeWs3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjRzl6SUNzOUlEUTdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lIZHlhWFJsUm1sNFpXUTJORG9nWm5WdVkzUnBiMjRvZG1Gc0tTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNtVmhiR3h2WXlnNEtUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1aWRXWXVkM0pwZEdWSmJuUXpNa3hGS0haaGJDQW1JQzB4TENCMGFHbHpMbkJ2Y3lrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WW5WbUxuZHlhWFJsVlVsdWRETXlURVVvVFdGMGFDNW1iRzl2Y2loMllXd2dLaUJUU0VsR1ZGOVNTVWRJVkY4ek1pa3NJSFJvYVhNdWNHOXpJQ3NnTkNrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11Y0c5eklDczlJRGc3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJSGR5YVhSbFUwWnBlR1ZrTmpRNklHWjFibU4wYVc5dUtIWmhiQ2tnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbkpsWVd4c2IyTW9PQ2s3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVZblZtTG5keWFYUmxTVzUwTXpKTVJTaDJZV3dnSmlBdE1Td2dkR2hwY3k1d2IzTXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxtSjFaaTUzY21sMFpVbHVkRE15VEVVb1RXRjBhQzVtYkc5dmNpaDJZV3dnS2lCVFNFbEdWRjlTU1VkSVZGOHpNaWtzSUhSb2FYTXVjRzl6SUNzZ05DazdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNHOXpJQ3M5SURnN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUhkeWFYUmxWbUZ5YVc1ME9pQm1kVzVqZEdsdmJpaDJZV3dwSUh0Y2JpQWdJQ0FnSUNBZ2RtRnNJRDBnSzNaaGJEdGNibHh1SUNBZ0lDQWdJQ0JwWmlBb2RtRnNJRHc5SURCNE4yWXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11Y21WaGJHeHZZeWd4S1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVluVm1XM1JvYVhNdWNHOXpLeXRkSUQwZ2RtRnNPMXh1WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2RtRnNJRHc5SURCNE0yWm1aaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1eVpXRnNiRzlqS0RJcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NWlkV1piZEdocGN5NXdiM01ySzEwZ1BTQW9LSFpoYkNBK1BqNGdNQ2tnSmlBd2VEZG1LU0I4SURCNE9EQTdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbUoxWmx0MGFHbHpMbkJ2Y3lzclhTQTlJQ2dvZG1Gc0lENCtQaUEzS1NBbUlEQjROMllwTzF4dVhHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCcFppQW9kbUZzSUR3OUlEQjRNV1ptWm1abUtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbkpsWVd4c2IyTW9NeWs3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TG1KMVpsdDBhR2x6TG5CdmN5c3JYU0E5SUNnb2RtRnNJRDQrUGlBd0tTQW1JREI0TjJZcElId2dNSGc0TUR0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVluVm1XM1JvYVhNdWNHOXpLeXRkSUQwZ0tDaDJZV3dnUGo0K0lEY3BJQ1lnTUhnM1ppa2dmQ0F3ZURnd08xeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NWlkV1piZEdocGN5NXdiM01ySzEwZ1BTQW9LSFpoYkNBK1BqNGdNVFFwSUNZZ01IZzNaaWs3WEc1Y2JpQWdJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaDJZV3dnUEQwZ01IaG1abVptWm1abUtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbkpsWVd4c2IyTW9OQ2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TG1KMVpsdDBhR2x6TG5CdmN5c3JYU0E5SUNnb2RtRnNJRDQrUGlBd0tTQW1JREI0TjJZcElId2dNSGc0TUR0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVluVm1XM1JvYVhNdWNHOXpLeXRkSUQwZ0tDaDJZV3dnUGo0K0lEY3BJQ1lnTUhnM1ppa2dmQ0F3ZURnd08xeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NWlkV1piZEdocGN5NXdiM01ySzEwZ1BTQW9LSFpoYkNBK1BqNGdNVFFwSUNZZ01IZzNaaWtnZkNBd2VEZ3dPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2RHaHBjeTVpZFdaYmRHaHBjeTV3YjNNcksxMGdQU0FvS0haaGJDQStQajRnTWpFcElDWWdNSGczWmlrN1hHNWNiaUFnSUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhaaGNpQndiM01nUFNCMGFHbHpMbkJ2Y3p0Y2JpQWdJQ0FnSUNBZ0lDQWdJSGRvYVd4bElDaDJZV3dnUGowZ01IZzRNQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVjbVZoYkd4dll5Z3hLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxtSjFabHQwYUdsekxuQnZjeXNyWFNBOUlDaDJZV3dnSmlBd2VHWm1LU0I4SURCNE9EQTdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkbUZzSUM4OUlEQjRPREE3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbkpsWVd4c2IyTW9NU2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TG1KMVpsdDBhR2x6TG5CdmN5c3JYU0E5SUhaaGJDQjhJREE3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvZEdocGN5NXdiM01nTFNCd2IzTWdQaUF4TUNrZ2RHaHliM2NnYm1WM0lFVnljbTl5S0NkSGFYWmxiaUIyWVhKcGJuUWdaRzlsYzI1Y1hDZDBJR1pwZENCcGJuUnZJREV3SUdKNWRHVnpKeWs3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnZDNKcGRHVlRWbUZ5YVc1ME9pQm1kVzVqZEdsdmJpaDJZV3dwSUh0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTUzY21sMFpWWmhjbWx1ZENoMllXd2dQQ0F3SUQ4Z0xYWmhiQ0FxSURJZ0xTQXhJRG9nZG1Gc0lDb2dNaWs3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJSGR5YVhSbFFtOXZiR1ZoYmpvZ1puVnVZM1JwYjI0b2RtRnNLU0I3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVkM0pwZEdWV1lYSnBiblFvUW05dmJHVmhiaWgyWVd3cEtUdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ2QzSnBkR1ZUZEhKcGJtYzZJR1oxYm1OMGFXOXVLSE4wY2lrZ2UxeHVJQ0FnSUNBZ0lDQnpkSElnUFNCVGRISnBibWNvYzNSeUtUdGNiaUFnSUNBZ0lDQWdkbUZ5SUdKNWRHVnpJRDBnUW5WbVptVnlMbUo1ZEdWTVpXNW5kR2dvYzNSeUtUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1M2NtbDBaVlpoY21sdWRDaGllWFJsY3lrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11Y21WaGJHeHZZeWhpZVhSbGN5azdYRzRnSUNBZ0lDQWdJSFJvYVhNdVluVm1MbmR5YVhSbEtITjBjaXdnZEdocGN5NXdiM01wTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbkJ2Y3lBclBTQmllWFJsY3p0Y2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnZDNKcGRHVkdiRzloZERvZ1puVnVZM1JwYjI0b2RtRnNLU0I3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjbVZoYkd4dll5ZzBLVHRjYmlBZ0lDQWdJQ0FnZEdocGN5NWlkV1l1ZDNKcGRHVkdiRzloZEV4RktIWmhiQ3dnZEdocGN5NXdiM01wTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbkJ2Y3lBclBTQTBPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQjNjbWwwWlVSdmRXSnNaVG9nWm5WdVkzUnBiMjRvZG1Gc0tTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNtVmhiR3h2WXlnNEtUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1aWRXWXVkM0pwZEdWRWIzVmliR1ZNUlNoMllXd3NJSFJvYVhNdWNHOXpLVHRjYmlBZ0lDQWdJQ0FnZEdocGN5NXdiM01nS3owZ09EdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ2QzSnBkR1ZDZVhSbGN6b2dablZ1WTNScGIyNG9ZblZtWm1WeUtTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCc1pXNGdQU0JpZFdabVpYSXViR1Z1WjNSb08xeHVJQ0FnSUNBZ0lDQjBhR2x6TG5keWFYUmxWbUZ5YVc1MEtHeGxiaWs3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjbVZoYkd4dll5aHNaVzRwTzF4dUlDQWdJQ0FnSUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHeGxianNnYVNzcktTQjBhR2x6TG1KMVpsdDBhR2x6TG5CdmN5c3JYU0E5SUdKMVptWmxjbHRwWFR0Y2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnZDNKcGRHVk5aWE56WVdkbE9pQm1kVzVqZEdsdmJpaDBZV2NzSUdadUxDQnZZbW9wSUh0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTUzY21sMFpWUmhaeWgwWVdjc0lGQmlaaTVDZVhSbGN5azdYRzVjYmlBZ0lDQWdJQ0FnZEdocGN5NXdiM01yS3pzZ0x5OGdjbVZ6WlhKMlpTQXhJR0o1ZEdVZ1ptOXlJSE5vYjNKMElHMWxjM05oWjJVZ2JHVnVaM1JvWEc1Y2JpQWdJQ0FnSUNBZ0x5OGdkM0pwZEdVZ2RHaGxJRzFsYzNOaFoyVWdaR2x5WldOMGJIa2dkRzhnZEdobElHSjFabVpsY2lCaGJtUWdjMlZsSUdodmR5QnRkV05vSUhkaGN5QjNjbWwwZEdWdVhHNGdJQ0FnSUNBZ0lIWmhjaUJ6ZEdGeWRGQnZjeUE5SUhSb2FYTXVjRzl6TzF4dUlDQWdJQ0FnSUNCbWJpaHZZbW9zSUhSb2FYTXBPMXh1SUNBZ0lDQWdJQ0IyWVhJZ2JHVnVJRDBnZEdocGN5NXdiM01nTFNCemRHRnlkRkJ2Y3p0Y2JseHVJQ0FnSUNBZ0lDQjJZWElnZG1GeWFXNTBUR1Z1SUQxY2JpQWdJQ0FnSUNBZ0lDQWdJR3hsYmlBOFBTQXdlRGRtSUQ4Z01TQTZYRzRnSUNBZ0lDQWdJQ0FnSUNCc1pXNGdQRDBnTUhnelptWm1JRDhnTWlBNlhHNGdJQ0FnSUNBZ0lDQWdJQ0JzWlc0Z1BEMGdNSGd4Wm1abVptWWdQeUF6SURwY2JpQWdJQ0FnSUNBZ0lDQWdJR3hsYmlBOFBTQXdlR1ptWm1abVptWWdQeUEwSURvZ1RXRjBhQzVqWldsc0tFMWhkR2d1Ykc5bktHeGxiaWtnTHlBb1RXRjBhQzVNVGpJZ0tpQTNLU2s3WEc1Y2JpQWdJQ0FnSUNBZ0x5OGdhV1lnTVNCaWVYUmxJR2x6YmlkMElHVnViM1ZuYUNCbWIzSWdaVzVqYjJScGJtY2diV1Z6YzJGblpTQnNaVzVuZEdnc0lITm9hV1owSUhSb1pTQmtZWFJoSUhSdklIUm9aU0J5YVdkb2RGeHVJQ0FnSUNBZ0lDQnBaaUFvZG1GeWFXNTBUR1Z1SUQ0Z01Ta2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2RHaHBjeTV5WldGc2JHOWpLSFpoY21sdWRFeGxiaUF0SURFcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnWm05eUlDaDJZWElnYVNBOUlIUm9hWE11Y0c5eklDMGdNVHNnYVNBK1BTQnpkR0Z5ZEZCdmN6c2dhUzB0S1NCMGFHbHpMbUoxWmx0cElDc2dkbUZ5YVc1MFRHVnVJQzBnTVYwZ1BTQjBhR2x6TG1KMVpsdHBYVHRjYmlBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lDOHZJR1pwYm1Gc2JIa3NJSGR5YVhSbElIUm9aU0J0WlhOellXZGxJR3hsYm1kMGFDQnBiaUIwYUdVZ2NtVnpaWEoyWldRZ2NHeGhZMlVnWVc1a0lISmxjM1J2Y21VZ2RHaGxJSEJ2YzJsMGFXOXVYRzRnSUNBZ0lDQWdJSFJvYVhNdWNHOXpJRDBnYzNSaGNuUlFiM01nTFNBeE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG5keWFYUmxWbUZ5YVc1MEtHeGxiaWs3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjRzl6SUNzOUlHeGxianRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdkM0pwZEdWUVlXTnJaV1JXWVhKcGJuUTZJQ0FnWm5WdVkzUnBiMjRvZEdGbkxDQmhjbklwSUhzZ2RHaHBjeTUzY21sMFpVMWxjM05oWjJVb2RHRm5MQ0IzY21sMFpWQmhZMnRsWkZaaGNtbHVkQ3dnWVhKeUtUc2dJQ0I5TEZ4dUlDQWdJSGR5YVhSbFVHRmphMlZrVTFaaGNtbHVkRG9nSUdaMWJtTjBhVzl1S0hSaFp5d2dZWEp5S1NCN0lIUm9hWE11ZDNKcGRHVk5aWE56WVdkbEtIUmhaeXdnZDNKcGRHVlFZV05yWldSVFZtRnlhVzUwTENCaGNuSXBPeUFnZlN4Y2JpQWdJQ0IzY21sMFpWQmhZMnRsWkVKdmIyeGxZVzQ2SUNCbWRXNWpkR2x2YmloMFlXY3NJR0Z5Y2lrZ2V5QjBhR2x6TG5keWFYUmxUV1Z6YzJGblpTaDBZV2NzSUhkeWFYUmxVR0ZqYTJWa1FtOXZiR1ZoYml3Z1lYSnlLVHNnSUgwc1hHNGdJQ0FnZDNKcGRHVlFZV05yWldSR2JHOWhkRG9nSUNBZ1puVnVZM1JwYjI0b2RHRm5MQ0JoY25JcElIc2dkR2hwY3k1M2NtbDBaVTFsYzNOaFoyVW9kR0ZuTENCM2NtbDBaVkJoWTJ0bFpFWnNiMkYwTENCaGNuSXBPeUFnSUNCOUxGeHVJQ0FnSUhkeWFYUmxVR0ZqYTJWa1JHOTFZbXhsT2lBZ0lHWjFibU4wYVc5dUtIUmhaeXdnWVhKeUtTQjdJSFJvYVhNdWQzSnBkR1ZOWlhOellXZGxLSFJoWnl3Z2QzSnBkR1ZRWVdOclpXUkViM1ZpYkdVc0lHRnljaWs3SUNBZ2ZTeGNiaUFnSUNCM2NtbDBaVkJoWTJ0bFpFWnBlR1ZrTXpJNklDQm1kVzVqZEdsdmJpaDBZV2NzSUdGeWNpa2dleUIwYUdsekxuZHlhWFJsVFdWemMyRm5aU2gwWVdjc0lIZHlhWFJsVUdGamEyVmtSbWw0WldRek1pd2dZWEp5S1RzZ0lIMHNYRzRnSUNBZ2QzSnBkR1ZRWVdOclpXUlRSbWw0WldRek1qb2dablZ1WTNScGIyNG9kR0ZuTENCaGNuSXBJSHNnZEdocGN5NTNjbWwwWlUxbGMzTmhaMlVvZEdGbkxDQjNjbWwwWlZCaFkydGxaRk5HYVhobFpETXlMQ0JoY25JcE95QjlMRnh1SUNBZ0lIZHlhWFJsVUdGamEyVmtSbWw0WldRMk5Eb2dJR1oxYm1OMGFXOXVLSFJoWnl3Z1lYSnlLU0I3SUhSb2FYTXVkM0pwZEdWTlpYTnpZV2RsS0hSaFp5d2dkM0pwZEdWUVlXTnJaV1JHYVhobFpEWTBMQ0JoY25JcE95QWdmU3hjYmlBZ0lDQjNjbWwwWlZCaFkydGxaRk5HYVhobFpEWTBPaUJtZFc1amRHbHZiaWgwWVdjc0lHRnljaWtnZXlCMGFHbHpMbmR5YVhSbFRXVnpjMkZuWlNoMFlXY3NJSGR5YVhSbFVHRmphMlZrVTBacGVHVmtOalFzSUdGeWNpazdJSDBzWEc1Y2JpQWdJQ0IzY21sMFpVSjVkR1Z6Um1sbGJHUTZJR1oxYm1OMGFXOXVLSFJoWnl3Z1luVm1abVZ5S1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11ZDNKcGRHVlVZV2NvZEdGbkxDQlFZbVl1UW5sMFpYTXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxuZHlhWFJsUW5sMFpYTW9ZblZtWm1WeUtUdGNiaUFnSUNCOUxGeHVJQ0FnSUhkeWFYUmxSbWw0WldRek1rWnBaV3hrT2lCbWRXNWpkR2x2YmloMFlXY3NJSFpoYkNrZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TG5keWFYUmxWR0ZuS0hSaFp5d2dVR0ptTGtacGVHVmtNeklwTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbmR5YVhSbFJtbDRaV1F6TWloMllXd3BPMXh1SUNBZ0lIMHNYRzRnSUNBZ2QzSnBkR1ZUUm1sNFpXUXpNa1pwWld4a09pQm1kVzVqZEdsdmJpaDBZV2NzSUhaaGJDa2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekxuZHlhWFJsVkdGbktIUmhaeXdnVUdKbUxrWnBlR1ZrTXpJcE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG5keWFYUmxVMFpwZUdWa016SW9kbUZzS1R0Y2JpQWdJQ0I5TEZ4dUlDQWdJSGR5YVhSbFJtbDRaV1EyTkVacFpXeGtPaUJtZFc1amRHbHZiaWgwWVdjc0lIWmhiQ2tnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbmR5YVhSbFZHRm5LSFJoWnl3Z1VHSm1Ma1pwZUdWa05qUXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxuZHlhWFJsUm1sNFpXUTJOQ2gyWVd3cE8xeHVJQ0FnSUgwc1hHNGdJQ0FnZDNKcGRHVlRSbWw0WldRMk5FWnBaV3hrT2lCbWRXNWpkR2x2YmloMFlXY3NJSFpoYkNrZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TG5keWFYUmxWR0ZuS0hSaFp5d2dVR0ptTGtacGVHVmtOalFwTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbmR5YVhSbFUwWnBlR1ZrTmpRb2RtRnNLVHRjYmlBZ0lDQjlMRnh1SUNBZ0lIZHlhWFJsVm1GeWFXNTBSbWxsYkdRNklHWjFibU4wYVc5dUtIUmhaeXdnZG1Gc0tTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdWQzSnBkR1ZVWVdjb2RHRm5MQ0JRWW1ZdVZtRnlhVzUwS1R0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTUzY21sMFpWWmhjbWx1ZENoMllXd3BPMXh1SUNBZ0lIMHNYRzRnSUNBZ2QzSnBkR1ZUVm1GeWFXNTBSbWxsYkdRNklHWjFibU4wYVc5dUtIUmhaeXdnZG1Gc0tTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdWQzSnBkR1ZVWVdjb2RHRm5MQ0JRWW1ZdVZtRnlhVzUwS1R0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTUzY21sMFpWTldZWEpwYm5Rb2RtRnNLVHRjYmlBZ0lDQjlMRnh1SUNBZ0lIZHlhWFJsVTNSeWFXNW5SbWxsYkdRNklHWjFibU4wYVc5dUtIUmhaeXdnYzNSeUtTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdWQzSnBkR1ZVWVdjb2RHRm5MQ0JRWW1ZdVFubDBaWE1wTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbmR5YVhSbFUzUnlhVzVuS0hOMGNpazdYRzRnSUNBZ2ZTeGNiaUFnSUNCM2NtbDBaVVpzYjJGMFJtbGxiR1E2SUdaMWJtTjBhVzl1S0hSaFp5d2dkbUZzS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11ZDNKcGRHVlVZV2NvZEdGbkxDQlFZbVl1Um1sNFpXUXpNaWs3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVkM0pwZEdWR2JHOWhkQ2gyWVd3cE8xeHVJQ0FnSUgwc1hHNGdJQ0FnZDNKcGRHVkViM1ZpYkdWR2FXVnNaRG9nWm5WdVkzUnBiMjRvZEdGbkxDQjJZV3dwSUh0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTUzY21sMFpWUmhaeWgwWVdjc0lGQmlaaTVHYVhobFpEWTBLVHRjYmlBZ0lDQWdJQ0FnZEdocGN5NTNjbWwwWlVSdmRXSnNaU2gyWVd3cE8xeHVJQ0FnSUgwc1hHNGdJQ0FnZDNKcGRHVkNiMjlzWldGdVJtbGxiR1E2SUdaMWJtTjBhVzl1S0hSaFp5d2dkbUZzS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11ZDNKcGRHVldZWEpwYm5SR2FXVnNaQ2gwWVdjc0lFSnZiMnhsWVc0b2RtRnNLU2s3WEc0Z0lDQWdmVnh1ZlR0Y2JseHVablZ1WTNScGIyNGdkM0pwZEdWUVlXTnJaV1JXWVhKcGJuUW9ZWEp5TENCd1ltWXBJQ0FnZXlCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHRnljaTVzWlc1bmRHZzdJR2tyS3lrZ2NHSm1MbmR5YVhSbFZtRnlhVzUwS0dGeWNsdHBYU2s3SUNBZ2ZWeHVablZ1WTNScGIyNGdkM0pwZEdWUVlXTnJaV1JUVm1GeWFXNTBLR0Z5Y2l3Z2NHSm1LU0FnZXlCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHRnljaTVzWlc1bmRHZzdJR2tyS3lrZ2NHSm1MbmR5YVhSbFUxWmhjbWx1ZENoaGNuSmJhVjBwT3lBZ2ZWeHVablZ1WTNScGIyNGdkM0pwZEdWUVlXTnJaV1JHYkc5aGRDaGhjbklzSUhCaVppa2dJQ0FnZXlCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHRnljaTVzWlc1bmRHZzdJR2tyS3lrZ2NHSm1MbmR5YVhSbFJteHZZWFFvWVhKeVcybGRLVHNnSUNBZ2ZWeHVablZ1WTNScGIyNGdkM0pwZEdWUVlXTnJaV1JFYjNWaWJHVW9ZWEp5TENCd1ltWXBJQ0FnZXlCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHRnljaTVzWlc1bmRHZzdJR2tyS3lrZ2NHSm1MbmR5YVhSbFJHOTFZbXhsS0dGeWNsdHBYU2s3SUNBZ2ZWeHVablZ1WTNScGIyNGdkM0pwZEdWUVlXTnJaV1JDYjI5c1pXRnVLR0Z5Y2l3Z2NHSm1LU0FnZXlCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHRnljaTVzWlc1bmRHZzdJR2tyS3lrZ2NHSm1MbmR5YVhSbFFtOXZiR1ZoYmloaGNuSmJhVjBwT3lBZ2ZWeHVablZ1WTNScGIyNGdkM0pwZEdWUVlXTnJaV1JHYVhobFpETXlLR0Z5Y2l3Z2NHSm1LU0FnZXlCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHRnljaTVzWlc1bmRHZzdJR2tyS3lrZ2NHSm1MbmR5YVhSbFJtbDRaV1F6TWloaGNuSmJhVjBwT3lBZ2ZWeHVablZ1WTNScGIyNGdkM0pwZEdWUVlXTnJaV1JUUm1sNFpXUXpNaWhoY25Jc0lIQmlaaWtnZXlCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHRnljaTVzWlc1bmRHZzdJR2tyS3lrZ2NHSm1MbmR5YVhSbFUwWnBlR1ZrTXpJb1lYSnlXMmxkS1RzZ2ZWeHVablZ1WTNScGIyNGdkM0pwZEdWUVlXTnJaV1JHYVhobFpEWTBLR0Z5Y2l3Z2NHSm1LU0FnZXlCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHRnljaTVzWlc1bmRHZzdJR2tyS3lrZ2NHSm1MbmR5YVhSbFJtbDRaV1EyTkNoaGNuSmJhVjBwT3lBZ2ZWeHVablZ1WTNScGIyNGdkM0pwZEdWUVlXTnJaV1JUUm1sNFpXUTJOQ2hoY25Jc0lIQmlaaWtnZXlCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHRnljaTVzWlc1bmRHZzdJR2tyS3lrZ2NHSm1MbmR5YVhSbFUwWnBlR1ZrTmpRb1lYSnlXMmxkS1RzZ2ZWeHVJbDE5IiwiLyohXG4gKiBzdHJpcC1jb21tZW50cyA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvc3RyaXAtY29tbWVudHM+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVCbG9jayA9IC9cXC9cXCooPyFcXC8pKC58W1xcclxcbl18XFxuKSs/XFwqXFwvXFxuP1xcbj8vZ207XG52YXIgcmVCbG9ja0lnbm9yZSA9IC9cXC9cXCooPyEoXFwqP1xcL3xcXCo/XFwhKSkoLnxbXFxyXFxuXXxcXG4pKz9cXCpcXC9cXG4/XFxuPy9nbTtcbnZhciByZUxpbmUgPSAvKF58W15cXFNcXG5dKSg/OlxcL1xcLykoW1xcc1xcU10rPykkL2dtO1xudmFyIHJlTGluZUlnbm9yZSA9IC8oXnxbXlxcU1xcbl0pKD86XFwvXFwvW14hXSkoW1xcc1xcU10rPykkL2dtO1xuXG4vKipcbiAqIFN0cmlwIGFsbCBjb21tZW50c1xuICpcbiAqIEBwYXJhbSAgIHtTdHJpbmd9IGBzdHJgICBmaWxlIGNvbnRlbnRzIG9yIHN0cmluZyB0byBzdHJpcC5cbiAqIEBwYXJhbSAgIHtPYmplY3R9IGBvcHRzYCAgb3B0aW9ucyBhcmUgcGFzc2VkIHRvIGAuYmxvY2tgLCBhbmQgYC5saW5lYFxuICogQHJldHVybiAge1N0cmluZ30gU3RyaW5nIHdpdGhvdXQgY29tbWVudHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHN0cmlwKHN0ciwgb3B0cykge1xuICByZXR1cm4gc3RyID8gc3RyaXAuYmxvY2soc3RyaXAubGluZShzdHIsIG9wdHMpLCBvcHRzKSA6ICcnO1xufVxuXG4vKipcbiAqIFN0cmlwIG9ubHkgYmxvY2sgY29tbWVudHMsIG9wdGlvbmFsbHkgbGVhdmluZyBwcm90ZWN0ZWQgY29tbWVudHNcbiAqIChlLmcuIGAvKiFgKSBpbnRhY3QuXG4gKlxuICogQHBhcmFtICAge1N0cmluZ30gYHN0cmAgIGZpbGUgY29udGVudCBvciBzdHJpbmcgdG8gc3RyaXAgdG9cbiAqIEBwYXJhbSAgIHtPYmplY3R9IGBvcHRzYCAgaWYgYHNhZmU6dHJ1ZWAsIHN0cmlwIG9ubHkgY29tbWVudHMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCBgLyohYCBvciBgLyoqIWBcbiAqIEByZXR1cm4gIHtTdHJpbmd9IFN0cmluZyB3aXRob3V0IGJsb2NrIGNvbW1lbnRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5zdHJpcC5ibG9jayA9IGZ1bmN0aW9uKHN0ciwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIHJlID0gcmVCbG9jazsgLy9uZXcgUmVnRXhwKHJlQmxvY2sgKyByZUJsb2NrRW5kLCAnZ20nKTtcbiAgaWYob3B0cy5zYWZlKSB7XG4gICAgcmUgPSByZUJsb2NrSWdub3JlOyAvL25ldyBSZWdFeHAocmVCbG9ja0lnbm9yZSArIHJlQmxvY2tFbmQsICdnbScpO1xuICB9XG4gIHJldHVybiBzdHIgPyBzdHIucmVwbGFjZShyZSwgJycpIDogJyc7XG59O1xuXG5cbi8qKlxuICogU3RyaXAgb25seSBsaW5lIGNvbW1lbnRzXG4gKlxuICogQHBhcmFtICAge1N0cmluZ30gYHN0cmAgIGZpbGUgY29udGVudCBvciBzdHJpbmcgdG8gc3RyaXAgdG9cbiAqIEBwYXJhbSAgIHtPYmplY3R9IGBvcHRzYCAgaWYgYHNhZmU6dHJ1ZWAsIHN0cmlwIGFsbCB0aGF0IG5vdCBzdGFydHMgd2l0aCBgLy8hYFxuICogQHJldHVybiAge1N0cmluZ30gU3RyaW5nIHdpdGhvdXQgbGluZSBjb21tZW50cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuc3RyaXAubGluZSA9IGZ1bmN0aW9uKHN0ciwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIHJlID0gcmVMaW5lO1xuICBpZihvcHRzLnNhZmUpIHtcbiAgICByZSA9IHJlTGluZUlnbm9yZTtcbiAgfVxuICByZXR1cm4gc3RyID8gc3RyLnJlcGxhY2UocmUsICcnKSA6ICcnO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYHN0cmlwYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaXA7IiwiIWZ1bmN0aW9uKCkge1xuICB2YXIgdG9wb2pzb24gPSB7XG4gICAgdmVyc2lvbjogXCIxLjYuMTlcIixcbiAgICBtZXNoOiBmdW5jdGlvbih0b3BvbG9neSkgeyByZXR1cm4gb2JqZWN0KHRvcG9sb2d5LCBtZXNoQXJjcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTsgfSxcbiAgICBtZXNoQXJjczogbWVzaEFyY3MsXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKHRvcG9sb2d5KSB7IHJldHVybiBvYmplY3QodG9wb2xvZ3ksIG1lcmdlQXJjcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTsgfSxcbiAgICBtZXJnZUFyY3M6IG1lcmdlQXJjcyxcbiAgICBmZWF0dXJlOiBmZWF0dXJlT3JDb2xsZWN0aW9uLFxuICAgIG5laWdoYm9yczogbmVpZ2hib3JzLFxuICAgIHByZXNpbXBsaWZ5OiBwcmVzaW1wbGlmeVxuICB9O1xuXG4gIGZ1bmN0aW9uIHN0aXRjaEFyY3ModG9wb2xvZ3ksIGFyY3MpIHtcbiAgICB2YXIgc3RpdGNoZWRBcmNzID0ge30sXG4gICAgICAgIGZyYWdtZW50QnlTdGFydCA9IHt9LFxuICAgICAgICBmcmFnbWVudEJ5RW5kID0ge30sXG4gICAgICAgIGZyYWdtZW50cyA9IFtdLFxuICAgICAgICBlbXB0eUluZGV4ID0gLTE7XG5cbiAgICAvLyBTdGl0Y2ggZW1wdHkgYXJjcyBmaXJzdCwgc2luY2UgdGhleSBtYXkgYmUgc3Vic3VtZWQgYnkgb3RoZXIgYXJjcy5cbiAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSwgaikge1xuICAgICAgdmFyIGFyYyA9IHRvcG9sb2d5LmFyY3NbaSA8IDAgPyB+aSA6IGldLCB0O1xuICAgICAgaWYgKGFyYy5sZW5ndGggPCAzICYmICFhcmNbMV1bMF0gJiYgIWFyY1sxXVsxXSkge1xuICAgICAgICB0ID0gYXJjc1srK2VtcHR5SW5kZXhdLCBhcmNzW2VtcHR5SW5kZXhdID0gaSwgYXJjc1tqXSA9IHQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgdmFyIGUgPSBlbmRzKGkpLFxuICAgICAgICAgIHN0YXJ0ID0gZVswXSxcbiAgICAgICAgICBlbmQgPSBlWzFdLFxuICAgICAgICAgIGYsIGc7XG5cbiAgICAgIGlmIChmID0gZnJhZ21lbnRCeUVuZFtzdGFydF0pIHtcbiAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZi5lbmRdO1xuICAgICAgICBmLnB1c2goaSk7XG4gICAgICAgIGYuZW5kID0gZW5kO1xuICAgICAgICBpZiAoZyA9IGZyYWdtZW50QnlTdGFydFtlbmRdKSB7XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtnLnN0YXJ0XTtcbiAgICAgICAgICB2YXIgZmcgPSBnID09PSBmID8gZiA6IGYuY29uY2F0KGcpO1xuICAgICAgICAgIGZyYWdtZW50QnlTdGFydFtmZy5zdGFydCA9IGYuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmZy5lbmQgPSBnLmVuZF0gPSBmZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kXSA9IGY7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZiA9IGZyYWdtZW50QnlTdGFydFtlbmRdKSB7XG4gICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XG4gICAgICAgIGYudW5zaGlmdChpKTtcbiAgICAgICAgZi5zdGFydCA9IHN0YXJ0O1xuICAgICAgICBpZiAoZyA9IGZyYWdtZW50QnlFbmRbc3RhcnRdKSB7XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZy5lbmRdO1xuICAgICAgICAgIHZhciBnZiA9IGcgPT09IGYgPyBmIDogZy5jb25jYXQoZik7XG4gICAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2dmLnN0YXJ0ID0gZy5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2dmLmVuZCA9IGYuZW5kXSA9IGdmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmRdID0gZjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZiA9IFtpXTtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnQgPSBzdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kID0gZW5kXSA9IGY7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBlbmRzKGkpIHtcbiAgICAgIHZhciBhcmMgPSB0b3BvbG9neS5hcmNzW2kgPCAwID8gfmkgOiBpXSwgcDAgPSBhcmNbMF0sIHAxO1xuICAgICAgaWYgKHRvcG9sb2d5LnRyYW5zZm9ybSkgcDEgPSBbMCwgMF0sIGFyYy5mb3JFYWNoKGZ1bmN0aW9uKGRwKSB7IHAxWzBdICs9IGRwWzBdLCBwMVsxXSArPSBkcFsxXTsgfSk7XG4gICAgICBlbHNlIHAxID0gYXJjW2FyYy5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiBpIDwgMCA/IFtwMSwgcDBdIDogW3AwLCBwMV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmx1c2goZnJhZ21lbnRCeUVuZCwgZnJhZ21lbnRCeVN0YXJ0KSB7XG4gICAgICBmb3IgKHZhciBrIGluIGZyYWdtZW50QnlFbmQpIHtcbiAgICAgICAgdmFyIGYgPSBmcmFnbWVudEJ5RW5kW2tdO1xuICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdO1xuICAgICAgICBkZWxldGUgZi5zdGFydDtcbiAgICAgICAgZGVsZXRlIGYuZW5kO1xuICAgICAgICBmLmZvckVhY2goZnVuY3Rpb24oaSkgeyBzdGl0Y2hlZEFyY3NbaSA8IDAgPyB+aSA6IGldID0gMTsgfSk7XG4gICAgICAgIGZyYWdtZW50cy5wdXNoKGYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZsdXNoKGZyYWdtZW50QnlFbmQsIGZyYWdtZW50QnlTdGFydCk7XG4gICAgZmx1c2goZnJhZ21lbnRCeVN0YXJ0LCBmcmFnbWVudEJ5RW5kKTtcbiAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSkgeyBpZiAoIXN0aXRjaGVkQXJjc1tpIDwgMCA/IH5pIDogaV0pIGZyYWdtZW50cy5wdXNoKFtpXSk7IH0pO1xuXG4gICAgcmV0dXJuIGZyYWdtZW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lc2hBcmNzKHRvcG9sb2d5LCBvLCBmaWx0ZXIpIHtcbiAgICB2YXIgYXJjcyA9IFtdO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgZ2VvbXNCeUFyYyA9IFtdLFxuICAgICAgICAgIGdlb207XG5cbiAgICAgIGZ1bmN0aW9uIGFyYyhpKSB7XG4gICAgICAgIHZhciBqID0gaSA8IDAgPyB+aSA6IGk7XG4gICAgICAgIChnZW9tc0J5QXJjW2pdIHx8IChnZW9tc0J5QXJjW2pdID0gW10pKS5wdXNoKHtpOiBpLCBnOiBnZW9tfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxpbmUoYXJjcykge1xuICAgICAgICBhcmNzLmZvckVhY2goYXJjKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcG9seWdvbihhcmNzKSB7XG4gICAgICAgIGFyY3MuZm9yRWFjaChsaW5lKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2VvbWV0cnkobykge1xuICAgICAgICBpZiAoby50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiKSBvLmdlb21ldHJpZXMuZm9yRWFjaChnZW9tZXRyeSk7XG4gICAgICAgIGVsc2UgaWYgKG8udHlwZSBpbiBnZW9tZXRyeVR5cGUpIGdlb20gPSBvLCBnZW9tZXRyeVR5cGVbby50eXBlXShvLmFyY3MpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ2VvbWV0cnlUeXBlID0ge1xuICAgICAgICBMaW5lU3RyaW5nOiBsaW5lLFxuICAgICAgICBNdWx0aUxpbmVTdHJpbmc6IHBvbHlnb24sXG4gICAgICAgIFBvbHlnb246IHBvbHlnb24sXG4gICAgICAgIE11bHRpUG9seWdvbjogZnVuY3Rpb24oYXJjcykgeyBhcmNzLmZvckVhY2gocG9seWdvbik7IH1cbiAgICAgIH07XG5cbiAgICAgIGdlb21ldHJ5KG8pO1xuXG4gICAgICBnZW9tc0J5QXJjLmZvckVhY2goYXJndW1lbnRzLmxlbmd0aCA8IDNcbiAgICAgICAgICA/IGZ1bmN0aW9uKGdlb21zKSB7IGFyY3MucHVzaChnZW9tc1swXS5pKTsgfVxuICAgICAgICAgIDogZnVuY3Rpb24oZ2VvbXMpIHsgaWYgKGZpbHRlcihnZW9tc1swXS5nLCBnZW9tc1tnZW9tcy5sZW5ndGggLSAxXS5nKSkgYXJjcy5wdXNoKGdlb21zWzBdLmkpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3BvbG9neS5hcmNzLmxlbmd0aDsgaSA8IG47ICsraSkgYXJjcy5wdXNoKGkpO1xuICAgIH1cblxuICAgIHJldHVybiB7dHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIiwgYXJjczogc3RpdGNoQXJjcyh0b3BvbG9neSwgYXJjcyl9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VBcmNzKHRvcG9sb2d5LCBvYmplY3RzKSB7XG4gICAgdmFyIHBvbHlnb25zQnlBcmMgPSB7fSxcbiAgICAgICAgcG9seWdvbnMgPSBbXSxcbiAgICAgICAgY29tcG9uZW50cyA9IFtdO1xuXG4gICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICAgIGlmIChvLnR5cGUgPT09IFwiUG9seWdvblwiKSByZWdpc3RlcihvLmFyY3MpO1xuICAgICAgZWxzZSBpZiAoby50eXBlID09PSBcIk11bHRpUG9seWdvblwiKSBvLmFyY3MuZm9yRWFjaChyZWdpc3Rlcik7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiByZWdpc3Rlcihwb2x5Z29uKSB7XG4gICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgICAgKHBvbHlnb25zQnlBcmNbYXJjID0gYXJjIDwgMCA/IH5hcmMgOiBhcmNdIHx8IChwb2x5Z29uc0J5QXJjW2FyY10gPSBbXSkpLnB1c2gocG9seWdvbik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBwb2x5Z29ucy5wdXNoKHBvbHlnb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVyaW9yKHJpbmcpIHtcbiAgICAgIHJldHVybiBjYXJ0ZXNpYW5SaW5nQXJlYShvYmplY3QodG9wb2xvZ3ksIHt0eXBlOiBcIlBvbHlnb25cIiwgYXJjczogW3JpbmddfSkuY29vcmRpbmF0ZXNbMF0pID4gMDsgLy8gVE9ETyBhbGxvdyBzcGhlcmljYWw/XG4gICAgfVxuXG4gICAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgICBpZiAoIXBvbHlnb24uXykge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gW10sXG4gICAgICAgICAgICBuZWlnaGJvcnMgPSBbcG9seWdvbl07XG4gICAgICAgIHBvbHlnb24uXyA9IDE7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICB3aGlsZSAocG9seWdvbiA9IG5laWdoYm9ycy5wb3AoKSkge1xuICAgICAgICAgIGNvbXBvbmVudC5wdXNoKHBvbHlnb24pO1xuICAgICAgICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nKSB7XG4gICAgICAgICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgICAgICAgIHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgICAgICAgICAgICAgIGlmICghcG9seWdvbi5fKSB7XG4gICAgICAgICAgICAgICAgICBwb2x5Z29uLl8gPSAxO1xuICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2gocG9seWdvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBwb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICAgIGRlbGV0ZSBwb2x5Z29uLl87XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJNdWx0aVBvbHlnb25cIixcbiAgICAgIGFyY3M6IGNvbXBvbmVudHMubWFwKGZ1bmN0aW9uKHBvbHlnb25zKSB7XG4gICAgICAgIHZhciBhcmNzID0gW107XG5cbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgZXh0ZXJpb3IgKHVuaXF1ZSkgYXJjcy5cbiAgICAgICAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgICAgICAgcG9seWdvbi5mb3JFYWNoKGZ1bmN0aW9uKHJpbmcpIHtcbiAgICAgICAgICAgIHJpbmcuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICAgICAgICAgICAgaWYgKHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICBhcmNzLnB1c2goYXJjKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN0aXRjaCB0aGUgYXJjcyBpbnRvIG9uZSBvciBtb3JlIHJpbmdzLlxuICAgICAgICBhcmNzID0gc3RpdGNoQXJjcyh0b3BvbG9neSwgYXJjcyk7XG5cbiAgICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSByaW5nIGlzIHJldHVybmVkLFxuICAgICAgICAvLyBhdCBtb3N0IG9uZSBvZiB0aGVzZSByaW5ncyBjYW4gYmUgdGhlIGV4dGVyaW9yO1xuICAgICAgICAvLyB0aGlzIGV4dGVyaW9yIHJpbmcgaGFzIHRoZSBzYW1lIHdpbmRpbmcgb3JkZXJcbiAgICAgICAgLy8gYXMgYW55IGV4dGVyaW9yIHJpbmcgaW4gdGhlIG9yaWdpbmFsIHBvbHlnb25zLlxuICAgICAgICBpZiAoKG4gPSBhcmNzLmxlbmd0aCkgPiAxKSB7XG4gICAgICAgICAgdmFyIHNnbiA9IGV4dGVyaW9yKHBvbHlnb25zWzBdWzBdKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgdDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgaWYgKHNnbiA9PT0gZXh0ZXJpb3IoYXJjc1tpXSkpIHtcbiAgICAgICAgICAgICAgdCA9IGFyY3NbMF0sIGFyY3NbMF0gPSBhcmNzW2ldLCBhcmNzW2ldID0gdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyY3M7XG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmZWF0dXJlT3JDb2xsZWN0aW9uKHRvcG9sb2d5LCBvKSB7XG4gICAgcmV0dXJuIG8udHlwZSA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIiA/IHtcbiAgICAgIHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICAgIGZlYXR1cmVzOiBvLmdlb21ldHJpZXMubWFwKGZ1bmN0aW9uKG8pIHsgcmV0dXJuIGZlYXR1cmUodG9wb2xvZ3ksIG8pOyB9KVxuICAgIH0gOiBmZWF0dXJlKHRvcG9sb2d5LCBvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZlYXR1cmUodG9wb2xvZ3ksIG8pIHtcbiAgICB2YXIgZiA9IHtcbiAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgaWQ6IG8uaWQsXG4gICAgICBwcm9wZXJ0aWVzOiBvLnByb3BlcnRpZXMgfHwge30sXG4gICAgICBnZW9tZXRyeTogb2JqZWN0KHRvcG9sb2d5LCBvKVxuICAgIH07XG4gICAgaWYgKG8uaWQgPT0gbnVsbCkgZGVsZXRlIGYuaWQ7XG4gICAgcmV0dXJuIGY7XG4gIH1cblxuICBmdW5jdGlvbiBvYmplY3QodG9wb2xvZ3ksIG8pIHtcbiAgICB2YXIgYWJzb2x1dGUgPSB0cmFuc2Zvcm1BYnNvbHV0ZSh0b3BvbG9neS50cmFuc2Zvcm0pLFxuICAgICAgICBhcmNzID0gdG9wb2xvZ3kuYXJjcztcblxuICAgIGZ1bmN0aW9uIGFyYyhpLCBwb2ludHMpIHtcbiAgICAgIGlmIChwb2ludHMubGVuZ3RoKSBwb2ludHMucG9wKCk7XG4gICAgICBmb3IgKHZhciBhID0gYXJjc1tpIDwgMCA/IH5pIDogaV0sIGsgPSAwLCBuID0gYS5sZW5ndGgsIHA7IGsgPCBuOyArK2spIHtcbiAgICAgICAgcG9pbnRzLnB1c2gocCA9IGFba10uc2xpY2UoKSk7XG4gICAgICAgIGFic29sdXRlKHAsIGspO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCAwKSByZXZlcnNlKHBvaW50cywgbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9pbnQocCkge1xuICAgICAgcCA9IHAuc2xpY2UoKTtcbiAgICAgIGFic29sdXRlKHAsIDApO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZShhcmNzKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFyY3MubGVuZ3RoOyBpIDwgbjsgKytpKSBhcmMoYXJjc1tpXSwgcG9pbnRzKTtcbiAgICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMikgcG9pbnRzLnB1c2gocG9pbnRzWzBdLnNsaWNlKCkpO1xuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nKGFyY3MpIHtcbiAgICAgIHZhciBwb2ludHMgPSBsaW5lKGFyY3MpO1xuICAgICAgd2hpbGUgKHBvaW50cy5sZW5ndGggPCA0KSBwb2ludHMucHVzaChwb2ludHNbMF0uc2xpY2UoKSk7XG4gICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvbHlnb24oYXJjcykge1xuICAgICAgcmV0dXJuIGFyY3MubWFwKHJpbmcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICAgIHZhciB0ID0gby50eXBlO1xuICAgICAgcmV0dXJuIHQgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIgPyB7dHlwZTogdCwgZ2VvbWV0cmllczogby5nZW9tZXRyaWVzLm1hcChnZW9tZXRyeSl9XG4gICAgICAgICAgOiB0IGluIGdlb21ldHJ5VHlwZSA/IHt0eXBlOiB0LCBjb29yZGluYXRlczogZ2VvbWV0cnlUeXBlW3RdKG8pfVxuICAgICAgICAgIDogbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZ2VvbWV0cnlUeXBlID0ge1xuICAgICAgUG9pbnQ6IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIHBvaW50KG8uY29vcmRpbmF0ZXMpOyB9LFxuICAgICAgTXVsdGlQb2ludDogZnVuY3Rpb24obykgeyByZXR1cm4gby5jb29yZGluYXRlcy5tYXAocG9pbnQpOyB9LFxuICAgICAgTGluZVN0cmluZzogZnVuY3Rpb24obykgeyByZXR1cm4gbGluZShvLmFyY3MpOyB9LFxuICAgICAgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFyY3MubWFwKGxpbmUpOyB9LFxuICAgICAgUG9seWdvbjogZnVuY3Rpb24obykgeyByZXR1cm4gcG9seWdvbihvLmFyY3MpOyB9LFxuICAgICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFyY3MubWFwKHBvbHlnb24pOyB9XG4gICAgfTtcblxuICAgIHJldHVybiBnZW9tZXRyeShvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldmVyc2UoYXJyYXksIG4pIHtcbiAgICB2YXIgdCwgaiA9IGFycmF5Lmxlbmd0aCwgaSA9IGogLSBuOyB3aGlsZSAoaSA8IC0taikgdCA9IGFycmF5W2ldLCBhcnJheVtpKytdID0gYXJyYXlbal0sIGFycmF5W2pdID0gdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpc2VjdChhLCB4KSB7XG4gICAgdmFyIGxvID0gMCwgaGkgPSBhLmxlbmd0aDtcbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICBpZiAoYVttaWRdIDwgeCkgbG8gPSBtaWQgKyAxO1xuICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvO1xuICB9XG5cbiAgZnVuY3Rpb24gbmVpZ2hib3JzKG9iamVjdHMpIHtcbiAgICB2YXIgaW5kZXhlc0J5QXJjID0ge30sIC8vIGFyYyBpbmRleCAtPiBhcnJheSBvZiBvYmplY3QgaW5kZXhlc1xuICAgICAgICBuZWlnaGJvcnMgPSBvYmplY3RzLm1hcChmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9KTtcblxuICAgIGZ1bmN0aW9uIGxpbmUoYXJjcywgaSkge1xuICAgICAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgaWYgKGEgPCAwKSBhID0gfmE7XG4gICAgICAgIHZhciBvID0gaW5kZXhlc0J5QXJjW2FdO1xuICAgICAgICBpZiAobykgby5wdXNoKGkpO1xuICAgICAgICBlbHNlIGluZGV4ZXNCeUFyY1thXSA9IFtpXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvbHlnb24oYXJjcywgaSkge1xuICAgICAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykgeyBsaW5lKGFyYywgaSk7IH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlb21ldHJ5KG8sIGkpIHtcbiAgICAgIGlmIChvLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIpIG8uZ2VvbWV0cmllcy5mb3JFYWNoKGZ1bmN0aW9uKG8pIHsgZ2VvbWV0cnkobywgaSk7IH0pO1xuICAgICAgZWxzZSBpZiAoby50eXBlIGluIGdlb21ldHJ5VHlwZSkgZ2VvbWV0cnlUeXBlW28udHlwZV0oby5hcmNzLCBpKTtcbiAgICB9XG5cbiAgICB2YXIgZ2VvbWV0cnlUeXBlID0ge1xuICAgICAgTGluZVN0cmluZzogbGluZSxcbiAgICAgIE11bHRpTGluZVN0cmluZzogcG9seWdvbixcbiAgICAgIFBvbHlnb246IHBvbHlnb24sXG4gICAgICBNdWx0aVBvbHlnb246IGZ1bmN0aW9uKGFyY3MsIGkpIHsgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykgeyBwb2x5Z29uKGFyYywgaSk7IH0pOyB9XG4gICAgfTtcblxuICAgIG9iamVjdHMuZm9yRWFjaChnZW9tZXRyeSk7XG5cbiAgICBmb3IgKHZhciBpIGluIGluZGV4ZXNCeUFyYykge1xuICAgICAgZm9yICh2YXIgaW5kZXhlcyA9IGluZGV4ZXNCeUFyY1tpXSwgbSA9IGluZGV4ZXMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICBmb3IgKHZhciBrID0gaiArIDE7IGsgPCBtOyArK2spIHtcbiAgICAgICAgICB2YXIgaWogPSBpbmRleGVzW2pdLCBpayA9IGluZGV4ZXNba10sIG47XG4gICAgICAgICAgaWYgKChuID0gbmVpZ2hib3JzW2lqXSlbaSA9IGJpc2VjdChuLCBpayldICE9PSBpaykgbi5zcGxpY2UoaSwgMCwgaWspO1xuICAgICAgICAgIGlmICgobiA9IG5laWdoYm9yc1tpa10pW2kgPSBiaXNlY3QobiwgaWopXSAhPT0gaWopIG4uc3BsaWNlKGksIDAsIGlqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZWlnaGJvcnM7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVzaW1wbGlmeSh0b3BvbG9neSwgdHJpYW5nbGVBcmVhKSB7XG4gICAgdmFyIGFic29sdXRlID0gdHJhbnNmb3JtQWJzb2x1dGUodG9wb2xvZ3kudHJhbnNmb3JtKSxcbiAgICAgICAgcmVsYXRpdmUgPSB0cmFuc2Zvcm1SZWxhdGl2ZSh0b3BvbG9neS50cmFuc2Zvcm0pLFxuICAgICAgICBoZWFwID0gbWluQXJlYUhlYXAoKTtcblxuICAgIGlmICghdHJpYW5nbGVBcmVhKSB0cmlhbmdsZUFyZWEgPSBjYXJ0ZXNpYW5UcmlhbmdsZUFyZWE7XG5cbiAgICB0b3BvbG9neS5hcmNzLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICB2YXIgdHJpYW5nbGVzID0gW10sXG4gICAgICAgICAgbWF4QXJlYSA9IDAsXG4gICAgICAgICAgdHJpYW5nbGU7XG5cbiAgICAgIC8vIFRvIHN0b3JlIGVhY2ggcG9pbnTigJlzIGVmZmVjdGl2ZSBhcmVhLCB3ZSBjcmVhdGUgYSBuZXcgYXJyYXkgcmF0aGVyIHRoYW5cbiAgICAgIC8vIGV4dGVuZGluZyB0aGUgcGFzc2VkLWluIHBvaW50IHRvIHdvcmthcm91bmQgYSBDaHJvbWUvVjggYnVnIChnZXR0aW5nXG4gICAgICAvLyBzdHVjayBpbiBzbWkgbW9kZSkuIEZvciBtaWRwb2ludHMsIHRoZSBpbml0aWFsIGVmZmVjdGl2ZSBhcmVhIG9mXG4gICAgICAvLyBJbmZpbml0eSB3aWxsIGJlIGNvbXB1dGVkIGluIHRoZSBuZXh0IHN0ZXAuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFyYy5sZW5ndGgsIHA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgcCA9IGFyY1tpXTtcbiAgICAgICAgYWJzb2x1dGUoYXJjW2ldID0gW3BbMF0sIHBbMV0sIEluZmluaXR5XSwgaSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBuID0gYXJjLmxlbmd0aCAtIDE7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdHJpYW5nbGUgPSBhcmMuc2xpY2UoaSAtIDEsIGkgKyAyKTtcbiAgICAgICAgdHJpYW5nbGVbMV1bMl0gPSB0cmlhbmdsZUFyZWEodHJpYW5nbGUpO1xuICAgICAgICB0cmlhbmdsZXMucHVzaCh0cmlhbmdsZSk7XG4gICAgICAgIGhlYXAucHVzaCh0cmlhbmdsZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHJpYW5nbGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICB0cmlhbmdsZSA9IHRyaWFuZ2xlc1tpXTtcbiAgICAgICAgdHJpYW5nbGUucHJldmlvdXMgPSB0cmlhbmdsZXNbaSAtIDFdO1xuICAgICAgICB0cmlhbmdsZS5uZXh0ID0gdHJpYW5nbGVzW2kgKyAxXTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRyaWFuZ2xlID0gaGVhcC5wb3AoKSkge1xuICAgICAgICB2YXIgcHJldmlvdXMgPSB0cmlhbmdsZS5wcmV2aW91cyxcbiAgICAgICAgICAgIG5leHQgPSB0cmlhbmdsZS5uZXh0O1xuXG4gICAgICAgIC8vIElmIHRoZSBhcmVhIG9mIHRoZSBjdXJyZW50IHBvaW50IGlzIGxlc3MgdGhhbiB0aGF0IG9mIHRoZSBwcmV2aW91cyBwb2ludFxuICAgICAgICAvLyB0byBiZSBlbGltaW5hdGVkLCB1c2UgdGhlIGxhdHRlcidzIGFyZWEgaW5zdGVhZC4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgcG9pbnQgY2Fubm90IGJlIGVsaW1pbmF0ZWQgd2l0aG91dCBlbGltaW5hdGluZyBwcmV2aW91c2x5LVxuICAgICAgICAvLyBlbGltaW5hdGVkIHBvaW50cy5cbiAgICAgICAgaWYgKHRyaWFuZ2xlWzFdWzJdIDwgbWF4QXJlYSkgdHJpYW5nbGVbMV1bMl0gPSBtYXhBcmVhO1xuICAgICAgICBlbHNlIG1heEFyZWEgPSB0cmlhbmdsZVsxXVsyXTtcblxuICAgICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcbiAgICAgICAgICBwcmV2aW91c1syXSA9IHRyaWFuZ2xlWzJdO1xuICAgICAgICAgIHVwZGF0ZShwcmV2aW91cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICBuZXh0WzBdID0gdHJpYW5nbGVbMF07XG4gICAgICAgICAgdXBkYXRlKG5leHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFyYy5mb3JFYWNoKHJlbGF0aXZlKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZSh0cmlhbmdsZSkge1xuICAgICAgaGVhcC5yZW1vdmUodHJpYW5nbGUpO1xuICAgICAgdHJpYW5nbGVbMV1bMl0gPSB0cmlhbmdsZUFyZWEodHJpYW5nbGUpO1xuICAgICAgaGVhcC5wdXNoKHRyaWFuZ2xlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9wb2xvZ3k7XG4gIH07XG5cbiAgZnVuY3Rpb24gY2FydGVzaWFuUmluZ0FyZWEocmluZykge1xuICAgIHZhciBpID0gLTEsXG4gICAgICAgIG4gPSByaW5nLmxlbmd0aCxcbiAgICAgICAgYSxcbiAgICAgICAgYiA9IHJpbmdbbiAtIDFdLFxuICAgICAgICBhcmVhID0gMDtcblxuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBhID0gYjtcbiAgICAgIGIgPSByaW5nW2ldO1xuICAgICAgYXJlYSArPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBhcmVhICogLjU7XG4gIH1cblxuICBmdW5jdGlvbiBjYXJ0ZXNpYW5UcmlhbmdsZUFyZWEodHJpYW5nbGUpIHtcbiAgICB2YXIgYSA9IHRyaWFuZ2xlWzBdLCBiID0gdHJpYW5nbGVbMV0sIGMgPSB0cmlhbmdsZVsyXTtcbiAgICByZXR1cm4gTWF0aC5hYnMoKGFbMF0gLSBjWzBdKSAqIChiWzFdIC0gYVsxXSkgLSAoYVswXSAtIGJbMF0pICogKGNbMV0gLSBhWzFdKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlQXJlYShhLCBiKSB7XG4gICAgcmV0dXJuIGFbMV1bMl0gLSBiWzFdWzJdO1xuICB9XG5cbiAgZnVuY3Rpb24gbWluQXJlYUhlYXAoKSB7XG4gICAgdmFyIGhlYXAgPSB7fSxcbiAgICAgICAgYXJyYXkgPSBbXSxcbiAgICAgICAgc2l6ZSA9IDA7XG5cbiAgICBoZWFwLnB1c2ggPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHVwKGFycmF5W29iamVjdC5fID0gc2l6ZV0gPSBvYmplY3QsIHNpemUrKyk7XG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9O1xuXG4gICAgaGVhcC5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzaXplIDw9IDApIHJldHVybjtcbiAgICAgIHZhciByZW1vdmVkID0gYXJyYXlbMF0sIG9iamVjdDtcbiAgICAgIGlmICgtLXNpemUgPiAwKSBvYmplY3QgPSBhcnJheVtzaXplXSwgZG93bihhcnJheVtvYmplY3QuXyA9IDBdID0gb2JqZWN0LCAwKTtcbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH07XG5cbiAgICBoZWFwLnJlbW92ZSA9IGZ1bmN0aW9uKHJlbW92ZWQpIHtcbiAgICAgIHZhciBpID0gcmVtb3ZlZC5fLCBvYmplY3Q7XG4gICAgICBpZiAoYXJyYXlbaV0gIT09IHJlbW92ZWQpIHJldHVybjsgLy8gaW52YWxpZCByZXF1ZXN0XG4gICAgICBpZiAoaSAhPT0gLS1zaXplKSBvYmplY3QgPSBhcnJheVtzaXplXSwgKGNvbXBhcmVBcmVhKG9iamVjdCwgcmVtb3ZlZCkgPCAwID8gdXAgOiBkb3duKShhcnJheVtvYmplY3QuXyA9IGldID0gb2JqZWN0LCBpKTtcbiAgICAgIHJldHVybiBpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB1cChvYmplY3QsIGkpIHtcbiAgICAgIHdoaWxlIChpID4gMCkge1xuICAgICAgICB2YXIgaiA9ICgoaSArIDEpID4+IDEpIC0gMSxcbiAgICAgICAgICAgIHBhcmVudCA9IGFycmF5W2pdO1xuICAgICAgICBpZiAoY29tcGFyZUFyZWEob2JqZWN0LCBwYXJlbnQpID49IDApIGJyZWFrO1xuICAgICAgICBhcnJheVtwYXJlbnQuXyA9IGldID0gcGFyZW50O1xuICAgICAgICBhcnJheVtvYmplY3QuXyA9IGkgPSBqXSA9IG9iamVjdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb3duKG9iamVjdCwgaSkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIHIgPSAoaSArIDEpIDw8IDEsXG4gICAgICAgICAgICBsID0gciAtIDEsXG4gICAgICAgICAgICBqID0gaSxcbiAgICAgICAgICAgIGNoaWxkID0gYXJyYXlbal07XG4gICAgICAgIGlmIChsIDwgc2l6ZSAmJiBjb21wYXJlQXJlYShhcnJheVtsXSwgY2hpbGQpIDwgMCkgY2hpbGQgPSBhcnJheVtqID0gbF07XG4gICAgICAgIGlmIChyIDwgc2l6ZSAmJiBjb21wYXJlQXJlYShhcnJheVtyXSwgY2hpbGQpIDwgMCkgY2hpbGQgPSBhcnJheVtqID0gcl07XG4gICAgICAgIGlmIChqID09PSBpKSBicmVhaztcbiAgICAgICAgYXJyYXlbY2hpbGQuXyA9IGldID0gY2hpbGQ7XG4gICAgICAgIGFycmF5W29iamVjdC5fID0gaSA9IGpdID0gb2JqZWN0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoZWFwO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtQWJzb2x1dGUodHJhbnNmb3JtKSB7XG4gICAgaWYgKCF0cmFuc2Zvcm0pIHJldHVybiBub29wO1xuICAgIHZhciB4MCxcbiAgICAgICAgeTAsXG4gICAgICAgIGt4ID0gdHJhbnNmb3JtLnNjYWxlWzBdLFxuICAgICAgICBreSA9IHRyYW5zZm9ybS5zY2FsZVsxXSxcbiAgICAgICAgZHggPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzBdLFxuICAgICAgICBkeSA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMV07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBvaW50LCBpKSB7XG4gICAgICBpZiAoIWkpIHgwID0geTAgPSAwO1xuICAgICAgcG9pbnRbMF0gPSAoeDAgKz0gcG9pbnRbMF0pICoga3ggKyBkeDtcbiAgICAgIHBvaW50WzFdID0gKHkwICs9IHBvaW50WzFdKSAqIGt5ICsgZHk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVJlbGF0aXZlKHRyYW5zZm9ybSkge1xuICAgIGlmICghdHJhbnNmb3JtKSByZXR1cm4gbm9vcDtcbiAgICB2YXIgeDAsXG4gICAgICAgIHkwLFxuICAgICAgICBreCA9IHRyYW5zZm9ybS5zY2FsZVswXSxcbiAgICAgICAga3kgPSB0cmFuc2Zvcm0uc2NhbGVbMV0sXG4gICAgICAgIGR4ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVswXSxcbiAgICAgICAgZHkgPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzFdO1xuICAgIHJldHVybiBmdW5jdGlvbihwb2ludCwgaSkge1xuICAgICAgaWYgKCFpKSB4MCA9IHkwID0gMDtcbiAgICAgIHZhciB4MSA9IChwb2ludFswXSAtIGR4KSAvIGt4IHwgMCxcbiAgICAgICAgICB5MSA9IChwb2ludFsxXSAtIGR5KSAvIGt5IHwgMDtcbiAgICAgIHBvaW50WzBdID0geDEgLSB4MDtcbiAgICAgIHBvaW50WzFdID0geTEgLSB5MDtcbiAgICAgIHgwID0geDE7XG4gICAgICB5MCA9IHkxO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBub29wKCkge31cblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIGRlZmluZSh0b3BvanNvbik7XG4gIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlLmV4cG9ydHMpIG1vZHVsZS5leHBvcnRzID0gdG9wb2pzb247XG4gIGVsc2UgdGhpcy50b3BvanNvbiA9IHRvcG9qc29uO1xufSgpO1xuIiwibW9kdWxlLmV4cG9ydHMuVmVjdG9yVGlsZSA9IHJlcXVpcmUoJy4vbGliL3ZlY3RvcnRpbGUuanMnKTtcbm1vZHVsZS5leHBvcnRzLlZlY3RvclRpbGVGZWF0dXJlID0gcmVxdWlyZSgnLi9saWIvdmVjdG9ydGlsZWZlYXR1cmUuanMnKTtcbm1vZHVsZS5leHBvcnRzLlZlY3RvclRpbGVMYXllciA9IHJlcXVpcmUoJy4vbGliL3ZlY3RvcnRpbGVsYXllci5qcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjdG9yVGlsZUxheWVyID0gcmVxdWlyZSgnLi92ZWN0b3J0aWxlbGF5ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlKHBiZiwgZW5kKSB7XG4gICAgdGhpcy5sYXllcnMgPSBwYmYucmVhZEZpZWxkcyhyZWFkVGlsZSwge30sIGVuZCk7XG59XG5cbmZ1bmN0aW9uIHJlYWRUaWxlKHRhZywgbGF5ZXJzLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAzKSB7XG4gICAgICAgIHZhciBsYXllciA9IG5ldyBWZWN0b3JUaWxlTGF5ZXIocGJmLCBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyk7XG4gICAgICAgIGlmIChsYXllci5sZW5ndGgpIGxheWVyc1tsYXllci5uYW1lXSA9IGxheWVyO1xuICAgIH1cbn1cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGVGZWF0dXJlO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlRmVhdHVyZShwYmYsIGVuZCwgZXh0ZW50LCBrZXlzLCB2YWx1ZXMpIHtcbiAgICAvLyBQdWJsaWNcbiAgICB0aGlzLnByb3BlcnRpZXMgPSB7fTtcbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudDtcbiAgICB0aGlzLnR5cGUgPSAwO1xuXG4gICAgLy8gUHJpdmF0ZVxuICAgIHRoaXMuX3BiZiA9IHBiZjtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IC0xO1xuICAgIHRoaXMuX2tleXMgPSBrZXlzO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcblxuICAgIHBiZi5yZWFkRmllbGRzKHJlYWRGZWF0dXJlLCB0aGlzLCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkRmVhdHVyZSh0YWcsIGZlYXR1cmUsIHBiZikge1xuICAgIGlmICh0YWcgPT0gMSkgZmVhdHVyZS5faWQgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PSAyKSByZWFkVGFnKHBiZiwgZmVhdHVyZSk7XG4gICAgZWxzZSBpZiAodGFnID09IDMpIGZlYXR1cmUudHlwZSA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09IDQpIGZlYXR1cmUuX2dlb21ldHJ5ID0gcGJmLnBvcztcbn1cblxuZnVuY3Rpb24gcmVhZFRhZyhwYmYsIGZlYXR1cmUpIHtcbiAgICB2YXIgZW5kID0gcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3M7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIga2V5ID0gZmVhdHVyZS5fa2V5c1twYmYucmVhZFZhcmludCgpXSxcbiAgICAgICAgICAgIHZhbHVlID0gZmVhdHVyZS5fdmFsdWVzW3BiZi5yZWFkVmFyaW50KCldO1xuICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbn1cblxuVmVjdG9yVGlsZUZlYXR1cmUudHlwZXMgPSBbJ1Vua25vd24nLCAnUG9pbnQnLCAnTGluZVN0cmluZycsICdQb2x5Z29uJ107XG5cblZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS5sb2FkR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGJmID0gdGhpcy5fcGJmO1xuICAgIHBiZi5wb3MgPSB0aGlzLl9nZW9tZXRyeTtcblxuICAgIHZhciBlbmQgPSBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyxcbiAgICAgICAgY21kID0gMSxcbiAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICBsaW5lcyA9IFtdLFxuICAgICAgICBsaW5lO1xuXG4gICAgd2hpbGUgKHBiZi5wb3MgPCBlbmQpIHtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjbWRMZW4gPSBwYmYucmVhZFZhcmludCgpO1xuICAgICAgICAgICAgY21kID0gY21kTGVuICYgMHg3O1xuICAgICAgICAgICAgbGVuZ3RoID0gY21kTGVuID4+IDM7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGgtLTtcblxuICAgICAgICBpZiAoY21kID09PSAxIHx8IGNtZCA9PT0gMikge1xuICAgICAgICAgICAgeCArPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIHkgKz0gcGJmLnJlYWRTVmFyaW50KCk7XG5cbiAgICAgICAgICAgIGlmIChjbWQgPT09IDEpIHsgLy8gbW92ZVRvXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUpIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgbGluZSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5lLnB1c2gobmV3IFBvaW50KHgsIHkpKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNtZCA9PT0gNykge1xuICAgICAgICAgICAgbGluZS5wdXNoKGxpbmVbMF0uY2xvbmUoKSk7IC8vIGNsb3NlUG9seWdvblxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY29tbWFuZCAnICsgY21kKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsaW5lKSBsaW5lcy5wdXNoKGxpbmUpO1xuXG4gICAgcmV0dXJuIGxpbmVzO1xufTtcblxuVmVjdG9yVGlsZUZlYXR1cmUucHJvdG90eXBlLmJib3ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGJmID0gdGhpcy5fcGJmO1xuICAgIHBiZi5wb3MgPSB0aGlzLl9nZW9tZXRyeTtcblxuICAgIHZhciBlbmQgPSBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyxcbiAgICAgICAgY21kID0gMSxcbiAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICB4MSA9IEluZmluaXR5LFxuICAgICAgICB4MiA9IC1JbmZpbml0eSxcbiAgICAgICAgeTEgPSBJbmZpbml0eSxcbiAgICAgICAgeTIgPSAtSW5maW5pdHk7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNtZExlbiA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgICAgICAgICBjbWQgPSBjbWRMZW4gJiAweDc7XG4gICAgICAgICAgICBsZW5ndGggPSBjbWRMZW4gPj4gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aC0tO1xuXG4gICAgICAgIGlmIChjbWQgPT09IDEgfHwgY21kID09PSAyKSB7XG4gICAgICAgICAgICB4ICs9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgICAgICAgICAgeSArPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIGlmICh4IDwgeDEpIHgxID0geDtcbiAgICAgICAgICAgIGlmICh4ID4geDIpIHgyID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgeTEpIHkxID0geTtcbiAgICAgICAgICAgIGlmICh5ID4geTIpIHkyID0geTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNtZCAhPT0gNykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbW1hbmQgJyArIGNtZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3gxLCB5MSwgeDIsIHkyXTtcbn07XG5cblZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLmV4dGVudCAqIE1hdGgucG93KDIsIHopLFxuICAgICAgICB4MCA9IHRoaXMuZXh0ZW50ICogeCxcbiAgICAgICAgeTAgPSB0aGlzLmV4dGVudCAqIHksXG4gICAgICAgIGNvb3JkcyA9IHRoaXMubG9hZEdlb21ldHJ5KCksXG4gICAgICAgIHR5cGUgPSBWZWN0b3JUaWxlRmVhdHVyZS50eXBlc1t0aGlzLnR5cGVdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBjb29yZHNbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHAgPSBsaW5lW2pdLCB5MiA9IDE4MCAtIChwLnkgKyB5MCkgKiAzNjAgLyBzaXplO1xuICAgICAgICAgICAgbGluZVtqXSA9IFtcbiAgICAgICAgICAgICAgICAocC54ICsgeDApICogMzYwIC8gc2l6ZSAtIDE4MCxcbiAgICAgICAgICAgICAgICAzNjAgLyBNYXRoLlBJICogTWF0aC5hdGFuKE1hdGguZXhwKHkyICogTWF0aC5QSSAvIDE4MCkpIC0gOTBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ1BvaW50JyAmJiBjb29yZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvb3JkcyA9IGNvb3Jkc1swXVswXTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdQb2ludCcpIHtcbiAgICAgICAgY29vcmRzID0gY29vcmRzWzBdO1xuICAgICAgICB0eXBlID0gJ011bHRpUG9pbnQnO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0xpbmVTdHJpbmcnICYmIGNvb3Jkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29vcmRzID0gY29vcmRzWzBdO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgIHR5cGUgPSAnTXVsdGlMaW5lU3RyaW5nJztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBjb29yZGluYXRlczogY29vcmRzXG4gICAgICAgIH0sXG4gICAgICAgIHByb3BlcnRpZXM6IHRoaXMucHJvcGVydGllc1xuICAgIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjdG9yVGlsZUZlYXR1cmUgPSByZXF1aXJlKCcuL3ZlY3RvcnRpbGVmZWF0dXJlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yVGlsZUxheWVyO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlTGF5ZXIocGJmLCBlbmQpIHtcbiAgICAvLyBQdWJsaWNcbiAgICB0aGlzLnZlcnNpb24gPSAxO1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5leHRlbnQgPSA0MDk2O1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFByaXZhdGVcbiAgICB0aGlzLl9wYmYgPSBwYmY7XG4gICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgIHRoaXMuX2ZlYXR1cmVzID0gW107XG5cbiAgICBwYmYucmVhZEZpZWxkcyhyZWFkTGF5ZXIsIHRoaXMsIGVuZCk7XG5cbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuX2ZlYXR1cmVzLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gcmVhZExheWVyKHRhZywgbGF5ZXIsIHBiZikge1xuICAgIGlmICh0YWcgPT09IDE1KSBsYXllci52ZXJzaW9uID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDEpIGxheWVyLm5hbWUgPSBwYmYucmVhZFN0cmluZygpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNSkgbGF5ZXIuZXh0ZW50ID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDIpIGxheWVyLl9mZWF0dXJlcy5wdXNoKHBiZi5wb3MpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMykgbGF5ZXIuX2tleXMucHVzaChwYmYucmVhZFN0cmluZygpKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDQpIGxheWVyLl92YWx1ZXMucHVzaChyZWFkVmFsdWVNZXNzYWdlKHBiZikpO1xufVxuXG5mdW5jdGlvbiByZWFkVmFsdWVNZXNzYWdlKHBiZikge1xuICAgIHZhciB2YWx1ZSA9IG51bGwsXG4gICAgICAgIGVuZCA9IHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zO1xuXG4gICAgd2hpbGUgKHBiZi5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHRhZyA9IHBiZi5yZWFkVmFyaW50KCkgPj4gMztcblxuICAgICAgICB2YWx1ZSA9IHRhZyA9PT0gMSA/IHBiZi5yZWFkU3RyaW5nKCkgOlxuICAgICAgICAgICAgdGFnID09PSAyID8gcGJmLnJlYWRGbG9hdCgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gMyA/IHBiZi5yZWFkRG91YmxlKCkgOlxuICAgICAgICAgICAgdGFnID09PSA0ID8gcGJmLnJlYWRWYXJpbnQ2NCgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gNSA/IHBiZi5yZWFkVmFyaW50KCkgOlxuICAgICAgICAgICAgdGFnID09PSA2ID8gcGJmLnJlYWRTVmFyaW50KCkgOlxuICAgICAgICAgICAgdGFnID09PSA3ID8gcGJmLnJlYWRCb29sZWFuKCkgOiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gcmV0dXJuIGZlYXR1cmUgYGlgIGZyb20gdGhpcyBsYXllciBhcyBhIGBWZWN0b3JUaWxlRmVhdHVyZWBcblZlY3RvclRpbGVMYXllci5wcm90b3R5cGUuZmVhdHVyZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLl9mZWF0dXJlcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignZmVhdHVyZSBpbmRleCBvdXQgb2YgYm91bmRzJyk7XG5cbiAgICB0aGlzLl9wYmYucG9zID0gdGhpcy5fZmVhdHVyZXNbaV07XG5cbiAgICB2YXIgZW5kID0gdGhpcy5fcGJmLnJlYWRWYXJpbnQoKSArIHRoaXMuX3BiZi5wb3M7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3JUaWxlRmVhdHVyZSh0aGlzLl9wYmYsIGVuZCwgdGhpcy5leHRlbnQsIHRoaXMuX2tleXMsIHRoaXMuX3ZhbHVlcyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG5mdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xufVxuXG5Qb2ludC5wcm90b3R5cGUgPSB7XG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTsgfSxcblxuICAgIGFkZDogICAgIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHApOyAgICAgfSxcbiAgICBzdWI6ICAgICBmdW5jdGlvbihwKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3N1YihwKTsgICAgIH0sXG4gICAgbXVsdDogICAgZnVuY3Rpb24oaykgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0KGspOyAgICB9LFxuICAgIGRpdjogICAgIGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2KGspOyAgICAgfSxcbiAgICByb3RhdGU6ICBmdW5jdGlvbihhKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3JvdGF0ZShhKTsgIH0sXG4gICAgbWF0TXVsdDogZnVuY3Rpb24obSkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9tYXRNdWx0KG0pOyB9LFxuICAgIHVuaXQ6ICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl91bml0KCk7IH0sXG4gICAgcGVycDogICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3BlcnAoKTsgfSxcbiAgICByb3VuZDogICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTsgfSxcblxuICAgIG1hZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IHAueCAmJlxuICAgICAgICAgICAgICAgdGhpcy55ID09PSBwLnk7XG4gICAgfSxcblxuICAgIGRpc3Q6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RTcXIocCkpO1xuICAgIH0sXG5cbiAgICBkaXN0U3FyOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHZhciBkeCA9IHAueCAtIHRoaXMueCxcbiAgICAgICAgICAgIGR5ID0gcC55IC0gdGhpcy55O1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfSxcblxuICAgIGFuZ2xlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuICAgIH0sXG5cbiAgICBhbmdsZVRvOiBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSAtIGIueSwgdGhpcy54IC0gYi54KTtcbiAgICB9LFxuXG4gICAgYW5nbGVXaXRoOiBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuZ2xlV2l0aFNlcChiLngsIGIueSk7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgdGhlIGFuZ2xlIG9mIHRoZSB0d28gdmVjdG9ycywgc29sdmluZyB0aGUgZm9ybXVsYSBmb3IgdGhlIGNyb3NzIHByb2R1Y3QgYSB4IGIgPSB8YXx8YnxzaW4ozrgpIGZvciDOuC5cbiAgICBhbmdsZVdpdGhTZXA6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIoXG4gICAgICAgICAgICB0aGlzLnggKiB5IC0gdGhpcy55ICogeCxcbiAgICAgICAgICAgIHRoaXMueCAqIHggKyB0aGlzLnkgKiB5KTtcbiAgICB9LFxuXG4gICAgX21hdE11bHQ6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgdmFyIHggPSBtWzBdICogdGhpcy54ICsgbVsxXSAqIHRoaXMueSxcbiAgICAgICAgICAgIHkgPSBtWzJdICogdGhpcy54ICsgbVszXSAqIHRoaXMueTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9hZGQ6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdGhpcy54ICs9IHAueDtcbiAgICAgICAgdGhpcy55ICs9IHAueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9zdWI6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdGhpcy54IC09IHAueDtcbiAgICAgICAgdGhpcy55IC09IHAueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9tdWx0OiBmdW5jdGlvbihrKSB7XG4gICAgICAgIHRoaXMueCAqPSBrO1xuICAgICAgICB0aGlzLnkgKj0gaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9kaXY6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdGhpcy54IC89IGs7XG4gICAgICAgIHRoaXMueSAvPSBrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3VuaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9kaXYodGhpcy5tYWcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcGVycDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgICB0aGlzLnkgPSB0aGlzLng7XG4gICAgICAgIHRoaXMueCA9IC15O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3JvdGF0ZTogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIHggPSBjb3MgKiB0aGlzLnggLSBzaW4gKiB0aGlzLnksXG4gICAgICAgICAgICB5ID0gc2luICogdGhpcy54ICsgY29zICogdGhpcy55O1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3JvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbi8vIGNvbnN0cnVjdHMgUG9pbnQgZnJvbSBhbiBhcnJheSBpZiBuZWNlc3NhcnlcblBvaW50LmNvbnZlcnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIGlmIChhIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoYVswXSwgYVsxXSk7XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcbiIsIi8qZ2xvYmFsIENhbWVyYSAqL1xuaW1wb3J0IEdlbyBmcm9tICcuL2dlbyc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy91dGlscyc7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tICcuL2dsL3NoYWRlcl9wcm9ncmFtJztcblxuaW1wb3J0IGdsTWF0cml4IGZyb20gJ2dsLW1hdHJpeCc7XG52YXIgbWF0NCA9IGdsTWF0cml4Lm1hdDQ7XG52YXIgdmVjMyA9IGdsTWF0cml4LnZlYzM7XG5cbi8vIEFic3RyYWN0IGJhc2UgY2xhc3NcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbWVyYSB7XG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzY2VuZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgICAgIHRoaXMuem9vbSA9IG9wdGlvbnMuem9vbTtcbiAgICAgICAgLy8gdGhpcy51cGRhdGVTY2VuZSgpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIGNhbWVyYSBieSB0eXBlIG5hbWUsIGZhY3Rvcnktc3R5bGVcbiAgICBzdGF0aWMgY3JlYXRlKG5hbWUsIHNjZW5lLCBjb25maWcpIHtcbiAgICAgICAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnaXNvbWV0cmljJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IElzb21ldHJpY0NhbWVyYShuYW1lLCBzY2VuZSwgY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ2ZsYXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxhdENhbWVyYShuYW1lLCBzY2VuZSwgY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ3BlcnNwZWN0aXZlJzpcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShuYW1lLCBzY2VuZSwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBtZXRob2QgY2FsbGVkIG9uY2UgcGVyIGZyYW1lXG4gICAgdXBkYXRlKCkge1xuICAgICAgICAvLyB0aGlzLnVwZGF0ZVNjZW5lKCk7XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIG9uY2UgcGVyIGZyYW1lIHBlciBwcm9ncmFtIChlLmcuIGZvciBtYWluIHJlbmRlciBwYXNzLCB0aGVuIGZvciBlYWNoIGFkZGl0aW9uYWwgcGFzcyBmb3IgZmVhdHVyZSBzZWxlY3Rpb24sIGV0Yy4pXG4gICAgc2V0dXBQcm9ncmFtKHByb2dyYW0pIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAgU3luYyBjYW1lcmEgcG9zaXRpb24gYW5kL29yIHpvb20gdG8gc2NlbmVcbiAgICAgICAgcG9zaXRpb246IFtsYXQsIGxuZ10gb3IgW2xhdCwgbG5nLCB6b29tXVxuICAgICAgICB6b29tOiB6b29tXG4gICAgKi9cbiAgICB1cGRhdGVTY2VuZSAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uIHx8IHRoaXMuem9vbSkge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmlldyA9IHsgbG5nOiB0aGlzLnBvc2l0aW9uWzBdLCBsYXQ6IHRoaXMucG9zaXRpb25bMV0sIHpvb206IHRoaXMucG9zaXRpb25bMl0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnpvb20pIHtcbiAgICAgICAgICAgICAgICB2aWV3Lnpvb20gPSB0aGlzLnpvb207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjZW5lLnNldFZpZXcodmlldyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuLyoqXG4gICAgUGVyc3BlY3RpdmUgbWF0cml4IHByb2plY3Rpb25cblxuICAgIFRoaXMgaXMgYSBzcGVjaWFsaXplZCBwZXJzcGVjdGl2ZSBjYW1lcmEgdGhhdCwgZ2l2ZW4gYSBkZXNpcmVkIGNhbWVyYSBmb2NhbCBsZW5ndGggKHdoaWNoIGNhbiBhbHNvIHZhcnkgYnkgem9vbSBsZXZlbCksXG4gICAgY29uc3RyYWlucyB0aGUgY2FtZXJhIGhlaWdodCBhYm92ZSB0aGUgZ3JvdW5kIHBsYW5lIHN1Y2ggdGhhdCB0aGUgZGlzcGxheWVkIGdyb3VuZCBhcmVhIG9mIHRoZSBtYXAgbWF0Y2hlcyB0aGF0IG9mXG4gICAgYSB0cmFkaXRpb25hbCB3ZWIgbWVyY2F0b3IgbWFwLiBUaGlzIG1lYW5zIHlvdSBjYW4gc2V0IHRoZSBjYW1lcmEgbG9jYXRpb24gYnkgW2xhdCwgbG5nLCB6b29tXSBhcyB5b3Ugd291bGQgYSB0eXBpY2FsXG4gICAgd2ViIG1lcmNhdG9yIG1hcCwgdGhlbiBhZGp1c3QgdGhlIGZvY2FsIGxlbmd0aCBhcyBuZWVkZWQuXG5cbiAgICBWYW5pc2hpbmcgcG9pbnQgY2FuIGFsc28gYmUgYWRqdXN0ZWQgdG8gYWNoaWV2ZSBkaWZmZXJlbnQgXCJ2aWV3aW5nIGFuZ2xlc1wiLCBlLmcuIGluc3RlYWQgb2YgbG9va2luZyBzdHJhaWdodCBkb3duIGludG9cbiAgICB0aGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydCwgdGhlIGNhbWVyYSBhcHBlYXJzIHRvIGJlIHRpbHRlZCBhdCBhbiBhbmdsZS4gRm9yIGV4YW1wbGU6XG5cbiAgICBbMCwgMF0gPSBsb29raW5nIHRvd2FyZHMgY2VudGVyIG9mIHZpZXdwb3J0XG4gICAgWy0yNTAsIC0yNTBdID0gbG9va2luZyAyNTAgcGl4ZWxzIGZyb20gdGhlIHZpZXdwb3J0IGNlbnRlciB0byB0aGUgbG93ZXItbGVmdCBjb3JuZXJcbiAgICBbNDAwLCAwXSA9IGxvb2tpbmcgNDAwIHBpeGVscyB0byB0aGUgcmlnaHQgb2YgdGhlIHZpZXdwb3J0IGNlbnRlclxuKi9cbmNsYXNzIFBlcnNwZWN0aXZlQ2FtZXJhIGV4dGVuZHMgQ2FtZXJhIHtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHNjZW5lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIobmFtZSwgc2NlbmUsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAncGVyc3BlY3RpdmUnO1xuXG4gICAgICAgIC8vIGEgc2luZ2xlIHNjYWxhciwgb3IgcGFpcnMgb2Ygc3RvcHMgbWFwcGluZyB6b29tIGxldmVscywgZS5nLiBbem9vbSwgZm9jYWwgbGVuZ3RoXVxuICAgICAgICB0aGlzLmZvY2FsX2xlbmd0aCA9IG9wdGlvbnMuZm9jYWxfbGVuZ3RoO1xuICAgICAgICB0aGlzLmZvdiA9IG9wdGlvbnMuZm92O1xuICAgICAgICBpZiAoIXRoaXMuZm9jYWxfbGVuZ3RoICYmICF0aGlzLmZvdikge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBmb2NhbCBsZW5ndGggcmFuZ2VzIGJ5IHpvb21cbiAgICAgICAgICAgIHRoaXMuZm9jYWxfbGVuZ3RoID0gW1sxNiwgMl0sIFsxNywgMi41XSwgWzE4LCAzXSwgWzE5LCA0XSwgWzIwLCA2XV07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZhbmlzaGluZ19wb2ludCA9IG9wdGlvbnMudmFuaXNoaW5nX3BvaW50IHx8IFswLCAwXTsgLy8gW3gsIHldXG4gICAgICAgIHRoaXMudmFuaXNoaW5nX3BvaW50ID0gdGhpcy52YW5pc2hpbmdfcG9pbnQubWFwKHBhcnNlRmxvYXQpOyAvLyB3ZSBpbXBsaWNpdGx5IG9ubHkgc3VwcG9ydCBweCB1bml0cyBoZXJlXG4gICAgICAgIHRoaXMudmFuaXNoaW5nX3BvaW50X3NrZXcgPSBbXTtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uX21ldGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMudmlld01hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcblxuICAgICAgICAvLyAnY2FtZXJhJyBpcyB0aGUgbmFtZSBvZiB0aGUgc2hhZGVyIGJsb2NrLCBlLmcuIGRldGVybWluZXMgd2hlcmUgaW4gdGhlIHNoYWRlciB0aGlzIGNvZGUgaXMgaW5qZWN0ZWRcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5yZXBsYWNlQmxvY2soJ2NhbWVyYScsIGBcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0NCB1X3Byb2plY3Rpb247XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzMgdV9leWU7XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzIgdV92YW5pc2hpbmdfcG9pbnQ7XG5cbiAgICAgICAgICAgIHZvaWQgY2FtZXJhUHJvamVjdGlvbiAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdV9wcm9qZWN0aW9uICogcG9zaXRpb247XG4gICAgICAgICAgICB9YFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIENvbnN0cmFpbnMgdGhlIGNhbWVyYSBzbyB0aGF0IHRoZSB2aWV3YWJsZSBhcmVhIG1hdGNoZXMgZ2l2ZW4gdGhlIHZpZXdwb3J0IGhlaWdodFxuICAgIC8vIChpbiB3b3JsZCBzcGFjZSwgZS5nLiBtZXRlcnMpLCBnaXZlbiBlaXRoZXIgYSBjYW1lcmEgZm9jYWwgbGVuZ3RoIG9yIGZpZWxkLW9mLXZpZXdcbiAgICAvLyAoZm9jYWwgbGVuZ3RoIGlzIHVzZWQgaWYgYm90aCBhcmUgcGFzc2VkKS5cbiAgICBjb25zdHJhaW5DYW1lcmEoeyB2aWV3X2hlaWdodCwgaGVpZ2h0LCBmb2NhbF9sZW5ndGgsIGZvdiB9KSB7XG4gICAgICAgIC8vIFNvbHZlIGZvciBjYW1lcmEgaGVpZ2h0XG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGZvY2FsIGxlbmd0aCwgY2FsY3VsYXRlIEZPVlxuICAgICAgICAgICAgaWYgKGZvY2FsX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvdiA9IE1hdGguYXRhbigxIC8gZm9jYWxfbGVuZ3RoKSAqIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBoYXZlIEZPViwgY2FsY3VsYXRlIGZvY2FsIGxlbmd0aFxuICAgICAgICAgICAgZWxzZSBpZiAoZm92KSB7XG4gICAgICAgICAgICAgICAgZm92ID0gZm92ICogTWF0aC5QSSAvIDE4MDsgLy8gY29udmVydCBGT1YgZGVncmVlcyB0byByYWRpYW5zXG4gICAgICAgICAgICAgICAgZm9jYWxfbGVuZ3RoID0gMSAvIE1hdGgudGFuKGZvdiAvIDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXN0YW5jZSB0aGF0IGNhbWVyYSBzaG91bGQgYmUgZnJvbSBncm91bmQgc3VjaCB0aGF0IGl0IGZpdHMgdGhlIGZpZWxkIG9mIHZpZXcgZXhwZWN0ZWRcbiAgICAgICAgICAgIC8vIGZvciBhIGNvbnZlbnRpb25hbCB3ZWIgbWVyY2F0b3IgbWFwIGF0IHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgYW5kIGNhbWVyYSBmb2NhbCBsZW5ndGhcbiAgICAgICAgICAgIGhlaWdodCA9IHZpZXdfaGVpZ2h0IC8gMiAqIGZvY2FsX2xlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb2x2ZSBmb3IgY2FtZXJhIGZvY2FsIGxlbmd0aCAvIGZpZWxkLW9mLXZpZXdcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb2NhbF9sZW5ndGggPSAyICogaGVpZ2h0IC8gdmlld19oZWlnaHQ7XG4gICAgICAgICAgICBmb3YgPSBNYXRoLmF0YW4oMSAvIGZvY2FsX2xlbmd0aCkgKiAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmlld19oZWlnaHQsIGhlaWdodCwgZm9jYWxfbGVuZ3RoLCBmb3YgfTtcbiAgICB9XG5cbiAgICB1cGRhdGVNYXRyaWNlcygpIHtcbiAgICAgICAgLy8gVE9ETzogb25seSByZS1jYWxjdWxhdGUgdGhlc2UgdmFycyB3aGVuIG5lY2Vzc2FyeVxuXG4gICAgICAgIC8vIEhlaWdodCBvZiB0aGUgdmlld3BvcnQgaW4gbWV0ZXJzIGF0IGN1cnJlbnQgem9vbVxuICAgICAgICB2YXIgdmlld3BvcnRfaGVpZ2h0ID0gdGhpcy5zY2VuZS5jc3Nfc2l6ZS5oZWlnaHQgKiBHZW8ubWV0ZXJzUGVyUGl4ZWwodGhpcy5zY2VuZS56b29tKTtcblxuICAgICAgICAvLyBDb21wdXRlIGNhbWVyYSBwcm9wZXJ0aWVzIHRvIGZpdCBkZXNpcmVkIHZpZXdcbiAgICAgICAgdmFyIHsgaGVpZ2h0LCBmb3YgfSA9IHRoaXMuY29uc3RyYWluQ2FtZXJhKHtcbiAgICAgICAgICAgIHZpZXdfaGVpZ2h0OiB2aWV3cG9ydF9oZWlnaHQsXG4gICAgICAgICAgICBmb2NhbF9sZW5ndGg6IFV0aWxzLmludGVycG9sYXRlKHRoaXMuc2NlbmUuem9vbSwgdGhpcy5mb2NhbF9sZW5ndGgpLFxuICAgICAgICAgICAgZm92OiBVdGlscy5pbnRlcnBvbGF0ZSh0aGlzLnNjZW5lLnpvb20sIHRoaXMuZm92KVxuICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVmlldyBtYXRyaXhcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gW3RoaXMuc2NlbmUuY2VudGVyX21ldGVycy54LCB0aGlzLnNjZW5lLmNlbnRlcl9tZXRlcnMueSwgaGVpZ2h0XTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbl9tZXRlcnMgPSBwb3NpdGlvbjtcblxuICAgICAgICAvLyBtYXQ0Lmxvb2tBdCh0aGlzLnZpZXdNYXRyaXgsXG4gICAgICAgIC8vICAgICB2ZWMzLmZyb21WYWx1ZXMoLi4ucG9zaXRpb24pLFxuICAgICAgICAvLyAgICAgdmVjMy5mcm9tVmFsdWVzKHBvc2l0aW9uWzBdLCBwb3NpdGlvblsxXSwgaGVpZ2h0IC0gMSksXG4gICAgICAgIC8vICAgICB2ZWMzLmZyb21WYWx1ZXMoMCwgMSwgMCkpO1xuICAgICAgICAvLyBFeGNsdWRlIGNhbWVyYSBoZWlnaHQgZnJvbSB2aWV3IG1hdHJpeFxuICAgICAgICBtYXQ0Lmxvb2tBdCh0aGlzLnZpZXdNYXRyaXgsXG4gICAgICAgICAgICB2ZWMzLmZyb21WYWx1ZXMocG9zaXRpb25bMF0sIHBvc2l0aW9uWzFdLCAwKSxcbiAgICAgICAgICAgIHZlYzMuZnJvbVZhbHVlcyhwb3NpdGlvblswXSwgcG9zaXRpb25bMV0sIC0xKSxcbiAgICAgICAgICAgIHZlYzMuZnJvbVZhbHVlcygwLCAxLCAwKSk7XG5cbiAgICAgICAgLy8gUHJvamVjdGlvbiBtYXRyaXhcbiAgICAgICAgbWF0NC5wZXJzcGVjdGl2ZSh0aGlzLnByb2plY3Rpb25NYXRyaXgsIGZvdiwgdGhpcy5zY2VuZS52aWV3X2FzcGVjdCwgMSwgaGVpZ2h0ICogMik7XG5cbiAgICAgICAgLy8gQ29udmVydCB2YW5pc2hpbmcgcG9pbnQgZnJvbSBwaXhlbHMgdG8gdmlld3BvcnQgc3BhY2VcbiAgICAgICAgdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tld1swXSA9IHRoaXMudmFuaXNoaW5nX3BvaW50WzBdIC8gdGhpcy5zY2VuZS5jc3Nfc2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tld1sxXSA9IHRoaXMudmFuaXNoaW5nX3BvaW50WzFdIC8gdGhpcy5zY2VuZS5jc3Nfc2l6ZS5oZWlnaHQ7XG5cbiAgICAgICAgLy8gQWRqdXN0IHByb2plY3Rpb24gbWF0cml4IHRvIGluY2x1ZGUgdmFuaXNoaW5nIHBvaW50IHNrZXdcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4WzhdID0gLXRoaXMudmFuaXNoaW5nX3BvaW50X3NrZXdbMF07IC8vIHogY29sdW1uIG9mIHggcm93LCBlLmcuIGFtb3VudCB6IHNrZXdzIHhcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4WzldID0gLXRoaXMudmFuaXNoaW5nX3BvaW50X3NrZXdbMV07IC8vIHogY29sdW1uIG9mIHkgcm93LCBlLmcuIGFtb3VudCB6IHNrZXdzIHlcblxuICAgICAgICAvLyBUcmFuc2xhdGUgZ2VvbWV0cnkgaW50byB0aGUgZGlzdGFuY2Ugc28gdGhhdCBjYW1lcmEgaXMgYXBwcm9wcmlhdGUgaGVpZ2h0IGFib3ZlIGdyb3VuZFxuICAgICAgICAvLyBBZGRpdGlvbmFsbHksIGFkanVzdCB4eSB0byBjb21wZW5zYXRlIGZvciBhbnkgdmFuaXNoaW5nIHBvaW50IHNrZXcsIGUuZy4gbW92ZSBnZW9tZXRyeSBzbyB0aGF0IHRoZSBkaXNwbGF5ZWQgZ1xuICAgICAgICAvLyBwbGFuZSBvZiB0aGUgbWFwIG1hdGNoZXMgdGhhdCBleHBlY3RlZCBieSBhIHRyYWRpdGlvbmFsIHdlYiBtZXJjYXRvciBtYXAgYXQgdGhpcyBbbGF0LCBsbmcsIHpvb21dLlxuICAgICAgICBtYXQ0LnRyYW5zbGF0ZSh0aGlzLnByb2plY3Rpb25NYXRyaXgsIHRoaXMucHJvamVjdGlvbk1hdHJpeCxcbiAgICAgICAgICAgIHZlYzMuZnJvbVZhbHVlcyhcbiAgICAgICAgICAgICAgICB2aWV3cG9ydF9oZWlnaHQvMiAqIHRoaXMuc2NlbmUudmlld19hc3BlY3QgKiAtdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tld1swXSxcbiAgICAgICAgICAgICAgICB2aWV3cG9ydF9oZWlnaHQvMiAqIC10aGlzLnZhbmlzaGluZ19wb2ludF9za2V3WzFdLFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBJbmNsdWRlIGNhbWVyYSBoZWlnaHQgaW4gcHJvamVjdGlvbiBtYXRyaXhcbiAgICAgICAgbWF0NC50cmFuc2xhdGUodGhpcy5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnByb2plY3Rpb25NYXRyaXgsIHZlYzMuZnJvbVZhbHVlcygwLCAwLCAtaGVpZ2h0KSk7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBzdXBlci51cGRhdGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaWNlcygpO1xuICAgIH1cblxuICAgIHNldHVwUHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnTWF0cml4NGZ2JywgJ3VfcHJvamVjdGlvbicsIGZhbHNlLCB0aGlzLnByb2plY3Rpb25NYXRyaXgpO1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzNmJywgJ3VfZXllJywgMCwgMCwgdGhpcy5wb3NpdGlvbl9tZXRlcnNbMl0pO1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzJmdicsICd1X3ZhbmlzaGluZ19wb2ludCcsIHRoaXMudmFuaXNoaW5nX3BvaW50X3NrZXcpO1xuICAgIH1cblxufVxuXG4vLyBJc29tZXRyaWMtc3R5bGUgcHJvamVjdGlvblxuLy8gTm90ZTogdGhpcyBpcyBhY3R1YWxseSBhbiBcImF4b25vbWV0cmljXCIgcHJvamVjdGlvbiwgYnV0IEknbSB1c2luZyB0aGUgY29sbG9xdWlhbCB0ZXJtIGlzb21ldHJpYyBiZWNhdXNlIGl0IGlzIG1vcmUgcmVjb2duaXphYmxlLlxuLy8gQW4gaXNvbWV0cmljIHByb2plY3Rpb24gaXMgYSBzcGVjaWZpYyBzdWJzZXQgb2YgYXhvbm9tZXRyaWMgcHJvamVjdGlvbnMuXG4vLyAnYXhpcycgZGV0ZXJtaW5lcyB0aGUgeHkgc2tldyBhcHBsaWVkIHRvIGEgdmVydGV4IGJhc2VkIG9uIGl0cyB6IGNvb3JkaW5hdGUsIGUuZy4gWzAsIDFdIGF4aXMgY2F1c2VzIGJ1aWxkaW5ncyB0byBiZSBkcmF3blxuLy8gc3RyYWlnaHQgdXB3YXJkcyBvbiBzY3JlZW4gYXQgdGhlaXIgdHJ1ZSBoZWlnaHQsIFswLCAuNV0gd291bGQgZHJhdyB0aGVtIHVwIGF0IGhhbGYtaGVpZ2h0LCBbMSwgMF0gd291bGQgYmUgc2lkZXdheXMsIGV0Yy5cbmNsYXNzIElzb21ldHJpY0NhbWVyYSBleHRlbmRzIENhbWVyYSB7XG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzY2VuZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIHNjZW5lLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2lzb21ldHJpYyc7XG4gICAgICAgIHRoaXMuYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCB7IHg6IDAsIHk6IDEgfTtcbiAgICAgICAgaWYgKHRoaXMuYXhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMuYXhpcyA9IHsgeDogdGhpcy5heGlzWzBdLCB5OiB0aGlzLmF4aXNbMV0gfTsgLy8gYWxsb3cgYXhpcyB0byBhbHNvIGJlIHBhc3NlZCBhcyAyLWVsZW0gYXJyYXlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucG9zaXRpb25fbWV0ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy52aWV3cG9ydF9oZWlnaHQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMudmlld01hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcblxuICAgICAgICAvLyAnY2FtZXJhJyBpcyB0aGUgbmFtZSBvZiB0aGUgc2hhZGVyIGJsb2NrLCBlLmcuIGRldGVybWluZXMgd2hlcmUgaW4gdGhlIHNoYWRlciB0aGlzIGNvZGUgaXMgaW5qZWN0ZWRcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5yZXBsYWNlQmxvY2soJ2NhbWVyYScsIGBcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0NCB1X3Byb2plY3Rpb247XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzMgdV9leWU7XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzIgdV92YW5pc2hpbmdfcG9pbnQ7XG5cbiAgICAgICAgICAgIHZvaWQgY2FtZXJhUHJvamVjdGlvbiAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdV9wcm9qZWN0aW9uICogcG9zaXRpb247XG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb24ueHkgKz0gcG9zaXRpb24ueiAqIHVfaXNvbWV0cmljX2F4aXM7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXZlcnNlIHogZm9yIGRlcHRoIGJ1ZmZlciBzbyB1cCBpcyBuZWdhdGl2ZSxcbiAgICAgICAgICAgICAgICAvLyBhbmQgc2NhbGUgZG93biB2YWx1ZXMgc28gb2JqZWN0cyBoaWdoZXIgdGhhbiBvbmUgc2NyZWVuIGhlaWdodCB3aWxsIG5vdCBnZXQgY2xpcHBlZFxuICAgICAgICAgICAgICAgIC8vIHB1bGwgZm9yd2FyZCBzbGlnaHRseSB0byBhdm9pZCBnb2luZyBwYXN0IGZhciBjbGlwcGluZyBwbGFuZVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnogPSAtcG9zaXRpb24ueiAvIDEwMC4gKyAxLiAtIDAuMDAxO1xuICAgICAgICAgICAgfWBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZSgpO1xuXG4gICAgICAgIHRoaXMudmlld3BvcnRfaGVpZ2h0ID0gdGhpcy5zY2VuZS5jc3Nfc2l6ZS5oZWlnaHQgKiBHZW8ubWV0ZXJzUGVyUGl4ZWwodGhpcy5zY2VuZS56b29tKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gW3RoaXMuc2NlbmUuY2VudGVyX21ldGVycy54LCB0aGlzLnNjZW5lLmNlbnRlcl9tZXRlcnMueSwgdGhpcy52aWV3cG9ydF9oZWlnaHRdO1xuICAgICAgICB0aGlzLnBvc2l0aW9uX21ldGVycyA9IHBvc2l0aW9uO1xuXG4gICAgICAgIC8vIFZpZXdcbiAgICAgICAgbWF0NC5pZGVudGl0eSh0aGlzLnZpZXdNYXRyaXgpO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZSh0aGlzLnZpZXdNYXRyaXgsIHRoaXMudmlld01hdHJpeCwgdmVjMy5mcm9tVmFsdWVzKC1wb3NpdGlvblswXSwgLXBvc2l0aW9uWzFdLCAwKSk7XG5cbiAgICAgICAgLy8gUHJvamVjdGlvblxuICAgICAgICBtYXQ0LmlkZW50aXR5KHRoaXMucHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgICAgICAgLy8gYXBwbHkgaXNvbWV0cmljIHNrZXdcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4WzhdID0gdGhpcy5heGlzLnggLyB0aGlzLnNjZW5lLnZpZXdfYXNwZWN0OyAgICAvLyB6IGNvbHVtbiBvZiB4IHJvdywgZS5nLiBhbW91bnQgeiBza2V3cyB4XG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeFs5XSA9IHRoaXMuYXhpcy55OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8geiBjb2x1bW4gb2YgeCByb3csIGUuZy4gYW1vdW50IHogc2tld3MgeVxuXG4gICAgICAgIC8vIGNvbnZlcnQgbWV0ZXJzIHRvIHZpZXdwb3J0XG4gICAgICAgIG1hdDQuc2NhbGUodGhpcy5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnByb2plY3Rpb25NYXRyaXgsXG4gICAgICAgICAgICB2ZWMzLmZyb21WYWx1ZXMoXG4gICAgICAgICAgICAgICAgMiAvIHRoaXMuc2NlbmUudmlld3BvcnRfbWV0ZXJzLngsXG4gICAgICAgICAgICAgICAgMiAvIHRoaXMuc2NlbmUudmlld3BvcnRfbWV0ZXJzLnksXG4gICAgICAgICAgICAgICAgMiAvIHRoaXMuc2NlbmUudmlld3BvcnRfbWV0ZXJzLnlcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzZXR1cFByb2dyYW0ocHJvZ3JhbSkge1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJ01hdHJpeDRmdicsICd1X3Byb2plY3Rpb24nLCBmYWxzZSwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KTtcblxuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzNmJywgJ3VfZXllJywgMCwgMCwgdGhpcy52aWV3cG9ydF9oZWlnaHQpO1xuICAgICAgICAvLyBwcm9ncmFtLnVuaWZvcm0oJzNmJywgJ3VfZXllJywgdGhpcy52aWV3cG9ydF9oZWlnaHQgKiB0aGlzLmF4aXMueCwgdGhpcy52aWV3cG9ydF9oZWlnaHQgKiB0aGlzLmF4aXMueSwgdGhpcy52aWV3cG9ydF9oZWlnaHQpO1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzJmJywgJ3VfdmFuaXNoaW5nX3BvaW50JywgMCwgMCk7XG4gICAgfVxuXG59XG5cbi8vIEZsYXQgcHJvamVjdGlvbiAoZS5nLiBqdXN0IHRvcC1kb3duLCBubyBwZXJzcGVjdGl2ZSkgLSBhIGRlZ2VuZXJhdGUgaXNvbWV0cmljIGNhbWVyYVxuY2xhc3MgRmxhdENhbWVyYSBleHRlbmRzIElzb21ldHJpY0NhbWVyYSB7XG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzY2VuZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIHNjZW5lLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2ZsYXQnO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgLy8gQXhpcyBpcyBmaXhlZCB0byAoMCwgMCkgZm9yIGZsYXQgY2FtZXJhXG4gICAgICAgIHRoaXMuYXhpcy54ID0gMDtcbiAgICAgICAgdGhpcy5heGlzLnkgPSAwO1xuXG4gICAgICAgIHN1cGVyLnVwZGF0ZSgpO1xuICAgIH1cblxufVxuIiwiLy8gTWlzY2VsbGFuZW91cyBnZW8gZnVuY3Rpb25zXG5cbnZhciBHZW87XG5leHBvcnQgZGVmYXVsdCBHZW8gPSB7fTtcblxuLy8gUHJvamVjdGlvbiBjb25zdGFudHNcbkdlby50aWxlX3NpemUgPSAyNTY7XG5HZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycyA9IDIwMDM3NTA4LjM0Mjc4OTI0NDtcbkdlby5jaXJjdW1mZXJlbmNlX21ldGVycyA9IEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzICogMjtcbkdlby5taW5fem9vbV9tZXRlcnNfcGVyX3BpeGVsID0gR2VvLmNpcmN1bWZlcmVuY2VfbWV0ZXJzIC8gR2VvLnRpbGVfc2l6ZTsgLy8gbWluIHpvb20gZHJhd3Mgd29ybGQgYXMgMiB0aWxlcyB3aWRlXG5HZW8ubWV0ZXJzX3Blcl9waXhlbCA9IFtdO1xuR2VvLm1ldGVyc19wZXJfdGlsZSA9IFtdO1xuR2VvLm1heF96b29tID0gMTg7XG5mb3IgKHZhciB6PTA7IHogPD0gR2VvLm1heF96b29tOyB6KyspIHtcbiAgICBHZW8ubWV0ZXJzX3Blcl9waXhlbFt6XSA9IEdlby5taW5fem9vbV9tZXRlcnNfcGVyX3BpeGVsIC8gTWF0aC5wb3coMiwgeik7XG4gICAgR2VvLm1ldGVyc19wZXJfdGlsZVt6XSA9IEdlby5jaXJjdW1mZXJlbmNlX21ldGVycyAvIE1hdGgucG93KDIsIHopO1xufVxuXG5HZW8ubWV0ZXJzUGVyUGl4ZWwgPSBmdW5jdGlvbiAoem9vbSkge1xuICAgIHJldHVybiBHZW8ubWluX3pvb21fbWV0ZXJzX3Blcl9waXhlbCAvIE1hdGgucG93KDIsIHpvb20pO1xufTtcblxuLy8gQ29udmVyc2lvbiBmdW5jdGlvbnMgYmFzZWQgb24gYW4gZGVmaW5lZCB0aWxlIHNjYWxlXG5HZW8udW5pdHNfcGVyX21ldGVyID0gW107XG5HZW8udGlsZV9zY2FsZSA9IDQwOTY7IC8vIGNvb3JkaW5hdGVzIGFyZSBsb2NhbGx5IHNjYWxlZCB0byB0aGUgcmFuZ2UgWzAsIHRpbGVfc2NhbGVdXG5HZW8udW5pdHNfcGVyX3BpeGVsID0gR2VvLnRpbGVfc2NhbGUgLyBHZW8udGlsZV9zaXplO1xuXG5mb3IgKGxldCB6PTA7IHogPD0gR2VvLm1heF96b29tOyB6KyspIHtcbiAgICBHZW8udW5pdHNfcGVyX21ldGVyW3pdID0gR2VvLnRpbGVfc2NhbGUgLyAoR2VvLnRpbGVfc2l6ZSAqIEdlby5tZXRlcnNfcGVyX3BpeGVsW3pdKTtcbn1cblxuLy8gQ29udmVydCB0aWxlIGxvY2F0aW9uIHRvIG1lcmNhdG9yIG1ldGVycyAtIG11bHRpcGx5IGJ5IHBpeGVscyBwZXIgdGlsZSwgdGhlbiBieSBtZXRlcnMgcGVyIHBpeGVsLCBhZGp1c3QgZm9yIG1hcCBvcmlnaW5cbkdlby5tZXRlcnNGb3JUaWxlID0gZnVuY3Rpb24gKHRpbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB0aWxlLnggKiBHZW8uY2lyY3VtZmVyZW5jZV9tZXRlcnMgLyBNYXRoLnBvdygyLCB0aWxlLnopIC0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMsXG4gICAgICAgIHk6IC0odGlsZS55ICogR2VvLmNpcmN1bWZlcmVuY2VfbWV0ZXJzIC8gTWF0aC5wb3coMiwgdGlsZS56KSAtIEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzKVxuICAgIH07XG59O1xuXG4vKipcbiAgIEdpdmVuIGEgcG9pbnQgaW4gbWVyY2F0b3IgbWV0ZXJzIGFuZCBhIHpvb20gbGV2ZWwsIHJldHVybiB0aGUgdGlsZSBYL1kvWiB0aGF0IHRoZSBwb2ludCBsaWVzIGluXG4qL1xuR2VvLnRpbGVGb3JNZXRlcnMgPSBmdW5jdGlvbiAoW3gsIHldLCB6b29tKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogTWF0aC5mbG9vcigoeCArIEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzKSAvIChHZW8uY2lyY3VtZmVyZW5jZV9tZXRlcnMgLyBNYXRoLnBvdygyLCB6b29tKSkpLFxuICAgICAgICB5OiBNYXRoLmZsb29yKCgteSArIEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzKSAvIChHZW8uY2lyY3VtZmVyZW5jZV9tZXRlcnMgLyBNYXRoLnBvdygyLCB6b29tKSkpLFxuICAgICAgICB6OiB6b29tXG4gICAgfTtcbn07XG5cbi8vIFdyYXAgYSB0aWxlIHRvIHBvc2l0aXZlICNzIGZvciB6b29tXG4vLyBPcHRpb25hbGx5IHNwZWNpZnkgdGhlIGF4ZXMgdG8gd3JhcFxuR2VvLndyYXBUaWxlID0gZnVuY3Rpb24oeyB4LCB5LCB6IH0sIG1hc2sgPSB7IHg6IHRydWUsIHk6IGZhbHNlIH0pIHtcbiAgICB2YXIgbSA9ICgxIDw8IHopIC0gMTtcbiAgICBpZiAobWFzay54KSB7XG4gICAgICAgIHggPSB4ICYgbTtcbiAgICB9XG4gICAgaWYgKG1hc2sueSkge1xuICAgICAgICB5ID0geSAmIG07XG4gICAgfVxuICAgIHJldHVybiB7IHgsIHksIHogfTtcbn07XG5cbi8qKlxuICAgQ29udmVydCBtZXJjYXRvciBtZXRlcnMgdG8gbGF0LWxuZ1xuKi9cbkdlby5tZXRlcnNUb0xhdExuZyA9IGZ1bmN0aW9uIChbeCwgeV0pIHtcblxuICAgIHggLz0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnM7XG4gICAgeSAvPSBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycztcblxuICAgIHkgPSAoMiAqIE1hdGguYXRhbihNYXRoLmV4cCh5ICogTWF0aC5QSSkpIC0gKE1hdGguUEkgLyAyKSkgLyBNYXRoLlBJO1xuXG4gICAgeCAqPSAxODA7XG4gICAgeSAqPSAxODA7XG5cbiAgICByZXR1cm4gW3gsIHldO1xufTtcblxuLyoqXG4gIENvbnZlcnQgbGF0LWxuZyB0byBtZXJjYXRvciBtZXRlcnNcbiovXG5HZW8ubGF0TG5nVG9NZXRlcnMgPSBmdW5jdGlvbihbeCwgeV0pIHtcblxuICAgIC8vIExhdGl0dWRlXG4gICAgeSA9IE1hdGgubG9nKE1hdGgudGFuKHkqTWF0aC5QSS8zNjAgKyBNYXRoLlBJLzQpKSAvIE1hdGguUEk7XG4gICAgeSAqPSBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycztcblxuICAgIC8vIExvbmdpdHVkZVxuICAgIHggKj0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMgLyAxODA7XG5cbiAgICByZXR1cm4gW3gsIHldO1xufTtcblxuR2VvLndyYXBMbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPiAxODAgfHwgeCA8IC0xODApIHtcbiAgICAgICAgeCA9ICgoeCArIDE4MCkgJSAzNjAgKyAzNjApICUgMzYwIC0gMTgwO1xuICAgIH1cbiAgICByZXR1cm4geDtcbn07XG5cbi8vIFJ1biBhbiBpbi1wbGFjZSB0cmFuc2Zvcm0gZnVuY3Rpb24gb24gZWFjaCBjb29vcmRpbmF0ZSBpbiBhIEdlb0pTT04gZ2VvbWV0cnlcbkdlby50cmFuc2Zvcm1HZW9tZXRyeSA9IGZ1bmN0aW9uIChnZW9tZXRyeSwgdHJhbnNmb3JtKSB7XG4gICAgaWYgKGdlb21ldHJ5ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBza2lwIGlmIG1pc3NpbmcgZ2VvbWV0cnkgKHZhbGlkIEdlb0pTT04pXG4gICAgfVxuXG4gICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2ludCcpIHtcbiAgICAgICAgdHJhbnNmb3JtKGdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnIHx8IGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xuICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlcy5mb3JFYWNoKHRyYW5zZm9ybSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyB8fCBnZW9tZXRyeS50eXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJykge1xuICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlcy5mb3JFYWNoKGNvb3JkaW5hdGVzID0+IGNvb3JkaW5hdGVzLmZvckVhY2godHJhbnNmb3JtKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzLmZvckVhY2gocG9seWdvbiA9PiB7XG4gICAgICAgICAgICBwb2x5Z29uLmZvckVhY2goY29vcmRpbmF0ZXMgPT4gY29vcmRpbmF0ZXMuZm9yRWFjaCh0cmFuc2Zvcm0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRPRE86IHN1cHBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uXG59O1xuXG5HZW8uYm94SW50ZXJzZWN0ID0gZnVuY3Rpb24gKGIxLCBiMikge1xuICAgIHJldHVybiAhKFxuICAgICAgICBiMi5zdy54ID4gYjEubmUueCB8fFxuICAgICAgICBiMi5uZS54IDwgYjEuc3cueCB8fFxuICAgICAgICBiMi5zdy55ID4gYjEubmUueSB8fFxuICAgICAgICBiMi5uZS55IDwgYjEuc3cueVxuICAgICk7XG59O1xuXG4vLyBGaW5kcyB0aGUgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgYSBwb2x5Z29uXG5HZW8uZmluZEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICB2YXIgbWluX3ggPSBJbmZpbml0eSxcbiAgICAgICAgbWF4X3ggPSAtSW5maW5pdHksXG4gICAgICAgIG1pbl95ID0gSW5maW5pdHksXG4gICAgICAgIG1heF95ID0gLUluZmluaXR5O1xuXG4gICAgLy8gT25seSBuZWVkIHRvIGV4YW1pbmUgb3V0ZXIgcmluZyAocG9seWdvblswXSlcbiAgICB2YXIgbnVtX2Nvb3JkcyA9IHBvbHlnb25bMF0ubGVuZ3RoO1xuICAgIGZvciAodmFyIGM9MDsgYyA8IG51bV9jb29yZHM7IGMrKykge1xuICAgICAgICB2YXIgY29vcmQgPSBwb2x5Z29uWzBdW2NdO1xuXG4gICAgICAgIGlmIChjb29yZFswXSA8IG1pbl94KSB7XG4gICAgICAgICAgICBtaW5feCA9IGNvb3JkWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb29yZFsxXSA8IG1pbl95KSB7XG4gICAgICAgICAgICBtaW5feSA9IGNvb3JkWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb29yZFswXSA+IG1heF94KSB7XG4gICAgICAgICAgICBtYXhfeCA9IGNvb3JkWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb29yZFsxXSA+IG1heF95KSB7XG4gICAgICAgICAgICBtYXhfeSA9IGNvb3JkWzFdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFttaW5feCwgbWluX3ksIG1heF94LCBtYXhfeV07XG59O1xuXG4vLyBDb252ZXJ0IGdlb21ldHJ5IHR5cGUgdG8gb25lIG9mOiAncG9pbnQnLCAnbGluZScsICdwb2x5Z29uJ1xuR2VvLmdlb21ldHJ5VHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gJ1BvbHlnb24nIHx8IHR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIHJldHVybiAncG9seWdvbic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdMaW5lU3RyaW5nJyB8fCB0eXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJykge1xuICAgICAgICByZXR1cm4gJ2xpbmUnO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ1BvaW50JyB8fCB0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcbiAgICAgICAgcmV0dXJuICdwb2ludCc7XG4gICAgfVxufTtcblxuR2VvLmNlbnRyb2lkID0gZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICBsZXQgbiA9IHBvbHlnb24ubGVuZ3RoO1xuICAgIGxldCBjZW50cm9pZCA9IFswLCAwXTtcblxuICAgIGZvciAobGV0IHA9MDsgcCA8IHBvbHlnb24ubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgY2VudHJvaWRbMF0gKz0gcG9seWdvbltwXVswXTtcbiAgICAgICAgY2VudHJvaWRbMV0gKz0gcG9seWdvbltwXVsxXTtcbiAgICB9XG5cbiAgICBjZW50cm9pZFswXSAvPSBuO1xuICAgIGNlbnRyb2lkWzFdIC89IG47XG5cbiAgICByZXR1cm4gY2VudHJvaWQ7XG59O1xuXG5HZW8ubXVsdGlDZW50cm9pZCA9IGZ1bmN0aW9uIChwb2x5Z29ucykge1xuICAgIGxldCBuID0gcG9seWdvbnMubGVuZ3RoO1xuICAgIGxldCBjZW50cm9pZCA9IFswLCAwXTtcblxuICAgIGZvciAobGV0IHA9MDsgcCA8IHBvbHlnb25zLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgIGxldCBwb2x5Z29uID0gcG9seWdvbnNbcF1bMF07XG4gICAgICAgIGxldCBjID0gR2VvLmNlbnRyb2lkKHBvbHlnb24pO1xuICAgICAgICBjZW50cm9pZFswXSArPSBjWzBdO1xuICAgICAgICBjZW50cm9pZFsxXSArPSBjWzFdO1xuICAgIH1cblxuICAgIGNlbnRyb2lkWzBdIC89IG47XG4gICAgY2VudHJvaWRbMV0gLz0gbjtcblxuICAgIHJldHVybiBjZW50cm9pZDtcbn07XG5cbkdlby5zaWduZWRQb2x5Z29uQXJlYVN1bSA9IGZ1bmN0aW9uIChwb2x5Z29uKSB7XG4gICAgbGV0IGFyZWEgPSAwO1xuICAgIGxldCBuID0gcG9seWdvbi5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgICAgbGV0IHAwID0gcG9seWdvbltpXTtcbiAgICAgICAgbGV0IHAxID0gcG9seWdvbltpKzFdO1xuXG4gICAgICAgIGFyZWEgKz0gcDBbMF0gKiBwMVsxXSAtIHAxWzBdICogcDBbMV07XG4gICAgfVxuXG4gICAgYXJlYSArPSBwb2x5Z29uW24gLSAxXVswXSAqIHBvbHlnb25bMF1bMV0gLSBwb2x5Z29uWzBdWzBdICogcG9seWdvbltuIC0gMV1bMV07XG4gICAgcmV0dXJuIGFyZWE7XG59O1xuXG4vLyBUT0RPOiBzdWJ0cmFjdCBpbm5lciByaW5nIGFyZWFzXG5HZW8ucG9seWdvbkFyZWEgPSBmdW5jdGlvbiAocG9seWdvbikge1xuICAgIHJldHVybiBNYXRoLmFicyhHZW8uc2lnbmVkUG9seWdvbkFyZWFTdW0ocG9seWdvbikpIC8gMjtcbn07XG5cbkdlby5tdWx0aVBvbHlnb25BcmVhID0gZnVuY3Rpb24gKHBvbHlnb25zKSB7XG4gICAgbGV0IGFyZWEgPSAwO1xuXG4gICAgZm9yIChsZXQgcD0wOyBwIDwgcG9seWdvbnMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgbGV0IHBvbHlnb24gPSBwb2x5Z29uc1twXVswXTtcbiAgICAgICAgYXJlYSArPSBHZW8ucG9seWdvbkFyZWEocG9seWdvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZWE7XG59O1xuXG5HZW8ucmluZ1dpbmRpbmcgPSBmdW5jdGlvbiAocmluZykge1xuICAgIHJldHVybiBHZW8uc2lnbmVkUG9seWdvbkFyZWFTdW0ocmluZykgPiAwID8gJ0NXJyA6ICdDQ1cnO1xufTtcblxuLy8gRW5mb3JjZSB3aW5kaW5nIG9yZGVyIG9uIG91dGVyL2lubmVyIHJpbmdzXG4vLyB3aW5kaW5nOiAnQ1cnIG9yICdDQ1cnXG5HZW8uZW5mb3JjZVdpbmRpbmcgPSBmdW5jdGlvbiAoZ2VvbSwgd2luZGluZykge1xuICAgIGxldCBwb2x5cztcbiAgICBpZiAoZ2VvbS50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgcG9seXMgPSBbZ2VvbS5jb29yZGluYXRlc107XG4gICAgfVxuICAgIGVsc2UgaWYgKGdlb20udHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgcG9seXMgPSBnZW9tLmNvb3JkaW5hdGVzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdlb207XG4gICAgfVxuXG4gICAgZm9yIChsZXQgcD0wOyBwIDwgcG9seXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgbGV0IHBvbHkgPSBwb2x5c1twXTtcblxuICAgICAgICAvLyBJZiBmaXJzdCByaW5nIHdpbmRpbmcgZG9lc24ndCBtYXRjaCwgcmV2ZXJzZSBhbGwgcmluZ3NcbiAgICAgICAgLy8gTk9URTogYXNzdW1lcyByaW5nIHdpbmRpbmcgb3JkZXJzIGFscmVhZHkgYWx0ZXJuYXRlIGFzIGV4cGVjdGVkXG4gICAgICAgIGlmIChHZW8ucmluZ1dpbmRpbmcocG9seVswXSkgIT09IHdpbmRpbmcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHJpbmcgb2YgcG9seSkge1xuICAgICAgICAgICAgICAgIHJpbmcucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZW9tO1xufTtcbiIsIi8vIFdlYkdMIGNvbnN0YW50cyAtIG5lZWQgdG8gaW1wb3J0IHRoZXNlIHNlcGFyYXRlbHkgdG8gbWFrZSB0aGVtIGF2YWlsYWJsZSBpbiB0aGUgd2ViIHdvcmtlclxuXG52YXIgZ2w7XG5leHBvcnQgZGVmYXVsdCBnbCA9IHt9O1xuXG4vKiBEYXRhVHlwZSAqL1xuZ2wuQllURSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgxNDAwO1xuZ2wuVU5TSUdORURfQllURSAgICAgICAgICAgICAgICAgID0gMHgxNDAxO1xuZ2wuU0hPUlQgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgxNDAyO1xuZ2wuVU5TSUdORURfU0hPUlQgICAgICAgICAgICAgICAgID0gMHgxNDAzO1xuZ2wuSU5UICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgxNDA0O1xuZ2wuVU5TSUdORURfSU5UICAgICAgICAgICAgICAgICAgID0gMHgxNDA1O1xuZ2wuRkxPQVQgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgxNDA2O1xuIiwiLy8gV2ViR0wgY29udGV4dCB3cmFwcGVyXG5cbnZhciBDb250ZXh0O1xuZXhwb3J0IGRlZmF1bHQgQ29udGV4dCA9IHt9O1xuXG4vLyBTZXR1cCBhIFdlYkdMIGNvbnRleHRcbi8vIElmIG5vIGNhbnZhcyBlbGVtZW50IGlzIHByb3ZpZGVkLCBvbmUgaXMgY3JlYXRlZCBhbmQgYWRkZWQgdG8gdGhlIGRvY3VtZW50IGJvZHlcbkNvbnRleHQuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIGdldENvbnRleHQgKGNhbnZhcywgb3B0aW9ucylcbntcbiAgICB2YXIgZnVsbHNjcmVlbiA9IGZhbHNlO1xuICAgIGlmIChjYW52YXMgPT0gbnVsbCkge1xuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgY2FudmFzLnN0eWxlLnRvcCA9IDA7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IC0xO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICAgIGZ1bGxzY3JlZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG9wdGlvbnMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBvcHRpb25zKTtcbiAgICBpZiAoIWdsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGNyZWF0ZSBXZWJHTCBjb250ZXh0LlwiKTtcbiAgICB9XG5cbiAgICBDb250ZXh0LnJlc2l6ZShnbCwgd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCwgb3B0aW9ucy5kZXZpY2VfcGl4ZWxfcmF0aW8pO1xuICAgIGlmIChmdWxsc2NyZWVuID09PSB0cnVlKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBDb250ZXh0LnJlc2l6ZShnbCwgd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBnbDtcbn07XG5cbkNvbnRleHQucmVzaXplID0gZnVuY3Rpb24gKGdsLCB3aWR0aCwgaGVpZ2h0LCBkZXZpY2VfcGl4ZWxfcmF0aW8pXG57XG4gICAgZGV2aWNlX3BpeGVsX3JhdGlvID0gZGV2aWNlX3BpeGVsX3JhdGlvIHx8IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgZ2wuY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGdsLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIGdsLmNhbnZhcy53aWR0aCA9IE1hdGgucm91bmQoZ2wuY2FudmFzLnN0eWxlLndpZHRoICogZGV2aWNlX3BpeGVsX3JhdGlvKTtcbiAgICBnbC5jYW52YXMuaGVpZ2h0ID0gTWF0aC5yb3VuZChnbC5jYW52YXMuc3R5bGUud2lkdGggKiBkZXZpY2VfcGl4ZWxfcmF0aW8pO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7XG59O1xuIiwiLy8gV2ViR0wgZXh0ZW5zaW9uIHdyYXBwZXJcbi8vIFN0b3JlcyBleHRlbnNpb25zIGJ5IG5hbWUgYW5kIEdMIGNvbnRleHRcblxubGV0IGV4dGVuc2lvbnMgPSBuZXcgTWFwKCk7IC8vIG1hcCBvZiBleHRlbnNpb25zIGJ5IEdMIGNvbnRleHRcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uIChnbCwgbmFtZSkge1xuICAgIGxldCBleHRzID0gZXh0ZW5zaW9ucy5nZXQoZ2wpO1xuICAgIGlmICghZXh0cykge1xuICAgICAgICBleHRlbnNpb25zLnNldChnbCwgbmV3IE1hcCgpKTtcbiAgICAgICAgZXh0cyA9IGV4dGVuc2lvbnMuZ2V0KGdsKTtcbiAgICB9XG5cbiAgICBpZiAoIWV4dHMuZ2V0KG5hbWUpKSB7XG4gICAgICAgIGV4dHMuc2V0KG5hbWUsIGdsLmdldEV4dGVuc2lvbihuYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiBleHRzLmdldChuYW1lKTtcbn1cbiIsInZhciBHTFNMID0ge307XG5leHBvcnQgZGVmYXVsdCBHTFNMO1xuXG4vKipcbiAgICBQYXJzZSB1bmlmb3JtcyBmcm9tIGEgSlMgb2JqZWN0LCBpbmZlcnMgdHlwZXMgYW5kIHJldHVybnMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHRoZVxuICAgIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiB0byBzZXQgdW5pZm9ybSB2YWx1ZXMgb24gYSBHTCBwcm9ncmFtLiBFYWNoIG9iamVjdCBpbiB0aGUgcmV0dXJuZWRcbiAgICBhcnJheSBoYXMgdGhlIGZvcm06XG4gICAgeyB0eXBlLCBtZXRob2QsIG5hbWUsIHZhbHVlIH1cblxuICAgIHR5cGU6IHRoZSBHTCB1bmlmb3JtIHR5cGUsIHN1Y2ggYXMgJ3ZlYzMnLCAnZmxvYXQnLCBldGMuXG4gICAgbWV0aG9kOiB0aGUgR0wgdW5pZm9ybSBzZXR0ZXIgbWV0aG9kIHRvIHVzZSwgc3VjaCBhcyAnMWYnLCAnM2Z2JywgZXRjLlxuICAgIG5hbWU6IHRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZSBvZiB0aGUgR0wgdW5pZm9ybSBsb2NhdGlvbiwgZS5nLiAnYXJyYXlbMF0uZmllbGQnLCBldGMuXG4gICAgdmFsdWU6IHRoZSB2YWx1ZSB0byBiZSBwYXNzZWQgdG8gdGhlIEdMIHVuaWZvcm0gc2V0dGVyIGZvciB0aGF0IHR5cGUsIGUuZy4gWzEsIDIsIDNdIGZvciBhIHZlYzNcblxuICAgIFRleHR1cmVzIGhhdmUgc3BlY2lhbCBiZWhhdmlvcjogdW5pZm9ybXMgd2l0aCBzdHJpbmcgdmFsdWVzIGFyZSB0cmVhdGVkIGFzIHRleHR1cmVzLCBhbmRcbiAgICB0aGUgc3RyaW5nIGlzIHVzZWQgYXMgYSB1bmlxdWUgdGV4dHVyZSAna2V5JyB0byBiZSBpbnRlcnByZXRlZCBieSB0aGUgY2FsbGVyICh3aGljaCBpcyByZXNwb25zaWJsZVxuICAgIGZvciBhY3R1YWxseSBzZXR0aW5nIHRoZSB1bmlmb3JtcykuIEZvciBleGFtcGxlLCB0aGlzIGNvdWxkIGJlIHVzZWQgYXMgYSBrZXkgaW50byBhIGRpY3Rpb25hcnkgb2ZcbiAgICBrbm93biB0ZXh0dXJlIG5hbWVzLCBvciBpdCBjb3VsZCBzaW1wbHkgYmUgdXNlZCBhcyBhIFVSTCB0byBkeW5hbWljYWxseSBsb2FkIHRoZSB0ZXh0dXJlIGZyb20uXG4qL1xuR0xTTC5wYXJzZVVuaWZvcm1zID0gZnVuY3Rpb24gKHVuaWZvcm1zLCBwcmVmaXggPSBudWxsKSB7XG4gICAgdmFyIHBhcnNlZCA9IFtdO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiB1bmlmb3Jtcykge1xuICAgICAgICB2YXIga2V5ID0gbmFtZTsgLy8gc2F2ZSB0aGUgb3JpZ2luYWwgbmFtZVxuICAgICAgICB2YXIgdW5pZm9ybSA9IHVuaWZvcm1zW25hbWVdO1xuICAgICAgICB2YXIgdTtcblxuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgICBuYW1lID0gcHJlZml4ICsgJy4nICsgbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbmdsZSBmbG9hdFxuICAgICAgICBpZiAodHlwZW9mIHVuaWZvcm0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICcxZicsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5pZm9ybSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdW5pZm9ybXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5OiB2ZWN0b3IsIGFycmF5IG9mIGZsb2F0cywgYXJyYXkgb2YgdGV4dHVyZXMsIG9yIGFycmF5IG9mIHN0cnVjdHNcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh1bmlmb3JtKSkge1xuICAgICAgICAgICAgLy8gTnVtZXJpYyB2YWx1ZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdW5pZm9ybVswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAvLyBmbG9hdCB2ZWN0b3JzICh2ZWMyLCB2ZWMzLCB2ZWM0KVxuICAgICAgICAgICAgICAgIGlmICh1bmlmb3JtLmxlbmd0aCA+PSAyICYmIHVuaWZvcm0ubGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3ZlYycgKyB1bmlmb3JtLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogdW5pZm9ybS5sZW5ndGggKyAnZnYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmlmb3JtLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZsb2F0IGFycmF5XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodW5pZm9ybS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmbG9hdFtdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJzFmdicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lICsgJ1swXScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5pZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhc3N1bWUgbWF0cml4IGZvciAodHlwZW9mID09IEZsb2F0MzJBcnJheSAmJiBsZW5ndGggPT0gMTYpP1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXJyYXkgb2YgdGV4dHVyZXNcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB1bmlmb3JtWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGZvciAodT0wOyB1IDwgdW5pZm9ybS5sZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2FtcGxlcjJEJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJzFpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgKyAnWycgKyB1ICsgJ10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuaWZvcm1bdV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtczogdW5pZm9ybVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcnJheSBvZiBhcnJheXMgLSBidXQgb25seSBhcnJheXMgb2YgdmVjdG9ycyBhcmUgYWxsb3dlZCBpbiB0aGlzIGNhc2VcbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodW5pZm9ybVswXSkgJiYgdHlwZW9mIHVuaWZvcm1bMF1bMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gZmxvYXQgdmVjdG9ycyAodmVjMiwgdmVjMywgdmVjNClcbiAgICAgICAgICAgICAgICBpZiAodW5pZm9ybVswXS5sZW5ndGggPj0gMiAmJiB1bmlmb3JtWzBdLmxlbmd0aCA8PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgZm9yICh1PTA7IHUgPCB1bmlmb3JtLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3ZlYycgKyB1bmlmb3JtWzBdLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHVuaWZvcm1bdV0ubGVuZ3RoICsgJ2Z2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lICsgJ1snICsgdSArICddJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5pZm9ybVt1XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXM6IHVuaWZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVsc2UgZXJyb3I/XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcnJheSBvZiBzdHJ1Y3R1cmVzXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdW5pZm9ybVswXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHU9MDsgdSA8IHVuaWZvcm0ubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGVhY2ggc3RydWN0IGluIHRoZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucHVzaCguLi5HTFNMLnBhcnNlVW5pZm9ybXModW5pZm9ybVt1XSwgbmFtZSArICdbJyArIHUgKyAnXScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQm9vbGVhblxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdW5pZm9ybSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJzFpJyxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmlmb3JtLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB1bmlmb3Jtc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGV4dHVyZVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdW5pZm9ybSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc2FtcGxlcjJEJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICcxaScsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5pZm9ybSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdW5pZm9ybXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cnVjdHVyZVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdW5pZm9ybSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIFNldCBlYWNoIGZpZWxkIGluIHRoZSBzdHJ1Y3RcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoKC4uLkdMU0wucGFyc2VVbmlmb3Jtcyh1bmlmb3JtLCBuYW1lKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IG90aGVyIG5vbi1mbG9hdCB0eXBlcz8gKGludCwgZXRjLilcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkO1xufTtcblxuLyoqXG4gICAgR2VuZXJhdGUgYSBHTFNMIHZhcmlhYmxlIGRlZmluaXRpb24gZnJvbSBhIEpTIG9iamVjdFxuKi9cbkdMU0wuZGVmaW5lVmFyaWFibGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHByZWZpeCA9IG51bGwpIHtcbiAgICB2YXIgdHlwZSwgYXJyYXk7XG4gICAgdmFyIHN0cnVjdHMgPSAnJztcbiAgICBwcmVmaXggPSBwcmVmaXggPyBwcmVmaXggKyAnXycgKyBuYW1lIDogbmFtZTtcblxuICAgIC8vIFNpbmdsZSBmbG9hdFxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHR5cGUgPSAnZmxvYXQnO1xuICAgIH1cbiAgICAvLyBNdWx0aXBsZSBmbG9hdHMgLSB2ZWN0b3Igb3IgYXJyYXlcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAvLyBOdW1lcmljIHZhbHVlc1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gZmxvYXQgdmVjdG9ycyAodmVjMiwgdmVjMywgdmVjNClcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gMiAmJiB2YWx1ZS5sZW5ndGggPD0gNCkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAndmVjJyArIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZsb2F0IGFycmF5XG4gICAgICAgICAgICBlbHNlIHsgLy9pZiAodmFsdWUubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnZmxvYXQnO1xuICAgICAgICAgICAgICAgIGFycmF5ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogYXNzdW1lIG1hdHJpeCBmb3IgKHR5cGVvZiA9PSBGbG9hdDMyQXJyYXkgJiYgbGVuZ3RoID09IDE2KT9cbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheSBvZiB0ZXh0dXJlc1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWVbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0eXBlID0gJ3NhbXBsZXIyRCc7XG4gICAgICAgICAgICBhcnJheSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheSBvZiBhcnJheXMgLSBidXQgb25seSBhcnJheXMgb2YgdmVjdG9ycyBhcmUgYWxsb3dlZCBpbiB0aGlzIGNhc2VcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkgJiYgdHlwZW9mIHZhbHVlWzBdWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gZmxvYXQgdmVjdG9ycyAodmVjMiwgdmVjMywgdmVjNClcbiAgICAgICAgICAgIGlmICh2YWx1ZVswXS5sZW5ndGggPj0gMiAmJiB2YWx1ZVswXS5sZW5ndGggPD0gNCkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAndmVjJyArIHZhbHVlWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2UgZXJyb3I/XG4gICAgICAgICAgICBhcnJheSA9IHZhbHVlWzBdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheSBvZiBzdHJ1Y3R1cmVzXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZVswXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnX3R5cGVfJyArIHByZWZpeDsgLy8gY3VzdG9tIHN0cnVjdCBuYW1lXG4gICAgICAgICAgICBhcnJheSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIHN0cnVjdHMgKz0gR0xTTC5kZWZpbmVTdHJ1Y3QodHlwZSwgdmFsdWVbMF0sIHByZWZpeCkgKyAnXFxuJzsgLy8gYnVpbGQgJiBhZGQgdG8gbGlzdCBvZiBkZXBlbmRlbnQgc3RydWN0c1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJvb2xlYW5cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICB0eXBlID0gJ2Jvb2wnO1xuICAgIH1cbiAgICAvLyBUZXh0dXJlXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0eXBlID0gJ3NhbXBsZXIyRCc7XG4gICAgfVxuICAgIC8vIFN0cnVjdHVyZVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdHlwZSA9ICdfdHlwZV8nICsgcHJlZml4OyAvLyBjdXN0b20gc3RydWN0IG5hbWVcbiAgICAgICAgc3RydWN0cyArPSBHTFNMLmRlZmluZVN0cnVjdCh0eXBlLCB2YWx1ZSwgcHJlZml4KSArICdcXG4nOyAvLyBidWlsZCAmIGFkZCB0byBsaXN0IG9mIGRlcGVuZGVudCBzdHJ1Y3RzXG4gICAgfVxuXG4gICAgLy8gQ29uc3RydWN0IHZhcmlhYmxlIGRlZmluaXRpb25cbiAgICB2YXIgdmFyaWFibGUgPSAnJztcbiAgICB2YXJpYWJsZSArPSBgJHt0eXBlfSAke25hbWV9YDtcbiAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgdmFyaWFibGUgKz0gYFske2FycmF5fV1gO1xuICAgIH1cbiAgICB2YXJpYWJsZSArPSAnO1xcbic7XG5cbiAgICAvLyBSZXR1cm4gdGhlIHZhcmlhYmxlIGRlZmluaXRpb24gaXRzZWxmLCBhbmQgYW55IGRlcGVuZGVudCBzdHJ1Y3QgZGVmaW5pdGlvbnNcbiAgICByZXR1cm4geyB2YXJpYWJsZSwgc3RydWN0cyB9O1xufTtcblxuLyoqXG4gICAgR2VuZXJhdGUgYSBHTFNMIHN0cnVjdHVyZSBkZWZpbml0aW9uIGZyb20gYSBKUyBvYmplY3RcbiovXG5HTFNMLmRlZmluZVN0cnVjdCA9IGZ1bmN0aW9uICh0eXBlLCB2YWx1ZSwgcHJlZml4ID0gbnVsbCkge1xuICAgIHZhciBzdHJ1Y3QgPSBgc3RydWN0ICR7dHlwZX0ge1xcbmA7XG4gICAgdmFyIGRlcGVuZGVudHMgPSAnJztcbiAgICBmb3IgKHZhciBmaWVsZCBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgc3VidmFyID0gR0xTTC5kZWZpbmVWYXJpYWJsZShmaWVsZCwgdmFsdWVbZmllbGRdLCBwcmVmaXgpO1xuICAgICAgICBzdHJ1Y3QgKz0gJyAgICAnICsgc3VidmFyLnZhcmlhYmxlO1xuICAgICAgICBkZXBlbmRlbnRzICs9IHN1YnZhci5zdHJ1Y3RzO1xuICAgIH1cbiAgICBzdHJ1Y3QgKz0gJ307XFxuJztcbiAgICBzdHJ1Y3QgPSBkZXBlbmRlbnRzICsgc3RydWN0O1xuICAgIHJldHVybiBzdHJ1Y3Q7XG59O1xuXG4vKipcbiAgICBHZW5lcmF0ZSBhIEdMU0wgdW5pZm9ybSBkZWZpbml0aW9uIGZyb20gYSBKUyBvYmplY3RcbiovXG5HTFNMLmRlZmluZVVuaWZvcm0gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgZGVmID0gR0xTTC5kZWZpbmVWYXJpYWJsZShuYW1lLCB2YWx1ZSk7XG4gICAgZGVmID0gZGVmLnN0cnVjdHMgKyAndW5pZm9ybSAnICsgZGVmLnZhcmlhYmxlO1xuICAgIHJldHVybiBkZWY7XG59O1xuXG4vKipcbiAgICBDaGVjayBmb3IgYSB1bmlmb3JtIGRlZmluaXRpb24gb2YgJ25hbWUnIGluIHRoZSBwcm92aWRlZCBHTFNMIHNvdXJjZVxuICAgIFNpbXBsZSByZWdleCBjaGVjayBmb3IgJ3VuaWZvcm0nIGtleXdvcmQgYW5kIHZhciBuYW1lLCBkb2VzIG5vdCBhdHRlbXB0IHRvIHBhcnNlL2V4dHJhY3QgR0xTTFxuICAgIE5PVEU6IGFzc3VtZXMgY29tbWVudHMgaGF2ZSBiZWVuIHN0cmlwcGVkIGZyb20gc291cmNlXG4qL1xuR0xTTC5pc1VuaWZvcm1EZWZpbmVkID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSkge1xuICAgIC8vIE1hdGNoLCBpbiBvcmRlcjpcbiAgICAvLyAtIHRoZSBrZXl3b3JkICd1bmlmb3JtJ1xuICAgIC8vIC0gYXQgbGVhc3Qgb25lIGNoYXJhY3RlciB0aGF0IGlzIGFueXRoaW5nIGV4Y2VwdCBhIHNlbWljb2xvbiwgO1xuICAgIC8vIC0gb3B0aW9uYWxseSwgYW55dGhpbmcgZW5jbG9zZWQgaW4gY3VybHkgYnJhY2VzLCB7IC4uLiB9IChhbiBpbmxpbmUgc3RydWN0dXJlIGRlZmluaXRpb24gY2FuIGdvIGhlcmUpXG4gICAgLy8gLSBvcHRpb25hbGx5LCBhbnkgIyBvZiBjaGFyYWN0ZXJzIHRoYXQgaXMgbm90IGEgc2VtaWNvbG9uLCA7XG4gICAgLy8gLSB0aGUgbmFtZSBvZiB0aGUgdW5pZm9ybVxuXG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cCgndW5pZm9ybVteO10rKD86e1tcXFxcc1xcXFxTXSp9KT9bXjtdKlxcXFxiJyArIG5hbWUgKyAnXFxcXGInLCAnZycpO1xuICAgIGlmIChzb3VyY2UubWF0Y2gocmUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAgICBDaGVjayB0aGF0IGEgc3ltYm9sIGlzIHJlZmVyZW5jZWQgaW4gdGhlIEdMU0wgc291cmNlXG4gICAgTk9URTogYXNzdW1lcyBjb21tZW50cyBoYXZlIGJlZW4gc3RyaXBwZWQgZnJvbSBzb3VyY2VcbiovXG5HTFNMLmlzU3ltYm9sUmVmZXJlbmNlZCA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UpIHtcbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyBuYW1lICsgJ1xcXFxiJywgJ2cnKTtcbiAgICBpZiAoc291cmNlLnNlYXJjaChyZSkgPj0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gICAgRXhwYW5kIGEgc2luZ2xlIHZhbHVlIG9yIDItZWxlbWVudCBhcnJheSBpbnRvIGEgMy1lbGVtZW50IGFycmF5LCB3aXRoIHRoZSBsYXN0ICggeiApXG4gICAgY29vcmRpbmF0ZSBkZWZhdWx0aW5nIHRvIDEgKHdpdGggb3B0aW9uIHRvIHNwZWNpZnkpLiBBbHNvIHJ1bnMgcGFyc2VGbG9hdCB0byB0cnkgdG8gbWFpbnRhaW5cbiAgICBkYXRhIGludGVncml0eS4gUmV0dXJucyBudWxsIGlmIGlucHV0IGNvdWxkbid0IGJlIHBhcnNlZC5cbiovXG5HTFNMLmV4cGFuZFZlYzMgPSBmdW5jdGlvbiAodiwgeiA9IDEpIHtcbiAgICBsZXQgeDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSAmJiB2Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICB4ID0gWy4uLnYsIHpdLm1hcChwYXJzZUZsb2F0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHggPSBbdiwgdiwgdl0ubWFwKHBhcnNlRmxvYXQpO1xuICAgIH1cblxuICAgIGlmICh4ICYmIHguZXZlcnkobiA9PiB0eXBlb2YgbiA9PT0gJ251bWJlcicgJiYgIWlzTmFOKG4pKSkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG59O1xuXG4vKipcbiAgICBFeHBhbmQgYSBzaW5nbGUgdmFsdWUgb3IgMy1lbGVtZW50IGFycmF5IGludG8gYSA0LWVsZW1lbnQgYXJyYXksIHdpdGggdGhlIGxhc3QgKGUuZy4gdyBvciBhKVxuICAgIGNvb3JkaW5hdGUgZGVmYXVsdGluZyB0byAxICh3aXRoIG9wdGlvbiB0byBzcGVjaWZ5KS4gQWxzbyBydW5zIHBhcnNlRmxvYXQgdG8gdHJ5IHRvIG1haW50YWluXG4gICAgZGF0YSBpbnRlZ3JpdHkuIFJldHVybnMgbnVsbCBpZiBpbnB1dCBjb3VsZG4ndCBiZSBwYXJzZWQuXG4qL1xuR0xTTC5leHBhbmRWZWM0ID0gZnVuY3Rpb24gKHYsIHcgPSAxKSB7XG4gICAgbGV0IHg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikgJiYgdi5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgeCA9IFsuLi52LCB3XS5tYXAocGFyc2VGbG9hdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB4ID0gW3YsIHYsIHYsIHddLm1hcChwYXJzZUZsb2F0KTtcbiAgICB9XG5cbiAgICBpZiAoeCAmJiB4LmV2ZXJ5KG4gPT4gdHlwZW9mIG4gPT09ICdudW1iZXInICYmICFpc05hTihuKSkpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxufTtcblxuXG4iLCJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlclN0YXRlIHtcblx0Y29uc3RydWN0b3IgKHZhbHVlLCBzZXR1cCkge1xuICAgICAgICBzZXR1cCh2YWx1ZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zZXR1cCA9IHNldHVwO1xuICAgIH1cblxuICAgIHNldCAodmFsdWUpIHtcbiAgICBcdC8vIGlmIHRoZSBzdGF0ZXMgYXJlIGRpZmZlcmVudCwgY2FsbCB0aGUgR0wgY29udGV4dCBmb3IgYSBzdGF0ZSBjaGFuZ2VcbiAgICBcdGlmIChKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlKSAhPT0gSlNPTi5zdHJpbmdpZnkodmFsdWUpKSB7XG4gICAgXHRcdHRoaXMuc2V0dXAodmFsdWUpO1xuICAgIFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgXHR9XG4gICAgfVxuXG4gICAgc3RhdGljIGluaXRpYWxpemUgKGdsKSB7XG4gICAgXHQvLyBDdWxsaW5nXG4gICAgXHRSZW5kZXJTdGF0ZS5jdWxsaW5nID0gbmV3IFJlbmRlclN0YXRlKFxuICAgIFx0XHR7IGN1bGw6IHRydWUsIGZhY2U6IGdsLkJBQ0sgfSxcbiAgICBcdFx0KHZhbHVlKSA9PiB7XG4gICAgXHRcdFx0aWYgKHZhbHVlLmN1bGwpIHtcbiAgICBcdFx0XHRcdGdsLmVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgICAgICAgICAgXHRcdGdsLmN1bGxGYWNlKHZhbHVlLmZhY2UpO1xuICAgIFx0XHRcdH0gZWxzZSB7XG4gICAgXHRcdFx0XHRnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSk7XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9XG4gICAgXHQpO1xuXG4gICAgXHQvLyBCbGVuZGluZyBtb2RlXG4gICAgXHRSZW5kZXJTdGF0ZS5ibGVuZGluZyA9IG5ldyBSZW5kZXJTdGF0ZShcbiAgICAgICAgICAgIHsgYmxlbmQ6IGZhbHNlLCBzcmM6IGdsLlNSQ19BTFBIQSwgZHN0OiBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBzcmNfYWxwaGE6IGdsLk9ORSwgZHN0X2FscGhhOiBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBIH0sXG4gICAgICAgICAgICAodmFsdWUpID0+IHtcbiAgICBcdFx0XHRpZiAodmFsdWUuYmxlbmQpIHtcbiAgICAgICAgICAgIFx0XHRnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5zcmNfYWxwaGEgJiYgdmFsdWUuZHN0X2FscGhhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZSh2YWx1ZS5zcmMsIHZhbHVlLmRzdCwgdmFsdWUuc3JjX2FscGhhLCB2YWx1ZS5kc3RfYWxwaGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKHZhbHVlLnNyYywgdmFsdWUuZHN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFx0XHRcdH0gZWxzZSB7XG4gICAgXHRcdFx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICBcdFx0XHR9XG4gICAgXHRcdH1cbiAgICBcdCk7XG5cbiAgICBcdC8vIERlcHRoIHdyaXRlXG4gICAgXHRSZW5kZXJTdGF0ZS5kZXB0aF93cml0ZSA9IG5ldyBSZW5kZXJTdGF0ZShcbiAgICBcdFx0eyBkZXB0aF93cml0ZTogdHJ1ZSB9LFxuICAgIFx0XHQodmFsdWUpID0+IHtcbiAgICAgICAgXHRcdGdsLmRlcHRoTWFzayh2YWx1ZS5kZXB0aF93cml0ZSk7XG4gICAgXHRcdH1cbiAgICBcdCk7XG5cbiAgICBcdC8vIERlcHRoIHRlc3RcbiAgICBcdFJlbmRlclN0YXRlLmRlcHRoX3Rlc3QgPSBuZXcgUmVuZGVyU3RhdGUoXG4gICAgXHRcdHsgZGVwdGhfdGVzdDogdHJ1ZSwgZGVwdGhfZnVuYzogZ2wuTEVRVUFMIH0sXG4gICAgXHRcdCh2YWx1ZSkgPT4ge1xuICAgIFx0XHRcdGlmICh2YWx1ZS5kZXB0aF90ZXN0KSB7XG4gICAgICAgICAgICBcdFx0Z2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgICBcdFx0XHRnbC5kZXB0aEZ1bmModmFsdWUuZGVwdGhfZnVuYyk7XG4gICAgXHRcdFx0fSBlbHNlIHtcbiAgICAgICAgICAgIFx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuICAgIFx0KTtcbiAgICB9XG59XG4iLCIvKiBnbG9iYWwgU2hhZGVyUHJvZ3JhbSAqL1xuLy8gR0wgcHJvZ3JhbSB3cmFwcGVyIHRvIGNhY2hlIHVuaWZvcm0gbG9jYXRpb25zL3ZhbHVlcywgZG8gY29tcGlsZS10aW1lIHByZS1wcm9jZXNzaW5nXG4vLyAoaW5qZWN0aW5nICNkZWZpbmVzIGFuZCAjcHJhZ21hIGJsb2NrcyBpbnRvIHNoYWRlcnMpLCBldGMuXG5cbmltcG9ydCBHTFNMIGZyb20gJy4vZ2xzbCc7XG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuL3RleHR1cmUnO1xuaW1wb3J0IGdldEV4dGVuc2lvbiBmcm9tICcuL2V4dGVuc2lvbnMnO1xuXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBzdHJpcCBmcm9tICdzdHJpcC1jb21tZW50cyc7XG5pbXBvcnQgeyBkZWZhdWx0IGFzIHBhcnNlU2hhZGVyRXJyb3JzIH0gZnJvbSAnZ2wtc2hhZGVyLWVycm9ycyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlclByb2dyYW0ge1xuXG4gICAgY29uc3RydWN0b3IoZ2wsIHZlcnRleF9zb3VyY2UsIGZyYWdtZW50X3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21waWxpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG5cbiAgICAgICAgLy8ga2V5L3ZhbHVlcyBpbnNlcnRlZCBhcyAjZGVmaW5lcyBpbnRvIHNoYWRlcnMgYXQgY29tcGlsZS10aW1lXG4gICAgICAgIHRoaXMuZGVmaW5lcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuZGVmaW5lc3x8e30pO1xuXG4gICAgICAgIC8vIGtleS92YWx1ZXMgZm9yIGJsb2NrcyB0aGF0IGNhbiBiZSBpbmplY3RlZCBpbnRvIHNoYWRlcnMgYXQgY29tcGlsZS10aW1lXG4gICAgICAgIHRoaXMuYmxvY2tzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5ibG9ja3N8fHt9KTtcbiAgICAgICAgdGhpcy5ibG9ja19zY29wZXMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmJsb2NrX3Njb3Blc3x8e30pO1xuXG4gICAgICAgIC8vIGxpc3Qgb2YgZXh0ZW5zaW9ucyB0byBhY3RpdmF0ZVxuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBvcHRpb25zLmV4dGVuc2lvbnMgfHwgW107XG5cbiAgICAgICAgLy8gSlMtb2JqZWN0IHVuaWZvcm1zIHRoYXQgYXJlIGV4cGVjdGVkIGJ5IHRoaXMgcHJvZ3JhbVxuICAgICAgICAvLyBJZiB0aGV5IGFyZSBub3QgZm91bmQgaW4gdGhlIGV4aXN0aW5nIHNoYWRlciBzb3VyY2UsIHRoZWlyIHR5cGVzIHdpbGwgYmUgaW5mZXJyZWQgYW5kIGRlZmluaXRpb25zXG4gICAgICAgIC8vIGZvciBlYWNoIHdpbGwgYmUgaW5qZWN0ZWQuXG4gICAgICAgIHRoaXMuZGVwZW5kZW50X3VuaWZvcm1zID0gb3B0aW9ucy51bmlmb3JtcztcblxuICAgICAgICB0aGlzLnVuaWZvcm1zID0ge307IC8vIHByb2dyYW0gbG9jYXRpb25zIG9mIHVuaWZvcm1zLCBsYXppbHkgYWRkZWQgYXMgZWFjaCB1bmlmb3JtIGlzIHNldFxuICAgICAgICB0aGlzLmF0dHJpYnMgPSB7fTsgLy8gcHJvZ3JhbSBsb2NhdGlvbnMgb2YgdmVydGV4IGF0dHJpYnV0ZXMsIGxhemlseSBhZGRlZCBhcyBlYWNoIGF0dHJpYnV0ZSBpcyBhY2Nlc3NlZFxuXG4gICAgICAgIHRoaXMudmVydGV4X3NvdXJjZSA9IHZlcnRleF9zb3VyY2U7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRfc291cmNlID0gZnJhZ21lbnRfc291cmNlO1xuXG4gICAgICAgIHRoaXMuaWQgPSBTaGFkZXJQcm9ncmFtLmlkKys7XG4gICAgICAgIFNoYWRlclByb2dyYW0ucHJvZ3JhbXNbdGhpcy5pZF0gPSB0aGlzO1xuICAgICAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7IC8vIGNhbiBwcm92aWRlIGEgcHJvZ3JhbSBuYW1lICh1c2VmdWwgZm9yIGRlYnVnZ2luZylcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0obnVsbCk7XG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLnVuaWZvcm1zID0ge307XG4gICAgICAgIHRoaXMuYXR0cmlicyA9IHt9O1xuICAgICAgICBkZWxldGUgU2hhZGVyUHJvZ3JhbS5wcm9ncmFtc1t0aGlzLmlkXTtcbiAgICAgICAgdGhpcy5jb21waWxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFVzZSBwcm9ncmFtIHdyYXBwZXIgd2l0aCBzaW1wbGUgc3RhdGUgY2FjaGVcbiAgICB1c2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb21waWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFNoYWRlclByb2dyYW0uY3VycmVudCAhPT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5jdXJyZW50ID0gdGhpcztcbiAgICB9XG5cbiAgICBjb21waWxlKCkge1xuICAgICAgICBpZiAodGhpcy5jb21waWxpbmcpIHtcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcihgU2hhZGVyUHJvZ3JhbS5jb21waWxlKCk6IHNraXBwaW5nIGZvciAke3RoaXMuaWR9ICgke3RoaXMubmFtZX0pIGJlY2F1c2UgYWxyZWFkeSBjb21waWxpbmdgKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21waWxpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbXBpbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuXG4gICAgICAgIC8vIENvcHkgc291cmNlcyBmcm9tIHByZS1tb2RpZmllZCB0ZW1wbGF0ZVxuICAgICAgICB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2UgPSB0aGlzLnZlcnRleF9zb3VyY2U7XG4gICAgICAgIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlID0gdGhpcy5mcmFnbWVudF9zb3VyY2U7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGV4dGVuc2lvbiBhdmFpbGFiaWxpdHlcbiAgICAgICAgbGV0IGV4dGVuc2lvbnMgPSB0aGlzLmNoZWNrRXh0ZW5zaW9ucygpO1xuXG4gICAgICAgIC8vIE1ha2UgbGlzdCBvZiBkZWZpbmVzIHRvIGJlIGluamVjdGVkIGxhdGVyXG4gICAgICAgIHZhciBkZWZpbmVzID0gdGhpcy5idWlsZERlZmluZUxpc3QoKTtcblxuICAgICAgICAvLyBJbmplY3QgdXNlci1kZWZpbmVkIGJsb2NrcyAoYXJiaXRyYXJ5IGNvZGUgcG9pbnRzIG1hdGNoaW5nIG5hbWVkICNwcmFnbWFzKVxuICAgICAgICAvLyBSZXBsYWNlIGFjY29yZGluZyB0byB0aGlzIHBhdHRlcm46XG4gICAgICAgIC8vICNwcmFnbWEgdGFuZ3JhbTogW2tleV1cbiAgICAgICAgLy8gZS5nLiAjcHJhZ21hIHRhbmdyYW06IGdsb2JhbFxuXG4gICAgICAgIC8vIEdhdGhlciBhbGwgYmxvY2sgY29kZSBzbmlwcGV0c1xuICAgICAgICB2YXIgYmxvY2tzID0gdGhpcy5idWlsZFNoYWRlckJsb2NrTGlzdCgpO1xuICAgICAgICB2YXIgcmVnZXhwO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBibG9ja3MpIHtcbiAgICAgICAgICAgIHZhciBibG9jayA9IGJsb2Nrc1trZXldO1xuICAgICAgICAgICAgaWYgKCFibG9jayB8fCAoQXJyYXkuaXNBcnJheShibG9jaykgJiYgYmxvY2subGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXJzdCBmaW5kIGNvZGUgcmVwbGFjZSBwb2ludHMgaW4gc2hhZGVyc1xuICAgICAgICAgICAgcmVnZXhwID0gbmV3IFJlZ0V4cCgnXlxcXFxzKiNwcmFnbWFcXFxccyt0YW5ncmFtOlxcXFxzKycgKyBrZXkgKyAnXFxcXHMqJCcsICdtJyk7XG4gICAgICAgICAgICB2YXIgaW5qZWN0X3ZlcnRleCA9IHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZS5tYXRjaChyZWdleHApO1xuICAgICAgICAgICAgdmFyIGluamVjdF9mcmFnbWVudCA9IHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlLm1hdGNoKHJlZ2V4cCk7XG5cbiAgICAgICAgICAgIC8vIEF2b2lkIG5ldHdvcmsgcmVxdWVzdCBpZiBub3RoaW5nIHRvIHJlcGxhY2VcbiAgICAgICAgICAgIGlmIChpbmplY3RfdmVydGV4ID09IG51bGwgJiYgaW5qZWN0X2ZyYWdtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29tYmluZSBhbGwgYmxvY2tzIGludG8gb25lIHN0cmluZ1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9ICcnO1xuICAgICAgICAgICAgYmxvY2suZm9yRWFjaCh2YWwgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE1hcmsgc3RhcnQgYW5kIGVuZCBvZiBlYWNoIGJsb2NrIHdpdGggbWV0YWRhdGEgKHdoaWNoIGNhbiBiZSBleHRyYWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAgIC8vIGZpbmFsIHNvdXJjZSBmb3IgZXJyb3IgaGFuZGxpbmcsIGRlYnVnZ2luZywgZXRjLilcbiAgICAgICAgICAgICAgICBsZXQgbWFyayA9IGAke3ZhbC5zY29wZX0sICR7dmFsLmtleX0sICR7dmFsLm51bX1gO1xuICAgICAgICAgICAgICAgIHNvdXJjZSArPSBgXFxuLy8gdGFuZ3JhbS1ibG9jay1zdGFydDogJHttYXJrfVxcbmA7XG4gICAgICAgICAgICAgICAgc291cmNlICs9IHZhbC5zb3VyY2U7XG4gICAgICAgICAgICAgICAgc291cmNlICs9IGBcXG4vLyB0YW5ncmFtLWJsb2NrLWVuZDogJHttYXJrfVxcbmA7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSW5qZWN0XG4gICAgICAgICAgICBpZiAoaW5qZWN0X3ZlcnRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlID0gdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlLnJlcGxhY2UocmVnZXhwLCBzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluamVjdF9mcmFnbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UgPSB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZS5yZXBsYWNlKHJlZ2V4cCwgc291cmNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIGEgI2RlZmluZSBmb3IgdGhpcyBpbmplY3Rpb24gcG9pbnRcbiAgICAgICAgICAgIGRlZmluZXNbJ1RBTkdSQU1fQkxPQ0tfJyArIGtleS5yZXBsYWNlKC9bXFxzLV0rL2csICdfJykudG9VcHBlckNhc2UoKV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xlYW4tdXAgYW55ICNwcmFnbWFzIHRoYXQgd2VyZW4ndCByZXBsYWNlZCAodG8gcHJldmVudCBjb21waWxlciB3YXJuaW5ncylcbiAgICAgICAgcmVnZXhwID0gbmV3IFJlZ0V4cCgnXlxcXFxzKiNwcmFnbWEuKiQnLCAnZ20nKTtcbiAgICAgICAgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlID0gdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlLnJlcGxhY2UocmVnZXhwLCAnJyk7XG4gICAgICAgIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlID0gdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UucmVwbGFjZShyZWdleHAsICcnKTtcblxuICAgICAgICAvLyBEZXRlY3QgdW5pZm9ybSBkZWZpbml0aW9ucywgaW5qZWN0IGFueSBtaXNzaW5nIG9uZXNcbiAgICAgICAgdGhpcy5lbnN1cmVVbmlmb3Jtcyh0aGlzLmRlcGVuZGVudF91bmlmb3Jtcyk7XG5cbiAgICAgICAgLy8gQnVpbGQgJiBpbmplY3QgZXh0ZW5zaW9ucyAmIGRlZmluZXNcbiAgICAgICAgLy8gVGhpcyBpcyBkb25lICphZnRlciogY29kZSBpbmplY3Rpb24gc28gdGhhdCB3ZSBjYW4gYWRkIGRlZmluZXMgZm9yIHdoaWNoIGNvZGUgcG9pbnRzIHdlcmUgaW5qZWN0ZWRcbiAgICAgICAgbGV0IGluZm8gPSAodGhpcy5uYW1lID8gKHRoaXMubmFtZSArICcgLyBpZCAnICsgdGhpcy5pZCkgOiAoJ2lkICcgKyB0aGlzLmlkKSk7XG4gICAgICAgIGxldCBoZWFkZXIgPSBgLy8gUHJvZ3JhbTogJHtpbmZvfVxcbmAgK1xuICAgICAgICAgICAgU2hhZGVyUHJvZ3JhbS5idWlsZEV4dGVuc2lvblN0cmluZyhleHRlbnNpb25zKTtcblxuICAgICAgICBkZWZpbmVzWydUQU5HUkFNX1ZFUlRFWF9TSEFERVInXSA9IHRydWU7XG4gICAgICAgIGRlZmluZXNbJ1RBTkdSQU1fRlJBR01FTlRfU0hBREVSJ10gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlID0gaGVhZGVyICsgU2hhZGVyUHJvZ3JhbS5idWlsZERlZmluZVN0cmluZyhkZWZpbmVzKSArIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZTtcblxuICAgICAgICBkZWZpbmVzWydUQU5HUkFNX1ZFUlRFWF9TSEFERVInXSA9IGZhbHNlO1xuICAgICAgICBkZWZpbmVzWydUQU5HUkFNX0ZSQUdNRU5UX1NIQURFUiddID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UgPSBoZWFkZXIgKyBTaGFkZXJQcm9ncmFtLmJ1aWxkRGVmaW5lU3RyaW5nKGRlZmluZXMpICsgdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2U7XG5cbiAgICAgICAgLy8gQWRkIHByZWNpc2lvbiBxdWFsaWZpZXJcbiAgICAgICAgdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UgPSAnI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNlbmRpZlxcblxcbicgKyB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZTtcblxuICAgICAgICAvLyBDb21waWxlICYgc2V0IHVuaWZvcm1zIHRvIGNhY2hlZCB2YWx1ZXNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IFNoYWRlclByb2dyYW0udXBkYXRlUHJvZ3JhbSh0aGlzLmdsLCB0aGlzLnByb2dyYW0sIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZSwgdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UpO1xuICAgICAgICAgICAgdGhpcy5jb21waWxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvbXBpbGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb21waWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jb21waWxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcblxuICAgICAgICAgICAgLy8gc2hhZGVyIGVycm9yIGluZm9cbiAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSAndmVydGV4JyB8fCBlcnJvci50eXBlID09PSAnZnJhZ21lbnQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkZXJfZXJyb3JzID0gZXJyb3IuZXJyb3JzO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGUgb2YgdGhpcy5zaGFkZXJfZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGUudHlwZSA9IGVycm9yLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGUuYmxvY2sgPSB0aGlzLmJsb2NrKGVycm9yLnR5cGUsIGUubGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyhuZXcgRXJyb3IoYFNoYWRlclByb2dyYW0uY29tcGlsZSgpOiBwcm9ncmFtICR7dGhpcy5pZH0gKCR7dGhpcy5uYW1lfSkgZXJyb3I6YCwgZXJyb3IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXNlKCk7XG4gICAgICAgIHRoaXMucmVmcmVzaFVuaWZvcm1zKCk7XG4gICAgICAgIHRoaXMucmVmcmVzaEF0dHJpYnV0ZXMoKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGxpc3Qgb2YgZGVmaW5lcyAoZ2xvYmFsLCB0aGVuIHByb2dyYW0tc3BlY2lmaWMpXG4gICAgYnVpbGREZWZpbmVMaXN0KCkge1xuICAgICAgICB2YXIgZCwgZGVmaW5lcyA9IHt9O1xuICAgICAgICBmb3IgKGQgaW4gU2hhZGVyUHJvZ3JhbS5kZWZpbmVzKSB7XG4gICAgICAgICAgICBkZWZpbmVzW2RdID0gU2hhZGVyUHJvZ3JhbS5kZWZpbmVzW2RdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoZCBpbiB0aGlzLmRlZmluZXMpIHtcbiAgICAgICAgICAgIGRlZmluZXNbZF0gPSB0aGlzLmRlZmluZXNbZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmluZXM7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBsaXN0IG9mIHNoYWRlciBibG9ja3MgKGdsb2JhbCwgdGhlbiBwcm9ncmFtLXNwZWNpZmljKVxuICAgIGJ1aWxkU2hhZGVyQmxvY2tMaXN0KCkge1xuICAgICAgICBsZXQga2V5LCBibG9ja3MgPSB7fTtcblxuICAgICAgICAvLyBHbG9iYWwgYmxvY2tzXG4gICAgICAgIGZvciAoa2V5IGluIFNoYWRlclByb2dyYW0uYmxvY2tzKSB7XG4gICAgICAgICAgICBibG9ja3Nba2V5XSA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShTaGFkZXJQcm9ncmFtLmJsb2Nrc1trZXldKSkge1xuICAgICAgICAgICAgICAgIGJsb2Nrc1trZXldLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIC4uLlNoYWRlclByb2dyYW0uYmxvY2tzW2tleV0ubWFwKChzb3VyY2UsIG51bSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsga2V5LCBzb3VyY2UsIG51bSwgc2NvcGU6ICdTaGFkZXJQcm9ncmFtJyB9O1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBibG9ja3Nba2V5XSA9IFt7IGtleSwgc291cmNlOiBTaGFkZXJQcm9ncmFtLmJsb2Nrc1trZXldLCBudW06IDAsIHNjb3BlOiAnU2hhZGVyUHJvZ3JhbScgfV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcm9ncmFtLXNwZWNpZmljIGJsb2Nrc1xuICAgICAgICBmb3IgKGtleSBpbiB0aGlzLmJsb2Nrcykge1xuICAgICAgICAgICAgYmxvY2tzW2tleV0gPSBibG9ja3Nba2V5XSB8fCBbXTtcblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5ibG9ja3Nba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2NvcGVzID0gKHRoaXMuYmxvY2tfc2NvcGVzICYmIHRoaXMuYmxvY2tfc2NvcGVzW2tleV0pIHx8IFtdO1xuICAgICAgICAgICAgICAgIGxldCBjdXJfc2NvcGUgPSBudWxsLCBudW0gPSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYj0wOyBiIDwgdGhpcy5ibG9ja3Nba2V5XS5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3VudCBibG9ja3MgcmVsYXRpdmUgdG8gY3VycmVudCBzY29wZVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGVzW2JdICE9PSBjdXJfc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cl9zY29wZSA9IHNjb3Blc1tiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBibG9ja3Nba2V5XS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5ibG9ja3Nba2V5XVtiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiBjdXJfc2NvcGUgfHwgdGhpcy5uYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIG51bSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGFkZHJlc3MgZGlzY3JlcGFuY3kgaW4gYXJyYXkgdnMuIHNpbmdsZS12YWx1ZSBibG9ja3NcbiAgICAgICAgICAgICAgICAvLyBzdHlsZXMgYXNzdW1lIGFycmF5IHdoZW4gdHJhY2tpbmcgYmxvY2sgc2NvcGVzXG4gICAgICAgICAgICAgICAgYmxvY2tzW2tleV0ucHVzaCh7IGtleSwgc291cmNlOiB0aGlzLmJsb2Nrc1trZXldLCBudW06IDAsIHNjb3BlOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrcztcbiAgICB9XG5cbiAgICAvLyBEZXRlY3QgdW5pZm9ybSBkZWZpbml0aW9ucywgaW5qZWN0IGFueSBtaXNzaW5nIG9uZXNcbiAgICBlbnN1cmVVbmlmb3Jtcyh1bmlmb3Jtcykge1xuICAgICAgICBpZiAoIXVuaWZvcm1zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdnMgPSBzdHJpcCh0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2UpO1xuICAgICAgICB2YXIgZnMgPSBzdHJpcCh0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZSk7XG4gICAgICAgIHZhciBpbmplY3QsIHZzX2luamVjdGlvbnMgPSBbXSwgZnNfaW5qZWN0aW9ucyA9IFtdO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBtaXNzaW5nIHVuaWZvcm0gZGVmaW5pdGlvbnNcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB1bmlmb3Jtcykge1xuICAgICAgICAgICAgaW5qZWN0ID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdmVydGV4IHNoYWRlclxuICAgICAgICAgICAgaWYgKCFHTFNMLmlzVW5pZm9ybURlZmluZWQobmFtZSwgdnMpICYmIEdMU0wuaXNTeW1ib2xSZWZlcmVuY2VkKG5hbWUsIHZzKSkge1xuICAgICAgICAgICAgICAgIGlmICghaW5qZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGluamVjdCA9IEdMU0wuZGVmaW5lVW5pZm9ybShuYW1lLCB1bmlmb3Jtc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZy50cmFjZShgUHJvZ3JhbSAke3RoaXMubmFtZX06ICR7bmFtZX0gbm90IGRlZmluZWQgaW4gdmVydGV4IHNoYWRlciwgaW5qZWN0aW5nOiAnJHtpbmplY3R9J2ApO1xuICAgICAgICAgICAgICAgIHZzX2luamVjdGlvbnMucHVzaChpbmplY3QpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgICAgIGlmICghR0xTTC5pc1VuaWZvcm1EZWZpbmVkKG5hbWUsIGZzKSAmJiBHTFNMLmlzU3ltYm9sUmVmZXJlbmNlZChuYW1lLCBmcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpbmplY3QgPSBHTFNMLmRlZmluZVVuaWZvcm0obmFtZSwgdW5pZm9ybXNbbmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2cudHJhY2UoYFByb2dyYW0gJHt0aGlzLm5hbWV9OiAke25hbWV9IG5vdCBkZWZpbmVkIGluIGZyYWdtZW50IHNoYWRlciwgaW5qZWN0aW5nOiAnJHtpbmplY3R9J2ApO1xuICAgICAgICAgICAgICAgIGZzX2luamVjdGlvbnMucHVzaChpbmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5qZWN0IG1pc3NpbmcgdW5pZm9ybXNcbiAgICAgICAgLy8gTk9URTogdGhlc2UgYXJlIGluamVjdGVkIGF0IHRoZSB2ZXJ5IHRvcCBvZiB0aGUgc2hhZGVycywgZXZlbiBiZWZvcmUgYW55ICNkZWZpbmVzIG9yICNwcmFnbWFzIGFyZSBhZGRlZFxuICAgICAgICAvLyB0aGlzIGNvdWxkIGNhdXNlIHNvbWUgaXNzdWVzIHdpdGggY2VydGFpbiAjcHJhZ21hcywgb3Igb3RoZXIgZnVuY3Rpb25zIHRoYXQgbWlnaHQgZXhwZWN0ICNkZWZpbmVzXG4gICAgICAgIGlmICh2c19pbmplY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZSA9IHZzX2luamVjdGlvbnMuam9pbignXFxuJykgKyB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnNfaW5qZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZSA9IGZzX2luamVjdGlvbnMuam9pbignXFxuJykgKyB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCB1bmlmb3JtcyBmcm9tIGEgSlMgb2JqZWN0LCB3aXRoIGluZmVycmVkIHR5cGVzXG4gICAgc2V0VW5pZm9ybXModW5pZm9ybXMsIHJlc2V0X3RleHR1cmVfdW5pdCA9IHRydWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBvbmx5IHVwZGF0ZSB1bmlmb3JtcyB3aGVuIGNoYW5nZWRcblxuICAgICAgICAvLyBUZXh0dXJlIHVuaXRzIG11c3QgYmUgdHJhY2tlZCBhbmQgaW5jcmVtZW50ZWQgZWFjaCB0aW1lIGEgdGV4dHVyZSBzYW1wbGVyIHVuaWZvcm0gaXMgc2V0LlxuICAgICAgICAvLyBCeSBkZWZhdWx0LCB0aGUgdGV4dHVyZSB1bml0IGlzIHJlc2V0IHRvIDAgZWFjaCB0aW1lIHNldFVuaWZvcm1zIGlzIGNhbGxlZCwgYnV0IHRoZXkgY2FuXG4gICAgICAgIC8vIGFsc28gYmUgcHJlc2VydmVkLCBmb3IgZXhhbXBsZSBpbiBjYXNlcyB3aGVyZSBtdWx0aXBsZSBjYWxscyB0byBzZXRVbmlmb3JtcyBhcmUgZXhwZWN0ZWRcbiAgICAgICAgLy8gKGUuZy4gcHJvZ3JhbS1zcGVjaWZpYyB1bmlmb3JtcyBmb2xsb3dlZCBieSBtZXNoLXNwZWNpZmljIG9uZXMpLlxuICAgICAgICBpZiAocmVzZXRfdGV4dHVyZV91bml0KSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVfdW5pdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXJzZSB1bmlmb3JtIHR5cGVzIGFuZCB2YWx1ZXMgZnJvbSB0aGUgSlMgb2JqZWN0XG4gICAgICAgIHZhciBwYXJzZWQgPSBHTFNMLnBhcnNlVW5pZm9ybXModW5pZm9ybXMpO1xuXG4gICAgICAgIC8vIFNldCBlYWNoIHVuaWZvcm1cbiAgICAgICAgZm9yICh2YXIgdW5pZm9ybSBvZiBwYXJzZWQpIHtcbiAgICAgICAgICAgIGlmICh1bmlmb3JtLnR5cGUgPT09ICdzYW1wbGVyMkQnKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIHRleHR1cmVzLCB3ZSBuZWVkIHRvIHRyYWNrIHRleHR1cmUgdW5pdHMsIHNvIHdlIGhhdmUgYSBzcGVjaWFsIHNldHRlclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGV4dHVyZVVuaWZvcm0odW5pZm9ybS5uYW1lLCB1bmlmb3JtLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudW5pZm9ybSh1bmlmb3JtLm1ldGhvZCwgdW5pZm9ybS5uYW1lLCB1bmlmb3JtLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhY2hlIHNvbWUgb3IgYWxsIHVuaWZvcm0gdmFsdWVzIHNvIHRoZXkgY2FuIGJlIHJlc3RvcmVkXG4gICAgc2F2ZVVuaWZvcm1zKHN1YnNldCkge1xuICAgICAgICBsZXQgdW5pZm9ybXMgPSBzdWJzZXQgfHwgdGhpcy51bmlmb3JtcztcbiAgICAgICAgZm9yIChsZXQgdSBpbiB1bmlmb3Jtcykge1xuICAgICAgICAgICAgbGV0IHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zW3VdO1xuICAgICAgICAgICAgaWYgKHVuaWZvcm0pIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLnNhdmVkX3ZhbHVlID0gdW5pZm9ybS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNhdmVkX3RleHR1cmVfdW5pdCA9IHRoaXMudGV4dHVyZV91bml0IHx8IDA7XG4gICAgfVxuXG4gICAgLy8gUmVzdG9yZSBzb21lIG9yIGFsbCB1bmlmb3JtcyB0byBzYXZlZCB2YWx1ZXNcbiAgICByZXN0b3JlVW5pZm9ybXMoc3Vic2V0KSB7XG4gICAgICAgIGxldCB1bmlmb3JtcyA9IHN1YnNldCB8fCB0aGlzLnVuaWZvcm1zO1xuICAgICAgICBmb3IgKGxldCB1IGluIHVuaWZvcm1zKSB7XG4gICAgICAgICAgICBsZXQgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbdV07XG4gICAgICAgICAgICBpZiAodW5pZm9ybSAmJiB1bmlmb3JtLnNhdmVkX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS52YWx1ZSA9IHVuaWZvcm0uc2F2ZWRfdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVVbmlmb3JtKHUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dHVyZV91bml0ID0gdGhpcy5zYXZlZF90ZXh0dXJlX3VuaXQgfHwgMDtcbiAgICB9XG5cbiAgICAvLyBTZXQgYSB0ZXh0dXJlIHVuaWZvcm0sIGZpbmRzIHRleHR1cmUgYnkgbmFtZSBvciBjcmVhdGVzIGEgbmV3IG9uZVxuICAgIHNldFRleHR1cmVVbmlmb3JtKHVuaWZvcm1fbmFtZSwgdGV4dHVyZV9uYW1lKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gVGV4dHVyZS50ZXh0dXJlc1t0ZXh0dXJlX25hbWVdO1xuICAgICAgICBpZiAodGV4dHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0ZXh0dXJlID0gbmV3IFRleHR1cmUodGhpcy5nbCwgdGV4dHVyZV9uYW1lKTtcbiAgICAgICAgICAgIHRleHR1cmUubG9hZCh0ZXh0dXJlX25hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dHVyZS5iaW5kKHRoaXMudGV4dHVyZV91bml0KTtcbiAgICAgICAgdGhpcy51bmlmb3JtKCcxaScsIHVuaWZvcm1fbmFtZSwgdGhpcy50ZXh0dXJlX3VuaXQpO1xuICAgICAgICB0aGlzLnRleHR1cmVfdW5pdCsrOyAvLyBUT0RPOiB0cmFjayBtYXggdGV4dHVyZSB1bml0cyBhbmQgbG9nL3Rocm93IGVycm9yc1xuICAgIH1cblxuICAgIC8vIGV4OiBwcm9ncmFtLnVuaWZvcm0oJzNmJywgJ3Bvc2l0aW9uJywgeCwgeSwgeik7XG4gICAgLy8gVE9ETzogb25seSB1cGRhdGUgdW5pZm9ybXMgd2hlbiBjaGFuZ2VkXG4gICAgdW5pZm9ybShtZXRob2QsIG5hbWUsIC4uLnZhbHVlKSB7IC8vICd2YWx1ZScgaXMgYSBtZXRob2QtYXBwcm9wcmlhdGUgYXJndW1lbnRzIGxpc3RcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVuaWZvcm1zW25hbWVdID0gdGhpcy51bmlmb3Jtc1tuYW1lXSB8fCB7fTtcbiAgICAgICAgbGV0IHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zW25hbWVdO1xuICAgICAgICB1bmlmb3JtLm5hbWUgPSBuYW1lO1xuICAgICAgICBpZiAodW5pZm9ybS5sb2NhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB1bmlmb3JtLmxvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB1bmlmb3JtLm1ldGhvZCA9ICd1bmlmb3JtJyArIG1ldGhvZDtcbiAgICAgICAgdW5pZm9ybS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVVuaWZvcm0obmFtZSk7XG4gICAgfVxuXG4gICAgLy8gU2V0IGEgc2luZ2xlIHVuaWZvcm1cbiAgICB1cGRhdGVVbmlmb3JtKG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbbmFtZV07XG4gICAgICAgIGlmICghdW5pZm9ybSB8fCB1bmlmb3JtLmxvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXNlKCk7XG4gICAgICAgIHRoaXMuZ2xbdW5pZm9ybS5tZXRob2RdLmFwcGx5KHRoaXMuZ2wsIFt1bmlmb3JtLmxvY2F0aW9uXS5jb25jYXQodW5pZm9ybS52YWx1ZSkpOyAvLyBjYWxsIGFwcHJvcHJpYXRlIEdMIHVuaWZvcm0gbWV0aG9kIGFuZCBwYXNzIHRocm91Z2ggYXJndW1lbnRzXG4gICAgfVxuXG4gICAgLy8gUmVmcmVzaCB1bmlmb3JtIGxvY2F0aW9ucyBhbmQgc2V0IHRvIGxhc3QgY2FjaGVkIHZhbHVlc1xuICAgIHJlZnJlc2hVbmlmb3JtcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciB1IGluIHRoaXMudW5pZm9ybXMpIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXNbdV0ubG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIHUpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVVbmlmb3JtKHUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVmcmVzaEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIC8vIHZhciBsZW4gPSB0aGlzLmdsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5wcm9ncmFtLCB0aGlzLmdsLkFDVElWRV9BVFRSSUJVVEVTKTtcbiAgICAgICAgLy8gZm9yICh2YXIgaT0wOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gICAgIHZhciBhID0gdGhpcy5nbC5nZXRBY3RpdmVBdHRyaWIodGhpcy5wcm9ncmFtLCBpKTtcbiAgICAgICAgLy8gfVxuICAgICAgICB0aGlzLmF0dHJpYnMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIGxvY2F0aW9uIG9mIGEgdmVydGV4IGF0dHJpYnV0ZVxuICAgIGF0dHJpYnV0ZShuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5jb21waWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dHJpYiA9ICh0aGlzLmF0dHJpYnNbbmFtZV0gPSB0aGlzLmF0dHJpYnNbbmFtZV0gfHwge30pO1xuICAgICAgICBpZiAoYXR0cmliLmxvY2F0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhdHRyaWI7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWIubmFtZSA9IG5hbWU7XG4gICAgICAgIGF0dHJpYi5sb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKTtcblxuICAgICAgICAvLyB2YXIgaW5mbyA9IHRoaXMuZ2wuZ2V0QWN0aXZlQXR0cmliKHRoaXMucHJvZ3JhbSwgYXR0cmliLmxvY2F0aW9uKTtcbiAgICAgICAgLy8gYXR0cmliLnR5cGUgPSBpbmZvLnR5cGU7XG4gICAgICAgIC8vIGF0dHJpYi5zaXplID0gaW5mby5zaXplO1xuXG4gICAgICAgIHJldHVybiBhdHRyaWI7XG4gICAgfVxuXG4gICAgLy8gR2V0IHNoYWRlciBzb3VyY2UgYXMgc3RyaW5nXG4gICAgc291cmNlKHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICd2ZXJ0ZXgnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdmcmFnbWVudCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldCBzaGFkZXIgc291cmNlIGFzIGFycmF5IG9mIGxpbmUgc3RyaW5nc1xuICAgIGxpbmVzKHR5cGUpIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHRoaXMuc291cmNlKHR5cGUpO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gR2V0IGEgc3BlY2lmaWMgbGluZSBmcm9tIHNoYWRlciBzb3VyY2VcbiAgICBsaW5lKHR5cGUsIG51bSkge1xuICAgICAgICBsZXQgc291cmNlID0gdGhpcy5saW5lcyh0eXBlKTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZVtudW1dO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IGluZm8gb24gd2hpY2ggc2hhZGVyIGJsb2NrIChpZiBhbnkpIGEgcGFydGljdWxhciBsaW5lIG51bWJlciBpbiBhIHNoYWRlciBpcyBpblxuICAgIC8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBpbmZvIGlmIGEgYmxvY2sgaXMgZm91bmQ6IHsgbmFtZSwgbGluZSwgc291cmNlIH1cbiAgICAvLyAgc2NvcGU6IHdoZXJlIHRoZSBzaGFkZXIgYmxvY2sgb3JpZ2luYXRlZCwgZWl0aGVyIGEgc3R5bGUgbmFtZSwgb3IgZ2xvYmFsIHN1Y2ggYXMgU2hhZGVyUHJvZ3JhbVxuICAgIC8vICBuYW1lOiBzaGFkZXIgYmxvY2sgbmFtZSAoZS5nLiAnY29sb3InLCAncG9zaXRpb24nLCAnZ2xvYmFsJylcbiAgICAvLyAgbnVtOiB0aGUgYmxvY2sgbnVtYmVyICp3aXRoaW4qIGxvY2FsIHNjb3BlIChlLmcuIGlmIGEgc3R5bGUgaGFzIG11bHRpcGxlICdjb2xvcicgYmxvY2tzKVxuICAgIC8vICBsaW5lOiBsaW5lIG51bWJlciAqd2l0aGluKiB0aGUgc2hhZGVyIGJsb2NrIChub3QgdGhlIHdob2xlIHNoYWRlciBwcm9ncmFtKSwgdXNlZnVsIGZvciBlcnJvciBoaWdobGlnaHRpbmdcbiAgICAvLyAgc291cmNlOiB0aGUgY29kZSBmb3IgdGhlIGxpbmVcbiAgICAvLyBOT1RFOiB0aGlzIGRvZXMgYSBicnV0ZWZvcmNlIGxvb3Agb3ZlciB0aGUgc2hhZGVyIHNvdXJjZSBhbmQgbG9va3MgZm9yIHNoYWRlciBibG9jayBzdGFydC9lbmQgbWFya2Vyc1xuICAgIC8vIFdlIGNvdWxkIHRyYWNrIGxpbmUgcmFuZ2VzIGZvciBzaGFkZXIgYmxvY2tzIGFzIHRoZXkgYXJlIGluc2VydGVkLCBidXQgYXMgdGhpcyBjb2RlIGlzIG9ubHkgdXNlZCBmb3JcbiAgICAvLyBlcnJvciBoYW5kbGluZyBvbiBjb21waWxhdGlvbiBmYWlsdXJlLCBpdCB3YXMgc2ltcGxlciB0byBrZWVwIGl0IHNlcGFyYXRlIHRoYW4gdG8gYnVyZGVuIHRoZSBjb3JlXG4gICAgLy8gY29tcGlsYXRpb24gcGF0aC5cbiAgICBibG9jayh0eXBlLCBudW0pIHtcbiAgICAgICAgbGV0IGxpbmVzID0gdGhpcy5saW5lcyh0eXBlKTtcbiAgICAgICAgbGV0IGJsb2NrO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBudW0gJiYgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gbGluZS5tYXRjaCgvXFwvXFwvIHRhbmdyYW0tYmxvY2stc3RhcnQ6IChbQS1aYS16MC05Xy1dKyksIChbQS1aYS16MC05Xy1dKyksIChcXGQrKS8pO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGN1cnJlbnQgYmxvY2tcbiAgICAgICAgICAgICAgICBibG9jayA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGU6IG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICAgICAgbnVtOiBtYXRjaFszXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGxpbmUubWF0Y2goL1xcL1xcLyB0YW5ncmFtLWJsb2NrLWVuZDogKFtBLVphLXowLTlfLV0rKSwgKFtBLVphLXowLTlfLV0rKSwgKFxcZCspLyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBudWxsOyAvLyBjbGVhciBjdXJyZW50IGJsb2NrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgbGluZSAjIGFuZCBjb250ZW50XG4gICAgICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICAvLyBpbml0IHRvIC0xIHNvIHRoYXQgbGluZSAwIGlzIGZpcnN0IGFjdHVhbCBsaW5lIG9mIGJsb2NrIGNvZGUsIGFmdGVyIGNvbW1lbnQgbWFya2VyXG4gICAgICAgICAgICAgICAgYmxvY2subGluZSA9IChibG9jay5saW5lID09IG51bGwpID8gLTEgOiBibG9jay5saW5lICsgMTtcbiAgICAgICAgICAgICAgICBibG9jay5zb3VyY2UgPSBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGxpc3Qgb2YgYXZhaWxhYmxlIGV4dGVuc2lvbnMgZnJvbSB0aG9zZSByZXF1ZXN0ZWRcbiAgICAvLyBTZXRzIGludGVybmFsICNkZWZpbmVzIGluZGljYXRpbmcgYXZhaWxhYmlsaXR5IG9mIGVhY2ggcmVxdWVzdGVkIGV4dGVuc2lvblxuICAgIGNoZWNrRXh0ZW5zaW9ucygpIHtcbiAgICAgICAgbGV0IGV4dHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBvZiB0aGlzLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgIGxldCBleHQgPSBnZXRFeHRlbnNpb24odGhpcy5nbCwgbmFtZSk7XG4gICAgICAgICAgICBsZXQgZGVmID0gYFRBTkdSQU1fRVhURU5TSU9OXyR7bmFtZX1gO1xuXG4gICAgICAgICAgICB0aGlzLmRlZmluZXNbZGVmXSA9IChleHQgIT0gbnVsbCk7XG5cbiAgICAgICAgICAgIGlmIChleHQpIHtcbiAgICAgICAgICAgICAgICBleHRzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoYENvdWxkIG5vdCBlbmFibGUgZXh0ZW5zaW9uICcke25hbWV9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRzO1xuICAgIH1cblxufVxuXG5cbi8vIFN0YXRpYyBtZXRob2RzIGFuZCBzdGF0ZVxuXG5TaGFkZXJQcm9ncmFtLmlkID0gMDsgICAgICAgICAgIC8vIGFzc2lnbiBlYWNoIHByb2dyYW0gYSB1bmlxdWUgaWRcblNoYWRlclByb2dyYW0ucHJvZ3JhbXMgPSB7fTsgICAgLy8gcHJvZ3JhbXMsIGJ5IGlkXG5TaGFkZXJQcm9ncmFtLmN1cnJlbnQgPSBudWxsOyAgIC8vIGN1cnJlbnRseSBib3VuZCBwcm9ncmFtXG5cbi8vIEdsb2JhbCBjb25maWcgYXBwbGllZCB0byBhbGwgcHJvZ3JhbXMgKGR1cGxpY2F0ZSBwcm9wZXJ0aWVzIGZvciBhIHNwZWNpZmljIHByb2dyYW0gd2lsbCB0YWtlIHByZWNlZGVuY2UpXG5TaGFkZXJQcm9ncmFtLmRlZmluZXMgPSB7fTtcblNoYWRlclByb2dyYW0uYmxvY2tzID0ge307XG5cbi8vIFR1cm4gYW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycyBpbnRvIHNpbmdsZSBzdHJpbmcgb2YgI2RlZmluZSBzdGF0ZW1lbnRzXG5TaGFkZXJQcm9ncmFtLmJ1aWxkRGVmaW5lU3RyaW5nID0gZnVuY3Rpb24gKGRlZmluZXMpIHtcbiAgICB2YXIgZGVmaW5lX3N0ciA9IFwiXCI7XG4gICAgZm9yICh2YXIgZCBpbiBkZWZpbmVzKSB7XG4gICAgICAgIGlmIChkZWZpbmVzW2RdID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZXNbZF0gPT09ICdib29sZWFuJyAmJiBkZWZpbmVzW2RdID09PSB0cnVlKSB7IC8vIGJvb2xlYW5zIGFyZSBzaW1wbGUgZGVmaW5lcyB3aXRoIG5vIHZhbHVlXG4gICAgICAgICAgICBkZWZpbmVfc3RyICs9IFwiI2RlZmluZSBcIiArIGQgKyBcIlxcblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmVzW2RdID09PSAnbnVtYmVyJyAmJiBNYXRoLmZsb29yKGRlZmluZXNbZF0pID09PSBkZWZpbmVzW2RdKSB7IC8vIGludCB0byBmbG9hdCBjb252ZXJzaW9uIHRvIHNhdGlzZnkgR0xTTCBmbG9hdHNcbiAgICAgICAgICAgIGRlZmluZV9zdHIgKz0gXCIjZGVmaW5lIFwiICsgZCArIFwiIFwiICsgZGVmaW5lc1tkXS50b0ZpeGVkKDEpICsgXCJcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gYW55IG90aGVyIGZsb2F0IG9yIHN0cmluZyB2YWx1ZVxuICAgICAgICAgICAgZGVmaW5lX3N0ciArPSBcIiNkZWZpbmUgXCIgKyBkICsgXCIgXCIgKyBkZWZpbmVzW2RdICsgXCJcXG5cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmaW5lX3N0cjtcbn07XG5cbi8vIFR1cm4gYSBsaXN0IG9mIGV4dGVuc2lvbiBuYW1lcyBpbnRvIHNpbmdsZSBzdHJpbmcgb2YgI2V4dGVuc2lvbiBzdGF0ZW1lbnRzXG5TaGFkZXJQcm9ncmFtLmJ1aWxkRXh0ZW5zaW9uU3RyaW5nID0gZnVuY3Rpb24gKGV4dGVuc2lvbnMpIHtcbiAgICBleHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCBbXTtcbiAgICBsZXQgc3RyID0gXCJcIjtcbiAgICBmb3IgKGxldCBleHQgb2YgZXh0ZW5zaW9ucykge1xuICAgICAgICBzdHIgKz0gYCNleHRlbnNpb24gR0xfJHtleHR9IDogZW5hYmxlXFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG5cblNoYWRlclByb2dyYW0uYWRkQmxvY2sgPSBmdW5jdGlvbiAoa2V5LCAuLi5ibG9ja3MpIHtcbiAgICBTaGFkZXJQcm9ncmFtLmJsb2Nrc1trZXldID0gU2hhZGVyUHJvZ3JhbS5ibG9ja3Nba2V5XSB8fCBbXTtcbiAgICBTaGFkZXJQcm9ncmFtLmJsb2Nrc1trZXldLnB1c2goLi4uYmxvY2tzKTtcbn07XG5cbi8vIFJlbW92ZSBhbGwgZ2xvYmFsIHNoYWRlciBibG9ja3MgZm9yIGEgZ2l2ZW4ga2V5XG5TaGFkZXJQcm9ncmFtLnJlbW92ZUJsb2NrID0gZnVuY3Rpb24gKGtleSkge1xuICAgIFNoYWRlclByb2dyYW0uYmxvY2tzW2tleV0gPSBbXTtcbn07XG5cblNoYWRlclByb2dyYW0ucmVwbGFjZUJsb2NrID0gZnVuY3Rpb24gKGtleSwgLi4uYmxvY2tzKSB7XG4gICAgU2hhZGVyUHJvZ3JhbS5yZW1vdmVCbG9jayhrZXkpO1xuICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soa2V5LCAuLi5ibG9ja3MpO1xufTtcblxuLy8gQ29tcGlsZSAmIGxpbmsgYSBXZWJHTCBwcm9ncmFtIGZyb20gcHJvdmlkZWQgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXIgc291cmNlc1xuLy8gdXBkYXRlIGEgcHJvZ3JhbSBpZiBvbmUgaXMgcGFzc2VkIGluLiBDcmVhdGUgb25lIGlmIG5vdC4gQWxlcnQgYW5kIGRvbid0IHVwZGF0ZSBhbnl0aGluZyBpZiB0aGUgc2hhZGVycyBkb24ndCBjb21waWxlLlxuU2hhZGVyUHJvZ3JhbS51cGRhdGVQcm9ncmFtID0gZnVuY3Rpb24gKGdsLCBwcm9ncmFtLCB2ZXJ0ZXhfc2hhZGVyX3NvdXJjZSwgZnJhZ21lbnRfc2hhZGVyX3NvdXJjZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciB2ZXJ0ZXhfc2hhZGVyID0gU2hhZGVyUHJvZ3JhbS5jcmVhdGVTaGFkZXIoZ2wsIHZlcnRleF9zaGFkZXJfc291cmNlLCBnbC5WRVJURVhfU0hBREVSKTtcbiAgICAgICAgdmFyIGZyYWdtZW50X3NoYWRlciA9IFNoYWRlclByb2dyYW0uY3JlYXRlU2hhZGVyKGdsLCBmcmFnbWVudF9zaGFkZXJfc291cmNlLCBnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgIH1cbiAgICBjYXRjaChlcnIpIHtcbiAgICAgICAgbG9nLmVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIGdsLnVzZVByb2dyYW0obnVsbCk7XG4gICAgaWYgKHByb2dyYW0gIT0gbnVsbCkge1xuICAgICAgICB2YXIgb2xkX3NoYWRlcnMgPSBnbC5nZXRBdHRhY2hlZFNoYWRlcnMocHJvZ3JhbSk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvbGRfc2hhZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZ2wuZGV0YWNoU2hhZGVyKHByb2dyYW0sIG9sZF9zaGFkZXJzW2ldKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgfVxuXG4gICAgaWYgKHZlcnRleF9zaGFkZXIgPT0gbnVsbCB8fCBmcmFnbWVudF9zaGFkZXIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG5cbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4X3NoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50X3NoYWRlcik7XG5cbiAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4X3NoYWRlcik7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50X3NoYWRlcik7XG5cbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgV2ViR0wgcHJvZ3JhbSBlcnJvcjpcbiAgICAgICAgICAgIFZBTElEQVRFX1NUQVRVUzogJHtnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUyl9XG4gICAgICAgICAgICBFUlJPUjogJHtnbC5nZXRFcnJvcigpfVxuICAgICAgICAgICAgLS0tIFZlcnRleCBTaGFkZXIgLS0tXG4gICAgICAgICAgICAke3ZlcnRleF9zaGFkZXJfc291cmNlfVxuICAgICAgICAgICAgLS0tIEZyYWdtZW50IFNoYWRlciAtLS1cbiAgICAgICAgICAgICR7ZnJhZ21lbnRfc2hhZGVyX3NvdXJjZX1gKTtcblxuICAgICAgICBsZXQgZXJyb3IgPSB7IHR5cGU6ICdwcm9ncmFtJywgbWVzc2FnZSB9O1xuICAgICAgICBsb2cuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9ncmFtO1xufTtcblxuLy8gQ29tcGlsZSBhIHZlcnRleCBvciBmcmFnbWVudCBzaGFkZXIgZnJvbSBwcm92aWRlZCBzb3VyY2VcblNoYWRlclByb2dyYW0uY3JlYXRlU2hhZGVyID0gZnVuY3Rpb24gKGdsLCBzb3VyY2UsIHN0eXBlKSB7XG4gICAgbGV0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihzdHlwZSk7XG5cbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgIGxldCB0eXBlID0gKHN0eXBlID09PSBnbC5WRVJURVhfU0hBREVSID8gJ3ZlcnRleCcgOiAnZnJhZ21lbnQnKTtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgICAgIGxldCBlcnJvcnMgPSBwYXJzZVNoYWRlckVycm9ycyhtZXNzYWdlKTtcbiAgICAgICAgdGhyb3cgeyB0eXBlLCBtZXNzYWdlLCBlcnJvcnMgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyO1xufTtcbiIsIi8vIEdlbmVyYXRlZCBmcm9tIEdMU0wgZmlsZXMsIGRvbid0IGVkaXQhXG52YXIgc2hhZGVyU291cmNlcyA9IHt9O1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL2FjY2Vzc29ycyddID1cblwiLy8gVmVydGV4IHBvc2l0aW9uIGluIG1vZGVsIHNwYWNlOiBbMCwgMV0gcmFuZ2Ugb3ZlciB0aGUgbG9jYWwgdGlsZVxcblwiICtcblwiLy8gTm90ZSBwb3NpdGlvbnMgY2FuIGJlIG91dHNpZGUgdGhhdCByYW5nZSBkdWUgdG8gdW5jbGlwcGVkIGdlb21ldHJ5LCBnZW9tZXRyeSBoaWdoZXIgdGhhbiBhIHVuaXQgY3ViZSwgZXRjLlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fVkVSVEVYX1NIQURFUlxcblwiICtcblwiXFxuXCIgK1xuXCJ2ZWM0IG1vZGVsUG9zaXRpb24oKSB7XFxuXCIgK1xuXCIgICAgcmV0dXJuIHZlYzQoU0hPUlQoYV9wb3NpdGlvbi54eXopIC8gVEFOR1JBTV9USUxFX1NDQUxFLCAxLik7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIvLyBWZXJ0ZXggcG9zaXRpb24gaW4gd29ybGQgY29vcmRpbmF0ZXMsIHVzZWZ1bCBmb3IgM2QgcHJvY2VkdXJhbCB0ZXh0dXJlcywgZXRjLlxcblwiICtcblwidmVjNCB3b3JsZFBvc2l0aW9uKCkge1xcblwiICtcblwiICAgIHJldHVybiB2X3dvcmxkX3Bvc2l0aW9uO1xcblwiICtcblwifVxcblwiICtcblwiXFxuXCIgK1xuXCIvLyBPcHRpb25hbGx5IHdyYXAgd29ybGQgY29vcmRpbmF0ZXMgKGFsbG93cyBtb3JlIHByZWNpc2lvbiBhdCBoaWdoZXIgem9vbXMpXFxuXCIgK1xuXCIvLyBlLmcuIGF0IHdyYXAgMTAwMCwgdGhlIHdvcmxkIHNwYWNlIHdpbGwgd3JhcCBldmVyeSAxMDAwIG1ldGVyc1xcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fVkVSVEVYX1NIQURFUlxcblwiICtcblwiXFxuXCIgK1xuXCJ2ZWM0IHdyYXBXb3JsZFBvc2l0aW9uKHZlYzQgd29ybGRfcG9zaXRpb24pIHtcXG5cIiArXG5cIiAgICAjaWYgZGVmaW5lZChUQU5HUkFNX1dPUkxEX1BPU0lUSU9OX1dSQVApXFxuXCIgK1xuXCIgICAgdmVjMiBhbmNob3IgPSB1X3RpbGVfb3JpZ2luLnh5IC0gbW9kKHVfdGlsZV9vcmlnaW4ueHksIFRBTkdSQU1fV09STERfUE9TSVRJT05fV1JBUCk7XFxuXCIgK1xuXCIgICAgICAgIHdvcmxkX3Bvc2l0aW9uLnh5IC09IGFuY2hvcjtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIiAgICByZXR1cm4gd29ybGRfcG9zaXRpb247XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIvLyBOb3JtYWwgaW4gd29ybGQgc3BhY2VcXG5cIiArXG5cIiNpZiBkZWZpbmVkKFRBTkdSQU1fVkVSVEVYX1NIQURFUilcXG5cIiArXG5cIlxcblwiICtcblwidmVjMyB3b3JsZE5vcm1hbCgpIHtcXG5cIiArXG5cIiAgICByZXR1cm4gVEFOR1JBTV9OT1JNQUw7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcXG5cIiArXG5cIiNlbGlmIGRlZmluZWQoVEFOR1JBTV9GUkFHTUVOVF9TSEFERVIpXFxuXCIgK1xuXCJcXG5cIiArXG5cInZlYzMgd29ybGROb3JtYWwoKSB7XFxuXCIgK1xuXCIgICAgcmV0dXJuIHVfaW52ZXJzZU5vcm1hbE1hdHJpeCAqIFRBTkdSQU1fTk9STUFMO1xcblwiICtcblwifVxcblwiICtcblwiXFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL2FtYmllbnRMaWdodCddID1cblwiLypcXG5cIiArXG5cIlxcblwiICtcblwiRXhwZWN0ZWQgZ2xvYmFsczpcXG5cIiArXG5cImxpZ2h0X2FjY3VtdWxhdG9yXypcXG5cIiArXG5cIlxcblwiICtcblwiKi9cXG5cIiArXG5cIlxcblwiICtcblwic3RydWN0IEFtYmllbnRMaWdodCB7XFxuXCIgK1xuXCIgICAgdmVjNCBhbWJpZW50O1xcblwiICtcblwifTtcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBjYWxjdWxhdGVMaWdodChpbiBBbWJpZW50TGlnaHQgX2xpZ2h0LCBpbiB2ZWMzIF9leWVUb1BvaW50LCBpbiB2ZWMzIF9ub3JtYWwpIHtcXG5cIiArXG5cIiAgICBsaWdodF9hY2N1bXVsYXRvcl9hbWJpZW50ICs9IF9saWdodC5hbWJpZW50O1xcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvZGlyZWN0aW9uYWxMaWdodCddID1cblwiLypcXG5cIiArXG5cIlxcblwiICtcblwiRXhwZWN0ZWQgZ2xvYmFsczpcXG5cIiArXG5cIm1hdGVyaWFsXFxuXCIgK1xuXCJsaWdodF9hY2N1bXVsYXRvcl8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIiovXFxuXCIgK1xuXCJcXG5cIiArXG5cInN0cnVjdCBEaXJlY3Rpb25hbExpZ2h0IHtcXG5cIiArXG5cIiAgICB2ZWM0IGFtYmllbnQ7XFxuXCIgK1xuXCIgICAgdmVjNCBkaWZmdXNlO1xcblwiICtcblwiICAgIHZlYzQgc3BlY3VsYXI7XFxuXCIgK1xuXCIgICAgdmVjMyBkaXJlY3Rpb247XFxuXCIgK1xuXCJ9O1xcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIGNhbGN1bGF0ZUxpZ2h0KGluIERpcmVjdGlvbmFsTGlnaHQgX2xpZ2h0LCBpbiB2ZWMzIF9leWVUb1BvaW50LCBpbiB2ZWMzIF9ub3JtYWwpIHtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGxpZ2h0X2FjY3VtdWxhdG9yX2FtYmllbnQgKz0gX2xpZ2h0LmFtYmllbnQ7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBmbG9hdCBuRG90VlAgPSBjbGFtcChkb3QoX25vcm1hbCwgLW5vcm1hbGl6ZShfbGlnaHQuZGlyZWN0aW9uKSksIDAuMCwgMS4wKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VcXG5cIiArXG5cIiAgICAgICAgbGlnaHRfYWNjdW11bGF0b3JfZGlmZnVzZSArPSBfbGlnaHQuZGlmZnVzZSAqIG5Eb3RWUDtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSXFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IHBmID0gMC4wO1xcblwiICtcblwiICAgICAgICBpZiAobkRvdFZQID4gMC4wKSB7XFxuXCIgK1xuXCIgICAgICAgICAgICB2ZWMzIHJlZmxlY3RWZWN0b3IgPSByZWZsZWN0KG5vcm1hbGl6ZShfbGlnaHQuZGlyZWN0aW9uKSwgX25vcm1hbCk7XFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBleWVEb3RSID0gbWF4KGRvdChub3JtYWxpemUoX2V5ZVRvUG9pbnQpLCByZWZsZWN0VmVjdG9yKSwgMC4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgIHBmID0gcG93KGV5ZURvdFIsIG1hdGVyaWFsLnNoaW5pbmVzcyk7XFxuXCIgK1xuXCIgICAgICAgIH1cXG5cIiArXG5cIiAgICAgICAgbGlnaHRfYWNjdW11bGF0b3Jfc3BlY3VsYXIgKz0gX2xpZ2h0LnNwZWN1bGFyICogcGY7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9sYXllcl9vcmRlciddID1cblwiLy8gQXBwbHkgbGF5ZXIgb3JkZXJpbmcgdG8gYXZvaWQgei1maWdodGluZ1xcblwiICtcblwidm9pZCBhcHBseUxheWVyT3JkZXIgKGZsb2F0IGxheWVyLCBpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XFxuXCIgK1xuXCIgICAgcG9zaXRpb24ueiAtPSBsYXllciAqIFRBTkdSQU1fTEFZRVJfREVMVEEgKiBwb3NpdGlvbi53O1xcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvbWF0ZXJpYWwnXSA9XG5cIi8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIkRlZmluZXMgZ2xvYmFsczpcXG5cIiArXG5cIm1hdGVyaWFsXFxuXCIgK1xuXCJsaWdodF9hY2N1bXVsYXRvcl8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIiovXFxuXCIgK1xuXCJcXG5cIiArXG5cIlxcblwiICtcblwiLy8gTUFURVJJQUxTXFxuXCIgK1xuXCIvL1xcblwiICtcblwic3RydWN0IE1hdGVyaWFsIHtcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9FTUlTU0lPTlxcblwiICtcblwiICAgICAgICB2ZWM0IGVtaXNzaW9uO1xcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9FTUlTU0lPTl9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgICAgICB2ZWMzIGVtaXNzaW9uU2NhbGU7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfQU1CSUVOVFxcblwiICtcblwiICAgICAgICB2ZWM0IGFtYmllbnQ7XFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRfVEVYVFVSRVxcblwiICtcblwiICAgICAgICAgICAgdmVjMyBhbWJpZW50U2NhbGU7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRVxcblwiICtcblwiICAgICAgICB2ZWM0IGRpZmZ1c2U7XFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VfVEVYVFVSRVxcblwiICtcblwiICAgICAgICAgICAgdmVjMyBkaWZmdXNlU2NhbGU7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJcXG5cIiArXG5cIiAgICAgICAgdmVjNCBzcGVjdWxhcjtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgc2hpbmluZXNzO1xcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUl9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgICAgICB2ZWMzIHNwZWN1bGFyU2NhbGU7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9OT1JNQUxfVEVYVFVSRVxcblwiICtcblwiICAgICAgICB2ZWMzIG5vcm1hbFNjYWxlO1xcblwiICtcblwiICAgICAgICBmbG9hdCBub3JtYWxBbW91bnQ7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJ9O1xcblwiICtcblwiXFxuXCIgK1xuXCIvLyBOb3RlOiB1bmlmb3JtIGlzIGNvcGllZCB0byBhIGdsb2JhbCBpbnN0YW5jZSB0byBhbGxvdyBtb2RpZmljYXRpb25cXG5cIiArXG5cInVuaWZvcm0gTWF0ZXJpYWwgdV9tYXRlcmlhbDtcXG5cIiArXG5cIk1hdGVyaWFsIG1hdGVyaWFsO1xcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9FTUlTU0lPTl9URVhUVVJFXFxuXCIgK1xuXCJ1bmlmb3JtIHNhbXBsZXIyRCB1X21hdGVyaWFsX2VtaXNzaW9uX3RleHR1cmU7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfQU1CSUVOVF9URVhUVVJFXFxuXCIgK1xuXCJ1bmlmb3JtIHNhbXBsZXIyRCB1X21hdGVyaWFsX2FtYmllbnRfdGV4dHVyZTtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFX1RFWFRVUkVcXG5cIiArXG5cInVuaWZvcm0gc2FtcGxlcjJEIHVfbWF0ZXJpYWxfZGlmZnVzZV90ZXh0dXJlO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSX1RFWFRVUkVcXG5cIiArXG5cInVuaWZvcm0gc2FtcGxlcjJEIHVfbWF0ZXJpYWxfc3BlY3VsYXJfdGV4dHVyZTtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9OT1JNQUxfVEVYVFVSRVxcblwiICtcblwidW5pZm9ybSBzYW1wbGVyMkQgdV9tYXRlcmlhbF9ub3JtYWxfdGV4dHVyZTtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIvLyBHbG9iYWwgbGlnaHQgYWNjdW11bGF0b3JzIGZvciBlYWNoIHByb3BlcnR5XFxuXCIgK1xuXCJ2ZWM0IGxpZ2h0X2FjY3VtdWxhdG9yX2FtYmllbnQgPSB2ZWM0KDAuMCk7XFxuXCIgK1xuXCJ2ZWM0IGxpZ2h0X2FjY3VtdWxhdG9yX2RpZmZ1c2UgPSB2ZWM0KDAuMCk7XFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUlxcblwiICtcblwiICAgIHZlYzQgbGlnaHRfYWNjdW11bGF0b3Jfc3BlY3VsYXIgPSB2ZWM0KDAuMCk7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9URVhUVVJFX1NQSEVSRU1BUFxcblwiICtcblwidmVjNCBnZXRTcGhlcmVNYXAgKGluIHNhbXBsZXIyRCBfdGV4LCBpbiB2ZWMzIF9leWVUb1BvaW50LCBpbiB2ZWMzIF9ub3JtYWwsIGluIHZlYzIgX3NrZXcpIHtcXG5cIiArXG5cIiAgICB2ZWMzIGV5ZSA9IG5vcm1hbGl6ZShfZXllVG9Qb2ludCk7XFxuXCIgK1xuXCIgICAgZXllLnh5IC09IF9za2V3O1xcblwiICtcblwiICAgIGV5ZSA9IG5vcm1hbGl6ZShleWUpO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgdmVjMyByID0gcmVmbGVjdChleWUsIF9ub3JtYWwpO1xcblwiICtcblwiICAgIHIueiArPSAxLjA7XFxuXCIgK1xuXCIgICAgZmxvYXQgbSA9IDIuICogbGVuZ3RoKHIpO1xcblwiICtcblwiICAgIHZlYzIgdXYgPSByLnh5IC8gbSArIC41O1xcblwiICtcblwiICAgIHJldHVybiB0ZXh0dXJlMkQoX3RleCwgdXYpO1xcblwiICtcblwifVxcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfVEVYVFVSRV9UUklQTEFOQVJcXG5cIiArXG5cInZlYzMgZ2V0VHJpUGxhbmFyQmxlbmQgKGluIHZlYzMgX25vcm1hbCkge1xcblwiICtcblwiICAgIHZlYzMgYmxlbmRpbmcgPSBhYnMoX25vcm1hbCk7XFxuXCIgK1xuXCIgICAgYmxlbmRpbmcgPSBub3JtYWxpemUobWF4KGJsZW5kaW5nLCAwLjAwMDAxKSk7XFxuXCIgK1xuXCIgICAgZmxvYXQgYiA9IChibGVuZGluZy54ICsgYmxlbmRpbmcueSArIGJsZW5kaW5nLnopO1xcblwiICtcblwiICAgIHJldHVybiBibGVuZGluZyAvIGI7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcXG5cIiArXG5cInZlYzQgZ2V0VHJpUGxhbmFyIChpbiBzYW1wbGVyMkQgX3RleCwgaW4gdmVjMyBfcG9zLCBpbiB2ZWMzIF9ub3JtYWwsIGluIHZlYzMgX3NjYWxlKSB7XFxuXCIgK1xuXCIgICAgdmVjMyBibGVuZGluZyA9IGdldFRyaVBsYW5hckJsZW5kKF9ub3JtYWwpO1xcblwiICtcblwiICAgIHZlYzQgeGF4aXMgPSB0ZXh0dXJlMkQoX3RleCwgZnJhY3QoX3Bvcy55eiAqIF9zY2FsZS54KSk7XFxuXCIgK1xuXCIgICAgdmVjNCB5YXhpcyA9IHRleHR1cmUyRChfdGV4LCBmcmFjdChfcG9zLnh6ICogX3NjYWxlLnkpKTtcXG5cIiArXG5cIiAgICB2ZWM0IHpheGlzID0gdGV4dHVyZTJEKF90ZXgsIGZyYWN0KF9wb3MueHkgKiBfc2NhbGUueikpO1xcblwiICtcblwiICAgIHJldHVybiAgeGF4aXMgKiBibGVuZGluZy54ICsgeWF4aXMgKiBibGVuZGluZy55ICsgemF4aXMgKiBibGVuZGluZy56O1xcblwiICtcblwifVxcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfVEVYVFVSRV9QTEFOQVJcXG5cIiArXG5cInZlYzQgZ2V0UGxhbmFyIChpbiBzYW1wbGVyMkQgX3RleCwgaW4gdmVjMyBfcG9zLCBpbiB2ZWMyIF9zY2FsZSkge1xcblwiICtcblwiICAgIHJldHVybiB0ZXh0dXJlMkQoIF90ZXgsIGZyYWN0KF9wb3MueHkgKiBfc2NhbGUueCkgKTtcXG5cIiArXG5cIn1cXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX05PUk1BTF9URVhUVVJFXFxuXCIgK1xuXCJ2b2lkIGNhbGN1bGF0ZU5vcm1hbCAoaW5vdXQgdmVjMyBfbm9ybWFsKSB7XFxuXCIgK1xuXCIgICAgLy8gR2V0IE5PUk1BTE1BUFxcblwiICtcblwiICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkVfVVZcXG5cIiArXG5cIiAgICBfbm9ybWFsICs9IHRleHR1cmUyRCh1X21hdGVyaWFsX25vcm1hbF90ZXh0dXJlLCBmcmFjdCh2X3RleGNvb3JkKm1hdGVyaWFsLm5vcm1hbFNjYWxlLnh5KSkucmdiKjIuMC0xLjA7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9OT1JNQUxfVEVYVFVSRV9QTEFOQVJcXG5cIiArXG5cIiAgICB2ZWMzIG5vcm1hbFRleCA9IGdldFBsYW5hcih1X21hdGVyaWFsX25vcm1hbF90ZXh0dXJlLCB2X3dvcmxkX3Bvc2l0aW9uLnh5eiwgbWF0ZXJpYWwubm9ybWFsU2NhbGUueHkpLnJnYioyLjAtMS4wO1xcblwiICtcblwiICAgIF9ub3JtYWwgKz0gbm9ybWFsVGV4O1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkVfVFJJUExBTkFSXFxuXCIgK1xuXCIgICAgdmVjMyBub3JtYWxUZXggPSBnZXRUcmlQbGFuYXIodV9tYXRlcmlhbF9ub3JtYWxfdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIF9ub3JtYWwsIG1hdGVyaWFsLm5vcm1hbFNjYWxlKS5yZ2IqMi4wLTEuMDtcXG5cIiArXG5cIiAgICBfbm9ybWFsICs9IG5vcm1hbFRleDtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIF9ub3JtYWwgPSBub3JtYWxpemUoX25vcm1hbCk7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBjYWxjdWxhdGVNYXRlcmlhbCAoaW4gdmVjMyBfZXllVG9Qb2ludCwgaW5vdXQgdmVjMyBfbm9ybWFsKSB7XFxuXCIgK1xuXCIgICAgLy8gZ2V0IEVNSVNTSU9OIFRFWFRVUkVNQVBcXG5cIiArXG5cIiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0VNSVNTSU9OX1RFWFRVUkVcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRU1JU1NJT05fVEVYVFVSRV9VVlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5lbWlzc2lvbiAqPSB0ZXh0dXJlMkQodV9tYXRlcmlhbF9lbWlzc2lvbl90ZXh0dXJlLHZfdGV4Y29vcmQpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9FTUlTU0lPTl9URVhUVVJFX1BMQU5BUlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5lbWlzc2lvbiAqPSBnZXRQbGFuYXIodV9tYXRlcmlhbF9lbWlzc2lvbl90ZXh0dXJlLCB2X3dvcmxkX3Bvc2l0aW9uLnh5eiwgbWF0ZXJpYWwuZW1pc3Npb25TY2FsZS54eSk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0VNSVNTSU9OX1RFWFRVUkVfVFJJUExBTkFSXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmVtaXNzaW9uICo9IGdldFRyaVBsYW5hcih1X21hdGVyaWFsX2VtaXNzaW9uX3RleHR1cmUsIHZfd29ybGRfcG9zaXRpb24ueHl6LCBfbm9ybWFsLCBtYXRlcmlhbC5lbWlzc2lvblNjYWxlKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRU1JU1NJT05fVEVYVFVSRV9TUEhFUkVNQVBcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuZW1pc3Npb24gKj0gZ2V0U3BoZXJlTWFwKHVfbWF0ZXJpYWxfZW1pc3Npb25fdGV4dHVyZSwgX2V5ZVRvUG9pbnQsIF9ub3JtYWwsIHVfdmFuaXNoaW5nX3BvaW50KTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBnZXQgQU1CSUVOVCBURVhUVVJFTUFQXFxuXCIgK1xuXCIgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9BTUJJRU5UX1RFWFRVUkVcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfQU1CSUVOVF9URVhUVVJFX1VWXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmFtYmllbnQgKj0gdGV4dHVyZTJEKHVfbWF0ZXJpYWxfYW1iaWVudF90ZXh0dXJlLHZfdGV4Y29vcmQpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9BTUJJRU5UX1RFWFRVUkVfUExBTkFSXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmFtYmllbnQgKj0gZ2V0UGxhbmFyKHVfbWF0ZXJpYWxfYW1iaWVudF90ZXh0dXJlLCB2X3dvcmxkX3Bvc2l0aW9uLnh5eiwgbWF0ZXJpYWwuYW1iaWVudFNjYWxlLnh5KTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfQU1CSUVOVF9URVhUVVJFX1RSSVBMQU5BUlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5hbWJpZW50ICo9IGdldFRyaVBsYW5hcih1X21hdGVyaWFsX2FtYmllbnRfdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIF9ub3JtYWwsIG1hdGVyaWFsLmFtYmllbnRTY2FsZSk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRfVEVYVFVSRV9TUEhFUkVNQVBcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuYW1iaWVudCAqPSBnZXRTcGhlcmVNYXAodV9tYXRlcmlhbF9hbWJpZW50X3RleHR1cmUsIF9leWVUb1BvaW50LCBfbm9ybWFsLCB1X3ZhbmlzaGluZ19wb2ludCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gZ2V0IERJRkZVU0UgVEVYVFVSRU1BUFxcblwiICtcblwiICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRV9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VfVEVYVFVSRV9VVlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5kaWZmdXNlICo9IHRleHR1cmUyRCh1X21hdGVyaWFsX2RpZmZ1c2VfdGV4dHVyZSx2X3RleGNvb3JkKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRV9URVhUVVJFX1BMQU5BUlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5kaWZmdXNlICo9IGdldFBsYW5hcih1X21hdGVyaWFsX2RpZmZ1c2VfdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIG1hdGVyaWFsLmRpZmZ1c2VTY2FsZS54eSk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VfVEVYVFVSRV9UUklQTEFOQVJcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuZGlmZnVzZSAqPSBnZXRUcmlQbGFuYXIodV9tYXRlcmlhbF9kaWZmdXNlX3RleHR1cmUsIHZfd29ybGRfcG9zaXRpb24ueHl6LCBfbm9ybWFsLCBtYXRlcmlhbC5kaWZmdXNlU2NhbGUpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFX1RFWFRVUkVfU1BIRVJFTUFQXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmRpZmZ1c2UgKj0gZ2V0U3BoZXJlTWFwKHVfbWF0ZXJpYWxfZGlmZnVzZV90ZXh0dXJlLCBfZXllVG9Qb2ludCwgX25vcm1hbCwgdV92YW5pc2hpbmdfcG9pbnQpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIGdldCBTUEVDVUxBUiBURVhUVVJFTUFQXFxuXCIgK1xuXCIgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUl9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSX1RFWFRVUkVfVVZcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuc3BlY3VsYXIgKj0gdGV4dHVyZTJEKHVfbWF0ZXJpYWxfc3BlY3VsYXJfdGV4dHVyZSx2X3RleGNvb3JkKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJfVEVYVFVSRV9QTEFOQVJcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuc3BlY3VsYXIgKj0gZ2V0UGxhbmFyKHVfbWF0ZXJpYWxfc3BlY3VsYXJfdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIG1hdGVyaWFsLnNwZWN1bGFyU2NhbGUueHkpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUl9URVhUVVJFX1RSSVBMQU5BUlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5zcGVjdWxhciAqPSBnZXRUcmlQbGFuYXIodV9tYXRlcmlhbF9zcGVjdWxhcl90ZXh0dXJlLCB2X3dvcmxkX3Bvc2l0aW9uLnh5eiwgX25vcm1hbCwgbWF0ZXJpYWwuc3BlY3VsYXJTY2FsZSk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSX1RFWFRVUkVfU1BIRVJFTUFQXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLnNwZWN1bGFyICo9IGdldFNwaGVyZU1hcCh1X21hdGVyaWFsX3NwZWN1bGFyX3RleHR1cmUsIF9leWVUb1BvaW50LCBfbm9ybWFsLCB1X3ZhbmlzaGluZ19wb2ludCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvcG9pbnRMaWdodCddID1cblwiLypcXG5cIiArXG5cIlxcblwiICtcblwiRXhwZWN0ZWQgZ2xvYmFsczpcXG5cIiArXG5cIm1hdGVyaWFsXFxuXCIgK1xuXCJsaWdodF9hY2N1bXVsYXRvcl8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIiovXFxuXCIgK1xuXCJcXG5cIiArXG5cInN0cnVjdCBQb2ludExpZ2h0IHtcXG5cIiArXG5cIiAgICB2ZWM0IGFtYmllbnQ7XFxuXCIgK1xuXCIgICAgdmVjNCBkaWZmdXNlO1xcblwiICtcblwiICAgIHZlYzQgc3BlY3VsYXI7XFxuXCIgK1xuXCIgICAgdmVjNCBwb3NpdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9FWFBPTkVOVFxcblwiICtcblwiICAgIGZsb2F0IGF0dGVudWF0aW9uRXhwb25lbnQ7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9JTk5FUl9SQURJVVNcXG5cIiArXG5cIiAgICBmbG9hdCBpbm5lclJhZGl1cztcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVU1xcblwiICtcblwiICAgIGZsb2F0IG91dGVyUmFkaXVzO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJ9O1xcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIGNhbGN1bGF0ZUxpZ2h0KGluIFBvaW50TGlnaHQgX2xpZ2h0LCBpbiB2ZWMzIF9leWVUb1BvaW50LCBpbiB2ZWMzIF9ub3JtYWwpIHtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgoX2xpZ2h0LnBvc2l0aW9uLnh5eiAtIF9leWVUb1BvaW50KTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIENvbXB1dGUgdmVjdG9yIGZyb20gc3VyZmFjZSB0byBsaWdodCBwb3NpdGlvblxcblwiICtcblwiICAgIHZlYzMgVlAgPSAoX2xpZ2h0LnBvc2l0aW9uLnh5eiAtIF9leWVUb1BvaW50KSAvIGRpc3Q7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBOb3JtYWxpemUgdGhlIHZlY3RvciBmcm9tIHN1cmZhY2UgdG8gbGlnaHQgcG9zaXRpb25cXG5cIiArXG5cIiAgICBmbG9hdCBuRG90VlAgPSBjbGFtcChkb3QoVlAsIF9ub3JtYWwpLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBBdHRlbnVhdGlvbiBkZWZhdWx0c1xcblwiICtcblwiICAgIGZsb2F0IGF0dGVudWF0aW9uID0gMS4wO1xcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fRVhQT05FTlRcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgUmluID0gMS4wO1xcblwiICtcblwiICAgICAgICBmbG9hdCBlID0gX2xpZ2h0LmF0dGVudWF0aW9uRXhwb25lbnQ7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9JTk5FUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgIFJpbiA9IF9saWdodC5pbm5lclJhZGl1cztcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IFJkaWZmID0gX2xpZ2h0Lm91dGVyUmFkaXVzLVJpbjtcXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IGQgPSBjbGFtcChtYXgoMC4wLGRpc3QtUmluKS9SZGlmZiwgMC4wLCAxLjApO1xcblwiICtcblwiICAgICAgICAgICAgYXR0ZW51YXRpb24gPSAxLjAtKHBvdyhkLGUpKTtcXG5cIiArXG5cIiAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgIC8vIElmIG5vIG91dGVyIGlzIHByb3ZpZGUgYmVoYXZlcyBsaWtlOlxcblwiICtcblwiICAgICAgICAgICAgLy8gaHR0cHM6Ly9pbWRvaW5naXR3cm9uZy53b3JkcHJlc3MuY29tLzIwMTEvMDEvMzEvbGlnaHQtYXR0ZW51YXRpb24vXFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBkID0gbWF4KDAuMCxkaXN0LVJpbikvUmluKzEuMDtcXG5cIiArXG5cIiAgICAgICAgICAgIGF0dGVudWF0aW9uID0gY2xhbXAoMS4wLyhwb3coZCxlKSksIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgUmluID0gMC4wO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICBSaW4gPSBfbGlnaHQuaW5uZXJSYWRpdXM7XFxuXCIgK1xuXCIgICAgICAgICAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVU1xcblwiICtcblwiICAgICAgICAgICAgICAgIGZsb2F0IFJkaWZmID0gX2xpZ2h0Lm91dGVyUmFkaXVzLVJpbjtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBkID0gY2xhbXAobWF4KDAuMCxkaXN0LVJpbikvUmRpZmYsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IDEuMC1kKmQ7XFxuXCIgK1xuXCIgICAgICAgICAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAgICAgICAgIC8vIElmIG5vIG91dGVyIGlzIHByb3ZpZGUgYmVoYXZlcyBsaWtlOlxcblwiICtcblwiICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaW1kb2luZ2l0d3Jvbmcud29yZHByZXNzLmNvbS8yMDExLzAxLzMxL2xpZ2h0LWF0dGVudWF0aW9uL1xcblwiICtcblwiICAgICAgICAgICAgICAgIGZsb2F0IGQgPSBtYXgoMC4wLGRpc3QtUmluKS9SaW4rMS4wO1xcblwiICtcblwiICAgICAgICAgICAgICAgIGF0dGVudWF0aW9uID0gY2xhbXAoMS4wL2QsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBkID0gY2xhbXAoZGlzdC9fbGlnaHQub3V0ZXJSYWRpdXMsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IDEuMC1kKmQ7XFxuXCIgK1xuXCIgICAgICAgICAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAgICAgICAgIGF0dGVudWF0aW9uID0gMS4wO1xcblwiICtcblwiICAgICAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQ29tcHV0ZXIgYWNjdW11bGF0b3JzXFxuXCIgK1xuXCIgICAgbGlnaHRfYWNjdW11bGF0b3JfYW1iaWVudCArPSBfbGlnaHQuYW1iaWVudCAqIGF0dGVudWF0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRVxcblwiICtcblwiICAgICAgICBsaWdodF9hY2N1bXVsYXRvcl9kaWZmdXNlICs9IF9saWdodC5kaWZmdXNlICogbkRvdFZQICogYXR0ZW51YXRpb247XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUlxcblwiICtcblwiICAgICAgICBmbG9hdCBwZiA9IDAuMDsgLy8gcG93ZXIgZmFjdG9yIGZvciBzaGlueSBzcGVjdWxhcnNcXG5cIiArXG5cIiAgICAgICAgaWYgKG5Eb3RWUCA+IDAuMCkge1xcblwiICtcblwiICAgICAgICAgICAgdmVjMyByZWZsZWN0VmVjdG9yID0gcmVmbGVjdCgtVlAsIF9ub3JtYWwpO1xcblwiICtcblwiICAgICAgICAgICAgZmxvYXQgZXllRG90UiA9IG1heCgwLjAsIGRvdCgtbm9ybWFsaXplKF9leWVUb1BvaW50KSwgcmVmbGVjdFZlY3RvcikpO1xcblwiICtcblwiICAgICAgICAgICAgcGYgPSBwb3coZXllRG90UiwgbWF0ZXJpYWwuc2hpbmluZXNzKTtcXG5cIiArXG5cIiAgICAgICAgfVxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIGxpZ2h0X2FjY3VtdWxhdG9yX3NwZWN1bGFyICs9IF9saWdodC5zcGVjdWxhciAqIHBmICogYXR0ZW51YXRpb247XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9zZWxlY3Rpb25fZnJhZ21lbnQnXSA9XG5cIi8vIEZyYWdtZW50IHNoYWRlciBmb3IgZmVhdHVyZSBzZWxlY3Rpb24gcGFzc2VzXFxuXCIgK1xuXCIvLyBSZW5kZXJzIGluIHNpbGhvdWV0dGUgYWNjb3JkaW5nIHRvIHNlbGVjdGlvbiAocGlja2luZykgY29sb3IsIG9yIGJsYWNrIGlmIG5vbmUgZGVmaW5lZFxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9GRUFUVVJFX1NFTEVDVElPTlxcblwiICtcblwiICAgIHZhcnlpbmcgdmVjNCB2X3NlbGVjdGlvbl9jb2xvcjtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIG1haW4gKHZvaWQpIHtcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9GRUFUVVJFX1NFTEVDVElPTlxcblwiICtcblwiICAgICAgICBnbF9GcmFnQ29sb3IgPSB2X3NlbGVjdGlvbl9jb2xvcjtcXG5cIiArXG5cIiAgICAjZWxzZVxcblwiICtcblwiICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuLCAwLiwgMC4sIDEuKTtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3NlbGVjdGlvbl9nbG9iYWxzJ10gPVxuXCIvLyBWZXJ0ZXggYXR0cmlidXRlICsgdmFyeWluZyBmb3IgZmVhdHVyZSBzZWxlY3Rpb25cXG5cIiArXG5cIiNpZiBkZWZpbmVkKFRBTkdSQU1fRkVBVFVSRV9TRUxFQ1RJT04pICYmIGRlZmluZWQoVEFOR1JBTV9WRVJURVhfU0hBREVSKVxcblwiICtcblwiICAgIGF0dHJpYnV0ZSB2ZWM0IGFfc2VsZWN0aW9uX2NvbG9yO1xcblwiICtcblwiICAgIHZhcnlpbmcgdmVjNCB2X3NlbGVjdGlvbl9jb2xvcjtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvc2VsZWN0aW9uX3ZlcnRleCddID1cblwiLy8gU2VsZWN0aW9uIHBhc3Mtc3BlY2lmaWMgcmVuZGVyaW5nXFxuXCIgK1xuXCIjaWYgZGVmaW5lZChUQU5HUkFNX0ZFQVRVUkVfU0VMRUNUSU9OKSAmJiBkZWZpbmVkKFRBTkdSQU1fVkVSVEVYX1NIQURFUilcXG5cIiArXG5cIiAgICBpZiAoYV9zZWxlY3Rpb25fY29sb3IucmdiID09IHZlYzMoMC4pKSB7XFxuXCIgK1xuXCIgICAgICAgIC8vIERpc2NhcmQgYnkgZm9yY2luZyBpbnZhbGlkIHRyaWFuZ2xlIGlmIHdlXFwncmUgaW4gdGhlIGZlYXR1cmVcXG5cIiArXG5cIiAgICAgICAgLy8gc2VsZWN0aW9uIHBhc3MgYnV0IGhhdmUgbm8gc2VsZWN0aW9uIGluZm9cXG5cIiArXG5cIiAgICAgICAgLy8gVE9ETzogaW4gc29tZSBjYXNlcyB3ZSBtYXkgYWN0dWFsbHkgd2FudCBub24tc2VsZWN0YWJsZSBmZWF0dXJlcyB0byBvY2NsdWRlIHNlbGVjdGFibGUgb25lcz9cXG5cIiArXG5cIiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KDAuLCAwLiwgMC4sIDEuKTtcXG5cIiArXG5cIiAgICAgICAgcmV0dXJuO1xcblwiICtcblwiICAgIH1cXG5cIiArXG5cIiAgICB2X3NlbGVjdGlvbl9jb2xvciA9IGFfc2VsZWN0aW9uX2NvbG9yO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9zcGhlcmljYWxfZW52aXJvbm1lbnRfbWFwJ10gPVxuXCIvLyBTcGhlcmljYWwgZW52aXJvbm1lbnQgbWFwXFxuXCIgK1xuXCIvLyBCYXNlZCBvbjogaHR0cDovL3d3dy5jbGlja3RvcmVsZWFzZS5jb20vYmxvZy9jcmVhdGluZy1zcGhlcmljYWwtZW52aXJvbm1lbnQtbWFwcGluZy1zaGFkZXJcXG5cIiArXG5cIlxcblwiICtcblwiLy8gdmlldzogbG9jYXRpb24gb2YgY2FtZXJhXFxuXCIgK1xuXCIvLyBwb3NpdGlvbjogbG9jYXRpb24gb2YgY3VycmVudCBwb2ludCBvbiBzdXJmYWNlXFxuXCIgK1xuXCIvLyBub3JtYWw6IG5vcm1hbCBvZiBjdXJyZW50IHBvaW50IG9uIHN1cmZhY2VcXG5cIiArXG5cIi8vIHNrZXc6IHNrZXdpbmcgZmFjdG9yICh1c2VkIHRvIGNvbXBlbnNhdGUgZm9yIGFsdGVyZWQgdmFuaXNoaW5nIHBvaW50KVxcblwiICtcblwiLy8gZW52bWFwOiBzcGhlcmljYWwgZW52aXJvbm1lbnQgbWFwIHRleHR1cmVcXG5cIiArXG5cIlxcblwiICtcblwidmVjNCBzcGhlcmljYWxFbnZpcm9ubWVudE1hcCh2ZWMzIHZpZXcsIHZlYzMgcG9zaXRpb24sIHZlYzMgbm9ybWFsLCB2ZWMyIHNrZXcsIHNhbXBsZXIyRCBlbnZtYXApIHtcXG5cIiArXG5cIiAgICAvLyBOb3JtYWxpemVkIHZlY3RvciBmcm9tIGNhbWVyYSB0byBzdXJmYWNlXFxuXCIgK1xuXCIgICAgdmVjMyBleWUgPSBub3JtYWxpemUocG9zaXRpb24ueHl6IC0gdmlldy54eXopO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gU2tld1xcblwiICtcblwiICAgIGV5ZS54eSAtPSBza2V3O1xcblwiICtcblwiICAgIGV5ZSA9IG5vcm1hbGl6ZShleWUpO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gUmVmbGVjdGlvbiBvZiBleWUgb2ZmIG9mIHN1cmZhY2Ugbm9ybWFsXFxuXCIgK1xuXCIgICAgdmVjMyByID0gcmVmbGVjdChleWUsIG5vcm1hbCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBNYXAgcmVmbGVjdGVkIHZlY3RvciBvbnRvIHRoZSBzdXJmYWNlIG9mIGEgc3BoZXJlXFxuXCIgK1xuXCIgICAgci56ICs9IDEuO1xcblwiICtcblwiICAgIGZsb2F0IG0gPSAyLiAqIGxlbmd0aChyKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIEFkanVzdCB4eSB0byBhY2NvdW50IGZvciBzcGhlcmljYWwgc2hhcGUsIGFuZCBjZW50ZXIgaW4gbWlkZGxlIG9mIHRleHR1cmVcXG5cIiArXG5cIiAgICB2ZWMyIHV2ID0gci54eSAvIG0gKyAuNTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFNhbXBsZSB0aGUgZW52aXJvbm1lbnQgbWFwXFxuXCIgK1xuXCIgICAgcmV0dXJuIHRleHR1cmUyRChlbnZtYXAsIHV2KTtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3Nwb3RMaWdodCddID1cblwiLypcXG5cIiArXG5cIlxcblwiICtcblwiRXhwZWN0ZWQgZ2xvYmFsczpcXG5cIiArXG5cIm1hdGVyaWFsXFxuXCIgK1xuXCJsaWdodF9hY2N1bXVsYXRvcl8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIiovXFxuXCIgK1xuXCJcXG5cIiArXG5cInN0cnVjdCBTcG90TGlnaHQge1xcblwiICtcblwiICAgIHZlYzQgYW1iaWVudDtcXG5cIiArXG5cIiAgICB2ZWM0IGRpZmZ1c2U7XFxuXCIgK1xuXCIgICAgdmVjNCBzcGVjdWxhcjtcXG5cIiArXG5cIiAgICB2ZWM0IHBvc2l0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0VYUE9ORU5UXFxuXCIgK1xuXCIgICAgZmxvYXQgYXR0ZW51YXRpb25FeHBvbmVudDtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0lOTkVSX1JBRElVU1xcblwiICtcblwiICAgIGZsb2F0IGlubmVyUmFkaXVzO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fT1VURVJfUkFESVVTXFxuXCIgK1xuXCIgICAgZmxvYXQgb3V0ZXJSYWRpdXM7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIHZlYzMgZGlyZWN0aW9uO1xcblwiICtcblwiICAgIGZsb2F0IHNwb3RDb3NDdXRvZmY7XFxuXCIgK1xuXCIgICAgZmxvYXQgc3BvdEV4cG9uZW50O1xcblwiICtcblwifTtcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBjYWxjdWxhdGVMaWdodChpbiBTcG90TGlnaHQgX2xpZ2h0LCBpbiB2ZWMzIF9leWVUb1BvaW50LCBpbiB2ZWMzIF9ub3JtYWwpIHtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgoX2xpZ2h0LnBvc2l0aW9uLnh5eiAtIF9leWVUb1BvaW50KTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIENvbXB1dGUgdmVjdG9yIGZyb20gc3VyZmFjZSB0byBsaWdodCBwb3NpdGlvblxcblwiICtcblwiICAgIHZlYzMgVlAgPSAoX2xpZ2h0LnBvc2l0aW9uLnh5eiAtIF9leWVUb1BvaW50KSAvIGRpc3Q7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBub3JtYWwgLiBsaWdodCBkaXJlY3Rpb25cXG5cIiArXG5cIiAgICBmbG9hdCBuRG90VlAgPSBjbGFtcChkb3QoX25vcm1hbCwgVlApLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBBdHRlbnVhdGlvbiBkZWZhdWx0c1xcblwiICtcblwiICAgIGZsb2F0IGF0dGVudWF0aW9uID0gMS4wO1xcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fRVhQT05FTlRcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgUmluID0gMS4wO1xcblwiICtcblwiICAgICAgICBmbG9hdCBlID0gX2xpZ2h0LmF0dGVudWF0aW9uRXhwb25lbnQ7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9JTk5FUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgIFJpbiA9IF9saWdodC5pbm5lclJhZGl1cztcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IFJkaWZmID0gX2xpZ2h0Lm91dGVyUmFkaXVzLVJpbjtcXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IGQgPSBjbGFtcChtYXgoMC4wLGRpc3QtUmluKS9SZGlmZiwgMC4wLCAxLjApO1xcblwiICtcblwiICAgICAgICAgICAgYXR0ZW51YXRpb24gPSAxLjAtKHBvdyhkLGUpKTtcXG5cIiArXG5cIiAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgIC8vIElmIG5vIG91dGVyIGlzIHByb3ZpZGUgYmVoYXZlcyBsaWtlOlxcblwiICtcblwiICAgICAgICAgICAgLy8gaHR0cHM6Ly9pbWRvaW5naXR3cm9uZy53b3JkcHJlc3MuY29tLzIwMTEvMDEvMzEvbGlnaHQtYXR0ZW51YXRpb24vXFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBkID0gbWF4KDAuMCxkaXN0LVJpbikvUmluKzEuMDtcXG5cIiArXG5cIiAgICAgICAgICAgIGF0dGVudWF0aW9uID0gY2xhbXAoMS4wLyhwb3coZCxlKSksIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgUmluID0gMC4wO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICBSaW4gPSBfbGlnaHQuaW5uZXJSYWRpdXM7XFxuXCIgK1xuXCIgICAgICAgICAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVU1xcblwiICtcblwiICAgICAgICAgICAgICAgIGZsb2F0IFJkaWZmID0gX2xpZ2h0Lm91dGVyUmFkaXVzLVJpbjtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBkID0gY2xhbXAobWF4KDAuMCxkaXN0LVJpbikvUmRpZmYsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IDEuMC1kKmQ7XFxuXCIgK1xuXCIgICAgICAgICAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAgICAgICAgIC8vIElmIG5vIG91dGVyIGlzIHByb3ZpZGUgYmVoYXZlcyBsaWtlOlxcblwiICtcblwiICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaW1kb2luZ2l0d3Jvbmcud29yZHByZXNzLmNvbS8yMDExLzAxLzMxL2xpZ2h0LWF0dGVudWF0aW9uL1xcblwiICtcblwiICAgICAgICAgICAgICAgIGZsb2F0IGQgPSBtYXgoMC4wLGRpc3QtUmluKS9SaW4rMS4wO1xcblwiICtcblwiICAgICAgICAgICAgICAgIGF0dGVudWF0aW9uID0gY2xhbXAoMS4wL2QsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBkID0gY2xhbXAoZGlzdC9fbGlnaHQub3V0ZXJSYWRpdXMsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IDEuMC1kKmQ7XFxuXCIgK1xuXCIgICAgICAgICAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAgICAgICAgIGF0dGVudWF0aW9uID0gMS4wO1xcblwiICtcblwiICAgICAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gc3BvdGxpZ2h0IGF0dGVudWF0aW9uIGZhY3RvclxcblwiICtcblwiICAgIGZsb2F0IHNwb3RBdHRlbnVhdGlvbiA9IDAuMDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFNlZSBpZiBwb2ludCBvbiBzdXJmYWNlIGlzIGluc2lkZSBjb25lIG9mIGlsbHVtaW5hdGlvblxcblwiICtcblwiICAgIGZsb2F0IHNwb3REb3QgPSBjbGFtcChkb3QoLVZQLCBub3JtYWxpemUoX2xpZ2h0LmRpcmVjdGlvbikpLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBpZiAoc3BvdERvdCA+PSBfbGlnaHQuc3BvdENvc0N1dG9mZikge1xcblwiICtcblwiICAgICAgICBzcG90QXR0ZW51YXRpb24gPSBwb3coc3BvdERvdCwgX2xpZ2h0LnNwb3RFeHBvbmVudCk7XFxuXCIgK1xuXCIgICAgfVxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgbGlnaHRfYWNjdW11bGF0b3JfYW1iaWVudCArPSBfbGlnaHQuYW1iaWVudCAqIGF0dGVudWF0aW9uICogc3BvdEF0dGVudWF0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRVxcblwiICtcblwiICAgICAgICBsaWdodF9hY2N1bXVsYXRvcl9kaWZmdXNlICs9IF9saWdodC5kaWZmdXNlICogbkRvdFZQICogYXR0ZW51YXRpb24gKiBzcG90QXR0ZW51YXRpb247XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUlxcblwiICtcblwiICAgICAgICAvLyBQb3dlciBmYWN0b3IgZm9yIHNoaW55IHNwZWN1bGFyc1xcblwiICtcblwiICAgICAgICBmbG9hdCBwZiA9IDAuMDtcXG5cIiArXG5cIiAgICAgICAgaWYgKG5Eb3RWUCA+IDAuMCkge1xcblwiICtcblwiICAgICAgICAgICAgdmVjMyByZWZsZWN0VmVjdG9yID0gcmVmbGVjdCgtVlAsIF9ub3JtYWwpO1xcblwiICtcblwiICAgICAgICAgICAgZmxvYXQgZXllRG90UiA9IG1heChkb3QoLW5vcm1hbGl6ZShfZXllVG9Qb2ludCksIHJlZmxlY3RWZWN0b3IpLCAwLjApO1xcblwiICtcblwiICAgICAgICAgICAgcGYgPSBwb3coZXllRG90UiwgbWF0ZXJpYWwuc2hpbmluZXNzKTtcXG5cIiArXG5cIiAgICAgICAgfVxcblwiICtcblwiICAgICAgICBsaWdodF9hY2N1bXVsYXRvcl9zcGVjdWxhciArPSBfbGlnaHQuc3BlY3VsYXIgKiBwZiAqIGF0dGVudWF0aW9uICogc3BvdEF0dGVudWF0aW9uO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvdW5wYWNrJ10gPVxuXCJcXG5cIiArXG5cIi8vIFVucGFjayBub3JtYWxpemVkIHNob3J0cyBiYWNrIHRvIHRoZWlyIG9yaWdpbmFsIGludGVnZXIgdmFsdWVzXFxuXCIgK1xuXCIjZGVmaW5lIFNIT1JUKHgpICh4ICogMzI3NjcuKVxcblwiICtcblwiI2RlZmluZSBVTlNJR05FRF9TSE9SVCh4KSAoeCAqIDY1NTM1LilcXG5cIiArXG5cIlxcblwiICtcblwiLy8gVXNlZCBmb3IgY2FzZXMgd2hlcmUgYW4gYXR0cmlidXRlIGlzIHN0b3JlZCBhcyBhIG5vcm1hbGl6ZWQgaW50IHR5cGUsXFxuXCIgK1xuXCIvLyBidXQgaXMgYSBmbG9hdGluZyBwb2ludCB2YWx1ZSB0aGF0IG5lZWRzIGEgcmFuZ2UgZ3JlYXRlciB0aGFuIFswLCAxXSBvciBbLTEsIDFdLlxcblwiICtcblwiLy8gVGhlIGludGVnZXIgdmFsdWUgaXMgXFxcInNjYWxlZFxcXCIgdG8gYW4gOC44IGZpeGVkIHBvaW50IHN0eWxlIGludGVnZXIgYmVmb3JlIGl0IGlzXFxuXCIgK1xuXCIvLyBub3JtYWxpemVkIGluIHRoZSBWQk8uIFVzZWQgZm9yIGNhc2VzIHdoZXJlIGxvdyBwcmVjaXNpb24gaXMgc3VpdGFibGUgZm9yIGJvdGhcXG5cIiArXG5cIi8vIHRoZSBpbnRlZ2VyIGFuZCBmcmFjdGlvbmFsIHBvcnRpb25zIG9mIHRoZSBudW1iZXIuXFxuXCIgK1xuXCIvLyBFeGFtcGxlcyBhcmUgZXh0cnVzaW9uIHZlY3RvcnMgZm9yIGR5bmFtaWMgbGluZXMsIGFuZCBzY3JlZW4tc3BhY2Ugc2l6ZSBmb3IgcG9pbnQgc3ByaXRlcy5cXG5cIiArXG5cIiNkZWZpbmUgU0NBTEVfOCh4KSAoeCAqIDI1Ni4pXFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snc3R5bGVzL3BvaW50cy9wb2ludHNfZnJhZ21lbnQnXSA9XG5cInVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfdGltZTtcXG5cIiArXG5cInVuaWZvcm0gdmVjMyB1X21hcF9wb3NpdGlvbjtcXG5cIiArXG5cInVuaWZvcm0gdmVjMyB1X3RpbGVfb3JpZ2luO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X21ldGVyc19wZXJfcGl4ZWw7XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfZGV2aWNlX3BpeGVsX3JhdGlvO1xcblwiICtcblwiXFxuXCIgK1xuXCJ1bmlmb3JtIG1hdDMgdV9ub3JtYWxNYXRyaXg7XFxuXCIgK1xuXCJ1bmlmb3JtIG1hdDMgdV9pbnZlcnNlTm9ybWFsTWF0cml4O1xcblwiICtcblwiXFxuXCIgK1xuXCJ1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXCIgK1xuXCJcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblwiICtcblwidmFyeWluZyB2ZWMyIHZfdGV4Y29vcmQ7XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzQgdl93b3JsZF9wb3NpdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiI2RlZmluZSBUQU5HUkFNX05PUk1BTCB2ZWMzKDAuLCAwLiwgMS4pXFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vIEFscGhhIGRpc2NhcmQgdGhyZXNob2xkIChzdWJzdGl0dXRlIGZvciBhbHBoYSBibGVuZGluZylcXG5cIiArXG5cIiNpZm5kZWYgVEFOR1JBTV9BTFBIQV9ESVNDQVJEXFxuXCIgK1xuXCIjZGVmaW5lIFRBTkdSQU1fQUxQSEFfRElTQ0FSRCAwLjVcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIvLyBBbHBoYSBmYWRlIHJhbmdlIGZvciBlZGdlcyBvZiBwb2ludHNcXG5cIiArXG5cIiNpZm5kZWYgVEFOR1JBTV9GQURFX1JBTkdFXFxuXCIgK1xuXCIjZGVmaW5lIFRBTkdSQU1fRkFERV9SQU5HRSAuMTVcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiI2RlZmluZSBUQU5HUkFNX0ZBREVfU1RBUlQgKDEuIC0gVEFOR1JBTV9GQURFX1JBTkdFKVxcblwiICtcblwiXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGNhbWVyYVxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBtYXRlcmlhbFxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBsaWdodGluZ1xcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBnbG9iYWxcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBtYWluICh2b2lkKSB7XFxuXCIgK1xuXCIgICAgLy8gSW5pdGlhbGl6ZSBnbG9iYWxzXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBzZXR1cFxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgdmVjNCBjb2xvciA9IHZfY29sb3I7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBBcHBseSBhIHRleHR1cmVcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVF9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgIGNvbG9yICo9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfdGV4Y29vcmQpO1xcblwiICtcblwiICAgIC8vIERyYXcgYSBwb2ludFxcblwiICtcblwiICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgIC8vIEZhZGUgYWxwaGEgbmVhciBjaXJjbGUgZWRnZVxcblwiICtcblwiICAgICAgICB2ZWMyIHV2ID0gdl90ZXhjb29yZCAqIDIuIC0gMS47XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IHBvaW50X2Rpc3QgPSBsZW5ndGgodXYpO1xcblwiICtcblwiICAgICAgICBjb2xvci5hID0gY2xhbXAoMS4gLSAoc21vb3Roc3RlcCgwLiwgVEFOR1JBTV9GQURFX1JBTkdFLCAocG9pbnRfZGlzdCAtIFRBTkdSQU1fRkFERV9TVEFSVCkpIC8gVEFOR1JBTV9GQURFX1JBTkdFKSwgMC4sIDEuKTtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIElmIGJsZW5kaW5nIGlzIG9mZiwgdXNlIGFscGhhIGRpc2NhcmQgYXMgYSBsb3dlci1xdWFsaXR5IHN1YnN0aXR1dGVcXG5cIiArXG5cIiAgICAjaWYgIWRlZmluZWQoVEFOR1JBTV9CTEVORF9PVkVSTEFZKSAmJiAhZGVmaW5lZChUQU5HUkFNX0JMRU5EX0lOTEFZKVxcblwiICtcblwiICAgICAgICBpZiAoY29sb3IuYSA8IFRBTkdSQU1fQUxQSEFfRElTQ0FSRCkge1xcblwiICtcblwiICAgICAgICAgICAgZGlzY2FyZDtcXG5cIiArXG5cIiAgICAgICAgfVxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gTWFudWFsbHkgdW4tbXVsdGlwbHkgYWxwaGEsIGZvciBjYXNlcyB3aGVyZSB0ZXh0dXJlIGhhcyBwcmUtbXVsdGlwbGllZCBhbHBoYVxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX1VOTVVMVElQTFlfQUxQSEFcXG5cIiArXG5cIiAgICAgICAgY29sb3IucmdiIC89IG1heChjb2xvci5hLCAwLjAwMSk7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IGNvbG9yXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBmaWx0ZXJcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ3N0eWxlcy9wb2ludHMvcG9pbnRzX3ZlcnRleCddID1cblwidW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV90aW1lO1xcblwiICtcblwidW5pZm9ybSB2ZWMzIHVfbWFwX3Bvc2l0aW9uO1xcblwiICtcblwidW5pZm9ybSB2ZWMzIHVfdGlsZV9vcmlnaW47XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfbWV0ZXJzX3Blcl9waXhlbDtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87XFxuXCIgK1xuXCJcXG5cIiArXG5cInVuaWZvcm0gbWF0NCB1X21vZGVsO1xcblwiICtcblwidW5pZm9ybSBtYXQ0IHVfbW9kZWxWaWV3O1xcblwiICtcblwidW5pZm9ybSBtYXQzIHVfbm9ybWFsTWF0cml4O1xcblwiICtcblwidW5pZm9ybSBtYXQzIHVfaW52ZXJzZU5vcm1hbE1hdHJpeDtcXG5cIiArXG5cIlxcblwiICtcblwiYXR0cmlidXRlIHZlYzQgYV9wb3NpdGlvbjtcXG5cIiArXG5cImF0dHJpYnV0ZSB2ZWM0IGFfc2hhcGU7XFxuXCIgK1xuXCJhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcblwiICtcblwiYXR0cmlidXRlIHZlYzIgYV90ZXhjb29yZDtcXG5cIiArXG5cImF0dHJpYnV0ZSB2ZWMyIGFfb2Zmc2V0O1xcblwiICtcblwiXFxuXCIgK1xuXCIjZGVmaW5lIFRBTkdSQU1fTk9STUFMIHZlYzMoMC4sIDAuLCAxLilcXG5cIiArXG5cIlxcblwiICtcblwidmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzIgdl90ZXhjb29yZDtcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X3dvcmxkX3Bvc2l0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGNhbWVyYVxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBtYXRlcmlhbFxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBsaWdodGluZ1xcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBnbG9iYWxcXG5cIiArXG5cIlxcblwiICtcblwidmVjMiByb3RhdGUyRCh2ZWMyIF9zdCwgZmxvYXQgX2FuZ2xlKSB7XFxuXCIgK1xuXCIgICAgcmV0dXJuIG1hdDIoY29zKF9hbmdsZSksLXNpbihfYW5nbGUpLFxcblwiICtcblwiICAgICAgICAgICAgICAgIHNpbihfYW5nbGUpLGNvcyhfYW5nbGUpKSAqIF9zdDtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBtYWluKCkge1xcblwiICtcblwiICAgIC8vIEluaXRpYWxpemUgZ2xvYmFsc1xcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogc2V0dXBcXG5cIiArXG5cIlxcblwiICtcblwiICAgIHZfY29sb3IgPSBhX2NvbG9yO1xcblwiICtcblwiICAgIHZfdGV4Y29vcmQgPSBhX3RleGNvb3JkO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gUG9zaXRpb25cXG5cIiArXG5cIiAgICB2ZWM0IHBvc2l0aW9uID0gdV9tb2RlbFZpZXcgKiB2ZWM0KFNIT1JUKGFfcG9zaXRpb24ueHl6KSwgMS4pO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQXBwbHkgcG9zaXRpb25pbmcgYW5kIHNjYWxpbmcgaW4gc2NyZWVuIHNwYWNlXFxuXCIgK1xuXCIgICAgZmxvYXQgenNjYWxlID0gZnJhY3QodV9tYXBfcG9zaXRpb24ueikgKiAoU0NBTEVfOChhX3NoYXBlLncpIC0gMS4pICsgMS47XFxuXCIgK1xuXCIgICAgLy8gZmxvYXQgenNjYWxlID0gbG9nKGZyYWN0KHVfbWFwX3Bvc2l0aW9uLnopICsgMS4pIC8gbG9nKDIuKSAqIChhX3NoYXBlLncgLSAxLikgKyAxLjtcXG5cIiArXG5cIiAgICB2ZWMyIHNoYXBlID0gU0NBTEVfOChhX3NoYXBlLnh5KSAqIHpzY2FsZTsgICAgIC8vXFxuXCIgK1xuXCIgICAgdmVjMiBvZmZzZXQgPSB2ZWMyKGFfb2Zmc2V0LngsIC1hX29mZnNldC55KTsgLy8gZmxpcCB5IHRvIG1ha2UgaXQgcG9pbnQgZG93blxcblwiICtcblwiICAgIGZsb2F0IHRoZXRhID0gcmFkaWFucyhhX3NoYXBlLnogKiAzNjAuKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIHNoYXBlID0gcm90YXRlMkQoc2hhcGUsIHRoZXRhKTsgICAgICAgICAgICAgLy8gYXBwbHkgcm90YXRpb24gdG8gdmVydGV4XFxuXCIgK1xuXCIgICAgc2hhcGUgKz0gcm90YXRlMkQoU0hPUlQob2Zmc2V0KSwgdGhldGEpOyAgLy8gYXBwbHkgb2Zmc2V0IG9uIHJvdGF0ZWQgYXhpcyAoZS5nLiBzbyBsaW5lIGxhYmVscyBmb2xsb3cgdGV4dCBheGlzKVxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gV29ybGQgY29vcmRpbmF0ZXMgZm9yIDNkIHByb2NlZHVyYWwgdGV4dHVyZXNcXG5cIiArXG5cIiAgICB2X3dvcmxkX3Bvc2l0aW9uID0gdV9tb2RlbCAqIHBvc2l0aW9uO1xcblwiICtcblwiICAgIHZfd29ybGRfcG9zaXRpb24ueHkgKz0gc2hhcGUgKiB1X21ldGVyc19wZXJfcGl4ZWw7XFxuXCIgK1xuXCIgICAgdl93b3JsZF9wb3NpdGlvbiA9IHdyYXBXb3JsZFBvc2l0aW9uKHZfd29ybGRfcG9zaXRpb24pO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gTW9kaWZ5IHBvc2l0aW9uIGJlZm9yZSBjYW1lcmEgcHJvamVjdGlvblxcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogcG9zaXRpb25cXG5cIiArXG5cIlxcblwiICtcblwiICAgIGNhbWVyYVByb2plY3Rpb24ocG9zaXRpb24pO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTEFZRVJfT1JERVJcXG5cIiArXG5cIiAgICAgICAgYXBwbHlMYXllck9yZGVyKFNIT1JUKGFfcG9zaXRpb24udyksIHBvc2l0aW9uKTtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIEFwcGx5IHBpeGVsIG9mZnNldCBpbiBzY3JlZW4tc3BhY2VcXG5cIiArXG5cIiAgICAvLyBNdWx0aXBseSBieSAyIGlzIGJlY2F1c2Ugc2NyZWVuIGlzIDIgdW5pdHMgd2lkZSBOb3JtYWxpemVkIERldmljZSBDb29yZHMgKGFuZCB1X3Jlc29sdXRpb24gZGV2aWNlIHBpeGVscyB3aWRlKVxcblwiICtcblwiICAgIC8vIERldmljZSBwaXhlbCByYXRpbyBhZGp1c3RtZW50IGlzIGJlY2F1c2Ugc2hhcGUgaXMgaW4gbG9naWNhbCBwaXhlbHNcXG5cIiArXG5cIiAgICBwb3NpdGlvbi54eSArPSBzaGFwZSAqIHBvc2l0aW9uLncgKiAyLiAqIHVfZGV2aWNlX3BpeGVsX3JhdGlvIC8gdV9yZXNvbHV0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgZ2xfUG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydzdHlsZXMvcG9seWdvbnMvcG9seWdvbnNfZnJhZ21lbnQnXSA9XG5cInVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfdGltZTtcXG5cIiArXG5cInVuaWZvcm0gdmVjMyB1X21hcF9wb3NpdGlvbjtcXG5cIiArXG5cInVuaWZvcm0gdmVjMyB1X3RpbGVfb3JpZ2luO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X21ldGVyc19wZXJfcGl4ZWw7XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfZGV2aWNlX3BpeGVsX3JhdGlvO1xcblwiICtcblwiXFxuXCIgK1xuXCJ1bmlmb3JtIG1hdDMgdV9ub3JtYWxNYXRyaXg7XFxuXCIgK1xuXCJ1bmlmb3JtIG1hdDMgdV9pbnZlcnNlTm9ybWFsTWF0cml4O1xcblwiICtcblwiXFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzQgdl9wb3NpdGlvbjtcXG5cIiArXG5cInZhcnlpbmcgdmVjMyB2X25vcm1hbDtcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblwiICtcblwidmFyeWluZyB2ZWM0IHZfd29ybGRfcG9zaXRpb247XFxuXCIgK1xuXCJcXG5cIiArXG5cIiNkZWZpbmUgVEFOR1JBTV9OT1JNQUwgdl9ub3JtYWxcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fVEVYVFVSRV9DT09SRFNcXG5cIiArXG5cIiAgICB2YXJ5aW5nIHZlYzIgdl90ZXhjb29yZDtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWYgZGVmaW5lZChUQU5HUkFNX0xJR0hUSU5HX1ZFUlRFWClcXG5cIiArXG5cIiAgICB2YXJ5aW5nIHZlYzQgdl9saWdodGluZztcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGNhbWVyYVxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBtYXRlcmlhbFxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBsaWdodGluZ1xcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBnbG9iYWxcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBtYWluICh2b2lkKSB7XFxuXCIgK1xuXCIgICAgLy8gSW5pdGlhbGl6ZSBnbG9iYWxzXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBzZXR1cFxcblwiICtcblwiICAgIFxcblwiICtcblwiICAgIHZlYzQgY29sb3IgPSB2X2NvbG9yO1xcblwiICtcblwiICAgIHZlYzMgbm9ybWFsID0gVEFOR1JBTV9OT1JNQUw7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9OT1JNQUxfVEVYVFVSRVxcblwiICtcblwiICAgICAgICBjYWxjdWxhdGVOb3JtYWwobm9ybWFsKTtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIE1vZGlmeSBub3JtYWwgYmVmb3JlIGxpZ2h0aW5nXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBub3JtYWxcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIE1vZGlmeSBjb2xvciBhbmQgbWF0ZXJpYWwgcHJvcGVydGllcyBiZWZvcmUgbGlnaHRpbmdcXG5cIiArXG5cIiAgICAjaWYgIWRlZmluZWQoVEFOR1JBTV9MSUdIVElOR19WRVJURVgpXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBjb2xvclxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmIGRlZmluZWQoVEFOR1JBTV9MSUdIVElOR19GUkFHTUVOVClcXG5cIiArXG5cIiAgICAgICAgY29sb3IgPSBjYWxjdWxhdGVMaWdodGluZyh2X3Bvc2l0aW9uLnh5eiAtIHVfZXllLCBub3JtYWwsIGNvbG9yKTtcXG5cIiArXG5cIiAgICAjZWxpZiBkZWZpbmVkKFRBTkdSQU1fTElHSFRJTkdfVkVSVEVYKVxcblwiICtcblwiICAgICAgICBjb2xvciA9IHZfbGlnaHRpbmc7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBNb2RpZnkgY29sb3IgYWZ0ZXIgbGlnaHRpbmcgKGZpbHRlci1saWtlIGVmZmVjdHMgdGhhdCBkb25cXCd0IHJlcXVpcmUgYSBhZGRpdGlvbmFsIHJlbmRlciBwYXNzZXMpXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBmaWx0ZXJcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29uc192ZXJ0ZXgnXSA9XG5cInVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfdGltZTtcXG5cIiArXG5cInVuaWZvcm0gdmVjMyB1X21hcF9wb3NpdGlvbjtcXG5cIiArXG5cInVuaWZvcm0gdmVjMyB1X3RpbGVfb3JpZ2luO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X21ldGVyc19wZXJfcGl4ZWw7XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfZGV2aWNlX3BpeGVsX3JhdGlvO1xcblwiICtcblwiXFxuXCIgK1xuXCJ1bmlmb3JtIG1hdDQgdV9tb2RlbDtcXG5cIiArXG5cInVuaWZvcm0gbWF0NCB1X21vZGVsVmlldztcXG5cIiArXG5cInVuaWZvcm0gbWF0MyB1X25vcm1hbE1hdHJpeDtcXG5cIiArXG5cInVuaWZvcm0gbWF0MyB1X2ludmVyc2VOb3JtYWxNYXRyaXg7XFxuXCIgK1xuXCJcXG5cIiArXG5cImF0dHJpYnV0ZSB2ZWM0IGFfcG9zaXRpb247XFxuXCIgK1xuXCJhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcblwiICtcblwiXFxuXCIgK1xuXCIvLyBPcHRpb25hbCBub3JtYWwgYXR0cmlidXRlLCBvdGhlcndpc2UgZGVmYXVsdCB0byB1cFxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTk9STUFMX0FUVFJJQlVURVxcblwiICtcblwiICAgIGF0dHJpYnV0ZSB2ZWMzIGFfbm9ybWFsO1xcblwiICtcblwiICAgICNkZWZpbmUgVEFOR1JBTV9OT1JNQUwgYV9ub3JtYWxcXG5cIiArXG5cIiNlbHNlXFxuXCIgK1xuXCIgICAgI2RlZmluZSBUQU5HUkFNX05PUk1BTCB2ZWMzKDAuLCAwLiwgMS4pXFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiLy8gT3B0aW9uYWwgZHluYW1pYyBsaW5lIGV4dHJ1c2lvblxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fRVhUUlVERV9MSU5FU1xcblwiICtcblwiICAgIC8vIHh5OiBleHRydXNpb24gZGlyZWN0aW9uIGluIHh5IHBsYW5lXFxuXCIgK1xuXCIgICAgLy8gejogIGhhbGYtd2lkdGggb2YgbGluZSAoYW1vdW50IHRvIGV4dHJ1ZGUpXFxuXCIgK1xuXCIgICAgLy8gdzogIHNjYWxpbmcgZmFjdG9yIGZvciBpbnRlcnBvbGF0aW5nIHdpZHRoIGJldHdlZW4gem9vbXNcXG5cIiArXG5cIiAgICBhdHRyaWJ1dGUgdmVjNCBhX2V4dHJ1ZGU7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwidmFyeWluZyB2ZWM0IHZfcG9zaXRpb247XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzMgdl9ub3JtYWw7XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X3dvcmxkX3Bvc2l0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIvLyBPcHRpb25hbCB0ZXh0dXJlIFVWc1xcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fVEVYVFVSRV9DT09SRFNcXG5cIiArXG5cIiAgICBhdHRyaWJ1dGUgdmVjMiBhX3RleGNvb3JkO1xcblwiICtcblwiICAgIHZhcnlpbmcgdmVjMiB2X3RleGNvb3JkO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZiBkZWZpbmVkKFRBTkdSQU1fTElHSFRJTkdfVkVSVEVYKVxcblwiICtcblwiICAgIHZhcnlpbmcgdmVjNCB2X2xpZ2h0aW5nO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogY2FtZXJhXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IG1hdGVyaWFsXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGxpZ2h0aW5nXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGdsb2JhbFxcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIG1haW4oKSB7XFxuXCIgK1xuXCIgICAgLy8gSW5pdGlhbGl6ZSBnbG9iYWxzXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBzZXR1cFxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gVGV4dHVyZSBVVnNcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9URVhUVVJFX0NPT1JEU1xcblwiICtcblwiICAgICAgICB2X3RleGNvb3JkID0gYV90ZXhjb29yZDtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFBvc2l0aW9uXFxuXCIgK1xuXCIgICAgdmVjNCBwb3NpdGlvbiA9IHZlYzQoU0hPUlQoYV9wb3NpdGlvbi54eXopLCAxLik7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9FWFRSVURFX0xJTkVTXFxuXCIgK1xuXCIgICAgICAgIHZlYzIgZXh0cnVkZSA9IFNDQUxFXzgoYV9leHRydWRlLnh5KTtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgd2lkdGggPSBTSE9SVChhX2V4dHJ1ZGUueik7XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IGR3ZHogPSBTSE9SVChhX2V4dHJ1ZGUudyk7XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IGR6ID0gY2xhbXAodV9tYXBfcG9zaXRpb24ueiAtIGFicyh1X3RpbGVfb3JpZ2luLnopLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgLy8gSW50ZXJwb2xhdGUgYmV0d2VlbiB6b29tIGxldmVsc1xcblwiICtcblwiICAgICAgICB3aWR0aCArPSBkd2R6ICogZHo7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgLy8gU2NhbGUgcGl4ZWwgZGltZW5zaW9ucyB0byBiZSBjb25zaXN0ZW50IGluIHNjcmVlbiBzcGFjZVxcblwiICtcblwiICAgICAgICB3aWR0aCAqPSBleHAyKC1keik7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgLy8gTW9kaWZ5IGxpbmUgd2lkdGggYmVmb3JlIGV4dHJ1c2lvblxcblwiICtcblwiICAgICAgICAjcHJhZ21hIHRhbmdyYW06IHdpZHRoXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgcG9zaXRpb24ueHkgKz0gZXh0cnVkZSAqIHdpZHRoO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gV29ybGQgY29vcmRpbmF0ZXMgZm9yIDNkIHByb2NlZHVyYWwgdGV4dHVyZXNcXG5cIiArXG5cIiAgICB2X3dvcmxkX3Bvc2l0aW9uID0gd3JhcFdvcmxkUG9zaXRpb24odV9tb2RlbCAqIHBvc2l0aW9uKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIEFkanVzdCBmb3IgdGlsZSBhbmQgdmlldyBwb3NpdGlvblxcblwiICtcblwiICAgIHBvc2l0aW9uID0gdV9tb2RlbFZpZXcgKiBwb3NpdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIE1vZGlmeSBwb3NpdGlvbiBiZWZvcmUgY2FtZXJhIHByb2plY3Rpb25cXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IHBvc2l0aW9uXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBTZXR1cCB2YXJ5aW5nc1xcblwiICtcblwiICAgIHZfcG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cIiArXG5cIiAgICB2X25vcm1hbCA9IG5vcm1hbGl6ZSh1X25vcm1hbE1hdHJpeCAqIFRBTkdSQU1fTk9STUFMKTtcXG5cIiArXG5cIiAgICB2X2NvbG9yID0gYV9jb2xvcjtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFZlcnRleCBsaWdodGluZ1xcblwiICtcblwiICAgICNpZiBkZWZpbmVkKFRBTkdSQU1fTElHSFRJTkdfVkVSVEVYKVxcblwiICtcblwiICAgICAgICB2ZWM0IGNvbG9yID0gYV9jb2xvcjtcXG5cIiArXG5cIiAgICAgICAgdmVjMyBub3JtYWwgPSBUQU5HUkFNX05PUk1BTDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAvLyBNb2RpZnkgbm9ybWFsIGJlZm9yZSBsaWdodGluZ1xcblwiICtcblwiICAgICAgICAjcHJhZ21hIHRhbmdyYW06IG5vcm1hbFxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIC8vIE1vZGlmeSBjb2xvciBhbmQgbWF0ZXJpYWwgcHJvcGVydGllcyBiZWZvcmUgbGlnaHRpbmdcXG5cIiArXG5cIiAgICAgICAgI3ByYWdtYSB0YW5ncmFtOiBjb2xvclxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIHZfbGlnaHRpbmcgPSBjYWxjdWxhdGVMaWdodGluZyhwb3NpdGlvbi54eXosIG5vcm1hbCwgY29sb3IpO1xcblwiICtcblwiICAgICAgICB2X2NvbG9yID0gY29sb3I7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBDYW1lcmFcXG5cIiArXG5cIiAgICBjYW1lcmFQcm9qZWN0aW9uKHBvc2l0aW9uKTtcXG5cIiArXG5cIiAgICBhcHBseUxheWVyT3JkZXIoU0hPUlQoYV9wb3NpdGlvbi53KSwgcG9zaXRpb24pO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgZ2xfUG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWRlclNvdXJjZXM7XG4iLCIvKmdsb2JhbCBUZXh0dXJlICovXG4vLyBUZXh0dXJlIG1hbmFnZW1lbnRcbmltcG9ydCBVdGlscyBmcm9tICcuLi91dGlscy91dGlscyc7XG5pbXBvcnQgc3Vic2NyaWJlTWl4aW4gZnJvbSAnLi4vdXRpbHMvc3Vic2NyaWJlJztcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi4vdXRpbHMvd29ya2VyX2Jyb2tlcic7XG5pbXBvcnQgQnVpbGRlcnMgZnJvbSAnLi4vc3R5bGVzL2J1aWxkZXJzJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG4vLyBHTCB0ZXh0dXJlIHdyYXBwZXIgb2JqZWN0IGZvciBrZWVwaW5nIHRyYWNrIG9mIGEgZ2xvYmFsIHNldCBvZiB0ZXh0dXJlcywga2V5ZWQgYnkgYSB1bmlxdWUgdXNlci1kZWZpbmVkIG5hbWVcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmUge1xuXG4gICAgY29uc3RydWN0b3IoZ2wsIG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaW5kKCk7XG4gICAgICAgIHRoaXMuaW1hZ2UgPSBudWxsOyAgICAgIC8vIGFuIEltYWdlIG9iamVjdC9lbGVtZW50IHRoYXQgaXMgdGhlIHNvdXJjZSBmb3IgdGhpcyB0ZXh0dXJlXG4gICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDsgICAgIC8vIGEgQ2FudmFzIG9iamVjdC9lbGVtZW50IHRoYXQgaXMgdGhlIHNvdXJjZSBmb3IgdGhpcyB0ZXh0dXJlXG4gICAgICAgIHRoaXMubG9hZGluZyA9IG51bGw7ICAgIC8vIGEgUHJvbWlzZSBvYmplY3QgdG8gdHJhY2sgdGhlIGxvYWRpbmcgc3RhdGUgb2YgdGhpcyB0ZXh0dXJlXG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBhIDEtcGl4ZWwgYmxhY2sgdGV4dHVyZSBzbyB3ZSBjYW4gc2FmZWx5IHJlbmRlciB3aGlsZSB3ZSB3YWl0IGZvciBhbiBpbWFnZSB0byBsb2FkXG4gICAgICAgIC8vIFNlZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xOTcyMjI0Ny93ZWJnbC13YWl0LWZvci10ZXh0dXJlLXRvLWxvYWRcbiAgICAgICAgdGhpcy5zZXREYXRhKDEsIDEsIG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAyNTVdKSwgeyBmaWx0ZXJpbmc6ICduZWFyZXN0JyB9KTtcblxuICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgc3VwcG9ydCBmb3Igbm9uLVVSTCBzb3VyY2VzOiBjYW52YXMvdmlkZW8gZWxlbWVudHMsIHJhdyBwaXhlbCBidWZmZXJzXG5cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5maWx0ZXJpbmcgPSBvcHRpb25zLmZpbHRlcmluZztcblxuICAgICAgICAvLyBEZXN0cm95IHByZXZpb3VzIHRleHR1cmUgaWYgcHJlc2VudFxuICAgICAgICBpZiAoVGV4dHVyZS50ZXh0dXJlc1t0aGlzLm5hbWVdKSB7XG4gICAgICAgICAgICBUZXh0dXJlLnRleHR1cmVzW3RoaXMubmFtZV0uZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FjaGUgdGV4dHVyZSBpbnN0YW5jZSBhbmQgZGVmaW5pdGlvblxuICAgICAgICBUZXh0dXJlLnRleHR1cmVzW3RoaXMubmFtZV0gPSB0aGlzO1xuICAgICAgICBUZXh0dXJlLnRleHR1cmVfY29uZmlnc1t0aGlzLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7IG5hbWUgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5zcHJpdGVzID0gb3B0aW9ucy5zcHJpdGVzO1xuICAgICAgICB0aGlzLnRleGNvb3JkcyA9IHt9OyAgICAvLyBzcHJpdGUgVVZzIChbMCwgMV0gcmFuZ2UpXG4gICAgICAgIHRoaXMuc2l6ZXMgPSB7fTsgICAgICAgIC8vIHNwcml0ZSBzaXplcyAocGl4ZWwgc2l6ZSlcbiAgICAgICAgbG9nLnRyYWNlKGBjcmVhdGluZyBUZXh0dXJlICR7dGhpcy5uYW1lfWApO1xuICAgIH1cblxuICAgIC8vIERlc3Ryb3kgYSBzaW5nbGUgdGV4dHVyZSBpbnN0YW5jZVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLnRleHR1cmUpO1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgICAgICBkZWxldGUgdGhpcy5kYXRhO1xuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgICAgICBkZWxldGUgVGV4dHVyZS50ZXh0dXJlc1t0aGlzLm5hbWVdO1xuICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG4gICAgICAgIGxvZy50cmFjZShgZGVzdHJveWluZyBUZXh0dXJlICR7dGhpcy5uYW1lfWApO1xuICAgIH1cblxuICAgIGJpbmQodW5pdCkge1xuICAgICAgICBpZiAoIXRoaXMudmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHVuaXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAoVGV4dHVyZS5hY3RpdmVVbml0ICE9PSB1bml0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRTAgKyB1bml0KTtcbiAgICAgICAgICAgICAgICBUZXh0dXJlLmFjdGl2ZVVuaXQgPSB1bml0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChUZXh0dXJlLmFjdGl2ZVRleHR1cmUgIT09IHRoaXMudGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgICAgICBUZXh0dXJlLmFjdGl2ZVRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMb2FkcyBhIHRleHR1cmUgZnJvbSBhIFVSTFxuICAgIGxvYWQodXJsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVGV4dHVyZS5iYXNlX3VybCkge1xuICAgICAgICAgICAgdXJsID0gVXRpbHMuYWRkQmFzZVVSTCh1cmwsIFRleHR1cmUuYmFzZV91cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsID0gVXRpbHMuY2FjaGVCdXN0ZXJGb3JVcmwodXJsKTtcblxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICB0aGlzLmltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUZXh0dXJlRmlsdGVyaW5nKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVNwcml0ZXMoKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7IC8vIG11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIG90aGVyIHR5cGVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKGBUZXh0dXJlOiBmYWlsZWQgdG8gbG9hZCB1cmw6ICcke3VybH0nYCwgZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIFRleHR1cmUudHJpZ2dlcignd2FybmluZycsIHsgbWVzc2FnZTogYEZhaWxlZCB0byBsb2FkIHRleHR1cmUgZnJvbSAke3VybH1gLCBlcnJvcjogZSwgdGV4dHVyZTogb3B0aW9ucyB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2Uub25lcnJvciA9IGUgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdhcm4gYW5kIHJlc29sdmUgb24gZXJyb3JcbiAgICAgICAgICAgICAgICBsb2cud2FybihgVGV4dHVyZTogZmFpbGVkIHRvIGxvYWQgdXJsOiAnJHt1cmx9J2AsIGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIFRleHR1cmUudHJpZ2dlcignd2FybmluZycsIHsgbWVzc2FnZTogYEZhaWxlZCB0byBsb2FkIHRleHR1cmUgZnJvbSAke3VybH1gLCBlcnJvcjogZSwgdGV4dHVyZTogb3B0aW9ucyB9KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICAgICAgICAgIHRoaXMuaW1hZ2Uuc3JjID0gdXJsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZztcbiAgICB9XG5cbiAgICAvLyBTZXRzIHRleHR1cmUgdG8gYSByYXcgaW1hZ2UgYnVmZmVyXG4gICAgc2V0RGF0YSh3aWR0aCwgaGVpZ2h0LCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcblxuICAgICAgICB0aGlzLmltYWdlID0gbnVsbDsgLy8gbXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggb3RoZXIgdHlwZXNcbiAgICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuXG4gICAgICAgIHRoaXMudXBkYXRlKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNldFRleHR1cmVGaWx0ZXJpbmcob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gU2V0cyB0aGUgdGV4dHVyZSB0byB0cmFjayBhIGNhbnZhcyBlbGVtZW50XG4gICAgc2V0Q2FudmFzKGNhbnZhcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgdGhpcy51cGRhdGUob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZUZpbHRlcmluZyhvcHRpb25zKTtcblxuICAgICAgICB0aGlzLmltYWdlID0gbnVsbDsgLy8gbXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggb3RoZXIgdHlwZXNcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBVcGxvYWRzIGN1cnJlbnQgaW1hZ2Ugb3IgYnVmZmVyIHRvIHRoZSBHUFUgKGNhbiBiZSB1c2VkIHRvIHVwZGF0ZSBhbmltYXRlZCB0ZXh0dXJlcyBvbiB0aGUgZmx5KVxuICAgIHVwZGF0ZShvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJpbmQoKTtcbiAgICAgICAgdGhpcy5nbC5waXhlbFN0b3JlaSh0aGlzLmdsLlVOUEFDS19GTElQX1lfV0VCR0wsIChvcHRpb25zLlVOUEFDS19GTElQX1lfV0VCR0wgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlKSk7XG4gICAgICAgIHRoaXMuZ2wucGl4ZWxTdG9yZWkodGhpcy5nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIG9wdGlvbnMuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMIHx8IGZhbHNlKTtcblxuICAgICAgICAvLyBJbWFnZSBlbGVtZW50XG4gICAgICAgIGlmICh0aGlzLmltYWdlICYmIHRoaXMuaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmltYWdlLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmltYWdlLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuaW1hZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbnZhcyBlbGVtZW50XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSYXcgaW1hZ2UgYnVmZmVyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMud2lkdGggJiYgdGhpcy5oZWlnaHQpIHsgLy8gTk9URTogdGhpcy5kYXRhIGNhbiBiZSBudWxsLCB0byB6ZXJvIG91dCB0ZXh0dXJlXG4gICAgICAgICAgICB0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFXzJELCAwLCB0aGlzLmdsLlJHQkEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgdGhpcy5kYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFRleHR1cmUudHJpZ2dlcigndXBkYXRlJywgdGhpcyk7XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lcyBhcHByb3ByaWF0ZSBmaWx0ZXJpbmcgbW9kZVxuICAgIHNldFRleHR1cmVGaWx0ZXJpbmcob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy5maWx0ZXJpbmcgPSBvcHRpb25zLmZpbHRlcmluZyB8fCB0aGlzLmZpbHRlcmluZyB8fCAnbGluZWFyJztcblxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB0aGlzLmJpbmQoKTtcblxuICAgICAgICAvLyBGb3IgcG93ZXItb2YtMiB0ZXh0dXJlcywgdGhlIGZvbGxvd2luZyBwcmVzZXRzIGFyZSBhdmFpbGFibGU6XG4gICAgICAgIC8vIG1pcG1hcDogbGluZWFyIGJsZW5kIGZyb20gbmVhcmVzdCBtaXBcbiAgICAgICAgLy8gbGluZWFyOiBsaW5lYXIgYmxlbmQgZnJvbSBvcmlnaW5hbCBpbWFnZSAobm8gbWlwcylcbiAgICAgICAgLy8gbmVhcmVzdDogbmVhcmVzdCBwaXhlbCBmcm9tIG9yaWdpbmFsIGltYWdlIChubyBtaXBzLCAnYmxvY2t5JyBsb29rKVxuICAgICAgICBpZiAoVXRpbHMuaXNQb3dlck9mMih0aGlzLndpZHRoKSAmJiBVdGlscy5pc1Bvd2VyT2YyKHRoaXMuaGVpZ2h0KSkge1xuICAgICAgICAgICAgdGhpcy5wb3dlcl9vZl8yID0gdHJ1ZTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIG9wdGlvbnMuVEVYVFVSRV9XUkFQX1MgfHwgKG9wdGlvbnMucmVwZWF0ICYmIGdsLlJFUEVBVCkgfHwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBvcHRpb25zLlRFWFRVUkVfV1JBUF9UIHx8IChvcHRpb25zLnJlcGVhdCAmJiBnbC5SRVBFQVQpIHx8IGdsLkNMQU1QX1RPX0VER0UpO1xuXG4gICAgICAgICAgICAvLyBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBvcHRpb25zLlRFWFRVUkVfV1JBUF9TIHx8IGdsLlJFUEVBVCk7XG4gICAgICAgICAgICAvLyBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBvcHRpb25zLlRFWFRVUkVfV1JBUF9UIHx8IGdsLlJFUEVBVCk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbHRlcmluZyA9PT0gJ21pcG1hcCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmluZyA9ICdtaXBtYXAnO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUik7IC8vIFRPRE86IHVzZSB0cmlsaW5lYXIgZmlsdGVyaW5nIGJ5IGRlZnVhbHQgaW5zdGVhZD9cbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZmlsdGVyaW5nID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyaW5nID0gJ2xpbmVhcic7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmZpbHRlcmluZyA9PT0gJ25lYXJlc3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJpbmcgPSAnbmVhcmVzdCc7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlYkdMIGhhcyBzdHJpY3QgcmVxdWlyZW1lbnRzIG9uIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzOlxuICAgICAgICAgICAgLy8gTm8gbWlwbWFwcyBhbmQgbXVzdCBjbGFtcCB0byBlZGdlXG4gICAgICAgICAgICB0aGlzLnBvd2VyX29mXzIgPSBmYWxzZTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbHRlcmluZyA9PT0gJ25lYXJlc3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJpbmcgPSAnbmVhcmVzdCc7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBkZWZhdWx0IHRvIGxpbmVhciBmb3Igbm9uLXBvd2VyLW9mLTIgdGV4dHVyZXNcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmluZyA9ICdsaW5lYXInO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgVGV4dHVyZS50cmlnZ2VyKCd1cGRhdGUnLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBQcmUtY2FsYyBzcHJpdGUgcmVnaW9ucyBmb3IgYSB0ZXh0dXJlIHNwcml0ZSBpbiBVViBbMCwgMV0gc3BhY2VcbiAgICBjYWxjdWxhdGVTcHJpdGVzKCkge1xuICAgICAgICBpZiAodGhpcy5zcHJpdGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzIGluIHRoaXMuc3ByaXRlcykge1xuICAgICAgICAgICAgICAgIGxldCBzcHJpdGUgPSB0aGlzLnNwcml0ZXNbc107XG5cbiAgICAgICAgICAgICAgICAvLyBNYXAgWzAsIDBdIHRvIFsxLCAxXSBjb29yZHMgdG8gdGhlIGFwcHJvcHJpYXRlIHNwcml0ZSBzdWItYXJlYSBvZiB0aGUgdGV4dHVyZVxuICAgICAgICAgICAgICAgIHRoaXMudGV4Y29vcmRzW3NdID0gQnVpbGRlcnMuZ2V0VGV4Y29vcmRzRm9yU3ByaXRlKFxuICAgICAgICAgICAgICAgICAgICBbc3ByaXRlWzBdLCBzcHJpdGVbMV1dLFxuICAgICAgICAgICAgICAgICAgICBbc3ByaXRlWzJdLCBzcHJpdGVbM11dLFxuICAgICAgICAgICAgICAgICAgICBbdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIFBpeGVsIHNpemUgb2Ygc3ByaXRlXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplc1tzXSA9IFtzcHJpdGVbMl0sIHNwcml0ZVszXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuXG4vLyBTdGF0aWMvY2xhc3MgbWV0aG9kcyBhbmQgc3RhdGVcblxuLy8gRGVzdHJveSBhbGwgdGV4dHVyZSBpbnN0YW5jZXMgZm9yIGEgZ2l2ZW4gR0wgY29udGV4dFxuVGV4dHVyZS5kZXN0cm95ID0gZnVuY3Rpb24gKGdsKSB7XG4gICAgdmFyIHRleHR1cmVzID0gT2JqZWN0LmtleXMoVGV4dHVyZS50ZXh0dXJlcyk7XG4gICAgZm9yICh2YXIgdCBvZiB0ZXh0dXJlcykge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IFRleHR1cmUudGV4dHVyZXNbdF07XG4gICAgICAgIGlmICh0ZXh0dXJlLmdsID09PSBnbCkge1xuICAgICAgICAgICAgdGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBHZXQgc3ByaXRlIHBpeGVsIHNpemUgYW5kIFVWc1xuVGV4dHVyZS5nZXRTcHJpdGVJbmZvID0gZnVuY3Rpb24gKHRleG5hbWUsIHNwcml0ZSkge1xuICAgIGxldCB0ZXh0dXJlID0gVGV4dHVyZS50ZXh0dXJlc1t0ZXhuYW1lXTtcbiAgICByZXR1cm4gdGV4dHVyZSAmJiB7IHNpemU6IHRleHR1cmUuc2l6ZXNbc3ByaXRlXSwgdGV4Y29vcmRzOiB0ZXh0dXJlLnRleGNvb3Jkc1tzcHJpdGVdIH07XG59O1xuXG4vLyBDcmVhdGUgYSBzZXQgb2YgdGV4dHVyZXMga2V5ZWQgaW4gYW4gb2JqZWN0XG4vLyBPcHRpb25hbGx5IGxvYWQgZWFjaCBpZiBpdCBoYXMgYSBVUkwgc3BlY2lmaWVkXG5UZXh0dXJlLmNyZWF0ZUZyb21PYmplY3QgPSBmdW5jdGlvbiAoZ2wsIHRleHR1cmVzKSB7XG4gICAgbGV0IGxvYWRpbmcgPSBbXTtcbiAgICBpZiAodGV4dHVyZXMpIHtcbiAgICAgICAgZm9yIChsZXQgdGV4bmFtZSBpbiB0ZXh0dXJlcykge1xuICAgICAgICAgICAgbGV0IGNvbmZpZyA9IHRleHR1cmVzW3RleG5hbWVdO1xuXG4gICAgICAgICAgICAvLyBJZiB0ZXh0dXJlIGFscmVhZHkgZXhpc3RzIGFuZCBkZWZpbml0aW9uIGhhc24ndCBjaGFuZ2VkLCBubyBuZWVkIHRvIHJlLWNyZWF0ZVxuICAgICAgICAgICAgLy8gTm90ZTogdG8gYXZvaWQgZmxpY2tlciB3aGVuIG90aGVyIHRleHR1cmVzL3NjZW5lIGl0ZW1zIGNoYW5nZVxuICAgICAgICAgICAgaWYgKCFUZXh0dXJlLmNoYW5nZWQodGV4bmFtZSwgY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGdsLCB0ZXhuYW1lLCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy51cmwpIHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nLnB1c2godGV4dHVyZS5sb2FkKGNvbmZpZy51cmwsIGNvbmZpZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChsb2FkaW5nKTtcbn07XG5cbi8vIEluZGljYXRlIGlmIGEgdGV4dHVyZSBkZWZpbml0aW9uIHdvdWxkIGJlIGEgY2hhbmdlIGZyb20gdGhlIGN1cnJlbnQgY2FjaGVcblRleHR1cmUuY2hhbmdlZCA9IGZ1bmN0aW9uIChuYW1lLCBjb25maWcpIHtcbiAgICBpZiAoVGV4dHVyZS50ZXh0dXJlc1tuYW1lXSkgeyAvLyBjYWNoZWQgdGV4dHVyZVxuICAgICAgICAvLyBjb21wYXJlIGRlZmluaXRpb25zXG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShUZXh0dXJlLnRleHR1cmVfY29uZmlnc1tuYW1lXSkgPT09XG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKHsgbmFtZSB9LCBjb25maWcpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLy8gR2V0IG1ldGFkYXRhIGZvciBhIHRleHR1cmUgYnkgbmFtZVxuLy8gUmV0dXJucyB2aWEgcHJvbWlzZSwgaW4gY2FzZSB0ZXh0dXJlIGlzIHN0aWxsIGxvYWRpbmdcbi8vIENhbiBiZSBjYWxsZWQgb24gbWFpbiB0aHJlYWQgZnJvbSB3b3JrZXIsIHRvIHN5bmMgdGV4dHVyZSBpbmZvIHRvIHdvcmtlclxuVGV4dHVyZS5nZXRJbmZvID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLyBHZXQgaW5mbyBmb3IgYWxsIHRleHR1cmVzIGJ5IGRlZmF1bHRcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgbmFtZSA9IE9iamVjdC5rZXlzKFRleHR1cmUudGV4dHVyZXMpO1xuICAgIH1cblxuICAgIC8vIEdldCBtdWx0aXBsZSB0ZXh0dXJlc1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChuYW1lLm1hcChuID0+IFRleHR1cmUuZ2V0SW5mbyhuKSkpO1xuICAgIH1cblxuICAgIC8vIEdldCBzaW5nbGUgdGV4dHVyZVxuICAgIHZhciB0ZXggPSBUZXh0dXJlLnRleHR1cmVzW25hbWVdO1xuICAgIGlmICh0ZXgpIHtcbiAgICAgICAgLy8gV2FpdCBmb3IgdGhpcyB0ZXh0dXJlIHRvIGZpbmlzaCBsb2FkaW5nLCBvciByZXR1cm4gaW1tZWRpYXRlbHlcbiAgICAgICAgdmFyIGxvYWRpbmcgPSB0ZXgubG9hZGluZyB8fCBQcm9taXNlLnJlc29sdmUodGV4KTtcbiAgICAgICAgcmV0dXJuIGxvYWRpbmcudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gYSBzdWJzZXQgb2YgdGV4dHVyZSBpbmZvXG4gICAgICAgICAgICAvLyAoY29tcGF0aWJsZSB3L3N0cnVjdHVyZWQgY2xvbmluZywgc3VpdGFibGUgZm9yIHBhc3NpbmcgdG8gYSB3b3JrZXIpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRleC5uYW1lLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0ZXgud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0ZXguaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHNwcml0ZXM6IHRleC5zcHJpdGVzLFxuICAgICAgICAgICAgICAgIHRleGNvb3JkczogdGV4LnRleGNvb3JkcyxcbiAgICAgICAgICAgICAgICBzaXplczogdGV4LnNpemVzLFxuICAgICAgICAgICAgICAgIGZpbHRlcmluZzogdGV4LmZpbHRlcmluZyxcbiAgICAgICAgICAgICAgICBwb3dlcl9vZl8yOiB0ZXgucG93ZXJfb2ZfMixcbiAgICAgICAgICAgICAgICB2YWxpZDogdGV4LnZhbGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5vIHRleHR1cmUgZm91bmRcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG59O1xuXG4vLyBTeW5jIHRleHR1cmUgaW5mbyB0byB3b3JrZXJcbi8vIENhbGxlZCBmcm9tIHdvcmtlciwgZ2V0cyBpbmZvIG9uIG9uZSBvciBtb3JlIHRleHR1cmVzIGluZm8gZnJvbSBtYWluIHRocmVhZCB2aWEgcmVtb3RlIGNhbGwsIHRoZW4gc3RvcmVzIGl0XG4vLyBsb2NhbGx5IGluIHdvcmtlci4gJ3RleHR1cmVzJyBjYW4gYmUgYW4gYXJyYXkgb2YgdGV4dHVyZSBuYW1lcyB0byBzeW5jLCBvciBpZiBudWxsLCBhbGwgdGV4dHVyZXMgYXJlIHN5bmNlZC5cblRleHR1cmUuc3luY1RleHR1cmVzVG9Xb3JrZXIgPSBmdW5jdGlvbiAobmFtZXMpIHtcbiAgICByZXR1cm4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKCdUZXh0dXJlLmdldEluZm8nLCBuYW1lcykuXG4gICAgICAgIHRoZW4odGV4dHVyZXMgPT4ge1xuICAgICAgICAgICAgZm9yICh2YXIgdGV4IG9mIHRleHR1cmVzKSB7XG4gICAgICAgICAgICAgICAgVGV4dHVyZS50ZXh0dXJlc1t0ZXgubmFtZV0gPSB0ZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVGV4dHVyZS50ZXh0dXJlcztcbiAgICAgICAgfSk7XG59O1xuXG4vLyBHbG9iYWwgc2V0IG9mIHRleHR1cmVzLCBieSBuYW1lXG5UZXh0dXJlLnRleHR1cmVzID0ge307XG5UZXh0dXJlLnRleHR1cmVfY29uZmlncyA9IHt9O1xuVGV4dHVyZS5ib3VuZFRleHR1cmUgPSAtMTtcblRleHR1cmUuYWN0aXZlVW5pdCA9IC0xO1xuXG5UZXh0dXJlLmJhc2VfdXJsID0gbnVsbDsgLy8gb3B0aW9uYWwgYmFzZSBVUkwgdG8gYWRkIHRvIHRleHR1cmVzXG5cbldvcmtlckJyb2tlci5hZGRUYXJnZXQoJ1RleHR1cmUnLCBUZXh0dXJlKTtcbnN1YnNjcmliZU1peGluKFRleHR1cmUpO1xuIiwiLy8gQ3JlYXRlcyBhIFZlcnRleCBBcnJheSBPYmplY3QgaWYgdGhlIGV4dGVuc2lvbiBpcyBhdmFpbGFibGUsIG9yIGZhbGxzIGJhY2sgb24gc3RhbmRhcmQgYXR0cmlidXRlIGNhbGxzXG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG52YXIgVmVydGV4QXJyYXlPYmplY3Q7XG5leHBvcnQgZGVmYXVsdCBWZXJ0ZXhBcnJheU9iamVjdCA9IHt9O1xuXG5WZXJ0ZXhBcnJheU9iamVjdC5kaXNhYmxlZCA9IGZhbHNlOyAvLyBzZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIFZBT3MgZXZlbiBpZiBleHRlbnNpb24gaXMgYXZhaWxhYmxlXG5WZXJ0ZXhBcnJheU9iamVjdC5ib3VuZF92YW8gPSBudWxsOyAvLyBjdXJyZW50bHkgYm91bmQgVkFPXG5cblZlcnRleEFycmF5T2JqZWN0LmluaXQgPSBmdW5jdGlvbiAoZ2wpIHtcbiAgICBpZiAoVmVydGV4QXJyYXlPYmplY3QuZXh0ID09IG51bGwpIHtcbiAgICAgICAgaWYgKFZlcnRleEFycmF5T2JqZWN0LmRpc2FibGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBWZXJ0ZXhBcnJheU9iamVjdC5leHQgPSBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdmVydGV4X2FycmF5X29iamVjdFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChWZXJ0ZXhBcnJheU9iamVjdC5leHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nLmluZm8oJ1ZlcnRleCBBcnJheSBPYmplY3QgZXh0ZW5zaW9uIGF2YWlsYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFZlcnRleEFycmF5T2JqZWN0LmRpc2FibGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBsb2cud2FybignVmVydGV4IEFycmF5IE9iamVjdCBleHRlbnNpb24gTk9UIGF2YWlsYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nLndhcm4oJ1ZlcnRleCBBcnJheSBPYmplY3QgZXh0ZW5zaW9uIGZvcmNlIGRpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5WZXJ0ZXhBcnJheU9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoc2V0dXAsIHRlYXJkb3duKSB7XG4gICAgbGV0IHZhbyA9IHt9O1xuICAgIHZhby5zZXR1cCA9IHNldHVwO1xuICAgIHZhby50ZWFyZG93biA9IHRlYXJkb3duO1xuXG4gICAgbGV0IGV4dCA9IFZlcnRleEFycmF5T2JqZWN0LmV4dDtcbiAgICBpZiAoZXh0ICE9IG51bGwpIHtcbiAgICAgICAgdmFvLl92YW8gPSBleHQuY3JlYXRlVmVydGV4QXJyYXlPRVMoKTtcbiAgICAgICAgZXh0LmJpbmRWZXJ0ZXhBcnJheU9FUyh2YW8uX3Zhbyk7XG4gICAgfVxuXG4gICAgdmFvLnNldHVwKHRydWUpO1xuXG4gICAgcmV0dXJuIHZhbztcbn07XG5cblZlcnRleEFycmF5T2JqZWN0LmJpbmQgPSBmdW5jdGlvbiAodmFvKSB7XG4gICAgbGV0IGV4dCA9IFZlcnRleEFycmF5T2JqZWN0LmV4dDtcbiAgICBpZiAodmFvICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGV4dCAhPSBudWxsICYmIHZhby5fdmFvICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dC5iaW5kVmVydGV4QXJyYXlPRVModmFvLl92YW8pO1xuICAgICAgICAgICAgVmVydGV4QXJyYXlPYmplY3QuYm91bmRfdmFvID0gdmFvO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFvLnNldHVwKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHQuYmluZFZlcnRleEFycmF5T0VTKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFZlcnRleEFycmF5T2JqZWN0LmJvdW5kX3ZhbyAhPSBudWxsICYmIHR5cGVvZiBWZXJ0ZXhBcnJheU9iamVjdC5ib3VuZF92YW8udGVhcmRvd24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIFZlcnRleEFycmF5T2JqZWN0LmJvdW5kX3Zhby50ZWFyZG93bigpO1xuICAgICAgICB9XG4gICAgICAgIFZlcnRleEFycmF5T2JqZWN0LmJvdW5kX3ZhbyA9IG51bGw7XG4gICAgfVxufTtcbiIsIi8qIGdsb2JhbCBWQk9NZXNoICovXG4vLyBNYW5hZ2UgcmVuZGVyaW5nIGZvciBwcmltaXRpdmVzXG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tICcuL3NoYWRlcl9wcm9ncmFtJztcbmltcG9ydCBWZXJ0ZXhBcnJheU9iamVjdCBmcm9tICcuL3Zhbyc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxuLy8gQSBzaW5nbGUgbWVzaC9WQk8sIGRlc2NyaWJlZCBieSBhIHZlcnRleCBsYXlvdXQsIHRoYXQgY2FuIGJlIGRyYXduIHdpdGggb25lIG9yIG1vcmUgcHJvZ3JhbXNcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZCT01lc2ggIHtcblxuICAgIGNvbnN0cnVjdG9yKGdsLCB2ZXJ0ZXhfZGF0YSwgdmVydGV4X2xheW91dCwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgICAgIHRoaXMudmVydGV4X2RhdGEgPSB2ZXJ0ZXhfZGF0YTsgLy8gdHlwZWQgYXJyYXlcbiAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0ID0gdmVydGV4X2xheW91dDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICB0aGlzLmRyYXdfbW9kZSA9IG9wdGlvbnMuZHJhd19tb2RlIHx8IHRoaXMuZ2wuVFJJQU5HTEVTO1xuICAgICAgICB0aGlzLmRhdGFfdXNhZ2UgPSBvcHRpb25zLmRhdGFfdXNhZ2UgfHwgdGhpcy5nbC5TVEFUSUNfRFJBVztcbiAgICAgICAgdGhpcy52ZXJ0aWNlc19wZXJfZ2VvbWV0cnkgPSAzOyAvLyBUT0RPOiBzdXBwb3J0IGxpbmVzLCBzdHJpcCwgZmFuLCBldGMuXG4gICAgICAgIHRoaXMudW5pZm9ybXMgPSBvcHRpb25zLnVuaWZvcm1zO1xuICAgICAgICB0aGlzLnJldGFpbiA9IG9wdGlvbnMucmV0YWluIHx8IGZhbHNlOyAvLyB3aGV0aGVyIHRvIHJldGFpbiBtZXNoIGRhdGEgaW4gQ1BVIGFmdGVyIHVwbG9hZGluZyB0byBHUFVcblxuICAgICAgICB0aGlzLnZlcnRleF9jb3VudCA9IHRoaXMudmVydGV4X2RhdGEuYnl0ZUxlbmd0aCAvIHRoaXMudmVydGV4X2xheW91dC5zdHJpZGU7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnlfY291bnQgPSB0aGlzLnZlcnRleF9jb3VudCAvIHRoaXMudmVydGljZXNfcGVyX2dlb21ldHJ5O1xuICAgICAgICB0aGlzLnZhb3MgPSBuZXcgTWFwKCk7IC8vIG1hcCBvZiBWZXJ0ZXhBcnJheU9iamVjdHMsIGtleWVkIGJ5IHByb2dyYW1cblxuICAgICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleF9kYXRhLCB0aGlzLmRhdGFfdXNhZ2UpO1xuXG4gICAgICAgIGlmICghdGhpcy5yZXRhaW4pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnZlcnRleF9kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFJlbmRlciwgYnkgZGVmYXVsdCB3aXRoIGN1cnJlbnRseSBib3VuZCBwcm9ncmFtLCBvciBvdGhlcndpc2Ugd2l0aCBvcHRpb25hbGx5IHByb3ZpZGVkIG9uZVxuICAgIHJlbmRlcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3JlbmRlcl9zZXR1cCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyX3NldHVwKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvZ3JhbSA9IG9wdGlvbnMucHJvZ3JhbSB8fCBTaGFkZXJQcm9ncmFtLmN1cnJlbnQ7XG4gICAgICAgIHByb2dyYW0udXNlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMudW5pZm9ybXMpIHtcbiAgICAgICAgICAgIHByb2dyYW0uc2F2ZVVuaWZvcm1zKHRoaXMudW5pZm9ybXMpO1xuICAgICAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3Jtcyh0aGlzLnVuaWZvcm1zLCBmYWxzZSk7IC8vIGRvbid0IHJlc2V0IHRleHR1cmUgdW5pdFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5iaW5kKHByb2dyYW0pO1xuXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgZWxlbWVudCBhcnJheSBtb2RlXG4gICAgICAgIHRoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmRyYXdfbW9kZSwgMCwgdGhpcy52ZXJ0ZXhfY291bnQpO1xuICAgICAgICBWZXJ0ZXhBcnJheU9iamVjdC5iaW5kKG51bGwpO1xuXG4gICAgICAgIGlmICh0aGlzLnVuaWZvcm1zKSB7XG4gICAgICAgICAgICBwcm9ncmFtLnJlc3RvcmVVbmlmb3Jtcyh0aGlzLnVuaWZvcm1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEJpbmQgYnVmZmVycyBhbmQgdmVydGV4IGF0dHJpYnV0ZXMgdG8gcHJlcGFyZSBmb3IgcmVuZGVyaW5nXG4gICAgYmluZChwcm9ncmFtKSB7XG4gICAgICAgIC8vIEJpbmQgVkFPIGZvciB0aGlzIHByb2dhbSwgb3IgY3JlYXRlIG9uZVxuICAgICAgICBsZXQgdmFvID0gdGhpcy52YW9zLmdldChwcm9ncmFtKTtcbiAgICAgICAgaWYgKHZhbykge1xuICAgICAgICAgICAgVmVydGV4QXJyYXlPYmplY3QuYmluZCh2YW8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YW9zLnNldChwcm9ncmFtLCBWZXJ0ZXhBcnJheU9iamVjdC5jcmVhdGUoKGZvcmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0LmVuYWJsZSh0aGlzLmdsLCBwcm9ncmFtLCBmb3JjZSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAoIXRoaXMudmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG5cbiAgICAgICAgbG9nLnRyYWNlKCdWQk9NZXNoLmRlc3Ryb3k6IGRlbGV0ZSBidWZmZXInICsgKHRoaXMudmVydGV4X2RhdGEgPyBgIG9mIHNpemUgJHt0aGlzLnZlcnRleF9kYXRhLmJ5dGVMZW5ndGh9YCA6ICcnKSk7XG5cbiAgICAgICAgdGhpcy5nbC5kZWxldGVCdWZmZXIodGhpcy5idWZmZXIpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnZlcnRleF9kYXRhO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxufVxuIiwiLyogZ2xvYmFsIFZlcnRleERhdGEgKi9cblxuaW1wb3J0IGdsIGZyb20gJy4vY29uc3RhbnRzJzsgLy8gd2ViIHdvcmtlcnMgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gR0wgY29udGV4dCwgc28gaW1wb3J0IGFsbCBHTCBjb25zdGFudHNcbmltcG9ydCB7bG9nfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5cbi8vIE1hcHMgR0wgdHlwZXMgdG8gSlMgYXJyYXkgdHlwZXNcbmxldCBhcnJheV90eXBlcyA9IHtcbiAgICBbZ2wuRkxPQVRdOiBGbG9hdDMyQXJyYXksXG4gICAgW2dsLkJZVEVdOiBJbnQ4QXJyYXksXG4gICAgW2dsLlVOU0lHTkVEX0JZVEVdOiBVaW50OEFycmF5LFxuICAgIFtnbC5JTlRdOiBJbnQzMkFycmF5LFxuICAgIFtnbC5VTlNJR05FRF9JTlRdOiBVaW50MzJBcnJheSxcbiAgICBbZ2wuU0hPUlRdOiBJbnQxNkFycmF5LFxuICAgIFtnbC5VTlNJR05FRF9TSE9SVF06IFVpbnQxNkFycmF5XG59O1xuXG4vLyBBbiBpbnRlcm1lZGlhcnkgb2JqZWN0IHRoYXQgaG9sZHMgdmVydGV4IGRhdGEgaW4gdHlwZWQgYXJyYXlzLCBhY2NvcmRpbmcgdG8gYSBnaXZlbiB2ZXJ0ZXggbGF5b3V0XG4vLyBVc2VkIHRvIGNvbnN0cnVjdCBhIG1lc2gvVkJPIGZvciByZW5kZXJpbmdcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcnRleERhdGEge1xuXG4gICAgY29uc3RydWN0b3IgKHZlcnRleF9sYXlvdXQsIHsgcHJlYWxsb2MgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMudmVydGV4X2xheW91dCA9IHZlcnRleF9sYXlvdXQ7XG5cbiAgICAgICAgaWYgKFZlcnRleERhdGEuYXJyYXlfcG9vbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IFZlcnRleERhdGEuYXJyYXlfcG9vbC5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyX2xlbmd0aCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcl9zaXplID0gTWF0aC5mbG9vcih0aGlzLmJ1ZmZlcl9sZW5ndGggLyB0aGlzLnZlcnRleF9sYXlvdXQuc3RyaWRlKTtcbiAgICAgICAgICAgIGxvZygndHJhY2UnLCBgVmVydGV4RGF0YTogcmV1c2VkIGJ1ZmZlciBvZiBieXRlcyAke3RoaXMuYnVmZmVyX2xlbmd0aH0sICR7dGhpcy5idWZmZXJfc2l6ZX0gdmVydGljZXNgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyX3NpemUgPSBwcmVhbGxvYyB8fCA1MDA7IC8vICMgb2YgdmVydGljZXMgdG8gYWxsb2NhdGVcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyX2xlbmd0aCA9IHRoaXMudmVydGV4X2xheW91dC5zdHJpZGUgKiB0aGlzLmJ1ZmZlcl9zaXplO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcl9sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyX29mZnNldCA9IDA7ICAgICAgICAgICAgIC8vIGJ5dGUgb2Zmc2V0IGludG8gY3VycmVudGx5IGFsbG9jYXRlZCBidWZmZXJcblxuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgY29tcG9uZW50IG9mIHRoaXMudmVydGV4X2xheW91dC5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMucHVzaChbLi4uY29tcG9uZW50XSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJ0ZXhfY291bnQgPSAwO1xuICAgICAgICB0aGlzLnJlYWxsb2NfY291bnQgPSAwO1xuICAgICAgICB0aGlzLnNldEJ1ZmZlclZpZXdzKCk7XG4gICAgfVxuXG4gICAgLy8gKFJlLSlhbGxvY2F0ZSB0eXBlZCB2aWV3cyBpbnRvIHRoZSBtYWluIGJ1ZmZlciAtIG9ubHkgY3JlYXRlIHRoZSB0eXBlcyB3ZSBuZWVkIGZvciB0aGlzIGxheW91dFxuICAgIHNldEJ1ZmZlclZpZXdzICgpIHtcbiAgICAgICAgdGhpcy5idWZmZXJfdmlld3MgPSB7fTtcbiAgICAgICAgdGhpcy5idWZmZXJfdmlld3NbZ2wuVU5TSUdORURfQllURV0gPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgZm9yICh2YXIgYXR0cmliIG9mIHRoaXMudmVydGV4X2xheW91dC5hdHRyaWJzKSB7XG4gICAgICAgICAgICAvLyBOZWVkIHZpZXcgZm9yIHRoaXMgdHlwZT9cbiAgICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlcl92aWV3c1thdHRyaWIudHlwZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBhcnJheV90eXBlID0gYXJyYXlfdHlwZXNbYXR0cmliLnR5cGVdO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyX3ZpZXdzW2F0dHJpYi50eXBlXSA9IG5ldyBhcnJheV90eXBlKHRoaXMuYnVmZmVyLmJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgY29tcG9uZW50IGJ1ZmZlciBwb2ludGVyc1xuICAgICAgICBmb3IgKHZhciBjb21wb25lbnQgb2YgdGhpcy5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICBjb21wb25lbnRbMV0gPSB0aGlzLmJ1ZmZlcl92aWV3c1tjb21wb25lbnRbMF1dO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgYWxsb2NhdGVkIGJ1ZmZlciBzaXplLCBleHBhbmQvcmVhbGxvYyBidWZmZXIgaWYgbmVlZGVkXG4gICAgY2hlY2tCdWZmZXJTaXplICgpIHtcbiAgICAgICAgaWYgKCh0aGlzLmJ1ZmZlcl9vZmZzZXQgKyB0aGlzLnZlcnRleF9sYXlvdXQuc3RyaWRlKSA+IHRoaXMuYnVmZmVyX2xlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJfc2l6ZSA9IE1hdGguZmxvb3IodGhpcy5idWZmZXJfc2l6ZSAqIDEuNSk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcl9zaXplIC09IHRoaXMuYnVmZmVyX3NpemUgJSA0O1xuICAgICAgICAgICAgdGhpcy5idWZmZXJfbGVuZ3RoID0gdGhpcy52ZXJ0ZXhfbGF5b3V0LnN0cmlkZSAqIHRoaXMuYnVmZmVyX3NpemU7XG4gICAgICAgICAgICB2YXIgbmV3X3ZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcl9sZW5ndGgpO1xuICAgICAgICAgICAgbmV3X3ZpZXcuc2V0KHRoaXMuYnVmZmVyKTsgLy8gY29weSBleGlzdGluZyBkYXRhIHRvIG5ldyBidWZmZXJcbiAgICAgICAgICAgIFZlcnRleERhdGEuYXJyYXlfcG9vbC5wdXNoKHRoaXMuYnVmZmVyKTsgLy8gc2F2ZSBwcmV2aW91cyBidWZmZXIgZm9yIHVzZSBieSBuZXh0IHRpbGVcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3X3ZpZXc7XG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlclZpZXdzKCk7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2NfY291bnQrKztcbiAgICAgICAgICAgIC8vIGxvZy5pbmZvKGBWZXJ0ZXhEYXRhOiBleHBhbmRlZCB2ZXJ0ZXggYmxvY2sgdG8gJHt0aGlzLmJ1ZmZlcl9zaXplfSB2ZXJ0aWNlc2ApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGEgdmVydGV4LCBjb3BpZWQgZnJvbSBhIHBsYWluIEpTIGFycmF5IG9mIGVsZW1lbnRzIG1hdGNoaW5nIHRoZSBvcmRlciBvZiB0aGUgdmVydGV4IGxheW91dC5cbiAgICAvLyBOb3RlOiB1c2VzIHByZS1jYWxjdWxhdGVkIGluZm8gYWJvdXQgZWFjaCBhdHRyaWJ1dGUsIGluY2x1ZGluZyBwb2ludGVyIHRvIGFwcHJvcHJpYXRlIHR5cGVkIGFycmF5XG4gICAgLy8gdmlldyBhbmQgb2Zmc2V0IGludG8gaXQuIFRoaXMgd2FzIHRoZSBmYXN0ZXN0IG1ldGhvZCBwcm9maWxlZCBzbyBmYXIgZm9yIGZpbGxpbmcgYSBtaXhlZC10eXBlXG4gICAgLy8gdmVydGV4IGxheW91dCAodGhvdWdoIHN0aWxsIHNsb3dlciB0aGFuIHRoZSBwcmV2aW91cyBtZXRob2QgdGhhdCBvbmx5IHN1cHBvcnRlZCBGbG9hdDMyQXJyYXkgYXR0cmlidXRlcykuXG4gICAgYWRkVmVydGV4ICh2ZXJ0ZXgpIHtcbiAgICAgICAgdGhpcy5jaGVja0J1ZmZlclNpemUoKTtcbiAgICAgICAgdmFyIGk9MDtcblxuICAgICAgICB2YXIgY2xlbiA9IHRoaXMuY29tcG9uZW50cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGM9MDsgYyA8IGNsZW47IGMrKykge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1tjXTtcbiAgICAgICAgICAgIGNvbXBvbmVudFsxXVsodGhpcy5idWZmZXJfb2Zmc2V0ID4+IGNvbXBvbmVudFsyXSkgKyBjb21wb25lbnRbM11dID0gdmVydGV4W2krK107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJ1ZmZlcl9vZmZzZXQgKz0gdGhpcy52ZXJ0ZXhfbGF5b3V0LnN0cmlkZTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfY291bnQrKztcbiAgICB9XG5cbiAgICAvLyBGaW5hbGl6ZSB2ZXJ0ZXggYnVmZmVyIGZvciB1c2UgaW4gY29uc3RydWN0aW5nIGEgbWVzaFxuICAgIGVuZCAoKSB7XG4gICAgICAgIC8vIENsaXAgdGhlIGJ1ZmZlciB0byBzaXplIHVzZWQgZm9yIHRoaXMgVkJPXG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5idWZmZXJfb2Zmc2V0KTtcbiAgICAgICAgbG9nKCd0cmFjZScsIGBWZXJ0ZXhEYXRhOiAke3RoaXMuYnVmZmVyX3NpemV9IHZlcnRpY2VzIHRvdGFsLCByZWFsbG9jIGNvdW50ICR7dGhpcy5yZWFsbG9jX2NvdW50fWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbn1cblxuVmVydGV4RGF0YS5hcnJheV9wb29sID0gW107IC8vIHBvb2wgb2YgY3VycmVudGx5IGF2YWlsYWJsZSAocHJldmlvdXNseSB1c2VkKSBidWZmZXJzICh1aW50OClcbiIsIi8qIGdsb2JhbCBWZXJ0ZXhMYXlvdXQgKi9cblxuaW1wb3J0IGdsIGZyb20gJy4vY29uc3RhbnRzJzsgLy8gd2ViIHdvcmtlcnMgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gR0wgY29udGV4dCwgc28gaW1wb3J0IGFsbCBHTCBjb25zdGFudHNcbmltcG9ydCBWZXJ0ZXhEYXRhIGZyb20gJy4vdmVydGV4X2RhdGEnO1xuXG4vLyBEZXNjcmliZXMgYSB2ZXJ0ZXggbGF5b3V0IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBtYW55IGRpZmZlcmVudCBHTCBwcm9ncmFtcy5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcnRleExheW91dCB7XG4gICAgLy8gQXR0cmlicyBhcmUgYW4gYXJyYXksIGluIGxheW91dCBvcmRlciwgb2Y6IG5hbWUsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWRcbiAgICAvLyBleDogeyBuYW1lOiAncG9zaXRpb24nLCBzaXplOiAzLCB0eXBlOiBnbC5GTE9BVCwgbm9ybWFsaXplZDogZmFsc2UgfVxuICAgIGNvbnN0cnVjdG9yIChhdHRyaWJzKSB7XG4gICAgICAgIHRoaXMuYXR0cmlicyA9IGF0dHJpYnM7IC8vIGRpY3Rpb25hcnkgb2YgYXR0cmlidXRlcywgc3BlY2lmaWVkIGFzIHN0YW5kYXJkIEdMIGF0dHJpYiBvcHRpb25zXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IFtdOyAgIC8vIGxpc3Qgb2YgdHlwZSBhbmQgb2Zmc2V0IGluZm8gYWJvdXQgZWFjaCBhdHRyaWJ1dGUgY29tcG9uZW50XG4gICAgICAgIHRoaXMuaW5kZXggPSB7fTsgICAgICAgIC8vIGxpbmVhciBidWZmZXIgaW5kZXggb2YgZWFjaCBhdHRyaWJ1dGUgY29tcG9uZW50LCBlLmcuIHRoaXMuaW5kZXgucG9zaXRpb24ueFxuXG4gICAgICAgIC8vIENhbGMgdmVydGV4IHN0cmlkZVxuICAgICAgICB0aGlzLnN0cmlkZSA9IDA7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgYXR0cmliIG9mIHRoaXMuYXR0cmlicykge1xuICAgICAgICAgICAgYXR0cmliLm9mZnNldCA9IHRoaXMuc3RyaWRlO1xuICAgICAgICAgICAgYXR0cmliLmJ5dGVfc2l6ZSA9IGF0dHJpYi5zaXplO1xuICAgICAgICAgICAgdmFyIHNoaWZ0ID0gMDtcblxuICAgICAgICAgICAgc3dpdGNoIChhdHRyaWIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgZ2wuRkxPQVQ6XG4gICAgICAgICAgICAgICAgY2FzZSBnbC5JTlQ6XG4gICAgICAgICAgICAgICAgY2FzZSBnbC5VTlNJR05FRF9JTlQ6XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYi5ieXRlX3NpemUgKj0gNDtcbiAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGdsLlNIT1JUOlxuICAgICAgICAgICAgICAgIGNhc2UgZ2wuVU5TSUdORURfU0hPUlQ6XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYi5ieXRlX3NpemUgKj0gMjtcbiAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRm9yY2UgNC1ieXRlIGFsaWdubWVudCBvbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICB0aGlzLnN0cmlkZSArPSBhdHRyaWIuYnl0ZV9zaXplO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RyaWRlICYgMykgeyAvLyBwYWQgdG8gbXVsdGlwbGUgb2YgNCBieXRlc1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyaWRlICs9IDQgLSAodGhpcy5zdHJpZGUgJiAzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIGluZm8gdG8gbGlzdCBvZiBhdHRyaWJ1dGUgY29tcG9uZW50c1xuICAgICAgICAgICAgLy8gVXNlZCB0byBidWlsZCB0aGUgdmVydGV4IGRhdGEsIHByb3ZpZGVzIHBvaW50ZXJzIGFuZCBvZmZzZXRzIGludG8gZWFjaCB0eXBlZCBhcnJheSB2aWV3XG4gICAgICAgICAgICAvLyBFYWNoIGNvbXBvbmVudCBpcyBhbiBhcnJheSBvZjpcbiAgICAgICAgICAgIC8vIFtHTCBhdHRyaWIgdHlwZSwgcG9pbnRlciB0byB0eXBlZCBhcnJheSB2aWV3LCBiaXRzIHRvIHNoaWZ0IHJpZ2h0IHRvIGRldGVybWluZSBidWZmZXIgb2Zmc2V0LCBhZGRpdGlvbmFsIGJ1ZmZlciBvZmZzZXQgZm9yIHRoZSBjb21wb25lbnRdXG4gICAgICAgICAgICB2YXIgb2Zmc2V0X3R5cGVkID0gYXR0cmliLm9mZnNldCA+PiBzaGlmdDtcbiAgICAgICAgICAgIGlmIChhdHRyaWIuc2l6ZSA+IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhPTA7IGEgPCBhdHRyaWIuc2l6ZTsgYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKFthdHRyaWIudHlwZSwgbnVsbCwgc2hpZnQsIG9mZnNldF90eXBlZCsrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLnB1c2goW2F0dHJpYi50eXBlLCBudWxsLCBzaGlmdCwgb2Zmc2V0X3R5cGVkXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByb3ZpZGUgYW4gaW5kZXggaW50byB0aGUgdmVydGV4IGRhdGEgYnVmZmVyIGZvciBlYWNoIGF0dHJpYnV0ZSBjb21wb25lbnRcbiAgICAgICAgICAgIHRoaXMuaW5kZXhbYXR0cmliLm5hbWVdID0gY291bnQ7XG4gICAgICAgICAgICBjb3VudCArPSBhdHRyaWIuc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldHVwIGEgdmVydGV4IGxheW91dCBmb3IgYSBzcGVjaWZpYyBHTCBwcm9ncmFtXG4gICAgLy8gQXNzdW1lcyB0aGF0IHRoZSBkZXNpcmVkIHZlcnRleCBidWZmZXIgKFZCTykgaXMgYWxyZWFkeSBib3VuZFxuICAgIC8vIElmIGEgZ2l2ZW4gcHJvZ3JhbSBkb2Vzbid0IGluY2x1ZGUgYWxsIGF0dHJpYnV0ZXMsIGl0IGNhbiBzdGlsbCB1c2UgdGhlIHZlcnRleCBsYXlvdXRcbiAgICAvLyB0byByZWFkIHRob3NlIGF0dHJpYnMgdGhhdCBpdCBkb2VzIHJlY29nbml6ZSwgdXNpbmcgdGhlIGF0dHJpYiBvZmZzZXRzIHRvIHNraXAgb3RoZXJzLlxuICAgIGVuYWJsZSAoZ2wsIHByb2dyYW0sIGZvcmNlKVxuICAgIHtcbiAgICAgICAgdmFyIGF0dHJpYiwgbG9jYXRpb247XG5cbiAgICAgICAgLy8gRW5hYmxlIGFsbCBhdHRyaWJ1dGVzIGZvciB0aGlzIGxheW91dFxuICAgICAgICBmb3IgKHZhciBhPTA7IGEgPCB0aGlzLmF0dHJpYnMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgIGF0dHJpYiA9IHRoaXMuYXR0cmlic1thXTtcbiAgICAgICAgICAgIGxvY2F0aW9uID0gcHJvZ3JhbS5hdHRyaWJ1dGUoYXR0cmliLm5hbWUpLmxvY2F0aW9uO1xuXG4gICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFWZXJ0ZXhMYXlvdXQuZW5hYmxlZF9hdHRyaWJzW2xvY2F0aW9uXSB8fCBmb3JjZSkge1xuICAgICAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jYXRpb24sIGF0dHJpYi5zaXplLCBhdHRyaWIudHlwZSwgYXR0cmliLm5vcm1hbGl6ZWQsIHRoaXMuc3RyaWRlLCBhdHRyaWIub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBWZXJ0ZXhMYXlvdXQuZW5hYmxlZF9hdHRyaWJzW2xvY2F0aW9uXSA9IHByb2dyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEaXNhYmxlIGFueSBwcmV2aW91c2x5IGJvdW5kIGF0dHJpYnV0ZXMgdGhhdCBhcmVuJ3QgZm9yIHRoaXMgbGF5b3V0XG4gICAgICAgIGZvciAobG9jYXRpb24gaW4gVmVydGV4TGF5b3V0LmVuYWJsZWRfYXR0cmlicykge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlVW51c2VkQXR0cmlidXRlKGdsLCBsb2NhdGlvbiwgcHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXNhYmxlIGFuIGF0dHJpYnV0ZSBpZiBpdCB3YXMgbm90IGVuYWJsZWQgZm9yIHRoZSBzcGVjaWZpZWQgcHJvZ3JhbVxuICAgIC8vIE5PVEU6IHRoaXMgd2FzIG1vdmVkIG91dCBvZiB0aGUgaW5uZXIgbG9vcCBpbiBlbmFibGUoKSB0byBhc3Npc3Qgdy9WTSBvcHRpbWl6YXRpb25cbiAgICBkaXNhYmxlVW51c2VkQXR0cmlidXRlIChnbCwgbG9jYXRpb24sIHByb2dyYW0pIHtcbiAgICAgICAgaWYgKFZlcnRleExheW91dC5lbmFibGVkX2F0dHJpYnNbbG9jYXRpb25dICE9PSBwcm9ncmFtKSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xuICAgICAgICAgICAgZGVsZXRlIFZlcnRleExheW91dC5lbmFibGVkX2F0dHJpYnNbbG9jYXRpb25dO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlVmVydGV4RGF0YSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVydGV4RGF0YSh0aGlzKTtcbiAgICB9XG5cbn1cblxuLy8gVHJhY2sgY3VycmVudGx5IGVuYWJsZWQgYXR0cmlicywgYnkgdGhlIHByb2dyYW0gdGhleSBhcmUgYm91bmQgdG9cbi8vIFN0YXRpYyBjbGFzcyBwcm9wZXJ0eSB0byByZWZsZWN0IGdsb2JhbCBHTCBzdGF0ZVxuVmVydGV4TGF5b3V0LmVuYWJsZWRfYXR0cmlicyA9IHt9O1xuIiwiaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IFNjZW5lIGZyb20gJy4vc2NlbmUnO1xuaW1wb3J0IEdlbyBmcm9tICcuL2dlbyc7XG5cbi8vIEV4cG9ydHMgbXVzdCBhcHBlYXIgb3V0c2lkZSBhIGZ1bmN0aW9uLCBidXQgd2lsbCBvbmx5IGJlIGRlZmluZWQgaW4gbWFpbiB0aHJlYWQgKGJlbG93KVxuZXhwb3J0IHZhciBMZWFmbGV0TGF5ZXI7XG5leHBvcnQgZnVuY3Rpb24gbGVhZmxldExheWVyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZXh0ZW5kTGVhZmxldChvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kTGVhZmxldChvcHRpb25zKSB7XG5cbiAgICAvLyBJZiBMZWFmbGV0TGF5ZXIgaXMgYWxyZWFkeSBkZWZpbmVkIHdoZW4gdGhpcyBpcyBjYWxsZWQganVzdCByZXR1cm4gdGhhdCBpbW1lZGlhdGVseVxuICAgIC8vIGUuZy4gaWYgeW91IGNhbGwgbGVhZmxldExheWVyIG11bHRpcGxlIHRpbWVzICh3aGljaCBpcyB2YWxpZClcbiAgICBpZiAodHlwZW9mIExlYWZsZXRMYXllciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMZWFmbGV0TGF5ZXIob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gTGVhZmxldCBsYXllciBmdW5jdGlvbmFsaXR5IGlzIG9ubHkgZGVmaW5lZCBpbiBtYWluIHRocmVhZFxuICAgIGlmIChVdGlscy5pc01haW5UaHJlYWQpIHtcblxuICAgICAgICBsZXQgTCA9IG9wdGlvbnMubGVhZmxldCB8fCB3aW5kb3cuTDtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2UgYXJlIGV4dGVuZGluZyB0aGUgbGVhZmxldCAwLjcueCBUaWxlTGF5ZXIgY2xhc3MsIG9yIHRoZSBuZXdlclxuICAgICAgICAvLyBsZWFmbGV0IDEueCBHcmlkTGF5ZXIgY2xhc3MuXG4gICAgICAgIGxldCBsYXllckJhc2VDbGFzcyA9IEwuR3JpZExheWVyID8gTC5HcmlkTGF5ZXIgOiBMLlRpbGVMYXllcjtcbiAgICAgICAgbGV0IGxlYWZsZXRWZXJzaW9uID0gbGF5ZXJCYXNlQ2xhc3MgPT09IEwuR3JpZExheWVyID8gJzEueCcgOiAnMC43LngnO1xuICAgICAgICBsZXQgbGF5ZXJDbGFzc0NvbmZpZyA9IHt9O1xuXG4gICAgICAgIC8vIElmIGV4dGVuZGluZyBsZWFmbGV0IDAuNy54IFRpbGVMYXllciwgbWFrZSBhZGQvcmVtb3ZlIHRpbGUgbm8gb3BzXG4gICAgICAgIGlmIChsYXllckJhc2VDbGFzcyA9PT0gTC5UaWxlTGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyQ2xhc3NDb25maWcuX2FkZFRpbGUgPSBmdW5jdGlvbigpe307XG4gICAgICAgICAgICBsYXllckNsYXNzQ29uZmlnLl9yZW1vdmVUaWxlID0gZnVuY3Rpb24oKXt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGN1c3RvbSBsYXllciBtZXRob2RzXG4gICAgICAgIE9iamVjdC5hc3NpZ24obGF5ZXJDbGFzc0NvbmZpZywge1xuXG4gICAgICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaG93RGVidWcgPSAoIW9wdGlvbnMuc2hvd0RlYnVnID8gZmFsc2UgOiB0cnVlKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLndoZWVsRGVib3VuY2VUaW1lID0gb3B0aW9ucy53aGVlbERlYm91bmNlVGltZSB8fCA0MDtcblxuICAgICAgICAgICAgICAgIEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVNjZW5lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ob29rcyA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIEZvcmNlIGxlYWZsZXQgem9vbSBhbmltYXRpb25zIG9mZlxuICAgICAgICAgICAgICAgIHRoaXMuX3pvb21BbmltYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJvdW5jZVZpZXdSZXNldCA9IFV0aWxzLmRlYm91bmNlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ3pvb21lbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ21vdmVlbmQnKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMud2hlZWxEZWJvdW5jZVRpbWUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY3JlYXRlU2NlbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lID0gU2NlbmUuY3JlYXRlKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2NlbmUsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVdvcmtlcnM6IHRoaXMub3B0aW9ucy5udW1Xb3JrZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlVXBkYXRlOiB0aGlzLm9wdGlvbnMucHJlVXBkYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdFVwZGF0ZTogdGhpcy5vcHRpb25zLnBvc3RVcGRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51b3VzWm9vbTogKExlYWZsZXRMYXllci5sZWFmbGV0VmVyc2lvbiA9PT0gJzEueCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlnaERlbnNpdHlEaXNwbGF5OiB0aGlzLm9wdGlvbnMuaGlnaERlbnNpdHlEaXNwbGF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nTGV2ZWw6IHRoaXMub3B0aW9ucy5sb2dMZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkdmFuY2VkIG9wdGlvbiwgYXBwIHdpbGwgaGF2ZSB0byBtYW51YWxseSBjYWxsZWQgc2NlbmUudXBkYXRlKCkgcGVyIGZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlUmVuZGVyTG9vcDogdGhpcy5vcHRpb25zLmRpc2FibGVSZW5kZXJMb29wLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWR2YW5jZWQgb3B0aW9uLCB3aWxsIHJlcXVpcmUgbGlicmFyeSB0byBiZSBzZXJ2ZWQgYXMgc2FtZSBob3N0IGFzIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q3Jvc3NEb21haW5Xb3JrZXJzOiB0aGlzLm9wdGlvbnMuYWxsb3dDcm9zc0RvbWFpbldvcmtlcnNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBGaW5pc2ggaW5pdGlhbGl6aW5nIHNjZW5lIGFuZCBzZXR1cCBldmVudHMgd2hlbiBsYXllciBpcyBhZGRlZCB0byBtYXBcbiAgICAgICAgICAgIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNjZW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlU2NlbmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsYXllckJhc2VDbGFzcy5wcm90b3R5cGUub25BZGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuaG9va3MucmVzaXplID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1hcC5vbigncmVzaXplJywgdGhpcy5ob29rcy5yZXNpemUpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ob29rcy5tb3ZlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gbWFwLmdldENlbnRlcigpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3Lnpvb20gPSBNYXRoLm1pbihtYXAuZ2V0Wm9vbSgpLCBtYXAuZ2V0TWF4Wm9vbSgpIHx8IEdlby5tYXhfem9vbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5zZXRWaWV3KHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmltbWVkaWF0ZVJlZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJldmVyc2VUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWFwLm9uKCdtb3ZlJywgdGhpcy5ob29rcy5tb3ZlKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuaG9va3Muem9vbXN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuc3RhcnRab29tKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1hcC5vbignem9vbXN0YXJ0JywgdGhpcy5ob29rcy56b29tc3RhcnQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ob29rcy5kcmFnc3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUucGFubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtYXAub24oJ2RyYWdzdGFydCcsIHRoaXMuaG9va3MuZHJhZ3N0YXJ0KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuaG9va3MuZHJhZ2VuZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5wYW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtYXAub24oJ2RyYWdlbmQnLCB0aGlzLmhvb2tzLmRyYWdlbmQpO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgbGVhZmxldCB6b29tIGFuaW1hdGlvbnMgb2ZmXG4gICAgICAgICAgICAgICAgbWFwLl96b29tQW5pbWF0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIE1vZGlmeSBkZWZhdWx0IGxlYWZsZXQgc2Nyb2xsIHdoZWVsIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlTY3JvbGxXaGVlbEJlaGF2aW9yKG1hcCk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgR0wgY2FudmFzIHRvIGxheWVyIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIoKTtcblxuICAgICAgICAgICAgICAgIC8vIEluaXRpYWwgdmlld1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVmlldygpO1xuXG4gICAgICAgICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRhbmdyYW0gZXZlbnRzXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgICAgICBtb3ZlOiB0aGlzLm9uVGFuZ3JhbVZpZXdVcGRhdGUuYmluZCh0aGlzKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGxlYWZsZXQncyBleGlzdGluZyBldmVudCBzeXN0ZW0gYXMgdGhlIGNhbGxiYWNrIG1lY2hhbmlzbVxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUubG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV2ZXJzZVRyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2luaXQnKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgICAgIGxheWVyQmFzZUNsYXNzLnByb3RvdHlwZS5vblJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgbWFwLm9mZigncmVzaXplJywgdGhpcy5ob29rcy5yZXNpemUpO1xuICAgICAgICAgICAgICAgIG1hcC5vZmYoJ21vdmUnLCB0aGlzLmhvb2tzLm1vdmUpO1xuICAgICAgICAgICAgICAgIG1hcC5vZmYoJ3pvb21zdGFydCcsIHRoaXMuaG9va3Muem9vbXN0YXJ0KTtcbiAgICAgICAgICAgICAgICBtYXAub2ZmKCdkcmFnc3RhcnQnLCB0aGlzLmhvb2tzLmRyYWdzdGFydCk7XG4gICAgICAgICAgICAgICAgbWFwLm9mZignZHJhZ2VuZCcsIHRoaXMuaG9va3MuZHJhZ2VuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ob29rcyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gY29vcmRzLnggKyAnLycgKyBjb29yZHMueSArICcvJyArIGNvb3Jkcy56O1xuICAgICAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdkYXRhLXRpbGUta2V5Jywga2V5KTtcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUud2lkdGggPSAnMjU2cHgnO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSAnMjU2cHgnO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93RGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlYnVnX292ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS50ZXh0Q29udGVudCA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnX292ZXJsYXkuc3R5bGUubGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnX292ZXJsYXkuc3R5bGUudG9wID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS5jb2xvciA9ICd3aGl0ZSc7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnX292ZXJsYXkuc3R5bGUuZm9udFNpemUgPSAnMTZweCc7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnX292ZXJsYXkuc3R5bGUudGV4dE91dGxpbmUgPSAnMXB4ICMwMDAwMDAnO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z19vdmVybGF5LnN0eWxlLnBhZGRpbmcgPSAnOHB4JztcblxuICAgICAgICAgICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoZGVidWdfb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5ib3JkZXJTdHlsZSA9ICdzb2xpZCc7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5ib3JkZXJDb2xvciA9ICd3aGl0ZSc7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5ib3JkZXJXaWR0aCA9ICcxcHgnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBkaXY7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBNb2RpZnkgbGVhZmxldCdzIGRlZmF1bHQgc2Nyb2xsIHdoZWVsIGJlaGF2aW9yIHRvIGhhdmUgYSBtdWNoIG1vcmUgc2Vuc2l0dmUvY29udGludW91cyB6b29tXG4gICAgICAgICAgICAvLyBOb3RlOiB0aGlzIHNob3VsZCBiZSBkZXByZWNhdGVkIG9uY2UgbGVhZmxldCBjb250aW51b3VzIHpvb20gaXMgbW9yZSB3aWRlbHkgdXNlZCBhbmQgdGhlXG4gICAgICAgICAgICAvLyBkZWZhdWx0IGJlaGF2aW9yIGlzIHByZXN1bWFibHkgaW1wcm92ZWRcbiAgICAgICAgICAgIG1vZGlmeVNjcm9sbFdoZWVsQmVoYXZpb3I6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2VuZS5jb250aW51b3VzX3pvb20gJiYgbWFwLnNjcm9sbFdoZWVsWm9vbSAmJiB0aGlzLm9wdGlvbnMubW9kaWZ5U2Nyb2xsV2hlZWwgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXllciA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmFibGVkID0gbWFwLnNjcm9sbFdoZWVsWm9vbS5lbmFibGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuc2Nyb2xsV2hlZWxab29tLmRpc2FibGUoKTsgLy8gZGlzYWJsZSBiZWZvcmUgbW9kaWZ5aW5nXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBtb2RpZnkgcHJvdG90eXBlIGFuZCBjdXJyZW50IGluc3RhbmNlLCBzbyBhZGQvcmVtb3ZlIGhvb2tzIHdvcmsgb24gZXhpc3RpbmcgcmVmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgICBMLk1hcC5TY3JvbGxXaGVlbFpvb20uX29uV2hlZWxTY3JvbGwgPSBtYXAuc2Nyb2xsV2hlZWxab29tLl9vbldoZWVsU2Nyb2xsID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9kaWZ5IHRvIHNraXAgZGVib3VuY2UsIGFzIGl0IHNlZW1zIHRvIGNhdXNlIGFuaW1hdGlvbi1zeW5jIGlzc3VlcyBpbiBDaHJvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpdGggVGFuZ3JhbSBjb250aW51b3VzIHJlbmRlcmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVsdGEgKz0gTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdE1vdXNlUG9zID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGVyZm9ybVpvb20oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEwuRG9tRXZlbnQuc3RvcChlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBMLk1hcC5TY3JvbGxXaGVlbFpvb20uX3BlcmZvcm1ab29tID0gbWFwLnNjcm9sbFdoZWVsWm9vbS5fcGVyZm9ybVpvb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhID0gdGhpcy5fZGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbSA9IG1hcC5nZXRab29tKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5zdG9wKCk7IC8vIHN0b3AgcGFubmluZyBhbmQgZmx5IGFuaW1hdGlvbnMgaWYgYW55XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHRoaXMgaXMgdGhlIG9ubHkgcmVhbCBtb2RpZmljYXRpb24gdG8gZGVmYXVsdCBsZWFmbGV0IGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSAvPSA0MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSBNYXRoLm1heChNYXRoLm1pbihkZWx0YSwgNCksIC00KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhID0gbWFwLl9saW1pdFpvb20oem9vbSArIGRlbHRhKSAtIHpvb207XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlbHRhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGVsdGEpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXAub3B0aW9ucy5zY3JvbGxXaGVlbFpvb20gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLnNldFpvb20oem9vbSArIGRlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLnNldFpvb21Bcm91bmQodGhpcy5fbGFzdE1vdXNlUG9zLCB6b29tICsgZGVsdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci5kZWJvdW5jZVZpZXdSZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuc2Nyb2xsV2hlZWxab29tLmVuYWJsZSgpOyAvLyByZS1lbmFibGUgYWZ0ZXIgbW9kaWZ5aW5nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB1cGRhdGVWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9tYXAuZ2V0Q2VudGVyKCk7XG4gICAgICAgICAgICAgICAgdmlldy56b29tID0gTWF0aC5taW4odGhpcy5fbWFwLmdldFpvb20oKSwgdGhpcy5fbWFwLmdldE1heFpvb20oKSB8fCBHZW8ubWF4X3pvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuc2V0Vmlldyh2aWV3KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHVwZGF0ZVNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX21hcC5nZXRTaXplKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5yZXNpemVNYXAoc2l6ZS54LCBzaXplLnkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25UYW5ncmFtVmlld1VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAuc2V0VmlldyhbdGhpcy5zY2VuZS5jZW50ZXIubGF0LCB0aGlzLnNjZW5lLmNlbnRlci5sbmddLCB0aGlzLnNjZW5lLnpvb20sIHsgYW5pbWF0ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXZlcnNlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IGZhbHNlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNjZW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS51cGRhdGUoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFJldmVyc2UgdGhlIENTUyBwb3NpdGlvbmluZyBMZWFmbGV0IGFwcGxpZXMgdG8gdGhlIGxheWVyLCBzaW5jZSBUYW5ncmFtJ3MgV2ViR0wgY2FudmFzXG4gICAgICAgICAgICAvLyBpcyBleHBlY3RlZCB0byBiZSAnYWJzb2x1dGVseScgcG9zaXRpb25lZC5cbiAgICAgICAgICAgIHJldmVyc2VUcmFuc2Zvcm06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX21hcCB8fCAhdGhpcy5zY2VuZSB8fCAhdGhpcy5zY2VuZS5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0b3BfbGVmdCA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChbMCwgMF0pO1xuICAgICAgICAgICAgICAgIEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLnNjZW5lLmNvbnRhaW5lciwgdG9wX2xlZnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgbGF5ZXIgY2xhc3NcbiAgICAgICAgTGVhZmxldExheWVyID0gbGF5ZXJCYXNlQ2xhc3MuZXh0ZW5kKGxheWVyQ2xhc3NDb25maWcpO1xuXG4gICAgICAgIC8vIFBvbHlmaWxsIHNvbWUgMS4wIG1ldGhvZHNcbiAgICAgICAgaWYgKHR5cGVvZiBMZWFmbGV0TGF5ZXIucmVtb3ZlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBMZWFmbGV0TGF5ZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ3JlbW92ZScpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIExlYWZsZXRMYXllci5sYXllckJhc2VDbGFzcyA9IGxheWVyQmFzZUNsYXNzO1xuICAgICAgICBMZWFmbGV0TGF5ZXIubGVhZmxldFZlcnNpb24gPSBsZWFmbGV0VmVyc2lvbjtcblxuICAgICAgICByZXR1cm4gbmV3IExlYWZsZXRMYXllcihvcHRpb25zKTtcbiAgICB9XG59XG4iLCIvKmdsb2JhbCBMaWdodCAqL1xuaW1wb3J0IFNoYWRlclByb2dyYW0gZnJvbSAnLi9nbC9zaGFkZXJfcHJvZ3JhbSc7XG5pbXBvcnQgc2hhZGVyU291cmNlcyBmcm9tICcuL2dsL3NoYWRlcl9zb3VyY2VzJzsgLy8gYnVpbHQtaW4gc2hhZGVyc1xuaW1wb3J0IEdMU0wgZnJvbSAnLi9nbC9nbHNsJztcbmltcG9ydCBHZW8gZnJvbSAnLi9nZW8nO1xuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfcGFyc2VyJztcblxuLy8gQWJzdHJhY3QgbGlnaHRcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpZ2h0IHtcblxuICAgIGNvbnN0cnVjdG9yIChzY2VuZSwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5hbWJpZW50ID09IG51bGwgfHwgdHlwZW9mIGNvbmZpZy5hbWJpZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5hbWJpZW50ID0gR0xTTC5leHBhbmRWZWM0KGNvbmZpZy5hbWJpZW50IHx8IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hbWJpZW50ID0gU3R5bGVQYXJzZXIucGFyc2VDb2xvcihjb25maWcuYW1iaWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLmRpZmZ1c2UgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLmRpZmZ1c2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmRpZmZ1c2UgPSBHTFNMLmV4cGFuZFZlYzQoY29uZmlnLmRpZmZ1c2UgIT0gbnVsbCA/IGNvbmZpZy5kaWZmdXNlIDogMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpZmZ1c2UgPSBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKGNvbmZpZy5kaWZmdXNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuc3BlY3VsYXIgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLnNwZWN1bGFyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5zcGVjdWxhciA9IEdMU0wuZXhwYW5kVmVjNChjb25maWcuc3BlY3VsYXIgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNwZWN1bGFyID0gU3R5bGVQYXJzZXIucGFyc2VDb2xvcihjb25maWcuc3BlY3VsYXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgbGlnaHQgYnkgdHlwZSBuYW1lLCBmYWN0b3J5LXN0eWxlXG4gICAgLy8gJ2NvbmZpZycgbXVzdCBpbmNsdWRlICduYW1lJyBhbmQgJ3R5cGUnLCBhbG9uZyB3aXRoIGFueSBvdGhlciB0eXBlLXNwZWNpZmljIHByb3BlcnRpZXNcbiAgICBzdGF0aWMgY3JlYXRlIChzY2VuZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChMaWdodC50eXBlc1tjb25maWcudHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlnaHQudHlwZXNbY29uZmlnLnR5cGVdKHNjZW5lLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IGxpZ2h0IGZvciBhIHN0eWxlOiBmcmFnbWVudCBsaWdodGluZywgdmVydGV4IGxpZ2h0aW5nLCBvciBub25lXG4gICAgc3RhdGljIHNldE1vZGUgKG1vZGUsIHN0eWxlKSB7XG4gICAgICAgIGlmIChtb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBtb2RlID0gJ2ZyYWdtZW50JztcbiAgICAgICAgfVxuICAgICAgICBtb2RlID0gTGlnaHQuZW5hYmxlZCAmJiAoKG1vZGUgIT0gbnVsbCkgPyBtb2RlIDogJ2ZyYWdtZW50Jyk7IC8vIGRlZmF1bHQgdG8gZnJhZ21lbnQgbGlnaHRpbmdcbiAgICAgICAgc3R5bGUuZGVmaW5lc1snVEFOR1JBTV9MSUdIVElOR19GUkFHTUVOVCddID0gKG1vZGUgPT09ICdmcmFnbWVudCcpO1xuICAgICAgICBzdHlsZS5kZWZpbmVzWydUQU5HUkFNX0xJR0hUSU5HX1ZFUlRFWCddID0gKG1vZGUgPT09ICd2ZXJ0ZXgnKTtcbiAgICB9XG5cbiAgICAvLyBJbmplY3QgYWxsIHByb3ZpZGVkIGxpZ2h0IGRlZmluaXRpb25zLCBhbmQgY2FsY3VsYXRlIGN1bXVsYXRpdmUgbGlnaHQgZnVuY3Rpb25cbiAgICBzdGF0aWMgaW5qZWN0IChsaWdodHMpIHtcbiAgICAgICAgLy8gQ2xlYXIgcHJldmlvdXMgaW5qZWN0aW9uc1xuICAgICAgICBTaGFkZXJQcm9ncmFtLnJlbW92ZUJsb2NrKExpZ2h0LmJsb2NrKTtcblxuICAgICAgICAvLyBJZiBsaWdodGluZyBpcyBnbG9iYWxseSBkaXNhYmxlZCwgbm90aGluZyBpcyBpbmplY3RlZCAobW9zdGx5IGZvciBkZWJ1Z2dpbmcgb3IgbGl2ZSBlZGl0aW5nKVxuICAgICAgICBpZiAoIUxpZ2h0LmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnN0cnVjdCBjb2RlIHRvIGNhbGN1bGF0ZSBlYWNoIGxpZ2h0IGluc3RhbmNlXG4gICAgICAgIGxldCBjYWxjdWxhdGVMaWdodHMgPSBcIlwiO1xuICAgICAgICBpZiAobGlnaHRzICYmIE9iamVjdC5rZXlzKGxpZ2h0cykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gQ29sbGVjdCB1bmlxdWVzIHR5cGVzIG9mIGxpZ2h0c1xuICAgICAgICAgICAgbGV0IHR5cGVzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBsaWdodF9uYW1lIGluIGxpZ2h0cykge1xuICAgICAgICAgICAgICAgIHR5cGVzW2xpZ2h0c1tsaWdodF9uYW1lXS50eXBlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluamVjdCBlYWNoIHR5cGUgb2YgbGlnaHRcbiAgICAgICAgICAgIGZvciAobGV0IHR5cGUgaW4gdHlwZXMpIHtcbiAgICAgICAgICAgICAgICBMaWdodC50eXBlc1t0eXBlXS5pbmplY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5qZWN0IHBlci1pbnN0YW5jZSBibG9ja3MgYW5kIGNvbnN0cnVjdCB0aGUgbGlzdCBvZiBmdW5jdGlvbnMgdG8gY2FsY3VsYXRlIGVhY2ggbGlnaHRcbiAgICAgICAgICAgIGZvciAobGV0IGxpZ2h0X25hbWUgaW4gbGlnaHRzKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmaW5lIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgbGlnaHRzW2xpZ2h0X25hbWVdLmluamVjdCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjYWxjdWxhdGlvbiBmdW5jdGlvbiB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZUxpZ2h0cyArPSBgY2FsY3VsYXRlTGlnaHQoJHtsaWdodF9uYW1lfSwgX2V5ZVRvUG9pbnQsIF9ub3JtYWwpO1xcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBubyBsaWdodCBpcyBkZWZpbmVkLCB1c2UgMTAwJSBvbW5pZGlyZWN0aW9uYWwgZGlmZnVzZSBsaWdodFxuICAgICAgICAgICAgY2FsY3VsYXRlTGlnaHRzID0gYFxuICAgICAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VcbiAgICAgICAgICAgICAgICAgICAgbGlnaHRfYWNjdW11bGF0b3JfZGlmZnVzZSA9IHZlYzQoMS4pO1xuICAgICAgICAgICAgICAgICNlbmRpZlxuICAgICAgICAgICAgYDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdsdWUgdG9nZXRoZXIgdGhlIGZpbmFsIGxpZ2h0aW5nIGZ1bmN0aW9uIHRoYXQgc3VtcyBhbGwgdGhlIGxpZ2h0c1xuICAgICAgICBsZXQgY2FsY3VsYXRlRnVuY3Rpb24gPSBgXG4gICAgICAgICAgICB2ZWM0IGNhbGN1bGF0ZUxpZ2h0aW5nKGluIHZlYzMgX2V5ZVRvUG9pbnQsIGluIHZlYzMgX25vcm1hbCwgaW4gdmVjNCBfY29sb3IpIHtcblxuICAgICAgICAgICAgICAgIC8vIERvIGluaXRpYWwgbWF0ZXJpYWwgY2FsY3VsYXRpb25zIG92ZXIgbm9ybWFsLCBlbWlzc2lvbiwgYW1iaWVudCwgZGlmZnVzZSBhbmQgc3BlY3VsYXIgdmFsdWVzXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlTWF0ZXJpYWwoX2V5ZVRvUG9pbnQsX25vcm1hbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBVbiByb2xsIHRoZSBsb29wIG9mIGluZGl2aWR1YWwgbGlndGhzIHRvIGNhbGN1bGF0ZVxuICAgICAgICAgICAgICAgICR7Y2FsY3VsYXRlTGlnaHRzfVxuXG4gICAgICAgICAgICAgICAgLy8gIEZpbmFsIGxpZ2h0IGludGVuc2l0eSBjYWxjdWxhdGlvblxuICAgICAgICAgICAgICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XG5cbiAgICAgICAgICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9FTUlTU0lPTlxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IG1hdGVyaWFsLmVtaXNzaW9uO1xuICAgICAgICAgICAgICAgICNlbmRpZlxuXG4gICAgICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfQU1CSUVOVFxuICAgICAgICAgICAgICAgICAgICBjb2xvciArPSBsaWdodF9hY2N1bXVsYXRvcl9hbWJpZW50ICogX2NvbG9yICogbWF0ZXJpYWwuYW1iaWVudDtcbiAgICAgICAgICAgICAgICAjZWxzZVxuICAgICAgICAgICAgICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciArPSBsaWdodF9hY2N1bXVsYXRvcl9hbWJpZW50ICogX2NvbG9yICogbWF0ZXJpYWwuZGlmZnVzZTtcbiAgICAgICAgICAgICAgICAgICAgI2VuZGlmXG4gICAgICAgICAgICAgICAgI2VuZGlmXG5cbiAgICAgICAgICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yICs9IGxpZ2h0X2FjY3VtdWxhdG9yX2RpZmZ1c2UgKiBfY29sb3IgKiBtYXRlcmlhbC5kaWZmdXNlO1xuICAgICAgICAgICAgICAgICNlbmRpZlxuXG4gICAgICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgKz0gbGlnaHRfYWNjdW11bGF0b3Jfc3BlY3VsYXIgKiBtYXRlcmlhbC5zcGVjdWxhcjtcbiAgICAgICAgICAgICAgICAjZW5kaWZcblxuICAgICAgICAgICAgICAgIC8vIENsYW1wIGZpbmFsIGNvbG9yXG4gICAgICAgICAgICAgICAgY29sb3IgPSBjbGFtcChjb2xvciwgMC4wLCAxLjApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICAgICAgfWA7XG5cbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5hZGRCbG9jayhMaWdodC5ibG9jaywgY2FsY3VsYXRlRnVuY3Rpb24pO1xuICAgIH1cblxuICAgIC8vIENvbW1vbiBpbnN0YW5jZSBkZWZpbml0aW9uXG4gICAgaW5qZWN0ICgpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gIGBcbiAgICAgICAgICAgIHVuaWZvcm0gJHt0aGlzLnN0cnVjdF9uYW1lfSB1XyR7dGhpcy5uYW1lfTtcbiAgICAgICAgICAgICR7dGhpcy5zdHJ1Y3RfbmFtZX0gJHt0aGlzLm5hbWV9O1xuICAgICAgICAgICAgYDtcbiAgICAgICAgbGV0IGFzc2lnbiA9IGBcbiAgICAgICAgICAgICR7dGhpcy5uYW1lfSA9IHVfJHt0aGlzLm5hbWV9O1xcblxuICAgICAgICBgO1xuXG4gICAgICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soTGlnaHQuYmxvY2ssIGluc3RhbmNlKTtcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5hZGRCbG9jaygnc2V0dXAnLCBhc3NpZ24pO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBtZXRob2QgY2FsbGVkIG9uY2UgcGVyIGZyYW1lXG4gICAgdXBkYXRlICgpIHtcbiAgICB9XG5cbiAgICAvLyBDYWxsZWQgb25jZSBwZXIgZnJhbWUgcGVyIHByb2dyYW0gKGUuZy4gZm9yIG1haW4gcmVuZGVyIHBhc3MsIHRoZW4gZm9yIGVhY2ggYWRkaXRpb25hbFxuICAgIC8vIHBhc3MgZm9yIGZlYXR1cmUgc2VsZWN0aW9uLCBldGMuKVxuICAgIHNldHVwUHJvZ3JhbSAoX3Byb2dyYW0pIHtcbiAgICAgICAgLy8gIFRocmVlIGNvbW1vbiBsaWdodCBwcm9wZXJ0aWVzXG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzRmdicsIGB1XyR7dGhpcy5uYW1lfS5hbWJpZW50YCwgdGhpcy5hbWJpZW50KTtcbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnNGZ2JywgYHVfJHt0aGlzLm5hbWV9LmRpZmZ1c2VgLCB0aGlzLmRpZmZ1c2UpO1xuICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCc0ZnYnLCBgdV8ke3RoaXMubmFtZX0uc3BlY3VsYXJgLCB0aGlzLnNwZWN1bGFyKTtcbiAgICB9XG5cbn1cblxuTGlnaHQudHlwZXMgPSB7fTsgLy8gcmVmZXJlbmNlcyB0byBzdWJjbGFzc2VzIGJ5IHNob3J0IG5hbWVcbkxpZ2h0LmJsb2NrID0gJ2xpZ2h0aW5nJzsgLy8gc2hhZGVyIGJsb2NrIG5hbWVcbkxpZ2h0LmVuYWJsZWQgPSB0cnVlOyAvLyBsaWdodGluZyBjYW4gYmUgZ2xvYmFsbHkgZW5hYmxlZC9kaXNhYmxlZFxuXG5cbi8vIExpZ2h0IHN1YmNsYXNzZXNcbmNsYXNzIEFtYmllbnRMaWdodCBleHRlbmRzIExpZ2h0IHtcblxuICAgIGNvbnN0cnVjdG9yKHNjZW5lLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIoc2NlbmUsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdhbWJpZW50JztcbiAgICAgICAgdGhpcy5zdHJ1Y3RfbmFtZSA9ICdBbWJpZW50TGlnaHQnO1xuICAgIH1cblxuICAgIC8vIEluamVjdCBzdHJ1Y3QgYW5kIGNhbGN1bGF0ZSBmdW5jdGlvblxuICAgIHN0YXRpYyBpbmplY3QoKSB7XG4gICAgICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soTGlnaHQuYmxvY2ssIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvYW1iaWVudExpZ2h0J10pO1xuICAgIH1cblxuICAgIHNldHVwUHJvZ3JhbSAoX3Byb2dyYW0pIHtcbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnNGZ2JywgYHVfJHt0aGlzLm5hbWV9LmFtYmllbnRgLCB0aGlzLmFtYmllbnQpO1xuICAgIH1cblxufVxuTGlnaHQudHlwZXNbJ2FtYmllbnQnXSA9IEFtYmllbnRMaWdodDtcblxuY2xhc3MgRGlyZWN0aW9uYWxMaWdodCBleHRlbmRzIExpZ2h0IHtcblxuICAgIGNvbnN0cnVjdG9yKHNjZW5lLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIoc2NlbmUsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdkaXJlY3Rpb25hbCc7XG4gICAgICAgIHRoaXMuc3RydWN0X25hbWUgPSAnRGlyZWN0aW9uYWxMaWdodCc7XG5cbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAoY29uZmlnLmRpcmVjdGlvbiB8fCBbMC4yLCAwLjcsIC0wLjVdKS5tYXAocGFyc2VGbG9hdCk7IC8vIFt4LCB5LCB6XVxuICAgIH1cblxuICAgIC8vIEluamVjdCBzdHJ1Y3QgYW5kIGNhbGN1bGF0ZSBmdW5jdGlvblxuICAgIHN0YXRpYyBpbmplY3QoKSB7XG4gICAgICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soTGlnaHQuYmxvY2ssIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvZGlyZWN0aW9uYWxMaWdodCddKTtcbiAgICB9XG5cbiAgICBzZXR1cFByb2dyYW0gKF9wcm9ncmFtKSB7XG4gICAgICAgIHN1cGVyLnNldHVwUHJvZ3JhbShfcHJvZ3JhbSk7XG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzNmdicsIGB1XyR7dGhpcy5uYW1lfS5kaXJlY3Rpb25gLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgfVxuXG59XG5MaWdodC50eXBlc1snZGlyZWN0aW9uYWwnXSA9IERpcmVjdGlvbmFsTGlnaHQ7XG5cblxuY2xhc3MgUG9pbnRMaWdodCBleHRlbmRzIExpZ2h0IHtcblxuICAgIGNvbnN0cnVjdG9yIChzY2VuZSwgY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKHNjZW5lLCBjb25maWcpO1xuICAgICAgICB0aGlzLnR5cGUgPSAncG9pbnQnO1xuICAgICAgICB0aGlzLnN0cnVjdF9uYW1lID0gJ1BvaW50TGlnaHQnO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBjb25maWcucG9zaXRpb24gfHwgWzAsIDAsIDBdO1xuICAgICAgICB0aGlzLnBvc2l0aW9uX2V5ZSA9IFtdOyAvLyBwb3NpdGlvbiBpbiBleWVzcGFjZVxuICAgICAgICB0aGlzLm9yaWdpbiA9IGNvbmZpZy5vcmlnaW4gfHwgJ3dvcmxkJztcbiAgICAgICAgdGhpcy5hdHRlbnVhdGlvbiA9ICFpc05hTihwYXJzZUZsb2F0KGNvbmZpZy5hdHRlbnVhdGlvbikpID8gcGFyc2VGbG9hdChjb25maWcuYXR0ZW51YXRpb24pIDogMDtcblxuICAgICAgICBpZiAoY29uZmlnLnJhZGl1cykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLnJhZGl1cykgJiYgY29uZmlnLnJhZGl1cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhZGl1cyA9IGNvbmZpZy5yYWRpdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhZGl1cyA9IFtudWxsLCBjb25maWcucmFkaXVzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluamVjdCBzdHJ1Y3QgYW5kIGNhbGN1bGF0ZSBmdW5jdGlvblxuICAgIHN0YXRpYyBpbmplY3QgKCkge1xuICAgICAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKExpZ2h0LmJsb2NrLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3BvaW50TGlnaHQnXSk7XG4gICAgfVxuXG4gICAgLy8gSW5qZWN0IGlzbnRhbmNlLXNwZWNpZmljIHNldHRpbmdzXG4gICAgaW5qZWN0KCkge1xuICAgICAgICBzdXBlci5pbmplY3QoKTtcblxuICAgICAgICBTaGFkZXJQcm9ncmFtLmRlZmluZXNbJ1RBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9FWFBPTkVOVCddID0gKHRoaXMuYXR0ZW51YXRpb24gIT09IDApO1xuICAgICAgICBTaGFkZXJQcm9ncmFtLmRlZmluZXNbJ1RBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9JTk5FUl9SQURJVVMnXSA9ICh0aGlzLnJhZGl1cyAhPSBudWxsICYmIHRoaXMucmFkaXVzWzBdICE9IG51bGwpO1xuICAgICAgICBTaGFkZXJQcm9ncmFtLmRlZmluZXNbJ1RBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVMnXSA9ICh0aGlzLnJhZGl1cyAhPSBudWxsKTtcbiAgICB9XG5cbiAgICB1cGRhdGUgKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUV5ZVBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlRXllUG9zaXRpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vcmlnaW4gPT09ICd3b3JsZCcpIHtcbiAgICAgICAgICAgIC8vIEZvciB3b3JsZCBvcmlnaW4sIGZvcm1hdCBpczogW2xvbmdpdHVkZSwgbGF0aXR1ZGUsIG1ldGVycyAoZGVmYXVsdCkgb3IgcGl4ZWxzIHcvcHggdW5pdHNdXG5cbiAgICAgICAgICAgIC8vIE1vdmUgbGlnaHQncyB3b3JsZCBwb3NpdGlvbiBpbnRvIGNhbWVyYSBzcGFjZVxuICAgICAgICAgICAgbGV0IFt4LCB5XSA9IEdlby5sYXRMbmdUb01ldGVycyh0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25fZXllWzBdID0geCAtIHRoaXMuc2NlbmUuY2FtZXJhLnBvc2l0aW9uX21ldGVyc1swXTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25fZXllWzFdID0geSAtIHRoaXMuc2NlbmUuY2FtZXJhLnBvc2l0aW9uX21ldGVyc1sxXTtcblxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbl9leWVbMl0gPSBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModGhpcy5wb3NpdGlvblsyXSwgeyB6b29tOiB0aGlzLnNjZW5lLnpvb20gfSk7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uX2V5ZVsyXSA9IHRoaXMucG9zaXRpb25fZXllWzJdIC0gdGhpcy5zY2VuZS5jYW1lcmEucG9zaXRpb25fbWV0ZXJzWzJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2dyb3VuZCcgfHwgdGhpcy5vcmlnaW4gPT09ICdjYW1lcmEnKSB7XG4gICAgICAgICAgICAvLyBGb3IgY2FtZXJhIG9yIGdyb3VuZCBvcmlnaW4sIGZvcm1hdCBpczogW3gsIHksIHpdIGluIG1ldGVycyAoZGVmYXVsdCkgb3IgcGl4ZWxzIHcvcHggdW5pdHNcblxuICAgICAgICAgICAgLy8gTGlnaHQgaXMgaW4gY2FtZXJhIHNwYWNlIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25fZXllID0gU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHRoaXMucG9zaXRpb24sIHsgem9vbTogdGhpcy5zY2VuZS56b29tIH0pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdncm91bmQnKSB7XG4gICAgICAgICAgICAgICAgLy8gTGVhdmUgbGlnaHQncyB4eSBpbiBjYW1lcmEgc3BhY2UsIGJ1dCB6IG5lZWRzIHRvIGJlIG1vdmVkIHJlbGF0aXZlIHRvIGdyb3VuZCBwbGFuZVxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25fZXllWzJdID0gdGhpcy5wb3NpdGlvbl9leWVbMl0gLSB0aGlzLnNjZW5lLmNhbWVyYS5wb3NpdGlvbl9tZXRlcnNbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXR1cFByb2dyYW0gKF9wcm9ncmFtKSB7XG4gICAgICAgIHN1cGVyLnNldHVwUHJvZ3JhbShfcHJvZ3JhbSk7XG5cbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnNGYnLCBgdV8ke3RoaXMubmFtZX0ucG9zaXRpb25gLFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbl9leWVbMF0sIHRoaXMucG9zaXRpb25fZXllWzFdLCB0aGlzLnBvc2l0aW9uX2V5ZVsyXSwgMSk7XG5cbiAgICAgICAgaWYoU2hhZGVyUHJvZ3JhbS5kZWZpbmVzWydUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fRVhQT05FTlQnXSkge1xuICAgICAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnMWYnLCBgdV8ke3RoaXMubmFtZX0uYXR0ZW51YXRpb25FeHBvbmVudGAsIHRoaXMuYXR0ZW51YXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoU2hhZGVyUHJvZ3JhbS5kZWZpbmVzWydUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTJ10pIHtcbiAgICAgICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzFmJywgYHVfJHt0aGlzLm5hbWV9LmlubmVyUmFkaXVzYCxcbiAgICAgICAgICAgICAgICBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModGhpcy5yYWRpdXNbMF0sIHsgem9vbTogdGhpcy5zY2VuZS56b29tIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKFNoYWRlclByb2dyYW0uZGVmaW5lc1snVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVUyddKSB7XG4gICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCcxZicsIGB1XyR7dGhpcy5uYW1lfS5vdXRlclJhZGl1c2AsXG4gICAgICAgICAgICAgICAgU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHRoaXMucmFkaXVzWzFdLCB7IHpvb206IHRoaXMuc2NlbmUuem9vbSB9KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5MaWdodC50eXBlc1sncG9pbnQnXSA9IFBvaW50TGlnaHQ7XG5cblxuY2xhc3MgU3BvdExpZ2h0IGV4dGVuZHMgUG9pbnRMaWdodCB7XG5cbiAgICBjb25zdHJ1Y3RvciAoc2NlbmUsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihzY2VuZSwgY29uZmlnKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3Nwb3RsaWdodCc7XG4gICAgICAgIHRoaXMuc3RydWN0X25hbWUgPSAnU3BvdExpZ2h0JztcblxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IChjb25maWcuZGlyZWN0aW9uIHx8IFswLCAwLCAtMV0pLm1hcChwYXJzZUZsb2F0KTsgLy8gW3gsIHksIHpdXG4gICAgICAgIHRoaXMuZXhwb25lbnQgPSBjb25maWcuZXhwb25lbnQgPyBwYXJzZUZsb2F0KGNvbmZpZy5leHBvbmVudCkgOiAwLjI7XG4gICAgICAgIHRoaXMuYW5nbGUgPSBjb25maWcuYW5nbGUgPyBwYXJzZUZsb2F0KGNvbmZpZy5hbmdsZSkgOiAyMDtcbiAgICB9XG5cbiAgICAvLyBJbmplY3Qgc3RydWN0IGFuZCBjYWxjdWxhdGUgZnVuY3Rpb25cbiAgICBzdGF0aWMgaW5qZWN0ICgpIHtcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5hZGRCbG9jayhMaWdodC5ibG9jaywgc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9zcG90TGlnaHQnXSk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9ncmFtIChfcHJvZ3JhbSkge1xuICAgICAgICBzdXBlci5zZXR1cFByb2dyYW0oX3Byb2dyYW0pO1xuXG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzNmdicsIGB1XyR7dGhpcy5uYW1lfS5kaXJlY3Rpb25gLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzFmJywgYHVfJHt0aGlzLm5hbWV9LnNwb3RDb3NDdXRvZmZgLCBNYXRoLmNvcyh0aGlzLmFuZ2xlICogMy4xNDE1OSAvIDE4MCkpO1xuICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCcxZicsIGB1XyR7dGhpcy5uYW1lfS5zcG90RXhwb25lbnRgLCB0aGlzLmV4cG9uZW50KTtcbiAgICB9XG5cbn1cbkxpZ2h0LnR5cGVzWydzcG90bGlnaHQnXSA9IFNwb3RMaWdodDtcbiIsIi8qZ2xvYmFsIE1hdGVyaWFsICovXG5pbXBvcnQgc2hhZGVyU291cmNlcyBmcm9tICcuL2dsL3NoYWRlcl9zb3VyY2VzJzsgLy8gYnVpbHQtaW4gc2hhZGVyc1xuaW1wb3J0IEdMU0wgZnJvbSAnLi9nbC9nbHNsJztcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX3BhcnNlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdGVyaWFsIHtcbiAgICBjb25zdHJ1Y3RvciAoY29uZmlnKSB7XG5cbiAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgYWxsIGhhdmUgdGhlIHNhbWUgZGVmYXVsdHMsIHNvIHRoZXkgY2FuIGJlIHNldCBpbiBidWxrXG4gICAgICAgIGZvciAobGV0IHByb3Agb2YgWydlbWlzc2lvbicsICdhbWJpZW50JywgJ2RpZmZ1c2UnLCAnc3BlY3VsYXInXSkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ1twcm9wXS50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlOiBjb25maWdbcHJvcF0udGV4dHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNvbmZpZ1twcm9wXS5tYXBwaW5nIHx8ICdzcGhlcmVtYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGU6IEdMU0wuZXhwYW5kVmVjMyhjb25maWdbcHJvcF0uc2NhbGUgIT0gbnVsbCA/IGNvbmZpZ1twcm9wXS5zY2FsZSA6IDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBHTFNMLmV4cGFuZFZlYzQoY29uZmlnW3Byb3BdLmFtb3VudCAhPSBudWxsID8gY29uZmlnW3Byb3BdLmFtb3VudCA6IDEpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb25maWdbcHJvcF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcF0gPSB7IGFtb3VudDogR0xTTC5leHBhbmRWZWM0KGNvbmZpZ1twcm9wXSkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbmZpZ1twcm9wXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wXSA9IHsgYW1vdW50OiBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKGNvbmZpZ1twcm9wXSkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcF0gPSBjb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXh0cmEgc3BlY3VsYXIgcHJvcHNcbiAgICAgICAgaWYgKHRoaXMuc3BlY3VsYXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3BlY3VsYXIuc2hpbmluZXNzID0gY29uZmlnLnNoaW5pbmVzcyA/IHBhcnNlRmxvYXQoY29uZmlnLnNoaW5pbmVzcykgOiAwLjI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3JtYWwgbWFwcGluZ1xuICAgICAgICBpZiAoY29uZmlnLm5vcm1hbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbCA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlOiBjb25maWcubm9ybWFsLnRleHR1cmUsXG4gICAgICAgICAgICAgICAgbWFwcGluZzogY29uZmlnLm5vcm1hbC5tYXBwaW5nIHx8ICd0cmlwbGFuYXInLFxuICAgICAgICAgICAgICAgIHNjYWxlOiBHTFNMLmV4cGFuZFZlYzMoY29uZmlnLm5vcm1hbC5zY2FsZSAhPSBudWxsID8gY29uZmlnLm5vcm1hbC5zY2FsZSA6IDEpLFxuICAgICAgICAgICAgICAgIGFtb3VudDogY29uZmlnLm5vcm1hbC5hbW91bnQgIT0gbnVsbCA/IGNvbmZpZy5ub3JtYWwuYW1vdW50IDogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERldGVybWluZSBpZiBhIG1hdGVyaWFsIGNvbmZpZyBibG9jayBoYXMgc3VmZmljaWVudCBwcm9wZXJ0aWVzIHRvIGNyZWF0ZSBhIG1hdGVyaWFsXG4gICAgc3RhdGljIGlzVmFsaWQgKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuZW1pc3Npb24gPT0gbnVsbCAmJlxuICAgICAgICAgICAgY29uZmlnLmFtYmllbnQgPT0gbnVsbCAmJlxuICAgICAgICAgICAgY29uZmlnLmRpZmZ1c2UgPT0gbnVsbCAmJlxuICAgICAgICAgICAgY29uZmlnLnNwZWN1bGFyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGluamVjdCAoc3R5bGUpIHtcbiAgICAgICAgLy8gRm9yIGVhY2ggcHJvcGVydHksIHNldHMgZGVmaW5lcyB0byBjb25maWd1cmUgdGV4dHVyZSBtYXBwaW5nLCB3aXRoIGEgcGF0dGVybiBsaWtlOlxuICAgICAgICAvLyAgIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRSwgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFX1RFWFRVUkUsIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRV9URVhUVVJFX1NQSEVSRU1BUFxuICAgICAgICAvLyBBbHNvIHNldHMgZmxhZ3MgdG8ga2VlcCB0cmFjayBvZiBlYWNoIHVuaXF1ZSBtYXBwaW5nIHR5cGUgYmVpbmcgdXNlZCwgZS5nLjpcbiAgICAgICAgLy8gICBUQU5HUkFNX01BVEVSSUFMX1RFWFRVUkVfU1BIRVJFTUFQXG4gICAgICAgIC8vIEVuYWJsZXMgdGV4dHVyZSBjb29yZGluYXRlcyBpZiBuZWVkZWQgYW5kIG5vdCBhbHJlYWR5IG9uXG4gICAgICAgIGZvciAobGV0IHByb3Agb2YgWydlbWlzc2lvbicsICdhbWJpZW50JywgJ2RpZmZ1c2UnLCAnc3BlY3VsYXInXSkge1xuICAgICAgICAgICAgbGV0IGRlZiA9IGBUQU5HUkFNX01BVEVSSUFMXyR7cHJvcC50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgICAgICBsZXQgdGV4ZGVmID0gZGVmICsgJ19URVhUVVJFJztcbiAgICAgICAgICAgIHN0eWxlLmRlZmluZXNbZGVmXSA9ICh0aGlzW3Byb3BdICE9IG51bGwpO1xuICAgICAgICAgICAgaWYgKHRoaXNbcHJvcF0gJiYgdGhpc1twcm9wXS50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuZGVmaW5lc1t0ZXhkZWZdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdHlsZS5kZWZpbmVzW3RleGRlZiArICdfJyArIHRoaXNbcHJvcF0ubWFwcGluZy50b1VwcGVyQ2FzZSgpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3R5bGUuZGVmaW5lc1tgVEFOR1JBTV9NQVRFUklBTF9URVhUVVJFXyR7dGhpc1twcm9wXS5tYXBwaW5nLnRvVXBwZXJDYXNlKCl9YF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0eWxlLnRleGNvb3JkcyA9IHN0eWxlLnRleGNvb3JkcyB8fCAodGhpc1twcm9wXS5tYXBwaW5nID09PSAndXYnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vcm1hbCBtYXBwaW5nXG4gICAgICAgIC8vIEFzIGFub3ZlLCBzZXRzIGZsYWdzIHRvIGtlZXAgdHJhY2sgb2YgZWFjaCB1bmlxdWUgbWFwcGluZyB0eXBlIGJlaW5nIHVzZWQsIGUuZy46XG4gICAgICAgIC8vICAgVEFOR1JBTV9NQVRFUklBTF9URVhUVVJFX1NQSEVSRU1BUFxuICAgICAgICBpZiAodGhpcy5ub3JtYWwgJiYgdGhpcy5ub3JtYWwudGV4dHVyZSkge1xuICAgICAgICAgICAgc3R5bGUuZGVmaW5lc1snVEFOR1JBTV9NQVRFUklBTF9OT1JNQUxfVEVYVFVSRSddID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0eWxlLmRlZmluZXNbJ1RBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkVfJyArIHRoaXMubm9ybWFsLm1hcHBpbmcudG9VcHBlckNhc2UoKV0gPSB0cnVlO1xuICAgICAgICAgICAgc3R5bGUuZGVmaW5lc1tgVEFOR1JBTV9NQVRFUklBTF9URVhUVVJFXyR7dGhpcy5ub3JtYWwubWFwcGluZy50b1VwcGVyQ2FzZSgpfWBdID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0eWxlLnRleGNvb3JkcyA9IHN0eWxlLnRleGNvb3JkcyB8fCAodGhpcy5ub3JtYWwubWFwcGluZyA9PT0gJ3V2Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZS5yZXBsYWNlU2hhZGVyQmxvY2soTWF0ZXJpYWwuYmxvY2ssIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvbWF0ZXJpYWwnXSwgJ01hdGVyaWFsJyk7XG4gICAgICAgIHN0eWxlLmFkZFNoYWRlckJsb2NrKCdzZXR1cCcsICdcXG5tYXRlcmlhbCA9IHVfbWF0ZXJpYWw7XFxuJywgJ01hdGVyaWFsJyk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9ncmFtIChfcHJvZ3JhbSkge1xuICAgICAgICAvLyBGb3IgZWFjaCBwcm9wZXJ0eSwgc2V0cyB1bmlmb3JtcyBpbiB0aGUgcGF0dGVybjpcbiAgICAgICAgLy8gdV9tYXRlcmlhbC5kaWZmdXNlLCB1X21hdGVyaWFsLmRpZmZ1c2VTY2FsZSB1X21hdGVyaWFsX2RpZmZ1c2VfdGV4dHVyZVxuICAgICAgICBmb3IgKGxldCBwcm9wIG9mIFsnZW1pc3Npb24nLCAnYW1iaWVudCcsICdkaWZmdXNlJywgJ3NwZWN1bGFyJ10pIHtcbiAgICAgICAgICAgIGlmICh0aGlzW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbcHJvcF0udGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBfcHJvZ3JhbS5zZXRUZXh0dXJlVW5pZm9ybShgdV9tYXRlcmlhbF8ke3Byb3B9X3RleHR1cmVgLCB0aGlzW3Byb3BdLnRleHR1cmUpO1xuICAgICAgICAgICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCczZnYnLCBgdV9tYXRlcmlhbC4ke3Byb3B9U2NhbGVgLCB0aGlzW3Byb3BdLnNjYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnNGZ2JywgYHVfbWF0ZXJpYWwuJHtwcm9wfWAsIHRoaXNbcHJvcF0uYW1vdW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXNbcHJvcF0uYW1vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzRmdicsIGB1X21hdGVyaWFsLiR7cHJvcH1gLCB0aGlzW3Byb3BdLmFtb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXh0cmEgc3BlY3VsYXIgcHJvcHNcbiAgICAgICAgaWYgKHRoaXMuc3BlY3VsYXIpIHtcbiAgICAgICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzFmJywgJ3VfbWF0ZXJpYWwuc2hpbmluZXNzJywgdGhpcy5zcGVjdWxhci5zaGluaW5lc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm9ybWFsIG1hcHBpbmdcbiAgICAgICAgaWYgKHRoaXMubm9ybWFsICYmIHRoaXMubm9ybWFsLnRleHR1cmUpIHtcbiAgICAgICAgICAgIF9wcm9ncmFtLnNldFRleHR1cmVVbmlmb3JtKCd1X21hdGVyaWFsX25vcm1hbF90ZXh0dXJlJywgdGhpcy5ub3JtYWwudGV4dHVyZSk7XG4gICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCczZnYnLCAndV9tYXRlcmlhbC5ub3JtYWxTY2FsZScsIHRoaXMubm9ybWFsLnNjYWxlKTtcbiAgICAgICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzFmJywgJ3VfbWF0ZXJpYWwubm9ybWFsQW1vdW50JywgdGhpcy5ub3JtYWwuYW1vdW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuTWF0ZXJpYWwuYmxvY2sgPSAnbWF0ZXJpYWwnO1xuIiwiLypqc2hpbnQgd29ya2VyOiB0cnVlKi9cblxuLy8gTW9kdWxlcyBhbmQgZGVwZW5kZW5jaWVzIHRvIGV4cG9zZSBpbiB0aGUgcHVibGljIFRhbmdyYW0gbW9kdWxlXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy91dGlscyc7XG5cbi8vIFRoZSBsZWFmbGV0IGxheWVyIHBsdWdpbiBpcyBjdXJyZW50bHkgdGhlIHByaW1hcnkgcHVibGljIEFQSVxuaW1wb3J0IHtsZWFmbGV0TGF5ZXJ9IGZyb20gJy4vbGVhZmxldF9sYXllcic7XG5cbi8vIFRoZSBzY2VuZSB3b3JrZXIgaXMgb25seSBhY3RpdmF0ZWQgd2hlbiBhIHdvcmtlciB0aHJlYWQgaXMgaW5zdGFudGlhdGVkLCBidXQgbXVzdCBhbHdheXMgYmUgbG9hZGVkXG5pbXBvcnQge1NjZW5lV29ya2VyfSBmcm9tICcuLi9zcmMvc2NlbmVfd29ya2VyJztcblxuLy8gQWRkaXRpb25hbCBtb2R1bGVzIGFyZSBleHBvc2VkIGZvciBkZWJ1Z2dpbmdcbmltcG9ydCB2ZXJzaW9uIGZyb20gJy4vdXRpbHMvdmVyc2lvbic7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBHZW8gZnJvbSAnLi9nZW8nO1xuaW1wb3J0IERhdGFTb3VyY2UgZnJvbSAnLi9zb3VyY2VzL2RhdGFfc291cmNlJztcbmltcG9ydCAnLi9zb3VyY2VzL2dlb2pzb24nO1xuaW1wb3J0ICcuL3NvdXJjZXMvdG9wb2pzb24nO1xuaW1wb3J0ICcuL3NvdXJjZXMvbXZ0JztcbmltcG9ydCBUaWxlTWFuYWdlciBmcm9tICcuL3RpbGVfbWFuYWdlcic7XG5pbXBvcnQgR0xTTCBmcm9tICcuL2dsL2dsc2wnO1xuaW1wb3J0IFNoYWRlclByb2dyYW0gZnJvbSAnLi9nbC9zaGFkZXJfcHJvZ3JhbSc7XG5pbXBvcnQgVmVydGV4RGF0YSBmcm9tICcuL2dsL3ZlcnRleF9kYXRhJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4vZ2wvdGV4dHVyZSc7XG5pbXBvcnQgTWF0ZXJpYWwgZnJvbSAnLi9tYXRlcmlhbCc7XG5pbXBvcnQgTGlnaHQgZnJvbSAnLi9saWdodCc7XG5pbXBvcnQgV29ya2VyQnJva2VyIGZyb20gJy4vdXRpbHMvd29ya2VyX2Jyb2tlcic7XG5pbXBvcnQge3J1bGVDYWNoZX0gZnJvbSAnLi9zdHlsZXMvcnVsZSc7XG5pbXBvcnQge1N0eWxlTWFuYWdlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfbWFuYWdlcic7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IEZlYXR1cmVTZWxlY3Rpb24gZnJvbSAnLi9zZWxlY3Rpb24nO1xuXG5pbXBvcnQgeWFtbCBmcm9tICdqcy15YW1sJztcbmltcG9ydCBnbE1hdHJpeCBmcm9tICdnbC1tYXRyaXgnO1xuXG4vLyBEZWZhdWx0IHRvIDY0LWJpdCBiZWNhdXNlIHdlIG5lZWQgdGhlIGV4dHJhIHByZWNpc2lvbiB3aGVuIG11bHRpcGx5aW5nIG1hdHJpY2VzIHcvbWVyY2F0b3IgcHJvamVjdGVkIHZhbHVlc1xuZ2xNYXRyaXguZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEZsb2F0NjRBcnJheSk7XG5cbi8vIE1ha2Ugc29tZSBtb2R1bGVzIGFjY2Vzc2libGUgZm9yIGRlYnVnZ2luZ1xudmFyIGRlYnVnID0ge1xuICAgIGxvZyxcbiAgICB5YW1sLFxuICAgIFV0aWxzLFxuICAgIEdlbyxcbiAgICBEYXRhU291cmNlLFxuICAgIFRpbGVNYW5hZ2VyLFxuICAgIEdMU0wsXG4gICAgU2hhZGVyUHJvZ3JhbSxcbiAgICBWZXJ0ZXhEYXRhLFxuICAgIFRleHR1cmUsXG4gICAgTWF0ZXJpYWwsXG4gICAgTGlnaHQsXG4gICAgU2NlbmVXb3JrZXIsXG4gICAgV29ya2VyQnJva2VyLFxuICAgIHJ1bGVDYWNoZSxcbiAgICBTdHlsZU1hbmFnZXIsXG4gICAgU3R5bGVQYXJzZXIsXG4gICAgRmVhdHVyZVNlbGVjdGlvblxufTtcblxuLy8gV2luZG93IGNhbiBvbmx5IGJlIHNldCBpbiBtYWluIHRocmVhZFxuaWYgKFV0aWxzLmlzTWFpblRocmVhZCkge1xuXG4gICAgd2luZG93LlRhbmdyYW0gPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgbGVhZmxldExheWVyLFxuICAgICAgICBkZWJ1ZyxcbiAgICAgICAgdmVyc2lvbjogdmVyc2lvbi5zdHJpbmdcbiAgICB9O1xuXG59XG5cbmlmIChVdGlscy5pc1dvcmtlclRocmVhZCkge1xuICAgIHNlbGYuVGFuZ3JhbSA9IHtcbiAgICAgICAgZGVidWcsXG4gICAgICAgIHZlcnNpb246IHZlcnNpb24uc3RyaW5nXG4gICAgfTtcbn1cblxuaWYgKFV0aWxzLmlzTWFpblRocmVhZCkge1xuICAgIFV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZVBvbHlmaWxsKCk7XG59XG5cbi8vIFNldHVwIGxvZ2dpbmcgdG8gcHJlZml4IHdpdGggVGFuZ3JhbSB2ZXJzaW9uXG52YXIgb3JpZ2luYWxGYWN0b3J5ID0gbG9nLm1ldGhvZEZhY3Rvcnk7XG5sb2cubWV0aG9kRmFjdG9yeSA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBsb2dMZXZlbCkge1xuICAgIHZhciByYXdNZXRob2QgPSBvcmlnaW5hbEZhY3RvcnkobWV0aG9kTmFtZSwgbG9nTGV2ZWwpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4ubWVzc2FnZSkge1xuICAgICAgICByYXdNZXRob2QoYFRhbmdyYW0gJHt2ZXJzaW9uLnN0cmluZ306YCwgLi4ubWVzc2FnZSk7XG4gICAgfTtcbn07XG4iLCIvKmdsb2JhbCBTY2VuZSAqL1xuaW1wb3J0IEdlbyBmcm9tICcuL2dlbyc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy91dGlscyc7XG5pbXBvcnQgV29ya2VyQnJva2VyIGZyb20gJy4vdXRpbHMvd29ya2VyX2Jyb2tlcic7XG5pbXBvcnQgc3Vic2NyaWJlTWl4aW4gZnJvbSAnLi91dGlscy9zdWJzY3JpYmUnO1xuaW1wb3J0IENvbnRleHQgZnJvbSAnLi9nbC9jb250ZXh0JztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4vZ2wvdGV4dHVyZSc7XG5pbXBvcnQgVmVydGV4QXJyYXlPYmplY3QgZnJvbSAnLi9nbC92YW8nO1xuaW1wb3J0IHtTdHlsZX0gZnJvbSAnLi9zdHlsZXMvc3R5bGUnO1xuaW1wb3J0IHtTdHlsZU1hbmFnZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX21hbmFnZXInO1xuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfcGFyc2VyJztcbmltcG9ydCBTY2VuZUxvYWRlciBmcm9tICcuL3NjZW5lX2xvYWRlcic7XG5pbXBvcnQgQ2FtZXJhIGZyb20gJy4vY2FtZXJhJztcbmltcG9ydCBMaWdodCBmcm9tICcuL2xpZ2h0JztcbmltcG9ydCBUaWxlTWFuYWdlciBmcm9tICcuL3RpbGVfbWFuYWdlcic7XG5pbXBvcnQgRGF0YVNvdXJjZSBmcm9tICcuL3NvdXJjZXMvZGF0YV9zb3VyY2UnO1xuaW1wb3J0IEZlYXR1cmVTZWxlY3Rpb24gZnJvbSAnLi9zZWxlY3Rpb24nO1xuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4vZ2wvcmVuZGVyX3N0YXRlJztcblxuaW1wb3J0IHtQb2x5Z29uc30gZnJvbSAnLi9zdHlsZXMvcG9seWdvbnMvcG9seWdvbnMnO1xuaW1wb3J0IHtMaW5lc30gZnJvbSAnLi9zdHlsZXMvbGluZXMvbGluZXMnO1xuaW1wb3J0IHtQb2ludHN9IGZyb20gJy4vc3R5bGVzL3BvaW50cy9wb2ludHMnO1xuaW1wb3J0IHtUZXh0U3R5bGV9IGZyb20gJy4vc3R5bGVzL3RleHQvdGV4dCc7XG5cbi8vIEFkZCBidWlsdC1pbiByZW5kZXJpbmcgc3R5bGVzXG5TdHlsZU1hbmFnZXIucmVnaXN0ZXIoUG9seWdvbnMpO1xuU3R5bGVNYW5hZ2VyLnJlZ2lzdGVyKExpbmVzKTtcblN0eWxlTWFuYWdlci5yZWdpc3RlcihQb2ludHMpO1xuU3R5bGVNYW5hZ2VyLnJlZ2lzdGVyKFRleHRTdHlsZSk7XG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IGdsTWF0cml4IGZyb20gJ2dsLW1hdHJpeCc7XG5sZXQgbWF0NCA9IGdsTWF0cml4Lm1hdDQ7XG5sZXQgbWF0MyA9IGdsTWF0cml4Lm1hdDM7XG5sZXQgdmVjMyA9IGdsTWF0cml4LnZlYzM7XG5cbi8vIExvYWQgc2NlbmUgZGVmaW5pdGlvbjogcGFzcyBhbiBvYmplY3QgZGlyZWN0bHksIG9yIGEgVVJMIGFzIHN0cmluZyB0byBsb2FkIHJlbW90ZWx5XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWdfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBzdWJzY3JpYmVNaXhpbih0aGlzKTtcblxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc291cmNlcyA9IHt9O1xuXG4gICAgICAgIHRoaXMudGlsZV9tYW5hZ2VyID0gVGlsZU1hbmFnZXI7XG4gICAgICAgIHRoaXMudGlsZV9tYW5hZ2VyLmluaXQodGhpcyk7XG4gICAgICAgIHRoaXMubnVtX3dvcmtlcnMgPSBvcHRpb25zLm51bVdvcmtlcnMgfHwgMjtcbiAgICAgICAgdGhpcy5jb250aW51b3VzX3pvb20gPSAodHlwZW9mIG9wdGlvbnMuY29udGludW91c1pvb20gPT09ICdib29sZWFuJykgPyBvcHRpb25zLmNvbnRpbnVvdXNab29tIDogdHJ1ZTtcbiAgICAgICAgdGhpcy50aWxlX3NpbXBsaWZpY2F0aW9uX2xldmVsID0gMDsgLy8gbGV2ZWwtb2YtZGV0YWlsIGRvd25zYW1wbGluZyB0byBhcHBseSB0byB0aWxlIGxvYWRpbmdcbiAgICAgICAgdGhpcy5hbGxvd19jcm9zc19kb21haW5fd29ya2VycyA9IChvcHRpb25zLmFsbG93Q3Jvc3NEb21haW5Xb3JrZXJzID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZSk7XG4gICAgICAgIHRoaXMud29ya2VyX3VybCA9IG9wdGlvbnMud29ya2VyVXJsO1xuICAgICAgICBpZiAob3B0aW9ucy5kaXNhYmxlVmVydGV4QXJyYXlPYmplY3RzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBWZXJ0ZXhBcnJheU9iamVjdC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBVdGlscy51c2VfaGlnaF9kZW5zaXR5X2Rpc3BsYXkgPSBvcHRpb25zLmhpZ2hEZW5zaXR5RGlzcGxheSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5oaWdoRGVuc2l0eURpc3BsYXkgOiB0cnVlO1xuICAgICAgICBVdGlscy51cGRhdGVEZXZpY2VQaXhlbFJhdGlvKCk7XG5cbiAgICAgICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbmZpZ19zb3VyY2UgPSBjb25maWdfc291cmNlO1xuICAgICAgICB0aGlzLmNvbmZpZ19zZXJpYWxpemVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0X3ZhbGlkX2NvbmZpZ19zb3VyY2UgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuc3R5bGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3RpdmVfc3R5bGVzID0ge307XG5cbiAgICAgICAgdGhpcy5idWlsZGluZyA9IG51bGw7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJhY2tzIGN1cnJlbnQgc2NlbmUgYnVpbGRpbmcgc3RhdGUgKHRpbGVzIGJlaW5nIGJ1aWx0LCBldGMuKVxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGEgcmVkcmF3XG4gICAgICAgIHRoaXMuYW5pbWF0ZWQgPSBmYWxzZTsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgcmVkcmF3IGV2ZXJ5IGZyYW1lXG4gICAgICAgIHRoaXMucHJlVXBkYXRlID0gb3B0aW9ucy5wcmVVcGRhdGU7ICAgICAgICAgICAgIC8vIG9wdGlvbmFsIHByZS1yZW5kZXIgbG9vcCBob29rXG4gICAgICAgIHRoaXMucG9zdFVwZGF0ZSA9IG9wdGlvbnMucG9zdFVwZGF0ZTsgICAgICAgICAgIC8vIG9wdGlvbmFsIHBvc3QtcmVuZGVyIGxvb3AgaG9va1xuICAgICAgICB0aGlzLnJlbmRlcl9sb29wID0gIW9wdGlvbnMuZGlzYWJsZVJlbmRlckxvb3A7ICAvLyBkaXNhYmxlIHJlbmRlciBsb29wIC0gYXBwIHdpbGwgaGF2ZSB0byBtYW51YWxseSBjYWxsIFNjZW5lLnJlbmRlcigpIHBlciBmcmFtZVxuICAgICAgICB0aGlzLnJlbmRlcl9sb29wX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbmRlcl9sb29wX3N0b3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mcmFtZSA9IDA7XG4gICAgICAgIHRoaXMucmVzZXRUaW1lKCk7XG5cbiAgICAgICAgdGhpcy56b29tID0gbnVsbDtcbiAgICAgICAgdGhpcy5jZW50ZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByZXNlcnZlX3RpbGVzX3dpdGhpbl96b29tID0gMTtcbiAgICAgICAgdGhpcy5wYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG5cbiAgICAgICAgdGhpcy5jYW1lcmEgPSBudWxsO1xuICAgICAgICB0aGlzLmxpZ2h0cyA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG51bGw7XG5cbiAgICAgICAgLy8gTW9kZWwtdmlldyBtYXRyaWNlc1xuICAgICAgICAvLyA2NC1iaXQgdmVyc2lvbnMgYXJlIGZvciBDUFUgY2FsY3VhdGlvbnNcbiAgICAgICAgLy8gMzItYml0IHZlcnNpb25zIGFyZSBkb3duc2FtcGxlZCBhbmQgc2VudCB0byBHUFVcbiAgICAgICAgdGhpcy5tb2RlbE1hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICAgICAgICB0aGlzLm1vZGVsTWF0cml4MzIgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICAgICAgdGhpcy5tb2RlbFZpZXdNYXRyaXggPSBuZXcgRmxvYXQ2NEFycmF5KDE2KTtcbiAgICAgICAgdGhpcy5tb2RlbFZpZXdNYXRyaXgzMiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgICAgICB0aGlzLm5vcm1hbE1hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoOSk7XG4gICAgICAgIHRoaXMubm9ybWFsTWF0cml4MzIgPSBuZXcgRmxvYXQzMkFycmF5KDkpO1xuICAgICAgICB0aGlzLmludmVyc2VOb3JtYWxNYXRyaXgzMiA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnRleHR1cmVfbGlzdGVuZXIgPSBudWxsO1xuXG4gICAgICAgIC8vIERlYnVnIGNvbmZpZ1xuICAgICAgICB0aGlzLmRlYnVnID0ge1xuICAgICAgICAgICAgcHJvZmlsZToge1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5X2J1aWxkOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpbWVSZWJ1aWxkOiBuID0+IHRoaXMuX3RpbWVSZWJ1aWxkKG4pXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51cGRhdGluZyA9IDA7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGlvbiA9IDA7IC8vIGFuIGlkIHRoYXQgaXMgaW5jcmVtZW50ZWQgZWFjaCB0aW1lIHRoZSBzY2VuZSBjb25maWcgaXMgaW52YWxpZGF0ZWRcblxuICAgICAgICB0aGlzLmxvZ0xldmVsID0gb3B0aW9ucy5sb2dMZXZlbCB8fCAnd2Fybic7XG4gICAgICAgIGxvZy5zZXRMZXZlbCh0aGlzLmxvZ0xldmVsKTtcbiAgICB9XG5cbiAgICAvLyBMb2FkIChvciByZWxvYWQpIHNjZW5lIGNvbmZpZ1xuICAgIC8vIE9wdGlvbmFsbHkgc3BlY2lmeSBuZXcgc2NlbmUgZmlsZSBVUkxcbiAgICBsb2FkKGNvbmZpZ19zb3VyY2UgPSBudWxsLCBjb25maWdfcGF0aCA9IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0aW5nKys7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXppbmcgPSB0cnVlO1xuXG4gICAgICAgIC8vIExvYWQgc2NlbmUgZGVmaW5pdGlvbiAoc291cmNlcywgc3R5bGVzLCBldGMuKSwgdGhlbiBjcmVhdGUgc3R5bGVzICYgd29ya2Vyc1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkU2NlbmUoY29uZmlnX3NvdXJjZSwgY29uZmlnX3BhdGgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLmNyZWF0ZVdvcmtlcnMoKSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGZWF0dXJlU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudGV4dHVyZV9saXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVfbGlzdGVuZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGU6ICgpID0+IHRoaXMuZGlydHkgPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZzogKGRhdGEpID0+IHRoaXMudHJpZ2dlcignd2FybmluZycsIE9iamVjdC5hc3NpZ24oeyB0eXBlOiAndGV4dHVyZXMnIH0sIGRhdGEpKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBUZXh0dXJlLnN1YnNjcmliZSh0aGlzLnRleHR1cmVfbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aWxlcyBiZWZvcmUgcmVidWlsZGluZ1xuICAgICAgICAgICAgICAgIHRoaXMudGlsZV9tYW5hZ2VyLnJlbW92ZVRpbGVzKHRpbGUgPT4gIXRpbGUudmlzaWJsZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ29uZmlnKHsgcmVidWlsZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRpbmctLTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdF92YWxpZF9jb25maWdfc291cmNlID0gdGhpcy5jb25maWdfc291cmNlO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdF92YWxpZF9jb25maWdfcGF0aCA9IHRoaXMuY29uZmlnX3BhdGg7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJfbG9vcCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR1cFJlbmRlckxvb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UmVkcmF3KCk7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnVwZGF0aW5nID0gMDtcblxuICAgICAgICAgICAgLy8gUmVwb3J0IGFuZCByZXZlcnQgdG8gbGFzdCB2YWxpZCBjb25maWcgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBsZXQgdHlwZSwgbWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnWUFNTEV4Y2VwdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3lhbWwnO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAnRXJyb3IgcGFyc2luZyBzY2VuZSBZQU1MJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IG1vcmUgZXJyb3IgdHlwZXNcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gJ0Vycm9yIGluaXRpYWxpemluZyBzY2VuZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJywgeyB0eXBlLCBtZXNzYWdlLCBlcnJvciwgdXJsOiB0aGlzLmNvbmZpZ19zb3VyY2UgfSk7XG5cbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgU2NlbmUubG9hZCgpIGZhaWxlZCB0byBsb2FkICR7dGhpcy5jb25maWdfc291cmNlfTogJHtlcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0X3ZhbGlkX2NvbmZpZ19zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBsb2cud2FybihtZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oYFNjZW5lLmxvYWQoKSByZXZlcnRpbmcgdG8gbGFzdCB2YWxpZCBjb25maWd1cmF0aW9uYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZCh0aGlzLmxhc3RfdmFsaWRfY29uZmlnX3NvdXJjZSwgdGhpcy5sYXN0X3ZhbGlkX2NvbmZpZ19wYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZy5lcnJvcihtZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRm9yIEFQSSBjb21wYXRpYmlsaXR5XG4gICAgcmVsb2FkKGNvbmZpZ19zb3VyY2UgPSBudWxsLCBjb25maWdfcGF0aCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZChjb25maWdfc291cmNlLCBjb25maWdfcGF0aCk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbmRlcl9sb29wX3N0b3AgPSB0cnVlOyAvLyBzY2hlZHVsZSByZW5kZXIgbG9vcCB0byBzdG9wXG5cbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUFsbCgpOyAvLyBjbGVhciBhbGwgZXZlbnQgbGlzdGVuZXJzXG5cbiAgICAgICAgVGV4dHVyZS51bnN1YnNjcmliZSh0aGlzLnRleHR1cmVfbGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnRleHR1cmVfbGlzdGVuZXIgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5nbCkge1xuICAgICAgICAgICAgVGV4dHVyZS5kZXN0cm95KHRoaXMuZ2wpO1xuICAgICAgICAgICAgU3R5bGVNYW5hZ2VyLmRlc3Ryb3kodGhpcy5nbCk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHt9O1xuXG4gICAgICAgICAgICB0aGlzLmdsID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc291cmNlcyA9IHt9O1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMud29ya2VycykpIHtcbiAgICAgICAgICAgIHRoaXMud29ya2Vycy5mb3JFYWNoKCh3b3JrZXIpID0+IHtcbiAgICAgICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMud29ya2VycyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRpbGVfbWFuYWdlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2FudmFzKCkge1xuICAgICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5jb250YWluZXIgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS50b3AgPSAwO1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5sZWZ0ID0gMDtcblxuICAgICAgICAvLyBGb3JjZSB0YW5ncmFtIGNhbnZhcyB1bmRlcm5lYXRoIGFsbCBsZWFmbGV0IGxheWVycywgYW5kIHNldCBiYWNrZ3JvdW5kIHRvIHRyYW5zcGFyZW50XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5nbCA9IENvbnRleHQuZ2V0Q29udGV4dCh0aGlzLmNhbnZhcywge1xuICAgICAgICAgICAgICAgIGFscGhhOiB0cnVlLCBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUsIC8vIFRPRE86IHZhcnkgdy9zY2VuZSBhbHBoYVxuICAgICAgICAgICAgICAgIGRldmljZV9waXhlbF9yYXRpbzogVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDb3VsZG4ndCBjcmVhdGUgV2ViR0wgY29udGV4dC4gXCIgK1xuICAgICAgICAgICAgICAgIFwiWW91ciBicm93c2VyIG1heSBub3Qgc3VwcG9ydCBXZWJHTCwgb3IgaXQncyB0dXJuZWQgb2ZmPyBcIiArXG4gICAgICAgICAgICAgICAgXCJWaXNpdCBodHRwOi8vd2ViZ2xyZXBvcnQuY29tLyBmb3IgbW9yZSBpbmZvLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNpemVNYXAodGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgsIHRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodCk7XG4gICAgICAgIFZlcnRleEFycmF5T2JqZWN0LmluaXQodGhpcy5nbCk7XG4gICAgICAgIFJlbmRlclN0YXRlLmluaXRpYWxpemUodGhpcy5nbCk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBVUkwgdG8gbG9hZCB0aGUgd2ViIHdvcmtlciBmcm9tXG4gICAgZ2V0V29ya2VyVXJsKCkge1xuICAgICAgICBsZXQgd29ya2VyX3VybCA9IHRoaXMud29ya2VyX3VybCB8fCBVdGlscy5maW5kQ3VycmVudFVSTCgndGFuZ3JhbS5kZWJ1Zy5qcycsICd0YW5ncmFtLm1pbi5qcycpO1xuXG4gICAgICAgIGlmICghd29ya2VyX3VybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgbG9hZCB3b3JrZXIgYmVjYXVzZSBjb3VsZG4ndCBmaW5kIGJhc2UgVVJMIHRoYXQgbGlicmFyeSB3YXMgbG9hZGVkIGZyb21cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbGxvd19jcm9zc19kb21haW5fd29ya2Vycykge1xuICAgICAgICAgICAgbGV0IGJvZHkgPSBgaW1wb3J0U2NyaXB0cygnJHt3b3JrZXJfdXJsfScpO2A7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtib2R5XSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JrZXJfdXJsO1xuICAgIH1cblxuICAgIC8vIFdlYiB3b3JrZXJzIGhhbmRsZSBoZWF2eSBkdXR5IHRpbGUgY29uc3RydWN0aW9uOiBuZXR3b3JraW5nLCBnZW9tZXRyeSBwcm9jZXNzaW5nLCBldGMuXG4gICAgY3JlYXRlV29ya2VycygpIHtcbiAgICAgICAgaWYgKCF0aGlzLndvcmtlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VXb3JrZXJzKHRoaXMuZ2V0V29ya2VyVXJsKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICAvLyBJbnN0YW50aWF0ZSB3b3JrZXJzIGZyb20gVVJMLCBpbml0IGV2ZW50IGhhbmRsZXJzXG4gICAgbWFrZVdvcmtlcnModXJsKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuXG4gICAgICAgIHRoaXMud29ya2VycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpZD0wOyBpZCA8IHRoaXMubnVtX3dvcmtlcnM7IGlkKyspIHtcbiAgICAgICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKHVybCk7XG4gICAgICAgICAgICB0aGlzLndvcmtlcnNbaWRdID0gd29ya2VyO1xuXG4gICAgICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMud29ya2VyTG9nTWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIFdvcmtlckJyb2tlci5hZGRXb3JrZXIod29ya2VyKTtcblxuICAgICAgICAgICAgbG9nLmRlYnVnKGBTY2VuZS5tYWtlV29ya2VyczogaW5pdGlhbGl6aW5nIHdvcmtlciAke2lkfWApO1xuICAgICAgICAgICAgbGV0IF9pZCA9IGlkO1xuICAgICAgICAgICAgcXVldWUucHVzaChXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2Uod29ya2VyLCAnc2VsZi5pbml0JywgaWQsIHRoaXMubnVtX3dvcmtlcnMsIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbykudGhlbihcbiAgICAgICAgICAgICAgICAoaWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKGBTY2VuZS5tYWtlV29ya2VyczogaW5pdGlhbGl6ZWQgd29ya2VyICR7aWR9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsb2cuZXJyb3IoYFNjZW5lLm1ha2VXb3JrZXJzOiBmYWlsZWQgdG8gaW5pdGlhbGl6ZSB3b3JrZXIgJHtfaWR9OmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmV4dF93b3JrZXIgPSAwO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocXVldWUpO1xuICAgIH1cblxuICAgIC8vIFJvdW5kIHJvYmluIHNlbGVjdGlvbiBvZiBuZXh0IHdvcmtlclxuICAgIG5leHRXb3JrZXIoKSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSB0aGlzLndvcmtlcnNbdGhpcy5uZXh0X3dvcmtlcl07XG4gICAgICAgIHRoaXMubmV4dF93b3JrZXIgPSAodGhpcy5uZXh0X3dvcmtlciArIDEpICUgdGhpcy53b3JrZXJzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAgU2V0IHRoZSBtYXAgdmlldywgY2FuIGJlIHBhc3NlZCBhbiBvYmplY3Qgd2l0aCBsYXQvbG5nIGFuZC9vciB6b29tXG4gICAgKi9cbiAgICBzZXRWaWV3KHsgbG5nLCBsYXQsIHpvb20gfSA9IHt9KSB7XG4gICAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gU2V0IGNlbnRlclxuICAgICAgICBpZiAodHlwZW9mIGxuZyA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGxhdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jZW50ZXIgfHwgbG5nICE9PSB0aGlzLmNlbnRlci5sbmcgfHwgbGF0ICE9PSB0aGlzLmNlbnRlci5sYXQpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbnRlciA9IHsgbG5nOiBHZW8ud3JhcExuZyhsbmcpLCBsYXQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB6b29tXG4gICAgICAgIGlmICh0eXBlb2Ygem9vbSA9PT0gJ251bWJlcicgJiYgem9vbSAhPT0gdGhpcy56b29tKSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0Wm9vbSh6b29tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cblxuICAgIHN0YXJ0Wm9vbSgpIHtcbiAgICAgICAgdGhpcy5sYXN0X3pvb20gPSB0aGlzLnpvb207XG4gICAgICAgIHRoaXMuem9vbWluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hvb3NlIHRoZSBiYXNlIHpvb20gbGV2ZWwgdG8gdXNlIGZvciBhIGdpdmVuIGZyYWN0aW9uYWwgem9vbVxuICAgIGJhc2Vab29tKHpvb20pIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3Ioem9vbSk7XG4gICAgfVxuXG4gICAgLy8gRm9yIGEgZ2l2ZW4gdmlldyB6b29tLCB3aGF0IHRpbGUgem9vbSBzaG91bGQgYmUgbG9hZGVkP1xuICAgIHRpbGVab29tKHZpZXdfem9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlWm9vbSh2aWV3X3pvb20pIC0gdGhpcy50aWxlX3NpbXBsaWZpY2F0aW9uX2xldmVsO1xuICAgIH1cblxuICAgIC8vIEZvciBhIGdpdmVuIHRpbGUgem9vbSwgd2hhdCBzdHlsZSB6b29tIHNob3VsZCBiZSB1c2VkP1xuICAgIHN0eWxlWm9vbSh0aWxlX3pvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVpvb20odGlsZV96b29tKSArIHRoaXMudGlsZV9zaW1wbGlmaWNhdGlvbl9sZXZlbDtcbiAgICB9XG5cbiAgICBzZXRab29tKHpvb20pIHtcbiAgICAgICAgdGhpcy56b29taW5nID0gZmFsc2U7XG4gICAgICAgIGxldCB0aWxlX3pvb20gPSB0aGlzLnRpbGVab29tKHpvb20pO1xuXG4gICAgICAgIGlmICghdGhpcy5jb250aW51b3VzX3pvb20pIHtcbiAgICAgICAgICAgIHpvb20gPSB0aWxlX3pvb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGlsZV96b29tICE9PSB0aGlzLnRpbGVab29tKHRoaXMubGFzdF96b29tKSkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRpbGVzIG91dHNpZGUgY3VycmVudCB6b29tIHRoYXQgYXJlIHN0aWxsIGxvYWRpbmdcbiAgICAgICAgICAgIHRoaXMudGlsZV9tYW5hZ2VyLnJlbW92ZVRpbGVzKHRpbGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aWxlLmxvYWRpbmcgJiYgdGhpcy50aWxlWm9vbSh0aWxlLmNvb3Jkcy56KSAhPT0gdGlsZV96b29tKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZy50cmFjZShgcmVtb3ZlZCAke3RpbGUua2V5fSAod2FzIGxvYWRpbmcsIGJ1dCBvdXRzaWRlIGN1cnJlbnQgem9vbSlgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3Rfem9vbSA9IHRoaXMuem9vbTtcbiAgICAgICAgdGhpcy56b29tID0gem9vbTtcbiAgICAgICAgdGhpcy50aWxlX3pvb20gPSB0aWxlX3pvb207XG5cbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZHMoKTtcblxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2aWV3UmVhZHkoKSB7XG4gICAgICAgIGlmICh0aGlzLmNzc19zaXplID09IG51bGwgfHwgdGhpcy5jZW50ZXIgPT0gbnVsbCB8fCB0aGlzLnpvb20gPT0gbnVsbCB8fCBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdmlld3BvcnQgYm91bmRzIGJhc2VkIG9uIGN1cnJlbnQgY2VudGVyIGFuZCB6b29tXG4gICAgdXBkYXRlQm91bmRzKCkge1xuICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgY29uY2VwdCBvZiBcInJlYWRpbmVzc1wiIHN0YXRlP1xuICAgICAgICBpZiAoIXRoaXMudmlld1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWV0ZXJzX3Blcl9waXhlbCA9IEdlby5tZXRlcnNQZXJQaXhlbCh0aGlzLnpvb20pO1xuXG4gICAgICAgIC8vIFNpemUgb2YgdGhlIGhhbGYtdmlld3BvcnQgaW4gbWV0ZXJzIGF0IGN1cnJlbnQgem9vbVxuICAgICAgICB0aGlzLnZpZXdwb3J0X21ldGVycyA9IHtcbiAgICAgICAgICAgIHg6IHRoaXMuY3NzX3NpemUud2lkdGggKiB0aGlzLm1ldGVyc19wZXJfcGl4ZWwsXG4gICAgICAgICAgICB5OiB0aGlzLmNzc19zaXplLmhlaWdodCAqIHRoaXMubWV0ZXJzX3Blcl9waXhlbFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENlbnRlciBvZiB2aWV3cG9ydCBpbiBtZXRlcnMsIGFuZCB0aWxlXG4gICAgICAgIGxldCBbeCwgeV0gPSBHZW8ubGF0TG5nVG9NZXRlcnMoW3RoaXMuY2VudGVyLmxuZywgdGhpcy5jZW50ZXIubGF0XSk7XG4gICAgICAgIHRoaXMuY2VudGVyX21ldGVycyA9IHsgeCwgeSB9O1xuXG4gICAgICAgIGxldCB6ID0gdGhpcy50aWxlWm9vbSh0aGlzLnpvb20pO1xuICAgICAgICB0aGlzLmNlbnRlcl90aWxlID0gR2VvLnRpbGVGb3JNZXRlcnMoW3RoaXMuY2VudGVyX21ldGVycy54LCB0aGlzLmNlbnRlcl9tZXRlcnMueV0sIHopO1xuXG4gICAgICAgIHRoaXMuYm91bmRzX21ldGVycyA9IHtcbiAgICAgICAgICAgIHN3OiB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5jZW50ZXJfbWV0ZXJzLnggLSB0aGlzLnZpZXdwb3J0X21ldGVycy54IC8gMixcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmNlbnRlcl9tZXRlcnMueSAtIHRoaXMudmlld3BvcnRfbWV0ZXJzLnkgLyAyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmU6IHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmNlbnRlcl9tZXRlcnMueCArIHRoaXMudmlld3BvcnRfbWV0ZXJzLnggLyAyLFxuICAgICAgICAgICAgICAgIHk6IHRoaXMuY2VudGVyX21ldGVycy55ICsgdGhpcy52aWV3cG9ydF9tZXRlcnMueSAvIDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnRpbGVfbWFuYWdlci51cGRhdGVUaWxlc0ZvclZpZXcoKTtcblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ21vdmUnKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgZmluZFZpc2libGVUaWxlQ29vcmRpbmF0ZXMoeyBidWZmZXIgfSA9IHt9KSB7XG4gICAgICAgIGlmICghdGhpcy5ib3VuZHNfbWV0ZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgeiA9IHRoaXMudGlsZVpvb20odGhpcy56b29tKTtcbiAgICAgICAgbGV0IHN3ID0gR2VvLnRpbGVGb3JNZXRlcnMoW3RoaXMuYm91bmRzX21ldGVycy5zdy54LCB0aGlzLmJvdW5kc19tZXRlcnMuc3cueV0sIHopO1xuICAgICAgICBsZXQgbmUgPSBHZW8udGlsZUZvck1ldGVycyhbdGhpcy5ib3VuZHNfbWV0ZXJzLm5lLngsIHRoaXMuYm91bmRzX21ldGVycy5uZS55XSwgeik7XG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlciB8fCAwO1xuXG4gICAgICAgIGxldCBjb29yZHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IHN3LnggLSBidWZmZXI7IHggPD0gbmUueCArIGJ1ZmZlcjsgeCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gbmUueSAtIGJ1ZmZlcjsgeSA8PSBzdy55ICsgYnVmZmVyOyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb29yZHMucHVzaCh7IHgsIHksIHogfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdGlsZXMgdG9vIGZhciBvdXRzaWRlIG9mIHZpZXdcbiAgICBwcnVuZVRpbGVDb29yZGluYXRlc0ZvclZpZXcoYm9yZGVyX2J1ZmZlciA9IDIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdSZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgdGlsZXMgdGhhdCBhcmUgYSBzcGVjaWZpZWQgIyBvZiB0aWxlcyBvdXRzaWRlIG9mIHRoZSB2aWV3cG9ydCBib3JkZXJcbiAgICAgICAgbGV0IGJvcmRlcl90aWxlcyA9IFtcbiAgICAgICAgICAgIE1hdGguY2VpbCgoTWF0aC5mbG9vcih0aGlzLmNzc19zaXplLndpZHRoIC8gR2VvLnRpbGVfc2l6ZSkgKyAyKSAvIDIpLFxuICAgICAgICAgICAgTWF0aC5jZWlsKChNYXRoLmZsb29yKHRoaXMuY3NzX3NpemUuaGVpZ2h0IC8gR2VvLnRpbGVfc2l6ZSkgKyAyKSAvIDIpXG4gICAgICAgIF07XG4gICAgICAgIGxldCBzdHlsZV96b29tID0gdGhpcy50aWxlWm9vbSh0aGlzLnpvb20pO1xuXG4gICAgICAgIHRoaXMudGlsZV9tYW5hZ2VyLnJlbW92ZVRpbGVzKHRpbGUgPT4ge1xuICAgICAgICAgICAgLy8gSWdub3JlIHZpc2libGUgdGlsZXNcbiAgICAgICAgICAgIGlmICh0aWxlLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc2NhcmQgaWYgdG9vIGZhciBmcm9tIGN1cnJlbnQgem9vbVxuICAgICAgICAgICAgbGV0IHpkaWZmID0gdGlsZS5jb29yZHMueiAtIHN0eWxlX3pvb207XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoemRpZmYpID4gdGhpcy5wcmVzZXJ2ZV90aWxlc193aXRoaW5fem9vbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYW5kbGUgdGlsZXMgYXQgZGlmZmVyZW50IHpvb21zXG4gICAgICAgICAgICBsZXQgenRyYW5zID0gTWF0aC5wb3coMiwgemRpZmYpO1xuICAgICAgICAgICAgbGV0IGNvb3JkcyA9IHtcbiAgICAgICAgICAgICAgICB4OiBNYXRoLmZsb29yKHRpbGUuY29vcmRzLnggLyB6dHJhbnMpLFxuICAgICAgICAgICAgICAgIHk6IE1hdGguZmxvb3IodGlsZS5jb29yZHMueSAvIHp0cmFucylcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIERpc2NhcmQgdGlsZXMgb3V0c2lkZSBhbiBhcmVhIHN1cnJvdW5kaW5nIHRoZSB2aWV3cG9ydFxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGNvb3Jkcy54IC0gdGhpcy5jZW50ZXJfdGlsZS54KSAtIGJvcmRlcl90aWxlc1swXSA+IGJvcmRlcl9idWZmZXIpIHtcbiAgICAgICAgICAgICAgICBsb2cudHJhY2UoYFNjZW5lOiByZW1vdmUgdGlsZSAke3RpbGUua2V5fSAoYXMgJHtjb29yZHMueH0vJHtjb29yZHMueX0vJHtzdHlsZV96b29tfSkgZm9yIGJlaW5nIHRvbyBmYXIgb3V0IG9mIHZpc2libGUgYXJlYSAqKipgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKE1hdGguYWJzKGNvb3Jkcy55IC0gdGhpcy5jZW50ZXJfdGlsZS55KSAtIGJvcmRlcl90aWxlc1sxXSA+IGJvcmRlcl9idWZmZXIpIHtcbiAgICAgICAgICAgICAgICBsb2cudHJhY2UoYFNjZW5lOiByZW1vdmUgdGlsZSAke3RpbGUua2V5fSAoYXMgJHtjb29yZHMueH0vJHtjb29yZHMueX0vJHtzdHlsZV96b29tfSkgZm9yIGJlaW5nIHRvbyBmYXIgb3V0IG9mIHZpc2libGUgYXJlYSAqKipgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmVzaXplIHRoZSBtYXAgd2hlbiBkZXZpY2UgcGl4ZWwgcmF0aW8gY2hhbmdlcywgZS5nLiB3aGVuIHN3aXRjaGluZyBiZXR3ZWVuIGRpc3BsYXlzXG4gICAgdXBkYXRlRGV2aWNlUGl4ZWxSYXRpbyAoKSB7XG4gICAgICAgIGlmIChVdGlscy51cGRhdGVEZXZpY2VQaXhlbFJhdGlvKCkpIHtcbiAgICAgICAgICAgIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSh0aGlzLndvcmtlcnMsICdzZWxmLnVwZGF0ZURldmljZVBpeGVsUmF0aW8nLCBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8pXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5yZWJ1aWxkKCkpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5yZXNpemVNYXAodGhpcy5jc3Nfc2l6ZS53aWR0aCwgdGhpcy5jc3Nfc2l6ZS5oZWlnaHQpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2l6ZU1hcCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuY3NzX3NpemUgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcbiAgICAgICAgdGhpcy5kZXZpY2Vfc2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKHRoaXMuY3NzX3NpemUud2lkdGggKiBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8pLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHRoaXMuY3NzX3NpemUuaGVpZ2h0ICogVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnZpZXdfYXNwZWN0ID0gdGhpcy5jc3Nfc2l6ZS53aWR0aCAvIHRoaXMuY3NzX3NpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuXG4gICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSB0aGlzLmNzc19zaXplLndpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9IHRoaXMuY3NzX3NpemUuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5kZXZpY2Vfc2l6ZS53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuZGV2aWNlX3NpemUuaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5nbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXF1ZXN0IHNjZW5lIGJlIHJlZHJhd24gYXQgbmV4dCBhbmltYXRpb24gbG9vcFxuICAgIHJlcXVlc3RSZWRyYXcoKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFJlZHJhdyBzY2VuZSBpbW1lZGlhdGVseSAtIGRvbid0IHdhaXQgZm9yIGFuaW1hdGlvbiBsb29wXG4gICAgLy8gVXNlIHNwYXJpbmdseSwgYnV0IGZvciBjYXNlcyB3aGVyZSB5b3UgbmVlZCB0aGUgY2xvc2VzdCBwb3NzaWJsZSBzeW5jIHdpdGggb3RoZXIgVUkgZWxlbWVudHMsXG4gICAgLy8gc3VjaCBhcyBvdGhlciwgbm9uLVdlYkdMIG1hcCBsYXllcnMgKGUuZy4gTGVhZmxldCByYXN0ZXIgbGF5ZXJzLCBtYXJrZXJzLCBldGMuKVxuICAgIGltbWVkaWF0ZVJlZHJhdygpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcmVuZGVyTG9vcCAoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyX2xvb3BfYWN0aXZlID0gdHJ1ZTsgLy8gb25seSBsZXQgdGhlIHJlbmRlciBsb29wIGluc3RhbnRpYXRlIG9uY2VcblxuICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSBzY2VuZVxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlcXVlc3QgdGhlIG5leHQgZnJhbWUgaWYgbm90IHNjaGVkdWxlZCB0byBzdG9wXG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJfbG9vcF9zdG9wKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyTG9vcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyX2xvb3Bfc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJfbG9vcF9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldHVwIHRoZSByZW5kZXIgbG9vcFxuICAgIHNldHVwUmVuZGVyTG9vcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcl9sb29wX2FjdGl2ZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMucmVuZGVyTG9vcCgpOyB9LCAwKTsgLy8gZGVsYXkgc3RhcnQgYnkgb25lIHRpY2tcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy50aWxlX21hbmFnZXIubG9hZFF1ZXVlZENvb3JkaW5hdGVzKCk7XG5cbiAgICAgICAgLy8gUmVuZGVyIG9uIGRlbWFuZFxuICAgICAgICB2YXIgd2lsbF9yZW5kZXIgPSAhKFxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICB0aGlzLnVwZGF0aW5nID4gMCB8fFxuICAgICAgICAgICAgdGhpcy52aWV3UmVhZHkoKSA9PT0gZmFsc2VcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBQcmUtcmVuZGVyIGxvb3AgaG9va1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnByZVVwZGF0ZSh3aWxsX3JlbmRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYWlsIGlmIG5vIG5lZWQgdG8gcmVuZGVyXG4gICAgICAgIGlmICghd2lsbF9yZW5kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7IC8vIHN1YmNsYXNzZXMgY2FuIHNldCB0aGlzIGJhY2sgdG8gdHJ1ZSB3aGVuIGFuaW1hdGlvbiBpcyBuZWVkZWRcblxuICAgICAgICAvLyBSZW5kZXIgdGhlIHNjZW5lXG4gICAgICAgIHRoaXMudXBkYXRlRGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuXG4gICAgICAgIC8vIFBvc3QtcmVuZGVyIGxvb3AgaG9va1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMucG9zdFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5wb3N0VXBkYXRlKHdpbGxfcmVuZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlZHJhdyBldmVyeSBmcmFtZSBpZiBhbmltYXRpbmdcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mcmFtZSsrO1xuICAgICAgICBsb2cudHJhY2UoJ1NjZW5lLnJlbmRlcigpJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgICAgICAvLyBNYXAgdHJhbnNmb3Jtc1xuICAgICAgICBpZiAoIXRoaXMuY2VudGVyX21ldGVycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHN0eWxlcywgY2FtZXJhLCBsaWdodHNcbiAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYWN0aXZlX3N0eWxlcykuZm9yRWFjaChpID0+IHRoaXMuc3R5bGVzW2ldLnVwZGF0ZSgpKTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5saWdodHMpLmZvckVhY2goaSA9PiB0aGlzLmxpZ2h0c1tpXS51cGRhdGUoKSk7XG5cbiAgICAgICAgLy8gUmVuZGVyYWJsZSB0aWxlIGxpc3RcbiAgICAgICAgdGhpcy5yZW5kZXJhYmxlX3RpbGVzID0gdGhpcy50aWxlX21hbmFnZXIuZ2V0UmVuZGVyYWJsZVRpbGVzKCk7XG4gICAgICAgIHRoaXMucmVuZGVyYWJsZV90aWxlc19jb3VudCA9IHRoaXMucmVuZGVyYWJsZV90aWxlcy5sZW5ndGg7XG5cbiAgICAgICAgLy8gUmVuZGVyIG1haW4gcGFzc1xuICAgICAgICB0aGlzLnJlbmRlcl9jb3VudCA9IHRoaXMucmVuZGVyUGFzcygpO1xuXG4gICAgICAgIC8vIFJlbmRlciBzZWxlY3Rpb24gcGFzcyAoaWYgbmVlZGVkKVxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24ucGVuZGluZ1JlcXVlc3RzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5jbGVhclBlbmRpbmdSZXF1ZXN0cygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uYmluZCgpOyAgICAgICAgICAgICAgICAgIC8vIHN3aXRjaCB0byBGQk9cbiAgICAgICAgICAgIHRoaXMucmVuZGVyUGFzcyhcbiAgICAgICAgICAgICAgICAnc2VsZWN0aW9uX3Byb2dyYW0nLCAgICAgICAgICAgICAgICAvLyByZW5kZXIgdy9hbHRlcm5hdGUgcHJvZ3JhbVxuICAgICAgICAgICAgICAgIHsgYWxsb3dfYmxlbmQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ucmVhZCgpOyAgICAgICAgICAgICAgICAgIC8vIHJlYWQgcmVzdWx0cyBmcm9tIHNlbGVjdGlvbiBidWZmZXJcblxuICAgICAgICAgICAgLy8gUmVzZXQgdG8gc2NyZWVuIGJ1ZmZlclxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucmVuZGVyX2NvdW50ICE9PSB0aGlzLmxhc3RfcmVuZGVyX2NvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmdldEZlYXR1cmVTZWxlY3Rpb25NYXBTaXplKCkudGhlbihzaXplID0+IHtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhgU2NlbmU6IHJlbmRlcmVkICR7dGhpcy5yZW5kZXJfY291bnR9IHByaW1pdGl2ZXMgKCR7c2l6ZX0gZmVhdHVyZXMgaW4gc2VsZWN0aW9uIG1hcClgKTtcbiAgICAgICAgICAgIH0sICgpID0+IHt9KTsgLy8gbm8gb3Agd2hlbiBwcm9taXNlIHJlamVjdHMgKG9ubHkgcHJpbnQgbGFzdCByZXNwb25zZSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RfcmVuZGVyX2NvdW50ID0gdGhpcy5yZW5kZXJfY291bnQ7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gUmVuZGVyIGFsbCBhY3RpdmUgc3R5bGVzLCBncm91cGVkIGJ5IGJsZW5kL2RlcHRoIHR5cGUgKG9wYXF1ZSwgb3ZlcmxheSwgZXRjLikgYW5kIGJ5IHByb2dyYW0gKHN0eWxlKVxuICAgIC8vIENhbGxlZCBib3RoIGZvciBtYWluIHJlbmRlciBwYXNzLCBhbmQgZm9yIHNlY29uZGFyeSBwYXNzZXMgbGlrZSBzZWxlY3Rpb24gYnVmZmVyXG4gICAgcmVuZGVyUGFzcyhwcm9ncmFtX2tleSA9ICdwcm9ncmFtJywgeyBhbGxvd19ibGVuZCB9ID0ge30pIHtcbiAgICAgICAgLy8gb3B0aW9uYWxseSBmb3JjZSBhbHBoYSBvZmYgKGUuZy4gZm9yIHNlbGVjdGlvbiBwYXNzKVxuICAgICAgICBhbGxvd19ibGVuZCA9IChhbGxvd19ibGVuZCA9PSBudWxsKSA/IHRydWUgOiBhbGxvd19ibGVuZDtcblxuICAgICAgICB0aGlzLmNsZWFyRnJhbWUoeyBjbGVhcl9jb2xvcjogdHJ1ZSwgY2xlYXJfZGVwdGg6IHRydWUgfSk7XG5cbiAgICAgICAgLy8gU29ydCBzdHlsZXMgYnkgYmxlbmQgb3JkZXJcbiAgICAgICAgbGV0IHN0eWxlcyA9IE9iamVjdC5rZXlzKHRoaXMuYWN0aXZlX3N0eWxlcykuXG4gICAgICAgICAgICBtYXAocyA9PiB0aGlzLnN0eWxlc1tzXSkuXG4gICAgICAgICAgICBzb3J0KFN0eWxlLmJsZW5kT3JkZXJTb3J0KTtcblxuICAgICAgICAvLyBSZW5kZXIgc3R5bGVzXG4gICAgICAgIGxldCBjb3VudCA9IDA7IC8vIGhvdyBtYW55IHByaW1pdGl2ZXMgd2VyZSByZW5kZXJlZFxuICAgICAgICBsZXQgbGFzdF9ibGVuZDtcbiAgICAgICAgZm9yIChsZXQgc3R5bGUgb2Ygc3R5bGVzKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSByZW5kZXIgc3RhdGUgd2hlbiBibGVuZCBtb2RlIGNoYW5nZXNcbiAgICAgICAgICAgIGlmIChzdHlsZS5ibGVuZCAhPT0gbGFzdF9ibGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sXG4gICAgICAgICAgICAgICAgICAgIFN0eWxlLnJlbmRlcl9zdGF0ZXNbc3R5bGUuYmxlbmRdLCAgICAgICAvLyByZW5kZXIgc3RhdGUgZm9yIGJsZW5kIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgeyBibGVuZDogKGFsbG93X2JsZW5kICYmIHN0eWxlLmJsZW5kKSB9IC8vIGVuYWJsZS9kaXNhYmxlIGJsZW5kaW5nIChlLmcuIG5vIGJsZW5kIGZvciBzZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJlbmRlclN0YXRlKHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ICs9IHRoaXMucmVuZGVyU3R5bGUoc3R5bGUubmFtZSwgcHJvZ3JhbV9rZXkpO1xuICAgICAgICAgICAgbGFzdF9ibGVuZCA9IHN0eWxlLmJsZW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cblxuICAgIHJlbmRlclN0eWxlKHN0eWxlLCBwcm9ncmFtX2tleSkge1xuICAgICAgICBsZXQgZmlyc3RfZm9yX3N0eWxlID0gdHJ1ZTtcbiAgICAgICAgbGV0IHJlbmRlcl9jb3VudCA9IDA7XG5cbiAgICAgICAgbGV0IHByb2dyYW0gPSB0aGlzLnN0eWxlc1tzdHlsZV1bcHJvZ3JhbV9rZXldO1xuICAgICAgICBpZiAoIXByb2dyYW0gfHwgIXByb2dyYW0uY29tcGlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVuZGVyIHRpbGUgR0wgZ2VvbWV0cmllc1xuICAgICAgICBmb3IgKGxldCB0IGluIHRoaXMucmVuZGVyYWJsZV90aWxlcykge1xuICAgICAgICAgICAgbGV0IHRpbGUgPSB0aGlzLnJlbmRlcmFibGVfdGlsZXNbdF07XG5cbiAgICAgICAgICAgIGlmICh0aWxlLm1lc2hlc1tzdHlsZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdHlsZS1zcGVjaWZpYyBzdGF0ZVxuICAgICAgICAgICAgLy8gT25seSBzZXR1cCBzdHlsZSBpZiByZW5kZXJpbmcgZm9yIGZpcnN0IHRpbWUgdGhpcyBmcmFtZVxuICAgICAgICAgICAgLy8gKGxhenkgaW5pdCwgbm90IGFsbCBzdHlsZXMgd2lsbCBiZSB1c2VkIGluIGFsbCBzY3JlZW4gdmlld3M7IHNvbWUgc3R5bGVzIG1pZ2h0IGJlIGRlZmluZWQgYnV0IG5ldmVyIHVzZWQpXG4gICAgICAgICAgICBpZiAoZmlyc3RfZm9yX3N0eWxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RfZm9yX3N0eWxlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBwcm9ncmFtLnVzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzW3N0eWxlXS5zZXR1cCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZG9uJ3Qgc2V0IHVuaWZvcm1zIHdoZW4gdGhleSBoYXZlbid0IGNoYW5nZWRcbiAgICAgICAgICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzJmJywgJ3VfcmVzb2x1dGlvbicsIHRoaXMuZGV2aWNlX3NpemUud2lkdGgsIHRoaXMuZGV2aWNlX3NpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzFmJywgJ3VfdGltZScsICgoK25ldyBEYXRlKCkpIC0gdGhpcy5zdGFydF90aW1lKSAvIDEwMDApO1xuICAgICAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybSgnM2YnLCAndV9tYXBfcG9zaXRpb24nLCB0aGlzLmNlbnRlcl9tZXRlcnMueCwgdGhpcy5jZW50ZXJfbWV0ZXJzLnksIHRoaXMuem9vbSk7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCcxZicsICd1X21ldGVyc19wZXJfcGl4ZWwnLCB0aGlzLm1ldGVyc19wZXJfcGl4ZWwpO1xuICAgICAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybSgnMWYnLCAndV9kZXZpY2VfcGl4ZWxfcmF0aW8nLCBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmEuc2V0dXBQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5saWdodHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saWdodHNbaV0uc2V0dXBQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGlsZS1zcGVjaWZpYyBzdGF0ZVxuICAgICAgICAgICAgLy8gVE9ETzogY2FsYyB0aGVzZSBvbmNlIHBlciB0aWxlIChjdXJyZW50bHkgYmVpbmcgbmVlZGxlc3NseSByZS1jYWxjdWxhdGVkIHBlci10aWxlLXBlci1zdHlsZSlcblxuICAgICAgICAgICAgLy8gVGlsZSBvcmlnaW5cbiAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybSgnM2YnLCAndV90aWxlX29yaWdpbicsIHRpbGUubWluLngsIHRpbGUubWluLnksIHRpbGUuc3R5bGVfem9vbSk7XG5cbiAgICAgICAgICAgIC8vIE1vZGVsIG1hdHJpeCAtIHRyYW5zZm9ybSB0aWxlIHNwYWNlIGludG8gd29ybGQgc3BhY2UgKG1ldGVycywgYWJzb2x1dGUgbWVyY2F0b3IgcG9zaXRpb24pXG4gICAgICAgICAgICBtYXQ0LmlkZW50aXR5KHRoaXMubW9kZWxNYXRyaXgpO1xuICAgICAgICAgICAgbWF0NC50cmFuc2xhdGUodGhpcy5tb2RlbE1hdHJpeCwgdGhpcy5tb2RlbE1hdHJpeCwgdmVjMy5mcm9tVmFsdWVzKHRpbGUubWluLngsIHRpbGUubWluLnksIDApKTtcbiAgICAgICAgICAgIG1hdDQuc2NhbGUodGhpcy5tb2RlbE1hdHJpeCwgdGhpcy5tb2RlbE1hdHJpeCwgdmVjMy5mcm9tVmFsdWVzKHRpbGUuc3Bhbi54IC8gR2VvLnRpbGVfc2NhbGUsIC0xICogdGlsZS5zcGFuLnkgLyBHZW8udGlsZV9zY2FsZSwgMSkpOyAvLyBzY2FsZSB0aWxlIGxvY2FsIGNvb3JkcyB0byBtZXRlcnNcbiAgICAgICAgICAgIG1hdDQuY29weSh0aGlzLm1vZGVsTWF0cml4MzIsIHRoaXMubW9kZWxNYXRyaXgpO1xuICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCdNYXRyaXg0ZnYnLCAndV9tb2RlbCcsIGZhbHNlLCB0aGlzLm1vZGVsTWF0cml4MzIpO1xuXG4gICAgICAgICAgICAvLyBNb2RlbCB2aWV3IG1hdHJpeCAtIHRyYW5zZm9ybSB0aWxlIHNwYWNlIGludG8gdmlldyBzcGFjZSAobWV0ZXJzLCByZWxhdGl2ZSB0byBjYW1lcmEpXG4gICAgICAgICAgICBtYXQ0Lm11bHRpcGx5KHRoaXMubW9kZWxWaWV3TWF0cml4MzIsIHRoaXMuY2FtZXJhLnZpZXdNYXRyaXgsIHRoaXMubW9kZWxNYXRyaXgpO1xuICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCdNYXRyaXg0ZnYnLCAndV9tb2RlbFZpZXcnLCBmYWxzZSwgdGhpcy5tb2RlbFZpZXdNYXRyaXgzMik7XG5cbiAgICAgICAgICAgIC8vIE5vcm1hbCBtYXRyaWNlcyAtIHRyYW5zZm9ybXMgc3VyZmFjZSBub3JtYWxzIGludG8gdmlldyBzcGFjZVxuICAgICAgICAgICAgbWF0My5ub3JtYWxGcm9tTWF0NCh0aGlzLm5vcm1hbE1hdHJpeDMyLCB0aGlzLm1vZGVsVmlld01hdHJpeDMyKTtcbiAgICAgICAgICAgIG1hdDMuaW52ZXJ0KHRoaXMuaW52ZXJzZU5vcm1hbE1hdHJpeDMyLCB0aGlzLm5vcm1hbE1hdHJpeDMyKTtcbiAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybSgnTWF0cml4M2Z2JywgJ3Vfbm9ybWFsTWF0cml4JywgZmFsc2UsIHRoaXMubm9ybWFsTWF0cml4MzIpO1xuICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCdNYXRyaXgzZnYnLCAndV9pbnZlcnNlTm9ybWFsTWF0cml4JywgZmFsc2UsIHRoaXMuaW52ZXJzZU5vcm1hbE1hdHJpeDMyKTtcblxuICAgICAgICAgICAgLy8gUmVuZGVyIHRpbGVcbiAgICAgICAgICAgIHRpbGUubWVzaGVzW3N0eWxlXS5yZW5kZXIoKTtcbiAgICAgICAgICAgIHJlbmRlcl9jb3VudCArPSB0aWxlLm1lc2hlc1tzdHlsZV0uZ2VvbWV0cnlfY291bnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVuZGVyX2NvdW50O1xuICAgIH1cblxuICAgIGNsZWFyRnJhbWUoeyBjbGVhcl9jb2xvciwgY2xlYXJfZGVwdGggfSA9IHt9KSB7XG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdHNcbiAgICAgICAgY2xlYXJfY29sb3IgPSAoY2xlYXJfY29sb3IgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZTsgLy8gZGVmYXVsdCB0cnVlXG4gICAgICAgIGNsZWFyX2RlcHRoID0gKGNsZWFyX2RlcHRoID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWU7IC8vIGRlZmF1bHQgdHJ1ZVxuXG4gICAgICAgIC8vIFJlc2V0IGZyYW1lIHN0YXRlXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG5cbiAgICAgICAgaWYgKGNsZWFyX2NvbG9yKSB7XG4gICAgICAgICAgICBnbC5jbGVhckNvbG9yKC4uLnRoaXMuYmFja2dyb3VuZC5jb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xlYXJfZGVwdGgpIHtcbiAgICAgICAgICAgIGdsLmRlcHRoTWFzayh0cnVlKTsgLy8gYWx3YXlzIGNsZWFyIGRlcHRoIGlmIHJlcXVlc3RlZCwgZXZlbiBpZiBkZXB0aCB3cml0ZSB3aWxsIGJlIHR1cm5lZCBvZmZcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbGVhcl9jb2xvciB8fCBjbGVhcl9kZXB0aCkge1xuICAgICAgICAgICAgbGV0IG1hc2sgPSAoY2xlYXJfY29sb3IgJiYgZ2wuQ09MT1JfQlVGRkVSX0JJVCkgfCAoY2xlYXJfZGVwdGggJiYgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG4gICAgICAgICAgICBnbC5jbGVhcihtYXNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFJlbmRlclN0YXRlKHsgZGVwdGhfdGVzdCwgZGVwdGhfd3JpdGUsIGN1bGxfZmFjZSwgYmxlbmQgfSA9IHt9KSB7XG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdHNcbiAgICAgICAgLy8gVE9ETzogd2hlbiB3ZSBhYnN0cmFjdCBvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgcmVuZGVyIHBhc3NlcywgdGhlc2UgY2FuIGJlIHBlci1wYXNzIGNvbmZpZyBvcHRpb25zXG4gICAgICAgIGRlcHRoX3Rlc3QgPSAoZGVwdGhfdGVzdCA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlOyAgICAgLy8gZGVmYXVsdCB0cnVlXG4gICAgICAgIGRlcHRoX3dyaXRlID0gKGRlcHRoX3dyaXRlID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWU7ICAgLy8gZGVmYXVsdCB0cnVlXG4gICAgICAgIGN1bGxfZmFjZSA9IChjdWxsX2ZhY2UgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZTsgICAgICAgLy8gZGVmYXVsdCB0cnVlXG4gICAgICAgIGJsZW5kID0gKGJsZW5kICE9IG51bGwpID8gYmxlbmQgOiBmYWxzZTsgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBmYWxzZVxuXG4gICAgICAgIC8vIFJlc2V0IGZyYW1lIHN0YXRlXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG5cbiAgICAgICAgUmVuZGVyU3RhdGUuZGVwdGhfdGVzdC5zZXQoeyBkZXB0aF90ZXN0OiBkZXB0aF90ZXN0LCBkZXB0aF9mdW5jOiBnbC5MRVFVQUwgfSk7XG4gICAgICAgIFJlbmRlclN0YXRlLmRlcHRoX3dyaXRlLnNldCh7IGRlcHRoX3dyaXRlOiBkZXB0aF93cml0ZSB9KTtcbiAgICAgICAgUmVuZGVyU3RhdGUuY3VsbGluZy5zZXQoeyBjdWxsOiBjdWxsX2ZhY2UsIGZhY2U6IGdsLkJBQ0sgfSk7XG5cbiAgICAgICAgLy8gQmxlbmRpbmcgb2YgYWxwaGEgY2hhbm5lbCBpcyBtb2RpZmllZCB0byBhY2NvdW50IGZvciBXZWJHTCBhbHBoYSBiZWhhdmlvciwgc2VlOlxuICAgICAgICAvLyBodHRwOi8vd2ViZ2xmdW5kYW1lbnRhbHMub3JnL3dlYmdsL2xlc3NvbnMvd2ViZ2wtYW5kLWFscGhhLmh0bWxcbiAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTE1MzM0MTZcbiAgICAgICAgaWYgKGJsZW5kKSB7XG4gICAgICAgICAgICAvLyBPcGFxdWU6IGFsbCBzb3VyY2UsIG5vIGRlc3RpbmF0aW9uXG4gICAgICAgICAgICBpZiAoYmxlbmQgPT09ICdvcGFxdWUnKSB7XG4gICAgICAgICAgICAgICAgUmVuZGVyU3RhdGUuYmxlbmRpbmcuc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgYmxlbmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNyYzogZ2wuU1JDX0FMUEhBLCBkc3Q6IGdsLlpFUk9cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRyYWRpdGlvbmFsIGFscGhhIGJsZW5kaW5nXG4gICAgICAgICAgICBlbHNlIGlmIChibGVuZCA9PT0gJ292ZXJsYXknIHx8IGJsZW5kID09PSAnaW5sYXknKSB7XG4gICAgICAgICAgICAgICAgUmVuZGVyU3RhdGUuYmxlbmRpbmcuc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgYmxlbmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNyYzogZ2wuU1JDX0FMUEhBLCBkc3Q6IGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsXG4gICAgICAgICAgICAgICAgICAgIHNyY19hbHBoYTogZ2wuT05FLCBkc3RfYWxwaGE6IGdsLk9ORV9NSU5VU19TUkNfQUxQSEFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZGl0aXZlIGJsZW5kaW5nXG4gICAgICAgICAgICBlbHNlIGlmIChibGVuZCA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAgICAgICBSZW5kZXJTdGF0ZS5ibGVuZGluZy5zZXQoe1xuICAgICAgICAgICAgICAgICAgICBibGVuZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3JjOiBnbC5PTkUsIGRzdDogZ2wuT05FLFxuICAgICAgICAgICAgICAgICAgICBzcmNfYWxwaGE6IGdsLk9ORSwgZHN0X2FscGhhOiBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNdWx0aXBsaWNhdGl2ZSBibGVuZGluZ1xuICAgICAgICAgICAgZWxzZSBpZiAoYmxlbmQgPT09ICdtdWx0aXBseScpIHtcbiAgICAgICAgICAgICAgICBSZW5kZXJTdGF0ZS5ibGVuZGluZy5zZXQoe1xuICAgICAgICAgICAgICAgICAgICBibGVuZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3JjOiBnbC5aRVJPLCBkc3Q6IGdsLlNSQ19DT0xPUixcbiAgICAgICAgICAgICAgICAgICAgc3JjX2FscGhhOiBnbC5PTkUsIGRzdF9hbHBoYTogZ2wuT05FX01JTlVTX1NSQ19BTFBIQVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgUmVuZGVyU3RhdGUuYmxlbmRpbmcuc2V0KHsgYmxlbmQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVxdWVzdCBmZWF0dXJlIHNlbGVjdGlvbiBhdCBnaXZlbiBwaXhlbC4gUnVucyBhc3luYyBhbmQgcmV0dXJucyByZXN1bHRzIHZpYSBhIHByb21pc2UuXG4gICAgZ2V0RmVhdHVyZUF0KHBpeGVsKSB7XG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKFwiU2NlbmUuZ2V0RmVhdHVyZUF0KCkgY2FsbGVkIGJlZm9yZSBzY2VuZSB3YXMgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQb2ludCBzY2FsZWQgdG8gWzAuLjFdIHJhbmdlXG4gICAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgICAgIHg6IHBpeGVsLnggKiBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8gLyB0aGlzLmRldmljZV9zaXplLndpZHRoLFxuICAgICAgICAgICAgeTogcGl4ZWwueSAqIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbyAvIHRoaXMuZGV2aWNlX3NpemUuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7IC8vIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBzY2VuZSByZS1yZW5kZXJzIGZvciB0aGVzZSB0byBiZSBwcm9jZXNzZWRcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmdldEZlYXR1cmVBdChwb2ludCkuY2F0Y2gociA9PiBQcm9taXNlLnJlc29sdmUocikpO1xuICAgIH1cblxuICAgIC8vIFJlYnVpbGQgZ2VvbWV0cnksIHdpdGhvdXQgcmUtcGFyc2luZyB0aGUgY29uZmlnIG9yIHJlLWNvbXBpbGluZyBzdHlsZXNcbiAgICAvLyBUT0RPOiBkZXRlY3Qgd2hpY2ggZWxlbWVudHMgbmVlZCB0byBiZSByZWZyZXNoZWQvcmVidWlsdCAoc3R5bGVzaGVldCBjaGFuZ2VzLCBldGMuKVxuICAgIHJlYnVpbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYnVpbGRHZW9tZXRyeSgpO1xuICAgIH1cblxuICAgIC8vIFJlYnVpbGQgYWxsIHRpbGVzXG4gICAgcmVidWlsZEdlb21ldHJ5KCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gU2tpcCByZWJ1aWxkIGlmIGFscmVhZHkgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1aWxkaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gUXVldWUgdXAgdG8gb25lIHJlYnVpbGQgY2FsbCBhdCBhIHRpbWUsIG9ubHkgc2F2ZSBsYXN0IHJlcXVlc3RcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5idWlsZGluZy5xdWV1ZWQgJiYgdGhpcy5idWlsZGluZy5xdWV1ZWQucmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGlmeSBwcmV2aW91cyByZXF1ZXN0IHRoYXQgaXQgZGlkIG5vdCBjb21wbGV0ZVxuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ1NjZW5lLnJlYnVpbGRHZW9tZXRyeTogcmVxdWVzdCBzdXBlcmNlZGVkIGJ5IGEgbmV3ZXIgY2FsbCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkaW5nLnF1ZXVlZC5yZXNvbHZlKGZhbHNlKTsgLy8gZmFsc2UgZmxhZyBpbmRpY2F0ZXMgcmVidWlsZCByZXF1ZXN0IHdhcyBzdXBlcmNlZGVkXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBxdWV1ZWQgcmVxdWVzdFxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcucXVldWVkID0geyByZXNvbHZlLCByZWplY3QgfTtcbiAgICAgICAgICAgICAgICBsb2cudHJhY2UoYFNjZW5lLnJlYnVpbGRHZW9tZXRyeSgpOiBxdWV1aW5nIHJlcXVlc3RgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRyYWNrIHRpbGUgYnVpbGQgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcgPSB7IHJlc29sdmUsIHJlamVjdCB9O1xuXG4gICAgICAgICAgICAvLyBQcm9maWxpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnLnByb2ZpbGUuZ2VvbWV0cnlfYnVpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9maWxlKCdyZWJ1aWxkR2VvbWV0cnknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIGNvbmZpZyAoaW4gY2FzZSBKUyBvYmplY3RzIHdlcmUgbWFuaXB1bGF0ZWQgZGlyZWN0bHkpXG4gICAgICAgICAgICB0aGlzLnN5bmNDb25maWdUb1dvcmtlcigpO1xuICAgICAgICAgICAgU3R5bGVNYW5hZ2VyLmNvbXBpbGUodGhpcy51cGRhdGVBY3RpdmVTdHlsZXMoKSwgdGhpcyk7IC8vIG9ubHkgcmVjb21waWxlIG5ld2x5IGFjdGl2ZSBzdHlsZXNcbiAgICAgICAgICAgIHRoaXMucmVzZXRGZWF0dXJlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0VGltZSgpO1xuXG4gICAgICAgICAgICAvLyBSZWJ1aWxkIHZpc2libGUgdGlsZXMsIHNvcnRlZCBmcm9tIGNlbnRlclxuICAgICAgICAgICAgbGV0IGJ1aWxkID0gW107XG4gICAgICAgICAgICB0aGlzLnRpbGVfbWFuYWdlci5mb3JFYWNoVGlsZSgodGlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aWxlLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGQucHVzaCh0aWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGlsZV9tYW5hZ2VyLnJlbW92ZVRpbGUodGlsZS5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50aWxlX21hbmFnZXIuYnVpbGRUaWxlcyhidWlsZCk7XG4gICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gUHJvZmlsaW5nXG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zy5wcm9maWxlLmdlb21ldHJ5X2J1aWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZmlsZUVuZCgncmVidWlsZEdlb21ldHJ5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFRpbGUgbWFuYWdlciBmaW5pc2hlZCBidWlsZGluZyB0aWxlc1xuICAgIHRpbGVNYW5hZ2VyQnVpbGREb25lKCkge1xuICAgICAgICBpZiAodGhpcy5idWlsZGluZykge1xuICAgICAgICAgICAgbG9nLmluZm8oYFNjZW5lOiBidWlsZCBnZW9tZXRyeSBmaW5pc2hlZGApO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVpbGRpbmcucmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQW5vdGhlciByZWJ1aWxkIHF1ZXVlZD9cbiAgICAgICAgICAgIHZhciBxdWV1ZWQgPSB0aGlzLmJ1aWxkaW5nLnF1ZXVlZDtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHF1ZXVlZCkge1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhgU2NlbmU6IHN0YXJ0aW5nIHF1ZXVlZCByZWJ1aWxkR2VvbWV0cnkoKSByZXF1ZXN0YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWJ1aWxkR2VvbWV0cnkoKS50aGVuKHF1ZXVlZC5yZXNvbHZlLCBxdWV1ZWQucmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAgIExvYWQgKG9yIHJlbG9hZCkgdGhlIHNjZW5lIGNvbmZpZ1xuICAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICBsb2FkU2NlbmUoY29uZmlnX3NvdXJjZSA9IG51bGwsIGNvbmZpZ19wYXRoID0gbnVsbCkge1xuICAgICAgICB0aGlzLmNvbmZpZ19zb3VyY2UgPSBjb25maWdfc291cmNlIHx8IHRoaXMuY29uZmlnX3NvdXJjZTtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29uZmlnX3NvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnX3BhdGggPSBVdGlscy5wYXRoRm9yVVJMKGNvbmZpZ19wYXRoIHx8IHRoaXMuY29uZmlnX3NvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ19wYXRoID0gVXRpbHMucGF0aEZvclVSTChjb25maWdfcGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU2NlbmVMb2FkZXIubG9hZFNjZW5lKHRoaXMuY29uZmlnX3NvdXJjZSwgdGhpcy5jb25maWdfcGF0aCkudGhlbihjb25maWcgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2xvYWQnLCB7IGNvbmZpZzogdGhpcy5jb25maWcgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWc7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxvYWREYXRhU291cmNlcygpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLmNvbmZpZy5zb3VyY2VzKSB7XG4gICAgICAgICAgICBsZXQgc291cmNlID0gdGhpcy5jb25maWcuc291cmNlc1tuYW1lXTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlc1tuYW1lXSA9IERhdGFTb3VyY2UuY3JlYXRlKE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZSwge25hbWV9KSk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5zb3VyY2VzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc291cmNlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBsb2cud2FybihgU2NlbmU6IGNvdWxkIG5vdCBjcmVhdGUgZGF0YSBzb3VyY2VgLCBzb3VyY2UpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybmluZycsIHsgdHlwZTogJ3NvdXJjZXMnLCBzb3VyY2UsIG1lc3NhZ2U6IGBDb3VsZCBub3QgY3JlYXRlIGRhdGEgc291cmNlYCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIExvYWQgYWxsIHRleHR1cmVzIGluIHRoZSBzY2VuZSBkZWZpbml0aW9uXG4gICAgbG9hZFRleHR1cmVzKCkge1xuICAgICAgICByZXR1cm4gVGV4dHVyZS5jcmVhdGVGcm9tT2JqZWN0KHRoaXMuZ2wsIHRoaXMuY29uZmlnLnRleHR1cmVzKTtcbiAgICB9XG5cbiAgICAvLyBDYWxsZWQgKGN1cnJlbnRseSBtYW51YWxseSkgYWZ0ZXIgc3R5bGVzIGFyZSB1cGRhdGVkIGluIHN0eWxlc2hlZXRcbiAgICB1cGRhdGVTdHlsZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCAmJiAhdGhpcy5pbml0aWFsaXppbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2NlbmUudXBkYXRlU3R5bGVzKCkgY2FsbGVkIGJlZm9yZSBzY2VuZSB3YXMgaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIChSZSlidWlsZCBzdHlsZXMgZnJvbSBjb25maWdcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBTdHlsZU1hbmFnZXIuYnVpbGQodGhpcy5jb25maWcuc3R5bGVzLCB0aGlzKTtcblxuICAgICAgICAvLyBPcHRpb25hbGx5IHNldCBHTCBjb250ZXh0ICh1c2VkIHdoZW4gaW5pdGlhbGl6aW5nIG9yIHJlLWluaXRpYWxpemluZyBHTCByZXNvdXJjZXMpXG4gICAgICAgIGZvciAodmFyIHN0eWxlIG9mIFV0aWxzLnZhbHVlcyh0aGlzLnN0eWxlcykpIHtcbiAgICAgICAgICAgIHN0eWxlLnNldEdMKHRoaXMuZ2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZCAmIGNvbXBpbGUgYWN0aXZlIHN0eWxlc1xuICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZVN0eWxlcygpO1xuICAgICAgICBTdHlsZU1hbmFnZXIuY29tcGlsZShPYmplY3Qua2V5cyh0aGlzLmFjdGl2ZV9zdHlsZXMpLCB0aGlzKTtcblxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB1cGRhdGVBY3RpdmVTdHlsZXMoKSB7XG4gICAgICAgIC8vIE1ha2UgYSBzZXQgb2YgY3VycmVudGx5IGFjdGl2ZSBzdHlsZXMgKHVzZWQgaW4gYSBkcmF3IHJ1bGUpXG4gICAgICAgIC8vIE5vdGU6IGRvZXNuJ3QgYWN0dWFsbHkgY2hlY2sgaWYgYW55IGdlb21ldHJ5IG1hdGNoZXMgdGhlIHJ1bGUsIGp1c3QgdGhhdCB0aGUgc3R5bGUgaXMgcG90ZW50aWFsbHkgcmVuZGVyYWJsZVxuICAgICAgICBsZXQgcHJldl9zdHlsZXMgPSBPYmplY3Qua2V5cyh0aGlzLmFjdGl2ZV9zdHlsZXMgfHwge30pO1xuICAgICAgICB0aGlzLmFjdGl2ZV9zdHlsZXMgPSB7fTtcbiAgICAgICAgdmFyIGFuaW1hdGVkID0gZmFsc2U7IC8vIGlzIGFueSBhY3RpdmUgc3R5bGUgYW5pbWF0ZWQ/XG4gICAgICAgIGZvciAodmFyIHJ1bGUgb2YgVXRpbHMucmVjdXJzZVZhbHVlcyh0aGlzLmNvbmZpZy5sYXllcnMpKSB7XG4gICAgICAgICAgICBpZiAocnVsZSAmJiBydWxlLmRyYXcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBbbmFtZSwgZ3JvdXBdIG9mIFV0aWxzLmVudHJpZXMocnVsZS5kcmF3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3YXJuIG9uIG5vbi1vYmplY3QgZHJhdyBncm91cFxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCAmJiB0eXBlb2YgZ3JvdXAgPT09ICdvYmplY3QnICYmIGdyb3VwLnZpc2libGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGVfbmFtZSA9IGdyb3VwLnN0eWxlIHx8IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGVzID0gW3N0eWxlX25hbWVdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25hbCBhZGRpdGlvbmFsIG91dGxpbmUgc3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cC5vdXRsaW5lICYmIGdyb3VwLm91dGxpbmUuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChncm91cC5vdXRsaW5lLnN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0gc3R5bGVzLmZpbHRlcih4ID0+IHRoaXMuc3R5bGVzW3hdKS5mb3JFYWNoKHN0eWxlX25hbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IHRoaXMuc3R5bGVzW3N0eWxlX25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZV9zdHlsZXNbc3R5bGVfbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUuYW5pbWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIGV4cGxpY2l0bHkgc2V0IHNjZW5lIGFuaW1hdGlvbiBmbGFnIGlmIGRlZmluZWQsIG90aGVyd2lzZSB0dXJuIG9uIGFuaW1hdGlvblxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgYW55IGFuaW1hdGVkIHN0eWxlc1xuICAgICAgICB0aGlzLmFuaW1hdGVkID0gdGhpcy5jb25maWcuc2NlbmUuYW5pbWF0ZWQgIT09IHVuZGVmaW5lZCA/IHRoaXMuY29uZmlnLnNjZW5lLmFuaW1hdGVkIDogYW5pbWF0ZWQ7XG5cbiAgICAgICAgLy8gQ29tcGlsZSBuZXdseSBhY3RpdmUgc3R5bGVzXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmFjdGl2ZV9zdHlsZXMpLmZpbHRlcihzID0+IHByZXZfc3R5bGVzLmluZGV4T2YocykgPT09IC0xKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgY2FtZXJhXG4gICAgY3JlYXRlQ2FtZXJhKCkge1xuICAgICAgICBsZXQgYWN0aXZlX2NhbWVyYSA9IHRoaXMuX2FjdGl2ZV9jYW1lcmE7XG4gICAgICAgIGlmIChhY3RpdmVfY2FtZXJhKSB7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYSA9IENhbWVyYS5jcmVhdGUoYWN0aXZlX2NhbWVyYSwgdGhpcywgdGhpcy5jb25maWcuY2FtZXJhc1t0aGlzLl9hY3RpdmVfY2FtZXJhXSk7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGxhY2UgdGhpcyBhbmQgbW92ZSBhbGwgcG9zaXRpb24gaW5mbyB0byBjYW1lcmFcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVNjZW5lKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXQgYWN0aXZlIGNhbWVyYSAtIGZvciBwdWJsaWMgQVBJXG4gICAgZ2V0QWN0aXZlQ2FtZXJhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlX2NhbWVyYTtcbiAgICB9XG5cbiAgICAvLyBTZXQgYWN0aXZlIGNhbWVyYSBhbmQgcmVjb21waWxlIC0gZm9yIHB1YmxpYyBBUElcbiAgICBzZXRBY3RpdmVDYW1lcmEobmFtZSkge1xuICAgICAgICB0aGlzLl9hY3RpdmVfY2FtZXJhID0gbmFtZTtcbiAgICAgICAgdGhpcy51cGRhdGVDb25maWcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZV9jYW1lcmE7XG4gICAgfVxuXG4gICAgLy8gSW50ZXJuYWwgbWFuYWdlbWVudCBvZiBhY3RpdmUgY2FtZXJhXG4gICAgZ2V0IF9hY3RpdmVfY2FtZXJhKCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcgJiYgdGhpcy5jb25maWcuY2FtZXJhcykge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLmNvbmZpZy5jYW1lcmFzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmNhbWVyYXNbbmFtZV0uYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldCBfYWN0aXZlX2NhbWVyYShuYW1lKSB7XG4gICAgICAgIHZhciBwcmV2ID0gdGhpcy5fYWN0aXZlX2NhbWVyYTtcblxuICAgICAgICAvLyBTZXQgbmV3IGFjdGl2ZSBjYW1lcmFcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmNhbWVyYXNbbmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmNhbWVyYXNbbmFtZV0uYWN0aXZlID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQ2xlYXIgcHJldmlvdXNseSBhY3RpdmUgY2FtZXJhXG4gICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2ICE9PSBuYW1lICYmIHRoaXMuY29uZmlnLmNhbWVyYXNbcHJldl0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jb25maWcuY2FtZXJhc1twcmV2XS5hY3RpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbGlnaHRpbmdcbiAgICBjcmVhdGVMaWdodHMoKSB7XG4gICAgICAgIHRoaXMubGlnaHRzID0ge307XG4gICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5jb25maWcubGlnaHRzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmxpZ2h0c1tpXSB8fCB0eXBlb2YgdGhpcy5jb25maWcubGlnaHRzW2ldICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxpZ2h0ID0gdGhpcy5jb25maWcubGlnaHRzW2ldO1xuICAgICAgICAgICAgbGlnaHQubmFtZSA9IGkucmVwbGFjZSgnLScsICdfJyk7IC8vIGxpZ2h0IG5hbWVzIGFyZSBpbmplY3RlZCBpbiBzaGFkZXJzLCBjYW4ndCBoYXZlIGh5cGhlbnNcbiAgICAgICAgICAgIGxpZ2h0LnZpc2libGUgPSAobGlnaHQudmlzaWJsZSA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlO1xuICAgICAgICAgICAgaWYgKGxpZ2h0LnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpZ2h0c1tsaWdodC5uYW1lXSA9IExpZ2h0LmNyZWF0ZSh0aGlzLCBsaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTGlnaHQuaW5qZWN0KHRoaXMubGlnaHRzKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgYmFja2dyb3VuZCBjb2xvclxuICAgIHNldEJhY2tncm91bmQoKSB7XG4gICAgICAgIGxldCBiZyA9IHRoaXMuY29uZmlnLnNjZW5lLmJhY2tncm91bmQ7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IHt9O1xuICAgICAgICBpZiAoYmcgJiYgYmcuY29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZC5jb2xvciA9IFN0eWxlUGFyc2VyLnBhcnNlQ29sb3IoYmcuY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5iYWNrZ3JvdW5kLmNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmQuY29sb3IgPSBbMCwgMCwgMCwgMF07IC8vIGRlZmF1bHQgYmFja2dyb3VuZCBUT0RPOiB2YXJ5IHcvc2NlbmUgYWxwaGFcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGJhY2tncm91bmQgaXMgZnVsbHkgb3BhcXVlLCBzZXQgY2FudmFzIGJhY2tncm91bmQgdG8gbWF0Y2hcbiAgICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZC5jb2xvclszXSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID1cbiAgICAgICAgICAgICAgICBgcmdiYSgke3RoaXMuYmFja2dyb3VuZC5jb2xvci5tYXAoYyA9PiBNYXRoLmZsb29yKGMgKiAyNTUpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzY2VuZSBjb25maWcsIGFuZCBvcHRpb25hbGx5IHJlYnVpbGQgZ2VvbWV0cnlcbiAgICB1cGRhdGVDb25maWcoeyByZWJ1aWxkIH0gPSB7fSkge1xuICAgICAgICB0aGlzLmdlbmVyYXRpb24rKztcbiAgICAgICAgdGhpcy51cGRhdGluZysrO1xuICAgICAgICB0aGlzLmNvbmZpZy5zY2VuZSA9IHRoaXMuY29uZmlnLnNjZW5lIHx8IHt9O1xuXG4gICAgICAgIFN0eWxlTWFuYWdlci5pbml0KCk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ2FtZXJhKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlTGlnaHRzKCk7XG4gICAgICAgIHRoaXMubG9hZERhdGFTb3VyY2VzKCk7XG4gICAgICAgIHRoaXMubG9hZFRleHR1cmVzKCk7XG4gICAgICAgIHRoaXMuc2V0QmFja2dyb3VuZCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuXG4gICAgICAgIC8vIFRPRE86IGRldGVjdCBjaGFuZ2VzIHRvIHN0eWxlcz8gYWxyZWFkeSAoY3VycmVudGx5KSBuZWVkIHRvIHJlY29tcGlsZSBhbnl3YXkgd2hlbiBjYW1lcmEgb3IgbGlnaHRzIGNoYW5nZVxuICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlcygpO1xuICAgICAgICB0aGlzLnN5bmNDb25maWdUb1dvcmtlcigpO1xuICAgICAgICBpZiAocmVidWlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVidWlsZEdlb21ldHJ5KCkudGhlbigoKSA9PiB7IHRoaXMudXBkYXRpbmctLTsgdGhpcy5yZXF1ZXN0UmVkcmF3KCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGluZy0tO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UmVkcmF3KCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXJpYWxpemUgY29uZmlnIGFuZCBzZW5kIHRvIHdvcmtlclxuICAgIHN5bmNDb25maWdUb1dvcmtlcigpIHtcbiAgICAgICAgLy8gVGVsbCB3b3JrZXJzIHdlJ3JlIGFib3V0IHRvIHJlYnVpbGQgKHNvIHRoZXkgY2FuIHVwZGF0ZSBzdHlsZXMsIGV0Yy4pXG4gICAgICAgIHRoaXMuY29uZmlnX3NlcmlhbGl6ZWQgPSBVdGlscy5zZXJpYWxpemVXaXRoRnVuY3Rpb25zKHRoaXMuY29uZmlnKTtcbiAgICAgICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHRoaXMud29ya2VycywgJ3NlbGYudXBkYXRlQ29uZmlnJywge1xuICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZ19zZXJpYWxpemVkLFxuICAgICAgICAgICAgZ2VuZXJhdGlvbjogdGhpcy5nZW5lcmF0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlc2V0RmVhdHVyZVNlbGVjdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgRmVhdHVyZVNlbGVjdGlvbih0aGlzLmdsLCB0aGlzLndvcmtlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMud29ya2Vycykge1xuICAgICAgICAgICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHRoaXMud29ya2VycywgJ3NlbGYucmVzZXRGZWF0dXJlU2VsZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXRzIHRoZSBjdXJyZW50IGZlYXR1cmUgc2VsZWN0aW9uIG1hcCBzaXplIGFjcm9zcyBhbGwgd29ya2Vycy4gUmV0dXJucyBhIHByb21pc2UuXG4gICAgZ2V0RmVhdHVyZVNlbGVjdGlvbk1hcFNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmZldGNoaW5nX3NlbGVjdGlvbl9tYXApIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmV0Y2hpbmdfc2VsZWN0aW9uX21hcCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSh0aGlzLndvcmtlcnMsICdzZWxmLmdldEZlYXR1cmVTZWxlY3Rpb25NYXBTaXplJylcbiAgICAgICAgICAgIC50aGVuKHNpemVzID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZldGNoaW5nX3NlbGVjdGlvbl9tYXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYik7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBpbnRlcm5hbCBjbG9jaywgbW9zdGx5IHVzZWZ1bCBmb3IgY29uc2lzdGVudCBleHBlcmllbmNlIHdoZW4gY2hhbmdpbmcgc3R5bGVzL2RlYnVnZ2luZ1xuICAgIHJlc2V0VGltZSgpIHtcbiAgICAgICAgdGhpcy5zdGFydF90aW1lID0gK25ldyBEYXRlKCk7XG4gICAgfVxuXG5cbiAgICAvLyBTdGF0cy9kZWJ1Zy9wcm9maWxpbmcgbWV0aG9kc1xuXG4gICAgLy8gTG9nIG1lc3NhZ2VzIHBhc3MgdGhyb3VnaCBmcm9tIHdlYiB3b3JrZXJzXG4gICAgd29ya2VyTG9nTWVzc2FnZShldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YS50eXBlICE9PSAnbG9nJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHsgd29ya2VyX2lkLCBsZXZlbCwgbXNnIH0gPSBldmVudC5kYXRhO1xuXG4gICAgICAgIGlmIChsb2dbbGV2ZWxdKSB7XG4gICAgICAgICAgICBsb2dbbGV2ZWxdKGB3b3JrZXIgJHt3b3JrZXJfaWR9OmAsICAuLi5tc2cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nLmVycm9yKGBTY2VuZS53b3JrZXJMb2dNZXNzYWdlOiB1bnJlY29nbml6ZWQgbG9nIGxldmVsICR7bGV2ZWx9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm9maWxlIGhlbHBlcnMsIGlzc3VlcyBhIHByb2ZpbGUgb24gbWFpbiB0aHJlYWQgJiBhbGwgd29ya2Vyc1xuICAgIF9wcm9maWxlKG5hbWUpIHtcbiAgICAgICAgY29uc29sZS5wcm9maWxlKGBtYWluIHRocmVhZDogJHtuYW1lfWApO1xuICAgICAgICBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UodGhpcy53b3JrZXJzLCAnc2VsZi5wcm9maWxlJywgbmFtZSk7XG4gICAgfVxuXG4gICAgX3Byb2ZpbGVFbmQobmFtZSkge1xuICAgICAgICBjb25zb2xlLnByb2ZpbGVFbmQoYG1haW4gdGhyZWFkOiAke25hbWV9YCk7XG4gICAgICAgIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSh0aGlzLndvcmtlcnMsICdzZWxmLnByb2ZpbGVFbmQnLCBuYW1lKTtcbiAgICB9XG5cbiAgICAvLyBSZWJ1aWxkIGdlb21ldHJ5IGEgZ2l2ZW4gIyBvZiB0aW1lcyBhbmQgcHJpbnQgYXZlcmFnZSwgbWluLCBtYXggdGltaW5nc1xuICAgIF90aW1lUmVidWlsZCAobnVtID0gMSkge1xuICAgICAgICBsZXQgdGltZXMgPSBbXTtcbiAgICAgICAgbGV0IGN5Y2xlID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gK25ldyBEYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnJlYnVpbGQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aW1lcy5wdXNoKCtuZXcgRGF0ZSgpIC0gc3RhcnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVzLmxlbmd0aCA8IG51bSkge1xuICAgICAgICAgICAgICAgICAgICBjeWNsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGF2ZyA9IH5+KHRpbWVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8gdGltZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nLmluZm8oYFByb2ZpbGVkIHJlYnVpbGQgJHtudW19IHRpbWVzOiAke2F2Z30gYXZnICgke01hdGgubWluKC4uLnRpbWVzKX0gbWluLCAke01hdGgubWF4KC4uLnRpbWVzKX0gbWF4KWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjeWNsZSgpO1xuICAgIH1cblxufVxuXG4vLyBTdGF0aWMgbWV0aG9kcy9zdGF0ZVxuXG5TY2VuZS5jcmVhdGUgPSBmdW5jdGlvbiAoY29uZmlnLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFNjZW5lKGNvbmZpZywgb3B0aW9ucyk7XG59O1xuIiwiaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IEdMU0wgZnJvbSAnLi9nbC9nbHNsJztcbi8vIGltcG9ydCBtZXJnZU9iamVjdHMgZnJvbSAnLi91dGlscy9tZXJnZSc7XG5pbXBvcnQge1N0eWxlTWFuYWdlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfbWFuYWdlcic7XG5cbnZhciBTY2VuZUxvYWRlcjtcblxuZXhwb3J0IGRlZmF1bHQgU2NlbmVMb2FkZXIgPSB7XG5cbiAgICAvLyBMb2FkIHNjZW5lcyBkZWZpbml0aW9ucyBmcm9tIFVSTCAmIHByb3Byb2Nlc3NcbiAgICBsb2FkU2NlbmUodXJsLCBwYXRoID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gU2NlbmVMb2FkZXIubG9hZFNjZW5lUmVjdXJzaXZlKHVybCwgcGF0aCkudGhlbihTY2VuZUxvYWRlci5maW5hbGl6ZSk7XG4gICAgfSxcblxuICAgIC8vIExvYWRzIHNjZW5lIGZpbGVzIGZyb20gVVJMLCByZWN1cnNpdmVseSBsb2FkaW5nICdpbmNsdWRlZCcgc2NlbmVzXG4gICAgLy8gT3B0aW9uYWwgKmluaXRpYWwqIHBhdGggb25seSAod29uJ3QgYmUgcGFzc2VkIHRvIHJlY3Vyc2l2ZSAnaW5jbHVkZScgY2FsbHMpXG4gICAgLy8gVXNlZnVsIGZvciBsb2FkaW5nIHJlc291cmNlcyBpbiBiYXNlIHNjZW5lIGZpbGUgZnJvbSBhIHNlcGFyYXRlIGxvY2F0aW9uXG4gICAgLy8gKGUuZy4gaW4gVGFuZ3JhbSBQbGF5LCB3aGVuIG1vZGlmaWVkIGxvY2FsIHNjZW5lIHNob3VsZCBzdGlsbCByZWZlciB0byBvcmlnaW5hbCByZXNvdXJjZSBVUkxzKVxuICAgIGxvYWRTY2VuZVJlY3Vyc2l2ZSh1cmwsIHBhdGggPSBudWxsKSB7XG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGggfHwgVXRpbHMucGF0aEZvclVSTCh1cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFV0aWxzLmxvYWRSZXNvdXJjZSh1cmwpLnRoZW4oY29uZmlnID0+IHtcbiAgICAgICAgICAgIHJldHVybiBTdHlsZU1hbmFnZXIubG9hZFJlbW90ZVN0eWxlcyhjb25maWcuc3R5bGVzLCBwYXRoKS5cbiAgICAgICAgICAgICAgICB0aGVuKHN0eWxlcyA9PiBTdHlsZU1hbmFnZXIubG9hZFNoYWRlckJsb2NrcyhzdHlsZXMsIHBhdGgpKS4gLy8gVE9ETzogZGVwcmVjYXRlIHJlbW90ZSBzaGFkZXIgYmxvY2tzP1xuICAgICAgICAgICAgICAgIHRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBhY2NlcHQgc2luZ2xlLXN0cmluZyBvciBhcnJheVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAodHlwZW9mIGNvbmZpZy5pbmNsdWRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgY29uZmlnLmluY2x1ZGUgPSBbY29uZmlnLmluY2x1ZGVdO1xuICAgICAgICAgICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZy5pbmNsdWRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgU2NlbmVMb2FkZXIubm9ybWFsaXplKGNvbmZpZywgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGVjdCBVUkxzIG9mIHNjZW5lcyB0byBpbmNsdWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCBpbmNsdWRlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgKGxldCB1cmwgb2YgY29uZmlnLmluY2x1ZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGluY2x1ZGVzLnB1c2goVXRpbHMuYWRkQmFzZVVSTCh1cmwsIHBhdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUgY29uZmlnLmluY2x1ZGU7IC8vIGRvbid0IHdhbnQgdG8gbWVyZ2UgdGhpcyBwcm9wZXJ0eVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBQcm9taXNlLlxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgYWxsKGluY2x1ZGVzLm1hcCh1cmwgPT4gU2NlbmVMb2FkZXIubG9hZFNjZW5lUmVjdXJzaXZlKHVybCkpKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoZW4oY29uZmlncyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgY29uZmlnID0gbWVyZ2VPYmplY3RzKHt9LCAuLi5jb25maWdzLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIFNjZW5lTG9hZGVyLm5vcm1hbGl6ZShjb25maWcsIHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIE5vcm1hbGl6ZSBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIGFkanVzdCB3aXRoaW4gZWFjaCBsb2NhbCBzY2VuZSBmaWxlICh1c3VhbGx5IGJ5IHBhdGgpXG4gICAgbm9ybWFsaXplKGNvbmZpZywgcGF0aCkge1xuICAgICAgICBTY2VuZUxvYWRlci5ub3JtYWxpemVEYXRhU291cmNlcyhjb25maWcsIHBhdGgpO1xuICAgICAgICBTY2VuZUxvYWRlci5ub3JtYWxpemVUZXh0dXJlcyhjb25maWcsIHBhdGgpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH0sXG5cbiAgICAvLyBFeHBhbmQgcGF0aHMgZm9yIGRhdGEgc291cmNlXG4gICAgbm9ybWFsaXplRGF0YVNvdXJjZXMoY29uZmlnLCBwYXRoKSB7XG4gICAgICAgIGNvbmZpZy5zb3VyY2VzID0gY29uZmlnLnNvdXJjZXMgfHwge307XG5cbiAgICAgICAgZm9yIChsZXQgc291cmNlIG9mICBVdGlscy52YWx1ZXMoY29uZmlnLnNvdXJjZXMpKSB7XG4gICAgICAgICAgICBzb3VyY2UudXJsID0gVXRpbHMuYWRkQmFzZVVSTChzb3VyY2UudXJsLCBwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfSxcblxuICAgIC8vIEV4cGFuZCBwYXRocyBhbmQgY2VudHJhbGl6ZSB0ZXh0dXJlIGRlZmluaXRpb25zIGZvciBhIHNjZW5lIG9iamVjdFxuICAgIG5vcm1hbGl6ZVRleHR1cmVzKGNvbmZpZywgcGF0aCkge1xuICAgICAgICBjb25maWcudGV4dHVyZXMgPSBjb25maWcudGV4dHVyZXMgfHwge307XG5cbiAgICAgICAgaWYgKGNvbmZpZy5zdHlsZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IFtzdHlsZV9uYW1lLCBzdHlsZV0gb2YgVXRpbHMuZW50cmllcyhjb25maWcuc3R5bGVzKSkge1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXggPSBzdHlsZS50ZXh0dXJlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRleHR1cmUgYnkgVVJMLCBleHBhbmQgcmVsYXRpdmUgdG8gc2NlbmUgZmlsZVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRleCA9PT0gJ3N0cmluZycgJiYgIWNvbmZpZy50ZXh0dXJlc1t0ZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS50ZXh0dXJlID0gVXRpbHMuYWRkQmFzZVVSTCh0ZXgsIHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRleHR1cmUgYnkgb2JqZWN0LCBtb3ZlIGl0IHRvIHRoZSBnbG9iYWwgc2NlbmUgdGV4dHVyZSBzZXQgYW5kIGdpdmUgaXQgYSBkZWZhdWx0IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRleCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0dXJlX25hbWUgPSAnX18nICsgc3R5bGVfbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy50ZXh0dXJlc1t0ZXh0dXJlX25hbWVdID0gdGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUudGV4dHVyZSA9IHRleHR1cmVfbmFtZTsgLy8gcG9pbnQgc3R5bGUgdG8gbG9jYXRpb24gb2YgdGV4dHVyZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgc3R5bGUgaGFzIHRleHR1cmUgdW5pZm9ybXMsIGV4cGFuZCB0ZXh0dXJlIFVSTHMgcmVsYXRpdmUgdG8gc2NlbmUgZmlsZVxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5zaGFkZXJzICYmIHN0eWxlLnNoYWRlcnMudW5pZm9ybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQge3R5cGUsIHZhbHVlLCBrZXksIHVuaWZvcm1zfSBvZiBHTFNMLnBhcnNlVW5pZm9ybXMoc3R5bGUuc2hhZGVycy51bmlmb3JtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnc2FtcGxlcjJEJyAmJiAhY29uZmlnLnRleHR1cmVzW3ZhbHVlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zW2tleV0gPSBVdGlscy5hZGRCYXNlVVJMKHZhbHVlLCBwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHN0eWxlIGhhcyBtYXRlcmlhbCwgZXhwYW5kIHRleHR1cmUgVVJMcyByZWxhdGl2ZSB0byBzY2VuZSBmaWxlXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLm1hdGVyaWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHByb3Agb2YgWydlbWlzc2lvbicsICdhbWJpZW50JywgJ2RpZmZ1c2UnLCAnc3BlY3VsYXInLCAnbm9ybWFsJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGVyaWFsIHByb3BlcnR5IGhhcyBhIHRleHR1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZS5tYXRlcmlhbFtwcm9wXSAhPSBudWxsICYmIHN0eWxlLm1hdGVyaWFsW3Byb3BdLnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4ID0gc3R5bGUubWF0ZXJpYWxbcHJvcF0udGV4dHVyZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRleHR1cmUgYnkgVVJMLCBleHBhbmQgcmVsYXRpdmUgdG8gc2NlbmUgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGV4ID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhY29uZmlnLnRleHR1cmVzW3RleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUubWF0ZXJpYWxbcHJvcF0udGV4dHVyZSA9IFV0aWxzLmFkZEJhc2VVUkwodGV4LCBwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGV4dHVyZSBieSBvYmplY3QsIG1vdmUgaXQgdG8gdGhlIGdsb2JhbCBzY2VuZSB0ZXh0dXJlIHNldCBhbmQgZ2l2ZSBpdCBhIGRlZmF1bHQgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0ZXggPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0dXJlX25hbWUgPSAnX18nICsgc3R5bGVfbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnRleHR1cmVzW3RleHR1cmVfbmFtZV0gPSB0ZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLm1hdGVyaWFsW3Byb3BdLnRleHR1cmUgPSB0ZXh0dXJlX25hbWU7IC8vIHBvaW50IHN0eWxlIHRvIGxvY2F0aW9uIG9mIHRleHR1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgcGF0aCB0byB0ZXh0dXJlc1xuICAgICAgICBpZiAoY29uZmlnLnRleHR1cmVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0ZXh0dXJlIG9mIFV0aWxzLnZhbHVlcyhjb25maWcudGV4dHVyZXMpKSB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS51cmwgPSBVdGlscy5hZGRCYXNlVVJMKHRleHR1cmUudXJsLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfSxcblxuICAgIC8vIE5vcm1hbGl6ZSBzb21lIHNjZW5lLXdpZGUgc2V0dGluZ3MgdGhhdCBhcHBseSB0byB0aGUgZmluYWwsIG1lcmdlZCBzY2VuZVxuICAgIGZpbmFsaXplKGNvbmZpZykge1xuICAgICAgICAvLyBBc3NpZ24gaWRzIHRvIGRhdGEgc291cmNlc1xuICAgICAgICBsZXQgc291cmNlX2lkID0gMDtcbiAgICAgICAgZm9yIChsZXQgc291cmNlIGluIGNvbmZpZy5zb3VyY2VzKSB7XG4gICAgICAgICAgICBjb25maWcuc291cmNlc1tzb3VyY2VdLmlkID0gc291cmNlX2lkKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBvbmx5IG9uZSBjYW1lcmEgc3BlY2lmaWVkLCBzZXQgaXQgYXMgZGVmYXVsdFxuICAgICAgICBjb25maWcuY2FtZXJhcyA9IGNvbmZpZy5jYW1lcmFzIHx8IHt9O1xuICAgICAgICBpZiAoY29uZmlnLmNhbWVyYSkge1xuICAgICAgICAgICAgY29uZmlnLmNhbWVyYXMuZGVmYXVsdCA9IGNvbmZpZy5jYW1lcmE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBubyBjYW1lcmFzIHNwZWNpZmllZCwgY3JlYXRlIG9uZVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoY29uZmlnLmNhbWVyYXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLmNhbWVyYXMuZGVmYXVsdCA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gY2FtZXJhIHNldCBhcyBhY3RpdmUsIHVzZSBmaXJzdCBvbmVcbiAgICAgICAgbGV0IGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBjYW1lcmEgb2YgVXRpbHMudmFsdWVzKGNvbmZpZy5jYW1lcmFzKSkge1xuICAgICAgICAgICAgaWYgKGNhbWVyYS5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jYW1lcmFzW09iamVjdC5rZXlzKGNvbmZpZy5jYW1lcmFzKVswXV0uYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuc3VyZSB0b3AtbGV2ZWwgcHJvcGVydGllc1xuICAgICAgICBjb25maWcubGlnaHRzID0gY29uZmlnLmxpZ2h0cyB8fCB7fTtcbiAgICAgICAgY29uZmlnLnN0eWxlcyA9IGNvbmZpZy5zdHlsZXMgfHwge307XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbn07XG4iLCIvKmpzaGludCB3b3JrZXI6IHRydWUqL1xuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IFdvcmtlckJyb2tlciBmcm9tICcuL3V0aWxzL3dvcmtlcl9icm9rZXInOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbmltcG9ydCBtZXJnZU9iamVjdHMgZnJvbSAnLi91dGlscy9tZXJnZSc7XG5pbXBvcnQgVGlsZSBmcm9tICcuL3RpbGUnO1xuaW1wb3J0IERhdGFTb3VyY2UgZnJvbSAnLi9zb3VyY2VzL2RhdGFfc291cmNlJztcbmltcG9ydCBGZWF0dXJlU2VsZWN0aW9uIGZyb20gJy4vc2VsZWN0aW9uJztcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX3BhcnNlcic7XG5pbXBvcnQge1N0eWxlTWFuYWdlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfbWFuYWdlcic7XG5pbXBvcnQge3BhcnNlUnVsZXN9IGZyb20gJy4vc3R5bGVzL3J1bGUnO1xuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi9nbC90ZXh0dXJlJztcblxuZXhwb3J0IHZhciBTY2VuZVdvcmtlciA9IHNlbGY7XG5cbi8vIFdvcmtlciBmdW5jdGlvbmFsaXR5IHdpbGwgb25seSBiZSBkZWZpbmVkIGluIHdvcmtlciB0aHJlYWRcbmlmIChVdGlscy5pc1dvcmtlclRocmVhZCkge1xuXG5PYmplY3QuYXNzaWduKHNlbGYsIHtcblxuICAgIEZlYXR1cmVTZWxlY3Rpb24sXG5cbiAgICBzb3VyY2VzOiB7XG4gICAgICAgIHRpbGVzOiB7fSxcbiAgICAgICAgb2JqZWN0czoge31cbiAgICB9LFxuICAgIHN0eWxlczoge30sXG4gICAgcnVsZXM6IHt9LFxuICAgIGxheWVyczoge30sXG4gICAgdGlsZXM6IHt9LFxuICAgIG9iamVjdHM6IHt9LFxuICAgIGNvbmZpZzoge30sICAgICAvLyByYXcgY29uZmlnIChlLmcuIGZ1bmN0aW9ucywgbWFjcm9zLCBldGMuIG5vdCBleHBhbmRlZClcblxuICAgIC8vIEluaXRpYWxpemUgd29ya2VyXG4gICAgaW5pdCAod29ya2VyX2lkLCBudW1fd29ya2VycywgZGV2aWNlX3BpeGVsX3JhdGlvKSB7XG4gICAgICAgIHNlbGYuX3dvcmtlcl9pZCA9IHdvcmtlcl9pZDtcbiAgICAgICAgc2VsZi5udW1fd29ya2VycyA9IG51bV93b3JrZXJzO1xuICAgICAgICBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8gPSBkZXZpY2VfcGl4ZWxfcmF0aW87XG4gICAgICAgIEZlYXR1cmVTZWxlY3Rpb24uc2V0UHJlZml4KHNlbGYuX3dvcmtlcl9pZCk7XG4gICAgICAgIHJldHVybiB3b3JrZXJfaWQ7XG4gICAgfSxcblxuICAgIC8vIFN0YXJ0cyBhIGNvbmZpZyByZWZyZXNoXG4gICAgdXBkYXRlQ29uZmlnICh7IGNvbmZpZywgZ2VuZXJhdGlvbiB9KSB7XG4gICAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UoY29uZmlnKTtcblxuICAgICAgICBzZWxmLmxhc3RfY29uZmlnID0gbWVyZ2VPYmplY3RzKHt9LCBzZWxmLmNvbmZpZyk7XG4gICAgICAgIHNlbGYuY29uZmlnID0gbWVyZ2VPYmplY3RzKHt9LCBjb25maWcpO1xuICAgICAgICBzZWxmLmdlbmVyYXRpb24gPSBnZW5lcmF0aW9uO1xuXG4gICAgICAgIC8vIERhdGEgYmxvY2sgZnVuY3Rpb25zIGFyZSBub3QgbWFjcm8nZWQgYW5kIHdyYXBwZWQgbGlrZSB0aGUgcmVzdCBvZiB0aGUgc3R5bGUgZnVuY3Rpb25zIGFyZVxuICAgICAgICAvLyBUT0RPOiBwcm9iYWJseSB3YW50IGEgY2xlYW5lciB3YXkgdG8gZXhjbHVkZSB0aGVzZVxuICAgICAgICBmb3IgKGxldCBsYXllciBpbiBjb25maWcubGF5ZXJzKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmxheWVyc1tsYXllcl0pIHtcbiAgICAgICAgICAgICAgICBjb25maWcubGF5ZXJzW2xheWVyXS5kYXRhID0gVXRpbHMuc3RyaW5nc1RvRnVuY3Rpb25zKGNvbmZpZy5sYXllcnNbbGF5ZXJdLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGRhdGEgc291cmNlc1xuICAgICAgICBjb25maWcuc291cmNlcyA9IFV0aWxzLnN0cmluZ3NUb0Z1bmN0aW9ucyhTdHlsZVBhcnNlci5leHBhbmRNYWNyb3MoY29uZmlnLnNvdXJjZXMpKTsgLy8gcGFyc2UgbmV3IHNvdXJjZXNcbiAgICAgICAgc2VsZi5zb3VyY2VzLnRpbGVzID0ge307IC8vIGNsZWFyIHByZXZpb3VzIHNvdXJjZXNcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBjb25maWcuc291cmNlcykge1xuICAgICAgICAgICAgbGV0IHNvdXJjZSA9IERhdGFTb3VyY2UuY3JlYXRlKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZy5zb3VyY2VzW25hbWVdLCB7bmFtZX0pKTtcbiAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzb3VyY2UudGlsZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNvdXJjZXMudGlsZXNbbmFtZV0gPSBzb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEaXN0cmlidXRlIG9iamVjdCBzb3VyY2VzIGFjcm9zcyB3b3JrZXJzXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5pZCAlIHNlbGYubnVtX3dvcmtlcnMgPT09IHNlbGYuX3dvcmtlcl9pZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBMb2FkIHNvdXJjZSBpZiBub3QgY2FjaGVkXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc291cmNlcy5vYmplY3RzW25hbWVdID0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYub2JqZWN0c1tzb3VyY2UubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub2JqZWN0c1tzb3VyY2UubmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5sb2FkKHNlbGYub2JqZWN0c1tzb3VyY2UubmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xlYXIgdGlsZSBjYWNoZSBpZiBkYXRhIHNvdXJjZSBjb25maWcgY2hhbmdlZFxuICAgICAgICBpZiAoIXNlbGYuY29uZmlnLnNvdXJjZXMgfHxcbiAgICAgICAgICAgICFzZWxmLmxhc3RfY29uZmlnLnNvdXJjZXMgfHxcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNlbGYuY29uZmlnLnNvdXJjZXMpLnNvbWUocyA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHNlbGYuY29uZmlnLnNvdXJjZXNbc10pICE9PSBKU09OLnN0cmluZ2lmeShzZWxmLmxhc3RfY29uZmlnLnNvdXJjZXNbc10pO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHNlbGYudGlsZXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4cGFuZCBzdHlsZXNcbiAgICAgICAgY29uZmlnID0gVXRpbHMuc3RyaW5nc1RvRnVuY3Rpb25zKFN0eWxlUGFyc2VyLmV4cGFuZE1hY3Jvcyhjb25maWcpLCBTdHlsZVBhcnNlci53cmFwRnVuY3Rpb24pO1xuICAgICAgICBzZWxmLnN0eWxlcyA9IFN0eWxlTWFuYWdlci5idWlsZChjb25maWcuc3R5bGVzLCB7IGdlbmVyYXRpb246IHNlbGYuZ2VuZXJhdGlvbiB9KTtcblxuICAgICAgICAvLyBQYXJzZSBlYWNoIHRvcC1sZXZlbCBsYXllciBhcyBhIHNlcGFyYXRlIHJ1bGUgdHJlZVxuICAgICAgICBzZWxmLmxheWVycyA9IGNvbmZpZy5sYXllcnM7XG4gICAgICAgIHNlbGYucnVsZXMgPSBwYXJzZVJ1bGVzKHNlbGYubGF5ZXJzKTtcblxuICAgICAgICAvLyBTeW5jIHRldHh1cmUgaW5mbyBmcm9tIG1haW4gdGhyZWFkXG4gICAgICAgIHNlbGYuc3luY2luZ190ZXh0dXJlcyA9IHNlbGYuc3luY1RleHR1cmVzKGNvbmZpZy50ZXh0dXJlcyk7XG5cbiAgICAgICAgLy8gUmV0dXJuIHByb21pc2UgZm9yIHdoZW4gY29uZmlnIHJlZnJlc2ggZmluaXNoZXNcbiAgICAgICAgc2VsZi5jb25maWd1cmluZyA9IHNlbGYuc3luY2luZ190ZXh0dXJlcy50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIFV0aWxzLmxvZygnZGVidWcnLCBgdXBkYXRlZCBjb25maWdgKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2hlbiBjb25maWcgcmVmcmVzaCBpcyBmaW5pc2hlZFxuICAgIGF3YWl0Q29uZmlndXJhdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNvbmZpZ3VyaW5nO1xuICAgIH0sXG5cbiAgICAvLyBCdWlsZCBhIHRpbGU6IGxvYWQgZnJvbSB0aWxlIHNvdXJjZSBpZiBidWlsZGluZyBmb3IgZmlyc3QgdGltZSwgb3RoZXJ3aXNlIHJlYnVpbGQgd2l0aCBleGlzdGluZyBkYXRhXG4gICAgYnVpbGRUaWxlICh7IHRpbGUgfSkge1xuICAgICAgICAvLyBUaWxlIGNhY2hlZD9cbiAgICAgICAgaWYgKHNlbGYudGlsZXNbdGlsZS5rZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEFscmVhZHkgbG9hZGluZz9cbiAgICAgICAgICAgIGlmIChzZWxmLnRpbGVzW3RpbGUua2V5XS5sb2FkaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRpbGUgY2FjaGVcbiAgICAgICAgdGlsZSA9IHNlbGYudGlsZXNbdGlsZS5rZXldID0gT2JqZWN0LmFzc2lnbihzZWxmLnRpbGVzW3RpbGUua2V5XSB8fCB7fSwgdGlsZSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGNvbmZpZyAoc3R5bGVzLCBldGMuKSwgdGhlbiBidWlsZCB0aWxlXG4gICAgICAgIHJldHVybiBzZWxmLmF3YWl0Q29uZmlndXJhdGlvbigpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gRmlyc3QgdGltZSBidWlsZGluZyB0aGUgdGlsZVxuICAgICAgICAgICAgaWYgKHRpbGUubG9hZGVkICE9PSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIHRpbGUubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRpbGUubG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRpbGUuZXJyb3IgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubG9hZFRpbGVTb3VyY2VEYXRhKHRpbGUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2FybiBhbmQgY29udGludWUgb24gZGF0YSBzb3VyY2UgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aWxlLnNvdXJjZV9kYXRhLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMubG9nKCd3YXJuJywgYHRpbGUgbG9hZCBlcnJvcihzKSBmb3IgJHt0aWxlLmtleX06ICR7dGlsZS5zb3VyY2VfZGF0YS5lcnJvcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBUaWxlLmJ1aWxkR2VvbWV0cnkodGlsZSwgc2VsZi5sYXllcnMsIHNlbGYucnVsZXMsIHNlbGYuc3R5bGVzKS50aGVuKGtleXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyB0aWxlOiBUaWxlLnNsaWNlKHRpbGUsIGtleXMpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZS5lcnJvciA9IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBVdGlscy5sb2coJ2Vycm9yJywgYHRpbGUgbG9hZCBlcnJvciBmb3IgJHt0aWxlLmtleX06ICR7dGlsZS5lcnJvcn0gYXQ6ICR7ZXJyb3Iuc3RhY2t9YCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyB0aWxlOiBUaWxlLnNsaWNlKHRpbGUpIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRpbGUgYWxyZWFkeSBsb2FkZWQsIGp1c3QgcmVidWlsZFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgVXRpbHMubG9nKCd0cmFjZScsIGB1c2VkIHdvcmtlciBjYWNoZSBmb3IgdGlsZSAke3RpbGUua2V5fWApO1xuXG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgZ2VvbWV0cnlcbiAgICAgICAgICAgICAgICByZXR1cm4gVGlsZS5idWlsZEdlb21ldHJ5KHRpbGUsIHNlbGYubGF5ZXJzLCBzZWxmLnJ1bGVzLCBzZWxmLnN0eWxlcykudGhlbihrZXlzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGlsZTogVGlsZS5zbGljZSh0aWxlLCBrZXlzKSB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gTG9hZCB0aGlzIHRpbGUncyBkYXRhIHNvdXJjZVxuICAgIGxvYWRUaWxlU291cmNlRGF0YSAodGlsZSkge1xuICAgICAgICByZXR1cm4gc2VsZi5zb3VyY2VzLnRpbGVzW3RpbGUuc291cmNlXS5sb2FkKHRpbGUpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgdGlsZVxuICAgIHJlbW92ZVRpbGUgKGtleSkge1xuICAgICAgICB2YXIgdGlsZSA9IHNlbGYudGlsZXNba2V5XTtcblxuICAgICAgICBpZiAodGlsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBDYW5jZWwgaWYgbG9hZGluZ1xuICAgICAgICAgICAgaWYgKHRpbGUubG9hZGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIFV0aWxzLmxvZygndHJhY2UnLCBgY2FuY2VsIHRpbGUgbG9hZCBmb3IgJHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgdGlsZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFRpbGUuY2FuY2VsKHRpbGUpO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgICAgICAgRmVhdHVyZVNlbGVjdGlvbi5jbGVhclRpbGUoa2V5KTtcbiAgICAgICAgICAgIGRlbGV0ZSBzZWxmLnRpbGVzW2tleV07XG4gICAgICAgICAgICBVdGlscy5sb2coJ3RyYWNlJywgYHJlbW92ZSB0aWxlIGZyb20gY2FjaGUgZm9yICR7a2V5fWApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEdldCBhIGZlYXR1cmUgZnJvbSB0aGUgc2VsZWN0aW9uIG1hcFxuICAgIGdldEZlYXR1cmVTZWxlY3Rpb24gKHsgaWQsIGtleSB9ID0ge30pIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IEZlYXR1cmVTZWxlY3Rpb24ubWFwW2tleV07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGZlYXR1cmU6IChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmZlYXR1cmUpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIFJlc2V0cyB0aGUgZmVhdHVyZSBzZWxlY3Rpb24gc3RhdGVcbiAgICByZXNldEZlYXR1cmVTZWxlY3Rpb24gKCkge1xuICAgICAgICBGZWF0dXJlU2VsZWN0aW9uLnJlc2V0KCk7XG4gICAgfSxcblxuICAgIC8vIFNlbGVjdGlvbiBtYXAgc2l6ZSBmb3IgdGhpcyB3b3JrZXJcbiAgICBnZXRGZWF0dXJlU2VsZWN0aW9uTWFwU2l6ZSAoKSB7XG4gICAgICAgIHJldHVybiBGZWF0dXJlU2VsZWN0aW9uLmdldE1hcFNpemUoKTtcbiAgICB9LFxuXG4gICAgLy8gVGV4dHVyZSBpbmZvIG5lZWRzIHRvIGJlIHN5bmNlZCBmcm9tIG1haW4gdGhyZWFkXG4gICAgc3luY1RleHR1cmVzICh0ZXhfY29uZmlnKSB7XG4gICAgICAgIC8vIFdlJ3JlIG9ubHkgc3luY2luZyB0aGUgdGV4dHVyZXMgdGhhdCBoYXZlIHNwcml0ZXMgZGVmaW5lZCwgc2luY2UgdGhlc2UgYXJlIChjdXJyZW50bHkpIHRoZSBvbmx5IG9uZXMgd2VcbiAgICAgICAgLy8gbmVlZCBpbmZvIGFib3V0IGZvciBnZW9tZXRyeSBjb25zdHJ1Y3Rpb24gKGUuZy4gd2lkdGgvaGVpZ2h0LCB3aGljaCB3ZSBvbmx5IGtub3cgYWZ0ZXIgdGhlIHRleHR1cmUgbG9hZHMpXG4gICAgICAgIGxldCB0ZXh0dXJlcyA9IFtdO1xuICAgICAgICBpZiAodGV4X2NvbmZpZykge1xuICAgICAgICAgICAgZm9yIChsZXQgW3RleG5hbWUsIHRleHR1cmVdIG9mIFV0aWxzLmVudHJpZXModGV4X2NvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dHVyZS5zcHJpdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVzLnB1c2godGV4bmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgVXRpbHMubG9nKCd0cmFjZScsICdzeW5jIHRleHR1cmVzIHRvIHdvcmtlcjonLCB0ZXh0dXJlcyk7XG4gICAgICAgIGlmICh0ZXh0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gVGV4dHVyZS5zeW5jVGV4dHVyZXNUb1dvcmtlcih0ZXh0dXJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0sXG5cbiAgICAvLyBTeW5jIGRldmljZSBwaXhlbCByYXRpbyBmcm9tIG1haW4gdGhyZWFkXG4gICAgdXBkYXRlRGV2aWNlUGl4ZWxSYXRpbyAoZGV2aWNlX3BpeGVsX3JhdGlvKSB7XG4gICAgICAgIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbyA9IGRldmljZV9waXhlbF9yYXRpbztcbiAgICB9LFxuXG4gICAgLy8gUHJvZmlsaW5nIGhlbHBlcnNcbiAgICBwcm9maWxlIChuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUucHJvZmlsZShgd29ya2VyICR7c2VsZi5fd29ya2VyX2lkfTogJHtuYW1lfWApO1xuICAgIH0sXG5cbiAgICBwcm9maWxlRW5kIChuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUucHJvZmlsZUVuZChgd29ya2VyICR7c2VsZi5fd29ya2VyX2lkfTogJHtuYW1lfWApO1xuICAgIH1cblxufSk7XG5cbldvcmtlckJyb2tlci5hZGRUYXJnZXQoJ3NlbGYnLCBzZWxmKTtcblxufVxuIiwiaW1wb3J0IFRleHR1cmUgZnJvbSAnLi9nbC90ZXh0dXJlJztcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi91dGlscy93b3JrZXJfYnJva2VyJztcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZlYXR1cmVTZWxlY3Rpb24ge1xuXG4gICAgY29uc3RydWN0b3IoZ2wsIHdvcmtlcnMpIHtcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB0aGlzLndvcmtlcnMgPSB3b3JrZXJzOyAvLyBwb29sIG9mIHdvcmtlcnMgdG8gcmVxdWVzdCBmZWF0dXJlIGxvb2stdXBzIGZyb20sIGtleWVkIGJ5IGlkXG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cblxuICAgIGluaXQoKSB7XG4gICAgICAgIC8vIFNlbGVjdGlvbiBzdGF0ZSB0cmFja2luZ1xuICAgICAgICB0aGlzLnJlcXVlc3RzID0ge307IC8vIHBlbmRpbmcgc2VsZWN0aW9uIHJlcXVlc3RzXG4gICAgICAgIHRoaXMuZmVhdHVyZSA9IG51bGw7IC8vIGN1cnJlbnRseSBzZWxlY3RlZCBmZWF0dXJlXG4gICAgICAgIHRoaXMucmVhZF9kZWxheSA9IDU7IC8vIGRlbGF5IHRpbWUgZnJvbSBzZWxlY3Rpb24gcmVuZGVyIHRvIGZyYW1lYnVmZmVyIHNhbXBsZSwgdG8gYXZvaWQgQ1BVL0dQVSBzeW5jIGxvY2tcbiAgICAgICAgdGhpcy5yZWFkX2RlbGF5X3RpbWVyID0gbnVsbDsgLy8gY3VycmVudCB0aW1lciAoc2V0VGltZW91dCkgZm9yIGRlbGF5ZWQgc2VsZWN0aW9uIHJlYWRzXG5cbiAgICAgICAgdGhpcy5waXhlbCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICB0aGlzLnBpeGVsMzIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMucGl4ZWwuYnVmZmVyKTtcblxuICAgICAgICAvLyBGcmFtZSBidWZmZXIgZm9yIHNlbGVjdGlvblxuICAgICAgICAvLyBUT0RPOiBpbml0aWF0ZSBsYXppbHkgaW4gY2FzZSB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueSBzZWxlY3Rpb25cbiAgICAgICAgdGhpcy5mYm8gPSB0aGlzLmdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZmJvKTtcbiAgICAgICAgdGhpcy5mYm9fc2l6ZSA9IHsgd2lkdGg6IDI1NiwgaGVpZ2h0OiAyNTYgfTsgLy8gVE9ETzogbWFrZSBjb25maWd1cmFibGUgLyBhZGFwdGl2ZSBiYXNlZCBvbiBjYW52YXMgc2l6ZVxuICAgICAgICB0aGlzLmZib19zaXplLmFzcGVjdCA9IHRoaXMuZmJvX3NpemUud2lkdGggLyB0aGlzLmZib19zaXplLmhlaWdodDtcblxuICAgICAgICAvLyBUZXh0dXJlIGZvciB0aGUgRkJPIGNvbG9yIGF0dGFjaG1lbnRcbiAgICAgICAgdmFyIGZib190ZXh0dXJlID0gbmV3IFRleHR1cmUodGhpcy5nbCwgJ3NlbGVjdGlvbl9mYm8nKTtcbiAgICAgICAgZmJvX3RleHR1cmUuc2V0RGF0YSh0aGlzLmZib19zaXplLndpZHRoLCB0aGlzLmZib19zaXplLmhlaWdodCwgbnVsbCwgeyBmaWx0ZXJpbmc6ICduZWFyZXN0JyB9KTtcbiAgICAgICAgdGhpcy5nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0aGlzLmdsLkZSQU1FQlVGRkVSLCB0aGlzLmdsLkNPTE9SX0FUVEFDSE1FTlQwLCB0aGlzLmdsLlRFWFRVUkVfMkQsIGZib190ZXh0dXJlLnRleHR1cmUsIDApO1xuXG4gICAgICAgIC8vIFJlbmRlcmJ1ZmZlciBmb3IgdGhlIEZCTyBkZXB0aCBhdHRhY2htZW50XG4gICAgICAgIHZhciBmYm9fZGVwdGhfcmIgPSB0aGlzLmdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICAgICAgICB0aGlzLmdsLmJpbmRSZW5kZXJidWZmZXIodGhpcy5nbC5SRU5ERVJCVUZGRVIsIGZib19kZXB0aF9yYik7XG4gICAgICAgIHRoaXMuZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSh0aGlzLmdsLlJFTkRFUkJVRkZFUiwgdGhpcy5nbC5ERVBUSF9DT01QT05FTlQxNiwgdGhpcy5mYm9fc2l6ZS53aWR0aCwgdGhpcy5mYm9fc2l6ZS5oZWlnaHQpO1xuICAgICAgICB0aGlzLmdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZ2wuREVQVEhfQVRUQUNITUVOVCwgdGhpcy5nbC5SRU5ERVJCVUZGRVIsIGZib19kZXB0aF9yYik7XG5cbiAgICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2wgJiYgdGhpcy5mYm8pIHtcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mYm8pO1xuICAgICAgICAgICAgdGhpcy5mYm8gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBmcmVlIHRleHR1cmU/XG4gICAgfVxuXG4gICAgYmluZCgpIHtcbiAgICAgICAgLy8gU3dpdGNoIHRvIEZCT1xuICAgICAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCB0aGlzLmZibyk7XG4gICAgICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5mYm9fc2l6ZS53aWR0aCwgdGhpcy5mYm9fc2l6ZS5oZWlnaHQpO1xuICAgIH1cblxuICAgIC8vIFJlcXVlc3QgZmVhdHVyZSBzZWxlY3Rpb25cbiAgICAvLyBSdW5zIGFzeW5jaHJvbm91c2x5LCBzY2hlZHVsZXMgc2VsZWN0aW9uIGJ1ZmZlciB0byBiZSB1cGRhdGVkXG4gICAgZ2V0RmVhdHVyZUF0KHBvaW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBRdWV1ZSByZXF1ZXN0cyBmb3IgZmVhdHVyZSBzZWxlY3Rpb24sIGFuZCB0aGV5IHdpbGwgYmUgcGlja2VkIHVwIGJ5IHRoZSByZW5kZXIgbG9vcFxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25fcmVxdWVzdF9pZCA9ICh0aGlzLnNlbGVjdGlvbl9yZXF1ZXN0X2lkICsgMSkgfHwgMDtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdHNbdGhpcy5zZWxlY3Rpb25fcmVxdWVzdF9pZF0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3BvaW50JyxcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5zZWxlY3Rpb25fcmVxdWVzdF9pZCxcbiAgICAgICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQW55IHBlbmRpbmcgc2VsZWN0aW9uIHJlcXVlc3RzXG4gICAgcGVuZGluZ1JlcXVlc3RzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0cztcbiAgICB9XG5cbiAgICBjbGVhclBlbmRpbmdSZXF1ZXN0cygpIHtcbiAgICAgICAgZm9yICh2YXIgciBpbiB0aGlzLnJlcXVlc3RzKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMucmVxdWVzdHNbcl07XG5cbiAgICAgICAgICAgIC8vIFRoaXMgcmVxdWVzdCB3YXMgYWxyZWFkeSBzZW50IHRvIHRoZSB3b3JrZXIsIHdlJ3JlIGp1c3QgYXdhaXRpbmcgaXRzIHJlcGx5XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zZW50KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlamVjdCByZXF1ZXN0IHNpbmNlIGl0IHdpbGwgbmV2ZXIgYmUgZnVsZmlsbGVkXG4gICAgICAgICAgICAvLyBUT0RPOiBwYXNzIGEgcmVhc29uIGZvciByZWplY3Rpb24/XG4gICAgICAgICAgICByZXF1ZXN0LnJlamVjdCh7IHJlcXVlc3QgfSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5yZXF1ZXN0c1tyXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlYWQgcGVuZGluZyByZXN1bHRzIGZyb20gdGhlIHNlbGVjdGlvbiBidWZmZXIuIENhbGxlZCBhZnRlciByZW5kZXJpbmcgdG8gc2VsZWN0aW9uIGJ1ZmZlci5cbiAgICByZWFkKCkge1xuICAgICAgICAvLyBEZWxheSByZWFkaW5nIHRoZSBwaXhlbCByZXN1bHQgZnJvbSB0aGUgc2VsZWN0aW9uIGJ1ZmZlciB0byBhdm9pZCBDUFUvR1BVIHN5bmMgbG9jay5cbiAgICAgICAgLy8gQ2FsbGluZyByZWFkUGl4ZWxzIHN5bmNocm9ub3VzbHkgY2F1c2VkIGEgbWFzc2l2ZSBwZXJmb3JtYW5jZSBoaXQsIHByZXN1bWFibHkgc2luY2UgaXRcbiAgICAgICAgLy8gZm9yY2VkIHRoaXMgZnVuY3Rpb24gdG8gd2FpdCBmb3IgdGhlIEdQVSB0byBmaW5pc2ggcmVuZGVyaW5nIGFuZCByZXRyaWV2ZSB0aGUgdGV4dHVyZSBjb250ZW50cy5cbiAgICAgICAgaWYgKHRoaXMucmVhZF9kZWxheV90aW1lciAhPSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWFkX2RlbGF5X3RpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWRfZGVsYXlfdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mYm8pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciByIGluIHRoaXMucmVxdWVzdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMucmVxdWVzdHNbcl07XG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIHJlcXVlc3Qgd2FzIGFscmVhZHkgc2VudCB0byB0aGUgd29ya2VyLCB3ZSdyZSBqdXN0IGF3YWl0aW5nIGl0cyByZXBseVxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBvdGhlciBzZWxlY3Rpb24gdHlwZXMsIHN1Y2ggYXMgZmVhdHVyZXMgd2l0aGluIGEgYm94XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QudHlwZSAhPT0gJ3BvaW50Jykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBzZWxlY3Rpb24gbWFwIGFnYWluc3QgRkJPXG4gICAgICAgICAgICAgICAgZ2wucmVhZFBpeGVscyhcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihyZXF1ZXN0LnBvaW50LnggKiB0aGlzLmZib19zaXplLndpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcigoMSAtIHJlcXVlc3QucG9pbnQueSkgKiB0aGlzLmZib19zaXplLmhlaWdodCksXG4gICAgICAgICAgICAgICAgICAgIDEsIDEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMucGl4ZWwpO1xuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlX2tleSA9ICh0aGlzLnBpeGVsWzBdICsgKHRoaXMucGl4ZWxbMV0gPDwgOCkgKyAodGhpcy5waXhlbFsyXSA8PCAxNikgKyAodGhpcy5waXhlbFszXSA8PCAyNCkpID4+PiAwO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgZmVhdHVyZSBmb3VuZCwgYXNrIGFwcHJvcHJpYXRlIHdlYiB3b3JrZXIgdG8gbG9va3VwIGZlYXR1cmVcbiAgICAgICAgICAgICAgICB2YXIgd29ya2VyX2lkID0gdGhpcy5waXhlbFszXTtcbiAgICAgICAgICAgICAgICBpZiAod29ya2VyX2lkICE9PSAyNTUpIHsgLy8gMjU1IGluZGljYXRlcyBhbiBlbXB0eSBzZWxlY3Rpb24gYnVmZmVyIHBpeGVsXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLndvcmtlcnNbd29ya2VyX2lkXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53b3JrZXJzW3dvcmtlcl9pZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGYuZ2V0RmVhdHVyZVNlbGVjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpZDogcmVxdWVzdC5pZCwga2V5OiBmZWF0dXJlX2tleSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4obWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2hSZWFkKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm8gZmVhdHVyZSBmb3VuZCwgYnV0IHN0aWxsIG5lZWQgdG8gcmVzb2x2ZSBwcm9taXNlXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoUmVhZCh7IGlkOiByZXF1ZXN0LmlkLCBmZWF0dXJlOiBudWxsIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlcXVlc3Quc2VudCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cbiAgICAgICAgfSwgdGhpcy5yZWFkX2RlbGF5KTtcbiAgICB9XG5cbiAgICAvLyBDYWxsZWQgb24gbWFpbiB0aHJlYWQgd2hlbiBhIHdlYiB3b3JrZXIgZmluZHMgYSBmZWF0dXJlIGluIHRoZSBzZWxlY3Rpb24gYnVmZmVyXG4gICAgZmluaXNoUmVhZCAobWVzc2FnZSkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMucmVxdWVzdHNbbWVzc2FnZS5pZF07XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgbG9nLmVycm9yKFwiRmVhdHVyZVNlbGVjdGlvbi5maW5pc2hSZWFkKCk6IGNvdWxkIG5vdCBmaW5kIG1lc3NhZ2VcIiwgbWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47IC8vIHJlcXVlc3Qgd2FzIGNsZWFyZWQgYmVmb3JlIGl0IHJldHVybmVkXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmVhdHVyZSA9IG1lc3NhZ2UuZmVhdHVyZTtcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKChmZWF0dXJlICE9IG51bGwgJiYgdGhpcy5mZWF0dXJlID09IG51bGwpIHx8XG4gICAgICAgICAgICAoZmVhdHVyZSA9PSBudWxsICYmIHRoaXMuZmVhdHVyZSAhPSBudWxsKSB8fFxuICAgICAgICAgICAgKGZlYXR1cmUgIT0gbnVsbCAmJiB0aGlzLmZlYXR1cmUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGZlYXR1cmUpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLmZlYXR1cmUpKSkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZlYXR1cmUgPSBmZWF0dXJlOyAvLyBzdG9yZSB0aGUgbW9zdCByZWNlbnRseSBzZWxlY3RlZCBmZWF0dXJlXG5cbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0LnJlc29sdmUoeyBmZWF0dXJlLCBjaGFuZ2VkLCByZXF1ZXN0IH0pO1xuICAgICAgICBkZWxldGUgdGhpcy5yZXF1ZXN0c1ttZXNzYWdlLmlkXTsgLy8gZG9uZSBwcm9jZXNzaW5nIHRoaXMgcmVxdWVzdFxuICAgIH1cblxuXG4gICAgLy8gU2VsZWN0aW9uIG1hcCBnZW5lcmF0aW9uXG4gICAgLy8gRWFjaCB3b3JrZXIgd2lsbCBjcmVhdGUgaXRzIG93biBpbmRlcGVuZGVudCwgJ2xvY2FsJyBzZWxlY3Rpb24gbWFwXG5cbiAgICAvLyBDcmVhdGUgYSB1bmlxdWUgMzItYml0IGNvbG9yIHRvIGlkZW50aWZ5IGEgZmVhdHVyZVxuICAgIC8vIFdvcmtlcnMgaW5kZXBlbmRlbnRseSBjcmVhdGUvbW9kaWZ5IHNlbGVjdGlvbiBjb2xvcnMgaW4gdGhlaXIgb3duIHRocmVhZHMsIGJ1dCB3ZSBhbHNvXG4gICAgLy8gbmVlZCB0aGUgbWFpbiB0aHJlYWQgdG8ga25vdyB3aGVyZSBlYWNoIGZlYXR1cmUgY29sb3Igb3JpZ2luYXRlZC4gVG8gYWNjb21wbGlzaCB0aGlzLFxuICAgIC8vIHdlIHBhcnRpdGlvbiB0aGUgbWFwIGJ5IHNldHRpbmcgdGhlIDR0aCBjb21wb25lbnQgKGFscGhhIGNoYW5uZWwpIHRvIHRoZSB3b3JrZXIncyBpZC5cbiAgICBzdGF0aWMgbWFrZUVudHJ5KHRpbGUpIHtcbiAgICAgICAgLy8gMzItYml0IGNvbG9yIGtleVxuICAgICAgICB0aGlzLm1hcF9lbnRyeSsrO1xuICAgICAgICB2YXIgaXIgPSB0aGlzLm1hcF9lbnRyeSAmIDI1NTtcbiAgICAgICAgdmFyIGlnID0gKHRoaXMubWFwX2VudHJ5ID4+IDgpICYgMjU1O1xuICAgICAgICB2YXIgaWIgPSAodGhpcy5tYXBfZW50cnkgPj4gMTYpICYgMjU1O1xuICAgICAgICB2YXIgaWEgPSB0aGlzLm1hcF9wcmVmaXg7XG4gICAgICAgIHZhciByID0gaXIgLyAyNTU7XG4gICAgICAgIHZhciBnID0gaWcgLyAyNTU7XG4gICAgICAgIHZhciBiID0gaWIgLyAyNTU7XG4gICAgICAgIHZhciBhID0gaWEgLyAyNTU7XG4gICAgICAgIHZhciBrZXkgPSAoaXIgKyAoaWcgPDwgOCkgKyAoaWIgPDwgMTYpICsgKGlhIDw8IDI0KSkgPj4+IDA7IC8vIG5lZWQgdW5zaWduZWQgcmlnaHQgc2hpZnQgdG8gY29udmVydCB0byBwb3NpdGl2ZSAjXG5cbiAgICAgICAgdGhpcy5tYXBba2V5XSA9IHtcbiAgICAgICAgICAgIGNvbG9yOiBbciwgZywgYiwgYV0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWFwX3NpemUrKztcblxuICAgICAgICB0aGlzLnRpbGVzW3RpbGUua2V5XSA9IHRoaXMudGlsZXNbdGlsZS5rZXldIHx8IFtdO1xuICAgICAgICB0aGlzLnRpbGVzW3RpbGUua2V5XS5wdXNoKGtleSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubWFwW2tleV07XG4gICAgfVxuXG4gICAgc3RhdGljIG1ha2VDb2xvcihmZWF0dXJlLCB0aWxlKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRoaXMubWFrZUVudHJ5KHRpbGUpO1xuICAgICAgICBzZWxlY3Rvci5mZWF0dXJlID0ge1xuICAgICAgICAgICAgaWQ6IGZlYXR1cmUuaWQsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBmZWF0dXJlLnByb3BlcnRpZXMsXG4gICAgICAgICAgICB0aWxlOiB0aWxlLmtleVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxlY3Rvci5jb2xvcjtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMudGlsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5tYXAgPSB7fTtcbiAgICAgICAgdGhpcy5tYXBfc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMubWFwX2VudHJ5ID0gMDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xlYXJUaWxlKGtleSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnRpbGVzW2tleV0pKSB7XG4gICAgICAgICAgICB0aGlzLnRpbGVzW2tleV0uZm9yRWFjaChrID0+IGRlbGV0ZSB0aGlzLm1hcFtrXSk7XG4gICAgICAgICAgICB0aGlzLm1hcF9zaXplIC09IHRoaXMudGlsZXNba2V5XS5sZW5ndGg7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy50aWxlc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldE1hcFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcF9zaXplO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZXRQcmVmaXgocHJlZml4KSB7XG4gICAgICAgIHRoaXMubWFwX3ByZWZpeCA9IHByZWZpeDtcbiAgICB9XG5cbn1cblxuLy8gU3RhdGljIHByb3BlcnRpZXNcbkZlYXR1cmVTZWxlY3Rpb24ubWFwID0ge307ICAgLy8gdGhpcyB3aWxsIGJlIHVuaXF1ZSBwZXIgbW9kdWxlIGluc3RhbmNlIChzbyB1bmlxdWUgcGVyIHdvcmtlcilcbkZlYXR1cmVTZWxlY3Rpb24udGlsZXMgPSB7fTsgLy8gc2VsZWN0aW9uIGtleXMsIGJ5IHRpbGVcbkZlYXR1cmVTZWxlY3Rpb24ubWFwX3NpemUgPSAwO1xuRmVhdHVyZVNlbGVjdGlvbi5tYXBfZW50cnkgPSAwO1xuRmVhdHVyZVNlbGVjdGlvbi5tYXBfcHJlZml4ID0gMDsgLy8gc2V0IGJ5IHdvcmtlciB0byB3b3JrZXIgaWQgI1xuRmVhdHVyZVNlbGVjdGlvbi5kZWZhdWx0Q29sb3IgPSBbMCwgMCwgMCwgMV07XG4iLCIvKmpzaGludCB3b3JrZXI6IHRydWUgKi9cbmltcG9ydCBHZW8gZnJvbSAnLi4vZ2VvJztcbmltcG9ydCB7TWV0aG9kTm90SW1wbGVtZW50ZWR9IGZyb20gJy4uL3V0aWxzL2Vycm9ycyc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhU291cmNlIHtcblxuICAgIGNvbnN0cnVjdG9yIChzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5pZCA9IHNvdXJjZS5pZDtcbiAgICAgICAgdGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG4gICAgICAgIHRoaXMudXJsID0gc291cmNlLnVybDtcbiAgICAgICAgdGhpcy5wYWRfc2NhbGUgPSBzb3VyY2UucGFkX3NjYWxlIHx8IDAuMDAwNTsgLy8gc2NhbGUgdGlsZSB1cCBieSBzbWFsbCBmYWN0b3IgdG8gY292ZXIgc2VhbXNcbiAgICAgICAgdGhpcy5lbmZvcmNlX3dpbmRpbmcgPSBzb3VyY2UuZW5mb3JjZV93aW5kaW5nIHx8IGZhbHNlOyAvLyB3aGV0aGVyIHRvIGVuZm9yY2Ugd2luZGluZyBvcmRlclxuXG4gICAgICAgIC8vIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBzb3VyY2UgZGF0YVxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHNvdXJjZS50cmFuc2Zvcm07XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmJpbmQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcHRpb25hbCBhZGRpdGlvbmFsIGRhdGEgdG8gcGFzcyB0byB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuZXh0cmFfZGF0YSA9IHNvdXJjZS5leHRyYV9kYXRhO1xuXG4gICAgICAgIC8vIE9wdGlvbmFsIGFkZGl0aW9uYWwgc2NyaXB0cyBtYWRlIGF2YWlsYWJsZSB0byB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uXG4gICAgICAgIGlmICh0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJyAmJiBzb3VyY2Uuc2NyaXB0cykge1xuICAgICAgICAgICAgc291cmNlLnNjcmlwdHMuZm9yRWFjaChmdW5jdGlvbihzLCBzaSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydFNjcmlwdHMocyk7XG4gICAgICAgICAgICAgICAgICAgIFV0aWxzLmxvZygnaW5mbycsICdEYXRhU291cmNlOiBsb2FkZWQgbGlicmFyeTogJyArIHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBVdGlscy5sb2coJ2Vycm9yJywgJ0RhdGFTb3VyY2U6IGZhaWxlZCB0byBsb2FkIGxpYnJhcnk6ICcgKyBzKTtcbiAgICAgICAgICAgICAgICAgICAgVXRpbHMubG9nKCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3Zlcnpvb20gd2lsbCBhcHBseSBmb3Igem9vbXMgaGlnaGVyIHRoYW4gdGhpc1xuICAgICAgICB0aGlzLm1heF96b29tID0gTWF0aC5taW4oc291cmNlLm1heF96b29tIHx8IEdlby5tYXhfem9vbSwgR2VvLm1heF96b29tKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSB0aWxlIHNvdXJjZSBieSB0eXBlLCBmYWN0b3J5LXN0eWxlXG4gICAgc3RhdGljIGNyZWF0ZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChEYXRhU291cmNlLnR5cGVzW3NvdXJjZS50eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhU291cmNlLnR5cGVzW3NvdXJjZS50eXBlXShzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWVyY2F0b3IgcHJvamVjdGlvblxuICAgIHN0YXRpYyBwcm9qZWN0RGF0YSAoc291cmNlKSB7XG4gICAgICAgIHZhciB0aW1lciA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICBmb3IgKHZhciB0IGluIHNvdXJjZS5sYXllcnMpIHtcbiAgICAgICAgICAgIHZhciBudW1fZmVhdHVyZXMgPSBzb3VyY2UubGF5ZXJzW3RdLmZlYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGY9MDsgZiA8IG51bV9mZWF0dXJlczsgZisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBzb3VyY2UubGF5ZXJzW3RdLmZlYXR1cmVzW2ZdO1xuICAgICAgICAgICAgICAgIEdlby50cmFuc2Zvcm1HZW9tZXRyeShmZWF0dXJlLmdlb21ldHJ5LCBjb29yZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBbeCwgeV0gPSBHZW8ubGF0TG5nVG9NZXRlcnMoY29vcmQpO1xuICAgICAgICAgICAgICAgICAgICBjb29yZFswXSA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkWzFdID0geTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb3VyY2UuZGVidWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc291cmNlLmRlYnVnLnByb2plY3Rpb24gPSArbmV3IERhdGUoKSAtIHRpbWVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgIFJlLXNjYWxlIGdlb21ldHJpZXMgd2l0aGluIGVhY2ggc291cmNlIHRvIGludGVybmFsIHRpbGUgdW5pdHNcbiAgICAqL1xuICAgIHN0YXRpYyBzY2FsZURhdGEgKHNvdXJjZSwge2Nvb3Jkczoge3p9LCBtaW4sIG1heH0pIHtcbiAgICAgICAgZm9yICh2YXIgdCBpbiBzb3VyY2UubGF5ZXJzKSB7XG4gICAgICAgICAgICB2YXIgbnVtX2ZlYXR1cmVzID0gc291cmNlLmxheWVyc1t0XS5mZWF0dXJlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBmPTA7IGYgPCBudW1fZmVhdHVyZXM7IGYrKykge1xuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gc291cmNlLmxheWVyc1t0XS5mZWF0dXJlc1tmXTtcbiAgICAgICAgICAgICAgICBHZW8udHJhbnNmb3JtR2VvbWV0cnkoZmVhdHVyZS5nZW9tZXRyeSwgY29vcmQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb29yZFswXSA9IChjb29yZFswXSAtIG1pbi54KSAqIEdlby51bml0c19wZXJfbWV0ZXJbel07XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkWzFdID0gKGNvb3JkWzFdIC0gbWluLnkpICogR2VvLnVuaXRzX3Blcl9tZXRlclt6XSAqIC0xOyAvLyBmbGlwIGNvb3JkcyBwb3NpdGl2ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9hZChkZXN0KSB7XG4gICAgICAgIGRlc3Quc291cmNlX2RhdGEgPSB7fTtcbiAgICAgICAgZGVzdC5zb3VyY2VfZGF0YS5sYXllcnMgPSB7fTtcbiAgICAgICAgZGVzdC5wYWRfc2NhbGUgPSB0aGlzLnBhZF9zY2FsZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZChkZXN0KS50aGVuKChkZXN0KSA9PiB7XG4gICAgICAgICAgICAvLyBQb3N0LXByb2Nlc3NpbmdcbiAgICAgICAgICAgIGZvciAobGV0IGxheWVyIGluIGRlc3Quc291cmNlX2RhdGEubGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBkZXN0LnNvdXJjZV9kYXRhLmxheWVyc1tsYXllcl07XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5mZWF0dXJlcykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBHZW8udHJhbnNmb3JtR2VvbWV0cnkoZmVhdHVyZS5nZW9tZXRyeSwgY29vcmQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsaXAgWSBjb29yZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZFsxXSA9IC1jb29yZFsxXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNsaWdodGx5IHNjYWxlIHVwIHRpbGUgdG8gY292ZXIgc2VhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYWRfc2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRbMF0gPSBNYXRoLnJvdW5kKGNvb3JkWzBdICogKDEgKyB0aGlzLnBhZF9zY2FsZSkgLSAoR2VvLnRpbGVfc2NhbGUgKiB0aGlzLnBhZF9zY2FsZS8yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkWzFdID0gTWF0aC5yb3VuZChjb29yZFsxXSAqICgxICsgdGhpcy5wYWRfc2NhbGUpIC0gKEdlby50aWxlX3NjYWxlICogdGhpcy5wYWRfc2NhbGUvMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb25hbGx5IGVuZm9yY2Ugd2luZGluZyBvcmRlciBzaW5jZSBub3QgYWxsIGRhdGEgc291cmNlcyBndWFyYW50ZWUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuZm9yY2Vfd2luZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdlby5lbmZvcmNlV2luZGluZyhmZWF0dXJlLmdlb21ldHJ5LCAnQ0NXJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU3ViLWNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcbiAgICBfbG9hZChkZXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBNZXRob2ROb3RJbXBsZW1lbnRlZCgnX2xvYWQnKTtcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBhIG5ldyBkYXRhIHNvdXJjZSB0eXBlLCB1bmRlciBhIHR5cGUgbmFtZVxuICAgIHN0YXRpYyByZWdpc3Rlcih0eXBlX2NsYXNzLCB0eXBlX25hbWUpIHtcbiAgICAgICAgaWYgKCF0eXBlX2NsYXNzIHx8ICF0eXBlX25hbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIERhdGFTb3VyY2UudHlwZXNbdHlwZV9uYW1lXSA9IHR5cGVfY2xhc3M7XG4gICAgfVxuXG59XG5cbkRhdGFTb3VyY2UudHlwZXMgPSB7fTsgLy8gc2V0IG9mIHN1cHBvcnRlZCBkYXRhIHNvdXJjZSBjbGFzc2VzLCByZWZlcmVuY2VkIGJ5IHR5cGUgbmFtZVxuXG5cbi8qKiogR2VuZXJpYyBuZXR3b3JrIGxvYWRpbmcgc291cmNlIC0gYWJzdHJhY3QgY2xhc3MgKioqL1xuXG5leHBvcnQgY2xhc3MgTmV0d29ya1NvdXJjZSBleHRlbmRzIERhdGFTb3VyY2Uge1xuXG4gICAgY29uc3RydWN0b3IgKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihzb3VyY2UpO1xuICAgICAgICB0aGlzLnJlc3BvbnNlX3R5cGUgPSBcIlwiOyAvLyB1c2UgdG8gc2V0IGV4cGxpY2l0IFhIUiB0eXBlXG4gICAgfVxuXG4gICAgX2xvYWQgKGRlc3QpIHtcbiAgICAgICAgLy8gc3VwZXIubG9hZChkZXN0KTtcblxuICAgICAgICBsZXQgdXJsID0gdGhpcy5mb3JtYXRVcmwoZGVzdCk7XG5cbiAgICAgICAgbGV0IHNvdXJjZV9kYXRhID0gZGVzdC5zb3VyY2VfZGF0YTtcbiAgICAgICAgc291cmNlX2RhdGEudXJsID0gdXJsO1xuICAgICAgICBkZXN0LmRlYnVnID0gZGVzdC5kZWJ1ZyB8fCB7fTtcbiAgICAgICAgZGVzdC5kZWJ1Zy5uZXR3b3JrID0gK25ldyBEYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHNvdXJjZV9kYXRhLmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIC8vIEZvciB0ZXN0aW5nIG5ldHdvcmsgZXJyb3JzXG4gICAgICAgICAgICAvLyB2YXIgcHJvbWlzZSA9IFV0aWxzLmlvKHVybCwgNjAgKiAxMDAsIHRoaXMucmVzcG9uc2VfdHlwZSk7XG4gICAgICAgICAgICAvLyBpZiAoTWF0aC5yYW5kb20oKSA8IC43KSB7XG4gICAgICAgICAgICAvLyAgICAgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KEVycm9yKCdmYWtlIGRhdGEgc291cmNlIGVycm9yJykpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gcHJvbWlzZS50aGVuKChib2R5KSA9PiB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IFV0aWxzLmlvKHVybCwgNjAgKiAxMDAwLCB0aGlzLnJlc3BvbnNlX3R5cGUpO1xuICAgICAgICAgICAgc291cmNlX2RhdGEucmVxdWVzdCA9IHByb21pc2UucmVxdWVzdDtcblxuICAgICAgICAgICAgcHJvbWlzZS50aGVuKChib2R5KSA9PiB7XG4gICAgICAgICAgICAgICAgZGVzdC5kZWJ1Zy5yZXNwb25zZV9zaXplID0gYm9keS5sZW5ndGggfHwgYm9keS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGRlc3QuZGVidWcubmV0d29yayA9ICtuZXcgRGF0ZSgpIC0gZGVzdC5kZWJ1Zy5uZXR3b3JrO1xuICAgICAgICAgICAgICAgIGRlc3QuZGVidWcucGFyc2luZyA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VTb3VyY2VEYXRhKGRlc3QsIHNvdXJjZV9kYXRhLCBib2R5KTtcbiAgICAgICAgICAgICAgICBkZXN0LmRlYnVnLnBhcnNpbmcgPSArbmV3IERhdGUoKSAtIGRlc3QuZGVidWcucGFyc2luZztcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRlc3QpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgc291cmNlX2RhdGEuZXJyb3IgPSBlcnJvci50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGVzdCk7IC8vIHJlc29sdmUgcmVxdWVzdCBidXQgcGFzcyBhbG9uZyBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFN1Yi1jbGFzc2VzIG11c3QgaW1wbGVtZW50OlxuXG4gICAgZm9ybWF0VXJsIChkZXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBNZXRob2ROb3RJbXBsZW1lbnRlZCgnZm9ybWF0VXJsJyk7XG4gICAgfVxuXG4gICAgcGFyc2VTb3VyY2VEYXRhIChkZXN0LCBzb3VyY2UsIHJlcG9uc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1ldGhvZE5vdEltcGxlbWVudGVkKCdwYXJzZVNvdXJjZURhdGEnKTtcbiAgICB9XG59XG5cblxuLyoqKiBHZW5lcmljIG5ldHdvcmsgdGlsZSBsb2FkaW5nIC0gYWJzdHJhY3QgY2xhc3MgKioqL1xuXG5leHBvcnQgY2xhc3MgTmV0d29ya1RpbGVTb3VyY2UgZXh0ZW5kcyBOZXR3b3JrU291cmNlIHtcblxuICAgIGNvbnN0cnVjdG9yIChzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoc291cmNlKTtcblxuICAgICAgICB0aGlzLnRpbGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cmxfaG9zdHMgPSBudWxsO1xuICAgICAgICB2YXIgaG9zdF9tYXRjaCA9IHRoaXMudXJsLm1hdGNoKC97czpcXFsoW159K10rKVxcXX0vKTtcbiAgICAgICAgaWYgKGhvc3RfbWF0Y2ggIT0gbnVsbCAmJiBob3N0X21hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMudXJsX2hvc3RzID0gaG9zdF9tYXRjaFsxXS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgdGhpcy5uZXh0X2hvc3QgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9ybWF0VXJsKHRpbGUpIHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IEdlby53cmFwVGlsZSh0aWxlLmNvb3JkcywgeyB4OiB0cnVlIH0pO1xuICAgICAgICB2YXIgdXJsID0gdGhpcy51cmwucmVwbGFjZSgne3h9JywgY29vcmRzLngpLnJlcGxhY2UoJ3t5fScsIGNvb3Jkcy55KS5yZXBsYWNlKCd7en0nLCBjb29yZHMueik7XG5cbiAgICAgICAgaWYgKHRoaXMudXJsX2hvc3RzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKC97czpcXFsoW159K10rKVxcXX0vLCB0aGlzLnVybF9ob3N0c1t0aGlzLm5leHRfaG9zdF0pO1xuICAgICAgICAgICAgdGhpcy5uZXh0X2hvc3QgPSAodGhpcy5uZXh0X2hvc3QgKyAxKSAlIHRoaXMudXJsX2hvc3RzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cblxuICAgIC8vIENoZWNrcyBmb3IgdGhlIHgveS96IHRpbGUgcGF0dGVybiBpbiBVUkwgdGVtcGxhdGVcbiAgICB1cmxIYXNUaWxlUGF0dGVybih1cmwpIHtcbiAgICAgICAgcmV0dXJuIHVybCAmJlxuICAgICAgICAgICAgdXJsLnNlYXJjaCgne3h9JykgPiAtMSAmJlxuICAgICAgICAgICAgdXJsLnNlYXJjaCgne3l9JykgPiAtMSAmJlxuICAgICAgICAgICAgdXJsLnNlYXJjaCgne3p9JykgPiAtMTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCBEYXRhU291cmNlLCB7TmV0d29ya1NvdXJjZSwgTmV0d29ya1RpbGVTb3VyY2V9IGZyb20gJy4vZGF0YV9zb3VyY2UnO1xuaW1wb3J0IHtNVlRTb3VyY2V9IGZyb20gJy4vbXZ0JztcbmltcG9ydCBHZW8gZnJvbSAnLi4vZ2VvJztcblxuLy8gRm9yIHRpbGluZyBHZW9KU09OIGNsaWVudC1zaWRlXG5pbXBvcnQgZ2VvanNvbnZ0IGZyb20gJ2dlb2pzb24tdnQnO1xuXG5cbi8qKlxuIE1hcHplbi9PU00uVVMtc3R5bGUgR2VvSlNPTiB2ZWN0b3IgdGlsZXNcbiBAY2xhc3MgR2VvSlNPTlRpbGVTb3VyY2VcbiovXG5leHBvcnQgY2xhc3MgR2VvSlNPTlRpbGVTb3VyY2UgZXh0ZW5kcyBOZXR3b3JrVGlsZVNvdXJjZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoc291cmNlKTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgVVJMIHRpbGUgcGF0dGVybiwgaWYgbm90IGZvdW5kLCB0cmVhdCBhcyBzdGFuZGFsb25lIEdlb0pTT04vVG9wb0pTT04gb2JqZWN0XG4gICAgICAgIGlmICghdGhpcy51cmxIYXNUaWxlUGF0dGVybih0aGlzLnVybCkpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGluc3RhbmNlIHR5cGUgZnJvbSBwYXJlbnQgY2xhc3NcbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgR2VvSlNPTlRpbGVTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGluc3RhbmNlIHR5cGVcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdlb0pTT05Tb3VyY2Uoc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFBhc3MgYmFjayB0byBwYXJlbnQgY2xhc3MgdG8gaW5zdGFudGlhdGVcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwYXJzZVNvdXJjZURhdGEgKHRpbGUsIHNvdXJjZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlR2VvSlNPTihkYXRhLCB0aWxlLCBzb3VyY2UpO1xuICAgIH1cblxuICAgIHByZXBhcmVHZW9KU09OIChkYXRhLCB0aWxlLCBzb3VyY2UpIHtcbiAgICAgICAgLy8gQXBwbHkgb3B0aW9uYWwgZGF0YSB0cmFuc2Zvcm1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMudHJhbnNmb3JtKGRhdGEsIHRoaXMuZXh0cmFfZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBzb3VyY2UubGF5ZXJzID0gR2VvSlNPTlNvdXJjZS5wcm90b3R5cGUuZ2V0TGF5ZXJzKGRhdGEpO1xuXG4gICAgICAgIC8vIEEgXCJzeW50aGV0aWNcIiB0aWxlIHRoYXQgYWRqdXN0cyB0aGUgdGlsZSBtaW4gYW5jaG9yIHRvIGFjY291bnQgZm9yIHRpbGUgbG9uZ2l0dWRlIHdyYXBwaW5nXG4gICAgICAgIGxldCBhbmNob3IgPSB7XG4gICAgICAgICAgICBjb29yZHM6IHRpbGUuY29vcmRzLFxuICAgICAgICAgICAgbWluOiBHZW8ubWV0ZXJzRm9yVGlsZShHZW8ud3JhcFRpbGUodGlsZS5jb29yZHMsIHsgeDogdHJ1ZSB9KSlcbiAgICAgICAgfTtcblxuICAgICAgICBEYXRhU291cmNlLnByb2plY3REYXRhKHNvdXJjZSk7IC8vIG1lcmNhdG9yIHByb2plY3Rpb25cbiAgICAgICAgRGF0YVNvdXJjZS5zY2FsZURhdGEoc291cmNlLCBhbmNob3IpOyAvLyByZS1zY2FsZSBmcm9tIG1ldGVycyB0byBsb2NhbCB0aWxlIGNvb3Jkc1xuICAgIH1cblxufVxuXG5cbi8qKlxuIEdlb0pTT04gc3RhbmRhbG9uZSAobm9uLXRpbGVkKSBzb3VyY2VcbiBVc2VzIGdlb2pzb24tdnQgc3BsaXQgaW50byB0aWxlcyBjbGllbnQtc2lkZVxuKi9cblxuZXhwb3J0IGNsYXNzIEdlb0pTT05Tb3VyY2UgZXh0ZW5kcyBOZXR3b3JrU291cmNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihzb3VyY2UpO1xuICAgICAgICB0aGlzLnRpbGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2FkX2RhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnRpbGVfaW5kZXhlcyA9IHt9OyAvLyBnZW9qc29uLXZ0IHRpbGUgaW5kaWNlcywgYnkgbGF5ZXIgbmFtZVxuICAgICAgICB0aGlzLm1heF96b29tID0gTWF0aC5tYXgodGhpcy5tYXhfem9vbSB8fCAwLCAxNSk7IC8vIFRPRE86IG1heCB6b29tIDwgMTUgY2F1c2VzIGFydGlmYWN0cy9uby1kcmF3IGF0IDIwLCBpbnZlc3RpZ2F0ZVxuICAgICAgICB0aGlzLnBhZF9zY2FsZSA9IDA7IC8vIHdlIGRvbid0IHdhbnQgcGFkZGluZyBvbiBhdXRvLXRpbGVkIHNvdXJjZXNcbiAgICAgICAgdGhpcy5lbmZvcmNlX3dpbmRpbmcgPSAoc291cmNlLmVuZm9yY2Vfd2luZGluZyA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlOyAvLyBkZWZhdWx0IG9uLCBjYW4gYmUgZm9yY2VkIG9mZlxuICAgIH1cblxuICAgIF9sb2FkKGRlc3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRfZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkX2RhdGEgPSBzdXBlci5fbG9hZCh7IHNvdXJjZV9kYXRhOiB7IGxheWVyczoge30gfSB9KS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBsYXllcnMgPSBkYXRhLnNvdXJjZV9kYXRhLmxheWVycztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsYXllcl9uYW1lIGluIGxheWVycykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbGVfaW5kZXhlc1tsYXllcl9uYW1lXSA9IGdlb2pzb252dChsYXllcnNbbGF5ZXJfbmFtZV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFpvb206IHRoaXMubWF4X3pvb20sICAvLyBtYXggem9vbSB0byBwcmVzZXJ2ZSBkZXRhaWwgb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHRvbGVyYW5jZTogMywgLy8gc2ltcGxpZmljYXRpb24gdG9sZXJhbmNlIChoaWdoZXIgbWVhbnMgc2ltcGxlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudDogR2VvLnRpbGVfc2NhbGUsIC8vIHRpbGUgZXh0ZW50IChib3RoIHdpZHRoIGFuZCBoZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXI6IDAgICAgIC8vIHRpbGUgYnVmZmVyIG9uIGVhY2ggc2lkZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRfZGF0YS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGxheWVyX25hbWUgaW4gdGhpcy50aWxlX2luZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICBkZXN0LnNvdXJjZV9kYXRhLmxheWVyc1tsYXllcl9uYW1lXSA9IHRoaXMuZ2V0VGlsZUZlYXR1cmVzKGRlc3QsIGxheWVyX25hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldFRpbGVGZWF0dXJlcyh0aWxlLCBsYXllcl9uYW1lKSB7XG4gICAgICAgIGxldCBjb29yZHMgPSBHZW8ud3JhcFRpbGUodGlsZS5jb29yZHMsIHsgeDogdHJ1ZSB9KTtcblxuICAgICAgICAvLyByZXF1ZXN0IGEgcGFydGljdWxhciB0aWxlXG4gICAgICAgIGxldCB0ID0gdGhpcy50aWxlX2luZGV4ZXNbbGF5ZXJfbmFtZV0uZ2V0VGlsZShjb29yZHMueiwgY29vcmRzLngsIGNvb3Jkcy55KTtcblxuICAgICAgICAvLyBDb252ZXJ0IGZyb20gTVZULXN0eWxlIEpTT04gc3RydWN0IHRvIEdlb0pTT05cbiAgICAgICAgbGV0IGNvbGxlY3Rpb247XG4gICAgICAgIGlmICh0ICYmIHQuZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgICAgICAgICBmZWF0dXJlczogW11cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAobGV0IGZlYXR1cmUgb2YgdC5mZWF0dXJlcykge1xuICAgICAgICAgICAgICAgIC8vIEdlb0pTT04gZmVhdHVyZVxuICAgICAgICAgICAgICAgIGxldCBmID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB7fSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogZmVhdHVyZS50YWdzXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLnR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZi5nZW9tZXRyeS5jb29yZGluYXRlcyA9IGZlYXR1cmUuZ2VvbWV0cnkubWFwKGNvb3JkID0+IFtjb29yZFswXSwgY29vcmRbMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgZi5nZW9tZXRyeS50eXBlID0gJ011bHRpUG9pbnQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmZWF0dXJlLnR5cGUgPT09IDIgfHwgZmVhdHVyZS50eXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBmZWF0dXJlLmdlb21ldHJ5Lm1hcChyaW5nID0+XG4gICAgICAgICAgICAgICAgICAgICAgICByaW5nLm1hcChjb29yZCA9PiBbY29vcmRbMF0sIGNvb3JkWzFdXSlcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS50eXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLmdlb21ldHJ5LnR5cGUgPSAnTXVsdGlMaW5lU3RyaW5nJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLmdlb21ldHJ5ID0gTVZUU291cmNlLmRlY29kZU11bHRpUG9seWdvbihmLmdlb21ldHJ5KTsgLy8gdW4tZmxhdHRlbiByaW5nc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmZlYXR1cmVzLnB1c2goZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICBmb3JtYXRVcmwgKGRlc3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsO1xuICAgIH1cblxuICAgIHBhcnNlU291cmNlRGF0YSAodGlsZSwgc291cmNlLCByZXNwb25zZSkge1xuICAgICAgICBzb3VyY2UubGF5ZXJzID0gdGhpcy5nZXRMYXllcnMoSlNPTi5wYXJzZShyZXNwb25zZSkpO1xuICAgIH1cblxuICAgIC8vIERldGVjdCBzaW5nbGUgb3IgbXVsdGlwbGUgbGF5ZXJzIGluIHJldHVybmVkIGRhdGFcbiAgICBnZXRMYXllcnMgKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ0ZlYXR1cmUnIHx8IGRhdGEudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgX2RlZmF1bHQ6IGRhdGEgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbkRhdGFTb3VyY2UucmVnaXN0ZXIoR2VvSlNPTlRpbGVTb3VyY2UsICdHZW9KU09OJyk7ICAgICAgLy8gcHJlZmVyZWQgc2hvcnRlciBuYW1lXG5EYXRhU291cmNlLnJlZ2lzdGVyKEdlb0pTT05UaWxlU291cmNlLCAnR2VvSlNPTlRpbGVzJyk7IC8vIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eVxuIiwiaW1wb3J0IERhdGFTb3VyY2UsIHtOZXR3b3JrVGlsZVNvdXJjZX0gZnJvbSAnLi9kYXRhX3NvdXJjZSc7XG5pbXBvcnQgR2VvIGZyb20gJy4uL2dlbyc7XG5cbmltcG9ydCBQYmYgZnJvbSAncGJmJztcbmltcG9ydCB7VmVjdG9yVGlsZSwgVmVjdG9yVGlsZUZlYXR1cmV9IGZyb20gJ3ZlY3Rvci10aWxlJztcblxuLyoqXG4gTWFwYm94IFZlY3RvciBUaWxlIGZvcm1hdFxuIEBjbGFzcyBNVlRTb3VyY2VcbiovXG5leHBvcnQgY2xhc3MgTVZUU291cmNlIGV4dGVuZHMgTmV0d29ya1RpbGVTb3VyY2Uge1xuXG4gICAgY29uc3RydWN0b3IgKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihzb3VyY2UpO1xuICAgICAgICB0aGlzLnJlc3BvbnNlX3R5cGUgPSBcImFycmF5YnVmZmVyXCI7IC8vIGJpbmFyeSBkYXRhXG4gICAgfVxuXG4gICAgcGFyc2VTb3VyY2VEYXRhICh0aWxlLCBzb3VyY2UsIHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIENvbnZlcnQgTWFwYm94IHZlY3RvciB0aWxlIHRvIEdlb0pTT05cbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShyZXNwb25zZSk7XG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgUGJmKGRhdGEpO1xuICAgICAgICBzb3VyY2UuZGF0YSA9IG5ldyBWZWN0b3JUaWxlKGJ1ZmZlcik7XG4gICAgICAgIHNvdXJjZS5sYXllcnMgPSB0aGlzLnRvR2VvSlNPTihzb3VyY2UuZGF0YSk7XG4gICAgICAgIGRlbGV0ZSBzb3VyY2UuZGF0YTsgLy8gY29tbWVudCBvdXQgdG8gc2F2ZSByYXcgZGF0YSBmb3IgZGVidWdnaW5nXG4gICAgfVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGxheWVycy9mZWF0dXJlcyB1c2luZyBNYXBib3ggbGliIEFQSSwgY29udmVydCB0byBHZW9KU09OIGZlYXR1cmVzXG4gICAgLy8gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBrZXlzIGZvciBlYWNoIGxheWVyLCBlLmcuIHsgbGF5ZXI6IGdlb2pzb24gfVxuICAgIHRvR2VvSlNPTiAodGlsZSkge1xuICAgICAgICB2YXIgbGF5ZXJzID0ge307XG4gICAgICAgIGZvciAodmFyIGwgaW4gdGlsZS5sYXllcnMpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRpbGUubGF5ZXJzW2xdO1xuICAgICAgICAgICAgdmFyIGxheWVyX2dlb2pzb24gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgICAgICAgICBmZWF0dXJlczogW11cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGY9MDsgZiA8IGxheWVyLmxlbmd0aDsgZisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBsYXllci5mZWF0dXJlKGYpO1xuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlX2dlb2pzb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHt9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBmZWF0dXJlLnByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gZmVhdHVyZV9nZW9qc29uLmdlb21ldHJ5O1xuICAgICAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IGZlYXR1cmUubG9hZEdlb21ldHJ5KCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcj0wOyByIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJpbmcgPSBjb29yZGluYXRlc1tyXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYz0wOyBjIDwgcmluZy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmluZ1tjXSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaW5nW2NdLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmluZ1tjXS55XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXM7XG5cbiAgICAgICAgICAgICAgICBpZiAoVmVjdG9yVGlsZUZlYXR1cmUudHlwZXNbZmVhdHVyZS50eXBlXSA9PT0gJ1BvaW50Jykge1xuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS50eXBlID0gJ1BvaW50JztcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5jb29yZGluYXRlc1swXVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoVmVjdG9yVGlsZUZlYXR1cmUudHlwZXNbZmVhdHVyZS50eXBlXSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnR5cGUgPSAnTGluZVN0cmluZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkudHlwZSA9ICdNdWx0aUxpbmVTdHJpbmcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFZlY3RvclRpbGVGZWF0dXJlLnR5cGVzW2ZlYXR1cmUudHlwZV0gPT09ICdQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IE1WVFNvdXJjZS5kZWNvZGVNdWx0aVBvbHlnb24oZ2VvbWV0cnkpOyAvLyB1bi1mbGF0dGVuIHJpbmdzXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGF5ZXJfZ2VvanNvbi5mZWF0dXJlcy5wdXNoKGZlYXR1cmVfZ2VvanNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXllcnNbbF0gPSBsYXllcl9nZW9qc29uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXllcnM7XG4gICAgfVxuXG4gICAgLy8gRGVjb2RlIG11bHRpcG9seWdvbnMsIHdoaWNoIGFyZSBlbmNvZGVkIGFzIGEgc2luZ2xlIHNldCBvZiByaW5nc1xuICAgIC8vIE91dGVyIHJpbmdzIGFyZSB3b3VuZCBDVywgaW5uZXIgYXJlIENDV1xuICAgIC8vIEEgQ1cgcmluZyBpbmRpY2F0ZXMgdGhlIHN0YXJ0IG9mIGEgbmV3IHBvbHlnb25cbiAgICBzdGF0aWMgZGVjb2RlTXVsdGlQb2x5Z29uIChnZW9tKSB7XG4gICAgICAgIGxldCBwb2x5cyA9IFtdO1xuICAgICAgICBsZXQgcG9seSA9IFtdO1xuICAgICAgICBmb3IgKGxldCByaW5nIG9mIGdlb20uY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIGxldCB3aW5kaW5nID0gR2VvLnJpbmdXaW5kaW5nKHJpbmcpO1xuICAgICAgICAgICAgaWYgKHdpbmRpbmcgPT09ICdDVycgJiYgcG9seS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcG9seXMucHVzaChwb2x5KTtcbiAgICAgICAgICAgICAgICBwb2x5ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2x5LnB1c2gocmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvbHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcG9seXMucHVzaChwb2x5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbmdsZSBvciBtdWx0aT9cbiAgICAgICAgaWYgKHBvbHlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZ2VvbS50eXBlID0gJ1BvbHlnb24nO1xuICAgICAgICAgICAgZ2VvbS5jb29yZGluYXRlcyA9IHBvbHlzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VvbS50eXBlID0gJ011bHRpUG9seWdvbic7XG4gICAgICAgICAgICBnZW9tLmNvb3JkaW5hdGVzID0gcG9seXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2VvbTtcbiAgICB9XG5cbn1cblxuRGF0YVNvdXJjZS5yZWdpc3RlcihNVlRTb3VyY2UsICdNVlQnKTtcbiIsImltcG9ydCBEYXRhU291cmNlIGZyb20gJy4vZGF0YV9zb3VyY2UnO1xuaW1wb3J0IHtHZW9KU09OU291cmNlLCBHZW9KU09OVGlsZVNvdXJjZX0gZnJvbSAnLi9nZW9qc29uJztcblxuaW1wb3J0IHRvcG9qc29uIGZyb20gJ3RvcG9qc29uJztcblxuXG4vKipcbiBNYXB6ZW4vT1NNLlVTLXN0eWxlIFRvcG9KU09OIHZlY3RvciB0aWxlc1xuIEBjbGFzcyBUb3BvSlNPTlRpbGVTb3VyY2VcbiovXG5leHBvcnQgY2xhc3MgVG9wb0pTT05UaWxlU291cmNlIGV4dGVuZHMgR2VvSlNPTlRpbGVTb3VyY2Uge1xuXG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIGxldCBfdGhpcyA9IHN1cGVyKHNvdXJjZSk7XG5cbiAgICAgICAgLy8gUmVwbGFjZSB3aXRoIG5vbi10aWxlZCBzb3VyY2UgaWYgdGlsZWQgc291cmNlIGZhaWxlZCB0byBpbnN0YW50aWF0ZVxuICAgICAgICBpZiAoX3RoaXMgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVG9wb0pTT05Tb3VyY2Uoc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhcnNlU291cmNlRGF0YSAodGlsZSwgc291cmNlLCByZXNwb25zZSkge1xuICAgICAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UpO1xuICAgICAgICBkYXRhID0gVG9wb0pTT05Tb3VyY2UucHJvdG90eXBlLnRvR2VvSlNPTihkYXRhKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlR2VvSlNPTihkYXRhLCB0aWxlLCBzb3VyY2UpO1xuICAgIH1cblxufVxuXG5cbi8qKlxuIFRvcG9KU09OIHN0YW5kYWxvbmUgKG5vbi10aWxlZCkgc291cmNlXG4gVXNlcyBnZW9qc29uLXZ0IHNwbGl0IGludG8gdGlsZXMgY2xpZW50LXNpZGVcbiovXG5cbmV4cG9ydCBjbGFzcyBUb3BvSlNPTlNvdXJjZSBleHRlbmRzIEdlb0pTT05Tb3VyY2Uge1xuXG4gICAgcGFyc2VTb3VyY2VEYXRhICh0aWxlLCBzb3VyY2UsIHJlc3BvbnNlKSB7XG4gICAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XG4gICAgICAgIGRhdGEgPSB0aGlzLnRvR2VvSlNPTihkYXRhKTtcbiAgICAgICAgc291cmNlLmxheWVycyA9IHRoaXMuZ2V0TGF5ZXJzKGRhdGEpO1xuICAgIH1cblxuICAgIHRvR2VvSlNPTiAoZGF0YSkge1xuICAgICAgICAvLyBTaW5nbGUgbGF5ZXJcbiAgICAgICAgaWYgKGRhdGEub2JqZWN0cyAmJlxuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YS5vYmplY3RzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGxldCBsYXllciA9IE9iamVjdC5rZXlzKGRhdGEub2JqZWN0cylbMF07XG4gICAgICAgICAgICBkYXRhID0gdG9wb2pzb24uZmVhdHVyZShkYXRhLCBkYXRhLm9iamVjdHNbbGF5ZXJdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsZSBsYXllcnNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGF5ZXJzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gZGF0YS5vYmplY3RzKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzW2tleV0gPSB0b3BvanNvbi5mZWF0dXJlKGRhdGEsIGRhdGEub2JqZWN0c1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBsYXllcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG59XG5cbkRhdGFTb3VyY2UucmVnaXN0ZXIoVG9wb0pTT05UaWxlU291cmNlLCAnVG9wb0pTT04nKTsgICAgICAgIC8vIHByZWZlcmVkIHNob3J0ZXIgbmFtZVxuRGF0YVNvdXJjZS5yZWdpc3RlcihUb3BvSlNPTlRpbGVTb3VyY2UsICdUb3BvSlNPTlRpbGVzJyk7ICAgLy8gZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5XG5cbiIsIi8vIEdlb21ldHJ5IGJ1aWxkaW5nIGZ1bmN0aW9uc1xuXG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQgR2VvIGZyb20gJy4uL2dlbyc7XG5cbmltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcblxudmFyIEJ1aWxkZXJzO1xuZXhwb3J0IGRlZmF1bHQgQnVpbGRlcnMgPSB7fTtcblxuQnVpbGRlcnMuZGVidWcgPSBmYWxzZTtcblxuQnVpbGRlcnMudGlsZV9ib3VuZHMgPSBbXG4gICAgeyB4OiAwLCB5OiAwfSxcbiAgICB7IHg6IEdlby50aWxlX3NjYWxlLCB5OiAtR2VvLnRpbGVfc2NhbGUgfSAvLyBUT0RPOiBjb3JyZWN0IGZvciBmbGlwcGVkIHktYXhpcz9cbl07XG5cbi8vIFJlLXNjYWxlIFVWcyBmcm9tIFswLCAxXSByYW5nZSB0byBhIHNtYWxsZXIgYXJlYSB3aXRoaW4gdGhlIGltYWdlXG5CdWlsZGVycy5zY2FsZVRleGNvb3Jkc1RvU3ByaXRlID0gZnVuY3Rpb24gKHV2LCBhcmVhX29yaWdpbiwgYXJlYV9zaXplLCB0ZXhfc2l6ZSkge1xuICAgIHZhciBhcmVhX29yaWdpbl95ID0gdGV4X3NpemVbMV0gLSBhcmVhX29yaWdpblsxXSAtIGFyZWFfc2l6ZVsxXTtcbiAgICB2YXIgc3V2ID0gW107XG4gICAgc3V2WzBdID0gKHV2WzBdICogYXJlYV9zaXplWzBdICsgYXJlYV9vcmlnaW5bMF0pIC8gdGV4X3NpemVbMF07XG4gICAgc3V2WzFdID0gKHV2WzFdICogYXJlYV9zaXplWzFdICsgYXJlYV9vcmlnaW5feSkgLyB0ZXhfc2l6ZVsxXTtcbiAgICByZXR1cm4gc3V2O1xufTtcblxuQnVpbGRlcnMuZ2V0VGV4Y29vcmRzRm9yU3ByaXRlID0gZnVuY3Rpb24gKGFyZWFfb3JpZ2luLCBhcmVhX3NpemUsIHRleF9zaXplKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgQnVpbGRlcnMuc2NhbGVUZXhjb29yZHNUb1Nwcml0ZShbMCwgMF0sIGFyZWFfb3JpZ2luLCBhcmVhX3NpemUsIHRleF9zaXplKSxcbiAgICAgICAgQnVpbGRlcnMuc2NhbGVUZXhjb29yZHNUb1Nwcml0ZShbMSwgMV0sIGFyZWFfb3JpZ2luLCBhcmVhX3NpemUsIHRleF9zaXplKVxuICAgIF07XG59O1xuXG4vLyBUZXNzZWxhdGUgYSBmbGF0IDJEIHBvbHlnb25cbi8vIHggJiB5IGNvb3JkaW5hdGVzIHdpbGwgYmUgc2V0IGFzIGZpcnN0IHR3byBlbGVtZW50cyBvZiBwcm92aWRlZCB2ZXJ0ZXhfdGVtcGxhdGVcbkJ1aWxkZXJzLmJ1aWxkUG9seWdvbnMgPSBmdW5jdGlvbiAoXG4gICAgcG9seWdvbnMsXG4gICAgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSxcbiAgICB7IHRleGNvb3JkX2luZGV4LCB0ZXhjb29yZF9zY2FsZSwgdGV4Y29vcmRfbm9ybWFsaXplIH0pIHtcblxuICAgIGlmICh0ZXhjb29yZF9pbmRleCkge1xuICAgICAgICB0ZXhjb29yZF9ub3JtYWxpemUgPSB0ZXhjb29yZF9ub3JtYWxpemUgfHwgMTtcbiAgICAgICAgdmFyIFtbbWluX3UsIG1pbl92XSwgW21heF91LCBtYXhfdl1dID0gdGV4Y29vcmRfc2NhbGUgfHwgW1swLCAwXSwgWzEsIDFdXTtcbiAgICB9XG5cbiAgICB2YXIgbnVtX3BvbHlnb25zID0gcG9seWdvbnMubGVuZ3RoO1xuICAgIGZvciAodmFyIHA9MDsgcCA8IG51bV9wb2x5Z29uczsgcCsrKSB7XG4gICAgICAgIHZhciBwb2x5Z29uID0gcG9seWdvbnNbcF07XG5cbiAgICAgICAgLy8gRmluZCBwb2x5Z29uIGV4dGVudHMgdG8gY2FsY3VsYXRlIFVWcywgZml0IHRoZW0gdG8gdGhlIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3hcbiAgICAgICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XG4gICAgICAgICAgICB2YXIgW21pbl94LCBtaW5feSwgbWF4X3gsIG1heF95XSA9IEdlby5maW5kQm91bmRpbmdCb3gocG9seWdvbik7XG4gICAgICAgICAgICB2YXIgc3Bhbl94ID0gbWF4X3ggLSBtaW5feDtcbiAgICAgICAgICAgIHZhciBzcGFuX3kgPSBtYXhfeSAtIG1pbl95O1xuICAgICAgICAgICAgdmFyIHNjYWxlX3UgPSAobWF4X3UgLSBtaW5fdSkgLyBzcGFuX3g7XG4gICAgICAgICAgICB2YXIgc2NhbGVfdiA9IChtYXhfdiAtIG1pbl92KSAvIHNwYW5feTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlc3NlbGxhdGVcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gQnVpbGRlcnMudHJpYW5ndWxhdGVQb2x5Z29uKHBvbHlnb24pO1xuXG4gICAgICAgIC8vIEFkZCB2ZXJ0ZXggZGF0YVxuICAgICAgICB2YXIgbnVtX3ZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciB2PTA7IHYgPCBudW1fdmVydGljZXM7IHYrKykge1xuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzW3ZdO1xuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlWzBdID0gdmVydGV4WzBdO1xuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlWzFdID0gdmVydGV4WzFdO1xuXG4gICAgICAgICAgICAvLyBBZGQgVVZzXG4gICAgICAgICAgICBpZiAodGV4Y29vcmRfaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAwXSA9ICgodmVydGV4WzBdIC0gbWluX3gpICogc2NhbGVfdSArIG1pbl91KSAqIHRleGNvb3JkX25vcm1hbGl6ZTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAxXSA9ICgodmVydGV4WzFdIC0gbWluX3kpICogc2NhbGVfdiArIG1pbl92KSAqIHRleGNvb3JkX25vcm1hbGl6ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmVydGV4X2RhdGEuYWRkVmVydGV4KHZlcnRleF90ZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBUZXNzZWxhdGUgYW5kIGV4dHJ1ZGUgYSBmbGF0IDJEIHBvbHlnb24gaW50byBhIHNpbXBsZSAzRCBtb2RlbCB3aXRoIGZpeGVkIGhlaWdodCBhbmQgYWRkIHRvIEdMIHZlcnRleCBidWZmZXJcbkJ1aWxkZXJzLmJ1aWxkRXh0cnVkZWRQb2x5Z29ucyA9IGZ1bmN0aW9uIChcbiAgICBwb2x5Z29ucyxcbiAgICB6LCBoZWlnaHQsIG1pbl9oZWlnaHQsXG4gICAgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSxcbiAgICBub3JtYWxfaW5kZXgsXG4gICAgbm9ybWFsX25vcm1hbGl6ZSxcbiAgICB7XG4gICAgICAgIHJlbW92ZV90aWxlX2VkZ2VzLFxuICAgICAgICB0aWxlX2VkZ2VfdG9sZXJhbmNlLFxuICAgICAgICB0ZXhjb29yZF9pbmRleCxcbiAgICAgICAgdGV4Y29vcmRfc2NhbGUsXG4gICAgICAgIHRleGNvb3JkX25vcm1hbGl6ZVxuICAgIH0pIHtcblxuICAgIC8vIFRvcFxuICAgIHZhciBtaW5feiA9IHogKyAobWluX2hlaWdodCB8fCAwKTtcbiAgICB2YXIgbWF4X3ogPSB6ICsgaGVpZ2h0O1xuICAgIHZlcnRleF90ZW1wbGF0ZVsyXSA9IG1heF96O1xuICAgIEJ1aWxkZXJzLmJ1aWxkUG9seWdvbnMocG9seWdvbnMsIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsIHsgdGV4Y29vcmRfaW5kZXgsIHRleGNvb3JkX3NjYWxlLCB0ZXhjb29yZF9ub3JtYWxpemUgfSk7XG5cbiAgICAvLyBXYWxsc1xuICAgIC8vIEZpdCBVVnMgdG8gd2FsbCBxdWFkXG4gICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XG4gICAgICAgIHRleGNvb3JkX25vcm1hbGl6ZSA9IHRleGNvb3JkX25vcm1hbGl6ZSB8fCAxO1xuICAgICAgICB2YXIgW1ttaW5fdSwgbWluX3ZdLCBbbWF4X3UsIG1heF92XV0gPSB0ZXhjb29yZF9zY2FsZSB8fCBbWzAsIDBdLCBbMSwgMV1dO1xuICAgICAgICB2YXIgdGV4Y29vcmRzID0gW1xuICAgICAgICAgICAgW21pbl91LCBtYXhfdl0sXG4gICAgICAgICAgICBbbWluX3UsIG1pbl92XSxcbiAgICAgICAgICAgIFttYXhfdSwgbWluX3ZdLFxuXG4gICAgICAgICAgICBbbWF4X3UsIG1pbl92XSxcbiAgICAgICAgICAgIFttYXhfdSwgbWF4X3ZdLFxuICAgICAgICAgICAgW21pbl91LCBtYXhfdl1cbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICB2YXIgbnVtX3BvbHlnb25zID0gcG9seWdvbnMubGVuZ3RoO1xuICAgIGZvciAodmFyIHA9MDsgcCA8IG51bV9wb2x5Z29uczsgcCsrKSB7XG4gICAgICAgIHZhciBwb2x5Z29uID0gcG9seWdvbnNbcF07XG5cbiAgICAgICAgZm9yICh2YXIgcT0wOyBxIDwgcG9seWdvbi5sZW5ndGg7IHErKykge1xuICAgICAgICAgICAgdmFyIGNvbnRvdXIgPSBwb2x5Z29uW3FdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciB3PTA7IHcgPCBjb250b3VyLmxlbmd0aCAtIDE7IHcrKykge1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVfdGlsZV9lZGdlcyAmJiBCdWlsZGVycy5pc09uVGlsZUVkZ2UoY29udG91clt3XSwgY29udG91clt3KzFdLCB7IHRvbGVyYW5jZTogdGlsZV9lZGdlX3RvbGVyYW5jZSB9KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gZG9uJ3QgZXh0cnVkZSB0aWxlIGVkZ2VzXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVHdvIHRyaWFuZ2xlcyBmb3IgdGhlIHF1YWQgZm9ybWVkIGJ5IGVhY2ggdmVydGV4IHBhaXIsIGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCBoZWlnaHRcbiAgICAgICAgICAgICAgICB2YXIgd2FsbF92ZXJ0aWNlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgW2NvbnRvdXJbdysxXVswXSwgY29udG91clt3KzFdWzFdLCBtYXhfel0sXG4gICAgICAgICAgICAgICAgICAgIFtjb250b3VyW3crMV1bMF0sIGNvbnRvdXJbdysxXVsxXSwgbWluX3pdLFxuICAgICAgICAgICAgICAgICAgICBbY29udG91clt3XVswXSwgY29udG91clt3XVsxXSwgbWluX3pdLFxuICAgICAgICAgICAgICAgICAgICAvLyBUcmlhbmdsZVxuICAgICAgICAgICAgICAgICAgICBbY29udG91clt3XVswXSwgY29udG91clt3XVsxXSwgbWluX3pdLFxuICAgICAgICAgICAgICAgICAgICBbY29udG91clt3XVswXSwgY29udG91clt3XVsxXSwgbWF4X3pdLFxuICAgICAgICAgICAgICAgICAgICBbY29udG91clt3KzFdWzBdLCBjb250b3VyW3crMV1bMV0sIG1heF96XVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxjIHRoZSBub3JtYWwgb2YgdGhlIHdhbGwgZnJvbSB1cCB2ZWN0b3IgYW5kIG9uZSBzZWdtZW50IG9mIHRoZSB3YWxsIHRyaWFuZ2xlc1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWwgPSBWZWN0b3IuY3Jvc3MoXG4gICAgICAgICAgICAgICAgICAgIFswLCAwLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yLm5vcm1hbGl6ZShbY29udG91clt3KzFdWzBdIC0gY29udG91clt3XVswXSwgY29udG91clt3KzFdWzFdIC0gY29udG91clt3XVsxXSwgMF0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB2ZXJ0ZXggdGVtcGxhdGUgd2l0aCBjdXJyZW50IHN1cmZhY2Ugbm9ybWFsXG4gICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW25vcm1hbF9pbmRleCArIDBdID0gbm9ybWFsWzBdICogbm9ybWFsX25vcm1hbGl6ZTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbbm9ybWFsX2luZGV4ICsgMV0gPSBub3JtYWxbMV0gKiBub3JtYWxfbm9ybWFsaXplO1xuICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtub3JtYWxfaW5kZXggKyAyXSA9IG5vcm1hbFsyXSAqIG5vcm1hbF9ub3JtYWxpemU7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciB3dj0wOyB3diA8IHdhbGxfdmVydGljZXMubGVuZ3RoOyB3disrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVswXSA9IHdhbGxfdmVydGljZXNbd3ZdWzBdO1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbMV0gPSB3YWxsX3ZlcnRpY2VzW3d2XVsxXTtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlWzJdID0gd2FsbF92ZXJ0aWNlc1t3dl1bMl07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAwXSA9IHRleGNvb3Jkc1t3dl1bMF0gKiB0ZXhjb29yZF9ub3JtYWxpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAxXSA9IHRleGNvb3Jkc1t3dl1bMV0gKiB0ZXhjb29yZF9ub3JtYWxpemU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhfZGF0YS5hZGRWZXJ0ZXgodmVydGV4X3RlbXBsYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBCdWlsZCB0ZXNzZWxsYXRlZCB0cmlhbmdsZXMgZm9yIGEgcG9seWxpbmVcbkJ1aWxkZXJzLmJ1aWxkUG9seWxpbmVzID0gZnVuY3Rpb24gKFxuICAgIGxpbmVzLFxuICAgIHdpZHRoLFxuICAgIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsXG4gICAge1xuICAgICAgICBjbG9zZWRfcG9seWdvbixcbiAgICAgICAgcmVtb3ZlX3RpbGVfZWRnZXMsXG4gICAgICAgIHRpbGVfZWRnZV90b2xlcmFuY2UsXG4gICAgICAgIHRleGNvb3JkX2luZGV4LFxuICAgICAgICB0ZXhjb29yZF9zY2FsZSxcbiAgICAgICAgdGV4Y29vcmRfbm9ybWFsaXplLFxuICAgICAgICBzY2FsaW5nX2luZGV4LFxuICAgICAgICBzY2FsaW5nX25vcm1hbGl6ZSxcbiAgICAgICAgam9pbiwgY2FwXG4gICAgfSkge1xuXG4gICAgdmFyIGNvcm5lcnNPbkNhcCA9IChjYXAgPT09IFwic3F1YXJlXCIpID8gMiA6ICgoY2FwID09PSBcInJvdW5kXCIpID8gMyA6IDApOyAgLy8gQnV0dCBpcyB0aGUgaW1wbGljaXQgZGVmYXVsdFxuICAgIHZhciB0cmlhbmdsZXNPbkpvaW4gPSAoam9pbiA9PT0gXCJiZXZlbFwiKSA/IDEgOiAoKGpvaW4gPT09IFwicm91bmRcIikgPyAzIDogMCk7ICAvLyBNaXRlciBpcyB0aGUgaW1wbGljaXQgZGVmYXVsdFxuXG4gICAgLy8gQnVpbGQgdmFyaWFibGVzXG4gICAgdGV4Y29vcmRfbm9ybWFsaXplID0gdGV4Y29vcmRfbm9ybWFsaXplIHx8IDE7XG4gICAgdmFyIFtbbWluX3UsIG1pbl92XSwgW21heF91LCBtYXhfdl1dID0gdGV4Y29vcmRfc2NhbGUgfHwgW1swLCAwXSwgWzEsIDFdXTtcblxuICAgIC8vIFZhbHVlcyB0aGF0IGFyZSBjb25zdGFudCBmb3IgZWFjaCBsaW5lIGFuZCBhcmUgcGFzc2VkIHRvIGhlbHBlciBmdW5jdGlvbnNcbiAgICB2YXIgY29uc3RhbnRzID0ge1xuICAgICAgICB2ZXJ0ZXhfZGF0YSxcbiAgICAgICAgdmVydGV4X3RlbXBsYXRlLFxuICAgICAgICBoYWxmV2lkdGg6IHdpZHRoLzIsXG4gICAgICAgIHZlcnRpY2VzOiBbXSxcbiAgICAgICAgc2NhbGluZ19pbmRleCxcbiAgICAgICAgc2NhbGluZ19ub3JtYWxpemUsXG4gICAgICAgIHNjYWxpbmdWZWNzOiBzY2FsaW5nX2luZGV4ICYmIFtdLFxuICAgICAgICB0ZXhjb29yZF9pbmRleCxcbiAgICAgICAgdGV4Y29vcmRzOiB0ZXhjb29yZF9pbmRleCAmJiBbXSxcbiAgICAgICAgdGV4Y29vcmRfbm9ybWFsaXplLFxuICAgICAgICBtaW5fdSwgbWluX3YsIG1heF91LCBtYXhfdixcbiAgICAgICAgblBhaXJzOiAwXG4gICAgfTtcblxuICAgIGZvciAodmFyIGxuID0gMDsgbG4gPCBsaW5lcy5sZW5ndGg7IGxuKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tsbl07XG4gICAgICAgIHZhciBsaW5lU2l6ZSA9IGxpbmUubGVuZ3RoO1xuXG4gICAgICAgIC8vIElnbm9yZSBub24tbGluZXNcbiAgICAgICAgaWYgKGxpbmVTaXplIDwgMikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgSW5pdGlhbGl6ZSB2YXJpYWJsZXNcbiAgICAgICAgdmFyIGNvb3JkUHJldiA9IFswLCAwXSwgLy8gUHJldmlvdXMgcG9pbnQgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIGNvb3JkQ3VyciA9IFswLCAwXSwgLy8gQ3VycmVudCBwb2ludCBjb29yZGluYXRlc1xuICAgICAgICAgICAgY29vcmROZXh0ID0gWzAsIDBdOyAvLyBOZXh0IHBvaW50IGNvb3JkaW5hdGVzXG5cbiAgICAgICAgdmFyIG5vcm1QcmV2ID0gWzAsIDBdLCAgLy8gUmlnaHQgbm9ybWFsIHRvIHNlZ21lbnQgYmV0d2VlbiBwcmV2aW91cyBhbmQgY3VycmVudCBtX3BvaW50c1xuICAgICAgICAgICAgbm9ybUN1cnIgPSBbMCwgMF0sICAvLyBSaWdodCBub3JtYWwgYXQgY3VycmVudCBwb2ludCwgc2NhbGVkIGZvciBtaXRlciBqb2ludFxuICAgICAgICAgICAgbm9ybU5leHQgPSBbMCwgMF07ICAvLyBSaWdodCBub3JtYWwgdG8gc2VnbWVudCBiZXR3ZWVuIGN1cnJlbnQgYW5kIG5leHQgbV9wb2ludHNcblxuICAgICAgICB2YXIgaXNQcmV2ID0gZmFsc2UsXG4gICAgICAgICAgICBpc05leHQgPSB0cnVlO1xuXG4gICAgICAgIC8vIEFkZCB2ZXJ0aWNlcyB0byBidWZmZXIgYWNjb3JkaW5nIHRvIHRoZWlyIGluZGV4XG4gICAgICAgIGluZGV4UGFpcnMoY29uc3RhbnRzKTtcblxuICAgICAgICAvLyBEbyB0aGlzIHdpdGggdGhlIHJlc3QgKGV4Y2VwdCB0aGUgbGFzdCBvbmUpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZVNpemUgOyBpKyspIHtcblxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSBuZXh0IG9uZT9cbiAgICAgICAgICAgIGlzTmV4dCA9IGkrMSA8IGxpbmVTaXplO1xuXG4gICAgICAgICAgICBpZiAoaXNQcmV2KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwcmV2aW91cyBvbmUsIGNvcHkgdGhlIGN1cnJlbnQgKHByZXZpb3VzKSB2YWx1ZXMgb24gKlByZXZcbiAgICAgICAgICAgICAgICBjb29yZFByZXYgPSBjb29yZEN1cnI7XG4gICAgICAgICAgICAgICAgbm9ybVByZXYgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKGNvb3JkUHJldiwgbGluZVtpXSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwICYmIGNsb3NlZF9wb2x5Z29uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyB0aGUgZmlyc3QgcG9pbnQgYW5kIGlzIGEgY2xvc2VkIHBvbHlnb25cblxuICAgICAgICAgICAgICAgIHZhciBuZWVkVG9DbG9zZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZV90aWxlX2VkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKEJ1aWxkZXJzLmlzT25UaWxlRWRnZShsaW5lW2ldLCBsaW5lW2xpbmVTaXplLTJdLCB7IHRvbGVyYW5jZTogdGlsZV9lZGdlX3RvbGVyYW5jZSB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZFRvQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChuZWVkVG9DbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICBjb29yZFByZXYgPSBsaW5lW2xpbmVTaXplLTJdO1xuICAgICAgICAgICAgICAgICAgICBub3JtUHJldiA9IFZlY3Rvci5ub3JtYWxpemUoVmVjdG9yLnBlcnAoY29vcmRQcmV2LCBsaW5lW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIGlzUHJldiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBc3NpZ24gY3VycmVudCBjb29yZGluYXRlXG4gICAgICAgICAgICBjb29yZEN1cnIgPSBsaW5lW2ldO1xuXG4gICAgICAgICAgICBpZiAoaXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgY29vcmROZXh0ID0gbGluZVtpKzFdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbG9zZWRfcG9seWdvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgdGhlIGxhc3QgcG9pbnQgaW4gYSBjbG9zZWQgcG9seWdvblxuICAgICAgICAgICAgICAgIGNvb3JkTmV4dCA9IGxpbmVbMV07XG4gICAgICAgICAgICAgICAgaXNOZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzTmV4dCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0J3Mgbm90IHRoZSBsYXN0IG9uZSBnZXQgbmV4dCBjb29yZGluYXRlcyBhbmQgY2FsY3VsYXRlIHRoZSByaWdodCBub3JtYWxcblxuICAgICAgICAgICAgICAgIG5vcm1OZXh0ID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3IucGVycChjb29yZEN1cnIsIGNvb3JkTmV4dCkpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVfdGlsZV9lZGdlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQnVpbGRlcnMuaXNPblRpbGVFZGdlKGNvb3JkQ3VyciwgY29vcmROZXh0LCB7IHRvbGVyYW5jZTogdGlsZV9lZGdlX3RvbGVyYW5jZSB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybUN1cnIgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKGNvb3JkUHJldiwgY29vcmRDdXJyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4UGFpcihjb29yZEN1cnIsIG5vcm1DdXJyLCBpL2xpbmVTaXplLCBjb25zdGFudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50cy5uUGFpcnMrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB2ZXJ0aWNlcyB0byBidWZmZXIgYWNvcmRpbmcgdGhlaXIgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFBhaXJzKGNvbnN0YW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXYgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAgQ29tcHV0ZSBjdXJyZW50IG5vcm1hbFxuICAgICAgICAgICAgaWYgKGlzUHJldikge1xuICAgICAgICAgICAgICAgIC8vICBJZiB0aGVyZSBpcyBhIFBSRVZJT1VTIC4uLlxuICAgICAgICAgICAgICAgIGlmIChpc05leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uIGFuZCBhIE5FWFQgT05FLCBjb21wdXRlIHByZXZpb3VzIGFuZCBuZXh0IG5vcm1hbHMgKHNjYWxlZCBieSB0aGUgYW5nbGUgd2l0aCB0aGUgbGFzdCBwcmV2KVxuICAgICAgICAgICAgICAgICAgICBub3JtQ3VyciA9IFZlY3Rvci5ub3JtYWxpemUoVmVjdG9yLmFkZChub3JtUHJldiwgbm9ybU5leHQpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gMiAvICgxICsgTWF0aC5hYnMoVmVjdG9yLmRvdChub3JtUHJldiwgbm9ybUN1cnIpKSk7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1DdXJyID0gVmVjdG9yLm11bHQobm9ybUN1cnIsc2NhbGUqc2NhbGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLiBhbmQgdGhlcmUgaXMgTk9UIGEgTkVYVCBPTkUsIGNvcHkgdGhlIHByZXZpb3VzIG5leHQgb25lICh3aGljaCBpcyB0aGUgY3VycmVudCBvbmUpXG4gICAgICAgICAgICAgICAgICAgIG5vcm1DdXJyID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3IucGVycChjb29yZFByZXYsIGNvb3JkQ3VycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgTk8gUFJFVklPVVMgLi4uXG4gICAgICAgICAgICAgICAgaWYgKGlzTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi4gYW5kIGEgTkVYVCBPTkUsXG4gICAgICAgICAgICAgICAgICAgIG5vcm1OZXh0ID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3IucGVycChjb29yZEN1cnIsIGNvb3JkTmV4dCkpO1xuICAgICAgICAgICAgICAgICAgICBub3JtQ3VyciA9IG5vcm1OZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLiBhbmQgTk8gTkVYVCBPTkUsIG5vdGhpbmcgdG8gZG8gKHdpdGhvdXQgcHJldiBvciBuZXh0IG9uZSB0aGlzIGlzIGp1c3QgYSBwb2ludClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNQcmV2IHx8IGlzTmV4dCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgdGhlIEJFR0lOTklORyBvZiBhIExJTkVcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiAhaXNQcmV2ICYmICFjbG9zZWRfcG9seWdvbikge1xuICAgICAgICAgICAgICAgICAgICBhZGRDYXAoY29vcmRDdXJyLCBub3JtQ3VyciwgY29ybmVyc09uQ2FwLCB0cnVlLCBjb25zdGFudHMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYSBKT0lOXG4gICAgICAgICAgICAgICAgaWYodHJpYW5nbGVzT25Kb2luICE9PSAwICYmIGlzUHJldiAmJiBpc05leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkSm9pbihbY29vcmRQcmV2LCBjb29yZEN1cnIsIGNvb3JkTmV4dF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW25vcm1QcmV2LG5vcm1DdXJyLCBub3JtTmV4dF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS9saW5lU2l6ZSwgdHJpYW5nbGVzT25Kb2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50cyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4UGFpcihjb29yZEN1cnIsIG5vcm1DdXJyLCBpLyhsaW5lU2l6ZS0xKSwgY29uc3RhbnRzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgY29uc3RhbnRzLm5QYWlycysrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlzUHJldiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdmVydGljZXMgdG8gYnVmZmVyIGFjY29yZGluZyB0byB0aGVpciBpbmRleFxuICAgICAgICBpbmRleFBhaXJzKGNvbnN0YW50cyk7XG5cbiAgICAgICAgIC8vIElmIGl0J3MgdGhlIEVORCBvZiBhIExJTkVcbiAgICAgICAgaWYoIWNsb3NlZF9wb2x5Z29uKSB7XG4gICAgICAgICAgICBhZGRDYXAoY29vcmRDdXJyLCBub3JtQ3VyciwgY29ybmVyc09uQ2FwICwgZmFsc2UsIGNvbnN0YW50cyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBBZGQgdG8gZXF1aWRpc3RhbnQgcGFpcnMgb2YgdmVydGljZXMgKGludGVybmFsIG1ldGhvZCBmb3IgcG9seWxpbmUgYnVpbGRlcilcbmZ1bmN0aW9uIGFkZFZlcnRleChjb29yZCwgbm9ybWFsLCB1diwgeyBoYWxmV2lkdGgsIHZlcnRpY2VzLCBzY2FsaW5nVmVjcywgdGV4Y29vcmRzIH0pIHtcbiAgICBpZiAoc2NhbGluZ1ZlY3MpIHtcbiAgICAgICAgLy8gIGEuIElmIHNjYWxpbmcgaXMgb24gYWRkIHRoZSB2ZXJ0ZXggKHRoZSBjdXJyQ29vcmQpIGFuZCB0aGUgc2NhbGluZyBWZWNzIChub3JtYWxzIHBvaW50aW5nIHdoZXJlIHRvIGV4dHJ1ZGUgdGhlIHZlcnRpY2VzKVxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKGNvb3JkKTtcbiAgICAgICAgc2NhbGluZ1ZlY3MucHVzaChub3JtYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICBiLiBBZGQgdGhlIGV4dHJ1ZGVkIHZlcnRpY2VzXG4gICAgICAgIHZlcnRpY2VzLnB1c2goW2Nvb3JkWzBdICsgbm9ybWFsWzBdICogaGFsZldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICBjb29yZFsxXSArIG5vcm1hbFsxXSAqIGhhbGZXaWR0aF0pO1xuICAgIH1cblxuICAgIC8vIGMpIEFkZCBVVnMgaWYgdGhleSBhcmUgZW5hYmxlZFxuICAgIGlmICh0ZXhjb29yZHMpIHtcbiAgICAgICAgdGV4Y29vcmRzLnB1c2godXYpO1xuICAgIH1cbn1cblxuLy8gIEFkZCB0byBlcXVpZGlzdGFudCBwYWlycyBvZiB2ZXJ0aWNlcyAoaW50ZXJuYWwgbWV0aG9kIGZvciBwb2x5bGluZSBidWlsZGVyKVxuZnVuY3Rpb24gYWRkVmVydGV4UGFpciAoY29vcmQsIG5vcm1hbCwgdl9wY3QsIGNvbnN0YW50cykge1xuICAgIGFkZFZlcnRleChjb29yZCwgbm9ybWFsLCBbY29uc3RhbnRzLm1heF91LCAoMS12X3BjdCkqY29uc3RhbnRzLm1pbl92ICsgdl9wY3QqY29uc3RhbnRzLm1heF92XSwgY29uc3RhbnRzKTtcbiAgICBhZGRWZXJ0ZXgoY29vcmQsIFZlY3Rvci5uZWcobm9ybWFsKSwgW2NvbnN0YW50cy5taW5fdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl0sIGNvbnN0YW50cyk7XG59XG5cbi8vICBUZXNzYWxhdGUgYSBGQU4gZ2VvbWV0cnkgYmV0d2VlbiBwb2ludHMgQSAgICAgICBCXG4vLyAgdXNpbmcgdGhlaXIgbm9ybWFscyBmcm9tIGEgY2VudGVyICAgICAgICBcXCAuIC4gL1xuLy8gIGFuZCBpbnRlcnBvbGF0aW5nIHRoZWlyIFVWcyAgICAgICAgICAgICAgIFxcIHAgL1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXC4vXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDXG5mdW5jdGlvbiBhZGRGYW4gKGNvb3JkLCBuQSwgbkMsIG5CLCB1QSwgdUMsIHVCLCBzaWduZWQsIG51bVRyaWFuZ2xlcywgY29uc3RhbnRzKSB7XG5cbiAgICBpZiAobnVtVHJpYW5nbGVzIDwgMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWRkIHByZXZpb3VzIHZlcnRpY2VzIHRvIGJ1ZmZlciBhbmQgY2xlYXIgdGhlIGJ1ZmZlcnMgYW5kIGluZGV4IHBhaXJzXG4gICAgLy8gYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gYWRkIG1vcmUgdHJpYW5nbGVzLlxuICAgIGluZGV4UGFpcnMoY29uc3RhbnRzKTtcblxuICAgIHZhciBub3JtQ3VyciA9IFZlY3Rvci5zZXQobkEpO1xuICAgIHZhciBub3JtUHJldiA9IFswLDBdO1xuXG4gICAgdmFyIGFuZ2xlX2RlbHRhID0gVmVjdG9yLmRvdChuQSwgbkIpO1xuICAgIGlmIChhbmdsZV9kZWx0YSA8IC0xKSB7XG4gICAgICAgIGFuZ2xlX2RlbHRhID0gLTE7XG4gICAgfVxuICAgIGFuZ2xlX2RlbHRhID0gTWF0aC5hY29zKGFuZ2xlX2RlbHRhKS9udW1UcmlhbmdsZXM7XG5cbiAgICBpZiAoIXNpZ25lZCkge1xuICAgICAgICBhbmdsZV9kZWx0YSAqPSAtMTtcbiAgICB9XG5cbiAgICB2YXIgdXZDdXJyID0gVmVjdG9yLnNldCh1QSk7XG4gICAgdmFyIHV2X2RlbHRhID0gVmVjdG9yLmRpdihWZWN0b3Iuc3ViKHVCLHVBKSwgbnVtVHJpYW5nbGVzKTtcblxuICAgIC8vICBBZGQgdGhlIEZJUlNUIGFuZCBDRU5URVIgdmVydGV4XG4gICAgLy8gIFRoZSB0cmlhbmdsZXMgd2lsbCBiZSBjb21wb3NlZCBpbiBhIEZBTiBzdHlsZSBhcm91bmQgaXRcbiAgICBhZGRWZXJ0ZXgoY29vcmQsIG5DLCB1QywgY29uc3RhbnRzKTtcblxuICAgIC8vICBBZGQgZmlyc3QgY29ybmVyXG4gICAgYWRkVmVydGV4KGNvb3JkLCBub3JtQ3VyciwgdUEsIGNvbnN0YW50cyk7XG5cbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJlc3Qgb2YgdGhlIGNvcm5lcnNcbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bVRyaWFuZ2xlczsgdCsrKSB7XG4gICAgICAgIG5vcm1QcmV2ID0gVmVjdG9yLm5vcm1hbGl6ZShub3JtQ3Vycik7XG4gICAgICAgIG5vcm1DdXJyID0gVmVjdG9yLnJvdCggVmVjdG9yLm5vcm1hbGl6ZShub3JtQ3VyciksIGFuZ2xlX2RlbHRhKTsgICAgIC8vICBSb3RhdGUgdGhlIGV4dHJ1c2lvbiBub3JtYWxcblxuICAgICAgICBpZiAobnVtVHJpYW5nbGVzID09PSA0ICYmICh0ID09PSAwIHx8IHQgPT09IG51bVRyaWFuZ2xlcyAtIDIpKSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSAyIC8gKDEgKyBNYXRoLmFicyhWZWN0b3IuZG90KG5vcm1QcmV2LCBub3JtQ3VycikpKTtcbiAgICAgICAgICAgIG5vcm1DdXJyID0gVmVjdG9yLm11bHQobm9ybUN1cnIsIHNjYWxlKnNjYWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHV2Q3VyciA9IFZlY3Rvci5hZGQodXZDdXJyLHV2X2RlbHRhKTtcblxuICAgICAgICBhZGRWZXJ0ZXgoY29vcmQsIG5vcm1DdXJyLCB1dkN1cnIsIGNvbnN0YW50cyk7ICAgICAgLy8gIEFkZCBjb21wdXRlZCBjb3JuZXJcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRyaWFuZ2xlczsgaSsrKSB7XG4gICAgICAgIGlmIChzaWduZWQpIHtcbiAgICAgICAgICAgIGFkZEluZGV4KGkrMiwgY29uc3RhbnRzKTtcbiAgICAgICAgICAgIGFkZEluZGV4KDAsIGNvbnN0YW50cyk7XG4gICAgICAgICAgICBhZGRJbmRleChpKzEsIGNvbnN0YW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRJbmRleChpKzEsIGNvbnN0YW50cyk7XG4gICAgICAgICAgICBhZGRJbmRleCgwLCBjb25zdGFudHMpO1xuICAgICAgICAgICAgYWRkSW5kZXgoaSsyLCBjb25zdGFudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgdGhlIGJ1ZmZlclxuICAgIGNvbnN0YW50cy52ZXJ0aWNlcyA9IFtdO1xuICAgIGlmIChjb25zdGFudHMuc2NhbGluZ1ZlY3MpIHtcbiAgICAgICAgY29uc3RhbnRzLnNjYWxpbmdWZWNzID0gW107XG4gICAgfVxuICAgIGlmIChjb25zdGFudHMudGV4Y29vcmRzKSB7XG4gICAgICAgIGNvbnN0YW50cy50ZXhjb29yZHMgPSBbXTtcbiAgICB9XG59XG5cbi8vICBBZGQgc3BlY2lhbCBqb2lucyAobm90IG1pdGVyKSB0eXBlcyB0aGF0IHJlcXVpcmUgRkFOIHRlc3NlbGxhdGlvbnNcbi8vICBVc2luZyBodHRwOi8vd3d3LmNvZGVwcm9qZWN0LmNvbS9BcnRpY2xlcy8yMjY1NjkvRHJhd2luZy1wb2x5bGluZXMtYnktdGVzc2VsbGF0aW9uIGFzIHJlZmVyZW5jZVxuZnVuY3Rpb24gYWRkSm9pbiAoY29vcmRzLCBub3JtYWxzLCB2X3BjdCwgblRyaWFuZ2xlcywgY29uc3RhbnRzKSB7XG5cbiAgICB2YXIgVCA9IFtWZWN0b3Iuc2V0KG5vcm1hbHNbMF0pLCBWZWN0b3Iuc2V0KG5vcm1hbHNbMV0pLCBWZWN0b3Iuc2V0KG5vcm1hbHNbMl0pXTtcbiAgICB2YXIgc2lnbmVkID0gVmVjdG9yLnNpZ25lZF9hcmVhKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0pID4gMDtcblxuICAgIHZhciBuQSA9IFRbMF0sICAgICAgICAgICAgICAvLyBub3JtYWwgdG8gcG9pbnQgQSAoYVQpXG4gICAgICAgIG5DID0gVmVjdG9yLm5lZyhUWzFdKSwgIC8vIG5vcm1hbCB0byBjZW50ZXIgKC12UClcbiAgICAgICAgbkIgPSBUWzJdOyAgICAgICAgICAgICAgLy8gbm9ybWFsIHRvIHBvaW50IEIgKGJUKVxuXG4gICAgdmFyIHVBID0gW2NvbnN0YW50cy5tYXhfdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl0sXG4gICAgICAgIHVDID0gW2NvbnN0YW50cy5taW5fdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl0sXG4gICAgICAgIHVCID0gW2NvbnN0YW50cy5tYXhfdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl07XG5cbiAgICBpZiAoc2lnbmVkKSB7XG4gICAgICAgIGFkZFZlcnRleChjb29yZHNbMV0sIG5BLCB1QSwgY29uc3RhbnRzKTtcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkMsIHVDLCBjb25zdGFudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5BID0gVmVjdG9yLm5lZyhUWzBdKTtcbiAgICAgICAgbkMgPSBUWzFdO1xuICAgICAgICBuQiA9IFZlY3Rvci5uZWcoVFsyXSk7XG4gICAgICAgIHVBID0gW2NvbnN0YW50cy5taW5fdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl07XG4gICAgICAgIHVDID0gW2NvbnN0YW50cy5tYXhfdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl07XG4gICAgICAgIHVCID0gW2NvbnN0YW50cy5taW5fdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl07XG4gICAgICAgIGFkZFZlcnRleChjb29yZHNbMV0sIG5DLCB1QywgY29uc3RhbnRzKTtcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkEsIHVBLCBjb25zdGFudHMpO1xuICAgIH1cblxuICAgIGFkZEZhbihjb29yZHNbMV0sIG5BLCBuQywgbkIsIHVBLCB1QywgdUIsIHNpZ25lZCwgblRyaWFuZ2xlcywgY29uc3RhbnRzKTtcblxuICAgIGlmIChzaWduZWQpIHtcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkIsIHVCLCBjb25zdGFudHMpO1xuICAgICAgICBhZGRWZXJ0ZXgoY29vcmRzWzFdLCBuQywgdUMsIGNvbnN0YW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkMsIHVDLCBjb25zdGFudHMpO1xuICAgICAgICBhZGRWZXJ0ZXgoY29vcmRzWzFdLCBuQiwgdUIsIGNvbnN0YW50cyk7XG4gICAgfVxufVxuXG4vLyAgRnVuY3Rpb24gdG8gYWRkIHRoZSB2ZXJ0ZXggbmVlZCBmb3IgbGluZSBjYXBzLFxuLy8gIGJlY2F1c2UgcmUtdXNlIHRoZSBidWZmZXJzIG5lZWRzIHRvIGJlIGF0IHRoZSBlbmRcbmZ1bmN0aW9uIGFkZENhcCAoY29vcmQsIG5vcm1hbCwgbnVtQ29ybmVycywgaXNCZWdpbm5pbmcsIGNvbnN0YW50cykge1xuXG4gICAgaWYgKG51bUNvcm5lcnMgPCAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBVVnNcbiAgICB2YXIgdXZBID0gW2NvbnN0YW50cy5taW5fdSxjb25zdGFudHMubWluX3ZdLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJlZ2lubmluZyBhbmdsZSBVVnNcbiAgICAgICAgdXZDID0gW2NvbnN0YW50cy5taW5fdSsoY29uc3RhbnRzLm1heF91LWNvbnN0YW50cy5taW5fdSkvMiwgY29uc3RhbnRzLm1pbl92XSwgICAvLyBjZW50ZXIgcG9pbnQgVVZzXG4gICAgICAgIHV2QiA9IFtjb25zdGFudHMubWF4X3UsY29uc3RhbnRzLm1pbl92XTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmRpbmcgYW5nbGUgVVZzXG5cbiAgICBpZiAoIWlzQmVnaW5uaW5nKSB7XG4gICAgICAgIHV2QSA9IFtjb25zdGFudHMubWluX3UsY29uc3RhbnRzLm1heF92XSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBCZWdpbmluZyBhbmdsZSBVVnNcbiAgICAgICAgdXZDID0gW2NvbnN0YW50cy5taW5fdSsoY29uc3RhbnRzLm1heF91LWNvbnN0YW50cy5taW5fdSkvMiwgY29uc3RhbnRzLm1heF92XSwgICAvLyBjZW50ZXIgcG9pbnQgVVZzXG4gICAgICAgIHV2QiA9IFtjb25zdGFudHMubWF4X3UsY29uc3RhbnRzLm1heF92XTtcbiAgICB9XG5cbiAgICBhZGRGYW4oIGNvb3JkLFxuICAgICAgICAgICAgVmVjdG9yLm5lZyhub3JtYWwpLCBbMCwgMF0sIG5vcm1hbCxcbiAgICAgICAgICAgIHV2QSwgdXZDLCB1dkIsXG4gICAgICAgICAgICBpc0JlZ2lubmluZywgbnVtQ29ybmVycyoyLCBjb25zdGFudHMpO1xufVxuXG4vLyBBZGQgYSB2ZXJ0ZXggYmFzZWQgb24gdGhlIGluZGV4IHBvc2l0aW9uIGludG8gdGhlIFZCTyAoaW50ZXJuYWwgbWV0aG9kIGZvciBwb2x5bGluZSBidWlsZGVyKVxuZnVuY3Rpb24gYWRkSW5kZXggKGluZGV4LCB7IHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsIGhhbGZXaWR0aCwgdmVydGljZXMsIHNjYWxpbmdfaW5kZXgsIHNjYWxpbmdfbm9ybWFsaXplLCBzY2FsaW5nVmVjcywgdGV4Y29vcmRfaW5kZXgsIHRleGNvb3JkcywgdGV4Y29vcmRfbm9ybWFsaXplIH0pIHtcbiAgICAvLyBQcmV2ZW50IGFjY2VzcyB0byB1bmRlZmluZWQgdmVydGljZXNcbiAgICBpZiAoaW5kZXggPj0gdmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQgdmVydGV4IHBvc2l0aW9uXG4gICAgdmVydGV4X3RlbXBsYXRlWzBdID0gdmVydGljZXNbaW5kZXhdWzBdO1xuICAgIHZlcnRleF90ZW1wbGF0ZVsxXSA9IHZlcnRpY2VzW2luZGV4XVsxXTtcblxuICAgIC8vIHNldCBVVnNcbiAgICBpZiAodGV4Y29vcmRfaW5kZXgpIHtcbiAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMF0gPSB0ZXhjb29yZHNbaW5kZXhdWzBdICogdGV4Y29vcmRfbm9ybWFsaXplO1xuICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAxXSA9IHRleGNvb3Jkc1tpbmRleF1bMV0gKiB0ZXhjb29yZF9ub3JtYWxpemU7XG4gICAgfVxuXG4gICAgLy8gc2V0IFNjYWxpbmcgdmVydGV4IChYLCBZIG5vcm1hbCBkaXJlY3Rpb24gKyBaIGhhbGZ3aWR0aCBhcyBhdHRyaWJ1dGUpXG4gICAgaWYgKHNjYWxpbmdfaW5kZXgpIHtcbiAgICAgICAgdmVydGV4X3RlbXBsYXRlW3NjYWxpbmdfaW5kZXggKyAwXSA9IHNjYWxpbmdWZWNzW2luZGV4XVswXSAqIHNjYWxpbmdfbm9ybWFsaXplO1xuICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbc2NhbGluZ19pbmRleCArIDFdID0gc2NhbGluZ1ZlY3NbaW5kZXhdWzFdICogc2NhbGluZ19ub3JtYWxpemU7XG4gICAgICAgIHZlcnRleF90ZW1wbGF0ZVtzY2FsaW5nX2luZGV4ICsgMl0gPSBoYWxmV2lkdGg7XG4gICAgfVxuXG4gICAgLy8gIEFkZCB2ZXJ0ZXggdG8gVkJPXG4gICAgdmVydGV4X2RhdGEuYWRkVmVydGV4KHZlcnRleF90ZW1wbGF0ZSk7XG59XG5cbi8vIEFkZCB0aGUgaW5kZXggdmVydGV4IHRvIHRoZSBWQk8gYW5kIGNsZWFuIHRoZSBidWZmZXJzXG5mdW5jdGlvbiBpbmRleFBhaXJzIChjb25zdGFudHMpIHtcbiAgICAvLyBBZGQgdmVydGljZXMgdG8gYnVmZmVyIGFjb3JkaW5nIHRoZWlyIGluZGV4XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25zdGFudHMublBhaXJzOyBpKyspIHtcbiAgICAgICAgYWRkSW5kZXgoMippKzIsIGNvbnN0YW50cyk7XG4gICAgICAgIGFkZEluZGV4KDIqaSsxLCBjb25zdGFudHMpO1xuICAgICAgICBhZGRJbmRleCgyKmkrMCwgY29uc3RhbnRzKTtcblxuICAgICAgICBhZGRJbmRleCgyKmkrMiwgY29uc3RhbnRzKTtcbiAgICAgICAgYWRkSW5kZXgoMippKzMsIGNvbnN0YW50cyk7XG4gICAgICAgIGFkZEluZGV4KDIqaSsxLCBjb25zdGFudHMpO1xuICAgIH1cblxuICAgIGNvbnN0YW50cy5uUGFpcnMgPSAwO1xuXG4gICAgLy8gQ2xlYW4gdGhlIGJ1ZmZlclxuICAgIGNvbnN0YW50cy52ZXJ0aWNlcyA9IFtdO1xuICAgIGlmIChjb25zdGFudHMuc2NhbGluZ1ZlY3MpIHtcbiAgICAgICAgY29uc3RhbnRzLnNjYWxpbmdWZWNzID0gW107XG4gICAgfVxuICAgIGlmIChjb25zdGFudHMudGV4Y29vcmRzKSB7XG4gICAgICAgIGNvbnN0YW50cy50ZXhjb29yZHMgPSBbXTtcbiAgICB9XG59XG5cbi8vIEJ1aWxkIGEgYmlsbGJvYXJkIHNwcml0ZSBxdWFkIGNlbnRlcmVkIG9uIGEgcG9pbnQuIFNwcml0ZXMgYXJlIGludGVuZGVkIHRvIGJlIGRyYXduIGluIHNjcmVlbnNwYWNlLCBhbmQgaGF2ZVxuLy8gcHJvcGVydGllcyBmb3Igd2lkdGgsIGhlaWdodCwgYW5nbGUsIGFuZCBhIHNjYWxlIGZhY3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIGludGVycG9sYXRlIHRoZSBzY3JlZW5zcGFjZSBzaXplXG4vLyBvZiBhIHNwcml0ZSBiZXR3ZWVuIHR3byB6b29tIGxldmVscy5cbkJ1aWxkZXJzLmJ1aWxkUXVhZHNGb3JQb2ludHMgPSBmdW5jdGlvbiAocG9pbnRzLCB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLFxuICAgIHsgdGV4Y29vcmRfaW5kZXgsIHBvc2l0aW9uX2luZGV4LCBzaGFwZV9pbmRleCwgb2Zmc2V0X2luZGV4IH0sXG4gICAgeyBxdWFkLCBxdWFkX3NjYWxlLCBvZmZzZXQsIGFuZ2xlLCB0ZXhjb29yZF9zY2FsZSwgdGV4Y29vcmRfbm9ybWFsaXplIH0pIHtcbiAgICBsZXQgdzIgPSBxdWFkWzBdIC8gMjtcbiAgICBsZXQgaDIgPSBxdWFkWzFdIC8gMjtcbiAgICBsZXQgc2NhbGluZyA9IFtcbiAgICAgICAgWy13MiwgLWgyXSxcbiAgICAgICAgW3cyLCAtaDJdLFxuICAgICAgICBbdzIsIGgyXSxcblxuICAgICAgICBbLXcyLCAtaDJdLFxuICAgICAgICBbdzIsIGgyXSxcbiAgICAgICAgWy13MiwgaDJdXG4gICAgXTtcblxuICAgIGxldCB0ZXhjb29yZHM7XG4gICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XG4gICAgICAgIHRleGNvb3JkX25vcm1hbGl6ZSA9IHRleGNvb3JkX25vcm1hbGl6ZSB8fCAxO1xuXG4gICAgICAgIGxldCBbW21pbl91LCBtaW5fdl0sIFttYXhfdSwgbWF4X3ZdXSA9IHRleGNvb3JkX3NjYWxlIHx8IFtbMCwgMF0sIFsxLCAxXV07XG4gICAgICAgIHRleGNvb3JkcyA9IFtcbiAgICAgICAgICAgIFttaW5fdSwgbWluX3ZdLFxuICAgICAgICAgICAgW21heF91LCBtaW5fdl0sXG4gICAgICAgICAgICBbbWF4X3UsIG1heF92XSxcblxuICAgICAgICAgICAgW21pbl91LCBtaW5fdl0sXG4gICAgICAgICAgICBbbWF4X3UsIG1heF92XSxcbiAgICAgICAgICAgIFttaW5fdSwgbWF4X3ZdXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgbGV0IG51bV9wb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgIGZvciAobGV0IHA9MDsgcCA8IG51bV9wb2ludHM7IHArKykge1xuICAgICAgICBsZXQgcG9pbnQgPSBwb2ludHNbcF07XG5cbiAgICAgICAgZm9yIChsZXQgcG9zPTA7IHBvcyA8IDY7IHBvcysrKSB7XG4gICAgICAgICAgICAvLyBBZGQgdGV4Y29vcmRzXG4gICAgICAgICAgICBpZiAodGV4Y29vcmRfaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAwXSA9IHRleGNvb3Jkc1twb3NdWzBdICogdGV4Y29vcmRfbm9ybWFsaXplO1xuICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVt0ZXhjb29yZF9pbmRleCArIDFdID0gdGV4Y29vcmRzW3Bvc11bMV0gKiB0ZXhjb29yZF9ub3JtYWxpemU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtwb3NpdGlvbl9pbmRleCArIDBdID0gcG9pbnRbMF07XG4gICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbcG9zaXRpb25faW5kZXggKyAxXSA9IHBvaW50WzFdO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbc2hhcGVfaW5kZXggKyAwXSA9IHNjYWxpbmdbcG9zXVswXTtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtzaGFwZV9pbmRleCArIDFdID0gc2NhbGluZ1twb3NdWzFdO1xuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3NoYXBlX2luZGV4ICsgMl0gPSBhbmdsZTtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtzaGFwZV9pbmRleCArIDNdID0gcXVhZF9zY2FsZTtcblxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW29mZnNldF9pbmRleCArIDBdID0gb2Zmc2V0WzBdO1xuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW29mZnNldF9pbmRleCArIDFdID0gb2Zmc2V0WzFdO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhfZGF0YS5hZGRWZXJ0ZXgodmVydGV4X3RlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLyogVXRpbGl0eSBmdW5jdGlvbnMgKi9cblxuLy8gVHJpYW5ndWxhdGlvbiB1c2luZyBlYXJjdXRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvZWFyY3V0XG5CdWlsZGVycy50cmlhbmd1bGF0ZVBvbHlnb24gPSBmdW5jdGlvbiAoY29udG91cnMpXG57XG4gICAgcmV0dXJuIGVhcmN1dChjb250b3Vycyk7XG59O1xuXG4vLyBUZXN0cyBpZiBhIGxpbmUgc2VnbWVudCAoZnJvbSBwb2ludCBBIHRvIEIpIGlzIG5lYXJseSBjb2luY2lkZW50IHdpdGggdGhlIGVkZ2Ugb2YgYSB0aWxlXG5CdWlsZGVycy5pc09uVGlsZUVkZ2UgPSBmdW5jdGlvbiAocGEsIHBiLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgdG9sZXJhbmNlX2Z1bmN0aW9uID0gb3B0aW9ucy50b2xlcmFuY2VfZnVuY3Rpb24gfHwgQnVpbGRlcnMudmFsdWVzV2l0aGluVG9sZXJhbmNlO1xuICAgIHZhciB0b2xlcmFuY2UgPSBvcHRpb25zLnRvbGVyYW5jZSB8fCAxO1xuICAgIHZhciB0aWxlX21pbiA9IEJ1aWxkZXJzLnRpbGVfYm91bmRzWzBdO1xuICAgIHZhciB0aWxlX21heCA9IEJ1aWxkZXJzLnRpbGVfYm91bmRzWzFdO1xuICAgIHZhciBlZGdlID0gbnVsbDtcblxuICAgIGlmICh0b2xlcmFuY2VfZnVuY3Rpb24ocGFbMF0sIHRpbGVfbWluLngsIHRvbGVyYW5jZSkgJiYgdG9sZXJhbmNlX2Z1bmN0aW9uKHBiWzBdLCB0aWxlX21pbi54LCB0b2xlcmFuY2UpKSB7XG4gICAgICAgIGVkZ2UgPSAnbGVmdCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRvbGVyYW5jZV9mdW5jdGlvbihwYVswXSwgdGlsZV9tYXgueCwgdG9sZXJhbmNlKSAmJiB0b2xlcmFuY2VfZnVuY3Rpb24ocGJbMF0sIHRpbGVfbWF4LngsIHRvbGVyYW5jZSkpIHtcbiAgICAgICAgZWRnZSA9ICdyaWdodCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRvbGVyYW5jZV9mdW5jdGlvbihwYVsxXSwgdGlsZV9taW4ueSwgdG9sZXJhbmNlKSAmJiB0b2xlcmFuY2VfZnVuY3Rpb24ocGJbMV0sIHRpbGVfbWluLnksIHRvbGVyYW5jZSkpIHtcbiAgICAgICAgZWRnZSA9ICd0b3AnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0b2xlcmFuY2VfZnVuY3Rpb24ocGFbMV0sIHRpbGVfbWF4LnksIHRvbGVyYW5jZSkgJiYgdG9sZXJhbmNlX2Z1bmN0aW9uKHBiWzFdLCB0aWxlX21heC55LCB0b2xlcmFuY2UpKSB7XG4gICAgICAgIGVkZ2UgPSAnYm90dG9tJztcbiAgICB9XG4gICAgcmV0dXJuIGVkZ2U7XG59O1xuXG5CdWlsZGVycy52YWx1ZXNXaXRoaW5Ub2xlcmFuY2UgPSBmdW5jdGlvbiAoYSwgYiwgdG9sZXJhbmNlKSB7XG4gICAgdG9sZXJhbmNlID0gdG9sZXJhbmNlIHx8IDE7XG4gICAgcmV0dXJuIChNYXRoLmFicyhhIC0gYikgPCB0b2xlcmFuY2UpO1xufTtcbiIsIi8vIExpbmUgcmVuZGVyaW5nIHN0eWxlXG5cbmltcG9ydCB7U3R5bGV9IGZyb20gJy4uL3N0eWxlJztcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4uL3N0eWxlX3BhcnNlcic7XG5pbXBvcnQge1N0eWxlTWFuYWdlcn0gZnJvbSAnLi4vc3R5bGVfbWFuYWdlcic7XG5pbXBvcnQgZ2wgZnJvbSAnLi4vLi4vZ2wvY29uc3RhbnRzJzsgLy8gd2ViIHdvcmtlcnMgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gR0wgY29udGV4dCwgc28gaW1wb3J0IGFsbCBHTCBjb25zdGFudHNcbmltcG9ydCBWZXJ0ZXhMYXlvdXQgZnJvbSAnLi4vLi4vZ2wvdmVydGV4X2xheW91dCc7XG5pbXBvcnQgQnVpbGRlcnMgZnJvbSAnLi4vYnVpbGRlcnMnO1xuaW1wb3J0IEdlbyBmcm9tICcuLi8uLi9nZW8nO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcblxuZXhwb3J0IHZhciBMaW5lcyA9IE9iamVjdC5jcmVhdGUoU3R5bGUpO1xuXG5PYmplY3QuYXNzaWduKExpbmVzLCB7XG4gICAgbmFtZTogJ2xpbmVzJyxcbiAgICBidWlsdF9pbjogdHJ1ZSxcbiAgICB2ZXJ0ZXhfc2hhZGVyX2tleTogJ3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29uc192ZXJ0ZXgnLCAvLyByZS11c2UgcG9seWdvbiBzaGFkZXJzXG4gICAgZnJhZ21lbnRfc2hhZGVyX2tleTogJ3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29uc19mcmFnbWVudCcsXG4gICAgc2VsZWN0aW9uOiB0cnVlLCAvLyB0dXJuIGZlYXR1cmUgc2VsZWN0aW9uIG9uXG5cbiAgICBpbml0KCkge1xuICAgICAgICBTdHlsZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gQmFzaWMgYXR0cmlidXRlcywgb3RoZXJzIGNhbiBiZSBhZGRlZCAoc2VlIHRleHR1cmUgVVZzIGJlbG93KVxuICAgICAgICB2YXIgYXR0cmlicyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfcG9zaXRpb24nLCBzaXplOiA0LCB0eXBlOiBnbC5TSE9SVCwgbm9ybWFsaXplZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYV9leHRydWRlJywgc2l6ZTogNCwgdHlwZTogZ2wuU0hPUlQsIG5vcm1hbGl6ZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfY29sb3InLCBzaXplOiA0LCB0eXBlOiBnbC5VTlNJR05FRF9CWVRFLCBub3JtYWxpemVkOiB0cnVlIH1cbiAgICAgICAgXTtcblxuICAgICAgICAvLyBUZWxsIHRoZSBzaGFkZXIgd2Ugd2FudCBhIG9yZGVyIGluIHZlcnRleCBhdHRyaWJ1dGVzLCBhbmQgdG8gZXh0cnVkZSBsaW5lc1xuICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9MQVlFUl9PUkRFUiA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5UQU5HUkFNX0VYVFJVREVfTElORVMgPSB0cnVlO1xuXG4gICAgICAgIC8vIE9wdGlvbmFsIGZlYXR1cmUgc2VsZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgYXR0cmlicy5wdXNoKHsgbmFtZTogJ2Ffc2VsZWN0aW9uX2NvbG9yJywgc2l6ZTogNCwgdHlwZTogZ2wuVU5TSUdORURfQllURSwgbm9ybWFsaXplZDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9wdGlvbmFsIHRleHR1cmUgVVZzXG4gICAgICAgIGlmICh0aGlzLnRleGNvb3Jkcykge1xuICAgICAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fVEVYVFVSRV9DT09SRFMgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBBZGQgdmVydGV4IGF0dHJpYnV0ZSBmb3IgVVZzIG9ubHkgd2hlbiBuZWVkZWRcbiAgICAgICAgICAgIGF0dHJpYnMucHVzaCh7IG5hbWU6ICdhX3RleGNvb3JkJywgc2l6ZTogMiwgdHlwZTogZ2wuVU5TSUdORURfU0hPUlQsIG5vcm1hbGl6ZWQ6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZlcnRleF9sYXlvdXQgPSBuZXcgVmVydGV4TGF5b3V0KGF0dHJpYnMpO1xuICAgIH0sXG5cbiAgICAvLyBDYWxjdWxhdGUgd2lkdGggYXQgem9vbSBnaXZlbiBpbiBgY29udGV4dGBcbiAgICBjYWxjV2lkdGggKHdpZHRoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAod2lkdGggJiYgU3R5bGVQYXJzZXIuY2FjaGVEaXN0YW5jZSh3aWR0aCwgY29udGV4dCkpIHx8IDA7XG4gICAgfSxcblxuICAgIC8vIENhbGN1bGF0ZSB3aWR0aCBhdCBuZXh0IHpvb20gKHVzZWQgZm9yIGxpbmUgd2lkdGggaW50ZXJwb2xhdGlvbilcbiAgICBjYWxjV2lkdGhOZXh0Wm9vbSAod2lkdGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC56b29tKys7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzLmNhbGNXaWR0aCh3aWR0aCwgY29udGV4dCk7XG4gICAgICAgIGNvbnRleHQuem9vbS0tO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICBfcGFyc2VGZWF0dXJlIChmZWF0dXJlLCBydWxlX3N0eWxlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZmVhdHVyZV9zdHlsZTtcblxuICAgICAgICAvLyBsaW5lIHdpZHRoIGluIG1ldGVyc1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLmNhbGNXaWR0aChydWxlX3N0eWxlLndpZHRoLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBza2lwIGxpbmVzIHdpdGggbmVnYXRpdmUgd2lkdGhcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dF93aWR0aCA9IHRoaXMuY2FsY1dpZHRoTmV4dFpvb20ocnVsZV9zdHlsZS5uZXh0X3dpZHRoLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAoKHdpZHRoID09PSAwICYmIG5leHRfd2lkdGggPT09IDApIHx8IG5leHRfd2lkdGggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIHNraXAgbGluZXMgdGhhdCBkb24ndCBpbnRlcnBvbGF0ZSB0byBhIHBvc2l0aXZlIHZhbHVlIGF0IG5leHQgem9vbVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29udmVydCB0byB1bml0cyBhbmQgcmVsYXRpdmUgY2hhbmdlIGZyb20gcHJldmlvdXMgem9vbVxuICAgICAgICAvLyBOQjogbXVsdGlwbHkgYnkgMiBiZWNhdXNlIGEgZ2l2ZW4gd2lkdGggaXMgdHdpY2UgYXMgYmlnIGluIHNjcmVlbiBzcGFjZSBhdCB0aGUgbmV4dCB6b29tXG4gICAgICAgIHN0eWxlLndpZHRoID0gd2lkdGggKiBjb250ZXh0LnVuaXRzX3Blcl9tZXRlcjtcbiAgICAgICAgc3R5bGUubmV4dF93aWR0aCA9IChuZXh0X3dpZHRoICogMikgLSB3aWR0aDtcbiAgICAgICAgc3R5bGUubmV4dF93aWR0aCAqPSBjb250ZXh0LnVuaXRzX3Blcl9tZXRlcjtcbiAgICAgICAgc3R5bGUubmV4dF93aWR0aCAvPSAyOyAvLyBOQjogZGl2aWRlIGJ5IDIgYmVjYXVzZSBleHRydXNpb24gd2lkdGggaXMgaGFsdmVkIGluIGJ1aWxkZXIgLSByZW1vdmU/XG5cbiAgICAgICAgc3R5bGUuY29sb3IgPSB0aGlzLnBhcnNlQ29sb3IocnVsZV9zdHlsZS5jb2xvciwgY29udGV4dCk7XG4gICAgICAgIGlmICghc3R5bGUuY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhlaWdodCBkZWZhdWx0cyB0byBmZWF0dXJlIGhlaWdodCwgYnV0IGV4dHJ1ZGUgc3R5bGUgY2FuIGR5bmFtaWNhbGx5IGFkanVzdCBoZWlnaHQgYnkgcmV0dXJuaW5nIGEgbnVtYmVyIG9yIGFycmF5IChpbnN0ZWFkIG9mIGEgYm9vbGVhbilcbiAgICAgICAgc3R5bGUueiA9IChydWxlX3N0eWxlLnogJiYgU3R5bGVQYXJzZXIuY2FjaGVEaXN0YW5jZShydWxlX3N0eWxlLnogfHwgMCwgY29udGV4dCkpIHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLno7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9IGZlYXR1cmUucHJvcGVydGllcy5oZWlnaHQgfHwgU3R5bGVQYXJzZXIuZGVmYXVsdHMuaGVpZ2h0O1xuICAgICAgICBzdHlsZS5leHRydWRlID0gcnVsZV9zdHlsZS5leHRydWRlO1xuICAgICAgICBpZiAoc3R5bGUuZXh0cnVkZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZS5leHRydWRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuZXh0cnVkZSA9IHN0eWxlLmV4dHJ1ZGUoY29udGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGUuZXh0cnVkZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBzdHlsZS5leHRydWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzdHlsZS5leHRydWRlKSkge1xuICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IHN0eWxlLmV4dHJ1ZGVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSYWlzZSBsaW5lIGhlaWdodCBpZiBleHRydWRlZFxuICAgICAgICBpZiAoc3R5bGUuZXh0cnVkZSAmJiBzdHlsZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHN0eWxlLnogKz0gc3R5bGUuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGUuY2FwID0gcnVsZV9zdHlsZS5jYXA7XG4gICAgICAgIHN0eWxlLmpvaW4gPSBydWxlX3N0eWxlLmpvaW47XG4gICAgICAgIHN0eWxlLnRpbGVfZWRnZXMgPSBydWxlX3N0eWxlLnRpbGVfZWRnZXM7IC8vIHVzdWFsbHkgYWN0aXZhdGVkIGZvciBkZWJ1Z2dpbmcsIG9yIHJhcmUgdmlzdWFsaXphdGlvbiBuZWVkc1xuXG4gICAgICAgIC8vIENvbnN0cnVjdCBhbiBvdXRsaW5lIHN0eWxlXG4gICAgICAgIHN0eWxlLm91dGxpbmUgPSBzdHlsZS5vdXRsaW5lIHx8IHt9O1xuICAgICAgICBpZiAocnVsZV9zdHlsZS5vdXRsaW5lICYmIHJ1bGVfc3R5bGUub3V0bGluZS5jb2xvciAmJiBydWxlX3N0eWxlLm91dGxpbmUud2lkdGgpIHtcbiAgICAgICAgICAgIC8vIG91dGxpbmUgd2lkdGggaW4gbWV0ZXJzXG4gICAgICAgICAgICAvLyBOQjogbXVsdGlwbHkgYnkgMiBiZWNhdXNlIG91dGxpbmUgaXMgYXBwbGllZCBvbiBib3RoIHNpZGVzIG9mIGxpbmVcbiAgICAgICAgICAgIGxldCBvdXRsaW5lX3dpZHRoID0gdGhpcy5jYWxjV2lkdGgocnVsZV9zdHlsZS5vdXRsaW5lLndpZHRoLCBjb250ZXh0KSAqIDI7XG4gICAgICAgICAgICBsZXQgb3V0bGluZV9uZXh0X3dpZHRoID0gdGhpcy5jYWxjV2lkdGhOZXh0Wm9vbShydWxlX3N0eWxlLm91dGxpbmUubmV4dF93aWR0aCwgY29udGV4dCkgKiAyO1xuXG4gICAgICAgICAgICAvLyBNYWludGFpbiBjb25zaXN0ZW50IG91dGxpbmUgd2lkdGggYXJvdW5kIHRoZSBsaW5lIGZpbGxcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUud2lkdGggPSB7IHZhbHVlOiBvdXRsaW5lX3dpZHRoICsgd2lkdGggfTtcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUubmV4dF93aWR0aCA9IHsgdmFsdWU6IG91dGxpbmVfbmV4dF93aWR0aCArIG5leHRfd2lkdGggfTtcblxuICAgICAgICAgICAgc3R5bGUub3V0bGluZS5jb2xvciA9IHJ1bGVfc3R5bGUub3V0bGluZS5jb2xvcjtcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUuY2FwID0gcnVsZV9zdHlsZS5vdXRsaW5lLmNhcCB8fCBydWxlX3N0eWxlLmNhcDtcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUuam9pbiA9IHJ1bGVfc3R5bGUub3V0bGluZS5qb2luIHx8IHJ1bGVfc3R5bGUuam9pbjtcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUuc3R5bGUgPSBydWxlX3N0eWxlLm91dGxpbmUuc3R5bGUgfHwgdGhpcy5uYW1lO1xuXG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IGRlZmluZWQgb3V0bGluZSBvcmRlciwgb3IgaW5oZXJpdGVkIGZyb20gaW5uZXIgbGluZVxuICAgICAgICAgICAgaWYgKHJ1bGVfc3R5bGUub3V0bGluZS5vcmRlcikge1xuICAgICAgICAgICAgICAgIHN0eWxlLm91dGxpbmUub3JkZXIgPSB0aGlzLnBhcnNlT3JkZXIocnVsZV9zdHlsZS5vdXRsaW5lLm9yZGVyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlLm91dGxpbmUub3JkZXIgPSBzdHlsZS5vcmRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRG9uJ3QgbGV0IG91dGxpbmUgYmUgYWJvdmUgaW5uZXIgbGluZVxuICAgICAgICAgICAgaWYgKHN0eWxlLm91dGxpbmUub3JkZXIgPiBzdHlsZS5vcmRlcikge1xuICAgICAgICAgICAgICAgIHN0eWxlLm91dGxpbmUub3JkZXIgPSBzdHlsZS5vcmRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3V0bGluZXMgYXJlIGFsd2F5cyBhdCBoYWxmLWxheWVyIGludGVydmFscyB0byBhdm9pZCBjb25mbGljdGluZyB3aXRoIGlubmVyIGxpbmVzXG4gICAgICAgICAgICBzdHlsZS5vdXRsaW5lLm9yZGVyIC09IDAuNTtcblxuICAgICAgICAgICAgc3R5bGUub3V0bGluZS5wcmVwcm9jZXNzZWQgPSB0cnVlOyAvLyBzaWduYWwgdGhhdCB3ZSd2ZSBhbHJlYWR5IHdyYXBwZWQgcHJvcGVydGllcyBpbiBjYWNoZSBvYmplY3RzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5vdXRsaW5lLndpZHRoID0gbnVsbDtcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUuY29sb3IgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBfcHJlcHJvY2VzcyAoZHJhdykge1xuICAgICAgICBkcmF3LmNvbG9yID0gU3R5bGVQYXJzZXIuY2FjaGVPYmplY3QoZHJhdy5jb2xvcik7XG4gICAgICAgIGRyYXcud2lkdGggPSBTdHlsZVBhcnNlci5jYWNoZU9iamVjdChkcmF3LndpZHRoKTtcbiAgICAgICAgZHJhdy5uZXh0X3dpZHRoID0gU3R5bGVQYXJzZXIuY2FjaGVPYmplY3QoZHJhdy53aWR0aCk7IC8vIHdpZHRoIHdpbGwgYmUgY29tcHV0ZWQgZm9yIG5leHQgem9vbVxuICAgICAgICBkcmF3LnogPSBTdHlsZVBhcnNlci5jYWNoZU9iamVjdChkcmF3LnopO1xuXG4gICAgICAgIGlmIChkcmF3Lm91dGxpbmUpIHtcbiAgICAgICAgICAgIGRyYXcub3V0bGluZS5jb2xvciA9IFN0eWxlUGFyc2VyLmNhY2hlT2JqZWN0KGRyYXcub3V0bGluZS5jb2xvcik7XG4gICAgICAgICAgICBkcmF3Lm91dGxpbmUud2lkdGggPSBTdHlsZVBhcnNlci5jYWNoZU9iamVjdChkcmF3Lm91dGxpbmUud2lkdGgpO1xuICAgICAgICAgICAgZHJhdy5vdXRsaW5lLm5leHRfd2lkdGggPSBTdHlsZVBhcnNlci5jYWNoZU9iamVjdChkcmF3Lm91dGxpbmUud2lkdGgpOyAvLyB3aWR0aCByZS1jb21wdXRlZCBmb3IgbmV4dCB6b29tXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgXCJ0ZW1wbGF0ZVwiIHRoYXQgc2V0cyBjb25zdGFudCBhdHRpYnV0ZXMgZm9yIGVhY2ggdmVydGV4LCB3aGljaCBpcyB0aGVuIG1vZGlmaWVkIHBlciB2ZXJ0ZXggb3IgcGVyIGZlYXR1cmUuXG4gICAgICogQSBwbGFpbiBKUyBhcnJheSBtYXRjaGluZyB0aGUgb3JkZXIgb2YgdGhlIHZlcnRleCBsYXlvdXQuXG4gICAgICovXG4gICAgbWFrZVZlcnRleFRlbXBsYXRlKHN0eWxlKSB7XG4gICAgICAgIGxldCBpID0gMDtcblxuICAgICAgICAvLyBwb3NpdGlvbiAtIHggJiB5IGNvb3JkcyB3aWxsIGJlIGZpbGxlZCBpbiBwZXItdmVydGV4IGJlbG93XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gMDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLnogfHwgMDtcblxuICAgICAgICAvLyBsYXllciBvcmRlciAtIHcgY29vcmQgb2YgJ3Bvc2l0aW9uJyBhdHRyaWJ1dGUgKGZvciBwYWNraW5nIGVmZmljaWVuY3kpXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5vcmRlcjtcblxuICAgICAgICAvLyBleHRydXNpb24gdmVjdG9yXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gMDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IDA7XG5cbiAgICAgICAgLy8gc2NhbGluZyB0byBwcmV2aW91cyBhbmQgbmV4dCB6b29tXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5uZXh0X3dpZHRoO1xuXG4gICAgICAgIC8vIGNvbG9yXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5jb2xvclswXSAqIDI1NTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLmNvbG9yWzFdICogMjU1O1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUuY29sb3JbMl0gKiAyNTU7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5jb2xvclszXSAqIDI1NTtcblxuICAgICAgICAvLyBzZWxlY3Rpb24gY29sb3JcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzBdICogMjU1O1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLnNlbGVjdGlvbl9jb2xvclsxXSAqIDI1NTtcbiAgICAgICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5zZWxlY3Rpb25fY29sb3JbMl0gKiAyNTU7XG4gICAgICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzNdICogMjU1O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRleHR1cmUgVVZzIHRvIHRlbXBsYXRlIG9ubHkgaWYgbmVlZGVkXG4gICAgICAgIGlmICh0aGlzLnRleGNvb3Jkcykge1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IDA7XG4gICAgICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRleF90ZW1wbGF0ZTtcbiAgICB9LFxuXG4gICAgYnVpbGRMaW5lcyhsaW5lcywgc3R5bGUsIHZlcnRleF9kYXRhLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB2ZXJ0ZXhfdGVtcGxhdGUgPSB0aGlzLm1ha2VWZXJ0ZXhUZW1wbGF0ZShzdHlsZSk7XG5cbiAgICAgICAgLy8gTWFpbiBsaW5lXG4gICAgICAgIEJ1aWxkZXJzLmJ1aWxkUG9seWxpbmVzKFxuICAgICAgICAgICAgbGluZXMsXG4gICAgICAgICAgICBzdHlsZS53aWR0aCxcbiAgICAgICAgICAgIHZlcnRleF9kYXRhLFxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNhcDogc3R5bGUuY2FwLFxuICAgICAgICAgICAgICAgIGpvaW46IHN0eWxlLmpvaW4sXG4gICAgICAgICAgICAgICAgc2NhbGluZ19pbmRleDogdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfZXh0cnVkZSxcbiAgICAgICAgICAgICAgICBzY2FsaW5nX25vcm1hbGl6ZTogVXRpbHMuc2NhbGVJbnQxNigxLCAyNTYpLCAvLyBzY2FsZSBleHRydXNpb24gbm9ybWFscyB0byBzaWduZWQgc2hvcnRzIHcvMjU2IHVuaXQgYmFzaXNcbiAgICAgICAgICAgICAgICB0ZXhjb29yZF9pbmRleDogdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfdGV4Y29vcmQsXG4gICAgICAgICAgICAgICAgdGV4Y29vcmRfc2NhbGU6IHRoaXMudGV4Y29vcmRfc2NhbGUsXG4gICAgICAgICAgICAgICAgdGV4Y29vcmRfbm9ybWFsaXplOiA2NTUzNSwgLy8gc2NhbGUgVVZzIHRvIHVuc2lnbmVkIHNob3J0c1xuICAgICAgICAgICAgICAgIGNsb3NlZF9wb2x5Z29uOiBvcHRpb25zICYmIG9wdGlvbnMuY2xvc2VkX3BvbHlnb24sXG4gICAgICAgICAgICAgICAgcmVtb3ZlX3RpbGVfZWRnZXM6ICFzdHlsZS50aWxlX2VkZ2VzICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5yZW1vdmVfdGlsZV9lZGdlcyxcbiAgICAgICAgICAgICAgICB0aWxlX2VkZ2VfdG9sZXJhbmNlOiBHZW8udGlsZV9zY2FsZSAqIGNvbnRleHQudGlsZS5wYWRfc2NhbGUgKiA0XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gT3V0bGluZVxuICAgICAgICAgaWYgKHN0eWxlLm91dGxpbmUgJiYgc3R5bGUub3V0bGluZS5jb2xvciAhPSBudWxsICYmIHN0eWxlLm91dGxpbmUud2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG91dGxpbmVfc3R5bGUgPSBTdHlsZU1hbmFnZXIuc3R5bGVzW3N0eWxlLm91dGxpbmUuc3R5bGVdO1xuICAgICAgICAgICAgaWYgKG91dGxpbmVfc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBvdXRsaW5lX3N0eWxlLmFkZEZlYXR1cmUoY29udGV4dC5mZWF0dXJlLCBzdHlsZS5vdXRsaW5lLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBidWlsZFBvbHlnb25zKHBvbHlnb25zLCBzdHlsZSwgdmVydGV4X2RhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gUmVuZGVyIHBvbHlnb25zIGFzIGluZGl2aWR1YWwgbGluZXNcbiAgICAgICAgZm9yIChsZXQgcD0wOyBwIDwgcG9seWdvbnMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRMaW5lcyhwb2x5Z29uc1twXSwgc3R5bGUsIHZlcnRleF9kYXRhLCBjb250ZXh0LCB7IGNsb3NlZF9wb2x5Z29uOiB0cnVlLCByZW1vdmVfdGlsZV9lZGdlczogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG4iLCIvLyBTZXRzIG9mIHZhbHVlcyB0byBtYXRjaCBmb3IgZGlyZWN0aW9uYWwgYW5kIGNvcm5lciBhbmNob3JzXG5jb25zdCBsZWZ0cyA9IFsnbGVmdCcsICd0b3AtbGVmdCcsICdib3R0b20tbGVmdCddO1xuY29uc3QgcmlnaHRzID0gWydyaWdodCcsICd0b3AtcmlnaHQnLCAnYm90dG9tLXJpZ2h0J107XG5jb25zdCB0b3BzID0gWyd0b3AnLCAndG9wLWxlZnQnLCAndG9wLXJpZ2h0J107XG5jb25zdCBib3R0b21zID0gWydib3R0b20nLCAnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0J107XG5cbnZhciBQb2ludEFuY2hvcjtcblxuZXhwb3J0IGRlZmF1bHQgUG9pbnRBbmNob3IgPSB7XG5cbiAgICBjb21wdXRlT2Zmc2V0IChvZmZzZXQsIHNpemUsIGFuY2hvcikge1xuICAgICAgICBpZiAoIWFuY2hvciB8fCBhbmNob3IgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9mZnNldDIgPSBbb2Zmc2V0WzBdLCBvZmZzZXRbMV1dO1xuXG4gICAgICAgIC8vIEFuIG9wdGlvbmFsIGxlZnQvcmlnaHQgb2Zmc2V0XG4gICAgICAgIGlmICh0aGlzLmlzTGVmdEFuY2hvcihhbmNob3IpKSB7XG4gICAgICAgICAgICBvZmZzZXQyWzBdIC09IHNpemVbMF0gLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNSaWdodEFuY2hvcihhbmNob3IpKSB7XG4gICAgICAgICAgICBvZmZzZXQyWzBdICs9IHNpemVbMF0gLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW4gb3B0aW9uYWwgdG9wL2JvdHRvbSBvZmZzZXRcbiAgICAgICAgaWYgKHRoaXMuaXNUb3BBbmNob3IoYW5jaG9yKSkge1xuICAgICAgICAgICAgb2Zmc2V0MlsxXSAtPSBzaXplWzFdIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzQm90dG9tQW5jaG9yKGFuY2hvcikpIHtcbiAgICAgICAgICAgIG9mZnNldDJbMV0gKz0gc2l6ZVsxXSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2Zmc2V0MjtcbiAgICB9LFxuXG4gICAgaXNMZWZ0QW5jaG9yIChhbmNob3IpIHtcbiAgICAgICAgcmV0dXJuIChsZWZ0cy5pbmRleE9mKGFuY2hvcikgPiAtMSk7XG4gICAgfSxcblxuICAgIGlzUmlnaHRBbmNob3IgKGFuY2hvcikge1xuICAgICAgICByZXR1cm4gKHJpZ2h0cy5pbmRleE9mKGFuY2hvcikgPiAtMSk7XG4gICAgfSxcblxuICAgIGlzVG9wQW5jaG9yIChhbmNob3IpIHtcbiAgICAgICAgcmV0dXJuICh0b3BzLmluZGV4T2YoYW5jaG9yKSA+IC0xKTtcbiAgICB9LFxuXG4gICAgaXNCb3R0b21BbmNob3IgKGFuY2hvcikge1xuICAgICAgICByZXR1cm4gKGJvdHRvbXMuaW5kZXhPZihhbmNob3IpID4gLTEpO1xuICAgIH1cblxufTtcbiIsIi8vIFBvaW50IHJlbmRlcmluZyBzdHlsZVxuXG5pbXBvcnQge1N0eWxlfSBmcm9tICcuLi9zdHlsZSc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuLi9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IGdsIGZyb20gJy4uLy4uL2dsL2NvbnN0YW50cyc7IC8vIHdlYiB3b3JrZXJzIGRvbid0IGhhdmUgYWNjZXNzIHRvIEdMIGNvbnRleHQsIHNvIGltcG9ydCBhbGwgR0wgY29uc3RhbnRzXG5pbXBvcnQgVmVydGV4TGF5b3V0IGZyb20gJy4uLy4uL2dsL3ZlcnRleF9sYXlvdXQnO1xuaW1wb3J0IEJ1aWxkZXJzIGZyb20gJy4uL2J1aWxkZXJzJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4uLy4uL2dsL3RleHR1cmUnO1xuaW1wb3J0IEdlbyBmcm9tICcuLi8uLi9nZW8nO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vLi4vdmVjdG9yJztcbmltcG9ydCBQb2ludEFuY2hvciBmcm9tICcuL3BvaW50X2FuY2hvcic7XG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5leHBvcnQgdmFyIFBvaW50cyA9IE9iamVjdC5jcmVhdGUoU3R5bGUpO1xuXG5PYmplY3QuYXNzaWduKFBvaW50cywge1xuICAgIG5hbWU6ICdwb2ludHMnLFxuICAgIGJ1aWx0X2luOiB0cnVlLFxuICAgIHNlbGVjdGlvbjogdHJ1ZSwgLy8gdHVybiBmZWF0dXJlIHNlbGVjdGlvbiBvblxuICAgIGJsZW5kOiAnb3ZlcmxheScsIC8vIG92ZXJsYXlzIGRyYXduIG9uIHRvcCBvZiBhbGwgb3RoZXIgc3R5bGVzLCB3aXRoIGJsZW5kaW5nXG5cbiAgICBpbml0KG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBTdHlsZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gQmFzZSBzaGFkZXJzXG4gICAgICAgIHRoaXMudmVydGV4X3NoYWRlcl9rZXkgPSAnc3R5bGVzL3BvaW50cy9wb2ludHNfdmVydGV4JztcbiAgICAgICAgdGhpcy5mcmFnbWVudF9zaGFkZXJfa2V5ID0gJ3N0eWxlcy9wb2ludHMvcG9pbnRzX2ZyYWdtZW50JztcblxuICAgICAgICB2YXIgYXR0cmlicyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfcG9zaXRpb24nLCBzaXplOiA0LCB0eXBlOiBnbC5TSE9SVCwgbm9ybWFsaXplZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYV9zaGFwZScsIHNpemU6IDQsIHR5cGU6IGdsLlNIT1JULCBub3JtYWxpemVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3RleGNvb3JkJywgc2l6ZTogMiwgdHlwZTogZ2wuVU5TSUdORURfU0hPUlQsIG5vcm1hbGl6ZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2Ffb2Zmc2V0Jywgc2l6ZTogMiwgdHlwZTogZ2wuU0hPUlQsIG5vcm1hbGl6ZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfY29sb3InLCBzaXplOiA0LCB0eXBlOiBnbC5VTlNJR05FRF9CWVRFLCBub3JtYWxpemVkOiB0cnVlIH1cbiAgICAgICAgXTtcblxuICAgICAgICAvLyBPcHRpb25hbCBmZWF0dXJlIHNlbGVjdGlvblxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGF0dHJpYnMucHVzaCh7IG5hbWU6ICdhX3NlbGVjdGlvbl9jb2xvcicsIHNpemU6IDQsIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEUsIG5vcm1hbGl6ZWQ6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSdyZSBub3QgcmVuZGVyaW5nIGFzIG92ZXJsYXksIHdlIG5lZWQgYSBsYXllciBhdHRyaWJ1dGVcbiAgICAgICAgaWYgKHRoaXMuYmxlbmQgIT09ICdvdmVybGF5Jykge1xuICAgICAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fTEFZRVJfT1JERVIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0ID0gbmV3IFZlcnRleExheW91dChhdHRyaWJzKTtcblxuICAgICAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9QT0lOVF9URVhUVVJFID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2hhZGVycy51bmlmb3JtcyA9IHRoaXMuc2hhZGVycy51bmlmb3JtcyB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMuc2hhZGVycy51bmlmb3Jtcy51X3RleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3BhcnNlRmVhdHVyZSAoZmVhdHVyZSwgcnVsZV9zdHlsZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmZlYXR1cmVfc3R5bGU7XG4gICAgICAgIGxldCB0aWxlID0gY29udGV4dC50aWxlLmtleTtcblxuICAgICAgICBzdHlsZS5jb2xvciA9IHRoaXMucGFyc2VDb2xvcihydWxlX3N0eWxlLmNvbG9yLCBjb250ZXh0KTtcblxuICAgICAgICAvLyByZXF1aXJlIGNvbG9yIG9yIHRleHR1cmVcbiAgICAgICAgaWYgKCFzdHlsZS5jb2xvciAmJiAhdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzcHJpdGUgPSBzdHlsZS5zcHJpdGUgPSBydWxlX3N0eWxlLnNwcml0ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzcHJpdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNwcml0ZSA9IHNwcml0ZShjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS5zcHJpdGVfZGVmYXVsdCA9IHJ1bGVfc3R5bGUuc3ByaXRlX2RlZmF1bHQ7IC8vIG9wdGlvbmFsIGZhbGxiYWNrIGlmICdzcHJpdGUnIG5vdCBmb3VuZFxuXG4gICAgICAgIC8vIGlmIHBvaW50IGhhcyB0ZXh0dXJlIGFuZCBzcHJpdGVzLCByZXF1aXJlIGEgdmFsaWQgc3ByaXRlIHRvIGRyYXdcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSAmJiBUZXh0dXJlLnRleHR1cmVzW3RoaXMudGV4dHVyZV0gJiYgVGV4dHVyZS50ZXh0dXJlc1t0aGlzLnRleHR1cmVdLnNwcml0ZXMpIHtcbiAgICAgICAgICAgIGlmICghc3ByaXRlICYmICFzdHlsZS5zcHJpdGVfZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFUZXh0dXJlLnRleHR1cmVzW3RoaXMudGV4dHVyZV0uc3ByaXRlc1tzcHJpdGVdKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc3ByaXRlIG5vdCBmb3VuZCwgY2hlY2sgZm9yIGRlZmF1bHQgc3ByaXRlXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnNwcml0ZV9kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZSA9IHN0eWxlLnNwcml0ZV9kZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIVRleHR1cmUudGV4dHVyZXNbdGhpcy50ZXh0dXJlXS5zcHJpdGVzW3Nwcml0ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKGBTdHlsZTogaW4gc3R5bGUgJyR7dGhpcy5uYW1lfScsIGNvdWxkIG5vdCBmaW5kIGRlZmF1bHQgc3ByaXRlICcke3Nwcml0ZX0nIGZvciB0ZXh0dXJlICcke3RoaXMudGV4dHVyZX0nYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKGBTdHlsZTogaW4gc3R5bGUgJyR7dGhpcy5uYW1lfScsIGNvdWxkIG5vdCBmaW5kIHNwcml0ZSAnJHtzcHJpdGV9JyBmb3IgdGV4dHVyZSAnJHt0aGlzLnRleHR1cmV9J2ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0cyB0ZXhjb29yZCBzY2FsZSBpZiBuZWVkZWQgKGUuZy4gZm9yIHNwcml0ZSBzdWItYXJlYSlcbiAgICAgICAgbGV0IHNwcml0ZV9pbmZvO1xuICAgICAgICBpZiAodGhpcy50ZXh0dXJlICYmIHNwcml0ZSkge1xuICAgICAgICAgICAgc3ByaXRlX2luZm8gPSBUZXh0dXJlLmdldFNwcml0ZUluZm8odGhpcy50ZXh0dXJlLCBzcHJpdGUpO1xuICAgICAgICAgICAgdGhpcy50ZXhjb29yZF9zY2FsZSA9IHNwcml0ZV9pbmZvLnRleGNvb3JkcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGV4Y29vcmRfc2NhbGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcG9pbnRzIGNhbiBiZSBwbGFjZWQgb2ZmIHRoZSBncm91bmRcbiAgICAgICAgc3R5bGUueiA9IChydWxlX3N0eWxlLnogJiYgU3R5bGVQYXJzZXIuY2FjaGVEaXN0YW5jZShydWxlX3N0eWxlLnosIGNvbnRleHQpKSB8fCBTdHlsZVBhcnNlci5kZWZhdWx0cy56O1xuXG4gICAgICAgIC8vIHBvaW50IHNpemUgZGVmaW5lZCBleHBsaWNpdGx5LCBvciBkZWZhdWx0cyB0byBzcHJpdGUgc2l6ZSwgb3IgZ2VuZXJpYyBmYWxsYmFja1xuICAgICAgICBzdHlsZS5zaXplID0gcnVsZV9zdHlsZS5zaXplO1xuICAgICAgICBpZiAoIXN0eWxlLnNpemUpIHtcbiAgICAgICAgICAgIGlmIChzcHJpdGVfaW5mbykge1xuICAgICAgICAgICAgICAgIHN0eWxlLnNpemUgPSB7IHZhbHVlOiBzcHJpdGVfaW5mby5zaXplIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5zaXplID0geyB2YWx1ZTogWzE2LCAxNl0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBvaW50IHN0eWxlIG9ubHkgc3VwcG9ydHMgc2l6ZXMgaW4gcGl4ZWwgdW5pdHMsIHNvIHVuaXQgY29udmVyc2lvbiBmbGFnIGlzIG9mZlxuICAgICAgICBzdHlsZS5zaXplID0gU3R5bGVQYXJzZXIuY2FjaGVEaXN0YW5jZShzdHlsZS5zaXplLCBjb250ZXh0LCAncGl4ZWxzJyk7XG5cbiAgICAgICAgLy8gc2NhbGUgc2l6ZSB0byAxNi1iaXQgc2lnbmVkIGludCwgd2l0aCBhIG1heCBhbGxvd2VkIHdpZHRoICsgaGVpZ2h0IG9mIDEyOCBwaXhlbHNcbiAgICAgICAgc3R5bGUuc2l6ZSA9IFtcbiAgICAgICAgICAgIE1hdGgubWluKChzdHlsZS5zaXplWzBdIHx8IHN0eWxlLnNpemUpLCAyNTYpLFxuICAgICAgICAgICAgTWF0aC5taW4oKHN0eWxlLnNpemVbMV0gfHwgc3R5bGUuc2l6ZSksIDI1NilcbiAgICAgICAgXTtcblxuICAgICAgICBzdHlsZS5hbmdsZSA9IHJ1bGVfc3R5bGUuYW5nbGUgfHwgMDtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHlsZS5hbmdsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3R5bGUuYW5nbGUgPSBzdHlsZS5hbmdsZShjb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZhY3RvciBieSB3aGljaCBwb2ludCBzY2FsZXMgZnJvbSBjdXJyZW50IHpvb20gbGV2ZWwgdG8gbmV4dCB6b29tIGxldmVsXG4gICAgICAgIHN0eWxlLnNjYWxlID0gcnVsZV9zdHlsZS5zY2FsZSB8fCAxO1xuXG4gICAgICAgIC8vIHRvIHN0b3JlIGJib3ggYnkgdGlsZXNcbiAgICAgICAgc3R5bGUudGlsZSA9IHRpbGU7XG5cbiAgICAgICAgLy8gcG9seWdvbnMgcmVuZGVyaW5nIGFzIHBvaW50cyB3aWxsIHJlbmRlciBlYWNoIGluZGl2aWR1YWwgcG9seWdvbiBwb2ludCBieSBkZWZhdWx0LCBidXRcbiAgICAgICAgLy8gcmVuZGVyaW5nIGEgc2luZ2xlIHBvaW50IGF0IHRoZSBwb2x5Z29uJ3MgY2VudHJvaWQgY2FuIGJlIGVuYWJsZWRcbiAgICAgICAgc3R5bGUuY2VudHJvaWQgPSBydWxlX3N0eWxlLmNlbnRyb2lkO1xuXG4gICAgICAgIC8vIE9mZnNldCBhcHBsaWVkIHRvIHBvaW50IGluIHNjcmVlbiBzcGFjZVxuICAgICAgICBzdHlsZS5vZmZzZXQgPSAoQXJyYXkuaXNBcnJheShydWxlX3N0eWxlLm9mZnNldCkgJiYgcnVsZV9zdHlsZS5vZmZzZXQubWFwKHBhcnNlRmxvYXQpKSB8fCBbMCwgMF07XG5cbiAgICAgICAgLy8gYW5jaG9yXG4gICAgICAgIHN0eWxlLm9mZnNldCA9IFBvaW50QW5jaG9yLmNvbXB1dGVPZmZzZXQoc3R5bGUub2Zmc2V0LCBzdHlsZS5zaXplLCBydWxlX3N0eWxlLmFuY2hvcik7XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBfcHJlcHJvY2VzcyAoZHJhdykge1xuICAgICAgICBkcmF3LmNvbG9yID0gU3R5bGVQYXJzZXIuY2FjaGVPYmplY3QoZHJhdy5jb2xvcik7XG4gICAgICAgIGRyYXcueiA9IFN0eWxlUGFyc2VyLmNhY2hlT2JqZWN0KGRyYXcueik7XG4gICAgICAgIGRyYXcuc2l6ZSA9IFN0eWxlUGFyc2VyLmNhY2hlT2JqZWN0KGRyYXcuc2l6ZSk7XG4gICAgICAgIHJldHVybiBkcmF3O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIFwidGVtcGxhdGVcIiB0aGF0IHNldHMgY29uc3RhbnQgYXR0aWJ1dGVzIGZvciBlYWNoIHZlcnRleCwgd2hpY2ggaXMgdGhlbiBtb2RpZmllZCBwZXIgdmVydGV4IG9yIHBlciBmZWF0dXJlLlxuICAgICAqIEEgcGxhaW4gSlMgYXJyYXkgbWF0Y2hpbmcgdGhlIG9yZGVyIG9mIHRoZSB2ZXJ0ZXggbGF5b3V0LlxuICAgICAqL1xuICAgIG1ha2VWZXJ0ZXhUZW1wbGF0ZShzdHlsZSkge1xuICAgICAgICBsZXQgY29sb3IgPSBzdHlsZS5jb2xvciB8fCBTdHlsZVBhcnNlci5kZWZhdWx0cy5jb2xvcjtcblxuICAgICAgICAvLyBwb3NpdGlvbiAtIHggJiB5IGNvb3JkcyB3aWxsIGJlIGZpbGxlZCBpbiBwZXItdmVydGV4IGJlbG93XG4gICAgICAgIHRoaXMuZmlsbFZlcnRleFRlbXBsYXRlKCdhX3Bvc2l0aW9uJywgMCwgeyBzaXplOiAyIH0pO1xuICAgICAgICB0aGlzLmZpbGxWZXJ0ZXhUZW1wbGF0ZSgnYV9wb3NpdGlvbicsIHN0eWxlLnogfHwgMCwgeyBzaXplOiAxLCBvZmZzZXQ6IDIgfSk7XG4gICAgICAgIC8vIGxheWVyIG9yZGVyIC0gdyBjb29yZCBvZiAncG9zaXRpb24nIGF0dHJpYnV0ZSAoZm9yIHBhY2tpbmcgZWZmaWNpZW5jeSlcbiAgICAgICAgdGhpcy5maWxsVmVydGV4VGVtcGxhdGUoJ2FfcG9zaXRpb24nLCBzdHlsZS5vcmRlciB8fCAwLCB7IHNpemU6IDEsIG9mZnNldDogMyB9KTtcblxuICAgICAgICAvLyBzY2FsaW5nIHZlY3RvciAtICh4LCB5KSBjb21wb25lbnRzIHBlciBwaXhlbCwgeiA9IGFuZ2xlLCB3ID0gc2NhbGluZyBmYWN0b3JcbiAgICAgICAgdGhpcy5maWxsVmVydGV4VGVtcGxhdGUoJ2Ffc2hhcGUnLCAwLCB7IHNpemU6IDQgfSk7XG5cbiAgICAgICAgLy8gdGV4dHVyZSBjb29yZHNcbiAgICAgICAgdGhpcy5maWxsVmVydGV4VGVtcGxhdGUoJ2FfdGV4Y29vcmQnLCAwLCB7IHNpemU6IDIgfSk7XG5cbiAgICAgICAgLy8gb2Zmc2V0c1xuICAgICAgICB0aGlzLmZpbGxWZXJ0ZXhUZW1wbGF0ZSgnYV9vZmZzZXQnLCAwLCB7IHNpemU6IDIgfSk7XG5cbiAgICAgICAgLy8gY29sb3JcbiAgICAgICAgdGhpcy5maWxsVmVydGV4VGVtcGxhdGUoJ2FfY29sb3InLCBWZWN0b3IubXVsdChjb2xvciwgMjU1KSwgeyBzaXplOiA0IH0pO1xuXG4gICAgICAgIC8vIHNlbGVjdGlvbiBjb2xvclxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZmlsbFZlcnRleFRlbXBsYXRlKCdhX3NlbGVjdGlvbl9jb2xvcicsIFZlY3Rvci5tdWx0KHN0eWxlLnNlbGVjdGlvbl9jb2xvciwgMjU1KSwgeyBzaXplOiA0IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGV4X3RlbXBsYXRlO1xuICAgIH0sXG5cbiAgICBidWlsZFF1YWQgKHBvaW50cywgc2l6ZSwgYW5nbGUsIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsIG9mZnNldCkge1xuICAgICAgICBCdWlsZGVycy5idWlsZFF1YWRzRm9yUG9pbnRzKFxuICAgICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgICAgdmVydGV4X2RhdGEsXG4gICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGV4Y29vcmRfaW5kZXg6IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX3RleGNvb3JkLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uX2luZGV4OiB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV9wb3NpdGlvbixcbiAgICAgICAgICAgICAgICBzaGFwZV9pbmRleDogdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfc2hhcGUsXG4gICAgICAgICAgICAgICAgb2Zmc2V0X2luZGV4OiB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV9vZmZzZXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcXVhZDogWyBVdGlscy5zY2FsZUludDE2KHNpemVbMF0sIDI1NiksIFV0aWxzLnNjYWxlSW50MTYoc2l6ZVsxXSwgMjU2KSBdLFxuICAgICAgICAgICAgICAgIHF1YWRfc2NhbGU6IFV0aWxzLnNjYWxlSW50MTYoMSwgMjU2KSxcbiAgICAgICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICAgICAgYW5nbGU6IFV0aWxzLnNjYWxlSW50MTYoYW5nbGUsIDM2MCksXG4gICAgICAgICAgICAgICAgdGV4Y29vcmRfc2NhbGU6IHRoaXMudGV4Y29vcmRfc2NhbGUsXG4gICAgICAgICAgICAgICAgdGV4Y29vcmRfbm9ybWFsaXplOiA2NTUzNVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBidWlsZFBvaW50cyAocG9pbnRzLCBzdHlsZSwgdmVydGV4X2RhdGEpIHtcbiAgICAgICAgaWYgKCFzdHlsZS5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJ1aWxkUXVhZChwb2ludHMsIHN0eWxlLnNpemUsIHN0eWxlLmFuZ2xlLCB2ZXJ0ZXhfZGF0YSwgdGhpcy5tYWtlVmVydGV4VGVtcGxhdGUoc3R5bGUpLCBzdHlsZS5vZmZzZXQpO1xuICAgIH0sXG5cbiAgICBidWlsZFBvbHlnb25zKHBvbHlnb25zLCBzdHlsZSwgdmVydGV4X2RhdGEpIHtcbiAgICAgICAgLy8gUmVuZGVyIHBvbHlnb25zIGFzIGluZGl2aWR1YWwgcG9pbnRzLCBvciBjZW50cm9pZFxuICAgICAgICBpZiAoIXN0eWxlLmNlbnRyb2lkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwb2x5PTA7IHBvbHkgPCBwb2x5Z29ucy5sZW5ndGg7IHBvbHkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwb2x5Z29uID0gcG9seWdvbnNbcG9seV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcj0wOyByIDwgcG9seWdvbi5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkUG9pbnRzKHBvbHlnb25bcl0sIHN0eWxlLCB2ZXJ0ZXhfZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNlbnRyb2lkID0gR2VvLm11bHRpQ2VudHJvaWQocG9seWdvbnMpO1xuICAgICAgICAgICAgdGhpcy5idWlsZFBvaW50cyhbY2VudHJvaWRdLCBzdHlsZSwgdmVydGV4X2RhdGEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGJ1aWxkTGluZXMobGluZXMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSkge1xuICAgICAgICAvLyBSZW5kZXIgbGluZXMgYXMgaW5kaXZpZHVhbCBwb2ludHNcbiAgICAgICAgZm9yIChsZXQgbG49MDsgbG4gPCBsaW5lcy5sZW5ndGg7IGxuKyspIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRQb2ludHMobGluZXNbbG5dLCBzdHlsZSwgdmVydGV4X2RhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcbiIsIi8vIFBvbHlnb24gcmVuZGVyaW5nIHN0eWxlXG5cbmltcG9ydCB7U3R5bGV9IGZyb20gJy4uL3N0eWxlJztcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4uL3N0eWxlX3BhcnNlcic7XG5pbXBvcnQgZ2wgZnJvbSAnLi4vLi4vZ2wvY29uc3RhbnRzJzsgLy8gd2ViIHdvcmtlcnMgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gR0wgY29udGV4dCwgc28gaW1wb3J0IGFsbCBHTCBjb25zdGFudHNcbmltcG9ydCBWZXJ0ZXhMYXlvdXQgZnJvbSAnLi4vLi4vZ2wvdmVydGV4X2xheW91dCc7XG5pbXBvcnQgQnVpbGRlcnMgZnJvbSAnLi4vYnVpbGRlcnMnO1xuaW1wb3J0IEdlbyBmcm9tICcuLi8uLi9nZW8nO1xuXG5leHBvcnQgdmFyIFBvbHlnb25zID0gT2JqZWN0LmNyZWF0ZShTdHlsZSk7XG5cbk9iamVjdC5hc3NpZ24oUG9seWdvbnMsIHtcbiAgICBuYW1lOiAncG9seWdvbnMnLFxuICAgIGJ1aWx0X2luOiB0cnVlLFxuICAgIHZlcnRleF9zaGFkZXJfa2V5OiAnc3R5bGVzL3BvbHlnb25zL3BvbHlnb25zX3ZlcnRleCcsXG4gICAgZnJhZ21lbnRfc2hhZGVyX2tleTogJ3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29uc19mcmFnbWVudCcsXG4gICAgc2VsZWN0aW9uOiB0cnVlLCAvLyB0dXJuIGZlYXR1cmUgc2VsZWN0aW9uIG9uXG5cbiAgICBpbml0KCkge1xuICAgICAgICBTdHlsZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gQmFzaWMgYXR0cmlidXRlcywgb3RoZXJzIGNhbiBiZSBhZGRlZCAoc2VlIHRleHR1cmUgVVZzIGJlbG93KVxuICAgICAgICB2YXIgYXR0cmlicyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfcG9zaXRpb24nLCBzaXplOiA0LCB0eXBlOiBnbC5TSE9SVCwgbm9ybWFsaXplZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYV9ub3JtYWwnLCBzaXplOiAzLCB0eXBlOiBnbC5CWVRFLCBub3JtYWxpemVkOiB0cnVlIH0sIC8vIGdldHMgcGFkZGVkIHRvIDQtYnl0ZXNcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfY29sb3InLCBzaXplOiA0LCB0eXBlOiBnbC5VTlNJR05FRF9CWVRFLCBub3JtYWxpemVkOiB0cnVlIH1cbiAgICAgICAgXTtcblxuICAgICAgICAvLyBUZWxsIHRoZSBzaGFkZXIgd2UgaGF2ZSBhIG5vcm1hbCBhbmQgb3JkZXIgYXR0cmlidXRlc1xuICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9OT1JNQUxfQVRUUklCVVRFID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fTEFZRVJfT1JERVIgPSB0cnVlO1xuXG4gICAgICAgIC8vIE9wdGlvbmFsIGZlYXR1cmUgc2VsZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgYXR0cmlicy5wdXNoKHsgbmFtZTogJ2Ffc2VsZWN0aW9uX2NvbG9yJywgc2l6ZTogNCwgdHlwZTogZ2wuVU5TSUdORURfQllURSwgbm9ybWFsaXplZDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9wdGlvbmFsIHRleHR1cmUgVVZzXG4gICAgICAgIGlmICh0aGlzLnRleGNvb3Jkcykge1xuICAgICAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fVEVYVFVSRV9DT09SRFMgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBBZGQgdmVydGV4IGF0dHJpYnV0ZSBmb3IgVVZzIG9ubHkgd2hlbiBuZWVkZWRcbiAgICAgICAgICAgIGF0dHJpYnMucHVzaCh7IG5hbWU6ICdhX3RleGNvb3JkJywgc2l6ZTogMiwgdHlwZTogZ2wuVU5TSUdORURfU0hPUlQsIG5vcm1hbGl6ZWQ6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZlcnRleF9sYXlvdXQgPSBuZXcgVmVydGV4TGF5b3V0KGF0dHJpYnMpO1xuICAgIH0sXG5cbiAgICBfcGFyc2VGZWF0dXJlIChmZWF0dXJlLCBydWxlX3N0eWxlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZmVhdHVyZV9zdHlsZTtcblxuICAgICAgICBzdHlsZS5jb2xvciA9IHRoaXMucGFyc2VDb2xvcihydWxlX3N0eWxlLmNvbG9yLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKCFzdHlsZS5jb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoZWlnaHQgZGVmYXVsdHMgdG8gZmVhdHVyZSBoZWlnaHQsIGJ1dCBleHRydWRlIHN0eWxlIGNhbiBkeW5hbWljYWxseSBhZGp1c3QgaGVpZ2h0IGJ5IHJldHVybmluZyBhIG51bWJlciBvciBhcnJheSAoaW5zdGVhZCBvZiBhIGJvb2xlYW4pXG4gICAgICAgIHN0eWxlLnogPSAocnVsZV9zdHlsZS56ICYmIFN0eWxlUGFyc2VyLmNhY2hlRGlzdGFuY2UocnVsZV9zdHlsZS56LCBjb250ZXh0KSkgfHwgU3R5bGVQYXJzZXIuZGVmYXVsdHMuejtcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gZmVhdHVyZS5wcm9wZXJ0aWVzLmhlaWdodCB8fCBTdHlsZVBhcnNlci5kZWZhdWx0cy5oZWlnaHQ7XG4gICAgICAgIHN0eWxlLm1pbl9oZWlnaHQgPSBmZWF0dXJlLnByb3BlcnRpZXMubWluX2hlaWdodCB8fCBTdHlsZVBhcnNlci5kZWZhdWx0cy5taW5faGVpZ2h0O1xuICAgICAgICBzdHlsZS5leHRydWRlID0gcnVsZV9zdHlsZS5leHRydWRlO1xuICAgICAgICBpZiAoc3R5bGUuZXh0cnVkZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZS5leHRydWRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuZXh0cnVkZSA9IHN0eWxlLmV4dHJ1ZGUoY29udGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGUuZXh0cnVkZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBzdHlsZS5leHRydWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzdHlsZS5leHRydWRlKSkge1xuICAgICAgICAgICAgICAgIHN0eWxlLm1pbl9oZWlnaHQgPSBzdHlsZS5leHRydWRlWzBdO1xuICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IHN0eWxlLmV4dHJ1ZGVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZS50aWxlX2VkZ2VzID0gcnVsZV9zdHlsZS50aWxlX2VkZ2VzOyAvLyB1c3VhbGx5IGFjdGl2YXRlZCBmb3IgZGVidWdnaW5nLCBvciByYXJlIHZpc3VhbGl6YXRpb24gbmVlZHNcblxuICAgICAgICAvLyBzdHlsZS5vdXRsaW5lID0gc3R5bGUub3V0bGluZSB8fCB7fTtcbiAgICAgICAgLy8gaWYgKHJ1bGVfc3R5bGUub3V0bGluZSkge1xuICAgICAgICAvLyAgICAgc3R5bGUub3V0bGluZS5jb2xvciA9IFN0eWxlUGFyc2VyLnBhcnNlQ29sb3IocnVsZV9zdHlsZS5vdXRsaW5lLmNvbG9yLCBjb250ZXh0KTtcbiAgICAgICAgLy8gICAgIHN0eWxlLm91dGxpbmUud2lkdGggPSBTdHlsZVBhcnNlci5wYXJzZURpc3RhbmNlKHJ1bGVfc3R5bGUub3V0bGluZS53aWR0aCwgY29udGV4dCk7XG4gICAgICAgIC8vICAgICBzdHlsZS5vdXRsaW5lLnRpbGVfZWRnZXMgPSBydWxlX3N0eWxlLm91dGxpbmUudGlsZV9lZGdlcztcbiAgICAgICAgLy8gICAgIHN0eWxlLm91dGxpbmUuY2FwID0gcnVsZV9zdHlsZS5vdXRsaW5lLmNhcCB8fCBydWxlX3N0eWxlLmNhcDtcbiAgICAgICAgLy8gICAgIHN0eWxlLm91dGxpbmUuam9pbiA9IHJ1bGVfc3R5bGUub3V0bGluZS5qb2luIHx8IHJ1bGVfc3R5bGUuam9pbjtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBlbHNlIHtcbiAgICAgICAgLy8gICAgIHN0eWxlLm91dGxpbmUuY29sb3IgPSBudWxsO1xuICAgICAgICAvLyAgICAgc3R5bGUub3V0bGluZS53aWR0aCA9IG51bGw7XG4gICAgICAgIC8vICAgICBzdHlsZS5vdXRsaW5lLnRpbGVfZWRnZXMgPSBmYWxzZTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuXG4gICAgX3ByZXByb2Nlc3MgKGRyYXcpIHtcbiAgICAgICAgZHJhdy5jb2xvciA9IFN0eWxlUGFyc2VyLmNhY2hlT2JqZWN0KGRyYXcuY29sb3IpO1xuICAgICAgICBkcmF3LnogPSBTdHlsZVBhcnNlci5jYWNoZU9iamVjdChkcmF3LnopO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSBcInRlbXBsYXRlXCIgdGhhdCBzZXRzIGNvbnN0YW50IGF0dGlidXRlcyBmb3IgZWFjaCB2ZXJ0ZXgsIHdoaWNoIGlzIHRoZW4gbW9kaWZpZWQgcGVyIHZlcnRleCBvciBwZXIgZmVhdHVyZS5cbiAgICAgKiBBIHBsYWluIEpTIGFycmF5IG1hdGNoaW5nIHRoZSBvcmRlciBvZiB0aGUgdmVydGV4IGxheW91dC5cbiAgICAgKi9cbiAgICBtYWtlVmVydGV4VGVtcGxhdGUoc3R5bGUpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuXG4gICAgICAgIC8vIHBvc2l0aW9uIC0geCAmIHkgY29vcmRzIHdpbGwgYmUgZmlsbGVkIGluIHBlci12ZXJ0ZXggYmVsb3dcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IDA7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUueiB8fCAwO1xuXG4gICAgICAgIC8vIGxheWVyIG9yZGVyIC0gdyBjb29yZCBvZiAncG9zaXRpb24nIGF0dHJpYnV0ZSAoZm9yIHBhY2tpbmcgZWZmaWNpZW5jeSlcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLm9yZGVyO1xuXG4gICAgICAgIC8vIG5vcm1hbFxuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gMDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IDA7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAxICogMTI3O1xuXG4gICAgICAgIC8vIGNvbG9yXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5jb2xvclswXSAqIDI1NTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLmNvbG9yWzFdICogMjU1O1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUuY29sb3JbMl0gKiAyNTU7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5jb2xvclszXSAqIDI1NTtcblxuICAgICAgICAvLyBzZWxlY3Rpb24gY29sb3JcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzBdICogMjU1O1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLnNlbGVjdGlvbl9jb2xvclsxXSAqIDI1NTtcbiAgICAgICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5zZWxlY3Rpb25fY29sb3JbMl0gKiAyNTU7XG4gICAgICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzNdICogMjU1O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRleHR1cmUgVVZzIHRvIHRlbXBsYXRlIG9ubHkgaWYgbmVlZGVkXG4gICAgICAgIGlmICh0aGlzLnRleGNvb3Jkcykge1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IDA7XG4gICAgICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRleF90ZW1wbGF0ZTtcbiAgICB9LFxuXG4gICAgYnVpbGRQb2x5Z29ucyhwb2x5Z29ucywgc3R5bGUsIHZlcnRleF9kYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIGxldCB2ZXJ0ZXhfdGVtcGxhdGUgPSB0aGlzLm1ha2VWZXJ0ZXhUZW1wbGF0ZShzdHlsZSk7XG4gICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgICAgdGV4Y29vcmRfaW5kZXg6IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX3RleGNvb3JkLFxuICAgICAgICAgICAgdGV4Y29vcmRfc2NhbGU6IHRoaXMudGV4Y29vcmRfc2NhbGUsXG4gICAgICAgICAgICB0ZXhjb29yZF9ub3JtYWxpemU6IDY1NTM1LCAvLyBzY2FsZSBVVnMgdG8gdW5zaWduZWQgc2hvcnRzXG4gICAgICAgICAgICByZW1vdmVfdGlsZV9lZGdlczogIXN0eWxlLnRpbGVfZWRnZXMsXG4gICAgICAgICAgICB0aWxlX2VkZ2VfdG9sZXJhbmNlOiBHZW8udGlsZV9zY2FsZSAqIGNvbnRleHQudGlsZS5wYWRfc2NhbGUgKiA0XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRXh0cnVkZWQgcG9seWdvbnMgKGUuZy4gM0QgYnVpbGRpbmdzKVxuICAgICAgICBpZiAoc3R5bGUuZXh0cnVkZSAmJiBzdHlsZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIEJ1aWxkZXJzLmJ1aWxkRXh0cnVkZWRQb2x5Z29ucyhcbiAgICAgICAgICAgICAgICBwb2x5Z29ucyxcbiAgICAgICAgICAgICAgICBzdHlsZS56LCBzdHlsZS5oZWlnaHQsIHN0eWxlLm1pbl9oZWlnaHQsXG4gICAgICAgICAgICAgICAgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV9ub3JtYWwsXG4gICAgICAgICAgICAgICAgMTI3LCAvLyBzY2FsZSBub3JtYWxzIHRvIHNpZ25lZCBieXRlc1xuICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVndWxhciBwb2x5Z29uc1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIEJ1aWxkZXJzLmJ1aWxkUG9seWdvbnMoXG4gICAgICAgICAgICAgICAgcG9seWdvbnMsXG4gICAgICAgICAgICAgICAgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcbiIsImltcG9ydCB7U3R5bGVzfSBmcm9tICcuL3N0eWxlX21hbmFnZXInO1xuaW1wb3J0IG1lcmdlT2JqZWN0cyBmcm9tICcuLi91dGlscy9tZXJnZSc7XG5pbXBvcnQge21hdGNofSBmcm9tICdtYXRjaC1mZWF0dXJlJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5leHBvcnQgY29uc3Qgd2hpdGVMaXN0ID0gWydmaWx0ZXInLCAnZHJhdycsICd2aXNpYmxlJywgJ2RhdGEnLCAncHJvcGVydGllcyddO1xuXG5leHBvcnQgbGV0IHJ1bGVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBjYWNoZUtleSAocnVsZXMpIHtcbiAgICBydWxlcyA9IHJ1bGVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICB2YXIgayA9IHJ1bGVzWzBdLmlkO1xuICAgIGZvciAodmFyIGk9MTsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGsgKz0gJy8nICsgcnVsZXNbaV0uaWQ7XG4gICAgfVxuICAgIHJldHVybiBrO1xufVxuXG4vLyBNZXJnZSBtYXRjaGluZyBsYXllciBydWxlIHRyZWVzIGludG8gYSBmaW5hbCBkcmF3IGdyb3VwXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VUcmVlcyhtYXRjaGluZ1RyZWVzLCBncm91cCkge1xuICAgIGxldCBkcmF3cywgdHJlZURlcHRoID0gMDtcblxuICAgIGxldCBkcmF3ID0ge1xuICAgICAgICB2aXNpYmxlOiB0cnVlIC8vIHZpc2libGUgYnkgZGVmYXVsdFxuICAgIH07XG5cbiAgICAvLyBGaW5kIGRlZXBlc3QgdHJlZVxuICAgIGZvciAobGV0IHQ9MDsgdCA8IG1hdGNoaW5nVHJlZXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgaWYgKG1hdGNoaW5nVHJlZXNbdF0ubGVuZ3RoID4gdHJlZURlcHRoKSB7XG4gICAgICAgICAgICB0cmVlRGVwdGggPSBtYXRjaGluZ1RyZWVzW3RdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIHJ1bGVzIHRvIHBhcnNlXG4gICAgaWYgKHRyZWVEZXB0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBJdGVyYXRlIHRyZWVzIGluIHBhcmFsbGVsXG4gICAgZm9yIChsZXQgeD0wOyB4IDwgdHJlZURlcHRoOyB4KyspIHtcbiAgICAgICAgLy8gUHVsbCBvdXQgdGhlIHJlcXVlc3RlZCBkcmF3IGdyb3VwLCBmb3IgZWFjaCB0cmVlLCBhdCB0aGlzIGRlcHRoXG4gICAgICAgIGRyYXdzID0gbWF0Y2hpbmdUcmVlcy5tYXAodHJlZSA9PiB0cmVlW3hdICYmIHRyZWVbeF1bZ3JvdXBdKTtcbiAgICAgICAgaWYgKGRyYXdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb3J0IGJ5IGxheWVyIG5hbWUgYmVmb3JlIG1lcmdpbmcsIHNvIHJ1bGVzIGFyZSBhcHBsaWVkIGRldGVybWluaXN0aWNhbGx5XG4gICAgICAgIC8vIHdoZW4gbXVsdGlwbGUgcnVsZXMgbW9kaWZ5IHRoZSBzYW1lIHByb3BlcnRpZXNcbiAgICAgICAgZHJhd3Muc29ydCgoYSwgYikgPT4gKGEgJiYgYS5sYXllcl9uYW1lKSA+IChiICYmIGIubGF5ZXJfbmFtZSkgPyAxIDogLTEpO1xuXG4gICAgICAgIC8vIE1lcmdlIGRyYXcgb2JqZWN0c1xuICAgICAgICBtZXJnZU9iamVjdHMoZHJhdywgLi4uZHJhd3MpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBsYXllciBuYW1lcywgdGhleSB3ZXJlIG9ubHkgdXNlZCB0cmFuc2llbnRseSB0byBzb3J0IGFuZCBjYWxjdWxhdGUgZmluYWwgbGF5ZXJcbiAgICAgICAgLy8gKGZpbmFsIG1lcmdlZCBuYW1lcyB3aWxsIG5vdCBiZSBhY2N1cmF0ZSBzaW5jZSBvbmx5IG9uZSB0cmVlIGNhbiB3aW4pXG4gICAgICAgIGRlbGV0ZSBkcmF3LmxheWVyX25hbWU7XG4gICAgfVxuXG4gICAgLy8gU2hvcnQtY2lyY3VpdCBpZiBub3QgdmlzaWJsZVxuICAgIGlmIChkcmF3LnZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBkcmF3O1xufVxuXG5cbmNsYXNzIFJ1bGUge1xuXG4gICAgY29uc3RydWN0b3Ioe25hbWUsIHBhcmVudCwgZHJhdywgdmlzaWJsZSwgZmlsdGVyLCBwcm9wZXJ0aWVzfSkge1xuICAgICAgICB0aGlzLmlkID0gUnVsZS5pZCsrO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5mdWxsX25hbWUgPSB0aGlzLnBhcmVudCA/ICh0aGlzLnBhcmVudC5mdWxsX25hbWUgKyAnOicgKyB0aGlzLm5hbWUpIDogdGhpcy5uYW1lO1xuICAgICAgICB0aGlzLmRyYXcgPSBkcmF3O1xuICAgICAgICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZSAhPT0gdW5kZWZpbmVkID8gdmlzaWJsZSA6ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC52aXNpYmxlKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcyAhPT0gdW5kZWZpbmVkID8gcHJvcGVydGllcyA6ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5wcm9wZXJ0aWVzKTtcblxuICAgICAgICAvLyBEZW5vcm1hbGl6ZSBsYXllciBuYW1lICYgcHJvcGVydGllcyB0byBkcmF3IGdyb3Vwc1xuICAgICAgICBpZiAodGhpcy5kcmF3KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBncm91cCBpbiB0aGlzLmRyYXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdbZ3JvdXBdLmxheWVyX25hbWUgPSB0aGlzLmZ1bGxfbmFtZTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdbZ3JvdXBdLnByb3BlcnRpZXMgPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5idWlsZEZpbHRlcigpO1xuICAgICAgICB0aGlzLmJ1aWxkRHJhdygpO1xuICAgIH1cblxuICAgIGJ1aWxkRHJhdygpIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVkRHJhdyA9IGNhbGN1bGF0ZURyYXcodGhpcyk7XG4gICAgfVxuXG4gICAgYnVpbGRGaWx0ZXIoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHRoaXMuZmlsdGVyO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyID0gbWF0Y2godGhpcy5maWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBkcmF3OiB0aGlzLmRyYXdcbiAgICAgICAgfTtcbiAgICB9XG5cbn1cblxuUnVsZS5pZCA9IDA7XG5cblxuZXhwb3J0IGNsYXNzIFJ1bGVMZWFmIGV4dGVuZHMgUnVsZSB7XG4gICAgY29uc3RydWN0b3Ioe25hbWUsIHBhcmVudCwgZHJhdywgdmlzaWJsZSwgZmlsdGVyLCBwcm9wZXJ0aWVzfSkge1xuICAgICAgICBzdXBlcih7bmFtZSwgcGFyZW50LCBkcmF3LCB2aXNpYmxlLCBmaWx0ZXIsIHByb3BlcnRpZXN9KTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGNsYXNzIFJ1bGVUcmVlIGV4dGVuZHMgUnVsZSB7XG4gICAgY29uc3RydWN0b3Ioe25hbWUsIHBhcmVudCwgZHJhdywgdmlzaWJsZSwgcnVsZXMsIGZpbHRlciwgcHJvcGVydGllc30pIHtcbiAgICAgICAgc3VwZXIoe25hbWUsIHBhcmVudCwgZHJhdywgdmlzaWJsZSwgZmlsdGVyLCBwcm9wZXJ0aWVzfSk7XG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlcyB8fCBbXTtcbiAgICB9XG5cbiAgICBhZGRSdWxlKHJ1bGUpIHtcbiAgICAgICAgdGhpcy5ydWxlcy5wdXNoKHJ1bGUpO1xuICAgIH1cblxuICAgIGJ1aWxkRHJhd0dyb3Vwcyhjb250ZXh0KSB7XG4gICAgICAgIGxldCBydWxlcyAgPSBbXTtcbiAgICAgICAgLy9UT0RPLCBzaG91bGQgdGhpcyBmdW5jdGlvbiB0YWtlIGEgUnVsZVRyZWVcbiAgICAgICAgbWF0Y2hGZWF0dXJlKGNvbnRleHQsIFt0aGlzXSwgcnVsZXMpO1xuXG4gICAgICAgIGlmIChydWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgY2FjaGVfa2V5ID0gY2FjaGVLZXkocnVsZXMpO1xuXG4gICAgICAgICAgICAvLyBPbmx5IGV2YWx1YXRlIGVhY2ggcnVsZSBjb21iaW5hdGlvbiBvbmNlICh1bmRlZmluZWQgbWVhbnMgbm90IHlldCBldmFsdWF0ZWQsXG4gICAgICAgICAgICAvLyBudWxsIG1lYW5zIGV2YWx1YXRlZCB3aXRoIG5vIGRyYXcgb2JqZWN0KVxuICAgICAgICAgICAgaWYgKHJ1bGVDYWNoZVtjYWNoZV9rZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBWaXNpYmxlP1xuICAgICAgICAgICAgICAgIGlmIChydWxlcy5zb21lKHggPT4geC52aXNpYmxlID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUNhY2hlW2NhY2hlX2tleV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCBhbGwgdGhlIHVuaXF1ZSBkcmF3IGJsb2NrcyBmb3IgdGhpcyBydWxlIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRyYXdfcnVsZXMgPSBydWxlcy5tYXAoeCA9PiB4ICYmIHguY2FsY3VsYXRlZERyYXcpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZHJhd19rZXlzID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcnVsZSBvZiBkcmF3X3J1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGdyb3VwIG9mIHJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd19rZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBlYWNoIGRyYXcgZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZHJhd19rZXkgaW4gZHJhd19rZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlQ2FjaGVbY2FjaGVfa2V5XSA9IHJ1bGVDYWNoZVtjYWNoZV9rZXldIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUNhY2hlW2NhY2hlX2tleV1bZHJhd19rZXldID0gbWVyZ2VUcmVlcyhkcmF3X3J1bGVzLCBkcmF3X2tleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgc2F2ZSB0aGUgb25lcyB0aGF0IHdlcmVuJ3QgbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFydWxlQ2FjaGVbY2FjaGVfa2V5XVtkcmF3X2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcnVsZUNhY2hlW2NhY2hlX2tleV1bZHJhd19rZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUNhY2hlW2NhY2hlX2tleV1bZHJhd19rZXldLmtleSA9IGNhY2hlX2tleSArICcvJyArIGRyYXdfa2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVDYWNoZVtjYWNoZV9rZXldW2RyYXdfa2V5XS5sYXllcnMgPSBydWxlcy5tYXAoeCA9PiB4ICYmIHguZnVsbF9uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHJ1bGVzIGV2YWx1YXRlZFxuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZUNhY2hlW2NhY2hlX2tleV0gJiYgT2JqZWN0LmtleXMocnVsZUNhY2hlW2NhY2hlX2tleV0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUNhY2hlW2NhY2hlX2tleV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVDYWNoZVtjYWNoZV9rZXldO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVMaXN0ZWQoa2V5KSB7XG4gICAgcmV0dXJuIHdoaXRlTGlzdC5pbmRleE9mKGtleSkgPiAtMTtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YWxrVXAocnVsZSwgY2IpIHtcblxuICAgIGlmIChydWxlLnBhcmVudCkge1xuICAgICAgICB3YWxrVXAocnVsZS5wYXJlbnQsIGNiKTtcbiAgICB9XG5cbiAgICBjYihydWxlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhbGtEb3duKHJ1bGUsIGNiKSB7XG5cbiAgICBpZiAocnVsZS5ydWxlcykge1xuICAgICAgICBydWxlLnJ1bGVzLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgICAgIHdhbGtEb3duKHIsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2IocnVsZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncm91cFByb3BzKG9iaikge1xuICAgIGxldCB3aGl0ZUxpc3RlZCA9IHt9LCBub25XaGl0ZUxpc3RlZCA9IHt9O1xuXG4gICAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoaXNXaGl0ZUxpc3RlZChrZXkpKSB7XG4gICAgICAgICAgICB3aGl0ZUxpc3RlZFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub25XaGl0ZUxpc3RlZFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFt3aGl0ZUxpc3RlZCwgbm9uV2hpdGVMaXN0ZWRdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRHJhdyhydWxlKSB7XG5cbiAgICBsZXQgZHJhdyAgPSBbXTtcblxuICAgIGlmIChydWxlLnBhcmVudCkge1xuICAgICAgICBsZXQgY3MgPSBydWxlLnBhcmVudC5jYWxjdWxhdGVkRHJhdyB8fCBbXTtcbiAgICAgICAgZHJhdy5wdXNoKC4uLmNzKTtcbiAgICB9XG5cbiAgICBkcmF3LnB1c2gocnVsZS5kcmF3KTtcbiAgICByZXR1cm4gZHJhdztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUnVsZVRyZWUobmFtZSwgcnVsZSwgcGFyZW50KSB7XG5cbiAgICBsZXQgcHJvcGVydGllcyA9IHtuYW1lLCBwYXJlbnR9O1xuICAgIGxldCBbd2hpdGVMaXN0ZWQsIG5vbldoaXRlTGlzdGVkXSA9IGdyb3VwUHJvcHMocnVsZSk7XG4gICAgbGV0IGVtcHR5ID0gaXNFbXB0eShub25XaGl0ZUxpc3RlZCk7XG4gICAgbGV0IENyZWF0ZTtcblxuICAgIGlmIChlbXB0eSAmJiBwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBDcmVhdGUgPSBSdWxlTGVhZjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBDcmVhdGUgPSBSdWxlVHJlZTtcbiAgICB9XG5cbiAgICBsZXQgciA9IG5ldyBDcmVhdGUoT2JqZWN0LmFzc2lnbihwcm9wZXJ0aWVzLCB3aGl0ZUxpc3RlZCkpO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuYWRkUnVsZShyKTtcbiAgICB9XG5cbiAgICBpZiAoIWVtcHR5KSB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBub25XaGl0ZUxpc3RlZCkge1xuICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gbm9uV2hpdGVMaXN0ZWRba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIHBhcnNlUnVsZVRyZWUoa2V5LCBwcm9wZXJ0eSwgcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEludmFsaWQgbGF5ZXJcbiAgICAgICAgICAgICAgICBsZXQgbXNnID0gYExheWVyIHZhbHVlIG11c3QgYmUgYW4gb2JqZWN0OiBjYW4ndCBjcmVhdGUgbGF5ZXIgJyR7a2V5fTogJHtKU09OLnN0cmluZ2lmeShwcm9wZXJ0eSl9J2A7XG4gICAgICAgICAgICAgICAgbXNnICs9IGAsIHVuZGVyIHBhcmVudCBsYXllciAnJHtyLmZ1bGxfbmFtZX0nLmA7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcGFyZW50IGlzIGEgc3R5bGUgbmFtZSwgdGhpcyBtYXkgYmUgYW4gaW5jb3JyZWN0bHkgbmVzdGVkIGxheWVyXG4gICAgICAgICAgICAgICAgaWYgKFN0eWxlc1tyLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSBgIFRoZSBwYXJlbnQgJyR7ci5uYW1lfScgaXMgYWxzbyB0aGUgbmFtZSBvZiBhIHN0eWxlLCBkaWQgeW91IG1lYW4gdG8gY3JlYXRlIGEgJ2RyYXcnIGdyb3VwYDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnICs9IGAgdW5kZXIgJyR7cGFyZW50Lm5hbWV9J2A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IGAgaW5zdGVhZD9gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2cud2Fybihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSdWxlcyhydWxlcykge1xuICAgIGxldCBydWxlVHJlZXMgPSB7fTtcblxuICAgIGZvciAobGV0IGtleSBpbiBydWxlcykge1xuICAgICAgICBsZXQgcnVsZSA9IHJ1bGVzW2tleV07XG4gICAgICAgIGlmIChydWxlKSB7XG4gICAgICAgICAgICBydWxlVHJlZXNba2V5XSA9IHBhcnNlUnVsZVRyZWUoa2V5LCBydWxlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBydWxlVHJlZXM7XG59XG5cblxuZnVuY3Rpb24gZG9lc01hdGNoKGZpbHRlciwgY29udGV4dCkge1xuICAgIHJldHVybiAoKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgJiYgZmlsdGVyKGNvbnRleHQpKSB8fCAoZmlsdGVyID09IG51bGwpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoRmVhdHVyZShjb250ZXh0LCBydWxlcywgY29sbGVjdGVkUnVsZXMpIHtcbiAgICBsZXQgbWF0Y2hlZCA9IGZhbHNlO1xuICAgIGxldCBjaGlsZE1hdGNoZWQgPSBmYWxzZTtcblxuICAgIGlmIChydWxlcy5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgICBmb3IgKGxldCByPTA7IHIgPCBydWxlcy5sZW5ndGg7IHIrKykge1xuICAgICAgICBsZXQgY3VycmVudCA9IHJ1bGVzW3JdO1xuICAgICAgICBjb250ZXh0LnByb3BlcnRpZXMgPSBjdXJyZW50LnByb3BlcnRpZXM7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBSdWxlTGVhZikge1xuXG4gICAgICAgICAgICBpZiAoZG9lc01hdGNoKGN1cnJlbnQuZmlsdGVyLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbGxlY3RlZFJ1bGVzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50IGluc3RhbmNlb2YgUnVsZVRyZWUpIHtcbiAgICAgICAgICAgIGlmIChkb2VzTWF0Y2goY3VycmVudC5maWx0ZXIsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBjaGlsZE1hdGNoZWQgPSBtYXRjaEZlYXR1cmUoXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQucnVsZXMsXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZFJ1bGVzXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGlmICghY2hpbGRNYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZFJ1bGVzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5wcm9wZXJ0aWVzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlZDtcbn1cbiIsIi8vIFJlbmRlcmluZyBzdHlsZXNcblxuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IEZlYXR1cmVTZWxlY3Rpb24gZnJvbSAnLi4vc2VsZWN0aW9uJztcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gJy4uL2dsL3NoYWRlcl9wcm9ncmFtJztcbmltcG9ydCBWQk9NZXNoIGZyb20gJy4uL2dsL3Zib19tZXNoJztcbmltcG9ydCBNYXRlcmlhbCBmcm9tICcuLi9tYXRlcmlhbCc7XG5pbXBvcnQgTGlnaHQgZnJvbSAnLi4vbGlnaHQnO1xuaW1wb3J0IHtNZXRob2ROb3RJbXBsZW1lbnRlZH0gZnJvbSAnLi4vdXRpbHMvZXJyb3JzJztcbmltcG9ydCBzaGFkZXJTb3VyY2VzIGZyb20gJy4uL2dsL3NoYWRlcl9zb3VyY2VzJzsgLy8gYnVpbHQtaW4gc2hhZGVyc1xuXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxuLy8gQmFzZSBjbGFzc1xuXG5leHBvcnQgdmFyIFN0eWxlID0ge1xuICAgIGluaXQgKHsgZ2VuZXJhdGlvbiB9ID0ge30pIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQnVpbHRJbigpKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWx0X2luID0gZmFsc2U7IC8vIGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlIHRvIGF2b2lkIGFueSBjb25mdXNpb25cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2VuZXJhdGlvbiA9IGdlbmVyYXRpb247ICAgICAgICAgICAgICAgLy8gc2NlbmUgZ2VuZXJhdGlvbiBpZCB0aGlzIHN0eWxlIHdhcyBjcmVhdGVkIGZvclxuICAgICAgICB0aGlzLmRlZmluZXMgPSAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnZGVmaW5lcycpICYmIHRoaXMuZGVmaW5lcykgfHwge307IC8vICNkZWZpbmVzIHRvIGJlIGluamVjdGVkIGludG8gdGhlIHNoYWRlcnNcbiAgICAgICAgdGhpcy5zaGFkZXJzID0gKHRoaXMuaGFzT3duUHJvcGVydHkoJ3NoYWRlcnMnKSAmJiB0aGlzLnNoYWRlcnMpIHx8IHt9OyAvLyBzaGFkZXIgY3VzdG9taXphdGlvbiAodW5pZm9ybXMsIGRlZmluZXMsIGJsb2NrcywgZXRjLilcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbiB8fCBmYWxzZTsgICAvLyBmbGFnIGluZGljYXRpbmcgaWYgdGhpcyBzdHlsZSBzdXBwb3J0cyBmZWF0dXJlIHNlbGVjdGlvblxuICAgICAgICB0aGlzLmNvbXBpbGluZyA9IGZhbHNlOyAgICAgICAgICAgICAgICAgICAgIC8vIHByb2dyYW1zIGFyZSBjdXJyZW50bHkgY29tcGlsaW5nXG4gICAgICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTsgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvZ3JhbXMgYXJlIGZpbmlzaGVkIGNvbXBpbGluZ1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdMIHByb2dyYW0gcmVmZXJlbmNlIChmb3IgbWFpbiByZW5kZXIgcGFzcylcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25fcHJvZ3JhbSA9IG51bGw7ICAgICAgICAgICAgICAvLyBHTCBwcm9ncmFtIHJlZmVyZW5jZSBmb3IgZmVhdHVyZSBzZWxlY3Rpb24gcmVuZGVyIHBhc3NcbiAgICAgICAgdGhpcy5mZWF0dXJlX3N0eWxlID0ge307ICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZSBmb3IgZmVhdHVyZSBjdXJyZW50bHkgYmVpbmcgcGFyc2VkLCBzaGFyZWQgdG8gbGVzc2VuIEdDL21lbW9yeSB0aHJhc2hcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGUgPSBbXTsgICAgICAgICAgICAgICAgICAvLyBzaGFyZWQgc2luZ2xlLXZlcnRleCB0ZW1wbGF0ZSwgZmlsbGVkIG91dCBieSBlYWNoIHN0eWxlXG4gICAgICAgIHRoaXMudGlsZV9kYXRhID0ge307XG4gICAgICAgIHRoaXMuZmVhdHVyZV9vcHRpb25zID0ge307XG5cbiAgICAgICAgLy8gRGVmYXVsdCB3b3JsZCBjb29yZHMgdG8gd3JhcCBldmVyeSAxMDAsMDAwIG1ldGVycywgY2FuIHR1cm4gb2ZmIGJ5IHNldHRpbmcgdGhpcyB0byAnZmFsc2UnXG4gICAgICAgIHRoaXMuZGVmaW5lcy5UQU5HUkFNX1dPUkxEX1BPU0lUSU9OX1dSQVAgPSAxMDAwMDA7XG5cbiAgICAgICAgLy8gQmxlbmRpbmdcbiAgICAgICAgdGhpcy5ibGVuZCA9IHRoaXMuYmxlbmQgfHwgJ29wYXF1ZSc7ICAgICAgICAvLyBkZWZhdWx0OiBvcGFxdWUgc3R5bGVzIGFyZSBkcmF3biBmaXJzdCwgd2l0aG91dCBibGVuZGluZ1xuICAgICAgICB0aGlzLmRlZmluZXNbYFRBTkdSQU1fQkxFTkRfJHt0aGlzLmJsZW5kLnRvVXBwZXJDYXNlKCl9YF0gPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5ibGVuZF9vcmRlciA9PSBudWxsKSB7IC8vIGNvbnRyb2xzIG9yZGVyIG9mIHJlbmRlcmluZyBmb3Igc3R5bGVzIHcvbm9uLW9wYXF1ZSBibGVuZGluZ1xuICAgICAgICAgICAgdGhpcy5ibGVuZF9vcmRlciA9IC0xOyAvLyBkZWZhdWx0cyB0byBmaXJzdFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHN0eWxlIGRlZmluZXMgaXRzIG93biBtYXRlcmlhbCwgcmVwbGFjZSB0aGUgaW5oZXJpdGVkIG1hdGVyaWFsIGluc3RhbmNlXG4gICAgICAgIGlmICghKHRoaXMubWF0ZXJpYWwgaW5zdGFuY2VvZiBNYXRlcmlhbCkpIHtcbiAgICAgICAgICAgIGlmICghTWF0ZXJpYWwuaXNWYWxpZCh0aGlzLm1hdGVyaWFsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0ZXJpYWwgPSBTdHlsZVBhcnNlci5kZWZhdWx0cy5tYXRlcmlhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwodGhpcy5tYXRlcmlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXRlcmlhbC5pbmplY3QodGhpcyk7XG5cbiAgICAgICAgLy8gU2V0IGxpZ2h0aW5nIG1vZGU6IGZyYWdtZW50LCB2ZXJ0ZXgsIG9yIG5vbmUgKHNwZWNpZmllZCBhcyAnZmFsc2UnKVxuICAgICAgICBMaWdodC5zZXRNb2RlKHRoaXMubGlnaHRpbmcsIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBkZXN0cm95ICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbSkge1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25fcHJvZ3JhbSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25fcHJvZ3JhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbl9wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIHJlc2V0ICgpIHtcbiAgICB9LFxuXG4gICAgaXNCdWlsdEluICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzT3duUHJvcGVydHkoJ2J1aWx0X2luJykgJiYgdGhpcy5idWlsdF9pbjtcbiAgICB9LFxuXG4gICAgZmlsbFZlcnRleFRlbXBsYXRlKGF0dHJpYnV0ZSwgdmFsdWUsIHsgc2l6ZSwgb2Zmc2V0IH0pIHtcbiAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA9PT0gdW5kZWZpbmVkKSA/IDAgOiBvZmZzZXQ7XG5cbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4W2F0dHJpYnV0ZV07XG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsb2cud2FybihgU3R5bGU6IGluIHN0eWxlICcke3RoaXMubmFtZX0nLCBubyBpbmRleCBmb3VuZCBpbiB2ZXJ0ZXggbGF5b3V0IGZvciBhdHRyaWJ1dGUgJyR7YXR0cmlidXRlfSdgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICBsZXQgdiA9IHZhbHVlLmxlbmd0aCA+IGkgPyB2YWx1ZVtpXSA6IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaW5kZXggKyBpICsgb2Zmc2V0XSA9IHY7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqKiBTdHlsZSBwYXJzaW5nIGFuZCBnZW9tZXRyeSBjb25zdHJ1Y3Rpb24gKioqL1xuXG4gICAgLy8gUmV0dXJucyBhbiBvYmplY3QgdG8gaG9sZCBmZWF0dXJlIGRhdGEgKGZvciBhIHRpbGUgb3Igb3RoZXIgb2JqZWN0KVxuICAgIHN0YXJ0RGF0YSAodGlsZSkge1xuICAgICAgICB0aGlzLnRpbGVfZGF0YVt0aWxlXSA9IHtcbiAgICAgICAgICAgIHZlcnRleF9kYXRhOiBudWxsLFxuICAgICAgICAgICAgdW5pZm9ybXM6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZV9kYXRhW3RpbGVdO1xuICAgIH0sXG5cbiAgICAvLyBGaW5hbGl6ZXMgYW4gb2JqZWN0IGhvbGRpbmcgZmVhdHVyZSBkYXRhIChmb3IgYSB0aWxlIG9yIG90aGVyIG9iamVjdClcbiAgICBlbmREYXRhICh0aWxlKSB7XG4gICAgICAgIHZhciB0aWxlX2RhdGEgPSB0aGlzLnRpbGVfZGF0YVt0aWxlXTtcbiAgICAgICAgaWYgKHRpbGVfZGF0YSAmJiB0aWxlX2RhdGEudmVydGV4X2RhdGEpIHtcbiAgICAgICAgICAgIC8vIE9ubHkga2VlcCBmaW5hbCBieXRlIGJ1ZmZlclxuICAgICAgICAgICAgdGlsZV9kYXRhLnZlcnRleF9kYXRhLmVuZCgpO1xuICAgICAgICAgICAgdGlsZV9kYXRhLnZlcnRleF9kYXRhID0gdGlsZV9kYXRhLnZlcnRleF9kYXRhLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbGVfZGF0YVt0aWxlXSA9IG51bGw7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGlsZV9kYXRhKTtcbiAgICB9LFxuXG4gICAgLy8gSGFzIG1lc2ggZGF0YSBmb3IgYSBnaXZlbiB0aWxlP1xuICAgIGhhc0RhdGFGb3JUaWxlICh0aWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVfZGF0YVt0aWxlXSAhPSBudWxsO1xuICAgIH0sXG5cbiAgICBhZGRGZWF0dXJlIChmZWF0dXJlLCBydWxlLCBjb250ZXh0KSB7XG4gICAgICAgIGxldCB0aWxlID0gY29udGV4dC50aWxlO1xuICAgICAgICBpZiAodGlsZS5nZW5lcmF0aW9uICE9PSB0aGlzLmdlbmVyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy50aWxlX2RhdGFbdGlsZS5rZXldKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RGF0YSh0aWxlLmtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3R5bGUgPSB0aGlzLnBhcnNlRmVhdHVyZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBhbGxvdyBzdWJjbGFzc2VzIHRvIHBhc3MgZXh0cmEgYXJnc1xuXG4gICAgICAgIC8vIFNraXAgZmVhdHVyZT9cbiAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QgZmVhdHVyZSBpbiB0aGlzIHJlbmRlciBzdHlsZT9cbiAgICAgICAgaWYgKCF0aGlzLnRpbGVfZGF0YVt0aWxlLmtleV0udmVydGV4X2RhdGEpIHtcbiAgICAgICAgICAgIHRoaXMudGlsZV9kYXRhW3RpbGUua2V5XS52ZXJ0ZXhfZGF0YSA9IHRoaXMudmVydGV4X2xheW91dC5jcmVhdGVWZXJ0ZXhEYXRhKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJ1aWxkR2VvbWV0cnkoZmVhdHVyZS5nZW9tZXRyeSwgc3R5bGUsIHRoaXMudGlsZV9kYXRhW3RpbGUua2V5XS52ZXJ0ZXhfZGF0YSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGJ1aWxkR2VvbWV0cnkgKGdlb21ldHJ5LCBzdHlsZSwgdmVydGV4X2RhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICAgICAgdGhpcy5idWlsZFBvbHlnb25zKFtnZW9tZXRyeS5jb29yZGluYXRlc10sIHN0eWxlLCB2ZXJ0ZXhfZGF0YSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRQb2x5Z29ucyhnZW9tZXRyeS5jb29yZGluYXRlcywgc3R5bGUsIHZlcnRleF9kYXRhLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRMaW5lcyhbZ2VvbWV0cnkuY29vcmRpbmF0ZXNdLCBzdHlsZSwgdmVydGV4X2RhdGEsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkTGluZXMoZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ1BvaW50Jykge1xuICAgICAgICAgICAgdGhpcy5idWlsZFBvaW50cyhbZ2VvbWV0cnkuY29vcmRpbmF0ZXNdLCBzdHlsZSwgdmVydGV4X2RhdGEsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xuICAgICAgICAgICAgdGhpcy5idWlsZFBvaW50cyhnZW9tZXRyeS5jb29yZGluYXRlcywgc3R5bGUsIHZlcnRleF9kYXRhLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXJzZUZlYXR1cmUgKGZlYXR1cmUsIHJ1bGVfc3R5bGUsIGNvbnRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZmVhdHVyZV9zdHlsZTtcblxuICAgICAgICAgICAgcnVsZV9zdHlsZSA9IHRoaXMucHJlcHJvY2VzcyhydWxlX3N0eWxlKTtcbiAgICAgICAgICAgIGlmICghcnVsZV9zdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG9yZGVyIGlmIGl0IHdhcyBub3QgY2FjaGVkXG4gICAgICAgICAgICBzdHlsZS5vcmRlciA9IHRoaXMucGFyc2VPcmRlcihydWxlX3N0eWxlLm9yZGVyLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgLy8gRmVhdHVyZSBzZWxlY3Rpb24gKG9ubHkgaWYgc3R5bGUgc3VwcG9ydHMgaXQpXG4gICAgICAgICAgICB2YXIgc2VsZWN0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgc3R5bGUuaW50ZXJhY3RpdmUgPSBydWxlX3N0eWxlLmludGVyYWN0aXZlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZS5pbnRlcmFjdGl2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RhYmxlID0gc3R5bGUuaW50ZXJhY3RpdmUoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RhYmxlID0gc3R5bGUuaW50ZXJhY3RpdmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBmZWF0dXJlIGlzIG1hcmtlZCBhcyBzZWxlY3RhYmxlXG4gICAgICAgICAgICBpZiAoc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlLnNlbGVjdGlvbl9jb2xvciA9IEZlYXR1cmVTZWxlY3Rpb24ubWFrZUNvbG9yKGZlYXR1cmUsIGNvbnRleHQudGlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5zZWxlY3Rpb25fY29sb3IgPSBGZWF0dXJlU2VsZWN0aW9uLmRlZmF1bHRDb2xvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3ViY2xhc3MgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgIHN0eWxlID0gdGhpcy5fcGFyc2VGZWF0dXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGFsbG93IHN1YmNsYXNzZXMgdG8gcGFzcyBleHRyYSBhcmdzXG5cbiAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgbG9nLmVycm9yKCdTdHlsZS5wYXJzZUZlYXR1cmU6IHN0eWxlIHBhcnNpbmcgZXJyb3InLCBmZWF0dXJlLCBzdHlsZSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wYXJzZUZlYXR1cmUgKGZlYXR1cmUsIHJ1bGVfc3R5bGUsIGNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1ldGhvZE5vdEltcGxlbWVudGVkKCdfcGFyc2VGZWF0dXJlJyk7XG4gICAgfSxcblxuICAgIHByZXByb2Nlc3MgKHJ1bGVfc3R5bGUpIHtcbiAgICAgICAgLy8gUHJlcHJvY2VzcyBmaXJzdCB0aW1lXG4gICAgICAgIGlmICghcnVsZV9zdHlsZS5wcmVwcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIHJ1bGVfc3R5bGUgPSB0aGlzLl9wcmVwcm9jZXNzKHJ1bGVfc3R5bGUpOyAvLyBvcHRpb25hbCBzdWJjbGFzcyBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgaWYgKCFydWxlX3N0eWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVsZV9zdHlsZS5wcmVwcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydWxlX3N0eWxlO1xuICAgIH0sXG5cbiAgICAvLyBvcHRpb25hbGx5IGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzXG4gICAgX3ByZXByb2Nlc3MgKHJ1bGVfc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIHJ1bGVfc3R5bGU7XG4gICAgfSxcblxuICAgIC8vIFBhcnNlIGFuIG9yZGVyIHZhbHVlXG4gICAgcGFyc2VPcmRlciAob3JkZXIsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG9yZGVyIGlmIGl0IHdhcyBub3QgY2FjaGVkXG4gICAgICAgIGlmICh0eXBlb2Ygb3JkZXIgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gU3R5bGVQYXJzZXIuY2FsY3VsYXRlT3JkZXIob3JkZXIsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICB9LFxuXG4gICAgLy8gUGFyc2UgYSBjb2xvciBvZiBjaG9vc2UgYSBkZWZhdWx0IGlmIGFjY2VwdGFibGUsIHJldHVybiB1bmRlZmluZWQgaWYgY29sb3IgbWlzc2luZ1xuICAgIHBhcnNlQ29sb3IoY29sb3IsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gTmVlZCBlaXRoZXIgYSBjb2xvciwgb3IgYSBzaGFkZXIgYmxvY2sgZm9yICdjb2xvcicgb3IgJ2ZpbHRlcidcbiAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gU3R5bGVQYXJzZXIuY2FjaGVDb2xvcihjb2xvciwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zaGFkZXJzLmJsb2Nrcy5jb2xvciB8fCB0aGlzLnNoYWRlcnMuYmxvY2tzLmZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIFN0eWxlUGFyc2VyLmRlZmF1bHRzLmNvbG9yO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEJ1aWxkIGZ1bmN0aW9ucyBhcmUgbm8tb3BzIHVudGlsIG92ZXJyaWRlblxuICAgIGJ1aWxkUG9seWdvbnMgKCkge30sXG4gICAgYnVpbGRMaW5lcyAoKSB7fSxcbiAgICBidWlsZFBvaW50cyAoKSB7fSxcblxuXG4gICAgLyoqKiBHTCBzdGF0ZSBhbmQgcmVuZGVyaW5nICoqKi9cblxuICAgIHNldEdMIChnbCkge1xuICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgfSxcblxuICAgIG1ha2VNZXNoICh2ZXJ0ZXhfZGF0YSwgeyB1bmlmb3JtcyB9ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWQk9NZXNoKHRoaXMuZ2wsIHZlcnRleF9kYXRhLCB0aGlzLnZlcnRleF9sYXlvdXQsIHsgdW5pZm9ybXMgfSk7XG4gICAgfSxcblxuICAgIGNvbXBpbGUgKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2wpIHtcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcihgc3R5bGUuY29tcGlsZSgpOiBza2lwcGluZyBmb3IgJHt0aGlzLm5hbWV9IGJlY2F1c2Ugbm8gR0wgY29udGV4dGApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbXBpbGluZykge1xuICAgICAgICAgICAgdGhyb3cobmV3IEVycm9yKGBzdHlsZS5jb21waWxlKCk6IHNraXBwaW5nIGZvciAke3RoaXMubmFtZX0gYmVjYXVzZSBzdHlsZSBpcyBhbHJlYWR5IGNvbXBpbGluZ2ApKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBpbGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBCdWlsZCBkZWZpbmVzICYgZm9yIHNlbGVjdGlvbiAobmVlZCB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IHNpbmNlIHRoZSBmaXJzdCBpcyBzdG9yZWQgYXMgYSByZWZlcmVuY2UgYnkgdGhlIHByb2dyYW0pXG4gICAgICAgIHZhciBkZWZpbmVzID0gdGhpcy5idWlsZERlZmluZUxpc3QoKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uX2RlZmluZXMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZpbmVzKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbl9kZWZpbmVzLlRBTkdSQU1fRkVBVFVSRV9TRUxFQ1RJT04gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGFueSBjdXN0b20gY29kZSBibG9ja3MsIHVuaWZvcm0gZGVwZW5kZW5jaWVzLCBldGMuXG4gICAgICAgIHZhciBibG9ja3MgPSAodGhpcy5zaGFkZXJzICYmIHRoaXMuc2hhZGVycy5ibG9ja3MpO1xuICAgICAgICB2YXIgYmxvY2tfc2NvcGVzID0gKHRoaXMuc2hhZGVycyAmJiB0aGlzLnNoYWRlcnMuYmxvY2tfc2NvcGVzKTtcbiAgICAgICAgdmFyIHVuaWZvcm1zID0gKHRoaXMuc2hhZGVycyAmJiB0aGlzLnNoYWRlcnMudW5pZm9ybXMpO1xuXG4gICAgICAgIC8vIGFjY2VwdCBhIHNpbmdsZSBleHRlbnNpb24sIG9yIGFuIGFycmF5IG9mIGV4dGVuc2lvbnNcbiAgICAgICAgdmFyIGV4dGVuc2lvbnMgPSAodGhpcy5zaGFkZXJzICYmIHRoaXMuc2hhZGVycy5leHRlbnNpb25zKTtcbiAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucyA9IFtleHRlbnNpb25zXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBzaGFkZXJzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0gPSBuZXcgU2hhZGVyUHJvZ3JhbShcbiAgICAgICAgICAgICAgICB0aGlzLmdsLFxuICAgICAgICAgICAgICAgIHNoYWRlclNvdXJjZXNbdGhpcy52ZXJ0ZXhfc2hhZGVyX2tleV0sXG4gICAgICAgICAgICAgICAgc2hhZGVyU291cmNlc1t0aGlzLmZyYWdtZW50X3NoYWRlcl9rZXldLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBkZWZpbmVzLFxuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtcyxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzLFxuICAgICAgICAgICAgICAgICAgICBibG9ja19zY29wZXMsXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtLmNvbXBpbGUoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25fcHJvZ3JhbSA9IG5ldyBTaGFkZXJQcm9ncmFtKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLFxuICAgICAgICAgICAgICAgICAgICBzaGFkZXJTb3VyY2VzW3RoaXMudmVydGV4X3NoYWRlcl9rZXldLFxuICAgICAgICAgICAgICAgICAgICBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3NlbGVjdGlvbl9mcmFnbWVudCddLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAodGhpcy5uYW1lICsgJyAoc2VsZWN0aW9uKScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lczogc2VsZWN0aW9uX2RlZmluZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrX3Njb3BlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25fcHJvZ3JhbS5jb21waWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbl9wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5jb21waWxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcihgc3R5bGUuY29tcGlsZSgpOiBzdHlsZSAke3RoaXMubmFtZX0gZXJyb3I6YCwgZXJyb3IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tcGlsaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcGlsZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBzaGFkZXIgYmxvY2tcbiAgICBhZGRTaGFkZXJCbG9jayAoa2V5LCBibG9jaywgc2NvcGUgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2hhZGVycy5ibG9ja3MgPSB0aGlzLnNoYWRlcnMuYmxvY2tzIHx8IHt9O1xuICAgICAgICB0aGlzLnNoYWRlcnMuYmxvY2tzW2tleV0gPSB0aGlzLnNoYWRlcnMuYmxvY2tzW2tleV0gfHwgW107XG4gICAgICAgIHRoaXMuc2hhZGVycy5ibG9ja3Nba2V5XS5wdXNoKGJsb2NrKTtcblxuICAgICAgICB0aGlzLnNoYWRlcnMuYmxvY2tfc2NvcGVzID0gdGhpcy5zaGFkZXJzLmJsb2NrX3Njb3BlcyB8fCB7fTtcbiAgICAgICAgdGhpcy5zaGFkZXJzLmJsb2NrX3Njb3Blc1trZXldID0gdGhpcy5zaGFkZXJzLmJsb2NrX3Njb3Blc1trZXldIHx8IFtdO1xuICAgICAgICB0aGlzLnNoYWRlcnMuYmxvY2tfc2NvcGVzW2tleV0ucHVzaChzY29wZSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhbGwgc2hhZGVyIGJsb2NrcyBmb3Iga2V5XG4gICAgcmVtb3ZlU2hhZGVyQmxvY2sgKGtleSkge1xuICAgICAgICBpZiAodGhpcy5zaGFkZXJzLmJsb2Nrcykge1xuICAgICAgICAgICAgdGhpcy5zaGFkZXJzLmJsb2Nrc1trZXldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZXBsYWNlU2hhZGVyQmxvY2sgKGtleSwgYmxvY2ssIHNjb3BlID0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlbW92ZVNoYWRlckJsb2NrKGtleSk7XG4gICAgICAgIHRoaXMuYWRkU2hhZGVyQmxvY2soa2V5LCBibG9jaywgc2NvcGUpO1xuICAgIH0sXG5cbiAgICAvKiogVE9ETzogY291bGQgcHJvYmFibHkgY29tYmluZSBhbmQgZ2VuZXJhbGl6ZSB0aGlzIHdpdGggc2ltaWxhciBtZXRob2QgaW4gU2hhZGVyUHJvZ3JhbVxuICAgICAqIChsaXN0IG9mIGRlZmluZSBvYmplY3RzIHRoYXQgaW5oZXJpdCBmcm9tIGVhY2ggb3RoZXIpXG4gICAgICovXG4gICAgYnVpbGREZWZpbmVMaXN0ICgpIHtcbiAgICAgICAgLy8gQWRkIGFueSBjdXN0b20gZGVmaW5lcyB0byBidWlsdC1pbiBzdHlsZSBkZWZpbmVzXG4gICAgICAgIHZhciBkZWZpbmVzID0ge307IC8vIGNyZWF0ZSBhIG5ldyBvYmplY3QgdG8gYXZvaWQgbXV0YXRpbmcgYSBwcm90b3R5cGUgdmFsdWUgdGhhdCBtYXkgYmUgc2hhcmVkIHdpdGggb3RoZXIgc3R5bGVzXG4gICAgICAgIGlmICh0aGlzLmRlZmluZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZCBpbiB0aGlzLmRlZmluZXMpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVzW2RdID0gdGhpcy5kZWZpbmVzW2RdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNoYWRlcnMgIT0gbnVsbCAmJiB0aGlzLnNoYWRlcnMuZGVmaW5lcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGQgaW4gdGhpcy5zaGFkZXJzLmRlZmluZXMpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVzW2RdID0gdGhpcy5zaGFkZXJzLmRlZmluZXNbZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmluZXM7XG5cbiAgICB9LFxuXG4gICAgLy8gU2V0dXAgYW55IEdMIHN0YXRlIGZvciByZW5kZXJpbmdcbiAgICBzZXR1cCAoKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybXMoKTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5zZXR1cFByb2dyYW0oU2hhZGVyUHJvZ3JhbS5jdXJyZW50KTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IHN0eWxlIHVuaWZvcm1zIG9uIGN1cnJlbnRseSBib3VuZCBwcm9ncmFtXG4gICAgc2V0VW5pZm9ybXMgKCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IFNoYWRlclByb2dyYW0uY3VycmVudDtcbiAgICAgICAgaWYgKCFwcm9ncmFtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm1zKHRoaXMuc2hhZGVycyAmJiB0aGlzLnNoYWRlcnMudW5pZm9ybXMsIHRydWUpOyAvLyByZXNldCB0ZXh0dXJlIHVuaXQgdG8gMFxuICAgIH0sXG5cbiAgICAvLyBSZW5kZXIgc3RhdGUgc2V0dGluZ3MgYnkgYmxlbmQgbW9kZVxuICAgIHJlbmRlcl9zdGF0ZXM6IHtcbiAgICAgICAgb3BhcXVlOiB7IGRlcHRoX3Rlc3Q6IHRydWUsIGRlcHRoX3dyaXRlOiB0cnVlIH0sXG4gICAgICAgIGFkZDogeyBkZXB0aF90ZXN0OiB0cnVlLCBkZXB0aF93cml0ZTogZmFsc2UgfSxcbiAgICAgICAgbXVsdGlwbHk6IHsgZGVwdGhfdGVzdDogdHJ1ZSwgZGVwdGhfd3JpdGU6IGZhbHNlIH0sXG4gICAgICAgIGlubGF5OiB7IGRlcHRoX3Rlc3Q6IHRydWUsIGRlcHRoX3dyaXRlOiBmYWxzZSB9LFxuICAgICAgICBvdmVybGF5OiB7IGRlcHRoX3Rlc3Q6IGZhbHNlLCBkZXB0aF93cml0ZTogZmFsc2UgfVxuICAgIH0sXG5cbiAgICAvLyBEZWZhdWx0IHNvcnQgb3JkZXIgZm9yIGJsZW5kIG1vZGVzXG4gICAgZGVmYXVsdF9ibGVuZF9vcmRlcnM6IHtcbiAgICAgICAgb3BhcXVlOiAwLFxuICAgICAgICBhZGQ6IDEsXG4gICAgICAgIG11bHRpcGx5OiAyLFxuICAgICAgICBpbmxheTogMyxcbiAgICAgICAgb3ZlcmxheTogNFxuICAgIH0sXG5cbiAgICAvLyBDb21wYXJpc29uIGZ1bmN0aW9uIGZvciBzb3J0aW5nIHN0eWxlcyBieSBibGVuZFxuICAgIGJsZW5kT3JkZXJTb3J0IChhLCBiKSB7XG4gICAgICAgIC8vIG9wYXF1ZSBhbHdheXMgY29tZXMgZmlyc3RcbiAgICAgICAgaWYgKGEuYmxlbmQgPT09ICdvcGFxdWUnIHx8IGIuYmxlbmQgPT09ICdvcGFxdWUnKSB7XG4gICAgICAgICAgICBpZiAoYS5ibGVuZCA9PT0gJ29wYXF1ZScgJiYgYi5ibGVuZCA9PT0gJ29wYXF1ZScpIHsgLy8gaWYgYm90aCBhcmUgb3BhcXVlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEubmFtZSA8IGIubmFtZSA/IC0xIDogMTsgLy8gdXNlIG5hbWUgYXMgdGllIGJyZWFrZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGEuYmxlbmQgPT09ICdvcGFxdWUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xOyAvLyBvbmx5IGBhYCB3YXMgb3BhcXVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTsgLy8gb25seSBgYmAgd2FzIG9wYXF1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlIGV4cGxpY2l0IGJsZW5kIG9yZGVyIGlmIHBvc3NpYmxlXG4gICAgICAgIGlmIChhLmJsZW5kX29yZGVyIDwgYi5ibGVuZF9vcmRlcikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuYmxlbmRfb3JkZXIgPiBiLmJsZW5kX29yZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGJsZW5kIG9yZGVycyBhcmUgZXF1YWwsIHVzZSBkZWZhdWx0IG9yZGVyIGJ5IGJsZW5kIG1vZGVcbiAgICAgICAgaWYgKFN0eWxlLmRlZmF1bHRfYmxlbmRfb3JkZXJzW2EuYmxlbmRdIDwgU3R5bGUuZGVmYXVsdF9ibGVuZF9vcmRlcnNbYi5ibGVuZF0pIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChTdHlsZS5kZWZhdWx0X2JsZW5kX29yZGVyc1thLmJsZW5kXSA+IFN0eWxlLmRlZmF1bHRfYmxlbmRfb3JkZXJzW2IuYmxlbmRdKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhLm5hbWUgPCBiLm5hbWUgPyAtMSA6IDE7IC8vIHVzZSBuYW1lIGFzIHRpZSBicmVha2VyXG4gICAgfSxcblxuICAgIHVwZGF0ZSAoKSB7XG4gICAgICAgIC8vIFN0eWxlLXNwZWNpZmljIGFuaW1hdGlvblxuICAgICAgICAvLyBpZiAodHlwZW9mIHRoaXMuYW5pbWF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICAgICB0aGlzLmFuaW1hdGlvbigpO1xuICAgICAgICAvLyB9XG4gICAgfVxuXG59O1xuIiwiLy8gTWFuYWdlIHJlbmRlcmluZyBzdHlsZXNcblxuaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gJy4uL2dsL3NoYWRlcl9wcm9ncmFtJztcbmltcG9ydCBzaGFkZXJTb3VyY2VzIGZyb20gJy4uL2dsL3NoYWRlcl9zb3VyY2VzJzsgLy8gYnVpbHQtaW4gc2hhZGVyc1xuaW1wb3J0IHtTdHlsZX0gZnJvbSAnLi9zdHlsZSc7XG5pbXBvcnQgbWVyZ2VPYmplY3RzIGZyb20gJy4uL3V0aWxzL21lcmdlJztcbmltcG9ydCBHZW8gZnJvbSAnLi4vZ2VvJztcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCB2YXIgU3R5bGVNYW5hZ2VyID0ge307XG5leHBvcnQgdmFyIFN0eWxlcyA9IHt9O1xuZXhwb3J0IHZhciBCYXNlU3R5bGVzID0ge307XG5cblN0eWxlTWFuYWdlci5zdHlsZXMgPSBTdHlsZXM7XG5cbi8vIFNldCB0aGUgYmFzZSBvYmplY3QgdXNlZCB0byBpbnN0YW50aWF0ZSBzdHlsZXNcblN0eWxlTWFuYWdlci5iYXNlU3R5bGUgPSBTdHlsZTtcblxuLy8gR2xvYmFsIGNvbmZpZ3VyYXRpb24gZm9yIGFsbCBzdHlsZXNcblN0eWxlTWFuYWdlci5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIFNoYWRlclByb2dyYW0ucmVtb3ZlQmxvY2soJ2dsb2JhbCcpO1xuICAgIFNoYWRlclByb2dyYW0ucmVtb3ZlQmxvY2soJ3NldHVwJyk7XG5cbiAgICAvLyBVbnBhY2tpbmcgZnVuY3Rpb25zIChmb3Igbm9ybWFsaXplZCB2ZXJ0ZXggYXR0cmlidXRlcylcbiAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKCdnbG9iYWwnLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3VucGFjayddKTtcblxuICAgIC8vIE1vZGVsIGFuZCB3b3JsZCBwb3NpdGlvbiBhY2Nlc3NvcnNcbiAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKCdnbG9iYWwnLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL2FjY2Vzc29ycyddKTtcblxuICAgIC8vIExheWVyIHJlLW9yZGVyaW5nIGZ1bmN0aW9uXG4gICAgU2hhZGVyUHJvZ3JhbS5hZGRCbG9jaygnZ2xvYmFsJywgc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9sYXllcl9vcmRlciddKTtcblxuICAgIC8vIEZlYXR1cmUgc2VsZWN0aW9uIGdsb2JhbFxuICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soJ2dsb2JhbCcsIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvc2VsZWN0aW9uX2dsb2JhbHMnXSk7XG5cbiAgICAvLyBGZWF0dXJlIHNlbGVjdGlvbiB2ZXJ0ZXggc2hhZGVyIHN1cHBvcnRcbiAgICBTaGFkZXJQcm9ncmFtLnJlcGxhY2VCbG9jaygnc2V0dXAnLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3NlbGVjdGlvbl92ZXJ0ZXgnXSk7XG5cbiAgICAvLyBNaW5pbXVtIHZhbHVlIGZvciBmbG9hdCBjb21wYXJpc29uc1xuICAgIFNoYWRlclByb2dyYW0uZGVmaW5lcy5UQU5HUkFNX0VQU0lMT04gPSAwLjAwMDAxO1xuXG4gICAgLy8gYXNzdW1lIG1pbiAxNi1iaXQgZGVwdGggYnVmZmVyLCBpbiBwcmFjdGljZSB1c2VzIDE0LWJpdHMsIDEgZXh0cmEgYml0IHRvIGhhbmRsZSB2aXJ0dWFsIGhhbGYtbGF5ZXJzXG4gICAgLy8gZm9yIG91dGxpbmVzIChpbnNlcnRlZCBpbiBiZXR3ZWVuIGxheWVycyksIGFub3RoZXIgZXh0cmEgYml0IHRvIHByZXZlbnQgcHJlY2lzaW9uIGxvc3NcbiAgICBTaGFkZXJQcm9ncmFtLmRlZmluZXMuVEFOR1JBTV9MQVlFUl9ERUxUQSA9IDEgLyAoMSA8PCAxNCk7XG5cbiAgICAvLyBJbnRlcm5hbCB0aWxlIHNjYWxlXG4gICAgU2hhZGVyUHJvZ3JhbS5kZWZpbmVzLlRBTkdSQU1fVElMRV9TQ0FMRSA9IGB2ZWMzKCR7R2VvLnRpbGVfc2NhbGV9LiwgJHtHZW8udGlsZV9zY2FsZX0uLCB1X21ldGVyc19wZXJfcGl4ZWwgKiAke0dlby50aWxlX3NpemV9LilgO1xufTtcblxuLy8gRGVzdHJveSBhbGwgc3R5bGVzIGZvciBhIGdpdmVuIEdMIGNvbnRleHRcblN0eWxlTWFuYWdlci5kZXN0cm95ID0gZnVuY3Rpb24gKGdsKSB7XG4gICAgT2JqZWN0LmtleXMoU3R5bGVzKS5mb3JFYWNoKChfbmFtZSkgPT4ge1xuICAgICAgICB2YXIgc3R5bGUgPSBTdHlsZXNbX25hbWVdO1xuICAgICAgICBpZiAoc3R5bGUuZ2wgPT09IGdsKSB7XG4gICAgICAgICAgICBsb2cudHJhY2UoYFN0eWxlTWFuYWdlci5kZXN0cm95OiBkZXN0cm95aW5nIHJlbmRlciBzdHlsZSAke3N0eWxlLm5hbWV9YCk7XG5cbiAgICAgICAgICAgIGlmICghc3R5bGUuaXNCdWlsdEluKCkpIHtcbiAgICAgICAgICAgICAgICBTdHlsZU1hbmFnZXIucmVtb3ZlKHN0eWxlLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vLyBSZWdpc3RlciBhIHN0eWxlXG5TdHlsZU1hbmFnZXIucmVnaXN0ZXIgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICBTdHlsZXNbc3R5bGUubmFtZV0gPSBzdHlsZTtcbiAgICBCYXNlU3R5bGVzW3N0eWxlLm5hbWVdID0gc3R5bGU7XG59O1xuXG4vLyBSZW1vdmUgYSBzdHlsZVxuU3R5bGVNYW5hZ2VyLnJlbW92ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgZGVsZXRlIFN0eWxlc1tuYW1lXTtcbn07XG5cbi8vIExvYWQgc3R5bGUgZGVmaW5pdGlvbnMgZnJvbSBleHRlcm5hbCBVUkxzXG5TdHlsZU1hbmFnZXIubG9hZFJlbW90ZVN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXMsIGJhc2UpIHtcbiAgICAvLyBDb2xsZWN0IFVSTHMgYW5kIG1vZGVzIHRvIGltcG9ydCBmcm9tIHRoZW1cbiAgICAvLyBUaGlzIGlzIGRvbmUgYXMgYSBzZXBhcmF0ZSBzdGVwIGJlY3Vhc2UgaXQgaXMgcG9zc2libGUgdG8gaW1wb3J0IG11bHRpcGxlIG1vZGVzIGZyb20gYSBzaW5nbGVcbiAgICAvLyBVUkwsIGFuZCB3ZSB3YW50IHRvIGF2b2lkIGR1cGxpY2F0ZSBjYWxscyBmb3IgdGhlIHNhbWUgZmlsZS5cbiAgICB2YXIgdXJscyA9IHt9O1xuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHN0eWxlc1tuYW1lXTtcbiAgICAgICAgaWYgKHN0eWxlLnVybCkge1xuICAgICAgICAgICAgbGV0IHVybCA9IHN0eWxlLnVybDtcbiAgICAgICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gVXRpbHMuYWRkQmFzZVVSTCh1cmwsIGJhc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXVybHNbdXJsXSkge1xuICAgICAgICAgICAgICAgIHVybHNbdXJsXSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIGEgbGlzdCBvZiB0aGUgc3R5bGVzIHRvIGltcG9ydCBmb3IgdGhpcyBVUkxcbiAgICAgICAgICAgIHVybHNbdXJsXS5wdXNoKHtcbiAgICAgICAgICAgICAgICB0YXJnZXRfbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBzb3VyY2VfbmFtZTogc3R5bGUubmFtZSB8fCBuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFzIGVhY2ggVVJMIGZpbmlzaGVzIGxvYWRpbmcsIHJlcGxhY2UgdGhlIHRhcmdldCBzdHlsZShzKVxuICAgIHJldHVybiBQcm9taXNlLmFsbChPYmplY3Qua2V5cyh1cmxzKS5tYXAodXJsID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIFV0aWxzLmxvYWRSZXNvdXJjZSh1cmwpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBNaXhpbiByZW1vdGUgc3R5bGVzLCB3aXRoaW4gZWFjaCByZW1vdGUgZmlsZVxuICAgICAgICAgICAgICAgIC8vIFRPRE86IG1heSBub3QgaGFuZGxlIG11bHRpcGxlIGxldmVscyBvZiBtaXhpbnMsIGFuZCB3aWxsIG5vdCBoYW5kbGUgbmVzdGVkIHJlbW90ZSBmaWxlc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHNvdXJjZV9uYW1lIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNvdXJjZV9pbXBvcnQgPSB1cmxzW3VybF0gJiYgdXJsc1t1cmxdLmZpbmQocyA9PiBzLnNvdXJjZV9uYW1lID09PSBzb3VyY2VfbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VfaW1wb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgaW1wb3J0ZWQgbmFtZSBpZiBkaWZmZXJlbnQgZnJvbSBuYW1lIGluIHNvdXJjZSBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3NvdXJjZV9uYW1lXS5uYW1lID0gc291cmNlX2ltcG9ydC50YXJnZXRfbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbc291cmNlX25hbWVdLm5hbWUgPSBzb3VyY2VfbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbc291cmNlX25hbWVdID0gU3R5bGVNYW5hZ2VyLm1peChkYXRhW3NvdXJjZV9uYW1lXSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJlbW90ZSBzdHlsZXMgdG8gbG9jYWwgc3R5bGVzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdGFyZ2V0IG9mIHVybHNbdXJsXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhW3RhcmdldC5zb3VyY2VfbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1t0YXJnZXQudGFyZ2V0X25hbWVdID0gZGF0YVt0YXJnZXQuc291cmNlX25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlc1t0YXJnZXQudGFyZ2V0X25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYFN0eWxlTWFuYWdlci5sb2FkUmVtb3RlU3R5bGVzOiBlcnJvciBpbXBvcnRpbmcgc3R5bGUgJHt0YXJnZXQudGFyZ2V0X25hbWV9LCBjb3VsZCBub3QgZmluZCBzb3VyY2Ugc3R5bGUgJHt0YXJnZXQuc291cmNlX25hbWV9IGluICR7dXJsfWApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKGBTdHlsZU1hbmFnZXIubG9hZFJlbW90ZVN0eWxlczogZXJyb3IgaW1wb3J0aW5nIHN0eWxlKHMpICR7SlNPTi5zdHJpbmdpZnkodXJsc1t1cmxdKX0gZnJvbSAke3VybH1gLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSkpLnRoZW4oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHN0eWxlcykpO1xufTtcblxuLy8gUHJlbG9hZCBzaGFkZXIgYmxvY2tzIGZyb20gZXh0ZXJuYWwgVVJMc1xuU3R5bGVNYW5hZ2VyLmxvYWRTaGFkZXJCbG9ja3MgPSBmdW5jdGlvbiAoc3R5bGVzLCBiYXNlKSB7XG4gICAgaWYgKCFzdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gICAgfVxuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIGZvciAodmFyIHN0eWxlIG9mIFV0aWxzLnZhbHVlcyhzdHlsZXMpKSB7XG4gICAgICAgIGlmIChzdHlsZS5zaGFkZXJzICYmIHN0eWxlLnNoYWRlcnMuYmxvY2tzKSB7XG4gICAgICAgICAgICBsZXQgX2Jsb2NrcyA9IHN0eWxlLnNoYWRlcnMuYmxvY2tzO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBba2V5LCBibG9ja10gb2YgVXRpbHMuZW50cmllcyhzdHlsZS5zaGFkZXJzLmJsb2NrcykpIHtcbiAgICAgICAgICAgICAgICBsZXQgX2tleSA9IGtleTtcblxuICAgICAgICAgICAgICAgIC8vIEFycmF5IG9mIGJsb2Nrc1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJsb2NrKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBiPTA7IGIgPCBibG9jay5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBibG9ja1tiXSA9PT0gJ29iamVjdCcgJiYgYmxvY2tbYl0udXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9pbmRleCA9IGI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHVybCA9IGJsb2NrW2JdLnVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBVdGlscy5hZGRCYXNlVVJMKHVybCwgYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChVdGlscy5pbyhVdGlscy5jYWNoZUJ1c3RlckZvclVybCh1cmwpKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ibG9ja3NbX2tleV1bX2luZGV4XSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5lcnJvcihgU3R5bGVNYW5hZ2VyLmxvYWRTaGFkZXJCbG9ja3M6IGVycm9yIGxvYWRpbmcgc2hhZGVyIGJsb2NrYCwgX2Jsb2NrcywgX2tleSwgX2luZGV4LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNpbmdsZSBibG9ja1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBibG9jayA9PT0gJ29iamVjdCcgJiYgYmxvY2sudXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB1cmwgPSBibG9jay51cmw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBVdGlscy5hZGRCYXNlVVJMKHVybCwgYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKFV0aWxzLmlvKFV0aWxzLmNhY2hlQnVzdGVyRm9yVXJsKHVybCkpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ibG9ja3NbX2tleV0gPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5lcnJvcihgU3R5bGVNYW5hZ2VyLmxvYWRTaGFkZXJCbG9ja3M6IGVycm9yIGxvYWRpbmcgc2hhZGVyIGJsb2NrYCwgX2Jsb2NrcywgX2tleSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChxdWV1ZSkudGhlbigoKSA9PiBQcm9taXNlLnJlc29sdmUoc3R5bGVzKSk7IC8vIFRPRE86IGFkZCBlcnJvclxufTtcblxuU3R5bGVNYW5hZ2VyLm1peCA9IGZ1bmN0aW9uIChzdHlsZSwgc3R5bGVzKSB7XG4gICAgLy8gRXhpdCBlYXJseSBpZiB3ZSBoYXZlIGFscmVhZHkgYXBwbGllZCBtaXhpbnMgdG8gdGhpcyBzdHlsZVxuICAgIGlmIChzdHlsZS5taXhlZCkge1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuICAgIHN0eWxlLm1peGVkID0ge307XG5cbiAgICAvLyBNaXhpbiBzb3VyY2VzLCBpbiBvcmRlclxuICAgIGxldCBzb3VyY2VzID0gW107XG4gICAgaWYgKHN0eWxlLm1peCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZS5taXgpKSB7XG4gICAgICAgICAgICBzb3VyY2VzLnB1c2goLi4uc3R5bGUubWl4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZXMucHVzaChzdHlsZS5taXgpO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZXMgPSBzb3VyY2VzLm1hcCh4ID0+IHN0eWxlc1t4XSkuZmlsdGVyKHggPT4geCAmJiB4ICE9PSBzdHlsZSk7IC8vIFRPRE86IHdhcm5pbmcgb24gdHJ5aW5nIHRvIG1peCBpbnRvIHNlbGZcblxuICAgICAgICAvLyBUcmFjayB3aGljaCBzdHlsZXMgd2VyZSBtaXhlZCBpbnRvIHRoaXMgb25lXG4gICAgICAgIGZvciAobGV0IHMgb2Ygc291cmNlcykge1xuICAgICAgICAgICAgc3R5bGUubWl4ZWRbc10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNvdXJjZXMucHVzaChzdHlsZSk7XG5cbiAgICAvLyBGbGFncyAtIE9SJ2QsIHRydWUgaWYgYW55IHN0eWxlIGhhcyBpdCBzZXRcbiAgICBzdHlsZS5hbmltYXRlZCA9IHNvdXJjZXMuc29tZSh4ID0+IHggJiYgeC5hbmltYXRlZCk7XG4gICAgc3R5bGUudGV4Y29vcmRzID0gc291cmNlcy5zb21lKHggPT4geCAmJiB4LnRleGNvb3Jkcyk7XG5cbiAgICAvLyBPdmVyd3JpdGVzIC0gbGFzdCBkZWZpbml0aW9uIHdpbnNcbiAgICBzdHlsZS5iYXNlID0gc291cmNlcy5tYXAoeCA9PiB4LmJhc2UpLmZpbHRlcih4ID0+IHgpLnBvcCgpO1xuICAgIHN0eWxlLmxpZ2h0aW5nID0gc291cmNlcy5tYXAoeCA9PiB4LmxpZ2h0aW5nKS5maWx0ZXIoeCA9PiB4ICE9IG51bGwpLnBvcCgpO1xuICAgIHN0eWxlLnRleHR1cmUgPSBzb3VyY2VzLm1hcCh4ID0+IHgudGV4dHVyZSkuZmlsdGVyKHggPT4geCkucG9wKCk7XG4gICAgaWYgKHNvdXJjZXMuc29tZSh4ID0+IHguaGFzT3duUHJvcGVydHkoJ2JsZW5kJykgJiYgeC5ibGVuZCkpIHtcbiAgICAgICAgLy8gb25seSBtaXggYmxlbmQgaWYgZXhwbGljaXRseSBzZXQsIG90aGVyd2lzZSBsZXQgYmFzZSBzdHlsZSBjaG9vc2UgYmxlbmRpbmcgbW9kZVxuICAgICAgICAvLyBoYXNPd25Qcm9wZXJ0eSBjaGVjayBnaXZlcyBwcmVmZXJlbmNlIHRvIGJhc2Ugc3R5bGUgcHJvdG90eXBlXG4gICAgICAgIHN0eWxlLmJsZW5kID0gc291cmNlcy5tYXAoeCA9PiB4Lmhhc093blByb3BlcnR5KCdibGVuZCcpICYmIHguYmxlbmQpLmZpbHRlcih4ID0+IHgpLnBvcCgpO1xuICAgIH1cbiAgICBzdHlsZS5ibGVuZF9vcmRlciA9IHNvdXJjZXMubWFwKHggPT4geC5ibGVuZF9vcmRlcikuZmlsdGVyKHggPT4geCAhPSBudWxsKS5wb3AoKTtcblxuICAgIC8vIE1lcmdlcyAtIHByb3BlcnR5LXNwZWNpZmljIHJ1bGVzIGZvciBtZXJnaW5nIHZhbHVlc1xuICAgIHN0eWxlLmRlZmluZXMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5zb3VyY2VzLm1hcCh4ID0+IHguZGVmaW5lcykuZmlsdGVyKHggPT4geCkpOyAvLyBpbnRlcm5hbCBkZWZpbmVzIChub3QgdXNlci1kZWZpbmVkKVxuICAgIHN0eWxlLm1hdGVyaWFsID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uc291cmNlcy5tYXAoeCA9PiB4Lm1hdGVyaWFsKS5maWx0ZXIoeCA9PiB4KSk7XG5cbiAgICAvLyBNaXggc2hhZGVyIHByb3BlcnRpZXNcbiAgICBTdHlsZU1hbmFnZXIubWl4U2hhZGVycyhzdHlsZSwgc3R5bGVzLCBzb3VyY2VzKTtcbiAgICByZXR1cm4gc3R5bGU7XG59O1xuXG4vLyBNaXggdGhlIHByb3BlcnRlcyBpbiB0aGUgXCJzaGFkZXJzXCIgYmxvY2tcblN0eWxlTWFuYWdlci5taXhTaGFkZXJzID0gZnVuY3Rpb24gKHN0eWxlLCBzdHlsZXMsIHNvdXJjZXMpIHtcbiAgICBsZXQgc2hhZGVycyA9IHt9OyAvLyBuZXdseSBtaXhlZCBzaGFkZXJzIHByb3BlcnRpZXNcbiAgICBsZXQgc2hhZGVyX21lcmdlcyA9IHNvdXJjZXMubWFwKHggPT4geC5zaGFkZXJzKS5maWx0ZXIoeCA9PiB4KTsgLy8ganVzdCB0aGUgc291cmNlIHN0eWxlcyB3aXRoIHNoYWRlciBwcm9wZXJ0aWVzXG5cbiAgICAvLyBEZWZpbmVzXG4gICAgc2hhZGVycy5kZWZpbmVzID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uc2hhZGVyX21lcmdlcy5tYXAoeCA9PiB4LmRlZmluZXMpLmZpbHRlcih4ID0+IHgpKTtcblxuICAgIC8vIFVuaWZvcm1zXG4gICAgc2hhZGVycy51bmlmb3JtcyA9IHt9OyAgLy8gdW5pZm9ybXMgZm9yIHRoaXMgc3R5bGUsIGJvdGggZXhwbGljaXRseSBkZWZpbmVkLCBhbmQgbWl4ZWQgZnJvbSBvdGhlciBzdHlsZXNcbiAgICBzaGFkZXJzLl91bmlmb3JtcyA9IChzdHlsZS5zaGFkZXJzICYmIHN0eWxlLnNoYWRlcnMudW5pZm9ybXMpIHx8IHt9OyAvLyB1bmlmb3JtcyBleHBsaWNpdGx5IGRlZmluZWQgYnkgKnRoaXMqIHN0eWxlXG4gICAgc2hhZGVycy5fdW5pZm9ybV9zY29wZXMgPSB7fTsgLy8gdHJhY2tzIHdoaWNoIHN0eWxlIGVhY2ggdW5pZm9ybSBvcmlnaW5hdGVkIGZyb20gKHRoaXMgb25lLCBvciBhbmNlc3RvcilcblxuICAgIC8vIE1peCBpbiB1bmlmb3JtcyBmcm9tIGFuY2VzdG9ycywgcHJvdmlkaW5nIG1lYW5zIHRvIGFjY2Vzc1xuICAgIHNvdXJjZXNcbiAgICAgICAgLmZpbHRlcih4ID0+IHguc2hhZGVycyAmJiB4LnNoYWRlcnMudW5pZm9ybXMpXG4gICAgICAgIC5mb3JFYWNoKHggPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgdSBpbiB4LnNoYWRlcnMudW5pZm9ybXMpIHtcbiAgICAgICAgICAgICAgICBzaGFkZXJzLl91bmlmb3JtX3Njb3Blc1t1XSA9IHgubmFtZTtcblxuICAgICAgICAgICAgICAgIC8vIERlZmluZSBnZXR0ZXIgYW5kIHNldHRlciBmb3IgdGhpcyB1bmlmb3JtXG4gICAgICAgICAgICAgICAgLy8gR2V0dGVyIHJldHVybnMgdmFsdWUgZm9yIHRoaXMgc3R5bGUgaWYgcHJlc2VudCwgb3RoZXJ3aXNlIGFza3MgYXBwcm9wcmlhdGUgYW5jZXN0b3IgZm9yIGl0XG4gICAgICAgICAgICAgICAgLy8gU2V0dGVyIHNldHMgdGhlIHZhbHVlIGZvciB0aGlzIHN0eWxlICh3aGV0aGVyIHByZXZpb3VzbHkgcHJlc2VudCBpbiB0aGlzIHN0eWxlIG9yIG5vdClcbiAgICAgICAgICAgICAgICAvLyBNaW1pY3MgSlMgcHJvdG90eXBlL2hhc093blByb3BlcnR5IGJlaGF2aW9yLCBidXQgd2l0aCBtdWx0aXBsZSBhbmNlc3RvcnMgKHZpYSBtaXhpbnMpXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNoYWRlcnMudW5pZm9ybXMsIHUsIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuaWZvcm0gaXMgZXhwbGljaXRseSBkZWZpbmVkIG9uIHRoaXMgc3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFkZXJzLl91bmlmb3Jtc1t1XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoYWRlcnMuX3VuaWZvcm1zW3VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5pZm9ybSB3YXMgbWl4ZWQgZnJvbSBhbm90aGVyIHN0eWxlLCBmb3J3YXJkIHJlcXVlc3QgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElkZW50aWZ5IGNoZWNrIGlzIG5lZWRlZCB0byBwcmV2ZW50IGluZmluaXRlIHJlY3Vyc2lvbiBpZiBhIHByZXZpb3VzbHkgZGVmaW5lZCB1bmlmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBzZXQgdG8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHlsZXNbc2hhZGVycy5fdW5pZm9ybV9zY29wZXNbdV1dLnNoYWRlcnMudW5pZm9ybXMgIT09IHNoYWRlcnMudW5pZm9ybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGVzW3NoYWRlcnMuX3VuaWZvcm1fc2NvcGVzW3VdXS5zaGFkZXJzLnVuaWZvcm1zW3VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFkZXJzLl91bmlmb3Jtc1t1XSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAvLyBFeHRlbnNpb25zOiBidWlsZCBhIGxpc3Qgb2YgdW5pcXVlIGV4dGVuc2lvbnNcbiAgICBzaGFkZXJzLmV4dGVuc2lvbnMgPSBPYmplY3Qua2V5cyhzaGFkZXJfbWVyZ2VzXG4gICAgICAgIC5tYXAoeCA9PiB4LmV4dGVuc2lvbnMpXG4gICAgICAgIC5maWx0ZXIoeCA9PiB4KVxuICAgICAgICAucmVkdWNlKChwcmV2LCBjdXIpID0+IHtcbiAgICAgICAgICAgIC8vIHNpbmdsZSBleHRlbnNpb25cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHByZXZbY3VyXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhcnJheSBvZiBleHRlbnNpb25zXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXIuZm9yRWFjaCh4ID0+IHByZXZbeF0gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9LCB7fSkgfHwge31cbiAgICApO1xuXG4gICAgLy8gU2hhZGVyIGJsb2Nrc1xuICAgIC8vIE1hcmsgYWxsIHNoYWRlciBibG9ja3MgZm9yIHRoZSB0YXJnZXQgc3R5bGUgYXMgb3JpZ2luYXRpbmcgd2l0aCBpdHMgb3duIG5hbWVcbiAgICBpZiAoc3R5bGUuc2hhZGVycyAmJiBzdHlsZS5zaGFkZXJzLmJsb2Nrcykge1xuICAgICAgICBzdHlsZS5zaGFkZXJzLmJsb2NrX3Njb3BlcyA9IHN0eWxlLnNoYWRlcnMuYmxvY2tfc2NvcGVzIHx8IHt9O1xuICAgICAgICBmb3IgKGxldCBbaywgYmxvY2tdIG9mIFV0aWxzLmVudHJpZXMoc3R5bGUuc2hhZGVycy5ibG9ja3MpKSB7XG4gICAgICAgICAgICBzdHlsZS5zaGFkZXJzLmJsb2NrX3Njb3Blc1trXSA9IHN0eWxlLnNoYWRlcnMuYmxvY2tfc2NvcGVzW2tdIHx8IFtdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYmxvY2spKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuc2hhZGVycy5ibG9ja19zY29wZXNba10ucHVzaCguLi5ibG9jay5tYXAoKCkgPT4gc3R5bGUubmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuc2hhZGVycy5ibG9ja19zY29wZXNba10ucHVzaChzdHlsZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1lcmdlIHNoYWRlciBibG9ja3MsIGtlZXBpbmcgdHJhY2sgb2Ygd2hpY2ggc3R5bGUgZWFjaCBibG9jayBvcmlnaW5hdGVkIGZyb21cbiAgICBsZXQgbWl4ZWQgPSB7fTsgLy8gYWxsIHNjb3BlcyBtaXhlZCBzbyBmYXJcbiAgICBmb3IgKGxldCBzb3VyY2Ugb2Ygc2hhZGVyX21lcmdlcykge1xuICAgICAgICBpZiAoIXNvdXJjZS5ibG9ja3MpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2hhZGVycy5ibG9ja3MgPSBzaGFkZXJzLmJsb2NrcyB8fCB7fTtcbiAgICAgICAgc2hhZGVycy5ibG9ja19zY29wZXMgPSBzaGFkZXJzLmJsb2NrX3Njb3BlcyB8fCB7fTtcbiAgICAgICAgbGV0IG1peGVkX3NvdXJjZSA9IHt9OyAvLyBzY29wZXMgbWl4ZWQgZm9yIHRoaXMgc291cmNlIHN0eWxlXG5cbiAgICAgICAgZm9yIChsZXQgW3QsIGJsb2NrXSBvZiBVdGlscy5lbnRyaWVzKHNvdXJjZS5ibG9ja3MpKSB7XG4gICAgICAgICAgICBsZXQgYmxvY2tfc2NvcGUgPSBzb3VyY2UuYmxvY2tfc2NvcGVzW3RdO1xuXG4gICAgICAgICAgICBzaGFkZXJzLmJsb2Nrc1t0XSA9IHNoYWRlcnMuYmxvY2tzW3RdIHx8IFtdO1xuICAgICAgICAgICAgc2hhZGVycy5ibG9ja19zY29wZXNbdF0gPSBzaGFkZXJzLmJsb2NrX3Njb3Blc1t0XSB8fCBbXTtcblxuICAgICAgICAgICAgLy8gc3RhbmRhcmRpemUgb24gYXJyYXlzIChibG9jayBjYW4gYmUgc2luZ2xlIG9yIG11bHRpLXZhbHVlKVxuICAgICAgICAgICAgYmxvY2sgPSBBcnJheS5pc0FycmF5KGJsb2NrKSA/IGJsb2NrIDogW2Jsb2NrXTtcbiAgICAgICAgICAgIGJsb2NrX3Njb3BlID0gQXJyYXkuaXNBcnJheShibG9ja19zY29wZSkgPyBibG9ja19zY29wZSA6IFtibG9ja19zY29wZV07XG5cbiAgICAgICAgICAgIGZvciAobGV0IGI9MDsgYiA8IGJsb2NrLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBibG9ja3Mgd2UndmUgYWxyZWFkeSBtaXhlZCBpbiBmcm9tIHRoZSBzYW1lIHNjb3BlXG4gICAgICAgICAgICAgICAgLy8gUmVwZWF0aW5nIHNjb3BlIGluZGljYXRlcyBhIGRpYW1vbmQgcGF0dGVybiB3aGVyZSBhIHN0eWxlIGlzIGJlaW5nIG1peGVkIG11bHRpcGxlIHRpbWVzXG4gICAgICAgICAgICAgICAgaWYgKG1peGVkW2Jsb2NrX3Njb3BlW2JdXSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWl4ZWRfc291cmNlW2Jsb2NrX3Njb3BlW2JdXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBzaGFkZXJzLmJsb2Nrc1t0XS5wdXNoKGJsb2NrW2JdKTtcbiAgICAgICAgICAgICAgICBzaGFkZXJzLmJsb2NrX3Njb3Blc1t0XS5wdXNoKGJsb2NrX3Njb3BlW2JdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBzdHlsZXMgbWl4ZWQgaW4gZnJvbSB0aGlzIHNvdXJjZSAtIHRoZXkgY291bGQgYmUgbXVsdGktbGV2ZWwgYW5jZXN0b3JzLFxuICAgICAgICAvLyBiZXlvbmQgdGhlIGZpcnN0LWxldmVsIFwicGFyZW50c1wiIGRlZmluZWQgaW4gdGhpcyBzdHlsZSdzIGBtaXhgIGxpc3RcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZS5taXhlZCwgbWl4ZWRfc291cmNlKTtcbiAgICB9XG5cbiAgICBzdHlsZS5zaGFkZXJzID0gc2hhZGVyczsgLy8gYXNzaWduIGJhY2sgdG8gc3R5bGVcbiAgICByZXR1cm4gc3R5bGU7XG59O1xuXG4vLyBDcmVhdGUgYSBuZXcgc3R5bGVcbi8vIG5hbWU6IG5hbWUgb2YgbmV3IHN0eWxlXG4vLyBjb25maWc6IHByb3BlcnRpZXMgb2YgbmV3IHN0eWxlXG4vLyBzdHlsZXM6IHdvcmtpbmcgc2V0IG9mIHN0eWxlcyBiZWluZyBidWlsdCAodXNlZCBmb3IgbWl4aW5nIGluIGV4aXN0aW5nIHN0eWxlcylcblN0eWxlTWFuYWdlci5jcmVhdGUgPSBmdW5jdGlvbiAobmFtZSwgY29uZmlnLCBzdHlsZXMgPSB7fSkge1xuICAgIGxldCBzdHlsZSA9IG1lcmdlT2JqZWN0cyh7fSwgY29uZmlnKTsgLy8gZGVlcCBjb3B5XG4gICAgc3R5bGUubmFtZSA9IG5hbWU7XG5cbiAgICAvLyBTdHlsZSBtaXhpbnNcbiAgICBzdHlsZSA9IFN0eWxlTWFuYWdlci5taXgoc3R5bGUsIHN0eWxlcyk7XG5cbiAgICAvLyBIYXMgYmFzZSBzdHlsZT9cbiAgICAvLyBPbmx5IHJlbmRlcmFibGUgKGluc3RhbnRpYXRlZCkgc3R5bGVzIHNob3VsZCBiZSBpbmNsdWRlZCBmb3IgcnVuLXRpbWUgdXNlXG4gICAgLy8gT3RoZXJzIGFyZSBpbnRlcm1lZGlhcnkvYWJzdHJhY3QsIHVzZWQgZHVyaW5nIHN0eWxlIGNvbXBvc2l0aW9uIGJ1dCBub3QgZXhlY3V0aW9uXG4gICAgaWYgKHN0eWxlLmJhc2UgJiYgQmFzZVN0eWxlc1tzdHlsZS5iYXNlXSkge1xuICAgICAgICBTdHlsZXNbbmFtZV0gPSBzdHlsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShCYXNlU3R5bGVzW3N0eWxlLmJhc2VdKSwgc3R5bGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbn07XG5cbi8vIENhbGxlZCB0byBjcmVhdGUgYW5kIGluaXRpYWxpemUgc3R5bGVzXG5TdHlsZU1hbmFnZXIuYnVpbGQgPSBmdW5jdGlvbiAoc3R5bGVzLCBzY2VuZSA9IHt9KSB7XG4gICAgLy8gU29ydCBzdHlsZXMgYnkgZGVwZW5kZW5jeSwgdGhlbiBidWlsZCB0aGVtXG4gICAgbGV0IHN0eWxlX2RlcHMgPSBPYmplY3Qua2V5cyhzdHlsZXMpLnNvcnQoXG4gICAgICAgIChhLCBiKSA9PiBTdHlsZU1hbmFnZXIuaW5oZXJpdGFuY2VEZXB0aChhLCBzdHlsZXMpIC0gU3R5bGVNYW5hZ2VyLmluaGVyaXRhbmNlRGVwdGgoYiwgc3R5bGVzKVxuICAgICk7XG5cbiAgICAvLyBPbmx5IGtlZXAgYnVpbHQtaW4gYmFzZSBzdHlsZXNcbiAgICBmb3IgKGxldCBzbmFtZSBpbiBTdHlsZXMpIHtcbiAgICAgICAgaWYgKCFCYXNlU3R5bGVzW3NuYW1lXSkge1xuICAgICAgICAgICAgZGVsZXRlIFN0eWxlc1tzbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBTdHlsZXNbc25hbWVdLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXb3JraW5nIHNldCBvZiBzdHlsZXMgYmVpbmcgYnVpbHRcbiAgICBsZXQgd3MgPSB7fTtcbiAgICBmb3IgKGxldCBzbmFtZSBvZiBzdHlsZV9kZXBzKSB7XG4gICAgICAgIHdzW3NuYW1lXSA9IFN0eWxlTWFuYWdlci5jcmVhdGUoc25hbWUsIHN0eWxlc1tzbmFtZV0sIHdzKTtcbiAgICB9XG5cbiAgICBTdHlsZU1hbmFnZXIuaW5pdFN0eWxlcyhzY2VuZSk7XG4gICAgcmV0dXJuIFN0eWxlcztcbn07XG5cbi8vIEluaXRpYWxpemUgYWxsIHN0eWxlc1xuU3R5bGVNYW5hZ2VyLmluaXRTdHlsZXMgPSBmdW5jdGlvbiAoc2NlbmUpIHtcbiAgICAvLyBJbml0aWFsaXplIGFsbFxuICAgIGZvciAobGV0IHNuYW1lIGluIFN0eWxlcykge1xuICAgICAgICBTdHlsZXNbc25hbWVdLmluaXQoc2NlbmUpO1xuICAgIH1cbn07XG5cbi8vIEdpdmVuIGEgc3R5bGUga2V5IGluIGEgc2V0IG9mIHN0eWxlcyB0byBhZGQsIGNvdW50IHRoZSBsZW5ndGggb2YgdGhlIGluaGVyaXRhbmNlIGNoYWluXG4vLyBUT0RPOiByZW1vdmUgY3VycmVudCAoU3R5bGVzKSBhbmQgZnV0dXJlIChzdHlsZXMpIGR1cGxpY2F0aW9uLCBjb25mdXNpbmdcblN0eWxlTWFuYWdlci5pbmhlcml0YW5jZURlcHRoID0gZnVuY3Rpb24gKGtleSwgc3R5bGVzKSB7XG4gICAgbGV0IHBhcmVudHMgPSAwO1xuXG4gICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICBsZXQgc3R5bGUgPSBzdHlsZXNba2V5XTtcbiAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHNjZW5lIGRlZiBlcnJvciwgdHJ5aW5nIHRvIGV4dGVuZCBhIHN0eWxlIHRoYXQgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXBlbmRlbmN5IGNoYWluIGVuZHMgd2hlbiB0aGlzIHN0eWxlIGlzbid0IG1peGluZyBpbiBhbnkgb3RoZXJzXG4gICAgICAgIGlmICghc3R5bGUubWl4KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYXZlcnNlIG5leHQgcGFyZW50IHN0eWxlXG4gICAgICAgIHBhcmVudHMrKztcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZS5taXgpKSB7XG4gICAgICAgICAgICAvLyBJZiBtdWx0aXBsZSBtaXhpbnMsIGZpbmQgdGhlIGRlZXBlc3Qgb25lXG4gICAgICAgICAgICBwYXJlbnRzICs9IE1hdGgubWF4KC4uLnN0eWxlLm1peC5tYXAocyA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5aW5nIHRvIG1peCBpbnRvIGl0c2VsZiFcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gU3R5bGVNYW5hZ2VyLmluaGVyaXRhbmNlRGVwdGgocywgc3R5bGVzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJ5aW5nIHRvIG1peCBpbnRvIGl0c2VsZiFcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHN0eWxlLm1peCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBzaW5nbGUgbWl4aW4sIGNvbnRpbnVlIGxvb3AgdXAgdGhlIHRyZWVcbiAgICAgICAgICAgIGtleSA9IHN0eWxlLm1peDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyZW50cztcbn07XG5cbi8vIENvbXBpbGUgYWxsIHN0eWxlc1xuU3R5bGVNYW5hZ2VyLmNvbXBpbGUgPSBmdW5jdGlvbiAoa2V5cywgc2NlbmUpIHtcbiAgICBrZXlzID0ga2V5cyB8fCBPYmplY3Qua2V5cyhTdHlsZXMpO1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGxldCBzdHlsZSA9IFN0eWxlc1trZXldO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3R5bGUuY29tcGlsZSgpO1xuICAgICAgICAgICAgbG9nLnRyYWNlKGBTdHlsZU1hbmFnZXIuY29tcGlsZSgpOiBjb21waWxlZCBzdHlsZSAke2tleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgbG9nLmVycm9yKGBTdHlsZU1hbmFnZXIuY29tcGlsZSgpOiBlcnJvciBjb21waWxpbmcgc3R5bGUgJHtrZXl9OmAsIGVycm9yKTtcblxuICAgICAgICAgICAgc2NlbmUudHJpZ2dlcignd2FybmluZycsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3R5bGVzJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRXJyb3IgY29tcGlsaW5nIHN0eWxlICR7a2V5fWAsXG4gICAgICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICAgICAgc2hhZGVyX2Vycm9yczogc3R5bGUucHJvZ3JhbSAmJiBzdHlsZS5wcm9ncmFtLnNoYWRlcl9lcnJvcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9nLmRlYnVnKGBTdHlsZU1hbmFnZXIuY29tcGlsZSgpOiBjb21waWxlZCBhbGwgc3R5bGVzYCk7XG59O1xuXG4vLyBHZXQgYWxsIHN0eWxlcyB3aXRoIG1lc2ggZGF0YSBmb3IgYSBnaXZlbiB0aWxlXG5TdHlsZU1hbmFnZXIuc3R5bGVzRm9yVGlsZSA9IGZ1bmN0aW9uICh0aWxlKSB7XG4gICAgbGV0IHN0eWxlcyA9IFtdO1xuICAgIGZvciAobGV0IHMgaW4gU3R5bGVzKSB7XG4gICAgICAgIGlmIChTdHlsZXNbc10uaGFzRGF0YUZvclRpbGUodGlsZSkpIHtcbiAgICAgICAgICAgIHN0eWxlcy5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG59O1xuIiwiaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBHZW8gZnJvbSAnLi4vZ2VvJztcblxuaW1wb3J0IHBhcnNlQ1NTQ29sb3IgZnJvbSAnY3NzY29sb3JwYXJzZXInO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCB2YXIgU3R5bGVQYXJzZXIgPSB7fTtcblxuLy8gU3R5bGUgbWFjcm9zXG5cblN0eWxlUGFyc2VyLmV4cGFuZE1hY3JvcyA9IGZ1bmN0aW9uIGV4cGFuZE1hY3JvcyAob2JqKSB7XG4gICAgZm9yICh2YXIgcCBpbiBvYmopIHtcbiAgICAgICAgdmFyIHZhbCA9IG9ialtwXTtcblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvYmpbcF0gPSBleHBhbmRNYWNyb3ModmFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IHN0cmluZ3MgYmFjayBpbnRvIGZ1bmN0aW9uc1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZm9yICh2YXIgbSBpbiBTdHlsZVBhcnNlci5tYWNyb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsLm1hdGNoKFN0eWxlUGFyc2VyLm1hY3Jvc1ttXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGY7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKmpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWwoJ2YgPSAnICsgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qanNoaW50IGlnbm9yZTplbmQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwXSA9IGY7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cudHJhY2UoYGV4cGFuZGVkIG1hY3JvICR7dmFsfSB0byAke2Z9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsbC1iYWNrIHRvIG9yaWdpbmFsIHZhbHVlIGlmIHBhcnNpbmcgZmFpbGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cudHJhY2UoYGZhaWxlZCB0byBleHBhbmQgbWFjcm8gJHt2YWx9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuLy8gTGlzdCBvZiBtYWNyb3NcblN0eWxlUGFyc2VyLm1hY3JvcyA9IFtcbiAgICAnU3R5bGUuY29sb3IucHNldWRvUmFuZG9tQ29sb3InLFxuICAgICdTdHlsZS5jb2xvci5yYW5kb21Db2xvcidcbl07XG5cblxuXG52YXIgU3R5bGUgPSB7fTtcblxuU3R5bGUuY29sb3IgPSB7XG4gICAgLy8gcHNldWRvLXJhbmRvbSBncmF5c2NhbGUgYnkgZ2VvbWV0cnkgaWRcbiAgICBwc2V1ZG9SYW5kb21HcmF5c2NhbGUoKSB7XG4gICAgICAgIHZhciBmdW5jID0gYGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGMgPSBNYXRoLm1heCgocGFyc2VJbnQoZmVhdHVyZS5pZCwgMTYpICUgMTAwKSAvIDEwMCwgMC40KTtcbiAgICAgICAgICAgIHJldHVybiBbMC43ICogYywgMC43ICogYywgMC43ICogY107XG4gICAgICAgIH1gO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICB9LFxuXG4gICAgLy8gcHNldWRvLXJhbmRvbSBjb2xvciBieSBnZW9tZXRyeSBpZFxuICAgIHBzZXVkb1JhbmRvbUNvbG9yKCkge1xuICAgICAgICB2YXIgZnVuYyA9IGBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgMC43ICogKHBhcnNlSW50KGZlYXR1cmUuaWQsIDE2KSAvIDEwMCAlIDEpLFxuICAgICAgICAgICAgICAgIDAuNyAqIChwYXJzZUludChmZWF0dXJlLmlkLCAxNikgLyAxMDAwMCAlIDEpLFxuICAgICAgICAgICAgICAgIDAuNyAqIChwYXJzZUludChmZWF0dXJlLmlkLCAxNikgLyAxMDAwMDAwICUgMSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1gO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgICAgLy8gcmV0dXJuIGBmdW5jdGlvbigpIHsgcmV0dXJuIFswLjcgKiAocGFyc2VJbnQoZmVhdHVyZS5pZCwgMTYpIC8gMTAwICUgMSksIDAuNyAqIChwYXJzZUludChmZWF0dXJlLmlkLCAxNikgLyAxMDAwMCAlIDEpLCAwLjcgKiAocGFyc2VJbnQoZmVhdHVyZS5pZCwgMTYpIC8gMTAwMDAwMCAlIDEpXTsgfWA7XG4gICAgfSxcblxuICAgIC8vIHJhbmRvbSBjb2xvclxuICAgIHJhbmRvbUNvbG9yKCkge1xuICAgICAgICB2YXIgZnVuYyA9IGBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBbMC43ICogTWF0aC5yYW5kb20oKSwgMC43ICogTWF0aC5yYW5kb20oKSwgMC43ICogTWF0aC5yYW5kb20oKV07XG4gICAgICAgIH1gO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICB9XG59O1xuXG4vLyBXcmFwcyBzdHlsZSBmdW5jdGlvbnMgYW5kIHByb3ZpZGVzIGEgc2NvcGUgb2YgY29tbW9ubHkgYWNjZXNzaWJsZSBkYXRhOlxuLy8gLSBmZWF0dXJlOiB0aGUgJ3Byb3BlcnRpZXMnIG9mIHRoZSBmZWF0dXJlLCBlLmcuIGFjY2Vzc2VkIGFzICdmZWF0dXJlLm5hbWUnXG4vLyAtICR6b29tOiB0aGUgY3VycmVudCBtYXAgem9vbSBsZXZlbFxuLy8gLSAkZ2VvbWV0cnk6IHRoZSB0eXBlIG9mIGdlb21ldHJ5LCAncG9pbnQnLCAnbGluZScsIG9yICdwb2x5Z29uJ1xuLy8gLSAkbWV0ZXJzX3Blcl9waXhlbDogY29udmVyc2lvbiBmb3IgbWV0ZXJzL3BpeGVscyBhdCBjdXJyZW50IG1hcCB6b29tXG4vLyAtIHByb3BlcnRpZXM6IHVzZXItZGVmaW5lZCBwcm9wZXJ0aWVzIG9uIHRoZSBzdHlsZS1ydWxlIG9iamVjdCBpbiB0aGUgc3R5bGVzaGVldFxuU3R5bGVQYXJzZXIud3JhcEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICB2YXIgZiA9IGBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBjb250ZXh0LmZlYXR1cmUucHJvcGVydGllcztcbiAgICAgICAgICAgICAgICB2YXIgJHpvb20gPSBjb250ZXh0Lnpvb207XG4gICAgICAgICAgICAgICAgdmFyICRsYXllciA9IGNvbnRleHQubGF5ZXI7XG4gICAgICAgICAgICAgICAgdmFyICRnZW9tZXRyeSA9IGNvbnRleHQuZ2VvbWV0cnk7XG4gICAgICAgICAgICAgICAgdmFyICRtZXRlcnNfcGVyX3BpeGVsID0gY29udGV4dC5tZXRlcnNfcGVyX3BpeGVsO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gY29udGV4dC5wcm9wZXJ0aWVzO1xuXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9ICgke2Z1bmN9KCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gbnVsbDsgLy8gY29udmVydCBOYU5zIHRvIG51bGxzXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1gO1xuICAgIHJldHVybiBmO1xufTtcblxuXG4vLyBTdHlsZSBwYXJzaW5nXG5cbi8vIFN0eWxlIGRlZmF1bHRzXG5TdHlsZVBhcnNlci5kZWZhdWx0cyA9IHtcbiAgICBjb2xvcjogWzEsIDEsIDEsIDFdLFxuICAgIHdpZHRoOiAxLFxuICAgIHNpemU6IDEsXG4gICAgZXh0cnVkZTogZmFsc2UsXG4gICAgaGVpZ2h0OiAyMCxcbiAgICBtaW5faGVpZ2h0OiAwLFxuICAgIG9yZGVyOiAwLFxuICAgIHo6IDAsXG4gICAgbWF0ZXJpYWw6IHtcbiAgICAgICAgYW1iaWVudDogMSxcbiAgICAgICAgZGlmZnVzZTogMVxuICAgIH1cbn07XG5cblxuLy8gQSBjb250ZXh0IG9iamVjdCB0aGF0IGlzIHBhc3NlZCB0byBzdHlsZSBwYXJzaW5nIGZ1bmN0aW9ucyB0byBwcm92aWRlIGEgc2NvcGUgb2YgY29tbW9ubHkgdXNlZCB2YWx1ZXNcblN0eWxlUGFyc2VyLmdldEZlYXR1cmVQYXJzZUNvbnRleHQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgdGlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZlYXR1cmUsXG4gICAgICAgIHRpbGUsXG4gICAgICAgIHpvb206IHRpbGUuc3R5bGVfem9vbSxcbiAgICAgICAgZ2VvbWV0cnk6IEdlby5nZW9tZXRyeVR5cGUoZmVhdHVyZS5nZW9tZXRyeS50eXBlKSxcbiAgICAgICAgbWV0ZXJzX3Blcl9waXhlbDogR2VvLm1ldGVyc1BlclBpeGVsKHRpbGUuY29vcmRzLnopLFxuICAgICAgICB1bml0c19wZXJfbWV0ZXI6IEdlby51bml0c19wZXJfbWV0ZXJbdGlsZS5jb29yZHMuel1cbiAgICB9O1xufTtcblxuLy8gQnVpbGQgYSBzdHlsZSBwYXJhbSBjYWNoZSBvYmplY3Rcbi8vIGB2YWx1ZWAgaXMgcmF3IHZhbHVlLCBjYWNoZSBtZXRob2RzIHdpbGwgYWRkIG90aGVyIHByb3BlcnRpZXMgYXMgbmVlZGVkXG4vLyBgdHJhbnNmb3JtYCBpcyBvcHRpb25hbCB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gcnVuIG9uIHZhbHVlcyAoZXhjZXB0IGZ1bmN0aW9uIHZhbHVlcylcblN0eWxlUGFyc2VyLmNhY2hlT2JqZWN0ID0gZnVuY3Rpb24gKG9iaiwgdHJhbnNmb3JtID0gbnVsbCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9iai52YWx1ZSkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogb2JqLnZhbHVlIH07IC8vIGNsb25lIGV4aXN0aW5nIGNhY2hlIG9iamVjdFxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikgJiYgQXJyYXkuaXNBcnJheShvYmpbMF0pKSB7IC8vIHpvb20gc3RvcHNcbiAgICAgICAgICAgIG9iaiA9IG9iai5tYXAodiA9PiBbdlswXSwgdHJhbnNmb3JtKHZbMV0pXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJykgeyAvLyBkb24ndCB0cmFuc2Zvcm0gZnVuY3Rpb25zXG4gICAgICAgICAgICBvYmogPSB0cmFuc2Zvcm0ob2JqKTsgLy8gc2luZ2xlIHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyB2YWx1ZTogb2JqIH07XG59O1xuXG4vLyBJbnRlcnBvbGF0aW9uIGFuZCBjYWNoaW5nIGZvciBhIGdlbmVyaWMgcHJvcGVydHkgKG5vdCBhIGNvbG9yIG9yIGRpc3RhbmNlKVxuLy8geyB2YWx1ZTogb3JpZ2luYWwsIHN0YXRpYzogdmFsLCB6b29tOiB7IDE6IHZhbDEsIDI6IHZhbDIsIC4uLiB9LCBkeW5hbWljOiBmdW5jdGlvbigpey4uLn0gfVxuU3R5bGVQYXJzZXIuY2FjaGVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHZhbCwgY29udGV4dCkge1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbC5keW5hbWljKSB7IC8vIGZ1bmN0aW9uLCBjb21wdXRlIGVhY2ggdGltZSAobm8gY2FjaGluZylcbiAgICAgICAgbGV0IHYgPSB2YWwuZHluYW1pYyhjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbC5zdGF0aWMpIHsgLy8gc2luZ2xlIHN0YXRpYyB2YWx1ZVxuICAgICAgICByZXR1cm4gdmFsLnN0YXRpYztcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsLnpvb20gJiYgdmFsLnpvb21bY29udGV4dC56b29tXSkgeyAvLyBpbnRlcnBvbGF0ZWQsIGNhY2hlZFxuICAgICAgICByZXR1cm4gdmFsLnpvb21bY29udGV4dC56b29tXTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIG5vdCB5ZXQgZXZhdWxhdGVkIGZvciBjYWNoZVxuICAgICAgICAvLyBEeW5hbWljIGZ1bmN0aW9uLWJhc2VkXG4gICAgICAgIGlmICh0eXBlb2YgdmFsLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWwuZHluYW1pYyA9IHZhbC52YWx1ZTtcbiAgICAgICAgICAgIGxldCB2ID0gdmFsLmR5bmFtaWMoY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheSBvZiB6b29tLWludGVycG9sYXRlZCBzdG9wcywgZS5nLiBbem9vbSwgdmFsdWVdIHBhaXJzXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsLnZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHZhbC52YWx1ZVswXSkpIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB2YWx1ZSBmb3IgY3VycmVudCB6b29tXG4gICAgICAgICAgICB2YWwuem9vbSA9IHZhbC56b29tIHx8IHt9O1xuICAgICAgICAgICAgdmFsLnpvb20gPSB7fTtcbiAgICAgICAgICAgIHZhbC56b29tW2NvbnRleHQuem9vbV0gPSBVdGlscy5pbnRlcnBvbGF0ZShjb250ZXh0Lnpvb20sIHZhbC52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnpvb21bY29udGV4dC56b29tXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5nbGUgc3RhdGljIHZhbHVlXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsLnN0YXRpYyA9IHZhbC52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWwuc3RhdGljO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuU3R5bGVQYXJzZXIuY29udmVydFVuaXRzID0gZnVuY3Rpb24odmFsLCBjb250ZXh0LCBjb252ZXJ0ID0gJ21ldGVycycpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHVuaXRzID0gdmFsLm1hdGNoKC8oWzAtOS4tXSspKFthLXpdKykvKTtcbiAgICAgICAgaWYgKHVuaXRzICYmIHVuaXRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdCh1bml0c1sxXSk7XG4gICAgICAgICAgICB1bml0cyA9IHVuaXRzWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udmVydCB0byBtZXRlcnNcbiAgICAgICAgaWYgKGNvbnZlcnQgPT09ICdtZXRlcnMnKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGZyb20gcGl4ZWxzXG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdweCcpIHtcbiAgICAgICAgICAgICAgICB2YWwgKj0gR2VvLm1ldGVyc1BlclBpeGVsKGNvbnRleHQuem9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGZyb20ga2lsb21ldGVyc1xuICAgICAgICAgICAgZWxzZSBpZiAodW5pdHMgPT09ICdrbScpIHtcbiAgICAgICAgICAgICAgICB2YWwgKj0gMTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgLy8gQXJyYXkgb2YgYXJyYXlzLCBlLmcuIHpvb20taW50ZXJwb2xhdGVkIHN0b3BzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbFswXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwubWFwKHYgPT4geyByZXR1cm4gW3ZbMF0sIFN0eWxlUGFyc2VyLmNvbnZlcnRVbml0cyh2WzFdLCBjb250ZXh0LCBjb252ZXJ0KV07IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IG9mIHZhbHVlc1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwubWFwKHYgPT4geyByZXR1cm4gU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHYsIGNvbnRleHQsIGNvbnZlcnQpOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufTtcblxuLy8gVGFrZXMgYSBkaXN0YW5jZSBjYWNoZSBvYmplY3QgYW5kIHJldHVybnMgYSBkaXN0YW5jZSB2YWx1ZSBmb3IgdGhpcyB6b29tXG4vLyAoY2FjaGluZyB0aGUgcmVzdWx0IGZvciBmdXR1cmUgdXNlKVxuLy8geyB2YWx1ZTogb3JpZ2luYWwsIHpvb206IHsgejogbWV0ZXJzIH0sIGR5bmFtaWM6IGZ1bmN0aW9uKCl7Li4ufSB9XG5TdHlsZVBhcnNlci5jYWNoZURpc3RhbmNlID0gZnVuY3Rpb24odmFsLCBjb250ZXh0LCBjb252ZXJ0ID0gJ21ldGVycycpIHtcbiAgICBpZiAodmFsLmR5bmFtaWMpIHtcbiAgICAgICAgbGV0IHYgPSB2YWwuZHluYW1pYyhjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbC56b29tICYmIHZhbC56b29tW2NvbnZlcnRdICYmIHZhbC56b29tW2NvbnZlcnRdW2NvbnRleHQuem9vbV0pIHtcbiAgICAgICAgcmV0dXJuIHZhbC56b29tW2NvbnZlcnRdW2NvbnRleHQuem9vbV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBEeW5hbWljIGZ1bmN0aW9uLWJhc2VkXG4gICAgICAgIGlmICh0eXBlb2YgdmFsLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWwuZHluYW1pYyA9IHZhbC52YWx1ZTtcbiAgICAgICAgICAgIGxldCB2ID0gdmFsLmR5bmFtaWMoY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheSBvZiB6b29tLWludGVycG9sYXRlZCBzdG9wcywgZS5nLiBbem9vbSwgdmFsdWVdIHBhaXJzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHZhbHVlIGZvciBjdXJyZW50IHpvb21cbiAgICAgICAgICAgIHZhbC56b29tID0gdmFsLnpvb20gfHwge307XG4gICAgICAgICAgICBsZXQgenVuaXRzID0gdmFsLnpvb21bY29udmVydF0gPSB2YWwuem9vbVtjb252ZXJ0XSB8fCB7fTtcblxuICAgICAgICAgICAgenVuaXRzW2NvbnRleHQuem9vbV0gPSBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModmFsLnZhbHVlLCBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGNvbnZlcnQgPT09ICdtZXRlcnMnICYmICdtZXRlcnMnKTsgLy8gY29udmVydCB0byBtZXRlcnNcbiAgICAgICAgICAgIHp1bml0c1tjb250ZXh0Lnpvb21dID0gVXRpbHMuaW50ZXJwb2xhdGUoY29udGV4dC56b29tLCB6dW5pdHNbY29udGV4dC56b29tXSk7XG5cbiAgICAgICAgICAgIHJldHVybiB6dW5pdHNbY29udGV4dC56b29tXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIENhY2hlIHByZXZpb3VzbHkgcGFyc2VkIGNvbG9yIHN0cmluZ3NcblN0eWxlUGFyc2VyLnN0cmluZ19jb2xvcnMgPSB7fTtcblN0eWxlUGFyc2VyLmNvbG9yRm9yU3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgLy8gQ2FjaGVkXG4gICAgaWYgKFN0eWxlUGFyc2VyLnN0cmluZ19jb2xvcnNbc3RyaW5nXSkge1xuICAgICAgICByZXR1cm4gU3R5bGVQYXJzZXIuc3RyaW5nX2NvbG9yc1tzdHJpbmddO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBhbmQgY2FjaGVcbiAgICBsZXQgY29sb3IgPSBwYXJzZUNTU0NvbG9yLnBhcnNlQ1NTQ29sb3Ioc3RyaW5nKTtcbiAgICBpZiAoY29sb3IgJiYgY29sb3IubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIGNvbG9yWzBdIC89IDI1NTtcbiAgICAgICAgY29sb3JbMV0gLz0gMjU1O1xuICAgICAgICBjb2xvclsyXSAvPSAyNTU7XG4gICAgICAgIGNvbG9yWzNdID0gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbG9yID0gU3R5bGVQYXJzZXIuZGVmYXVsdHMuY29sb3I7XG4gICAgfVxuICAgIFN0eWxlUGFyc2VyLnN0cmluZ19jb2xvcnNbc3RyaW5nXSA9IGNvbG9yO1xuICAgIHJldHVybiBjb2xvcjtcbn07XG5cbi8vIFRha2VzIGEgY29sb3IgY2FjaGUgb2JqZWN0IGFuZCByZXR1cm5zIGEgY29sb3IgdmFsdWUgZm9yIHRoaXMgem9vbVxuLy8gKGNhY2hpbmcgdGhlIHJlc3VsdCBmb3IgZnV0dXJlIHVzZSlcbi8vIHsgdmFsdWU6IG9yaWdpbmFsLCBzdGF0aWM6IFtyLGcsYixhXSwgem9vbTogeyB6OiBbcixnLGIsYV0gfSwgZHluYW1pYzogZnVuY3Rpb24oKXsuLi59IH1cblN0eWxlUGFyc2VyLmNhY2hlQ29sb3IgPSBmdW5jdGlvbih2YWwsIGNvbnRleHQgPSB7fSkge1xuICAgIGlmICh2YWwuZHluYW1pYykge1xuICAgICAgICBsZXQgdiA9IHZhbC5keW5hbWljKGNvbnRleHQpO1xuICAgICAgICBpZiAodiAmJiB2WzNdID09IG51bGwpIHtcbiAgICAgICAgICAgIHZbM10gPSAxOyAvLyBkZWZhdWx0IGFscGhhXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbC5zdGF0aWMpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5zdGF0aWM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbC56b29tICYmIHZhbC56b29tW2NvbnRleHQuem9vbV0pIHtcbiAgICAgICAgcmV0dXJuIHZhbC56b29tW2NvbnRleHQuem9vbV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBEeW5hbWljIGZ1bmN0aW9uLWJhc2VkIGNvbG9yXG4gICAgICAgIGlmICh0eXBlb2YgdmFsLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWwuZHluYW1pYyA9IHZhbC52YWx1ZTtcbiAgICAgICAgICAgIGxldCB2ID0gdmFsLmR5bmFtaWMoY29udGV4dCk7XG4gICAgICAgICAgICBpZiAodiAmJiB2WzNdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2WzNdID0gMTsgLy8gZGVmYXVsdCBhbHBoYVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luZ2xlIHN0cmluZyBjb2xvclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsLnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsLnN0YXRpYyA9IFN0eWxlUGFyc2VyLmNvbG9yRm9yU3RyaW5nKHZhbC52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnN0YXRpYztcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheSBvZiB6b29tLWludGVycG9sYXRlZCBzdG9wcywgZS5nLiBbem9vbSwgY29sb3JdIHBhaXJzXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsLnZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHZhbC52YWx1ZVswXSkpIHtcbiAgICAgICAgICAgIGlmICghdmFsLnpvb20pIHtcbiAgICAgICAgICAgICAgICB2YWwuem9vbSA9IHt9O1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFueSBzdHJpbmcgY29sb3JzIGluc2lkZSBzdG9wc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaSA8IHZhbC52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdiA9IHZhbC52YWx1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgJiYgdHlwZW9mIHZbMV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2WzFdID0gU3R5bGVQYXJzZXIuY29sb3JGb3JTdHJpbmcodlsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBjb2xvciBmb3IgY3VycmVudCB6b29tXG4gICAgICAgICAgICB2YWwuem9vbVtjb250ZXh0Lnpvb21dID0gVXRpbHMuaW50ZXJwb2xhdGUoY29udGV4dC56b29tLCB2YWwudmFsdWUpO1xuICAgICAgICAgICAgdmFsLnpvb21bY29udGV4dC56b29tXVszXSA9IHZhbC56b29tW2NvbnRleHQuem9vbV1bM10gfHwgMTsgLy8gZGVmYXVsdCBhbHBoYVxuICAgICAgICAgICAgcmV0dXJuIHZhbC56b29tW2NvbnRleHQuem9vbV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luZ2xlIGFycmF5IGNvbG9yXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsLnN0YXRpYyA9IHZhbC52YWx1ZTtcbiAgICAgICAgICAgIGlmICh2YWwuc3RhdGljICYmIHZhbC5zdGF0aWNbM10gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbC5zdGF0aWNbM10gPSAxOyAvLyBkZWZhdWx0IGFscGhhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsLnN0YXRpYztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblN0eWxlUGFyc2VyLnBhcnNlQ29sb3IgPSBmdW5jdGlvbih2YWwsIGNvbnRleHQgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbCA9IHZhbChjb250ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBQYXJzZSBDU1Mtc3R5bGUgY29sb3JzXG4gICAgLy8gVE9ETzogY2hhbmdlIGFsbCBjb2xvcnMgdG8gdXNlIDAtMjU1IHJhbmdlIGludGVybmFsbHkgdG8gYXZvaWQgZGl2aWRpbmcgYW5kIHRoZW4gcmUtbXVsdGlwbHlpbmcgaW4gZ2VvbSBidWlsZGVyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbCA9IFN0eWxlUGFyc2VyLmNvbG9yRm9yU3RyaW5nKHZhbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSAmJiBBcnJheS5pc0FycmF5KHZhbFswXSkpIHtcbiAgICAgICAgLy8gQXJyYXkgb2Ygem9vbS1pbnRlcnBvbGF0ZWQgc3RvcHMsIGUuZy4gW3pvb20sIGNvbG9yXSBwYWlyc1xuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2ID0gdmFsW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2WzFdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZbMV0gPSBTdHlsZVBhcnNlci5jb2xvckZvclN0cmluZyh2WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lnpvb20pIHtcbiAgICAgICAgICAgIHZhbCA9IFV0aWxzLmludGVycG9sYXRlKGNvbnRleHQuem9vbSwgdmFsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHRzXG4gICAgaWYgKHZhbCkge1xuICAgICAgICAvLyBhbHBoYVxuICAgICAgICBpZiAodmFsWzNdID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbFszXSA9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbCA9IFswLCAwLCAwLCAxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xufTtcblxuU3R5bGVQYXJzZXIuY2FsY3VsYXRlT3JkZXIgPSBmdW5jdGlvbihvcmRlciwgY29udGV4dCkge1xuICAgIC8vIENvbXB1dGVkIG9yZGVyXG4gICAgaWYgKHR5cGVvZiBvcmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvcmRlciA9IG9yZGVyKGNvbnRleHQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIE9yZGVyIHRpZWQgdG8gZmVhdHVyZSBwcm9wZXJ0eVxuICAgICAgICBpZiAoY29udGV4dC5mZWF0dXJlLnByb3BlcnRpZXNbb3JkZXJdKSB7XG4gICAgICAgICAgICBvcmRlciA9IGNvbnRleHQuZmVhdHVyZS5wcm9wZXJ0aWVzW29yZGVyXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHBsaWNpdCBvcmRlciB2YWx1ZVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9yZGVyID0gcGFyc2VGbG9hdChvcmRlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3JkZXI7XG59O1xuIiwiaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBCdWlsZGVycyBmcm9tICcuLi9idWlsZGVycyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbnZhc1RleHQge1xuXG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAndHJhbnNwYXJlbnQnOyAvLyByZW5kZXIgdGV4dCBvbiB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kXG4gICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgfVxuXG4gICAgcmVzaXplICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBTZXQgZm9udCBzdHlsZSBwYXJhbXMgZm9yIGNhbnZhcyBkcmF3aW5nXG4gICAgc2V0Rm9udCAodGlsZSwgeyBmb250X2NzcywgZmlsbCwgc3Ryb2tlLCBzdHJva2Vfd2lkdGgsIHB4X3NpemUgfSkge1xuICAgICAgICB0aGlzLnB4X3NpemUgPSBweF9zaXplO1xuICAgICAgICB0aGlzLnRleHRfYnVmZmVyID0gODsgLy8gcGl4ZWwgcGFkZGluZyBhcm91bmQgdGV4dFxuICAgICAgICBsZXQgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICAgIGN0eC5mb250ID0gZm9udF9jc3M7XG4gICAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2Vfd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBudWxsO1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGw7XG4gICAgICAgIGN0eC5taXRlckxpbWl0ID0gMjtcbiAgICB9XG5cbiAgICB0ZXh0U2l6ZXMgKHRpbGUsIHRleHRzKSB7XG4gICAgICAgIGZvciAobGV0IHN0eWxlIGluIHRleHRzKSB7XG4gICAgICAgICAgICBsZXQgdGV4dF9pbmZvcyA9IHRleHRzW3N0eWxlXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgdGV4dCBpbiB0ZXh0X2luZm9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHRfc2V0dGluZ3MgPSB0ZXh0X2luZm9zW3RleHRdLnRleHRfc2V0dGluZ3M7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRleHQgc2l6ZXNcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZvbnQodGlsZSwgdGV4dF9zZXR0aW5ncyk7IC8vIFRPRE86IG9ubHkgc2V0IG9uY2UgYWJvdmVcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICAgICAgICB0ZXh0X2luZm9zW3RleHRdLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRTaXplKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0X3NldHRpbmdzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRfc2V0dGluZ3MudGV4dF93cmFwXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHRzO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGVzIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGV4dCBiYXNlZCBvbiBjdXJyZW50IGZvbnQgc3R5bGVcbiAgICAvLyBJbmNsdWRlcyB3b3JkIHdyYXBwaW5nLCByZXR1cm5zIHNpemUgaW5mbyBmb3Igd2hvbGUgdGV4dCBibG9jayBhbmQgaW5kaXZpZHVhbCBsaW5lc1xuICAgIHRleHRTaXplICh0ZXh0LCB0aWxlLCB0cmFuc2Zvcm0sIHRleHRfd3JhcCkge1xuICAgICAgICBsZXQgc3RyID0gdGhpcy5hcHBseVRleHRUcmFuc2Zvcm0odGV4dCwgdHJhbnNmb3JtKTtcbiAgICAgICAgbGV0IGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IHRoaXMudGV4dF9idWZmZXIgKiBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW87XG4gICAgICAgIGxldCBsZWFkaW5nID0gMiAqIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbzsgLy8gbWFrZSBjb25maWd1cmFibGUgYW5kL29yIHVzZSBDYW52YXMgVGV4dE1ldHJpY3Mgd2hlbiBhdmFpbGFibGVcbiAgICAgICAgbGV0IGxpbmVfaGVpZ2h0ID0gdGhpcy5weF9zaXplICsgbGVhZGluZzsgLy8gcHhfc2l6ZSBhbHJlYWR5IGluIGRldmljZSBwaXhlbHNcblxuICAgICAgICAvLyBXb3JkIHdyYXBwaW5nXG4gICAgICAgIC8vIExpbmUgYnJlYWtzIGNhbiBiZSBjYXVzZWQgYnk6XG4gICAgICAgIC8vICAtIGltcGxpY2l0IGxpbmUgYnJlYWsgd2hlbiBhIG1heGltdW0gY2hhcmFjdGVyIHRocmVzaG9sZCBpcyBleGNlZWRlZCBwZXIgbGluZSAodGV4dF93cmFwKVxuICAgICAgICAvLyAgLSBleHBsaWNpdCBsaW5lIGJyZWFrIGluIHRoZSBsYWJlbCB0ZXh0IChcXG4pXG4gICAgICAgIGxldCB3b3JkcztcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0X3dyYXAgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB3b3JkcyA9IHN0ci5zcGxpdCgnICcpOyAvLyBzcGxpdCB3b3JkcyBvbiBzcGFjZXNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdvcmRzID0gW3N0cl07IC8vIG5vIG1heCBsaW5lIHdvcmQgd3JhcHBpbmcgKGJ1dCBuZXcgbGluZXMgd2lsbCBzdGlsbCBiZSBpbiBlZmZlY3QpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld19saW5lX3RlbXBsYXRlID0geyB3aWR0aDogMCwgY2hhcnM6IDAsIHRleHQ6ICcnIH07XG4gICAgICAgIGxldCBsaW5lID0gT2JqZWN0LmFzc2lnbih7fSwgbmV3X2xpbmVfdGVtcGxhdGUpOyAvLyBjdXJyZW50IGxpbmVcbiAgICAgICAgbGV0IGxpbmVzID0gW107IC8vIGNvbXBsZXRlZCBsaW5lc1xuICAgICAgICBsZXQgbWF4X3dpZHRoID0gMDsgLy8gbWF4IHdpZHRoIHRvIGZpdCBhbGwgbGluZXNcblxuICAgICAgICAvLyBhZGQgY3VycmVudCBsaW5lIGJ1ZmZlciB0byBjb21wbGV0ZWQgbGluZXMsIG9wdGlvbmFsbHkgc3RhcnQgbmV3IGxpbmVcbiAgICAgICAgZnVuY3Rpb24gYWRkTGluZSAobmV3X2xpbmUpIHtcbiAgICAgICAgICAgIGxpbmUudGV4dCA9IGxpbmUudGV4dC50cmltKCk7XG4gICAgICAgICAgICBpZiAobGluZS50ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsaW5lLndpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxpbmUudGV4dCkud2lkdGg7XG4gICAgICAgICAgICAgICAgbWF4X3dpZHRoID0gTWF0aC5tYXgobWF4X3dpZHRoLCBNYXRoLmNlaWwobGluZS53aWR0aCkpO1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3X2xpbmUpIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gT2JqZWN0LmFzc2lnbih7fSwgbmV3X2xpbmVfdGVtcGxhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QgaXRlcmF0ZSBvbiBzcGFjZS1icmVhayBncm91cHMgKHdpbGwgYmUgb25lIGlmIG1heCBsaW5lIGxlbmd0aCBvZmYpLCB0aGVuIGl0ZXJhdGUgb24gbGluZS1icmVhayBncm91cHNcbiAgICAgICAgZm9yIChsZXQgdz0wOyB3IDwgd29yZHMubGVuZ3RoOyB3KyspIHtcbiAgICAgICAgICAgIGxldCBicmVha3MgPSB3b3Jkc1t3XS5zcGxpdCgnXFxuJyk7IC8vIHNwbGl0IG9uIGxpbmUgYnJlYWtzXG5cbiAgICAgICAgICAgIGZvciAobGV0IG49MDsgbiA8IGJyZWFrcy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICAgIGxldCB3b3JkID0gYnJlYWtzW25dO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgYWRkaW5nIGN1cnJlbnQgd29yZCB3b3VsZCBvdmVyZmxvdywgYWRkIGEgbmV3IGxpbmUgaW5zdGVhZFxuICAgICAgICAgICAgICAgIGlmIChsaW5lLmNoYXJzICsgd29yZC5sZW5ndGggPiB0ZXh0X3dyYXAgJiYgbGluZS5jaGFycyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkTGluZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgY3VycmVudCB3b3JkIChwbHVzIHNwYWNlKVxuICAgICAgICAgICAgICAgIGxpbmUuY2hhcnMgKz0gd29yZC5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIGxpbmUudGV4dCArPSB3b3JkICsgJyAnO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgbGluZSBicmVha3MgcHJlc2VudCwgYWRkIG5ldyBsaW5lICh1bmxlc3Mgb24gbGFzdCBsaW5lKVxuICAgICAgICAgICAgICAgIGlmIChicmVha3MubGVuZ3RoID4gMSAmJiBuIDwgYnJlYWtzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkTGluZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRkTGluZShmYWxzZSk7XG5cbiAgICAgICAgLy8gRmluYWwgZGltZW5zaW9ucyBvZiB0ZXh0XG4gICAgICAgIGxldCBoZWlnaHQgPSBsaW5lcy5sZW5ndGggKiBsaW5lX2hlaWdodDtcblxuICAgICAgICBsZXQgY29sbGlzaW9uX3NpemUgPSBbXG4gICAgICAgICAgICBtYXhfd2lkdGggLyBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8sXG4gICAgICAgICAgICBoZWlnaHQgLyBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW9cbiAgICAgICAgXTtcblxuICAgICAgICBsZXQgdGV4dHVyZV9zaXplID0gW1xuICAgICAgICAgICAgbWF4X3dpZHRoICsgYnVmZmVyICogMixcbiAgICAgICAgICAgIGhlaWdodCArIGJ1ZmZlciAqIDJcbiAgICAgICAgXTtcblxuICAgICAgICBsZXQgbG9naWNhbF9zaXplID0gdGV4dHVyZV9zaXplLm1hcCh2ID0+IHYgLyBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8pO1xuXG4gICAgICAgIC8vIFJldHVybnMgbGluZXMgKHcvcGVyLWxpbmUgaW5mbyBmb3IgZHJhd2luZykgYW5kIHRleHQncyBvdmVyYWxsIGJvdW5kaW5nIGJveCArIGNhbnZhcyBzaXplXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lcyxcbiAgICAgICAgICAgIHNpemU6IHsgY29sbGlzaW9uX3NpemUsIHRleHR1cmVfc2l6ZSwgbG9naWNhbF9zaXplLCBsaW5lX2hlaWdodCB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRHJhdyBvbmUgb3IgbW9yZSBsaW5lcyBvZiB0ZXh0IGF0IHNwZWNpZmllZCBsb2NhdGlvbiwgYWRqdXN0aW5nIGZvciBidWZmZXIgYW5kIGJhc2VsaW5lXG4gICAgZHJhd1RleHQgKGxpbmVzLCBbeCwgeV0sIHNpemUsIHRpbGUsIHsgc3Ryb2tlLCB0cmFuc2Zvcm0sIGFsaWduIH0pIHtcbiAgICAgICAgYWxpZ24gPSBhbGlnbiB8fCAnY2VudGVyJztcblxuICAgICAgICBmb3IgKGxldCBsaW5lX251bT0wOyBsaW5lX251bSA8IGxpbmVzLmxlbmd0aDsgbGluZV9udW0rKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBsaW5lc1tsaW5lX251bV07XG4gICAgICAgICAgICBsZXQgc3RyID0gdGhpcy5hcHBseVRleHRUcmFuc2Zvcm0obGluZS50ZXh0LCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgbGV0IGJ1ZmZlciA9IHRoaXMudGV4dF9idWZmZXIgKiBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW87XG4gICAgICAgICAgICBsZXQgdGV4dHVyZV9zaXplID0gc2l6ZS50ZXh0dXJlX3NpemU7XG4gICAgICAgICAgICBsZXQgbGluZV9oZWlnaHQgPSBzaXplLmxpbmVfaGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBUZXh0IGFsaWdubWVudFxuICAgICAgICAgICAgbGV0IHR4O1xuICAgICAgICAgICAgaWYgKGFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICB0eCA9IHggKyBidWZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICB0eCA9IHggKyB0ZXh0dXJlX3NpemVbMF0vMiAtIGxpbmUud2lkdGgvMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgdHggPSB4ICsgdGV4dHVyZV9zaXplWzBdIC0gbGluZS53aWR0aCAtIGJ1ZmZlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW4gdGhlIGFic2VuY2Ugb2YgYmV0dGVyIENhbnZhcyBUZXh0TWV0cmljcyAobm90IHN1cHBvcnRlZCBieSBicm93c2VycyB5ZXQpLFxuICAgICAgICAgICAgLy8gMC43NSBidWZmZXIgcHJvZHVjZXMgYSBiZXR0ZXIgYXBwcm94aW1hdGUgdmVydGljYWwgY2VudGVyaW5nIG9mIHRleHRcbiAgICAgICAgICAgIGxldCB0eSA9IHkgKyBidWZmZXIgKiAwLjc1ICsgKGxpbmVfbnVtICsgMSkgKiBsaW5lX2hlaWdodDtcblxuICAgICAgICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zdHJva2VUZXh0KHN0ciwgdHgsIHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsVGV4dChzdHIsIHR4LCB0eSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByYXN0ZXJpemUgKHRpbGUsIHRleHRzLCB0ZXh0dXJlX3NpemUpIHtcbiAgICAgICAgZm9yIChsZXQgc3R5bGUgaW4gdGV4dHMpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0X2luZm9zID0gdGV4dHNbc3R5bGVdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB0ZXh0IGluIHRleHRfaW5mb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5mbyA9IHRleHRfaW5mb3NbdGV4dF07XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldEZvbnQodGlsZSwgaW5mby50ZXh0X3NldHRpbmdzKTsgLy8gVE9ETzogb25seSBzZXQgb25jZSBhYm92ZVxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1RleHQoaW5mby5saW5lcywgaW5mby5wb3NpdGlvbiwgaW5mby5zaXplLCB0aWxlLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogaW5mby50ZXh0X3NldHRpbmdzLnN0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBpbmZvLnRleHRfc2V0dGluZ3MudHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgICAgICBhbGlnbjogaW5mby50ZXh0X3NldHRpbmdzLmFsaWduXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpbmZvLnRleGNvb3JkcyA9IEJ1aWxkZXJzLmdldFRleGNvb3Jkc0ZvclNwcml0ZShcbiAgICAgICAgICAgICAgICAgICAgaW5mby5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgaW5mby5zaXplLnRleHR1cmVfc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZV9zaXplXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFRleHR1cmVUZXh0UG9zaXRpb25zICh0ZXh0cykge1xuICAgICAgICAvLyBGaW5kIHdpZGVzdCBsYWJlbCBhbmQgc3VtIG9mIGFsbCBsYWJlbCBoZWlnaHRzXG4gICAgICAgIGxldCB3aWRlc3QgPSAwLCBoZWlnaHQgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IHN0eWxlIGluIHRleHRzKSB7XG4gICAgICAgICAgICBsZXQgdGV4dF9pbmZvcyA9IHRleHRzW3N0eWxlXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgdGV4dCBpbiB0ZXh0X2luZm9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHRfaW5mbyA9IHRleHRfaW5mb3NbdGV4dF07XG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSB0ZXh0X2luZm8uc2l6ZS50ZXh0dXJlX3NpemU7XG5cbiAgICAgICAgICAgICAgICB0ZXh0X2luZm8ucG9zaXRpb24gPSBbMCwgaGVpZ2h0XTtcblxuICAgICAgICAgICAgICAgIGlmIChzaXplWzBdID4gd2lkZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZGVzdCA9IHNpemVbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICs9IHNpemVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gWyB3aWRlc3QsIGhlaWdodCBdO1xuICAgIH1cblxuICAgIC8vIENhbGxlZCBiZWZvcmUgcmFzdGVyaXphdGlvblxuICAgIGFwcGx5VGV4dFRyYW5zZm9ybSAodGV4dCwgdHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm0gPT09ICdjYXBpdGFsaXplJykge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSgvXFx3XFxTKi9nLCBmdW5jdGlvbiAodHh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR4dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR4dC5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRyYW5zZm9ybSA9PT0gJ3VwcGVyY2FzZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJhbnNmb3JtID09PSAnbG93ZXJjYXNlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGZvbnQgQ1NTLXN0eWxlIHNpemUgKCcxMnB4JywgJzE0cHQnLCAnMS41ZW0nLCBldGMuKSB0byBwaXhlbCBzaXplIChhZGp1c3RlZCBmb3IgZGV2aWNlIHBpeGVsIHJhdGlvKVxuICAgIC8vIERlZmF1bHRzIHVuaXRzIHRvIHBpeGVscyBpZiBub3Qgc3BlY2lmaWVkXG4gICAgc3RhdGljIGZvbnRQaXhlbFNpemUgKHNpemUpIHtcbiAgICAgICAgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNpemUgPSAodHlwZW9mIHNpemUgPT09ICdzdHJpbmcnKSA/IHNpemUgOiBTdHJpbmcoc2l6ZSk7IC8vIG5lZWQgYSBzdHJpbmcgZm9yIHJlZ2V4XG5cbiAgICAgICAgbGV0IFssIHB4X3NpemUsIHVuaXRzXSA9IHNpemUubWF0Y2goQ2FudmFzVGV4dC5mb250X3NpemVfcmUpIHx8IFtdO1xuICAgICAgICB1bml0cyA9IHVuaXRzIHx8ICdweCc7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSBcImVtXCIpIHtcbiAgICAgICAgICAgIHB4X3NpemUgKj0gMTY7XG4gICAgICAgIH0gZWxzZSBpZiAodW5pdHMgPT09IFwicHRcIikge1xuICAgICAgICAgICAgcHhfc2l6ZSAvPSAwLjc1O1xuICAgICAgICB9IGVsc2UgaWYgKHVuaXRzID09PSBcIiVcIikge1xuICAgICAgICAgICAgcHhfc2l6ZSAvPSA2LjI1O1xuICAgICAgICB9XG5cbiAgICAgICAgcHhfc2l6ZSA9IHBhcnNlRmxvYXQocHhfc2l6ZSk7XG4gICAgICAgIHB4X3NpemUgKj0gVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvO1xuICAgICAgICByZXR1cm4gcHhfc2l6ZTtcbiAgICB9XG5cbn1cblxuLy8gRXh0cmFjdCBmb250IHNpemUgYW5kIHVuaXRzXG5DYW52YXNUZXh0LmZvbnRfc2l6ZV9yZSA9IC8oKD86WzAtOV0qXFwuKT9bMC05XSspXFxzKihweHxwdHxlbXwlKT8vO1xuIiwiLypnbG9iYWwgTGFiZWwgKi9cblxuaW1wb3J0IGJveEludGVyc2VjdCBmcm9tICdib3gtaW50ZXJzZWN0JzsgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pa29sYWx5c2Vua28vYm94LWludGVyc2VjdFxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBPQkIgZnJvbSAnLi4vLi4vdXRpbHMvb2JiJztcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhYmVsIHtcblxuICAgIGNvbnN0cnVjdG9yICh0ZXh0LCBzaXplLCBvcHRpb25zKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgcG9zaXRpb246IG51bGwsXG4gICAgICAgICAgICBhYWJiOiBudWxsLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3Igb3ZlcmxhcHMgd2l0aCBvdGhlciBsYWJlbHMgaW4gdGhlIHRpbGVcbiAgICBvY2NsdWRlZCAoYWFiYnMpIHtcbiAgICAgICAgbGV0IGludGVyc2VjdCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEJyb2FkcGhhc2VcbiAgICAgICAgaWYgKGFhYmJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGJveEludGVyc2VjdChbdGhpcy5hYWJiXSwgYWFiYnMsIChpLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nLnRyYWNlKGAke3RoaXMudGV4dH0gYnJvYWQgcGhhc2UgY29sbGlkZWAsIHRoaXMsIHRoaXMuYWFiYiwgYWFiYnNbal0pO1xuXG4gICAgICAgICAgICAgICAgLy8gTmFycm93IHBoYXNlXG4gICAgICAgICAgICAgICAgaWYgKE9CQi5pbnRlcnNlY3QodGhpcy5hYWJiLm9iYiwgYWFiYnNbal0ub2JiKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2cudHJhY2UoYCR7dGhpcy50ZXh0fSBuYXJyb3cgcGhhc2UgY29sbGlkZWAsIHRoaXMsIHRoaXMuYWFiYi5vYmIsIGFhYmJzW2pdLm9iYik7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRlcnNlY3Q7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoaXMgbGFiZWwncyBib3VuZGluZyBib3ggdG8gdGhlIHByb3ZpZGVkIHNldFxuICAgIGFkZCAoYWFiYnMpIHtcbiAgICAgICAgYWFiYnMucHVzaCh0aGlzLmFhYmIpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrcyB3aGV0aGVyIHRoZSBsYWJlbCBpcyB3aXRoaW4gdGhlIHRpbGUgYm91bmRhcmllc1xuICAgIGluVGlsZUJvdW5kcyAoKSB7XG4gICAgICAgIGxldCBtaW4gPSBbIHRoaXMuYWFiYlswXSwgdGhpcy5hYWJiWzFdIF07XG4gICAgICAgIGxldCBtYXggPSBbIHRoaXMuYWFiYlsyXSwgdGhpcy5hYWJiWzNdIF07XG5cbiAgICAgICAgaWYgKCFVdGlscy5wb2ludEluVGlsZShtaW4pIHx8ICFVdGlscy5wb2ludEluVGlsZShtYXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBXaGV0aGVyIHRoZSBsYWJlbCBzaG91bGQgYmUgZGlzY2FyZGVkXG4gICAgLy8gRGVwZW5kcyBvbiB3aGV0aGVyIGxhYmVsIG11c3QgZml0IGluIHRoZSB0aWxlIGJvdW5kcywgYW5kIGlmIHNvLCBjYW4gaXQgYmUgbW92ZWQgdG8gZml0IHRoZXJlXG4gICAgZGlzY2FyZCAoYWFiYnMpIHtcbiAgICAgICAgLy8gU2hvdWxkIHRoZSBsYWJlbCBiZSBjdWxsZWQgaWYgaXQgY2FuJ3QgZml0IGluc2lkZSB0aGUgdGlsZSBib3VuZHM/XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3VsbF9mcm9tX3RpbGUpIHtcbiAgICAgICAgICAgIGxldCBpbl90aWxlID0gdGhpcy5pblRpbGVCb3VuZHMoKTtcblxuICAgICAgICAgICAgLy8gSWYgaXQgZG9lc24ndCBmaXQsIHNob3VsZCB3ZSB0cnkgdG8gbW92ZSBpdCBpbnRvIHRoZSB0aWxlIGJvdW5kcz9cbiAgICAgICAgICAgIGlmICghaW5fdGlsZSAmJiB0aGlzLm9wdGlvbnMubW92ZV9pbnRvX3RpbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW4gd2UgZml0IHRoZSBsYWJlbCBpbnRvIHRoZSB0aWxlP1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tb3ZlSW50b1RpbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gY2FuJ3QgZml0IGluIHRpbGUsIGRpc2NhcmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpbl90aWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIG91dCBvZiB0aWxlIGJvdW5kcywgZGlzY2FyZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGxhYmVsIGhhc24ndCBiZWVuIGRpc2NhcmRlZCB5ZXQsIGNoZWNrIHRvIHNlZSBpZiBpdCdzIG9jY2x1ZGVkIGJ5IG90aGVyIGxhYmVsc1xuICAgICAgICByZXR1cm4gdGhpcy5vY2NsdWRlZChhYWJicyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IExhYmVsUG9pbnQgZnJvbSAnLi9sYWJlbF9wb2ludCc7XG5pbXBvcnQgTGFiZWxMaW5lIGZyb20gJy4vbGFiZWxfbGluZSc7XG5pbXBvcnQgR2VvIGZyb20gJy4uLy4uL2dlbyc7XG5cbnZhciBMYWJlbEJ1aWxkZXI7XG5leHBvcnQgZGVmYXVsdCBMYWJlbEJ1aWxkZXIgPSB7fTtcblxuTGFiZWxCdWlsZGVyLmJ1aWxkRnJvbUdlb21ldHJ5ID0gZnVuY3Rpb24gKHRleHQsIHNpemUsIGdlb21ldHJ5LCBvcHRpb25zKSB7XG4gICAgbGV0IGxhYmVscyA9IFtdO1xuXG4gICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiTGluZVN0cmluZ1wiKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuXG4gICAgICAgIGxhYmVscy5wdXNoKG5ldyBMYWJlbExpbmUodGV4dCwgc2l6ZSwgbGluZXMsIG9wdGlvbnMpKTtcbiAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiTXVsdGlMaW5lU3RyaW5nXCIpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgICAgIGxhYmVscy5wdXNoKG5ldyBMYWJlbExpbmUodGV4dCwgc2l6ZSwgbGluZSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSBcIlBvaW50XCIpIHtcbiAgICAgICAgbGFiZWxzLnB1c2gobmV3IExhYmVsUG9pbnQodGV4dCwgZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHNpemUsIG9wdGlvbnMpKTtcbiAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiTXVsdGlQb2ludFwiKSB7XG4gICAgICAgIGxldCBwb2ludHMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgbGFiZWxzLnB1c2gobmV3IExhYmVsUG9pbnQodGV4dCwgcG9pbnQsIHNpemUsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcbiAgICAgICAgbGV0IGNlbnRyb2lkID0gR2VvLmNlbnRyb2lkKGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdKTtcbiAgICAgICAgbGFiZWxzLnB1c2gobmV3IExhYmVsUG9pbnQodGV4dCwgY2VudHJvaWQsIHNpemUsIG9wdGlvbnMpKTtcbiAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiTXVsdGlQb2x5Z29uXCIpIHtcbiAgICAgICAgbGV0IGNlbnRyb2lkID0gR2VvLm11bHRpQ2VudHJvaWQoZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuICAgICAgICBsYWJlbHMucHVzaChuZXcgTGFiZWxQb2ludCh0ZXh0LCBjZW50cm9pZCwgc2l6ZSwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIHJldHVybiBsYWJlbHM7XG59O1xuIiwiaW1wb3J0IFZlY3RvciBmcm9tICcuLi8uLi92ZWN0b3InO1xuaW1wb3J0IExhYmVsIGZyb20gJy4vbGFiZWwnO1xuaW1wb3J0IE9CQiBmcm9tICcuLi8uLi91dGlscy9vYmInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbExpbmUgZXh0ZW5kcyBMYWJlbCB7XG5cbiAgICBjb25zdHJ1Y3RvciAodGV4dCwgc2l6ZSwgbGluZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIodGV4dCwgc2l6ZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5zZWdtZW50X2luZGV4ID0gMDtcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZSAoKSB7XG4gICAgICAgIGxldCBzZWdtZW50ID0gdGhpcy5jdXJyZW50U2VnbWVudCgpO1xuICAgICAgICB0aGlzLmFuZ2xlID0gdGhpcy5jb21wdXRlQW5nbGUoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFsoc2VnbWVudFswXVswXSArIHNlZ21lbnRbMV1bMF0pIC8gMiwgKHNlZ21lbnRbMF1bMV0gKyBzZWdtZW50WzFdWzFdKSAvIDJdO1xuICAgICAgICB0aGlzLmFhYmIgPSB0aGlzLmNvbXB1dGVBQUJCKCk7XG4gICAgfVxuXG4gICAgbW92ZU5leHRTZWdtZW50ICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VnbWVudF9pbmRleCArIDEgPj0gdGhpcy5saW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlZ21lbnRfaW5kZXgrKztcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb21wdXRlQW5nbGUgKCkge1xuICAgICAgICBsZXQgc2VnbWVudCA9IHRoaXMuY3VycmVudFNlZ21lbnQoKTtcbiAgICAgICAgbGV0IHAwcDEgPSBWZWN0b3Iuc3ViKHNlZ21lbnRbMF0sIHNlZ21lbnRbMV0pO1xuXG4gICAgICAgIHAwcDEgPSBWZWN0b3Iubm9ybWFsaXplKHAwcDEpO1xuXG4gICAgICAgIGxldCBQSV8yID0gTWF0aC5QSSAvIDI7XG4gICAgICAgIGxldCB0aGV0YSA9IE1hdGguYXRhbjIocDBwMVswXSwgcDBwMVsxXSkgKyBQSV8yO1xuXG4gICAgICAgIGlmICh0aGV0YSA+IFBJXzIgfHwgdGhldGEgPCAtUElfMikge1xuICAgICAgICAgICAgdGhldGEgKz0gTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICB0aGV0YSAlPSBNYXRoLlBJICogMjtcblxuICAgICAgICByZXR1cm4gdGhldGE7XG4gICAgfVxuXG4gICAgZml0VG9TZWdtZW50ICgpIHtcbiAgICAgICAgbGV0IHNlZ21lbnQgPSB0aGlzLmN1cnJlbnRTZWdtZW50KCk7XG4gICAgICAgIGxldCBwMHAxID0gVmVjdG9yLnN1YihzZWdtZW50WzBdLCBzZWdtZW50WzFdKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IFZlY3Rvci5sZW5ndGgocDBwMSk7XG5cbiAgICAgICAgbGV0IGxhYmVsX2xlbmd0aCA9IHRoaXMuc2l6ZS5jb2xsaXNpb25fc2l6ZVswXSAqIHRoaXMub3B0aW9ucy51bml0c19wZXJfcGl4ZWw7XG5cbiAgICAgICAgaWYgKGxhYmVsX2xlbmd0aCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgLy8gYW4gZXhjZWVkIGhldXJlc3RpYyBvZiAxMDAlIHdvdWxkIGxldCB0aGUgbGFiZWwgZml0IGluIGFueSBjYXNlc1xuICAgICAgICAgICAgbGV0IGV4Y2VlZCA9ICgxIC0gKGxlbmd0aCAvIGxhYmVsX2xlbmd0aCkpICogMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGV4Y2VlZCA8IHRoaXMub3B0aW9ucy5saW5lX2V4Y2VlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYWJlbF9sZW5ndGggPD0gbGVuZ3RoO1xuICAgIH1cblxuICAgIGN1cnJlbnRTZWdtZW50ICgpIHtcbiAgICAgICAgbGV0IHAxID0gdGhpcy5saW5lc1t0aGlzLnNlZ21lbnRfaW5kZXhdO1xuICAgICAgICBsZXQgcDIgPSB0aGlzLmxpbmVzW3RoaXMuc2VnbWVudF9pbmRleCArIDFdO1xuXG4gICAgICAgIHJldHVybiBbIHAxLCBwMiBdO1xuICAgIH1cblxuICAgIGNvbXB1dGVBQUJCICgpIHtcbiAgICAgICAgbGV0IHVwcCA9IHRoaXMub3B0aW9ucy51bml0c19wZXJfcGl4ZWw7XG4gICAgICAgIGxldCB3aWR0aCA9ICh0aGlzLnNpemUuY29sbGlzaW9uX3NpemVbMF0gKyB0aGlzLm9wdGlvbnMuYnVmZmVyWzBdICogMikgKiB1cHA7XG4gICAgICAgIGxldCBoZWlnaHQgPSAodGhpcy5zaXplLmNvbGxpc2lvbl9zaXplWzFdICsgdGhpcy5vcHRpb25zLmJ1ZmZlclsxXSAqIDIpICogdXBwO1xuXG4gICAgICAgIC8vIGFwcGx5IG9mZnNldCwgeCBwb3NpdGl2ZSwgeSBwb2ludGluZyBkb3duXG4gICAgICAgIGxldCBvZmZzZXQgPSBWZWN0b3Iucm90KHRoaXMub3B0aW9ucy5vZmZzZXQsIHRoaXMuYW5nbGUpO1xuICAgICAgICBsZXQgcCA9IFtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMF0gKyAob2Zmc2V0WzBdICogdXBwKSxcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMV0gLSAob2Zmc2V0WzFdICogdXBwKVxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIHRoZSBhbmdsZSBvZiB0aGUgb2JiIGlzIG5lZ2F0aXZlIHNpbmNlIGl0J3MgdGhlIHRpbGUgc3lzdGVtIHkgYXhpcyBpcyBwb2ludGluZyBkb3duXG4gICAgICAgIGxldCBvYmIgPSBuZXcgT0JCKHBbMF0sIHBbMV0sIC10aGlzLmFuZ2xlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbGV0IGFhYmIgPSBvYmIuZ2V0RXh0ZW50KCk7XG4gICAgICAgIGFhYmIub2JiID0gb2JiO1xuXG4gICAgICAgIHJldHVybiBhYWJiO1xuICAgIH1cblxuICAgIC8vIFRyeSB0byBtb3ZlIHRoZSBsYWJlbCBpbnRvIHRoZSB0aWxlIGJvdW5kc1xuICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBsYWJlbCB3YXMgbW92ZWQgaW50byB0aWxlLCBmYWxzZSBpZiBpdCBjb3VsZG4ndCBiZSBtb3ZlZFxuICAgIG1vdmVJbnRvVGlsZSAoKSB7XG4gICAgICAgIGxldCBpbl90aWxlID0gZmFsc2U7XG4gICAgICAgIGxldCBmaXRzX3RvX3NlZ21lbnQgPSB0aGlzLmZpdFRvU2VnbWVudCgpO1xuXG4gICAgICAgIC8vIFRyeSBsaW5lIHNlZ21lbnRzIHVudGlsIHdlIGZpbmQgb25lIHRoYXQgZml0cyB0aGUgbGFiZWwgKGFuZCBpcyBpbnNpZGUgdGhlIHRpbGUpXG4gICAgICAgIHdoaWxlICghaW5fdGlsZSB8fCAhZml0c190b19zZWdtZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubW92ZU5leHRTZWdtZW50KCkpIHtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gd2UgY2FuJ3QgbW92ZSBmdXJ0aGVyIGluIHRoaXMgbGluZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbl90aWxlID0gdGhpcy5pblRpbGVCb3VuZHMoKTtcbiAgICAgICAgICAgIGZpdHNfdG9fc2VnbWVudCA9IHRoaXMuZml0VG9TZWdtZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5fdGlsZSAmJiBmaXRzX3RvX3NlZ21lbnQ7XG4gICAgfVxuXG4gICAgZGlzY2FyZCAoYWFiYnMpIHtcbiAgICAgICAgLy8gRmlyc3QgZmluZCBhIGxpbmUgc2VnbWVudCB0aGF0IGZpdHMgdGhlIGxhYmVsXG4gICAgICAgIGlmICh0aGlzLmxpbmVzICYmICF0aGlzLmZpdFRvU2VnbWVudCgpKSB7XG4gICAgICAgICAgICB3aGlsZSAoIXRoaXMuZml0VG9TZWdtZW50KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubW92ZU5leHRTZWdtZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbGFiZWwgZml0cyBpbiBsaW5lLCBydW4gc3RhbmRhcmQgZGlzY2FyZCB0ZXN0c1xuICAgICAgICByZXR1cm4gc3VwZXIuZGlzY2FyZChhYWJicyk7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgTGFiZWwgZnJvbSAnLi9sYWJlbCc7XG5pbXBvcnQgR2VvIGZyb20gJy4uLy4uL2dlbyc7XG5pbXBvcnQgT0JCIGZyb20gJy4uLy4uL3V0aWxzL29iYic7XG5pbXBvcnQgUG9pbnRBbmNob3IgZnJvbSAnLi4vcG9pbnRzL3BvaW50X2FuY2hvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhYmVsUG9pbnQgZXh0ZW5kcyBMYWJlbCB7XG5cbiAgICBjb25zdHJ1Y3RvciAodGV4dCwgcG9zaXRpb24sIHNpemUsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIodGV4dCwgc2l6ZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vZmZzZXQgPSB0aGlzLmNvbXB1dGVPZmZzZXQoKTtcbiAgICAgICAgdGhpcy5hYWJiID0gdGhpcy5jb21wdXRlQUFCQigpO1xuICAgIH1cblxuICAgIGNvbXB1dGVPZmZzZXQgKCkge1xuICAgICAgICByZXR1cm4gUG9pbnRBbmNob3IuY29tcHV0ZU9mZnNldCh0aGlzLm9wdGlvbnMub2Zmc2V0LCB0aGlzLnNpemUuY29sbGlzaW9uX3NpemUsIHRoaXMub3B0aW9ucy5hbmNob3IpO1xuICAgIH1cblxuICAgIGNvbXB1dGVBQUJCICgpIHtcbiAgICAgICAgbGV0IHdpZHRoID0gKHRoaXMuc2l6ZS5jb2xsaXNpb25fc2l6ZVswXSArIHRoaXMub3B0aW9ucy5idWZmZXJbMF0gKiAyKSAqIHRoaXMub3B0aW9ucy51bml0c19wZXJfcGl4ZWw7XG4gICAgICAgIGxldCBoZWlnaHQgPSAodGhpcy5zaXplLmNvbGxpc2lvbl9zaXplWzFdICsgdGhpcy5vcHRpb25zLmJ1ZmZlclsxXSAqIDIpICogdGhpcy5vcHRpb25zLnVuaXRzX3Blcl9waXhlbDtcblxuICAgICAgICBsZXQgcCA9IFtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMF0gKyAodGhpcy5vcHRpb25zLm9mZnNldFswXSAqIHRoaXMub3B0aW9ucy51bml0c19wZXJfcGl4ZWwpLFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSAtICh0aGlzLm9wdGlvbnMub2Zmc2V0WzFdICogdGhpcy5vcHRpb25zLnVuaXRzX3Blcl9waXhlbClcbiAgICAgICAgXTtcblxuICAgICAgICBsZXQgb2JiID0gbmV3IE9CQihwWzBdLCBwWzFdLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbGV0IGFhYmIgPSBvYmIuZ2V0RXh0ZW50KCk7XG4gICAgICAgIGFhYmIub2JiID0gb2JiO1xuXG4gICAgICAgIHJldHVybiBhYWJiO1xuICAgIH1cblxuICAgIC8vIFRyeSB0byBtb3ZlIHRoZSBsYWJlbCBpbnRvIHRoZSB0aWxlIGJvdW5kc1xuICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBsYWJlbCB3YXMgbW92ZWQgaW50byB0aWxlLCBmYWxzZSBpZiBpdCBjb3VsZG4ndCBiZSBtb3ZlZFxuICAgIG1vdmVJbnRvVGlsZSAoKSB7XG4gICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuYWFiYlswXSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMF0gKz0gLXRoaXMuYWFiYlswXTtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYWFiYlsyXSA+PSBHZW8udGlsZV9zY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvblswXSAtPSB0aGlzLmFhYmJbMl0gLSBHZW8udGlsZV9zY2FsZSArIDE7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFhYmJbM10gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzFdIC09IHRoaXMuYWFiYlszXTtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYWFiYlsxXSA8PSAtR2VvLnRpbGVfc2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMV0gLT0gdGhpcy5hYWJiWzFdICsgR2VvLnRpbGVfc2NhbGUgLSAxO1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5hYWJiID0gdGhpcy5jb21wdXRlQUFCQigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5UaWxlQm91bmRzKCk7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgR2VvIGZyb20gJy4uLy4uL2dlbyc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuLi9zdHlsZV9wYXJzZXInO1xuXG52YXIgTGF5b3V0U2V0dGluZ3M7XG5cbmV4cG9ydCBkZWZhdWx0IExheW91dFNldHRpbmdzID0ge1xuXG4gICBjb21wdXRlIChmZWF0dXJlLCBkcmF3LCB0ZXh0LCBjb250ZXh0LCB0aWxlKSB7XG4gICAgICAgIGxldCBsYXlvdXQgPSB7fTtcbiAgICAgICAgbGF5b3V0LnVuaXRzX3Blcl9waXhlbCA9IHRpbGUudW5pdHNfcGVyX3BpeGVsIHx8IDE7XG5cbiAgICAgICAgLy8gbGFiZWwgYW5jaG9ycyAocG9pbnQgbGFiZWxzIG9ubHkpXG4gICAgICAgIC8vIGxhYmVsIHdpbGwgYmUgYWRqdXN0ZWQgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbiwgcmVsYXRvdmUgdG8gaXRzIG9yaWdpbmFsIHBvaW50XG4gICAgICAgIC8vIG9uZSBvZjogbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCB0b3AtbGVmdCwgdG9wLXJpZ2h0LCBib3R0b20tbGVmdCwgYm90dG9tLXJpZ2h0XG4gICAgICAgIGxheW91dC5hbmNob3IgPSBkcmF3LmFuY2hvcjtcblxuICAgICAgICAvLyBsYWJlbCBvZmZzZXQgaW4gcGl4ZWwgKGFwcGxpZWQgaW4gc2NyZWVuIHNwYWNlKVxuICAgICAgICBsYXlvdXQub2Zmc2V0ID0gU3R5bGVQYXJzZXIuY2FjaGVQcm9wZXJ0eShkcmF3Lm9mZnNldCwgY29udGV4dCkgfHwgWzAsIDBdO1xuXG4gICAgICAgIC8vIGxhYmVsIGJ1ZmZlciBpbiBwaXhlbFxuICAgICAgICBsZXQgYnVmZmVyID0gZHJhdy5idWZmZXI7XG4gICAgICAgIGlmIChidWZmZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBbYnVmZmVyLCBidWZmZXJdOyAvLyBidWZmZXIgY2FuIGJlIDFEIG9yIDJEXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ1ZmZlclswXSA9IHBhcnNlRmxvYXQoYnVmZmVyWzBdKTtcbiAgICAgICAgICAgIGJ1ZmZlclsxXSA9IHBhcnNlRmxvYXQoYnVmZmVyWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBsYXlvdXQuYnVmZmVyID0gYnVmZmVyIHx8IFswLCAwXTtcblxuICAgICAgICAvLyBsYWJlbCBwcmlvcml0eSAobG93ZXIgaXMgaGlnaGVyKVxuICAgICAgICBsZXQgcHJpb3JpdHkgPSBkcmF3LnByaW9yaXR5O1xuICAgICAgICBpZiAocHJpb3JpdHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gcHJpb3JpdHkoY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmlvcml0eSA9IC0xID4+PiAwOyAvLyBkZWZhdWx0IHRvIG1heCBwcmlvcml0eSB2YWx1ZSBpZiBub25lIHNldFxuICAgICAgICB9XG4gICAgICAgIGxheW91dC5wcmlvcml0eSA9IHByaW9yaXR5O1xuXG4gICAgICAgIC8vIGxhYmVsIGxpbmUgZXhjZWVkIHBlcmNlbnRhZ2VcbiAgICAgICAgaWYgKGRyYXcubGluZV9leGNlZWQgJiYgZHJhdy5saW5lX2V4Y2VlZC5zdWJzdHIoLTEpID09PSAnJScpIHtcbiAgICAgICAgICAgIGxheW91dC5saW5lX2V4Y2VlZCA9IHBhcnNlRmxvYXQoZHJhdy5saW5lX2V4Y2VlZC5zdWJzdHIoMCxkcmF3LmxpbmVfZXhjZWVkLmxlbmd0aC0xKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYXlvdXQubGluZV9leGNlZWQgPSA4MDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGVhdCBtaW5pbXVtIGRpc3RhbmNlXG4gICAgICAgIGxheW91dC5yZXBlYXRfZGlzdGFuY2UgPSBTdHlsZVBhcnNlci5jYWNoZVByb3BlcnR5KGRyYXcucmVwZWF0X2Rpc3RhbmNlLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGxheW91dC5yZXBlYXRfZGlzdGFuY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgbGF5b3V0LnJlcGVhdF9kaXN0YW5jZSA9IEdlby50aWxlX3NpemU7XG4gICAgICAgIH1cbiAgICAgICAgbGF5b3V0LnJlcGVhdF9kaXN0YW5jZSAqPSBsYXlvdXQudW5pdHNfcGVyX3BpeGVsO1xuXG4gICAgICAgIC8vIHJlcGVhdCBncm91cCBrZXlcbiAgICAgICAgaWYgKHR5cGVvZiBkcmF3LnJlcGVhdF9ncm91cCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbGF5b3V0LnJlcGVhdF9ncm91cCA9IGRyYXcucmVwZWF0X2dyb3VwKGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkcmF3LnJlcGVhdF9ncm91cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxheW91dC5yZXBlYXRfZ3JvdXAgPSBkcmF3LnJlcGVhdF9ncm91cDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxheW91dC5yZXBlYXRfZ3JvdXAgPSBkcmF3LmtleTsgLy8gZGVmYXVsdCB0byB1bmlxdWUgc2V0IG9mIG1hdGNoaW5nIGxheWVyc1xuICAgICAgICB9XG4gICAgICAgIGxheW91dC5yZXBlYXRfZ3JvdXAgKz0gJy8nICsgdGV4dDtcblxuICAgICAgICAvLyBjb2xsaXNpb24gZmxhZ1xuICAgICAgICBsYXlvdXQuY29sbGlkZSA9IChkcmF3LmNvbGxpZGUgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZTtcblxuICAgICAgICAvLyB0aWxlIGJvdW5kYXJ5IGhhbmRsaW5nXG4gICAgICAgIGxheW91dC5jdWxsX2Zyb21fdGlsZSA9IChkcmF3LmN1bGxfZnJvbV90aWxlICE9IG51bGwpID8gZHJhdy5jdWxsX2Zyb21fdGlsZSA6IHRydWU7XG4gICAgICAgIGxheW91dC5tb3ZlX2ludG9fdGlsZSA9IChkcmF3Lm1vdmVfaW50b190aWxlICE9IG51bGwpID8gZHJhdy5tb3ZlX2ludG9fdGlsZSA6IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGxheW91dDtcbiAgICB9XG5cbn07XG4iLCJpbXBvcnQgR2VvIGZyb20gJy4uLy4uL2dlbyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlcGVhdEdyb3VwIHtcblxuICAgIGNvbnN0cnVjdG9yIChrZXksIHJlcGVhdF9kaXN0LCBtYXhfcmVwZWF0X2Rpc3QpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMucmVwZWF0X2Rpc3QgPSByZXBlYXRfZGlzdDtcbiAgICAgICAgdGhpcy5yZXBlYXRfZGlzdF9zcSA9IHRoaXMucmVwZWF0X2Rpc3QgKiB0aGlzLnJlcGVhdF9kaXN0O1xuICAgICAgICB0aGlzLm1heF9yZXBlYXRfZGlzdF9zcSA9IG1heF9yZXBlYXRfZGlzdCAqIG1heF9yZXBlYXRfZGlzdDtcbiAgICAgICAgdGhpcy5vbmVfcGVyX2dyb3VwID0gKHRoaXMucmVwZWF0X2Rpc3Rfc3EgPj0gdGhpcy5tYXhfcmVwZWF0X2Rpc3Rfc3EpID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IFtdO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGFuIG9iamVjdCB0byBzZWUgaWYgaXQncyBhIHJlcGVhdCBpbiB0aGlzIGdyb3VwXG4gICAgY2hlY2sgKG9iaikge1xuICAgICAgICAvLyBJZiBvbmx5IG9uZSBvYmplY3QgYWxsb3dlZCBwZXIgZ3JvdXAsIHNob3J0Y3V0IGRpc3RhbmNlIGxvZ2ljXG4gICAgICAgIGlmICh0aGlzLm9uZV9wZXJfZ3JvdXApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwb3J0ZWQgZGlzdGFuY2UgbWF4ZXMgb3V0IGF0IHRocmVzaG9sZCBpbiB0aGlzIGNhc2VcbiAgICAgICAgICAgICAgICAvLyAobm90IHRydWUgZGlzdCB2YWx1ZSBzaW5jZSB3ZSBza2lwcGVkIGNhbGN1bGF0aW5nIGl0KVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Rfc3E6IHRoaXMubWF4X3JlcGVhdF9kaXN0X3NxLFxuICAgICAgICAgICAgICAgICAgICByZXBlYXRfZGlzdF9zcTogdGhpcy5yZXBlYXRfZGlzdF9zcSxcbiAgICAgICAgICAgICAgICAgICAgb25lX3Blcl9ncm91cDogdGhpcy5vbmVfcGVyX2dyb3VwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjsgLy8gbm8gb2JqZWN0IGZvciB0aGlzIGdyb3VwIHlldFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZGlzdGFuY2UgZnJvbSBuZXcgb2JqZWN0IHRvIG9iamVjdHMgYWxyZWFkeSBpbiBncm91cFxuICAgICAgICBsZXQgcDEgPSBvYmoucG9zaXRpb247XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IHRoaXMucG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcDIgPSB0aGlzLnBvc2l0aW9uc1tpXTtcbiAgICAgICAgICAgIGxldCBkeCA9IHAxWzBdIC0gcDJbMF07XG4gICAgICAgICAgICBsZXQgZHkgPSBwMVsxXSAtIHAyWzFdO1xuICAgICAgICAgICAgbGV0IGRpc3Rfc3EgPSBkeCAqIGR4ICsgZHkgKiBkeTtcblxuICAgICAgICAgICAgLy8gRm91bmQgYW4gZXhpc3Rpbmcgb2JqZWN0IHdpdGhpbiBhbGxvd2VkIGRpc3RhbmNlXG4gICAgICAgICAgICBpZiAoZGlzdF9zcSA8IHRoaXMucmVwZWF0X2Rpc3Rfc3EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkaXN0X3NxLFxuICAgICAgICAgICAgICAgICAgICByZXBlYXRfZGlzdF9zcTogdGhpcy5yZXBlYXRfZGlzdF9zcVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgb2JqZWN0IHRvIHRoaXMgZ3JvdXBcbiAgICBhZGQgKG9iaikge1xuICAgICAgICAvLyBvbmx5IHN0b3JlIG9iamVjdCdzIHBvc2l0aW9uLCB0byBzYXZlIHNwYWNlIC8gcHJldmVudCB1bm5lY2Vzc2FyeSByZWZlcmVuY2VzXG4gICAgICAgIGlmIChvYmogJiYgb2JqLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9ucy5wdXNoKG9iai5wb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGF0aWMgbWV0aG9kcyBhcmUgdXNlZCB0byBtYW5hZ2UgcmVwZWF0IGdyb3Vwcywgd2l0aGluIGFuZCBhY3Jvc3MgdGlsZXNcblxuICAgIC8vIFJlc2V0IGFsbCBncm91cHMgZm9yIHRoaXMgdGlsZVxuICAgIHN0YXRpYyBjbGVhciAodGlsZSkge1xuICAgICAgICB0aGlzLmdyb3Vwc1t0aWxlXSA9IHt9O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGFuIG9iamVjdCB0byBzZWUgaWYgaXQncyBhIHJlcGVhdCB3aXRoaW4gaXRzIGRlc2lnbmF0ZWQgZ3JvdXBcbiAgICBzdGF0aWMgY2hlY2sgKG9iaiwgbGF5b3V0LCB0aWxlKSB7XG4gICAgICAgIGlmIChsYXlvdXQucmVwZWF0X2Rpc3RhbmNlICYmIHRoaXMuZ3JvdXBzW3RpbGVdW2xheW91dC5yZXBlYXRfZ3JvdXBdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncm91cHNbdGlsZV1bbGF5b3V0LnJlcGVhdF9ncm91cF0uY2hlY2sob2JqKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBhbiBvYmplY3QgdG8gaXRzIGRlc2lnbmF0ZWQgZ3JvdXBcbiAgICBzdGF0aWMgYWRkIChvYmosIGxheW91dCwgdGlsZSkge1xuICAgICAgICBpZiAobGF5b3V0LnJlcGVhdF9kaXN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JvdXBzW3RpbGVdW2xheW91dC5yZXBlYXRfZ3JvdXBdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1t0aWxlXVtsYXlvdXQucmVwZWF0X2dyb3VwXSA9IG5ldyBSZXBlYXRHcm91cChcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0LnJlcGVhdF9ncm91cCxcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0LnJlcGVhdF9kaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgUmVwZWF0R3JvdXAubWF4X3JlcGVhdF9kaXN0ICogbGF5b3V0LnVuaXRzX3Blcl9waXhlbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1t0aWxlXVtsYXlvdXQucmVwZWF0X2dyb3VwXS5hZGQob2JqKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG4vLyBDdXJyZW50IHNldCBvZiByZXBlYXQgZ3JvdXBzLCBncm91cGVkIGFuZCBrZXllZCBieSB0aWxlXG5SZXBlYXRHcm91cC5ncm91cHMgPSB7fTtcblxuLy8gTWF4IHJlcGVhdCBkaXN0OiBmb3IgZ3JvdXBzIHdpdGggYSByZXBlYXQgZGlzdCBiZXlvbmQgdGhpcyB0aHJlc2hvbGQsIG9ubHkgb25lIGxhYmVsXG4vLyB3aWxsIGJlIGFsbG93ZWQgcGVyIGdyb3VwLCBlLmcuIHNldCB0byB0aWxlIHNpemUgZm9yIG9uZS1sYWJlbC1wZXItdGlsZVxuUmVwZWF0R3JvdXAubWF4X3JlcGVhdF9kaXN0ID0gR2VvLnRpbGVfc2l6ZTtcbiIsIi8vIFRleHQgcmVuZGVyaW5nIHN0eWxlXG5cbmltcG9ydCBUZXh0dXJlIGZyb20gJy4uLy4uL2dsL3RleHR1cmUnO1xuaW1wb3J0IFdvcmtlckJyb2tlciBmcm9tICcuLi8uLi91dGlscy93b3JrZXJfYnJva2VyJztcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi91dGlscy91dGlscyc7XG5pbXBvcnQge1BvaW50c30gZnJvbSAnLi4vcG9pbnRzL3BvaW50cyc7XG5pbXBvcnQgQ2FudmFzVGV4dCBmcm9tICcuL2NhbnZhc190ZXh0JztcbmltcG9ydCBMYWJlbEJ1aWxkZXIgZnJvbSAnLi9sYWJlbF9idWlsZGVyJztcbmltcG9ydCBUZXh0U2V0dGluZ3MgZnJvbSAnLi90ZXh0X3NldHRpbmdzJztcbmltcG9ydCBMYXlvdXRTZXR0aW5ncyBmcm9tICcuL2xheW91dF9zZXR0aW5ncyc7XG5pbXBvcnQgUmVwZWF0R3JvdXAgZnJvbSAnLi9yZXBlYXRfZ3JvdXAnO1xuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi4vc3R5bGVfcGFyc2VyJztcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCBsZXQgVGV4dFN0eWxlID0gT2JqZWN0LmNyZWF0ZShQb2ludHMpO1xuXG5PYmplY3QuYXNzaWduKFRleHRTdHlsZSwge1xuICAgIG5hbWU6ICd0ZXh0JyxcbiAgICBzdXBlcjogUG9pbnRzLFxuICAgIGJ1aWx0X2luOiB0cnVlLFxuICAgIHNlbGVjdGlvbjogZmFsc2UsIC8vIG5vIGZlYXR1cmUgc2VsZWN0aW9uIGZvciB0ZXh0IGJ5IGRlZmF1bHRcblxuICAgIGluaXQoKSB7XG5cbiAgICAgICAgdGhpcy5zdXBlci5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHRoaXMgb2JqZWN0IHRvIGJlIGNhbGxlZCBmcm9tIHdvcmtlciB0aHJlYWRzXG4gICAgICAgIHRoaXMubWFpbl90aHJlYWRfdGFyZ2V0ID0gJ1RleHRTdHlsZS0nICsgdGhpcy5uYW1lO1xuICAgICAgICBpZiAoVXRpbHMuaXNNYWluVGhyZWFkKSB7XG4gICAgICAgICAgICBXb3JrZXJCcm9rZXIuYWRkVGFyZ2V0KHRoaXMubWFpbl90aHJlYWRfdGFyZ2V0LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBvaW50IHN0eWxlIChwYXJlbnQgY2xhc3MpIHJlcXVpcmVzIHRleHR1cmluZyB0byBiZSB0dXJuZWQgb25cbiAgICAgICAgLy8gKGxhYmVscyBhcmUgYWx3YXlzIGRyYXduIHdpdGggdGV4dHVyZXMpXG4gICAgICAgIHRoaXMuZGVmaW5lcy5UQU5HUkFNX1BPSU5UX1RFWFRVUkUgPSB0cnVlO1xuXG4gICAgICAgIC8vIE1hbnVhbGx5IHVuLW11bHRpcGx5IGFscGhhLCBiZWNhdXNlIENhbnZhcyB0ZXh0IHJhc3Rlcml6YXRpb24gaXMgcHJlLW11bHRpcGxpZWRcbiAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fVU5NVUxUSVBMWV9BTFBIQSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0sXG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zdXBlci5yZXNldC5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAoVXRpbHMuaXNNYWluVGhyZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IG5ldyBDYW52YXNUZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVXRpbHMuaXNXb3JrZXJUaHJlYWQpIHtcbiAgICAgICAgICAgIHRoaXMucXVldWVzID0ge307XG4gICAgICAgICAgICB0aGlzLnRleHRzID0ge307IC8vIHVuaXF1ZSB0ZXh0cywgZ3JvdXBlZCBieSB0aWxlLCBieSBzdHlsZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIENhbGxlZCBvbiB3b3JrZXIgdGhyZWFkIHRvIHJlbGVhc2UgdGlsZS1zcGVjaWZpYyByZXNvdXJjZXNcbiAgICBmcmVlVGlsZSAodGlsZSkge1xuICAgICAgICBkZWxldGUgdGhpcy50ZXh0c1t0aWxlXTtcbiAgICB9LFxuXG4gICAgLy8gT3ZlcnJpZGUgdG8gcXVldWUgZmVhdHVyZXMgaW5zdGVhZCBvZiBwcm9jZXNzaW5nIGltbWVkaWF0ZWx5XG4gICAgYWRkRmVhdHVyZSAoZmVhdHVyZSwgZHJhdywgY29udGV4dCkge1xuICAgICAgICBsZXQgdGlsZSA9IGNvbnRleHQudGlsZTtcbiAgICAgICAgaWYgKHRpbGUuZ2VuZXJhdGlvbiAhPT0gdGhpcy5nZW5lcmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxsZWQgaGVyZSBiZWNhdXNlIG90aGVyd2lzZSBpdCB3aWxsIGJlIGRlbGF5ZWQgdW50aWwgdGhlIGZlYXR1cmUgcXVldWUgaXMgcGFyc2VkLFxuICAgICAgICAvLyBhbmQgd2Ugd2FudCB0aGUgcHJlcHJvY2Vzc2luZyBkb25lIGJlZm9yZSB3ZSBldmFsdWF0ZSB0ZXh0IHN0eWxlIGJlbG93XG4gICAgICAgIGRyYXcgPSB0aGlzLnByZXByb2Nlc3MoZHJhdyk7XG4gICAgICAgIGlmICghZHJhdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29sbGVjdCB0ZXh0IC0gZGVmYXVsdCBzb3VyY2UgaXMgZmVhdHVyZS5wcm9wZXJ0aWVzLm5hbWVcbiAgICAgICAgbGV0IHRleHQ7XG4gICAgICAgIGxldCBzb3VyY2UgPSBkcmF3LnRleHRfc291cmNlIHx8ICduYW1lJztcblxuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRleHQgPSBmZWF0dXJlLnByb3BlcnRpZXNbc291cmNlXTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0ZXh0ID0gc291cmNlKGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBubyB0ZXh0IGZvciB0aGlzIGZlYXR1cmVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXB1dGUgdGV4dCBzdHlsZSBhbmQgbGF5b3V0IHNldHRpbmdzIGZvciB0aGlzIGZlYXR1cmUgbGFiZWxcbiAgICAgICAgbGV0IGxheW91dCA9IExheW91dFNldHRpbmdzLmNvbXB1dGUoZmVhdHVyZSwgZHJhdywgdGV4dCwgY29udGV4dCwgdGlsZSk7XG4gICAgICAgIGxldCB0ZXh0X3NldHRpbmdzID0gVGV4dFNldHRpbmdzLmNvbXB1dGUoZmVhdHVyZSwgZHJhdywgY29udGV4dCk7XG4gICAgICAgIGxldCB0ZXh0X3NldHRpbmdzX2tleSA9IFRleHRTZXR0aW5ncy5rZXkodGV4dF9zZXR0aW5ncyk7XG5cbiAgICAgICAgLy8gZmlyc3QgbGFiZWwgaW4gdGlsZSwgb3Igd2l0aCB0aGlzIHN0eWxlP1xuICAgICAgICB0aGlzLnRleHRzW3RpbGUua2V5XSA9IHRoaXMudGV4dHNbdGlsZS5rZXldIHx8IHt9O1xuICAgICAgICB0aGlzLnRleHRzW3RpbGUua2V5XVt0ZXh0X3NldHRpbmdzX2tleV0gPSB0aGlzLnRleHRzW3RpbGUua2V5XVt0ZXh0X3NldHRpbmdzX2tleV0gfHwge307XG5cbiAgICAgICAgLy8gdW5pcXVlIHRleHQgc3RyaW5ncywgZ3JvdXBlZCBieSB0ZXh0IGRyYXdpbmcgc3R5bGVcbiAgICAgICAgaWYgKCF0aGlzLnRleHRzW3RpbGUua2V5XVt0ZXh0X3NldHRpbmdzX2tleV1bdGV4dF0pIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IGxhYmVsIHdpdGggdGhpcyB0ZXh0L3N0eWxlL3RpbGUgY29tYmluYXRpb24sIG1ha2UgYSBuZXcgbGFiZWwgZW50cnlcbiAgICAgICAgICAgIHRoaXMudGV4dHNbdGlsZS5rZXldW3RleHRfc2V0dGluZ3Nfa2V5XVt0ZXh0XSA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0X3NldHRpbmdzLFxuICAgICAgICAgICAgICAgIHJlZjogMCAvLyAjIG9mIHRpbWVzIHRoaXMgdGV4dC9zdHlsZSBjb21ibyBhcHBlYXJzIGluIHRpbGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBRdWV1ZSB0aGUgZmVhdHVyZSBmb3IgcHJvY2Vzc2luZ1xuICAgICAgICBpZiAoIXRoaXMudGlsZV9kYXRhW3RpbGUua2V5XSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydERhdGEodGlsZS5rZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnF1ZXVlc1t0aWxlLmtleV0pIHtcbiAgICAgICAgICAgIHRoaXMucXVldWVzW3RpbGUua2V5XSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcy50aWxlX2RhdGFbdGlsZS5rZXldLnF1ZXVlLnB1c2goe1xuICAgICAgICB0aGlzLnF1ZXVlc1t0aWxlLmtleV0ucHVzaCh7XG4gICAgICAgICAgICBmZWF0dXJlLCBkcmF3LCBjb250ZXh0LFxuICAgICAgICAgICAgdGV4dCwgdGV4dF9zZXR0aW5nc19rZXksIGxheW91dFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gT3ZlcnJpZGVcbiAgICBlbmREYXRhICh0aWxlKSB7XG4gICAgICAgIGxldCBxdWV1ZSA9IHRoaXMucXVldWVzW3RpbGVdO1xuICAgICAgICB0aGlzLnF1ZXVlc1t0aWxlXSA9IFtdO1xuXG4gICAgICAgIGxldCBjb3VudCA9IE9iamVjdC5rZXlzKHRoaXMudGV4dHNbdGlsZV18fHt9KS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3QgY2FsbCB0byBtYWluIHRocmVhZCwgYXNrIGZvciB0ZXh0IHBpeGVsIHNpemVzXG4gICAgICAgIHJldHVybiBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UodGhpcy5tYWluX3RocmVhZF90YXJnZXQrJy5jYWxjVGV4dFNpemVzJywgdGlsZSwgdGhpcy50ZXh0c1t0aWxlXSkudGhlbih0ZXh0cyA9PiB7XG4gICAgICAgICAgICBpZiAoIXRleHRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmVlVGlsZSh0aWxlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5lbmREYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRleHRzW3RpbGVdID0gdGV4dHM7XG5cbiAgICAgICAgICAgIGxldCBsYWJlbHMgPSB0aGlzLmNyZWF0ZUxhYmVscyh0aWxlLCBxdWV1ZSk7XG5cbiAgICAgICAgICAgIGlmICghbGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmVlVGlsZSh0aWxlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5lbmREYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhYmVscyA9IHRoaXMuZGlzY2FyZExhYmVscyh0aWxlLCBsYWJlbHMsIHRleHRzKTtcblxuICAgICAgICAgICAgLy8gTm8gbGFiZWxzIGZvciB0aGlzIHRpbGVcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0ZXh0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmVlVGlsZSh0aWxlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5lbmREYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlY29uZCBjYWxsIHRvIG1haW4gdGhyZWFkLCBmb3IgcmFzdGVyaXppbmcgdGhlIHNldCBvZiB0ZXh0c1xuICAgICAgICAgICAgcmV0dXJuIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSh0aGlzLm1haW5fdGhyZWFkX3RhcmdldCsnLnJhc3Rlcml6ZVRleHRzJywgdGlsZSwgdGV4dHMpLnRoZW4oKHsgdGV4dHMsIHRleHR1cmUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRzW3RpbGVdID0gdGV4dHM7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQnVpbGQgcXVldWVkIGZlYXR1cmVzXG4gICAgICAgICAgICAgICAgICAgIGxhYmVscy5mb3JFYWNoKHEgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSBxLmxhYmVsLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dF9zZXR0aW5nc19rZXkgPSBxLnRleHRfc2V0dGluZ3Nfa2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHRfaW5mbyA9IHRoaXMudGV4dHNbdGlsZV0gJiYgdGhpcy50ZXh0c1t0aWxlXVt0ZXh0X3NldHRpbmdzX2tleV0gJiYgdGhpcy50ZXh0c1t0aWxlXVt0ZXh0X3NldHRpbmdzX2tleV1bdGV4dF07XG4gICAgICAgICAgICAgICAgICAgICAgICBxLmxhYmVsLnRleGNvb3JkcyA9IHRleHRfaW5mby50ZXhjb29yZHM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3VwZXIuYWRkRmVhdHVyZS5jYWxsKHRoaXMsIHEuZmVhdHVyZSwgcS5kcmF3LCBxLmNvbnRleHQsIHEubGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZyZWVUaWxlKHRpbGUpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIuZW5kRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4odGlsZV9kYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0YWNoIHRpbGUtc3BlY2lmaWMgbGFiZWwgYXRsYXMgdG8gbWVzaCBhcyBhIHRleHR1cmUgdW5pZm9ybVxuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dHVyZSAmJiB0aWxlX2RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVfZGF0YS51bmlmb3JtcyA9IHsgdV90ZXh0dXJlOiB0ZXh0dXJlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlX2RhdGEudGV4dHVyZXMgPSBbdGV4dHVyZV07IC8vIGFzc2lnbiB0ZXh0dXJlIG93bmVyc2hpcCB0byB0aWxlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGlsZV9kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGNyZWF0ZUxhYmVscyAodGlsZSwgZmVhdHVyZV9xdWV1ZSkge1xuICAgICAgICBsZXQgcHJpb3JpdGllcyA9IHt9OyAvLyBsYWJlbHMsIGdyb3VwIGJ5IHByaW9yaXR5XG5cbiAgICAgICAgZm9yIChsZXQgZj0wOyBmIDwgZmVhdHVyZV9xdWV1ZS5sZW5ndGg7IGYrKykge1xuICAgICAgICAgICAgbGV0IHsgZmVhdHVyZSwgZHJhdywgY29udGV4dCwgdGV4dCwgdGV4dF9zZXR0aW5nc19rZXksIGxheW91dCB9ID0gZmVhdHVyZV9xdWV1ZVtmXTtcbiAgICAgICAgICAgIGxldCB0ZXh0X2luZm8gPSB0aGlzLnRleHRzW3RpbGVdW3RleHRfc2V0dGluZ3Nfa2V5XVt0ZXh0XTtcblxuICAgICAgICAgICAgbGV0IGxhYmVscyA9IExhYmVsQnVpbGRlci5idWlsZEZyb21HZW9tZXRyeSh0ZXh0LCB0ZXh0X2luZm8uc2l6ZSwgZmVhdHVyZS5nZW9tZXRyeSwgbGF5b3V0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gbGFiZWxzW2ldO1xuICAgICAgICAgICAgICAgIHByaW9yaXRpZXNbbGF5b3V0LnByaW9yaXR5XSA9IHByaW9yaXRpZXNbbGF5b3V0LnByaW9yaXR5XSB8fCBbXTtcbiAgICAgICAgICAgICAgICBwcmlvcml0aWVzW2xheW91dC5wcmlvcml0eV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUsIGRyYXcsIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRleHQsIHRleHRfc2V0dGluZ3Nfa2V5LCBsYXlvdXQsIGxhYmVsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJpb3JpdGllcztcbiAgICB9LFxuXG4gICAgLy8gVGVzdCBsYWJlbHMgZm9yIGNvbGxpc2lvbnMsIGhpZ2hlciB0byBsb3dlciBwcmlvcml0eVxuICAgIC8vIFdoZW4gdHdvIGNvbGxpZGUsIGRpc2NhcmQgdGhlIGxvd2VyLXByaW9yaXR5IGxhYmVsXG4gICAgZGlzY2FyZExhYmVscyAodGlsZSwgbGFiZWxzLCB0ZXh0cykge1xuICAgICAgICBsZXQgYWFiYnMgPSBbXTtcbiAgICAgICAgbGV0IGtlZXBfbGFiZWxzID0gW107XG4gICAgICAgIFJlcGVhdEdyb3VwLmNsZWFyKHRpbGUpO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgbGFiZWxzIGJ5IHByaW9yaXR5XG4gICAgICAgIGxldCBwcmlvcml0aWVzID0gT2JqZWN0LmtleXMobGFiZWxzKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgIGZvciAobGV0IHByaW9yaXR5IG9mIHByaW9yaXRpZXMpIHtcbiAgICAgICAgICAgIGlmICghbGFiZWxzW3ByaW9yaXR5XSkgeyAvLyBubyBsYWJlbHMgYXQgdGhpcyBwcmlvcml0eSwgc2tpcCB0byBuZXh0XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFiZWxzW3ByaW9yaXR5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7IGxhYmVsLCB0ZXh0X3NldHRpbmdzX2tleSwgbGF5b3V0IH0gPSBsYWJlbHNbcHJpb3JpdHldW2ldO1xuICAgICAgICAgICAgICAgIGxldCBzZXR0aW5ncyA9IHRleHRzW3RleHRfc2V0dGluZ3Nfa2V5XVtsYWJlbC50ZXh0XTtcblxuICAgICAgICAgICAgICAgIC8vIHRlc3QgdGhlIGxhYmVsIGZvciBpbnRlcnNlY3Rpb25zIHdpdGggb3RoZXIgbGFiZWxzIGluIHRoZSB0aWxlXG4gICAgICAgICAgICAgICAgaWYgKCFsYXlvdXQuY29sbGlkZSB8fCAhbGFiZWwuZGlzY2FyZChhYWJicykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHJlcGVhdHNcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoZWNrID0gUmVwZWF0R3JvdXAuY2hlY2sobGFiZWwsIGxheW91dCwgdGlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLnRyYWNlKGBkaXNjYXJkIGxhYmVsICcke2xhYmVsLnRleHR9JywgKG9uZV9wZXJfZ3JvdXA6ICR7Y2hlY2sub25lX3Blcl9ncm91cH0pLCBkaXN0ICR7TWF0aC5zcXJ0KGNoZWNrLmRpc3Rfc3EpL2xheW91dC51bml0c19wZXJfcGl4ZWx9IDwgJHtNYXRoLnNxcnQoY2hlY2sucmVwZWF0X2Rpc3Rfc3EpL2xheW91dC51bml0c19wZXJfcGl4ZWx9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyByZWdpc3RlciBhcyBwbGFjZWQgZm9yIGZ1dHVyZSByZXBlYXQgY3VsbGluZ1xuICAgICAgICAgICAgICAgICAgICBSZXBlYXRHcm91cC5hZGQobGFiZWwsIGxheW91dCwgdGlsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuYWRkKGFhYmJzKTsgLy8gYWRkIGxhYmVsIHRvIGN1cnJlbnRseSB2aXNpYmxlIHNldFxuICAgICAgICAgICAgICAgICAgICBrZWVwX2xhYmVscy5wdXNoKGxhYmVsc1twcmlvcml0eV1baV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBhIGNvdW50IG9mIGhvdyBtYW55IHRpbWVzIHRoaXMgc3R5bGUgaXMgdXNlZCBpbiB0aGUgdGlsZVxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yZWYrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGF5b3V0LmNvbGxpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLnRyYWNlKGBkaXNjYXJkIGxhYmVsICcke2xhYmVsLnRleHR9JyBkdWUgdG8gY29sbGlzaW9uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRleHQvc3R5bGUgY29tYmluYXRpb25zIHRoYXQgaGF2ZSBubyB2aXNpYmxlIGxhYmVsc1xuICAgICAgICBmb3IgKGxldCBzdHlsZSBpbiB0ZXh0cykge1xuICAgICAgICAgICAgZm9yIChsZXQgdGV4dCBpbiB0ZXh0c1tzdHlsZV0pIHtcbiAgICAgICAgICAgICAgICAvLyBubyBsYWJlbHMgZm9yIHRoaXMgdGV4dFxuICAgICAgICAgICAgICAgIGlmICh0ZXh0c1tzdHlsZV1bdGV4dF0ucmVmIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGV4dHNbc3R5bGVdW3RleHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzdHlsZSBpbiB0ZXh0cykge1xuICAgICAgICAgICAgLy8gbm8gbGFiZWxzIGZvciB0aGlzIHN0eWxlXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGV4dHNbc3R5bGVdKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGV4dHNbc3R5bGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtlZXBfbGFiZWxzO1xuICAgIH0sXG5cbiAgICAvLyBDYWxsZWQgb24gbWFpbiB0aHJlYWQgZnJvbSB3b3JrZXIsIHRvIGNvbXB1dGUgdGhlIHNpemUgb2YgZWFjaCB0ZXh0IHN0cmluZyxcbiAgICAvLyB3ZXJlIGl0IHRvIGJlIHJlbmRlcmVkLiBUaGlzIGluZm8gaXMgdGhlbiB1c2VkIHRvIHBlcmZvcm0gaW5pdGlhbCBsYWJlbCBjdWxsaW5nLCAqYmVmb3JlKlxuICAgIC8vIGxhYmVscyBhcmUgYWN0dWFsbHkgcmVuZGVyZWQuXG4gICAgY2FsY1RleHRTaXplcyAodGlsZSwgdGV4dHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLnRleHRTaXplcyh0aWxlLCB0ZXh0cyk7XG4gICAgfSxcblxuICAgIC8vIENhbGxlZCBvbiBtYWluIHRocmVhZCBmcm9tIHdvcmtlciwgdG8gY3JlYXRlIGF0bGFzIG9mIGxhYmVscyBmb3IgYSB0aWxlXG4gICAgcmFzdGVyaXplVGV4dHMgKHRpbGUsIHRleHRzKSB7XG4gICAgICAgIGxldCBjYW52YXMgPSBuZXcgQ2FudmFzVGV4dCgpO1xuICAgICAgICBsZXQgdGV4dHVyZV9zaXplID0gY2FudmFzLnNldFRleHR1cmVUZXh0UG9zaXRpb25zKHRleHRzKTtcbiAgICAgICAgbG9nLnRyYWNlKGB0ZXh0IHN1bW1hcnkgZm9yIHRpbGUgJHt0aWxlfTogZml0cyBpbiAke3RleHR1cmVfc2l6ZVswXX14JHt0ZXh0dXJlX3NpemVbMV19cHhgKTtcblxuICAgICAgICAvLyB1cGRhdGUgY2FudmFzIHNpemUgJiByYXN0ZXJpemUgYWxsIHRoZSB0ZXh0IHN0cmluZ3Mgd2UgbmVlZFxuICAgICAgICBjYW52YXMucmVzaXplKC4uLnRleHR1cmVfc2l6ZSk7XG4gICAgICAgIGNhbnZhcy5yYXN0ZXJpemUodGlsZSwgdGV4dHMsIHRleHR1cmVfc2l6ZSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgdGV4dHVyZVxuICAgICAgICBsZXQgdCA9ICdsYWJlbHMtJyArIHRpbGUgKyAnLScgKyAoVGV4dFN0eWxlLnRleHR1cmVfaWQrKyk7XG4gICAgICAgIGxldCB0ZXh0dXJlID0gbmV3IFRleHR1cmUodGhpcy5nbCwgdCk7XG4gICAgICAgIHRleHR1cmUuc2V0Q2FudmFzKGNhbnZhcy5jYW52YXMsIHtcbiAgICAgICAgICAgIGZpbHRlcmluZzogJ2xpbmVhcicsXG4gICAgICAgICAgICBVTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0w6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHsgdGV4dHMsIHRleHR1cmU6IHQgfTsgLy8gdGV4dHVyZSBpcyByZXR1cm5lZCBieSBuYW1lIChub3QgaW5zdGFuY2UpXG4gICAgfSxcblxuICAgIC8vIFNldHMgdXAgY2FjaGluZyBmb3IgZHJhdyBydWxlIHByb3BlcnRpZXNcbiAgICBfcHJlcHJvY2VzcyAoZHJhdykge1xuICAgICAgICBpZiAoIWRyYXcuZm9udCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29sb3JzXG4gICAgICAgIGRyYXcuZm9udC5maWxsID0gU3R5bGVQYXJzZXIuY2FjaGVPYmplY3QoZHJhdy5mb250LmZpbGwpO1xuICAgICAgICBpZiAoZHJhdy5mb250LnN0cm9rZSkge1xuICAgICAgICAgICAgZHJhdy5mb250LnN0cm9rZS5jb2xvciA9IFN0eWxlUGFyc2VyLmNhY2hlT2JqZWN0KGRyYXcuZm9udC5zdHJva2UuY29sb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udmVydCBmb250IGFuZCB0ZXh0IHN0cm9rZSBzaXplc1xuICAgICAgICBkcmF3LmZvbnQucHhfc2l6ZSA9IFN0eWxlUGFyc2VyLmNhY2hlT2JqZWN0KGRyYXcuZm9udC5zaXplLCBDYW52YXNUZXh0LmZvbnRQaXhlbFNpemUpO1xuICAgICAgICBpZiAoZHJhdy5mb250LnN0cm9rZSAmJiBkcmF3LmZvbnQuc3Ryb2tlLndpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRyYXcuZm9udC5zdHJva2Uud2lkdGggPSBTdHlsZVBhcnNlci5jYWNoZU9iamVjdChkcmF3LmZvbnQuc3Ryb2tlLndpZHRoLCBwYXJzZUZsb2F0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9mZnNldCAocGFyc2UgZWFjaCBhcnJheSBjb21wb25lbnQpXG4gICAgICAgIGRyYXcub2Zmc2V0ID0gU3R5bGVQYXJzZXIuY2FjaGVPYmplY3QoZHJhdy5vZmZzZXQsIHYgPT4gKEFycmF5LmlzQXJyYXkodikgJiYgdi5tYXAocGFyc2VGbG9hdCkpIHx8IDApO1xuXG4gICAgICAgIC8vIFJlcGVhdCBydWxlc1xuICAgICAgICBkcmF3LnJlcGVhdF9kaXN0YW5jZSA9IFN0eWxlUGFyc2VyLmNhY2hlT2JqZWN0KGRyYXcucmVwZWF0X2Rpc3RhbmNlLCBwYXJzZUZsb2F0KTtcblxuICAgICAgICByZXR1cm4gZHJhdztcbiAgICB9LFxuXG4gICAgLy8gUGFyc2UgZmVhdHVyZSBpcyBjYWxsZWQgXCJsYXRlXCIsIGFmdGVyIGFsbCBsYWJlbHMgaGF2ZSBiZWVuIGNyZWF0ZWRcbiAgICAvLyBUaGUgdXN1YWwgcGFyc2luZyBkb25lIGJ5IF9wYXJzZUZlYXR1cmUoKSBpcyBoYW5kbGVkIGJ5IGFkZEZlYXR1cmUoKSBhYm92ZVxuICAgIC8vIEhlcmUgd2UganVzdCBwYXNzIHRoZSBsYWJlbCB0aHJvdWdoIHRvIHRoZSBidWlsZCBmdW5jdGlvbnMgYmVsb3dcbiAgICBfcGFyc2VGZWF0dXJlIChmZWF0dXJlLCBkcmF3LCBjb250ZXh0LCBsYWJlbCkge1xuICAgICAgICB0aGlzLmZlYXR1cmVfc3R5bGUubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZV9zdHlsZTtcbiAgICB9LFxuXG4gICAgYnVpbGQgKHN0eWxlLCB2ZXJ0ZXhfZGF0YSkge1xuICAgICAgICBsZXQgdmVydGV4X3RlbXBsYXRlID0gdGhpcy5tYWtlVmVydGV4VGVtcGxhdGUoc3R5bGUpO1xuICAgICAgICBsZXQgbGFiZWwgPSBzdHlsZS5sYWJlbDtcblxuICAgICAgICB0aGlzLnRleGNvb3JkX3NjYWxlID0gbGFiZWwudGV4Y29vcmRzO1xuXG4gICAgICAgIHRoaXMuYnVpbGRRdWFkKFxuICAgICAgICAgICAgW2xhYmVsLnBvc2l0aW9uXSxcbiAgICAgICAgICAgIGxhYmVsLnNpemUubG9naWNhbF9zaXplLFxuICAgICAgICAgICAgVXRpbHMucmFkVG9EZWcobGFiZWwuYW5nbGUpIHx8IDAsIHZlcnRleF9kYXRhLFxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlLCBsYWJlbC5vcHRpb25zLm9mZnNldFxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBidWlsZExpbmVzIChsaW5lcywgc3R5bGUsIHZlcnRleF9kYXRhKSB7XG4gICAgICAgIHRoaXMuYnVpbGQoc3R5bGUsIHZlcnRleF9kYXRhKTtcbiAgICB9LFxuXG4gICAgYnVpbGRQb2ludHMgKHBvaW50cywgc3R5bGUsIHZlcnRleF9kYXRhKSB7XG4gICAgICAgIHRoaXMuYnVpbGQoc3R5bGUsIHZlcnRleF9kYXRhKTtcbiAgICB9LFxuXG4gICAgYnVpbGRQb2x5Z29ucyAocG9pbnRzLCBzdHlsZSwgdmVydGV4X2RhdGEpIHtcbiAgICAgICAgdGhpcy5idWlsZChzdHlsZSwgdmVydGV4X2RhdGEpO1xuICAgIH1cblxufSk7XG5cblRleHRTdHlsZS50ZXh0dXJlX2lkID0gMDsgLy8gbmFtZXNwYWNlcyBwZXItdGlsZSBsYWJlbCB0ZXh0dXJlc1xuIiwiaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBHZW8gZnJvbSAnLi4vLi4vZ2VvJztcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4uL3N0eWxlX3BhcnNlcic7XG5pbXBvcnQgUG9pbnRBbmNob3IgZnJvbSAnLi4vcG9pbnRzL3BvaW50X2FuY2hvcic7XG5cbnZhciBUZXh0U2V0dGluZ3M7XG5cbmV4cG9ydCBkZWZhdWx0IFRleHRTZXR0aW5ncyA9IHtcblxuICAgIC8vIEEga2V5IGZvciBncm91cGluZyBhbGwgbGFiZWxzIG9mIHRoZSBzYW1lIHRleHQgc3R5bGUgKGUuZy4gc2FtZSBDYW52YXMgc3RhdGUsIHRvIG1pbmltaXplIHN0YXRlIGNoYW5nZXMpXG4gICAga2V5IChzZXR0aW5ncykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc2V0dGluZ3Muc3R5bGUsXG4gICAgICAgICAgICBzZXR0aW5ncy53ZWlnaHQsXG4gICAgICAgICAgICBzZXR0aW5ncy5mYW1pbHksXG4gICAgICAgICAgICBzZXR0aW5ncy5weF9zaXplLFxuICAgICAgICAgICAgc2V0dGluZ3MuZmlsbCxcbiAgICAgICAgICAgIHNldHRpbmdzLnN0cm9rZSxcbiAgICAgICAgICAgIHNldHRpbmdzLnN0cm9rZV93aWR0aCxcbiAgICAgICAgICAgIHNldHRpbmdzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIHNldHRpbmdzLnR5cGVmYWNlLFxuICAgICAgICAgICAgc2V0dGluZ3MudGV4dF93cmFwLFxuICAgICAgICAgICAgc2V0dGluZ3MuYWxpZ25cbiAgICAgICAgXS5qb2luKCcvJyk7IC8vIHR5cGVmYWNlIGZvciBsZWdhY3lcbiAgICB9LFxuXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgc3R5bGU6ICdub3JtYWwnLFxuICAgICAgICB3ZWlnaHQ6IG51bGwsXG4gICAgICAgIHNpemU6ICcxMnB4JyxcbiAgICAgICAgcHhfc2l6ZTogMTIsXG4gICAgICAgIGZhbWlseTogJ0hlbHZldGljYScsXG4gICAgICAgIGZpbGw6ICd3aGl0ZScsXG4gICAgICAgIHRleHRfd3JhcDogMTUsXG4gICAgICAgIGFsaWduOiAnY2VudGVyJ1xuICAgIH0sXG5cbiAgICBjb21wdXRlIChmZWF0dXJlLCBkcmF3LCBjb250ZXh0KSB7XG4gICAgICAgIGxldCBzdHlsZSA9IHt9O1xuXG4gICAgICAgIGRyYXcuZm9udCA9IGRyYXcuZm9udCB8fCB0aGlzLmRlZmF1bHRzO1xuXG4gICAgICAgIC8vIFVzZSBmaWxsIGlmIHNwZWNpZmllZCwgb3IgZGVmYXVsdFxuICAgICAgICBzdHlsZS5maWxsID0gKGRyYXcuZm9udC5maWxsICYmIFV0aWxzLnRvQ1NTQ29sb3IoU3R5bGVQYXJzZXIuY2FjaGVDb2xvcihkcmF3LmZvbnQuZmlsbCwgY29udGV4dCkpKSB8fCB0aGlzLmRlZmF1bHRzLmZpbGw7XG5cbiAgICAgICAgLy8gRm9udCBwcm9wZXJ0aWVzIGFyZSBtb2RlbGVkIGFmdGVyIENTUyBuYW1lczpcbiAgICAgICAgLy8gLSBmYW1pbHk6IEhlbHZldGljYSwgRnV0dXJhLCBldGMuXG4gICAgICAgIC8vIC0gc2l6ZTogaW4gcHQsIHB4LCBvciBlbVxuICAgICAgICAvLyAtIHN0eWxlOiBub3JtYWwsIGl0YWxpYywgb2JsaXF1ZVxuICAgICAgICAvLyAtIHdlaWdodDogbm9ybWFsLCBib2xkLCBldGMuXG4gICAgICAgIC8vIC0gdHJhbnNmb3JtOiBjYXBpdGFsaXplLCB1cHBlcmNhc2UsIGxvd2VyY2FzZVxuICAgICAgICBzdHlsZS5zdHlsZSA9IGRyYXcuZm9udC5zdHlsZSB8fCB0aGlzLmRlZmF1bHRzLnN0eWxlO1xuICAgICAgICBzdHlsZS53ZWlnaHQgPSBkcmF3LmZvbnQud2VpZ2h0IHx8IHRoaXMuZGVmYXVsdHMud2VpZ2h0O1xuICAgICAgICBzdHlsZS5mYW1pbHkgPSAoZHJhdy5mb250LmZhbWlseSA/IGAke2RyYXcuZm9udC5mYW1pbHl9LCBgIDogJycpICsgdGhpcy5kZWZhdWx0cy5mYW1pbHk7XG4gICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IGRyYXcuZm9udC50cmFuc2Zvcm07XG5cbiAgICAgICAgLy8gb3JpZ2luYWwgc2l6ZSAobm90IGN1cnJlbnRseSB1c2VkLCBidXQgdXNlZnVsIGZvciBkZWJ1Z2dpbmcpXG4gICAgICAgIHN0eWxlLnNpemUgPSBkcmF3LmZvbnQuc2l6ZSB8fCBkcmF3LmZvbnQudHlwZWZhY2UgfHwgdGhpcy5kZWZhdWx0cy5zaXplOyAvLyBUT0RPOiAndHlwZWZhY2UnIGxlZ2FjeSBzeW50YXgsIGRlcHJlY2F0ZVxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZWQgcGl4ZWwgc2l6ZVxuICAgICAgICBzdHlsZS5weF9zaXplID0gU3R5bGVQYXJzZXIuY2FjaGVQcm9wZXJ0eShkcmF3LmZvbnQucHhfc2l6ZSwgY29udGV4dCkgfHwgdGhpcy5kZWZhdWx0cy5weF9zaXplO1xuXG4gICAgICAgIC8vIFVzZSBzdHJva2UgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChkcmF3LmZvbnQuc3Ryb2tlICYmIGRyYXcuZm9udC5zdHJva2UuY29sb3IpIHtcbiAgICAgICAgICAgIHN0eWxlLnN0cm9rZSA9IFV0aWxzLnRvQ1NTQ29sb3IoU3R5bGVQYXJzZXIuY2FjaGVDb2xvcihkcmF3LmZvbnQuc3Ryb2tlLmNvbG9yLCBjb250ZXh0KSB8fCB0aGlzLmRlZmF1bHRzLnN0cm9rZSk7XG4gICAgICAgICAgICBzdHlsZS5zdHJva2Vfd2lkdGggPSBTdHlsZVBhcnNlci5jYWNoZVByb3BlcnR5KGRyYXcuZm9udC5zdHJva2Uud2lkdGgsIGNvbnRleHQpIHx8IHRoaXMuZGVmYXVsdHMuc3Ryb2tlX3dpZHRoO1xuICAgICAgICAgICAgc3R5bGUuc3Ryb2tlX3dpZHRoICo9IFV0aWxzLmRldmljZV9waXhlbF9yYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmF3LmZvbnQudHlwZWZhY2UpIHsgLy8gJ3R5cGVmYWNlJyBsZWdhY3kgc3ludGF4LCBkZXByZWNhdGVcbiAgICAgICAgICAgIHN0eWxlLmZvbnRfY3NzID0gZHJhdy5mb250LnR5cGVmYWNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3R5bGUuZm9udF9jc3MgPSB0aGlzLmZvbnRDU1Moc3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV29yZCB3cmFwIGFuZCB0ZXh0IGFsaWdubWVudFxuICAgICAgICAvLyBOb3QgYSBmb250IHByb3BlcnRpZXMsIGJ1dCBhZmZlY3QgYXRsYXMgb2YgdW5pcXVlIHRleHQgdGV4dHVyZXNcbiAgICAgICAgbGV0IHRleHRfd3JhcCA9IGRyYXcudGV4dF93cmFwOyAvLyB1c2UgZXhwbGljaXRseSBzZXQgdmFsdWVcbiAgICAgICAgaWYgKHRleHRfd3JhcCA9PSBudWxsICYmIEdlby5nZW9tZXRyeVR5cGUoZmVhdHVyZS5nZW9tZXRyeS50eXBlKSAhPT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICAvLyBwb2ludCBsYWJlbHMgKGZvciBwb2ludCBhbmQgcG9seWdvbiBmZWF0dXJlcykgaGF2ZSB3b3JkIHdyYXAgb24gdy9kZWZhdWx0IG1heCBsZW5ndGgsXG4gICAgICAgICAgICAvLyBsaW5lIGxhYmVscyBkZWZhdWx0IG9mZlxuICAgICAgICAgICAgdGV4dF93cmFwID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHRpbmcgdG8gJ3RydWUnIGNhdXNlcyBkZWZhdWx0IHdyYXAgdmFsdWUgdG8gYmUgdXNlZFxuICAgICAgICBpZiAodGV4dF93cmFwID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0ZXh0X3dyYXAgPSB0aGlzLmRlZmF1bHRzLnRleHRfd3JhcDtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS50ZXh0X3dyYXAgPSB0ZXh0X3dyYXA7XG5cbiAgICAgICAgLy8gZGVmYXVsdCBhbGlnbm1lbnQgdG8gbWF0Y2ggYW5jaG9yXG4gICAgICAgIGlmICghZHJhdy5hbGlnbiAmJiBkcmF3LmFuY2hvciAmJiBkcmF3LmFuY2hvciAhPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIGlmIChQb2ludEFuY2hvci5pc0xlZnRBbmNob3IoZHJhdy5hbmNob3IpKSB7XG4gICAgICAgICAgICAgICAgZHJhdy5hbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChQb2ludEFuY2hvci5pc1JpZ2h0QW5jaG9yKGRyYXcuYW5jaG9yKSkge1xuICAgICAgICAgICAgICAgIGRyYXcuYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZS5hbGlnbiA9IGRyYXcuYWxpZ24gfHwgdGhpcy5kZWZhdWx0cy5hbGlnbjtcblxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcblxuICAgIC8vIEJ1aWxkIENTUy1zdHlsZSBmb250IHN0cmluZyAodG8gc2V0IENhbnZhcyBkcmF3IHN0YXRlKVxuICAgIGZvbnRDU1MgKHsgc3R5bGUsIHdlaWdodCwgcHhfc2l6ZSwgZmFtaWx5IH0pIHtcbiAgICAgICAgcmV0dXJuIFtzdHlsZSwgd2VpZ2h0LCBweF9zaXplICsgJ3B4JywgZmFtaWx5XVxuICAgICAgICAgICAgLmZpbHRlcih4ID0+IHgpIC8vIHJlbW92ZSBudWxsIHByb3BzXG4gICAgICAgICAgICAuam9pbignICcpO1xuICAgIH1cblxufTtcbiIsIi8qZ2xvYmFsIFRpbGUgKi9cbmltcG9ydCBHZW8gZnJvbSAnLi9nZW8nO1xuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfcGFyc2VyJztcbmltcG9ydCB7U3R5bGVNYW5hZ2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9tYW5hZ2VyJztcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi91dGlscy93b3JrZXJfYnJva2VyJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4vZ2wvdGV4dHVyZSc7XG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWxlIHtcblxuICAgIC8qKlxuICAgICAgICBUaWxlXG4gICAgICAgIEBjb25zdHJ1Y3RvclxuICAgICAgICBSZXF1aXJlZCBwcm9wZXJ0aWVzOlxuICAgICAgICBjb29yZHM6IG9iamVjdCB3aXRoIHt4LCB5LCB6fSBwcm9wZXJ0aWVzIGlkZW50aWZ5aW5nIHRpbGUgY29vcmRpbmF0ZSBsb2NhdGlvblxuICAgICAgICB3b3JrZXI6IHdlYiB3b3JrZXIgdG8gaGFuZGxlIHRpbGUgY29uc3RydWN0aW9uXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGNvb3Jkcywgc291cmNlLCB3b3JrZXIsIHN0eWxlX3pvb20gfSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgICAgICAgIGNvb3Jkczoge1xuICAgICAgICAgICAgICAgIHg6IG51bGwsXG4gICAgICAgICAgICAgICAgeTogbnVsbCxcbiAgICAgICAgICAgICAgICB6OiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVidWc6IHt9LFxuICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBsb2FkZWQ6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICB3b3JrZXI6IG51bGwsXG4gICAgICAgICAgICBnZW5lcmF0aW9uOiBudWxsLFxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjZW50ZXJfZGlzdDogMFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLndvcmtlciA9IHdvcmtlcjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuc3R5bGVfem9vbSA9IHN0eWxlX3pvb207IC8vIHpvb20gbGV2ZWwgdG8gYmUgdXNlZCBmb3Igc3R5bGluZ1xuXG4gICAgICAgIHRoaXMuY29vcmRzID0gY29vcmRzO1xuICAgICAgICB0aGlzLmNvb3JkcyA9IFRpbGUub3Zlclpvb21lZENvb3JkaW5hdGUodGhpcy5jb29yZHMsIHRoaXMuc291cmNlLm1heF96b29tKTtcbiAgICAgICAgdGhpcy5jb29yZF9rZXkgPSBUaWxlLmNvb3JkS2V5KHRoaXMuY29vcmRzKTtcbiAgICAgICAgdGhpcy5rZXkgPSBUaWxlLmtleSh0aGlzLmNvb3JkcywgdGhpcy5zb3VyY2UsIHRoaXMuc3R5bGVfem9vbSk7XG4gICAgICAgIHRoaXMubWluID0gR2VvLm1ldGVyc0ZvclRpbGUodGhpcy5jb29yZHMpO1xuICAgICAgICB0aGlzLm1heCA9IEdlby5tZXRlcnNGb3JUaWxlKHt4OiB0aGlzLmNvb3Jkcy54ICsgMSwgeTogdGhpcy5jb29yZHMueSArIDEsIHo6IHRoaXMuY29vcmRzLnogfSksXG4gICAgICAgIHRoaXMuc3BhbiA9IHsgeDogKHRoaXMubWF4LnggLSB0aGlzLm1pbi54KSwgeTogKHRoaXMubWF4LnkgLSB0aGlzLm1pbi55KSB9O1xuICAgICAgICB0aGlzLmJvdW5kcyA9IHsgc3c6IHsgeDogdGhpcy5taW4ueCwgeTogdGhpcy5tYXgueSB9LCBuZTogeyB4OiB0aGlzLm1heC54LCB5OiB0aGlzLm1pbi55IH0gfTtcblxuICAgICAgICAvLyBVbml0cyBwZXIgcGl4ZWwgbmVlZHMgdG8gYWNjb3VudCBmb3Igb3Zlci16b29taW5nXG4gICAgICAgIHRoaXMudW5pdHNfcGVyX3BpeGVsID0gR2VvLnVuaXRzX3Blcl9waXhlbDtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVfem9vbSA+IHRoaXMuY29vcmRzLnopIHtcbiAgICAgICAgICAgIHRoaXMudW5pdHNfcGVyX3BpeGVsIC89IE1hdGgucG93KDIsIHRoaXMuc3R5bGVfem9vbSAtIHRoaXMuY29vcmRzLnopO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tZXNoZXMgPSB7fTsgLy8gcmVuZGVyYWJsZSBWQk8gbWVzaGVzIGtleWVkIGJ5IHN0eWxlXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSBbXTsgLy8gdGV4dHVyZXMgdGhhdCB0aGUgdGlsZSBvd25zIChsYWJlbHMsIGV0Yy4pXG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGlsZShzcGVjKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY29vcmRLZXkoe3gsIHksIHp9KSB7XG4gICAgICAgIHJldHVybiBbeCwgeSwgel0uam9pbignLycpO1xuICAgIH1cblxuICAgIHN0YXRpYyBrZXkgKGNvb3Jkcywgc291cmNlLCBzdHlsZV96b29tKSB7XG4gICAgICAgIGNvb3JkcyA9IFRpbGUub3Zlclpvb21lZENvb3JkaW5hdGUoY29vcmRzLCBzb3VyY2UubWF4X3pvb20pO1xuICAgICAgICBpZiAoY29vcmRzLnkgPCAwIHx8IGNvb3Jkcy55ID49ICgxIDw8IGNvb3Jkcy56KSB8fCBjb29yZHMueiA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gY3VsbCB0aWxlcyBvdXQgb2YgcmFuZ2UgKHggd2lsbCB3cmFwKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc291cmNlLm5hbWUsIHN0eWxlX3pvb20sIGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnpdLmpvaW4oJy8nKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY29vcmRpbmF0ZUF0Wm9vbSh7eCwgeSwgen0sIHpvb20pIHtcbiAgICAgICAgaWYgKHogIT09IHpvb20pIHtcbiAgICAgICAgICAgIGxldCB6c2NhbGUgPSBNYXRoLnBvdygyLCB6IC0gem9vbSk7XG4gICAgICAgICAgICB4ID0gTWF0aC5mbG9vcih4IC8genNjYWxlKTtcbiAgICAgICAgICAgIHkgPSBNYXRoLmZsb29yKHkgLyB6c2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7eCwgeSwgejogem9vbX07XG4gICAgfVxuXG4gICAgc3RhdGljIGlzQ2hpbGQocGFyZW50LCBjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQueiA+IHBhcmVudC56KSB7XG4gICAgICAgICAgICBsZXQge3gsIHl9ID0gVGlsZS5jb29yZGluYXRlQXRab29tKGNoaWxkLCBwYXJlbnQueik7XG4gICAgICAgICAgICByZXR1cm4gKHBhcmVudC54ID09PSB4ICYmIHBhcmVudC55ID09PSB5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RhdGljIG92ZXJab29tZWRDb29yZGluYXRlKHt4LCB5LCB6fSwgbWF4X3pvb20pIHtcbiAgICAgICAgaWYgKG1heF96b29tICE9PSB1bmRlZmluZWQgJiYgeiA+IG1heF96b29tKSB7XG4gICAgICAgICAgICByZXR1cm4gVGlsZS5jb29yZGluYXRlQXRab29tKHt4LCB5LCB6fSwgbWF4X3pvb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7eCwgeSwgen07XG4gICAgfVxuXG4gICAgLy8gU29ydCBhIHNldCBvZiB0aWxlIGluc3RhbmNlcyAod2hpY2ggYWxyZWFkeSBoYXZlIGEgZGlzdGFuY2UgZnJvbSBjZW50ZXIgdGlsZSBjb21wdXRlZClcbiAgICBzdGF0aWMgc29ydCh0aWxlcykge1xuICAgICAgICByZXR1cm4gdGlsZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgbGV0IGFkID0gYS5jZW50ZXJfZGlzdDtcbiAgICAgICAgICAgIGxldCBiZCA9IGIuY2VudGVyX2Rpc3Q7XG4gICAgICAgICAgICByZXR1cm4gKGJkID4gYWQgPyAtMSA6IChiZCA9PT0gYWQgPyAwIDogMSkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmcmVlUmVzb3VyY2VzKCkge1xuICAgICAgICBpZiAodGhpcy5tZXNoZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG0gaW4gdGhpcy5tZXNoZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc2hlc1ttXS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50ZXh0dXJlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLnRleHR1cmVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHR1cmUgPSBUZXh0dXJlLnRleHR1cmVzW3RdO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWVzaGVzID0ge307XG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSBbXTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLndvcmtlck1lc3NhZ2UoJ3NlbGYucmVtb3ZlVGlsZScsIHRoaXMua2V5KTtcbiAgICAgICAgdGhpcy5mcmVlUmVzb3VyY2VzKCk7XG4gICAgICAgIHRoaXMud29ya2VyID0gbnVsbDtcbiAgICB9XG5cbiAgICBidWlsZEFzTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICBjb29yZF9rZXk6IHRoaXMuY29vcmRfa2V5LFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZS5uYW1lLFxuICAgICAgICAgICAgY29vcmRzOiB0aGlzLmNvb3JkcyxcbiAgICAgICAgICAgIG1pbjogdGhpcy5taW4sXG4gICAgICAgICAgICBtYXg6IHRoaXMubWF4LFxuICAgICAgICAgICAgdW5pdHNfcGVyX3BpeGVsOiB0aGlzLnVuaXRzX3Blcl9waXhlbCxcbiAgICAgICAgICAgIHN0eWxlX3pvb206IHRoaXMuc3R5bGVfem9vbSxcbiAgICAgICAgICAgIGdlbmVyYXRpb246IHRoaXMuZ2VuZXJhdGlvbixcbiAgICAgICAgICAgIGRlYnVnOiB0aGlzLmRlYnVnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgd29ya2VyTWVzc2FnZSAoLi4ubWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHRoaXMud29ya2VyLCAuLi5tZXNzYWdlKTtcbiAgICB9XG5cbiAgICBidWlsZChnZW5lcmF0aW9uKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGlvbiA9IGdlbmVyYXRpb247XG4gICAgICAgIGlmICghdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud29ya2VyTWVzc2FnZSgnc2VsZi5idWlsZFRpbGUnLCB7IHRpbGU6IHRoaXMuYnVpbGRBc01lc3NhZ2UoKSB9KS5jYXRjaChlID0+IHsgdGhyb3cgZTsgfSk7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBnZW9tZXRyeSBmb3IgdGlsZSAtIGNhbGxlZCBieSB3ZWIgd29ya2VyXG4gICAgLy8gUmV0dXJucyBhIHNldCBvZiB0aWxlIGtleXMgdGhhdCBzaG91bGQgYmUgc2VudCB0byB0aGUgbWFpbiB0aHJlYWQgKHNvIHRoYXQgd2UgY2FuIG1pbmltaXplIGRhdGEgZXhjaGFuZ2UgYmV0d2VlbiB3b3JrZXIgYW5kIG1haW4gdGhyZWFkKVxuICAgIHN0YXRpYyBidWlsZEdlb21ldHJ5ICh0aWxlLCBsYXllcnMsIHJ1bGVzLCBzdHlsZXMpIHtcbiAgICAgICAgdGlsZS5kZWJ1Zy5yZW5kZXJpbmcgPSArbmV3IERhdGUoKTtcbiAgICAgICAgdGlsZS5kZWJ1Zy5mZWF0dXJlcyA9IDA7XG5cbiAgICAgICAgbGV0IGRhdGEgPSB0aWxlLnNvdXJjZV9kYXRhO1xuXG4gICAgICAgIC8vIFRyZWF0IHRvcC1sZXZlbCBzdHlsZSBydWxlcyBhcyAnbGF5ZXJzJ1xuICAgICAgICBmb3IgKGxldCBsYXllcl9uYW1lIGluIGxheWVycykge1xuICAgICAgICAgICAgbGV0IGxheWVyID0gbGF5ZXJzW2xheWVyX25hbWVdO1xuICAgICAgICAgICAgLy8gU2tpcCBsYXllcnMgd2l0aCBubyBkYXRhIHNvdXJjZSBkZWZpbmVkXG4gICAgICAgICAgICBpZiAoIWxheWVyIHx8ICFsYXllci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm4oYExheWVyICR7bGF5ZXJ9IHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZW9tZXRyeSBkYXRhIHNvdXJjZSBhbmQgd2lsbCBub3QgYmUgcmVuZGVyZWQuYCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNvdXJjZSBuYW1lcyBkb24ndCBtYXRjaFxuICAgICAgICAgICAgaWYgKGxheWVyLmRhdGEuc291cmNlICE9PSB0aWxlLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgZGF0YSBmb3Igb25lIG9yIG1vcmUgbGF5ZXJzIGZyb20gc291cmNlXG4gICAgICAgICAgICBsZXQgc291cmNlX2xheWVycyA9IFRpbGUuZ2V0RGF0YUZvclNvdXJjZShkYXRhLCBsYXllci5kYXRhLCBsYXllcl9uYW1lKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VfbGF5ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW5kZXIgZmVhdHVyZXMgaW4gbGF5ZXJcbiAgICAgICAgICAgIHNvdXJjZV9sYXllcnMuZm9yRWFjaChzb3VyY2VfbGF5ZXIgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBnZW9tID0gc291cmNlX2xheWVyLmdlb207XG4gICAgICAgICAgICAgICAgaWYgKCFnZW9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBmID0gMDsgZiA8IGdlb20uZmVhdHVyZXMubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZlYXR1cmUgPSBnZW9tLmZlYXR1cmVzW2ZdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5nZW9tZXRyeSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCBmZWF0dXJlcyB3L28gZ2VvbWV0cnkgKHZhbGlkIEdlb0pTT04pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgY29udGV4dCA9IFN0eWxlUGFyc2VyLmdldEZlYXR1cmVQYXJzZUNvbnRleHQoZmVhdHVyZSwgdGlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGF5ZXIgPSBzb3VyY2VfbGF5ZXIubGF5ZXI7IC8vIGFkZCBkYXRhIHNvdXJjZSBsYXllciBuYW1lXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGRyYXcgZ3JvdXBzIGZvciB0aGlzIGZlYXR1cmVcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxheWVyX3J1bGVzID0gcnVsZXNbbGF5ZXJfbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBkcmF3X2dyb3VwcyA9IGxheWVyX3J1bGVzLmJ1aWxkRHJhd0dyb3Vwcyhjb250ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkcmF3X2dyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW5kZXIgZHJhdyBncm91cHNcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBfbmFtZSBpbiBkcmF3X2dyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gZHJhd19ncm91cHNbZ3JvdXBfbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWdyb3VwLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIHN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGVfbmFtZSA9IGdyb3VwLnN0eWxlIHx8IGdyb3VwX25hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSBzdHlsZXNbc3R5bGVfbmFtZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cud2FybihgU3R5bGUgJyR7c3R5bGVfbmFtZX0nIG5vdCBmb3VuZCBmb3IgcnVsZSBpbiBsYXllciAnJHtsYXllcl9uYW1lfSc6YCwgZ3JvdXAsIGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnByb3BlcnRpZXMgPSBncm91cC5wcm9wZXJ0aWVzOyAvLyBhZGQgcnVsZS1zcGVjaWZpYyBwcm9wZXJ0aWVzIHRvIGNvbnRleHRcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUuYWRkRmVhdHVyZShmZWF0dXJlLCBncm91cCwgY29udGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucHJvcGVydGllcyA9IG51bGw7IC8vIGNsZWFyIGdyb3VwLXNwZWNpZmljIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRpbGUuZGVidWcuZmVhdHVyZXMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aWxlLmRlYnVnLnJlbmRlcmluZyA9ICtuZXcgRGF0ZSgpIC0gdGlsZS5kZWJ1Zy5yZW5kZXJpbmc7XG5cbiAgICAgICAgLy8gRmluYWxpemUgYXJyYXkgYnVmZmVyIGZvciBlYWNoIHJlbmRlciBzdHlsZVxuICAgICAgICBsZXQgdGlsZV9zdHlsZXMgPSBTdHlsZU1hbmFnZXIuc3R5bGVzRm9yVGlsZSh0aWxlLmtleSk7XG4gICAgICAgIHRpbGUubWVzaF9kYXRhID0ge307XG4gICAgICAgIGxldCBxdWV1ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBzdHlsZV9uYW1lIG9mIHRpbGVfc3R5bGVzKSB7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSBzdHlsZXNbc3R5bGVfbmFtZV07XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKHN0eWxlLmVuZERhdGEodGlsZS5rZXkpLnRoZW4oKHN0eWxlX2RhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVfZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aWxlLm1lc2hfZGF0YVtzdHlsZV9uYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleF9kYXRhOiBzdHlsZV9kYXRhLnZlcnRleF9kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXM6IHN0eWxlX2RhdGEudW5pZm9ybXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlczogc3R5bGVfZGF0YS50ZXh0dXJlc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChxdWV1ZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBSZXR1cm4ga2V5cyB0byBiZSB0cmFuc2ZlcmVkIHRvIG1haW4gdGhyZWFkXG4gICAgICAgICAgICByZXR1cm4gWydtZXNoX2RhdGEnXTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgIFJldHJpZXZlcyBnZW9tZXRyeSBmcm9tIGEgdGlsZSBhY2NvcmRpbmcgdG8gYSBkYXRhIHNvdXJjZSBkZWZpbml0aW9uXG4gICAgICAgIFJldHVybnMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoOlxuICAgICAgICAgICAgbGF5ZXI6IHNvdXJjZSBsYXllciBuYW1lXG4gICAgICAgICAgICBnZW9tOiBHZW9KU09OIEZlYXR1cmVDb2xsZWN0aW9uXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0RGF0YUZvclNvdXJjZSAoc291cmNlX2RhdGEsIHNvdXJjZV9jb25maWcsIGRlZmF1bHRfbGF5ZXIgPSBudWxsKSB7XG4gICAgICAgIHZhciBsYXllcnMgPSBbXTtcblxuICAgICAgICBpZiAoc291cmNlX2NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiBubyBsYXllciBzcGVjaWZpZWQsIGFuZCBhIGRlZmF1bHQgc291cmNlIGxheWVyIGV4aXN0c1xuICAgICAgICAgICAgaWYgKCFzb3VyY2VfY29uZmlnLmxheWVyICYmIHNvdXJjZV9kYXRhLmxheWVycy5fZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGxheWVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6ICdfZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgICAgIGdlb206IHNvdXJjZV9kYXRhLmxheWVycy5fZGVmYXVsdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgbm8gbGF5ZXIgc3BlY2lmaWVkLCBhbmQgYSBkZWZhdWx0IHJlcXVlc3RlZCBsYXllciBleGlzdHNcbiAgICAgICAgICAgIGVsc2UgaWYgKCFzb3VyY2VfY29uZmlnLmxheWVyICYmIGRlZmF1bHRfbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBsYXllcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiBkZWZhdWx0X2xheWVyLFxuICAgICAgICAgICAgICAgICAgICBnZW9tOiBzb3VyY2VfZGF0YS5sYXllcnNbZGVmYXVsdF9sYXllcl1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGEgbGF5ZXIgaXMgc3BlY2lmaWVkIGJ5IG5hbWUsIHVzZSBpdFxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNvdXJjZV9jb25maWcubGF5ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsYXllcjogc291cmNlX2NvbmZpZy5sYXllcixcbiAgICAgICAgICAgICAgICAgICAgZ2VvbTogc291cmNlX2RhdGEubGF5ZXJzW3NvdXJjZV9jb25maWcubGF5ZXJdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBtdWx0aXBsZSBsYXllcnMgYXJlIHNwZWNpZmllZCBieSBuYW1lLCBjb21iaW5lIHRoZW1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlX2NvbmZpZy5sYXllcikpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VfY29uZmlnLmxheWVyLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlX2RhdGEubGF5ZXJzW2xheWVyXSAmJiBzb3VyY2VfZGF0YS5sYXllcnNbbGF5ZXJdLmZlYXR1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbTogc291cmNlX2RhdGEubGF5ZXJzW2xheWVyXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFzc2VtYmxlIGEgY3VzdG9tIGxheWVyIHZpYSBhIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQgd2l0aCBhbGwgc291cmNlIGxheWVyc1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNvdXJjZV9jb25maWcubGF5ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsYXllcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGdlb206IHNvdXJjZV9jb25maWcubGF5ZXIoc291cmNlX2RhdGEubGF5ZXJzKVxuICAgICAgICAgICAgICAgICAgICAvLyBjdXN0b20gbGF5ZXIgaGFzIG5vIG5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXllcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgQ2FsbGVkIG9uIG1haW4gdGhyZWFkIHdoZW4gYSB3ZWIgd29ya2VyIGNvbXBsZXRlcyBwcm9jZXNzaW5nXG4gICAgICAgZm9yIGEgc2luZ2xlIHRpbGUuXG4gICAgKi9cbiAgICBidWlsZE1lc2hlcyhzdHlsZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsZWFudXAgZXhpc3RpbmcgVkJPc1xuICAgICAgICB0aGlzLmZyZWVSZXNvdXJjZXMoKTtcblxuICAgICAgICAvLyBEZWJ1Z1xuICAgICAgICB0aGlzLmRlYnVnLmdlb21ldHJpZXMgPSAwO1xuICAgICAgICB0aGlzLmRlYnVnLmJ1ZmZlcl9zaXplID0gMDtcblxuICAgICAgICAvLyBDcmVhdGUgVkJPc1xuICAgICAgICBsZXQgbWVzaF9kYXRhID0gdGhpcy5tZXNoX2RhdGE7XG4gICAgICAgIGlmIChtZXNoX2RhdGEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHMgaW4gbWVzaF9kYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc2hfZGF0YVtzXS52ZXJ0ZXhfZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnLmJ1ZmZlcl9zaXplICs9IG1lc2hfZGF0YVtzXS52ZXJ0ZXhfZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0eWxlc1tzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oYENvdWxkIG5vdCBjcmVhdGUgbWVzaCBiZWNhdXNlIHN0eWxlICcke3N9JyBub3QgZm91bmQsIGZvciB0aWxlICR7dGhpcy5rZXl9LCBhYm9ydGluZyB0aWxlYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc2hlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNoZXNbc10gPSBzdHlsZXNbc10ubWFrZU1lc2gobWVzaF9kYXRhW3NdLnZlcnRleF9kYXRhLCBtZXNoX2RhdGFbc10pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnLmdlb21ldHJpZXMgKz0gdGhpcy5tZXNoZXNbc10uZ2VvbWV0cnlfY291bnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQXNzaWduIG93bmVyc2hpcCB0byB0ZXh0dXJlcyBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAobWVzaF9kYXRhW3NdLnRleHR1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZXMucHVzaCguLi5tZXNoX2RhdGFbc10udGV4dHVyZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVidWcuZ2VvbV9yYXRpbyA9ICh0aGlzLmRlYnVnLmdlb21ldHJpZXMgLyB0aGlzLmRlYnVnLmZlYXR1cmVzKS50b0ZpeGVkKDEpO1xuICAgICAgICB0aGlzLm1lc2hfZGF0YSA9IG51bGw7IC8vIFRPRE86IG1pZ2h0IHdhbnQgdG8gcHJlc2VydmUgdGhpcyBmb3IgcmVidWlsZGluZyBnZW9tZXRyaWVzIHdoZW4gc3R5bGVzL2V0Yy4gY2hhbmdlP1xuICAgICAgICB0aGlzLnByaW50RGVidWcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAgQ2FsbGVkIG9uIG1haW4gdGhyZWFkIHdoZW4gd2ViIHdvcmtlciBjb21wbGV0ZXMgcHJvY2Vzc2luZywgYnV0IHRpbGUgaGFzIHNpbmNlIGJlZW4gZGlzY2FyZGVkXG4gICAgICAgIEZyZWVzIHJlc291cmNlcyB0aGF0IHdvdWxkIGhhdmUgYmVlbiB0cmFuc2ZlcnJlZCB0byB0aGUgdGlsZSBvYmplY3QuXG4gICAgICAgIFN0YXRpYyBtZXRob2QgYmVjYXVzZSB0aGUgdGlsZSBvYmplY3Qgbm8gbG9uZ2VyIGV4aXN0cyAodGhlIHRpbGUgZGF0YSByZXR1cm5lZCBieSB0aGUgd29ya2VyIGlzIHBhc3NlZCBpbnN0ZWFkKS5cbiAgICAqL1xuICAgIHN0YXRpYyBhYm9ydEJ1aWxkICh0aWxlKSB7XG4gICAgICAgIGlmICh0aWxlLm1lc2hfZGF0YSkge1xuICAgICAgICAgICAgZm9yIChsZXQgcyBpbiB0aWxlLm1lc2hfZGF0YSkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0dXJlcyA9IHRpbGUubWVzaF9kYXRhW3NdLnRleHR1cmVzO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRleHR1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dHVyZSA9IFRleHR1cmUudGV4dHVyZXNbdF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy50cmFjZShgZGVzdHJveWluZyB0ZXh0dXJlICR7dH0gZm9yIHRpbGUgJHt0aWxlLmtleX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaW50RGVidWcgKCkge1xuICAgICAgICBsb2cuZGVidWcoYFRpbGU6IGRlYnVnIGZvciAke3RoaXMua2V5fTogWyAgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmRlYnVnKX0gXWApO1xuICAgIH1cblxuICAgIHVwZGF0ZShzY2VuZSkge1xuICAgICAgICBsZXQgY29vcmRzID0gdGhpcy5jb29yZHM7XG4gICAgICAgIGlmIChjb29yZHMueiAhPT0gc2NlbmUuY2VudGVyX3RpbGUueikge1xuICAgICAgICAgICAgY29vcmRzID0gVGlsZS5jb29yZGluYXRlQXRab29tKGNvb3Jkcywgc2NlbmUuY2VudGVyX3RpbGUueik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jZW50ZXJfZGlzdCA9IE1hdGguYWJzKHNjZW5lLmNlbnRlcl90aWxlLnggLSBjb29yZHMueCkgKyBNYXRoLmFicyhzY2VuZS5jZW50ZXJfdGlsZS55IC0gY29vcmRzLnkpO1xuICAgIH1cblxuICAgIC8vIFNsaWNlIGEgc3Vic2V0IG9mIGtleXMgb3V0IG9mIGEgdGlsZVxuICAgIC8vIEluY2x1ZGVzIGEgbWluaW11bSBzZXQgb2YgcHJlLWRlZmluZWQga2V5cyBmb3IgbG9hZCBzdGF0ZSwgZGVidWcuIGV0Yy5cbiAgICAvLyBXZSB1c2UgdGhpcyB0byBzZW5kIGEgc3Vic2V0IG9mIHRoZSB0aWxlIGJhY2sgdG8gdGhlIG1haW4gdGhyZWFkLCB0byBtaW5pbWl6ZSB1bm5lY2Vzc2FyeSBkYXRhIHRyYW5zZmVyXG4gICAgLy8gKGUuZy4gdmVyeSBsYXJnZSBpdGVtcyBsaWtlIGZlYXR1cmUgZ2VvbWV0cnkgYXJlIG5vdCBuZWVkZWQgb24gdGhlIG1haW4gdGhyZWFkKVxuICAgIHN0YXRpYyBzbGljZSAodGlsZSwga2V5cykge1xuICAgICAgICBsZXQga2VlcCA9IFtcbiAgICAgICAgICAgICdrZXknLFxuICAgICAgICAgICAgJ2xvYWRpbmcnLFxuICAgICAgICAgICAgJ2xvYWRlZCcsXG4gICAgICAgICAgICAnZ2VuZXJhdGlvbicsXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgJ2RlYnVnJ1xuICAgICAgICBdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgICAgICAgICAga2VlcC5wdXNoKC4uLmtleXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnVpbGQgdGhlIHRpbGUgc3Vic2V0XG4gICAgICAgIHZhciB0aWxlX3N1YnNldCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBrZXkgb2Yga2VlcCkge1xuICAgICAgICAgICAgdGlsZV9zdWJzZXRba2V5XSA9IHRpbGVba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aWxlX3N1YnNldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAgQ2FsbGVkIG9uIHdvcmtlciB0byBjYW5jZWwgbG9hZGluZ1xuICAgICAgICBTdGF0aWMgbWV0aG9kIGJlY2F1c2UgdGhlIHdvcmtlciBvbmx5IGhhcyBvYmplY3QgcmVwcmVzZW50YXRpb25zIG9mIHRpbGUgZGF0YSwgdGhlcmUgaXMgbm9cbiAgICAgICAgdGlsZSBpbnN0YW5jZSBjcmVhdGVkIHlldC5cbiAgICAqL1xuICAgIHN0YXRpYyBjYW5jZWwodGlsZSkge1xuICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgICAgaWYgKHRpbGUuc291cmNlX2RhdGEgJiYgdGlsZS5zb3VyY2VfZGF0YS5yZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgdGlsZS5zb3VyY2VfZGF0YS5yZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBUaWxlLmFib3J0QnVpbGQodGlsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3RoZXIpIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdrZXknKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gb3RoZXJba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbn1cbiIsImltcG9ydCBUaWxlIGZyb20gJy4vdGlsZSc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy91dGlscyc7XG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG52YXIgVGlsZU1hbmFnZXI7XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVNYW5hZ2VyID0ge1xuXG4gICAgaW5pdChzY2VuZSkge1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICAgIHRoaXMudGlsZXMgPSB7fTtcbiAgICAgICAgdGhpcy52aXNpYmxlX2Nvb3JkcyA9IHt9O1xuICAgICAgICB0aGlzLnF1ZXVlZF9jb29yZHMgPSBbXTtcbiAgICAgICAgdGhpcy5idWlsZGluZ190aWxlcyA9IG51bGw7XG4gICAgfSxcblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaFRpbGUodGlsZSA9PiB0aWxlLmRlc3Ryb3koKSk7XG4gICAgICAgIHRoaXMudGlsZXMgPSB7fTtcbiAgICAgICAgdGhpcy52aXNpYmxlX2Nvb3JkcyA9IHt9O1xuICAgICAgICB0aGlzLnF1ZXVlZF9jb29yZHMgPSBbXTtcbiAgICAgICAgdGhpcy5zY2VuZSA9IG51bGw7XG4gICAgfSxcblxuICAgIGtlZXBUaWxlKHRpbGUpIHtcbiAgICAgICAgdGhpcy50aWxlc1t0aWxlLmtleV0gPSB0aWxlO1xuICAgIH0sXG5cbiAgICBoYXNUaWxlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlc1trZXldICE9PSB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIGZvcmdldFRpbGUoa2V5KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRpbGVzW2tleV07XG4gICAgICAgIHRoaXMudGlsZUJ1aWxkU3RvcChrZXkpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBzaW5nbGUgdGlsZVxuICAgIHJlbW92ZVRpbGUoa2V5KSB7XG4gICAgICAgIGxvZy50cmFjZShgdGlsZSB1bmxvYWQgZm9yICR7a2V5fWApO1xuXG4gICAgICAgIHZhciB0aWxlID0gdGhpcy50aWxlc1trZXldO1xuXG4gICAgICAgIGlmICh0aWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRpbGUuZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mb3JnZXRUaWxlKHRpbGUua2V5KTtcbiAgICAgICAgdGhpcy5zY2VuZS5yZXF1ZXN0UmVkcmF3KCk7XG4gICAgfSxcblxuICAgIC8vIFJ1biBhIGZ1bmN0aW9uIG9uIGVhY2ggdGlsZVxuICAgIGZvckVhY2hUaWxlKGZ1bmMpIHtcbiAgICAgICAgZm9yIChsZXQgdCBpbiB0aGlzLnRpbGVzKSB7XG4gICAgICAgICAgICBmdW5jKHRoaXMudGlsZXNbdF0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aWxlcyB0aGF0IHBhc3MgYSBmaWx0ZXIgY29uZGl0aW9uXG4gICAgcmVtb3ZlVGlsZXMoZmlsdGVyKSB7XG4gICAgICAgIGxldCByZW1vdmVfdGlsZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgdCBpbiB0aGlzLnRpbGVzKSB7XG4gICAgICAgICAgICBsZXQgdGlsZSA9IHRoaXMudGlsZXNbdF07XG4gICAgICAgICAgICBpZiAoZmlsdGVyKHRpbGUpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlX3RpbGVzLnB1c2godCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcj0wOyByIDwgcmVtb3ZlX3RpbGVzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICBsZXQga2V5ID0gcmVtb3ZlX3RpbGVzW3JdO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVUaWxlKGtleSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlVGlsZXNGb3JWaWV3KCkge1xuICAgICAgICAvLyBGaW5kIHZpc2libGUgdGlsZXMgYW5kIGxvYWQgbmV3IG9uZXNcbiAgICAgICAgdGhpcy52aXNpYmxlX2Nvb3JkcyA9IHt9O1xuICAgICAgICBsZXQgdGlsZV9jb29yZHMgPSB0aGlzLnNjZW5lLmZpbmRWaXNpYmxlVGlsZUNvb3JkaW5hdGVzKCk7XG4gICAgICAgIGZvciAobGV0IGNvb3JkcyBvZiB0aWxlX2Nvb3Jkcykge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZUNvb3JkaW5hdGUoY29vcmRzKTtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZV9jb29yZHNbVGlsZS5jb29yZEtleShjb29yZHMpXSA9IGNvb3JkcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aWxlcyB0b28gZmFyIG91dHNpZGUgb2Ygdmlld1xuICAgICAgICB0aGlzLnNjZW5lLnBydW5lVGlsZUNvb3JkaW5hdGVzRm9yVmlldygpOyAvLyBUT0RPOiByZXR1cm4gbGlzdCB0byBwcnVuZT9cblxuICAgICAgICB0aGlzLmZvckVhY2hUaWxlKHRpbGUgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KHRpbGUpO1xuICAgICAgICAgICAgdGlsZS51cGRhdGUodGhpcy5zY2VuZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB1cGRhdGVWaXNpYmlsaXR5KHRpbGUpIHtcbiAgICAgICAgaWYgKHRpbGUuc3R5bGVfem9vbSAhPT0gdGhpcy5zY2VuZS50aWxlX3pvb20pIHtcbiAgICAgICAgICAgIHRpbGUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZV9jb29yZHNbdGlsZS5jb29yZF9rZXldKSB7XG4gICAgICAgICAgICB0aWxlLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYnJ1dGUgZm9yY2VcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLnZpc2libGVfY29vcmRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKFRpbGUuaXNDaGlsZCh0aWxlLmNvb3JkcywgdGhpcy52aXNpYmxlX2Nvb3Jkc1trZXldKSkge1xuICAgICAgICAgICAgICAgICAgICB0aWxlLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aWxlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRSZW5kZXJhYmxlVGlsZXMoKSB7XG4gICAgICAgIGxldCB0aWxlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0IGluIHRoaXMudGlsZXMpIHtcbiAgICAgICAgICAgIGxldCB0aWxlID0gdGhpcy50aWxlc1t0XTtcbiAgICAgICAgICAgIGlmICh0aWxlLnZpc2libGUgJiYgdGlsZS5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICB0aWxlcy5wdXNoKHRpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aWxlcztcbiAgICB9LFxuXG4gICAgLy8gUXVldWUgYSB0aWxlIGZvciBsb2FkXG4gICAgcXVldWVDb29yZGluYXRlKGNvb3Jkcykge1xuICAgICAgICB0aGlzLnF1ZXVlZF9jb29yZHNbdGhpcy5xdWV1ZWRfY29vcmRzLmxlbmd0aF0gPSBjb29yZHM7XG4gICAgfSxcblxuICAgIC8vIExvYWQgYWxsIHF1ZXVlZCB0aWxlc1xuICAgIGxvYWRRdWV1ZWRDb29yZGluYXRlcygpIHtcbiAgICAgICAgaWYgKHRoaXMucXVldWVkX2Nvb3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvcnQgcXVldWVkIHRpbGVzIGZyb20gY2VudGVyIHRpbGVcbiAgICAgICAgdGhpcy5xdWV1ZWRfY29vcmRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGxldCBhZCA9IE1hdGguYWJzKHRoaXMuc2NlbmUuY2VudGVyX3RpbGUueCAtIGEueCkgKyBNYXRoLmFicyh0aGlzLnNjZW5lLmNlbnRlcl90aWxlLnkgLSBhLnkpO1xuICAgICAgICAgICAgbGV0IGJkID0gTWF0aC5hYnModGhpcy5zY2VuZS5jZW50ZXJfdGlsZS54IC0gYi54KSArIE1hdGguYWJzKHRoaXMuc2NlbmUuY2VudGVyX3RpbGUueSAtIGIueSk7XG4gICAgICAgICAgICByZXR1cm4gKGJkID4gYWQgPyAtMSA6IChiZCA9PT0gYWQgPyAwIDogMSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5xdWV1ZWRfY29vcmRzLmZvckVhY2goY29vcmRzID0+IHRoaXMubG9hZENvb3JkaW5hdGUoY29vcmRzKSk7XG4gICAgICAgIHRoaXMucXVldWVkX2Nvb3JkcyA9IFtdO1xuICAgIH0sXG5cbiAgICAvLyBMb2FkIGFsbCB0aWxlcyB0byBjb3ZlciBhIGdpdmVuIGxvZ2ljYWwgdGlsZSBjb29yZGluYXRlXG4gICAgbG9hZENvb3JkaW5hdGUoY29vcmRzKSB7XG4gICAgICAgIC8vIFNraXAgaWYgbm90IGF0IGN1cnJlbnQgc2NlbmUgem9vbVxuICAgICAgICBpZiAoY29vcmRzLnogIT09IHRoaXMuc2NlbmUuY2VudGVyX3RpbGUueikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIG5lY2Vzc2FyeSB0aWxlcyBmb3IgZWFjaCBzb3VyY2VcbiAgICAgICAgZm9yIChsZXQgc291cmNlIG9mIFV0aWxzLnZhbHVlcyh0aGlzLnNjZW5lLnNvdXJjZXMpKSB7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZS50aWxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQga2V5ID0gVGlsZS5rZXkoY29vcmRzLCBzb3VyY2UsIHRoaXMuc2NlbmUudGlsZV96b29tKTtcbiAgICAgICAgICAgIGlmIChrZXkgJiYgIXRoaXMuaGFzVGlsZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRpbGUgPSBUaWxlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzLFxuICAgICAgICAgICAgICAgICAgICAvLyBtYXhfem9vbTogdGhpcy5zY2VuZS5maW5kTWF4Wm9vbSgpLCAvLyBUT0RPOiByZXBsYWNlIHdpdGggYmV0dGVyIG1heCB6b29tIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcjogdGhpcy5zY2VuZS5uZXh0V29ya2VyKCksXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlX3pvb206IHRoaXMuc2NlbmUuc3R5bGVab29tKGNvb3Jkcy56KSAvLyBUT0RPOiByZXBsYWNlP1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5rZWVwVGlsZSh0aWxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkVGlsZSh0aWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBTb3J0IGFuZCBidWlsZCBhIGxpc3Qgb2YgdGlsZXNcbiAgICBidWlsZFRpbGVzKHRpbGVzKSB7XG4gICAgICAgIFRpbGUuc29ydCh0aWxlcykuZm9yRWFjaCh0aWxlID0+IHRoaXMuYnVpbGRUaWxlKHRpbGUpKTtcbiAgICAgICAgdGhpcy5jaGVja0J1aWxkUXVldWUoKTtcbiAgICB9LFxuXG4gICAgYnVpbGRUaWxlKHRpbGUpIHtcbiAgICAgICAgdGhpcy50aWxlQnVpbGRTdGFydCh0aWxlLmtleSk7XG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSh0aWxlKTtcbiAgICAgICAgdGlsZS51cGRhdGUodGhpcy5zY2VuZSk7XG4gICAgICAgIHRpbGUuYnVpbGQodGhpcy5zY2VuZS5nZW5lcmF0aW9uKVxuICAgICAgICAgICAgLnRoZW4obWVzc2FnZSA9PiB0aGlzLmJ1aWxkVGlsZUNvbXBsZXRlZChtZXNzYWdlKSlcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JnZXRUaWxlKHRpbGUua2V5KTtcbiAgICAgICAgICAgICAgICBUaWxlLmFib3J0QnVpbGQodGlsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gQ2FsbGVkIG9uIG1haW4gdGhyZWFkIHdoZW4gYSB3ZWIgd29ya2VyIGNvbXBsZXRlcyBwcm9jZXNzaW5nIGZvciBhIHNpbmdsZSB0aWxlIChpbml0aWFsIGxvYWQsIG9yIHJlYnVpbGQpXG4gICAgYnVpbGRUaWxlQ29tcGxldGVkKHsgdGlsZSB9KSB7XG4gICAgICAgIC8vIFJlbW92ZWQgdGhpcyB0aWxlIGR1cmluZyBsb2FkP1xuICAgICAgICBpZiAodGhpcy50aWxlc1t0aWxlLmtleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nLnRyYWNlKGBkaXNjYXJkZWQgdGlsZSAke3RpbGUua2V5fSBpbiBUaWxlTWFuYWdlci5idWlsZFRpbGVDb21wbGV0ZWQgYmVjYXVzZSBwcmV2aW91c2x5IHJlbW92ZWRgKTtcbiAgICAgICAgICAgIFRpbGUuYWJvcnRCdWlsZCh0aWxlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGlsZXNGb3JWaWV3KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVpbHQgd2l0aCBhbiBvdXRkYXRlZCBzY2VuZSBjb25maWd1cmF0aW9uP1xuICAgICAgICBlbHNlIGlmICh0aWxlLmdlbmVyYXRpb24gIT09IHRoaXMuc2NlbmUuZ2VuZXJhdGlvbikge1xuICAgICAgICAgICAgbG9nLmRlYnVnKGBkaXNjYXJkZWQgdGlsZSAke3RpbGUua2V5fSBpbiBUaWxlTWFuYWdlci5idWlsZFRpbGVDb21wbGV0ZWQgYmVjYXVzZSBidWlsdCB3aXRoIGAgK1xuICAgICAgICAgICAgICAgIGBzY2VuZSBjb25maWcgZ2VuICR7dGlsZS5nZW5lcmF0aW9ufSwgY3VycmVudCAke3RoaXMuc2NlbmUuZ2VuZXJhdGlvbn1gKTtcbiAgICAgICAgICAgIHRoaXMuZm9yZ2V0VGlsZSh0aWxlLmtleSk7XG4gICAgICAgICAgICBUaWxlLmFib3J0QnVpbGQodGlsZSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRpbGVzRm9yVmlldygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRpbGUgd2l0aCBwcm9wZXJ0aWVzIGZyb20gd29ya2VyXG4gICAgICAgICAgICBpZiAodGhpcy50aWxlc1t0aWxlLmtleV0pIHtcbiAgICAgICAgICAgICAgICB0aWxlID0gdGhpcy50aWxlc1t0aWxlLmtleV0ubWVyZ2UodGlsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSh0aWxlKTtcbiAgICAgICAgICAgIHRpbGUudXBkYXRlKHRoaXMuc2NlbmUpO1xuICAgICAgICAgICAgdGlsZS5idWlsZE1lc2hlcyh0aGlzLnNjZW5lLnN0eWxlcyk7XG4gICAgICAgICAgICB0aGlzLnNjZW5lLnJlcXVlc3RSZWRyYXcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGlsZUJ1aWxkU3RvcCh0aWxlLmtleSk7XG4gICAgfSxcblxuICAgIC8vIFRyYWNrIHRpbGUgYnVpbGQgc3RhdGVcbiAgICB0aWxlQnVpbGRTdGFydChrZXkpIHtcbiAgICAgICAgdGhpcy5idWlsZGluZ190aWxlcyA9IHRoaXMuYnVpbGRpbmdfdGlsZXMgfHwge307XG4gICAgICAgIHRoaXMuYnVpbGRpbmdfdGlsZXNba2V5XSA9IHRydWU7XG4gICAgICAgIGxvZy50cmFjZShgdGlsZUJ1aWxkU3RhcnQgZm9yICR7a2V5fTogJHtPYmplY3Qua2V5cyh0aGlzLmJ1aWxkaW5nX3RpbGVzKS5sZW5ndGh9YCk7XG4gICAgfSxcblxuICAgIHRpbGVCdWlsZFN0b3Aoa2V5KSB7XG4gICAgICAgIC8vIERvbmUgYnVpbGRpbmc/XG4gICAgICAgIGlmICh0aGlzLmJ1aWxkaW5nX3RpbGVzKSB7XG4gICAgICAgICAgICBsb2cudHJhY2UoYHRpbGVCdWlsZFN0b3AgZm9yICR7a2V5fTogJHtPYmplY3Qua2V5cyh0aGlzLmJ1aWxkaW5nX3RpbGVzKS5sZW5ndGh9YCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5idWlsZGluZ190aWxlc1trZXldO1xuICAgICAgICAgICAgdGhpcy5jaGVja0J1aWxkUXVldWUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBDaGVjayBzdGF0dXMgb2YgdGlsZSBidWlsZGluZyBxdWV1ZSBhbmQgbm90aWZ5IHNjZW5lIHdoZW4gd2UncmUgZG9uZVxuICAgIGNoZWNrQnVpbGRRdWV1ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1aWxkaW5nX3RpbGVzIHx8IE9iamVjdC5rZXlzKHRoaXMuYnVpbGRpbmdfdGlsZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZGluZ190aWxlcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNjZW5lLnRpbGVNYW5hZ2VyQnVpbGREb25lKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gU3VtIG9mIGEgZGVidWcgcHJvcGVydHkgYWNyb3NzIHRpbGVzXG4gICAgZ2V0RGVidWdTdW0ocHJvcCwgZmlsdGVyKSB7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICBmb3IgKHZhciB0IGluIHRoaXMudGlsZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbGVzW3RdLmRlYnVnW3Byb3BdICE9IG51bGwgJiYgKHR5cGVvZiBmaWx0ZXIgIT09ICdmdW5jdGlvbicgfHwgZmlsdGVyKHRoaXMudGlsZXNbdF0pID09PSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHN1bSArPSB0aGlzLnRpbGVzW3RdLmRlYnVnW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfSxcblxuICAgIC8vIEF2ZXJhZ2Ugb2YgYSBkZWJ1ZyBwcm9wZXJ0eSBhY3Jvc3MgdGlsZXNcbiAgICBnZXREZWJ1Z0F2ZXJhZ2UocHJvcCwgZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERlYnVnU3VtKHByb3AsIGZpbHRlcikgLyBPYmplY3Qua2V5cyh0aGlzLnRpbGVzKS5sZW5ndGg7XG4gICAgfVxuXG59O1xuIiwiXG5cbmV4cG9ydCBjbGFzcyBNZXRob2ROb3RJbXBsZW1lbnRlZCBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2ROYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSAgICA9ICdNZXRob2ROb3RJbXBsZW1lbnRlZCc7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9ICdNZXRob2QgJyArIG1ldGhvZE5hbWUgKyAnIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3MnO1xuICAgIH1cbn1cbiIsIi8vIERlZXAvcmVjdXJzaXZlIG1lcmdlIG9mIG9uZSBvciBtb3JlIHNvdXJjZSBvYmplY3RzIGludG8gYSBkZXN0aW5hdGlvbiBvYmplY3RcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlT2JqZWN0cyAoZGVzdCwgLi4uc291cmNlcykge1xuICAgIGZvciAobGV0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIHRoZSBzb3VyY2UgaW50byB0aGUgZGVzdGluYXRpb24gaWYgaXQgaXMgYSBhIG5vbi1udWxsIGtleS92YWx1ZSBvYmplY3RcbiAgICAgICAgICAgIC8vIChlLmcuIGRvbid0IG1lcmdlIGFycmF5cywgdGhvc2UgYXJlIHRyZWF0ZWQgYXMgc2NhbGFyIHZhbHVlczsgbnVsbCB2YWx1ZXMgd2lsbCBvdmVyd3JpdGUvZXJhc2VcbiAgICAgICAgICAgIC8vIHRoZSBwcmV2aW91cyBkZXN0aW5hdGlvbiB2YWx1ZSlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRlc3Rba2V5XSA9IG1lcmdlT2JqZWN0cyhkZXN0W2tleV0gfHwge30sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE92ZXJ3cml0ZSB0aGUgcHJldmlvdXMgZGVzdGluYXRpb24gdmFsdWUgaWYgdGhlIHNvdXJjZSBwcm9wZXJ0eSBpczogYSBzY2FsYXIgKG51bWJlci9zdHJpbmcpLFxuICAgICAgICAgICAgLy8gYW4gYXJyYXksIG9yIGEgbnVsbCB2YWx1ZVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlc3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5kZWZpbmVkIHNvdXJjZSBwcm9wZXJ0aWVzIGFyZSBpZ25vcmVkXG4gICAgICAgIH1cblxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn1cbiIsImltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT0JCIHtcblxuICAgIGNvbnN0cnVjdG9yICh4LCB5LCBhLCB3LCBoKSB7XG4gICAgICAgIHRoaXMuZGltZW5zaW9uID0gW3csIGhdO1xuICAgICAgICB0aGlzLmFuZ2xlID0gYTtcbiAgICAgICAgdGhpcy5jZW50cm9pZCA9IFt4LCB5XTtcbiAgICAgICAgdGhpcy5xdWFkID0gW107XG4gICAgICAgIHRoaXMuYXhlcyA9IFtdO1xuXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgbW92ZSAocHgsIHB5KSB7XG4gICAgXHR0aGlzLmNlbnRyb2lkID0gW3B4LCBweV07XG5cbiAgICBcdHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0RXh0ZW50ICgpIHtcbiAgICBcdGxldCBpbmYgPSAxZTY7XG4gICAgXHRsZXQgYWFiYiA9IFtpbmYsIGluZiwgLWluZiwgLWluZl07XG5cbiAgICBcdGZvciAobGV0IGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICBhYWJiWzBdID0gTWF0aC5taW4odGhpcy5xdWFkW2ldWzBdLCBhYWJiWzBdKTtcbiAgICAgICAgICAgIGFhYmJbMV0gPSBNYXRoLm1pbih0aGlzLnF1YWRbaV1bMV0sIGFhYmJbMV0pO1xuICAgICAgICAgICAgYWFiYlsyXSA9IE1hdGgubWF4KHRoaXMucXVhZFtpXVswXSwgYWFiYlsyXSk7XG4gICAgICAgICAgICBhYWJiWzNdID0gTWF0aC5tYXgodGhpcy5xdWFkW2ldWzFdLCBhYWJiWzNdKTtcbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIGFhYmI7XG4gICAgfVxuXG4gICAgcGVycEF4ZXMgKCkge1xuICAgIFx0dGhpcy5heGVzWzBdID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3Iuc3ViKHRoaXMucXVhZFsyXSwgdGhpcy5xdWFkWzNdKSk7XG4gICAgXHR0aGlzLmF4ZXNbMV0gPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5zdWIodGhpcy5xdWFkWzJdLCB0aGlzLnF1YWRbMV0pKTtcbiAgICB9XG5cbiAgICB1cGRhdGUgKCkge1xuICAgIFx0bGV0IHggPSBbIE1hdGguY29zKHRoaXMuYW5nbGUpLCBNYXRoLnNpbih0aGlzLmFuZ2xlKV07XG4gICAgXHRsZXQgeSA9IFstTWF0aC5zaW4odGhpcy5hbmdsZSksIE1hdGguY29zKHRoaXMuYW5nbGUpXTtcblxuICAgIFx0eCA9IFZlY3Rvci5tdWx0KHgsIHRoaXMuZGltZW5zaW9uWzBdIC8gMi4wKTtcbiAgICBcdHkgPSBWZWN0b3IubXVsdCh5LCB0aGlzLmRpbWVuc2lvblsxXSAvIDIuMCk7XG5cbiAgICBcdHRoaXMucXVhZFswXSA9IFZlY3Rvci5zdWIoVmVjdG9yLnN1Yih0aGlzLmNlbnRyb2lkLCB4KSwgeSk7IC8vIGxvd2VyLWxlZnRcbiAgICBcdHRoaXMucXVhZFsxXSA9IFZlY3Rvci5zdWIoVmVjdG9yLmFkZCh0aGlzLmNlbnRyb2lkLCB4KSwgeSk7IC8vIGxvd2VyLXJpZ2h0XG4gICAgXHR0aGlzLnF1YWRbMl0gPSBWZWN0b3IuYWRkKFZlY3Rvci5hZGQodGhpcy5jZW50cm9pZCwgeCksIHkpOyAvLyB1cGVyLXJpZ2h0XG4gICAgXHR0aGlzLnF1YWRbM10gPSBWZWN0b3IuYWRkKFZlY3Rvci5zdWIodGhpcy5jZW50cm9pZCwgeCksIHkpOyAvLyB1cGVyLWxlZnRcblxuICAgIFx0dGhpcy5wZXJwQXhlcygpO1xuICAgIH1cblxuICAgIHN0YXRpYyBwcm9qZWN0VG9BeGlzIChvYmIsIGF4aXMpIHtcbiAgICBcdGxldCBpbmYgPSAxZTY7XG4gICAgXHRsZXQgbWluID0gaW5mO1xuICAgIFx0bGV0IG1heCA9IC1pbmY7XG5cbiAgICBcdGxldCBxdWFkID0gb2JiLnF1YWQ7XG5cbiAgICBcdC8vIGZvciBlYWNoIGF4aXMsIHByb2plY3Qgb2JiIHF1YWQgdG8gaXQgYW5kIGZpbmQgbWluIGFuZCBtYXggdmFsdWVzXG4gICAgXHRmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgbGV0IGQgPSAgVmVjdG9yLmRvdChxdWFkW2ldLCBheGlzKTtcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgZCk7XG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGQpO1xuICAgIFx0fVxuXG4gICAgXHRyZXR1cm4gW21pbiwgbWF4XTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXhpc0NvbGxpZGUgKG9iYl9hLCBvYmJfYiwgYXhlcykge1xuICAgIFx0Zm9yIChsZXQgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICBcdFx0bGV0IGFfcHJvaiA9IE9CQi5wcm9qZWN0VG9BeGlzKG9iYl9hLCBheGVzW2ldKTtcbiAgICBcdFx0bGV0IGJfcHJvaiA9IE9CQi5wcm9qZWN0VG9BeGlzKG9iYl9iLCBheGVzW2ldKTtcblxuICAgIFx0XHRpZiAoYl9wcm9qWzBdID4gYV9wcm9qWzFdIHx8IGJfcHJvalsxXSA8IGFfcHJvalswXSkge1xuICAgIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgICBcdFx0fVxuICAgIFx0fVxuICAgIFx0cmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc3RhdGljIGludGVyc2VjdChvYmJfYSwgb2JiX2IpIHtcbiAgICBcdHJldHVybiBPQkIuYXhpc0NvbGxpZGUob2JiX2EsIG9iYl9iLCBvYmJfYS5heGVzKSAmJiBPQkIuYXhpc0NvbGxpZGUob2JiX2EsIG9iYl9iLCBvYmJfYi5heGVzKTtcbiAgICB9XG5cbn1cblxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3Vic2NyaWJlTWl4aW4gKHRhcmdldCkge1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICAvLyB2YXIgbGlzdGVuZXJzID0gW107XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0YXJnZXQsIHtcblxuICAgICAgICBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgICAgICAgICAgLy8gbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVuc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIC8vIHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIC8vIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAvLyAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5zdWJzY3JpYmVBbGwoKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgICAgICAgIC8vIGxpc3RlbmVycyA9IFtdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyaWdnZXIoZXZlbnQsIC4uLmRhdGEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJbZXZlbnRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyW2V2ZW50XSguLi5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG59XG4iLCIvLyBNaXNjZWxsYW5lb3VzIHV0aWxpdGllc1xuLypqc2hpbnQgd29ya2VyOiB0cnVlKi9cblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgeWFtbCBmcm9tICdqcy15YW1sJztcbmltcG9ydCBHZW8gZnJvbSAnLi4vZ2VvJztcblxudmFyIFV0aWxzO1xuZXhwb3J0IGRlZmF1bHQgVXRpbHMgPSB7fTtcblxuLy8gQWRkIGEgYmFzZSBVUkwgZm9yIHNjaGVtZWxlc3Mgb3IgcHJvdG9jb2wtbGVzcyBVUkxzXG4vLyBEZWZhdWx0cyB0byBhZGRpbmcgY3VycmVudCB3aW5kb3cgcHJvdG9jb2wgYW5kIGJhc2UsIG9yIGFkZHMgYSBjdXN0b20gYmFzZSBpZiBzcGVjaWZpZWRcbi8vIE1heWJlIHVzZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL1VSSS5qcyBpZiBtb3JlIHJvYnVzdCBmdW5jdGlvbmFsaXR5IGlzIG5lZWRlZFxuVXRpbHMuYWRkQmFzZVVSTCA9IGZ1bmN0aW9uICh1cmwsIGJhc2UpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2NoZW1lbGVzcywgYWRkIHByb3RvY29sXG4gICAgaWYgKHVybC5zdWJzdHIoMCwgMikgPT09ICcvLycpIHtcbiAgICAgICAgdXJsID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgdXJsO1xuICAgIH1cbiAgICAvLyBObyBodHRwKHMpIG9yIGRhdGEsIGFkZCBiYXNlXG4gICAgZWxzZSBpZiAodXJsLnNlYXJjaCgvXihodHRwfGh0dHBzfGRhdGF8YmxvYik6LykgPCAwKSB7XG4gICAgICAgIHZhciByZWxhdGl2ZSA9ICh1cmxbMF0gIT09ICcvJyk7XG4gICAgICAgIHZhciBiYXNlX2luZm87XG4gICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgICBiYXNlX2luZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7IC8vIHVzZSBhIHRlbXBvcmFyeSBlbGVtZW50IHRvIHBhcnNlIFVSTFxuICAgICAgICAgICAgYmFzZV9pbmZvLmhyZWYgPSBiYXNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmFzZV9pbmZvID0gd2luZG93LmxvY2F0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgICBsZXQgcGF0aCA9IGJhc2VfaW5mby5ocmVmLm1hdGNoKC8oW15cXCNdKykvKTsgLy8gc3RyaXAgaGFzaFxuICAgICAgICAgICAgcGF0aCA9IChwYXRoICYmIHBhdGgubGVuZ3RoID4gMSkgPyBwYXRoWzBdIDogJyc7XG4gICAgICAgICAgICB1cmwgPSBwYXRoICsgdXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRWFzeSB3YXlcbiAgICAgICAgICAgIGlmIChiYXNlX2luZm8ub3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gYmFzZV9pbmZvLm9yaWdpbiArICcvJyArIHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhcmQgd2F5IChJRTExKVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IHVybC5tYXRjaCgvXigoaHR0cHxodHRwc3xkYXRhfGJsb2IpOlxcL1xcL1teXFwvXSpcXC8pLyk7XG4gICAgICAgICAgICAgICAgb3JpZ2luID0gKG9yaWdpbiAmJiBvcmlnaW4ubGVuZ3RoID4gMSkgPyBvcmlnaW5bMF0gOiAnJztcbiAgICAgICAgICAgICAgICB1cmwgPSBvcmlnaW4gKyB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn07XG5cblV0aWxzLnBhdGhGb3JVUkwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgaWYgKHVybCAmJiB1cmwuc2VhcmNoKC9eKGRhdGF8YmxvYik6LykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB1cmwuc3Vic3RyKDAsIHVybC5sYXN0SW5kZXhPZignLycpICsgMSkgfHwgJy4vJztcbiAgICB9XG4gICAgcmV0dXJuICcuLyc7XG59O1xuXG5VdGlscy5jYWNoZUJ1c3RlckZvclVybCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBpZiAodXJsLnNlYXJjaCgvXihkYXRhfGJsb2IpOi8pID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHVybDsgLy8gbm8gY2FjaGUtYnVzdGluZyBvbiBvYmplY3Qgb3IgZGF0YSBVUkxzXG4gICAgfVxuICAgIGlmICh1cmwuaW5kZXhPZignPycpID4gLTEpIHtcbiAgICAgICAgdXJsICs9ICcmJyArICgrbmV3IERhdGUoKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1cmwgKz0gJz8nICsgKCtuZXcgRGF0ZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn07XG5cbi8vIFBvbHlmaWxsIChmb3IgU2FmYXJpIGNvbXBhdGliaWxpdHkpXG5VdGlscy5fY3JlYXRlT2JqZWN0VVJMID0gdW5kZWZpbmVkO1xuVXRpbHMuY3JlYXRlT2JqZWN0VVJMID0gZnVuY3Rpb24gKHVybCkge1xuICAgIGlmIChVdGlscy5fY3JlYXRlT2JqZWN0VVJMID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgVXRpbHMuX2NyZWF0ZU9iamVjdFVSTCA9ICh3aW5kb3cuVVJMICYmIHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKSB8fCAod2luZG93LndlYmtpdFVSTCAmJiB3aW5kb3cud2Via2l0VVJMLmNyZWF0ZU9iamVjdFVSTCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBVdGlscy5fY3JlYXRlT2JqZWN0VVJMICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBVdGlscy5fY3JlYXRlT2JqZWN0VVJMID0gbnVsbDtcbiAgICAgICAgICAgIGxvZy53YXJuKGB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTCAob3IgdmVuZG9yIHByZWZpeCkgbm90IGZvdW5kLCB1bmFibGUgdG8gY3JlYXRlIGxvY2FsIGJsb2IgVVJMc2ApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFV0aWxzLl9jcmVhdGVPYmplY3RVUkwpIHtcbiAgICAgICAgcmV0dXJuIFV0aWxzLl9jcmVhdGVPYmplY3RVUkwodXJsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxufTtcblxuVXRpbHMuaW8gPSBmdW5jdGlvbiAodXJsLCB0aW1lb3V0ID0gNjAwMDAsIHJlc3BvbnNlVHlwZSA9ICd0ZXh0JywgbWV0aG9kID0gJ0dFVCcsIGhlYWRlcnMgPSB7fSkge1xuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHJlcXVlc3Qub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJlcXVlc3QudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xuICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKFsndGV4dCcsICdqc29uJ10uaW5kZXhPZihyZXF1ZXN0LnJlc3BvbnNlVHlwZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoRXJyb3IoJ1JlcXVlc3QgZXJyb3Igd2l0aCBhIHN0YXR1cyBvZiAnICsgcmVxdWVzdC5zdGF0dXNUZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldnQpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChFcnJvcignVGhlcmUgd2FzIGEgbmV0d29yayBlcnJvcicgKyBldnQudG9TdHJpbmcoKSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9udGltZW91dCA9IChldnQpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChFcnJvcigndGltZW91dCAnKyBldnQudG9TdHJpbmcoKSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCAncmVxdWVzdCcsIHtcbiAgICAgICAgdmFsdWU6IHJlcXVlc3RcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xufTtcblxuVXRpbHMucGFyc2VSZXNvdXJjZSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgdmFyIGRhdGE7XG4gICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IHlhbWwuc2FmZUxvYWQoYm9keSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn07XG5cblV0aWxzLmxvYWRSZXNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIFV0aWxzLmlvKFV0aWxzLmNhY2hlQnVzdGVyRm9yVXJsKHNvdXJjZSkpLnRoZW4oKGJvZHkpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IFV0aWxzLnBhcnNlUmVzb3VyY2UoYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8vIE5lZWRlZCBmb3Igb2xkZXIgYnJvd3NlcnMgdGhhdCBzdGlsbCBzdXBwb3J0IFdlYkdMIChTYWZhcmkgNiBldGMuKVxuVXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lUG9seWZpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPVxuICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICB8fFxuICAgICAgICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICB8fFxuICAgICAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgMTAwMCAvNjApO1xuICAgICAgICAgICAgfTtcbiAgICB9XG59O1xuXG4vLyBTdHJpbmdpZnkgYW4gb2JqZWN0IGludG8gSlNPTiwgYnV0IGNvbnZlcnQgZnVuY3Rpb25zIHRvIHN0cmluZ3NcblV0aWxzLnNlcmlhbGl6ZVdpdGhGdW5jdGlvbnMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeShvYmosIGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgICAgLy8gQ29udmVydCBmdW5jdGlvbnMgdG8gc3RyaW5nc1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn07XG5cbi8vIFBhcnNlIGEgSlNPTiBzdHJpbmcsIGJ1dCBjb252ZXJ0IGZ1bmN0aW9uLWxpa2Ugc3RyaW5ncyBiYWNrIGludG8gZnVuY3Rpb25zXG5VdGlscy5kZXNlcmlhbGl6ZVdpdGhGdW5jdGlvbnMgPSBmdW5jdGlvbihzZXJpYWxpemVkLCB3cmFwKSB7XG4gICAgdmFyIG9iaiA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgb2JqID0gVXRpbHMuc3RyaW5nc1RvRnVuY3Rpb25zKG9iaiwgd3JhcCk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbi8vIFJlY3Vyc2l2ZWx5IHBhcnNlIGFuIG9iamVjdCwgYXR0ZW1wdGluZyB0byBjb252ZXJ0IHN0cmluZyBwcm9wZXJ0aWVzIHRoYXQgbG9vayBsaWtlIGZ1bmN0aW9ucyBiYWNrIGludG8gZnVuY3Rpb25zXG5VdGlscy5zdHJpbmdzVG9GdW5jdGlvbnMgPSBmdW5jdGlvbihvYmosIHdyYXApIHtcbiAgICAvLyBDb252ZXJ0IHN0cmluZ1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICBvYmogPSBVdGlscy5zdHJpbmdUb0Z1bmN0aW9uKG9iaiwgd3JhcCk7XG4gICAgfVxuICAgIC8vIExvb3AgdGhyb3VnaCBvYmplY3QgcHJvcGVydGllc1xuICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAobGV0IHAgaW4gb2JqKSB7XG4gICAgICAgICAgICBvYmpbcF0gPSBVdGlscy5zdHJpbmdzVG9GdW5jdGlvbnMob2JqW3BdLCB3cmFwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufTtcblxuLy8gQ29udmVydCBzdHJpbmcgYmFjayBpbnRvIGEgZnVuY3Rpb25cbi8vIFRPRE86IG1ha2UgZnVuY3Rpb24gbWF0Y2hpbmcgdG9sZXJhbnQgb2Ygd2hpdGVzcGFjZSBhbmQgbXVsdGlsaW5lc1xuVXRpbHMuc3RyaW5nVG9GdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbCwgd3JhcCkge1xuICAgIC8vIENvbnZlcnQgc3RyaW5ncyBiYWNrIGludG8gZnVuY3Rpb25zXG4gICAgaWYgKHZhbC5tYXRjaCgvXlxccypmdW5jdGlvblxccypcXHcqXFxzKlxcKFtcXHNcXFNdKlxcKVxccypcXHtbXFxzXFxTXSpcXH0vbSkgIT0gbnVsbCkge1xuICAgICAgICB2YXIgZjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd3JhcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGV2YWwoJ2YgPSAnICsgd3JhcCh2YWwpKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmFsKCdmID0gJyArIHZhbCk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGZhbGwtYmFjayB0byBvcmlnaW5hbCB2YWx1ZSBpZiBwYXJzaW5nIGZhaWxlZFxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufTtcblxuLy8gTG9nIHdyYXBwZXIsIHNlbmRzIG1lc3NhZ2UgdG8gbWFpbiB0aHJlYWQgZm9yIGRpc3BsYXksIGFuZCBpbmNsdWRlcyB3b3JrZXIgaWQgI1xuVXRpbHMubG9nID0gZnVuY3Rpb24gKGxldmVsLCAuLi5tc2cpIHtcbiAgICBsZXZlbCA9IGxldmVsIHx8ICdpbmZvJztcbiAgICBpZiAoVXRpbHMuaXNXb3JrZXJUaHJlYWQpIHtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnbG9nJyxcbiAgICAgICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgICAgIHdvcmtlcl9pZDogc2VsZi5fd29ya2VyX2lkLFxuICAgICAgICAgICAgbXNnOiBtc2dcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsb2dbbGV2ZWxdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxvZ1tsZXZlbF0oLi4ubXNnKTtcbiAgICB9XG59O1xuXG4vLyBEZWZhdWx0IHRvIGFsbG93aW5nIGhpZ2ggcGl4ZWwgZGVuc2l0eVxuLy8gUmV0dXJucyB0cnVlIGlmIGRpc3BsYXkgZGVuc2l0eSBjaGFuZ2VkXG5VdGlscy51c2VfaGlnaF9kZW5zaXR5X2Rpc3BsYXkgPSB0cnVlO1xuVXRpbHMudXBkYXRlRGV2aWNlUGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcHJldiA9IFV0aWxzLmRldmljZV9waXhlbF9yYXRpbztcbiAgICBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8gPSAoVXRpbHMudXNlX2hpZ2hfZGVuc2l0eV9kaXNwbGF5ICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB8fCAxO1xuICAgIHJldHVybiBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8gIT09IHByZXY7XG59O1xuXG4vLyBNYXJrIHRocmVhZCBhcyBtYWluIG9yIHdvcmtlclxuKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh3aW5kb3cuZG9jdW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgVXRpbHMuaXNXb3JrZXJUaHJlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIFV0aWxzLmlzTWFpblRocmVhZCAgID0gdHJ1ZTtcbiAgICAgICAgICAgIFV0aWxzLnVwZGF0ZURldmljZVBpeGVsUmF0aW8oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoc2VsZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBVdGlscy5pc1dvcmtlclRocmVhZCA9IHRydWU7XG4gICAgICAgICAgICBVdGlscy5pc01haW5UaHJlYWQgICA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufSkoKTtcblxuLy8gR2V0IFVSTCB0aGF0IHRoZSBjdXJyZW50IHNjcmlwdCB3YXMgbG9hZGVkIGZyb21cbi8vIElmIGN1cnJlbnRTY3JpcHQgaXMgbm90IGF2YWlsYWJsZSwgbG9vcHMgdGhyb3VnaCA8c2NyaXB0PiBlbGVtZW50cyBzZWFyY2hpbmcgZm9yIGEgbGlzdCBvZiBwcm92aWRlZCBwYXRoc1xuLy8gZS5nLiBVdGlscy5maW5kQ3VycmVudFVSTCgndGFuZ3JhbS5kZWJ1Zy5qcycsICd0YW5ncmFtLm1pbi5qcycpO1xuVXRpbHMuZmluZEN1cnJlbnRVUkwgPSBmdW5jdGlvbiAoLi4ucGF0aHMpIHtcbiAgICAvLyBGaW5kIGN1cnJlbnRseSBleGVjdXRpbmcgc2NyaXB0XG4gICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQ7XG4gICAgaWYgKHNjcmlwdCkge1xuICAgICAgICByZXR1cm4gc2NyaXB0LnNyYztcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXRocykpIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgb24gbG9vcGluZyB0aHJvdWdoIDxzY3JpcHQ+IGVsZW1lbnRzIGlmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgICAgICAgZm9yICh2YXIgcz0wOyBzIDwgc2NyaXB0cy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgcGF0aCBvZiBwYXRocykge1xuICAgICAgICAgICAgICAgIGlmIChzY3JpcHRzW3NdLnNyYy5pbmRleE9mKHBhdGgpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0c1tzXS5zcmM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gVXNlZCBmb3IgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gcG93ZXItb2YtMiBhbmQgbm9uLXBvd2VyLW9mLTIgdGV4dHVyZXNcbi8vIFZpYTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xOTcyMjI0Ny93ZWJnbC13YWl0LWZvci10ZXh0dXJlLXRvLWxvYWRcblV0aWxzLmlzUG93ZXJPZjIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiAodmFsdWUgLSAxKSkgPT09IDA7XG59O1xuXG5VdGlscy5uZXh0UG93ZXJPZjIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2cyKHZhbHVlKSkpO1xufTtcblxuLy8gSW50ZXJwb2xhdGUgJ3gnIGFsb25nIGEgc2VyaWVzIG9mIGNvbnRyb2wgcG9pbnRzXG4vLyAncG9pbnRzJyBpcyBhbiBhcnJheSBvZiBjb250cm9sIHBvaW50cyBpbiB0aGUgZm9ybSBbeCwgeV1cbi8vXG4vLyBFeGFtcGxlOlxuLy8gICAgIENvbnRyb2wgcG9pbnRzOlxuLy8gICAgICAgICBbMCwgNV06ICB3aGVuIHg9MCwgeT01XG4vLyAgICAgICAgIFs0LCAxMF06IHdoZW4geD00LCB5PTEwXG4vL1xuLy8gICAgIFV0aWxzLmludGVycG9sYXRlKDIsIFtbMCwgNV0sIFs0LCAxMF1dKTtcbi8vICAgICAtPiBjb21wdXRlcyB4PTIsIGhhbGZ3YXkgYmV0d2VlbiB4PTAgYW5kIHg9NDogKDEwIC0gNSkgLyAyICs1XG4vLyAgICAgLT4gcmV0dXJucyA3LjVcbi8vXG4vLyBUT0RPOiBhZGQgb3RoZXIgaW50ZXJwb2xhdGlvbiBtZXRob2RzIGJlc2lkZXMgbGluZWFyXG4vL1xuVXRpbHMuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbih4LCBwb2ludHMpIHtcbiAgICAvLyBJZiB0aGlzIGRvZXNuJ3QgcmVzZW1ibGUgYSBsaXN0IG9mIGNvbnRyb2wgcG9pbnRzLCBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSB8fCAhQXJyYXkuaXNBcnJheShwb2ludHNbMF0pKSB7XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBvaW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuXG4gICAgdmFyIHgxLCB4MiwgZCwgeTtcblxuICAgIC8vIE1pbiBib3VuZHNcbiAgICBpZiAoeCA8PSBwb2ludHNbMF1bMF0pIHtcbiAgICAgICAgeSA9IHBvaW50c1swXVsxXTtcbiAgICB9XG4gICAgLy8gTWF4IGJvdW5kc1xuICAgIGVsc2UgaWYgKHggPj0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMV1bMF0pIHtcbiAgICAgICAgeSA9IHBvaW50c1twb2ludHMubGVuZ3RoLTFdWzFdO1xuICAgIH1cbiAgICAvLyBGaW5kIHdoaWNoIGNvbnRyb2wgcG9pbnRzIHggaXMgYmV0d2VlblxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoeCA+PSBwb2ludHNbaV1bMF0gJiYgeCA8IHBvaW50c1tpKzFdWzBdKSB7XG4gICAgICAgICAgICAgICAgLy8gTGluZWFyIGludGVycG9sYXRpb25cbiAgICAgICAgICAgICAgICB4MSA9IHBvaW50c1tpXVswXTtcbiAgICAgICAgICAgICAgICB4MiA9IHBvaW50c1tpKzFdWzBdO1xuXG4gICAgICAgICAgICAgICAgLy8gTXVsdGlwbGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9pbnRzW2ldWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGM9MDsgYyA8IHBvaW50c1tpXVsxXS5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHBvaW50c1tpKzFdWzFdW2NdIC0gcG9pbnRzW2ldWzFdW2NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeVtjXSA9IGQgKiAoeCAtIHgxKSAvICh4MiAtIHgxKSArIHBvaW50c1tpXVsxXVtjXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTaW5nbGUgdmFsdWVcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IHBvaW50c1tpKzFdWzFdIC0gcG9pbnRzW2ldWzFdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gZCAqICh4IC0geDEpIC8gKHgyIC0geDEpICsgcG9pbnRzW2ldWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geTtcbn07XG5cbi8vIEl0ZXJhdG9ycyAoRVM2IGdlbmVyYXRvcnMpXG5cbi8vIEl0ZXJhdG9yIGZvciBrZXkvdmFsdWUgcGFpcnMgb2YgYW4gb2JqZWN0XG5VdGlscy5lbnRyaWVzID0gZnVuY3Rpb24qIChvYmopIHtcbiAgICBmb3IgKHZhciBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICB5aWVsZCBba2V5LCBvYmpba2V5XV07XG4gICAgfVxufTtcblxuLy8gSXRlcmF0b3IgZm9yIHZhbHVlcyBvZiBhbiBvYmplY3RcblV0aWxzLnZhbHVlcyA9IGZ1bmN0aW9uKiAob2JqKSB7XG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgeWllbGQgb2JqW2tleV07XG4gICAgfVxufTtcblxuLy8gUmVjdXJzaXZlIGl0ZXJhdG9ycyBmb3IgYWxsIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LCBubyBtYXR0ZXIgaG93IGRlZXBseSBuZXN0ZWRcbi8vIFRPRE86IGZpeCBmb3IgY2lyY3VsYXIgc3RydWN0dXJlc1xuVXRpbHMucmVjdXJzZUVudHJpZXMgPSBmdW5jdGlvbiogKG9iaikge1xuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgaWYgKG9ialtrZXldKSB7XG4gICAgICAgICAgICB5aWVsZCBba2V5LCBvYmpba2V5XSwgb2JqXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIFV0aWxzLnJlY3Vyc2VFbnRyaWVzKG9ialtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblV0aWxzLnJlY3Vyc2VWYWx1ZXMgPSBmdW5jdGlvbiogKG9iaikge1xuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgaWYgKG9ialtrZXldKSB7XG4gICAgICAgICAgICB5aWVsZCBvYmpba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIFV0aWxzLnJlY3Vyc2VWYWx1ZXMob2JqW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gU2NhbGUgYSAqc2lnbmVkKiBzaG9ydCBmb3IgdXNlIGluIGEgR0wgVkJPXG4vLyBgdW5pdGAgaXMgYW4gb3B0aW9uYWwgc2NhbGluZyBmYWN0b3IgdG8gbWltaWMgZml4ZWQgcG9pbnQsIHNpbmNlIHRoZXNlIHZhbHVlcyB3aWxsIGJlXG4vLyBub3JtYWxpemVkIHRvIDAtMSwgZS5nLiBkaXZpZGUgaW5wdXQgYnkgdW5pdCBvbiB0aGUgd2F5IGluLCBtdWx0aXBseSBpdCBiYWNrIGluIHRoZSBzaGFkZXJcblV0aWxzLnNjYWxlSW50MTYgPSBmdW5jdGlvbiAodmFsLCB1bml0KSB7XG4gICAgcmV0dXJuICh2YWwgLyB1bml0KSAqIDMyNzY3O1xufTtcblxuVXRpbHMuZGVnVG9SYWQgPSBmdW5jdGlvbiAoZGVncmVlcykge1xuICAgIHJldHVybiBkZWdyZWVzICogTWF0aC5QSSAvIDE4MDtcbn07XG5cblV0aWxzLnJhZFRvRGVnID0gZnVuY3Rpb24gKHJhZGlhbnMpIHtcbiAgICByZXR1cm4gcmFkaWFucyAqIDE4MCAvIE1hdGguUEk7XG59O1xuXG5VdGlscy50b0NTU0NvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKGNvbG9yWzNdID09PSAxKSB7IC8vIGZ1bGwgb3BhY2l0eVxuICAgICAgICByZXR1cm4gYHJnYigke2NvbG9yLnNsaWNlKDAsIDMpLm1hcChjID0+IE1hdGgucm91bmQoYyAqIDI1NSkpLmpvaW4oJywgJyl9KWA7XG4gICAgfVxuICAgIC8vIFJHQiBpcyBiZXR3ZWVuIFswLCAyNTVdIG9wYWNpdHkgaXMgYmV0d2VlbiBbMCwgMV1cbiAgICByZXR1cm4gYHJnYmEoJHtjb2xvci5tYXAoKGMsIGkpID0+IChpIDwgMyAmJiBNYXRoLnJvdW5kKGMgKiAyNTUpKSB8fCBjKS5qb2luKCcsICcpfSlgO1xufTtcblxuVXRpbHMucG9pbnRJblRpbGUgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICByZXR1cm4gcG9pbnRbMF0gPj0gMCAmJsKgcG9pbnRbMV0gPiAtR2VvLnRpbGVfc2NhbGUgJiYgcG9pbnRbMF0gPCBHZW8udGlsZV9zY2FsZSAmJiBwb2ludFsxXSA8PSAwO1xufTtcblxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NjE2NDYxL2dlbmVyYXRlLWEtaGFzaC1mcm9tLXN0cmluZy1pbi1qYXZhc2NyaXB0LWpxdWVyeVxuVXRpbHMuaGFzaFN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBsZXQgaGFzaCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCBjaHIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgY2hyO1xuICAgICAgICBoYXNoIHw9IDA7XG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xufTtcblxuVXRpbHMuZGVib3VuY2UgPSBmdW5jdGlvbiAoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBsZXQgY29udGV4dCA9IHRoaXMsXG4gICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBsZXQgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4iLCJ2YXIgdmVyc2lvbjtcbmV4cG9ydCBkZWZhdWx0IHZlcnNpb24gPSB7XG4gICAgZ2V0IHN0cmluZygpIHsgcmV0dXJuIGB2JHt2ZXJzaW9uLm1ham9yfS4ke3ZlcnNpb24ubWlub3J9LiR7dmVyc2lvbi5wYXRjaH1gOyB9LFxuICAgIG1ham9yOiAwLFxuICAgIG1pbm9yOiA0LFxuICAgIHBhdGNoOiA0LFxuICAgIHByZTogZmFsc2Vcbn07XG4iLCIvKmpzaGludCB3b3JrZXI6IHRydWUqL1xuXG4vLyBXb3JrZXJCcm9rZXIgcm91dGVzIG1lc3NhZ2VzIGJldHdlZW4gd2ViIHdvcmtlcnMgYW5kIHRoZSBtYWluIHRocmVhZCwgYWxsb3dpbmcgZm9yIHNpbXBsZXJcbi8vIGFzeW5jIGNvZGUgdmlhIHByb21pc2VzLiBFeGFtcGxlIHVzYWdlOlxuLy9cbi8vIEluIHdlYiB3b3JrZXIsIHJlZ2lzdGVyIHNlbGYgYXMgdGFyZ2V0IGRlZmluZSBhIG1ldGhvZDpcbi8vXG4vLyAgICAgV29ya2VyQnJva2VyLmFkZFRhcmdldCgnc2VsZicsIHNlbGYpO1xuLy9cbi8vICAgICBzZWxmLnNxdWFyZSA9IGZ1bmN0aW9uICh4KSB7XG4vLyAgICAgICAgIHJldHVybiB4ICogeDtcbi8vICAgICB9O1xuLy9cbi8vIEluIG1haW4gdGhyZWFkLCBpbnZva2UgdGhhdCBtZXRob2QgYW5kIHJlY2VpdmUgdGhlIHJlc3VsdCAoaWYgYW55KSBhcyBhIHByb21pc2U6XG4vL1xuLy8gICAgIHdvcmtlciA9IG5ldyBXb3JrZXIoLi4uKTtcbi8vICAgICBXb3JrZXJCcm9rZXIuYWRkV29ya2VyKHdvcmtlcik7XG4vL1xuLy8gICAgIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSh3b3JrZXIsICdzZWxmLnNxdWFyZScsIDUpLnRoZW4oZnVuY3Rpb24oeSkge1xuLy8gICAgICAgICBjb25zb2xlLmxvZyh5KTtcbi8vICAgICB9KTtcbi8vXG4vLyAgICAgLT4gcHJpbnRzIDI1XG4vL1xuLy8gQXN5bmMgY29kZTpcbi8vXG4vLyBGb3Igc3luY2hyb25vdXMgY29kZSB0aGF0IG11c3QgcGFzcyBhIHJldHVybiB2YWx1ZSB0byB0aGUgbWFpbiB0aHJlYWQsIHRoZSBmdW5jdGlvbiBjYW4gc2ltcGx5XG4vLyByZXR1cm4gYW4gaW1tZWRpYXRlIHZhbHVlIChzZWUgZXhhbXBsZSBhYm92ZSkuIEZvciBjYXNlcyB3aGVyZSB0aGUgd29ya2VyIG1ldGhvZCBuZWVkcyB0byBydW5cbi8vIGFzeW5jaHJvbm91cyBjb2RlLCB0aGUgZnVuY3Rpb24gY2FuIHJldHVybiBhIHByb21pc2UsIGFuZCB0aGUgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgdmFsdWUgd2lsbFxuLy8gYmUgc2VudCBiYWNrIHRvIHRoZSBtYWluIHRocmVhZCB3aGVuIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbi8vXG4vLyBFcnJvciBoYW5kbGluZzpcbi8vXG4vLyBJZiB0aGUgd29ya2VyIG1ldGhvZCBlaXRoZXIgdGhyb3dzIGFuIGVycm9yLCBvciByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGlzIHJlamVjdGVkLCBpdCB3aWxsIGJlXG4vLyBzZW50IGJhY2sgdG8gdGhlIG1haW4gdGhyZWFkIGFzIGEgcHJvbWlzZSByZWplY3Rpb24uIFRoZXNlIHR3byBleGFtcGxlcyBhcmUgZXF1aXZhbGVudDpcbi8vXG4vLyAgICAgSW4gd29ya2VyLCB0aHJvd2luZyBhbiBlcnJvcjpcbi8vXG4vLyAgICAgICAgIHNlbGYuYnJva2VuID0gZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcnJvciBpbiB3b3JrZXIhJyk7XG4vLyAgICAgICAgIH07XG4vL1xuLy8gICAgIEluIHdvcmtlciwgcmV0dXJuaW5nIGEgcmVqZWN0ZWQgcHJvbWlzZTpcbi8vXG4vLyAgICAgICAgIHNlbGYuYnJva2VuID0gZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignZXJyb3IgaW4gd29ya2VyIScpKTtcbi8vICAgICAgICAgfTtcbi8vXG4vLyAgICAgSW4gbWFpbiB0aHJlYWQsIGJvdGggZXJyb3JzIGFyZSByZWNlaXZlZCBhcyBhIHByb21pc2UgcmVqZWN0aW9uOlxuLy9cbi8vICAgICAgICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHdvcmtlciwgJ3NlbGYuYnJva2VuJykudGhlbihcbi8vICAgICAgICAgICAgIC8vIFByb21pc2UgcmVzb2x2ZWRcbi8vICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzdWNjZXNzIScpO1xuLy8gICAgICAgICAgICAgfSxcbi8vICAgICAgICAgICAgIC8vIFByb21pc2UgcmVqZWN0ZWRcbi8vICAgICAgICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4vLyAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yIScsIGVycm9yKTtcbi8vICAgICAgICAgICAgIH0pO1xuLy9cbi8vICAgICAgICAgLT4gcHJpbnRzICdlcnJvciEgZXJyb3IgaW4gd29ya2VyJ1xuLy9cbi8vIENhbGxpbmcgZnJvbSB3b3JrZXIgdG8gbWFpbiB0aHJlYWQ6XG4vL1xuLy8gVGhlIHNhbWUgc3R5bGUgb2YgY2FsbHMgY2FuIGJlIG1hZGUgKmZyb20qIGEgd2ViIHdvcmtlciwgdG8gdGhlIG1haW4gdGhyZWFkLiBUaGUgQVBJIGlzIHRoZSBzYW1lXG4vLyB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCB0aGUgZmlyc3QgYXJndW1lbnQsICd3b3JrZXInLCBpcyBub3QgbmVlZGVkIGZvciBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UoKSxcbi8vIHNpbmNlIHRoZSBtYWluIHRocmVhZCBpcyB0aGUgaW1wbGljaXQgdGFyZ2V0LlxuLy9cbi8vIEluIG1haW4gdGhyZWFkLCBkZWZpbmUgYSBtZXRob2QgYW5kIHJlZ2lzdGVyIGl0OlxuLy9cbi8vICAgICB2YXIgZ2VvbWV0cnkgPSB7XG4vLyAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24oeCwgeSkge1xuLy8gICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbi8vICAgICAgICAgfVxuLy8gICAgIH07XG4vL1xuLy8gICAgIFdvcmtlckJyb2tlci5hZGRUYXJnZXQoJ2dlb21ldHJ5JywgZ2VvbWV0cnkpO1xuLy9cbi8vIEluIHdvcmtlciB0aHJlYWQ6XG4vL1xuLy8gICAgIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSgnZ2VvbWV0cnkubGVuZ3RoJywgMywgNCkudGhlbihmdW5jdGlvbihkKSB7XG4vLyAgICAgICAgIGNvbnNvbGUubG9nKGQpO1xuLy8gICAgIH0pO1xuLy9cbi8vICAgICAtPiBwcmludHMgNVxuLy9cblxuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMnO1xuXG52YXIgV29ya2VyQnJva2VyO1xuZXhwb3J0IGRlZmF1bHQgV29ya2VyQnJva2VyID0ge307XG5cbi8vIEdsb2JhbCBsaXN0IG9mIGFsbCB3b3JrZXIgbWVzc2FnZXNcbi8vIFVuaXF1ZWx5IHRyYWNrcyBldmVyeSBjYWxsIG1hZGUgYmV0d2VlbiBtYWluIHRocmVhZCBhbmQgYSB3b3JrZXJcbnZhciBtZXNzYWdlX2lkID0gMDtcbnZhciBtZXNzYWdlcyA9IHt9O1xuXG4vLyBSZWdpc3RlciBhbiBvYmplY3QgdG8gcmVjZWl2ZSBjYWxscyBmcm9tIG90aGVyIHRocmVhZFxudmFyIHRhcmdldHMgPSB7fTtcbldvcmtlckJyb2tlci5hZGRUYXJnZXQgPSBmdW5jdGlvbiAobmFtZSwgdGFyZ2V0KSB7XG4gICAgdGFyZ2V0c1tuYW1lXSA9IHRhcmdldDtcbn07XG5cbi8vIEdpdmVuIGEgZG90LW5vdGF0aW9uLXN0eWxlIG1ldGhvZCBuYW1lLCBlLmcuICdPYmplY3Qub2JqZWN0Lm1ldGhvZCcsXG4vLyBmaW5kIHRoZSBvYmplY3QgdG8gY2FsbCB0aGUgbWV0aG9kIG9uIGZyb20gdGhlIGxpc3Qgb2YgcmVnaXN0ZXJlZCB0YXJnZXRzXG5mdW5jdGlvbiBmaW5kVGFyZ2V0IChtZXRob2QpIHtcbiAgICB2YXIgY2hhaW4gPSBbXTtcbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY2hhaW4gPSBtZXRob2Quc3BsaXQoJy4nKTtcbiAgICAgICAgbWV0aG9kID0gY2hhaW4ucG9wKCk7XG4gICAgfVxuXG4gICAgLy8gdGFyZ2V0ID0gdGFyZ2V0IHx8IChVdGlscy5pc01haW5UaHJlYWQgJiYgd2luZG93KSB8fCAoVXRpbHMuaXNXb3JrZXJUaHJlYWQgJiYgc2VsZik7XG4gICAgdmFyIHRhcmdldCA9IHRhcmdldHM7XG5cbiAgICBmb3IgKGxldCBtPTA7IG0gPCBjaGFpbi5sZW5ndGg7IG0rKykge1xuICAgICAgICBpZiAodGFyZ2V0W2NoYWluW21dXSkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W2NoYWluW21dXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbbWV0aG9kLCB0YXJnZXRdO1xufVxuXG4vLyBNYWluIHRocmVhZDpcbi8vIC0gU2VuZCBtZXNzYWdlcyB0byB3b3JrZXJzLCBhbmQgb3B0aW9uYWxseSByZWNlaXZlIGFuIGFzeW5jIHJlc3BvbnNlIGFzIGEgcHJvbWlzZVxuLy8gLSBSZWNlaXZlIG1lc3NhZ2VzIGZyb20gd29ya2VycywgYW5kIG9wdGlvbmFsbHkgc2VuZCBhbiBhc3luYyByZXNwb25zZSBiYWNrIGFzIGEgcHJvbWlzZVxuZnVuY3Rpb24gc2V0dXBNYWluVGhyZWFkICgpIHtcblxuICAgIC8vIFNlbmQgYSBtZXNzYWdlIHRvIGEgd29ya2VyLCBhbmQgb3B0aW9uYWxseSBnZXQgYW4gYXN5bmMgcmVzcG9uc2VcbiAgICAvLyBBcmd1bWVudHM6XG4gICAgLy8gICAtIHdvcmtlcjogb25lIG9yIG1vcmUgd2ViIHdvcmtlciBpbnN0YW5jZXMgdG8gc2VuZCB0aGUgbWVzc2FnZSB0byAoc2luZ2xlIHZhbHVlIG9yIGFycmF5KVxuICAgIC8vICAgLSBtZXRob2Q6IHRoZSBtZXRob2Qgd2l0aCB0aGlzIG5hbWUsIHNwZWNpZmllZCB3aXRoIGRvdC1ub3RhdGlvbiwgd2lsbCBiZSBpbnZva2VkIGluIHRoZSB3b3JrZXJcbiAgICAvLyAgIC0gbWVzc2FnZTogd2lsbCBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZCBjYWxsXG4gICAgLy8gUmV0dXJuczpcbiAgICAvLyAgIC0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgaWYgdGhlIHdvcmtlciBtZXRob2QgcmV0dXJucyBhIHZhbHVlIChjb3VsZCBiZSBpbW1lZGlhdGVseSwgb3IgYXN5bmMpXG4gICAgLy9cbiAgICBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAod29ya2VyLCBtZXRob2QsIC4uLm1lc3NhZ2UpIHtcbiAgICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSB3b3JrZXIgc3BlY2lmaWVkLCBwb3N0IHRvIG11bHRpcGxlXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHdvcmtlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgICB3b3JrZXIubWFwKHcgPT4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHcsIG1ldGhvZCwgLi4ubWVzc2FnZSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhY2sgc3RhdGUgb2YgdGhpcyBtZXNzYWdlXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbWVzc2FnZXNbbWVzc2FnZV9pZF0gPSB7IG1ldGhvZCwgbWVzc2FnZSwgcmVzb2x2ZSwgcmVqZWN0IH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnbWFpbl9zZW5kJywgICAgICAvLyBtYXJrIG1lc3NhZ2UgYXMgbWV0aG9kIGludm9jYXRpb24gZnJvbSBtYWluIHRocmVhZFxuICAgICAgICAgICAgbWVzc2FnZV9pZCwgICAgICAgICAgICAgLy8gdW5pcXVlIGlkIGZvciB0aGlzIG1lc3NhZ2UsIGZvciBsaWZlIG9mIHByb2dyYW1cbiAgICAgICAgICAgIG1ldGhvZCwgICAgICAgICAgICAgICAgIC8vIHdpbGwgZGlzcGF0Y2ggdG8gYSBmdW5jdGlvbiBvZiB0aGlzIG5hbWUgd2l0aGluIHRoZSB3b3JrZXJcbiAgICAgICAgICAgIG1lc3NhZ2UgICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UgcGF5bG9hZFxuICAgICAgICB9KTtcblxuICAgICAgICBtZXNzYWdlX2lkKys7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICAvLyBBZGQgYSB3b3JrZXIgdG8gY29tbXVuaWNhdGUgd2l0aCAtIGVhY2ggd29ya2VyIG11c3QgYmUgcmVnaXN0ZXJlZCBmcm9tIHRoZSBtYWluIHRocmVhZFxuICAgIHZhciB3b3JrZXJfaWQgPSAwO1xuICAgIHZhciB3b3JrZXJzID0gbmV3IE1hcCgpO1xuXG4gICAgV29ya2VyQnJva2VyLmFkZFdvcmtlciA9IGZ1bmN0aW9uICh3b3JrZXIpIHtcblxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIGFsbCByZWdpc3RlcmVkIHdvcmtlcnNcbiAgICAgICAgd29ya2Vycy5zZXQod29ya2VyLCB3b3JrZXJfaWQrKyk7XG5cbiAgICAgICAgLy8gTGlzdGVuIGZvciBtZXNzYWdlcyBjb21pbmcgYmFjayBmcm9tIHRoZSB3b3JrZXIsIGFuZCBmdWxmaWxsIHRoYXQgbWVzc2FnZSdzIHByb21pc2VcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhLnR5cGUgIT09ICd3b3JrZXJfcmVwbHknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQYXNzIHRoZSByZXN1bHQgdG8gdGhlIHByb21pc2VcbiAgICAgICAgICAgIHZhciBpZCA9IGV2ZW50LmRhdGEubWVzc2FnZV9pZDtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlc1tpZF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1tpZF0ucmVqZWN0KGV2ZW50LmRhdGEuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNbaWRdLnJlc29sdmUoZXZlbnQuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1lc3NhZ2VzW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTGlzdGVuIGZvciBtZXNzYWdlcyBpbml0aWF0aW5nIGEgY2FsbCBmcm9tIHRoZSB3b3JrZXIsIGRpc3BhdGNoIHRoZW0sXG4gICAgICAgIC8vIGFuZCBzZW5kIGFueSByZXR1cm4gdmFsdWUgYmFjayB0byB0aGUgd29ya2VyXG4gICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvLyBVbmlxdWUgaWQgZm9yIHRoaXMgbWVzc2FnZSAmIHJldHVybiBjYWxsIHRvIG1haW4gdGhyZWFkXG4gICAgICAgICAgICB2YXIgaWQgPSBldmVudC5kYXRhLm1lc3NhZ2VfaWQ7XG4gICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS50eXBlICE9PSAnd29ya2VyX3NlbmQnIHx8IGlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGwgdGhlIHJlcXVlc3RlZCBtZXRob2QgYW5kIHNhdmUgdGhlIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgLy8gdmFyIHRhcmdldCA9IHRhcmdldHNbZXZlbnQuZGF0YS50YXJnZXRdO1xuICAgICAgICAgICAgdmFyIFttZXRob2RfbmFtZSwgdGFyZ2V0XSA9IGZpbmRUYXJnZXQoZXZlbnQuZGF0YS5tZXRob2QpO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgV29ya2VyIGJyb2tlciBjb3VsZCBub3QgZGlzcGF0Y2ggbWVzc2FnZSB0eXBlICR7ZXZlbnQuZGF0YS5tZXRob2R9IG9uIHRhcmdldCAke2V2ZW50LmRhdGEudGFyZ2V0fSBiZWNhdXNlIG5vIG9iamVjdCB3aXRoIHRoYXQgbmFtZSBpcyByZWdpc3RlcmVkIG9uIG1haW4gdGhyZWFkYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtZXRob2QgPSAodHlwZW9mIHRhcmdldFttZXRob2RfbmFtZV0gPT09ICdmdW5jdGlvbicpICYmIHRhcmdldFttZXRob2RfbmFtZV07XG4gICAgICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBXb3JrZXIgYnJva2VyIGNvdWxkIG5vdCBkaXNwYXRjaCBtZXNzYWdlIHR5cGUgJHtldmVudC5kYXRhLm1ldGhvZH0gb24gdGFyZ2V0ICR7ZXZlbnQuZGF0YS50YXJnZXR9IGJlY2F1c2Ugb2JqZWN0IGhhcyBubyBtZXRob2Qgd2l0aCB0aGF0IG5hbWVgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZXJyb3I7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseSh0YXJnZXQsIGV2ZW50LmRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3duIGVycm9ycyB3aWxsIGJlIHBhc3NlZCBiYWNrIChpbiBzdHJpbmcgZm9ybSkgdG8gd29ya2VyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZW5kIHJldHVybiB2YWx1ZSB0byB3b3JrZXJcbiAgICAgICAgICAgIGxldCB0cmFuc2ZlcmFibGVzO1xuICAgICAgICAgICAgLy8gQXN5bmMgcmVzdWx0XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2ZlcmFibGVzID0gZmluZFRyYW5zZmVyYWJsZXModmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbWFpbl9yZXBseScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMubWFwKHQgPT4gdC5vYmplY3QpKTtcblxuICAgICAgICAgICAgICAgICAgICBmcmVlVHJhbnNmZXJhYmxlcyh0cmFuc2ZlcmFibGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZmVyYWJsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMubG9nKCd0cmFjZScsIGAnJHttZXRob2RfbmFtZX0nIHRyYW5zZmVycmVkICR7dHJhbnNmZXJhYmxlcy5sZW5ndGh9IG9iamVjdHMgdG8gd29ya2VyIHRocmVhZGApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtYWluX3JlcGx5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VfaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYCR7ZXJyb3IubWVzc2FnZX06ICR7ZXJyb3Iuc3RhY2t9YCA6IGVycm9yKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEltbWVkaWF0ZSByZXN1bHRcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMgPSBmaW5kVHJhbnNmZXJhYmxlcyhyZXN1bHQpO1xuXG4gICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ21haW5fcmVwbHknLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBgJHtlcnJvci5tZXNzYWdlfTogJHtlcnJvci5zdGFja31gIDogZXJyb3IpXG4gICAgICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcy5tYXAodCA9PiB0Lm9iamVjdCkpO1xuXG4gICAgICAgICAgICAgICAgZnJlZVRyYW5zZmVyYWJsZXModHJhbnNmZXJhYmxlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZmVyYWJsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBVdGlscy5sb2coJ3RyYWNlJywgYCcke21ldGhvZF9uYW1lfScgdHJhbnNmZXJyZWQgJHt0cmFuc2ZlcmFibGVzLmxlbmd0aH0gb2JqZWN0cyB0byB3b3JrZXIgdGhyZWFkYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH07XG5cbiAgICAvLyBFeHBvc2UgZm9yIGRlYnVnZ2luZ1xuICAgIFdvcmtlckJyb2tlci5nZXRNZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgIH07XG5cbiAgICBXb3JrZXJCcm9rZXIuZ2V0TWVzc2FnZUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZV9pZDtcbiAgICB9O1xuXG59XG5cbi8vIFdvcmtlciB0aHJlYWRzOlxuLy8gLSBSZWNlaXZlIG1lc3NhZ2VzIGZyb20gbWFpbiB0aHJlYWQsIGFuZCBvcHRpb25hbGx5IHNlbmQgYW4gYXN5bmMgcmVzcG9uc2UgYmFjayBhcyBhIHByb21pc2Vcbi8vIC0gU2VuZCBtZXNzYWdlcyB0byBtYWluIHRocmVhZCwgYW5kIG9wdGlvbmFsbHkgcmVjZWl2ZSBhbiBhc3luYyByZXNwb25zZSBhcyBhIHByb21pc2VcbmZ1bmN0aW9uIHNldHVwV29ya2VyVGhyZWFkICgpIHtcblxuICAgIC8vIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBtYWluIHRocmVhZCwgYW5kIG9wdGlvbmFsbHkgZ2V0IGFuIGFzeW5jIHJlc3BvbnNlIGFzIGEgcHJvbWlzZVxuICAgIC8vIEFyZ3VtZW50czpcbiAgICAvLyAgIC0gbWV0aG9kOiB0aGUgbWV0aG9kIHdpdGggdGhpcyBuYW1lLCBzcGVjaWZpZWQgd2l0aCBkb3Qtbm90YXRpb24sIHdpbGwgYmUgaW52b2tlZCBvbiB0aGUgbWFpbiB0aHJlYWRcbiAgICAvLyAgIC0gbWVzc2FnZTogd2lsbCBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZCBjYWxsXG4gICAgLy8gUmV0dXJuczpcbiAgICAvLyAgIC0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgaWYgdGhlIG1haW4gdGhyZWFkIG1ldGhvZCByZXR1cm5zIGEgdmFsdWUgKGNvdWxkIGJlIGltbWVkaWF0ZWx5LCBvciBhc3luYylcbiAgICAvL1xuICAgIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uIChtZXRob2QsIC4uLm1lc3NhZ2UpIHtcbiAgICAgICAgLy8gVHJhY2sgc3RhdGUgb2YgdGhpcyBtZXNzYWdlXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbWVzc2FnZXNbbWVzc2FnZV9pZF0gPSB7IG1ldGhvZCwgbWVzc2FnZSwgcmVzb2x2ZSwgcmVqZWN0IH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ3dvcmtlcl9zZW5kJywgICAgLy8gbWFyayBtZXNzYWdlIGFzIG1ldGhvZCBpbnZvY2F0aW9uIGZyb20gd29ya2VyXG4gICAgICAgICAgICBtZXNzYWdlX2lkLCAgICAgICAgICAgICAvLyB1bmlxdWUgaWQgZm9yIHRoaXMgbWVzc2FnZSwgZm9yIGxpZmUgb2YgcHJvZ3JhbVxuICAgICAgICAgICAgbWV0aG9kLCAgICAgICAgICAgICAgICAgLy8gd2lsbCBkaXNwYXRjaCB0byBhIG1ldGhvZCBvZiB0aGlzIG5hbWUgb24gdGhlIG1haW4gdGhyZWFkXG4gICAgICAgICAgICBtZXNzYWdlICAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIHBheWxvYWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWVzc2FnZV9pZCsrO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLy8gTGlzdGVuIGZvciBtZXNzYWdlcyBjb21pbmcgYmFjayBmcm9tIHRoZSBtYWluIHRocmVhZCwgYW5kIGZ1bGZpbGwgdGhhdCBtZXNzYWdlJ3MgcHJvbWlzZVxuICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YS50eXBlICE9PSAnbWFpbl9yZXBseScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhc3MgdGhlIHJlc3VsdCB0byB0aGUgcHJvbWlzZVxuICAgICAgICB2YXIgaWQgPSBldmVudC5kYXRhLm1lc3NhZ2VfaWQ7XG4gICAgICAgIGlmIChtZXNzYWdlc1tpZF0pIHtcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXNbaWRdLnJlamVjdChldmVudC5kYXRhLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzW2lkXS5yZXNvbHZlKGV2ZW50LmRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgbWVzc2FnZXNbaWRdO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZWNlaXZlIG1lc3NhZ2VzIGZyb20gbWFpbiB0aHJlYWQsIGRpc3BhdGNoIHRoZW0sIGFuZCBzZW5kIGJhY2sgYSByZXBseVxuICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgICAvLyBVbmlxdWUgaWQgZm9yIHRoaXMgbWVzc2FnZSAmIHJldHVybiBjYWxsIHRvIG1haW4gdGhyZWFkXG4gICAgICAgIHZhciBpZCA9IGV2ZW50LmRhdGEubWVzc2FnZV9pZDtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSAhPT0gJ21haW5fc2VuZCcgfHwgaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgcmVxdWVzdGVkIHdvcmtlciBtZXRob2QgYW5kIHNhdmUgdGhlIHJldHVybiB2YWx1ZVxuICAgICAgICB2YXIgW21ldGhvZF9uYW1lLCB0YXJnZXRdID0gZmluZFRhcmdldChldmVudC5kYXRhLm1ldGhvZCk7XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgV29ya2VyIGJyb2tlciBjb3VsZCBub3QgZGlzcGF0Y2ggbWVzc2FnZSB0eXBlICR7ZXZlbnQuZGF0YS5tZXRob2R9IG9uIHRhcmdldCAke2V2ZW50LmRhdGEudGFyZ2V0fSBiZWNhdXNlIG5vIG9iamVjdCB3aXRoIHRoYXQgbmFtZSBpcyByZWdpc3RlcmVkIG9uIG1haW4gdGhyZWFkYCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWV0aG9kID0gKHR5cGVvZiB0YXJnZXRbbWV0aG9kX25hbWVdID09PSAnZnVuY3Rpb24nKSAmJiB0YXJnZXRbbWV0aG9kX25hbWVdO1xuXG4gICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgV29ya2VyIGJyb2tlciBjb3VsZCBub3QgZGlzcGF0Y2ggbWVzc2FnZSB0eXBlICR7ZXZlbnQuZGF0YS5tZXRob2R9IGJlY2F1c2Ugd29ya2VyIGhhcyBubyBtZXRob2Qgd2l0aCB0aGF0IG5hbWVgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQsIGVycm9yO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRhcmdldCwgZXZlbnQuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAvLyBUaHJvd24gZXJyb3JzIHdpbGwgYmUgcGFzc2VkIGJhY2sgKGluIHN0cmluZyBmb3JtKSB0byBtYWluIHRocmVhZFxuICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VuZCByZXR1cm4gdmFsdWUgdG8gbWFpbiB0aHJlYWRcbiAgICAgICAgbGV0IHRyYW5zZmVyYWJsZXM7XG4gICAgICAgIC8vIEFzeW5jIHJlc3VsdFxuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmVzdWx0LnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmZXJhYmxlcyA9IGZpbmRUcmFuc2ZlcmFibGVzKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd29ya2VyX3JlcGx5JyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcy5tYXAodCA9PiB0Lm9iamVjdCkpO1xuXG4gICAgICAgICAgICAgICAgZnJlZVRyYW5zZmVyYWJsZXModHJhbnNmZXJhYmxlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZmVyYWJsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBVdGlscy5sb2coJ3RyYWNlJywgYCcke21ldGhvZF9uYW1lfScgdHJhbnNmZXJyZWQgJHt0cmFuc2ZlcmFibGVzLmxlbmd0aH0gb2JqZWN0cyB0byBtYWluIHRocmVhZGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd29ya2VyX3JlcGx5JyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGAke2Vycm9yLm1lc3NhZ2V9OiAke2Vycm9yLnN0YWNrfWAgOiBlcnJvcilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEltbWVkaWF0ZSByZXN1bHRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cmFuc2ZlcmFibGVzID0gZmluZFRyYW5zZmVyYWJsZXMocmVzdWx0KTtcblxuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3dvcmtlcl9yZXBseScsXG4gICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogaWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgIGVycm9yOiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGAke2Vycm9yLm1lc3NhZ2V9OiAke2Vycm9yLnN0YWNrfWAgOiBlcnJvcilcbiAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMubWFwKHQgPT4gdC5vYmplY3QpKTtcblxuICAgICAgICAgICAgZnJlZVRyYW5zZmVyYWJsZXModHJhbnNmZXJhYmxlcyk7XG4gICAgICAgICAgICBpZiAodHJhbnNmZXJhYmxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgVXRpbHMubG9nKCd0cmFjZScsIGAnJHttZXRob2RfbmFtZX0nIHRyYW5zZmVycmVkICR7dHJhbnNmZXJhYmxlcy5sZW5ndGh9IG9iamVjdHMgdG8gbWFpbiB0aHJlYWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG59XG5cbi8vIEJ1aWxkIGEgbGlzdCBvZiB0cmFuc2ZlcmFibGUgb2JqZWN0cyBmcm9tIGEgc291cmNlIG9iamVjdFxuLy8gUmV0dXJucyBhIGxpc3Qgb2YgaW5mbyBhYm91dCBlYWNoIHRyYW5zZmVyYWJsZTpcbi8vICAgLSBvYmplY3Q6IHRoZSBhY3R1YWwgdHJhbnNmZXJhYmxlIG9iamVjdFxuLy8gICAtIHBhcmVudDogdGhlIHBhcmVudCBvYmplY3QgdGhhdCB0aGUgdHJhbnNmZXJhYmxlIGlzIGEgcHJvcGVydHkgb2YgKGlmIGFueSlcbi8vICAgLSBwcm9wZXJ0eTogdGhlIHByb3BlcnR5IG5hbWUgb2YgdGhlIHRyYW5zZmVyYWJsZSBvbiB0aGUgcGFyZW50IG9iamVjdCAoaWYgYW55KVxuLy8gVE9ETzogYWRkIG9wdGlvbiBpbiBjYXNlIHlvdSBET04nVCB3YW50IHRvIHRyYW5zZmVyIG9iamVjdHNcbmZ1bmN0aW9uIGZpbmRUcmFuc2ZlcmFibGVzKHNvdXJjZSwgcGFyZW50ID0gbnVsbCwgcHJvcGVydHkgPSBudWxsLCBsaXN0ID0gW10pIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICAvLyBDaGVjayBlYWNoIGFycmF5IGVsZW1lbnRcbiAgICAgICAgc291cmNlLmZvckVhY2goKHgsIGkpID0+IGZpbmRUcmFuc2ZlcmFibGVzKHgsIHNvdXJjZSwgaSwgbGlzdCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBJcyB0aGUgb2JqZWN0IGEgdHJhbnNmZXJhYmxlIGFycmF5IGJ1ZmZlcj9cbiAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goeyBvYmplY3Q6IHNvdXJjZSwgcGFyZW50LCBwcm9wZXJ0eSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPciBsb29rcyBsaWtlIGEgdHlwZWQgYXJyYXkgKGhhcyBhbiBhcnJheSBidWZmZXIgcHJvcGVydHkpP1xuICAgICAgICBlbHNlIGlmIChzb3VyY2UuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIGxpc3QucHVzaCh7IG9iamVjdDogc291cmNlLmJ1ZmZlciwgcGFyZW50LCBwcm9wZXJ0eSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UgY2hlY2sgZWFjaCBwcm9wZXJ0eVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgZmluZFRyYW5zZmVyYWJsZXMoc291cmNlW3Byb3BdLCBzb3VyY2UsIHByb3AsIGxpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufVxuXG4vLyBSZW1vdmUgbmV1dGVyZWQgdHJhbnNmZXJhYmxlcyBmcm9tIHBhcmVudCBvYmplY3RzLCBhcyB0aGV5IHNob3VsZCBubyBsb25nZXIgYmUgYWNjZXNzZWQgYWZ0ZXIgdHJhbnNmZXJcbmZ1bmN0aW9uIGZyZWVUcmFuc2ZlcmFibGVzKHRyYW5zZmVyYWJsZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHJhbnNmZXJhYmxlcykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cmFuc2ZlcmFibGVzLmZpbHRlcih0ID0+IHQucGFyZW50ICYmIHQucHJvcGVydHkpLmZvckVhY2godCA9PiBkZWxldGUgdC5wYXJlbnRbdC5wcm9wZXJ0eV0pO1xufVxuXG4vLyBTZXR1cCB0aGlzIHRocmVhZCBhcyBhcHByb3ByaWF0ZVxuaWYgKFV0aWxzLmlzTWFpblRocmVhZCkge1xuICAgIHNldHVwTWFpblRocmVhZCgpO1xufVxuXG5pZiAoVXRpbHMuaXNXb3JrZXJUaHJlYWQpIHtcbiAgICBzZXR1cFdvcmtlclRocmVhZCgpO1xufVxuIiwiLyoqKiBWZWN0b3IgZnVuY3Rpb25zIC0gdmVjdG9ycyBwcm92aWRlZCBhcyBbeCwgeSwgel0gYXJyYXlzICoqKi9cblxudmFyIFZlY3RvcjtcbmV4cG9ydCBkZWZhdWx0IFZlY3RvciA9IHt9O1xuXG5WZWN0b3Iuc2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgViA9IFtdO1xuICAgIHZhciBsaW0gPSB2Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbTsgaSsrKSB7XG4gICAgICAgIFZbaV0gPSB2W2ldO1xuICAgIH1cbiAgICByZXR1cm4gVjtcbn07XG5cblZlY3Rvci5uZWcgPSBmdW5jdGlvbiAodikge1xuICAgIHZhciBWID0gW107XG4gICAgdmFyIGxpbSA9IHYubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGltOyBpKyspIHtcbiAgICAgICAgVltpXSA9IHZbaV0gKiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIFY7XG59O1xuXG4vLyBBZGRpdGlvbiBvZiB0d28gdmVjdG9yc1xuVmVjdG9yLmFkZCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICB2YXIgdiA9IFtdO1xuICAgIHZhciBsaW0gPSBNYXRoLm1pbih2MS5sZW5ndGgsdjIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbTsgaSsrKSB7XG4gICAgICAgIHZbaV0gPSB2MVtpXSArIHYyW2ldO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn07XG5cbi8vIFN1YnN0cmFjdGlvbiBvZiB0d28gdmVjdG9yc1xuVmVjdG9yLnN1YiA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICB2YXIgdiA9IFtdO1xuICAgIHZhciBsaW0gPSBNYXRoLm1pbih2MS5sZW5ndGgsdjIubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGltOyBpKyspIHtcbiAgICAgICAgdltpXSA9IHYxW2ldIC0gdjJbaV07XG4gICAgfVxuICAgIHJldHVybiB2O1xufTtcblxuVmVjdG9yLnNpZ25lZF9hcmVhID0gZnVuY3Rpb24gKHYxLCB2MiwgdjMpIHtcbiAgICByZXR1cm4gKHYyWzBdLXYxWzBdKSoodjNbMV0tdjFbMV0pIC0gKHYzWzBdLXYxWzBdKSoodjJbMV0tdjFbMV0pO1xufTtcblxuLy8gTXVsdGlwbGljYXRpb24gb2YgdHdvIHZlY3RvcnNcblZlY3Rvci5tdWx0ID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgIHZhciB2ID0gW10sXG4gICAgICAgIGxlbiA9IHYxLmxlbmd0aCxcbiAgICAgICAgaTtcblxuICAgIGlmICh0eXBlb2YgdjIgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIE11bGl0cGx5IGJ5IHNjYWxhclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZbaV0gPSB2MVtpXSAqIHYyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBNdWx0aXBseSB0d28gdmVjdG9yc1xuICAgICAgICBsZW4gPSBNYXRoLm1pbih2MS5sZW5ndGgsdjIubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2W2ldID0gdjFbaV0gKiB2MltpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbn07XG5cbi8vIERpdmlzaW9uIG9mIHR3byB2ZWN0b3JzXG5WZWN0b3IuZGl2ID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgIHZhciB2ID0gW10sXG4gICAgICAgIGk7XG4gICAgaWYodHlwZW9mIHYyID09PSAnbnVtYmVyJyl7XG4gICAgICAgIC8vIERpdmlkZSBieSBzY2FsYXJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHYxLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZbaV0gPSB2MVtpXSAvIHYyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGl2aWRlIHRvIHZlY3RvcnNcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKHYxLmxlbmd0aCx2Mi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZbaV0gPSB2MVtpXSAvIHYyW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xufTtcblxuLy8gR2V0IDJEIHBlcnBlbmRpY3VsYXJcblZlY3Rvci5wZXJwID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgIHJldHVybiBbIHYyWzFdIC0gdjFbMV0sXG4gICAgICAgICAgICAgdjFbMF0gLSB2MlswXSBdO1xufTtcblxuLy8gR2V0IDJEIHZlY3RvciByb3RhdGVkXG5WZWN0b3Iucm90ID0gZnVuY3Rpb24gKHYsIGEpIHtcbiAgICB2YXIgdnIgPSBWZWN0b3IubGVuZ3RoKHYpO1xuICAgIHZhciB2YSA9IFZlY3Rvci5hbmdsZSh2KTtcbiAgICByZXR1cm4gW3ZyICogTWF0aC5jb3ModmErYSksXG4gICAgICAgICAgICB2ciAqIE1hdGguc2luKHZhK2EpXTtcbn07XG5cbi8vIEdldCAyRCBoZWFkaW5nIGFuZ2xlXG5WZWN0b3IuYW5nbGUgPSBmdW5jdGlvbiAoW3gsIHldKSB7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeSx4KTtcbn07XG5cbi8vIENvbXBhcmUgdHdvIHBvaW50c1xuVmVjdG9yLmlzRXF1YWwgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgdmFyIGxlbiA9IHYxLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh2MVtpXSAhPT0gdjJbaV0pe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLy8gVmVjdG9yIGxlbmd0aCBzcXVhcmVkXG5WZWN0b3IubGVuZ3RoU3EgPSBmdW5jdGlvbiAodilcbntcbiAgICBpZiAodi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICh2WzBdKnZbMF0gKyB2WzFdKnZbMV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICh2WzBdKnZbMF0gKyB2WzFdKnZbMV0gKyB2WzJdKnZbMl0pO1xuICAgIH1cbn07XG5cbi8vIFZlY3RvciBsZW5ndGhcblZlY3Rvci5sZW5ndGggPSBmdW5jdGlvbiAodilcbntcbiAgICByZXR1cm4gTWF0aC5zcXJ0KFZlY3Rvci5sZW5ndGhTcSh2KSk7XG59O1xuXG4vLyBOb3JtYWxpemUgYSB2ZWN0b3JcblZlY3Rvci5ub3JtYWxpemUgPSBmdW5jdGlvbiAodilcbntcbiAgICB2YXIgZDtcbiAgICBpZiAodi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgZCA9IHZbMF0qdlswXSArIHZbMV0qdlsxXTtcbiAgICAgICAgZCA9IE1hdGguc3FydChkKTtcblxuICAgICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFt2WzBdIC8gZCwgdlsxXSAvIGRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZCA9IHZbMF0qdlswXSArIHZbMV0qdlsxXSArIHZbMl0qdlsyXTtcbiAgICAgICAgZCA9IE1hdGguc3FydChkKTtcblxuICAgICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFt2WzBdIC8gZCwgdlsxXSAvIGQsIHZbMl0gLyBkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzAsIDAsIDBdO1xuICAgIH1cbn07XG5cbi8vIENyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcblZlY3Rvci5jcm9zcyAgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgKHYxWzFdICogdjJbMl0pIC0gKHYxWzJdICogdjJbMV0pLFxuICAgICAgICAodjFbMl0gKiB2MlswXSkgLSAodjFbMF0gKiB2MlsyXSksXG4gICAgICAgICh2MVswXSAqIHYyWzFdKSAtICh2MVsxXSAqIHYyWzBdKVxuICAgIF07XG59O1xuXG4vLyBEb3QgcHJvZHVjdCBvZiB0d28gdmVjdG9yc1xuVmVjdG9yLmRvdCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIGxpbSA9IE1hdGgubWluKHYxLmxlbmd0aCwgdjIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbTsgaSsrKSB7XG4gICAgICAgIG4gKz0gdjFbaV0gKiB2MltpXTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG59O1xuXG4vLyBGaW5kIHRoZSBpbnRlcnNlY3Rpb24gb2YgdHdvIGxpbmVzIHNwZWNpZmllZCBhcyBzZWdtZW50cyBmcm9tIHBvaW50cyAocDEsIHAyKSBhbmQgKHAzLCBwNClcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZS1saW5lX2ludGVyc2VjdGlvblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DcmFtZXInc19ydWxlXG5WZWN0b3IubGluZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChwMSwgcDIsIHAzLCBwNCwgcGFyYWxsZWxfdG9sZXJhbmNlKSB7XG4gICAgcGFyYWxsZWxfdG9sZXJhbmNlID0gcGFyYWxsZWxfdG9sZXJhbmNlIHx8IDAuMDE7XG5cbiAgICAvLyBhMSp4ICsgYjEqeSA9IGMxIGZvciBsaW5lICh4MSwgeTEpIHRvICh4MiwgeTIpXG4gICAgLy8gYTIqeCArIGIyKnkgPSBjMiBmb3IgbGluZSAoeDMsIHkzKSB0byAoeDQsIHk0KVxuICAgIHZhciBhMSA9IHAxWzFdIC0gcDJbMV07IC8vIHkxIC0geTJcbiAgICB2YXIgYjEgPSBwMVswXSAtIHAyWzBdOyAvLyB4MSAtIHgyXG4gICAgdmFyIGEyID0gcDNbMV0gLSBwNFsxXTsgLy8geTMgLSB5NFxuICAgIHZhciBiMiA9IHAzWzBdIC0gcDRbMF07IC8vIHgzIC0geDRcbiAgICB2YXIgYzEgPSAocDFbMF0gKiBwMlsxXSkgLSAocDFbMV0gKiBwMlswXSk7IC8vIHgxKnkyIC0geTEqeDJcbiAgICB2YXIgYzIgPSAocDNbMF0gKiBwNFsxXSkgLSAocDNbMV0gKiBwNFswXSk7IC8vIHgzKnk0IC0geTMqeDRcbiAgICB2YXIgZGVub20gPSAoYjEgKiBhMikgLSAoYTEgKiBiMik7XG5cbiAgICBpZiAoTWF0aC5hYnMoZGVub20pID4gcGFyYWxsZWxfdG9sZXJhbmNlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAoKGMxICogYjIpIC0gKGIxICogYzIpKSAvIGRlbm9tLFxuICAgICAgICAgICAgKChjMSAqIGEyKSAtIChhMSAqIGMyKSkgLyBkZW5vbVxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDsgLy8gcmV0dXJuIG51bGwgaWYgbGluZXMgYXJlIChjbG9zZSB0bykgcGFyYWxsZWxcbn07XG4iXX0=
